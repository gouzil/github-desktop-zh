removed in remote
  base   100644 25e9d0f1932af30296de26c5fb0013e09a99c19c atom/app/atom_content_client.cc
  our    100644 f17ae3137032f0b0e26eb735d37cfb3daaeebcfc atom/app/atom_content_client.cc
@@ -1,244 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_content_client.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/common/content_constants.h"
-#include "content/public/common/pepper_plugin_info.h"
-#include "content/public/common/user_agent.h"
-#include "media/media_features.h"
-#include "ppapi/shared_impl/ppapi_permissions.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "url/url_constants.h"
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-#include "chrome/common/widevine_cdm_constants.h"
-#endif
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/common/atom_constants.h"
-#include "pdf/pdf.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-namespace atom {
-
-namespace {
-
-content::PepperPluginInfo CreatePepperFlashInfo(const base::FilePath& path,
-                                                const std::string& version) {
-  content::PepperPluginInfo plugin;
-
-  plugin.is_out_of_process = true;
-  plugin.name = content::kFlashPluginName;
-  plugin.path = path;
-  plugin.permissions = ppapi::PERMISSION_ALL_BITS;
-
-  std::vector<std::string> flash_version_numbers = base::SplitString(
-      version, ".", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-  if (flash_version_numbers.empty())
-    flash_version_numbers.push_back("11");
-  // |SplitString()| puts in an empty string given an empty string. :(
-  else if (flash_version_numbers[0].empty())
-    flash_version_numbers[0] = "11";
-  if (flash_version_numbers.size() < 2)
-    flash_version_numbers.push_back("2");
-  if (flash_version_numbers.size() < 3)
-    flash_version_numbers.push_back("999");
-  if (flash_version_numbers.size() < 4)
-    flash_version_numbers.push_back("999");
-  // E.g., "Shockwave Flash 10.2 r154":
-  plugin.description = plugin.name + " " + flash_version_numbers[0] + "." +
-                       flash_version_numbers[1] + " r" +
-                       flash_version_numbers[2];
-  plugin.version = base::JoinString(flash_version_numbers, ".");
-  content::WebPluginMimeType swf_mime_type(content::kFlashPluginSwfMimeType,
-                                           content::kFlashPluginSwfExtension,
-                                           content::kFlashPluginSwfDescription);
-  plugin.mime_types.push_back(swf_mime_type);
-  content::WebPluginMimeType spl_mime_type(content::kFlashPluginSplMimeType,
-                                           content::kFlashPluginSplExtension,
-                                           content::kFlashPluginSplDescription);
-  plugin.mime_types.push_back(spl_mime_type);
-
-  return plugin;
-}
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-content::PepperPluginInfo CreateWidevineCdmInfo(const base::FilePath& path,
-                                                const std::string& version) {
-  content::PepperPluginInfo widevine_cdm;
-  widevine_cdm.is_out_of_process = true;
-  widevine_cdm.path = path;
-  widevine_cdm.name = kWidevineCdmDisplayName;
-  widevine_cdm.description =
-      kWidevineCdmDescription + std::string(" (version: ") + version + ")";
-  widevine_cdm.version = version;
-  content::WebPluginMimeType widevine_cdm_mime_type(
-      kWidevineCdmPluginMimeType, kWidevineCdmPluginExtension,
-      kWidevineCdmPluginMimeTypeDescription);
-
-  widevine_cdm.mime_types.push_back(widevine_cdm_mime_type);
-  widevine_cdm.permissions = kWidevineCdmPluginPermissions;
-
-  return widevine_cdm;
-}
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-
-#if defined(ENABLE_PDF_VIEWER)
-void ComputeBuiltInPlugins(std::vector<content::PepperPluginInfo>* plugins) {
-  content::PepperPluginInfo pdf_info;
-  pdf_info.is_internal = true;
-  pdf_info.is_out_of_process = true;
-  pdf_info.name = "Chromium PDF Viewer";
-  pdf_info.description = "Portable Document Format";
-  pdf_info.path = base::FilePath::FromUTF8Unsafe(kPdfPluginPath);
-  content::WebPluginMimeType pdf_mime_type(kPdfPluginMimeType, "pdf",
-                                           "Portable Document Format");
-  pdf_info.mime_types.push_back(pdf_mime_type);
-  pdf_info.internal_entry_points.get_interface = chrome_pdf::PPP_GetInterface;
-  pdf_info.internal_entry_points.initialize_module =
-      chrome_pdf::PPP_InitializeModule;
-  pdf_info.internal_entry_points.shutdown_module =
-      chrome_pdf::PPP_ShutdownModule;
-  pdf_info.permissions = ppapi::PERMISSION_PRIVATE | ppapi::PERMISSION_DEV;
-  plugins->push_back(pdf_info);
-}
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-void ConvertStringWithSeparatorToVector(std::vector<std::string>* vec,
-                                        const char* separator,
-                                        const char* cmd_switch) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  auto string_with_separator = command_line->GetSwitchValueASCII(cmd_switch);
-  if (!string_with_separator.empty())
-    *vec = base::SplitString(string_with_separator, separator,
-                             base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-}
-
-}  // namespace
-
-void AddPepperFlashFromCommandLine(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath flash_path =
-      command_line->GetSwitchValuePath(switches::kPpapiFlashPath);
-  if (flash_path.empty())
-    return;
-
-  auto flash_version =
-      command_line->GetSwitchValueASCII(switches::kPpapiFlashVersion);
-
-  plugins->push_back(CreatePepperFlashInfo(flash_path, flash_version));
-}
-
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-void AddWidevineCdmFromCommandLine(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath widevine_cdm_path =
-      command_line->GetSwitchValuePath(switches::kWidevineCdmPath);
-  if (widevine_cdm_path.empty())
-    return;
-
-  if (!base::PathExists(widevine_cdm_path))
-    return;
-
-  auto widevine_cdm_version =
-      command_line->GetSwitchValueASCII(switches::kWidevineCdmVersion);
-  if (widevine_cdm_version.empty())
-    return;
-
-  plugins->push_back(
-      CreateWidevineCdmInfo(widevine_cdm_path, widevine_cdm_version));
-}
-#endif  //  defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-
-AtomContentClient::AtomContentClient() {}
-
-AtomContentClient::~AtomContentClient() {}
-
-std::string AtomContentClient::GetProduct() const {
-  return "Chrome/" CHROME_VERSION_STRING;
-}
-
-std::string AtomContentClient::GetUserAgent() const {
-  return content::BuildUserAgentFromProduct("Chrome/" CHROME_VERSION_STRING
-                                            " " ATOM_PRODUCT_NAME
-                                            "/" ATOM_VERSION_STRING);
-}
-
-base::string16 AtomContentClient::GetLocalizedString(int message_id) const {
-  return l10n_util::GetStringUTF16(message_id);
-}
-
-void AtomContentClient::AddAdditionalSchemes(Schemes* schemes) {
-  schemes->standard_schemes.push_back("chrome-extension");
-
-  std::vector<std::string> splited;
-  ConvertStringWithSeparatorToVector(&splited, ",",
-                                     switches::kRegisterServiceWorkerSchemes);
-  for (const std::string& scheme : splited)
-    schemes->service_worker_schemes.push_back(scheme);
-  schemes->service_worker_schemes.push_back(url::kFileScheme);
-
-  ConvertStringWithSeparatorToVector(&splited, ",", switches::kSecureSchemes);
-  for (const std::string& scheme : splited)
-    schemes->secure_schemes.push_back(scheme);
-}
-
-void AtomContentClient::AddPepperPlugins(
-    std::vector<content::PepperPluginInfo>* plugins) {
-  AddPepperFlashFromCommandLine(plugins);
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-  AddWidevineCdmFromCommandLine(plugins);
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-#if defined(ENABLE_PDF_VIEWER)
-  ComputeBuiltInPlugins(plugins);
-#endif  // defined(ENABLE_PDF_VIEWER)
-}
-
-void AtomContentClient::AddContentDecryptionModules(
-    std::vector<content::CdmInfo>* cdms,
-    std::vector<media::CdmHostFilePath>* cdm_host_file_paths) {
-#if defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-  auto command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath widevine_cdm_path =
-      command_line->GetSwitchValuePath(switches::kWidevineCdmPath);
-  if (widevine_cdm_path.empty())
-    return;
-
-  if (!base::PathExists(widevine_cdm_path))
-    return;
-
-  auto widevine_cdm_version =
-      command_line->GetSwitchValueASCII(switches::kWidevineCdmVersion);
-  if (widevine_cdm_version.empty())
-    return;
-
-  std::vector<media::VideoCodec> supported_video_codecs;
-  supported_video_codecs.push_back(media::VideoCodec::kCodecVP8);
-  supported_video_codecs.push_back(media::VideoCodec::kCodecVP9);
-#if BUILDFLAG(USE_PROPRIETARY_CODECS)
-  supported_video_codecs.push_back(media::VideoCodec::kCodecH264);
-#endif  // BUILDFLAG(USE_PROPRIETARY_CODECS)
-  content::CdmRegistry::GetInstance()->RegisterCdm(
-      content::CdmInfo(kWidevineCdmDisplayName, kWidevineCdmGuid,
-                       base::Version(widevine_cdm_version), widevine_cdm_path,
-                       kWidevineCdmFileSystemId, supported_video_codecs, false,
-                       kWidevineKeySystem, false));
-#endif  // defined(WIDEVINE_CDM_AVAILABLE) && BUILDFLAG(ENABLE_LIBRARY_CDMS)
-}
-
-}  // namespace atom
removed in remote
  base   100644 33dbe19d990e6d3030d075f136e591c303b9432f atom/app/atom_content_client.h
  our    100644 b6ecc3407d0e967ba170be76968b4318b56f8450 atom/app/atom_content_client.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_CONTENT_CLIENT_H_
-#define ATOM_APP_ATOM_CONTENT_CLIENT_H_
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "brightray/common/content_client.h"
-
-namespace atom {
-
-class AtomContentClient : public brightray::ContentClient {
- public:
-  AtomContentClient();
-  ~AtomContentClient() override;
-
- protected:
-  // content::ContentClient:
-  std::string GetProduct() const override;
-  std::string GetUserAgent() const override;
-  base::string16 GetLocalizedString(int message_id) const override;
-  void AddAdditionalSchemes(Schemes* schemes) override;
-  void AddPepperPlugins(
-      std::vector<content::PepperPluginInfo>* plugins) override;
-  void AddContentDecryptionModules(
-      std::vector<content::CdmInfo>* cdms,
-      std::vector<media::CdmHostFilePath>* cdm_host_file_paths) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomContentClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_ATOM_CONTENT_CLIENT_H_
removed in remote
  base   100644 e1603fa5942f7b000c3385648530255032e775a2 atom/app/atom_library_main.h
  our    100644 2c7a27caa20a411558010c3c58bd78e7850c0737 atom/app/atom_library_main.h
@@ -1,22 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_LIBRARY_MAIN_H_
-#define ATOM_APP_ATOM_LIBRARY_MAIN_H_
-
-#include "build/build_config.h"
-
-#if defined(OS_MACOSX)
-extern "C" {
-__attribute__((visibility("default"))) int AtomMain(int argc, char* argv[]);
-
-#ifdef ENABLE_RUN_AS_NODE
-__attribute__((visibility("default"))) int AtomInitializeICUandStartNode(
-    int argc,
-    char* argv[]);
-#endif
-}
-#endif  // OS_MACOSX
-
-#endif  // ATOM_APP_ATOM_LIBRARY_MAIN_H_
removed in remote
  base   100644 7ee7522934689937f7be7b0f866134bf611c7d69 atom/app/atom_library_main.mm
  our    100644 57a519fcd0db28548ea75034cf92191161183385 atom/app/atom_library_main.mm
@@ -1,38 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_library_main.h"
-
-#include "atom/app/atom_main_delegate.h"
-#include "atom/app/node_main.h"
-#include "atom/common/atom_command_line.h"
-#include "base/at_exit.h"
-#include "base/i18n/icu_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/scoped_nsautorelease_pool.h"
-#include "brightray/common/mac/main_application_bundle.h"
-#include "content/public/app/content_main.h"
-
-int AtomMain(int argc, char* argv[]) {
-  atom::AtomMainDelegate delegate;
-  content::ContentMainParams params(&delegate);
-  params.argc = argc;
-  params.argv = const_cast<const char**>(argv);
-  atom::AtomCommandLine::Init(argc, argv);
-  return content::ContentMain(params);
-}
-
-#ifdef ENABLE_RUN_AS_NODE
-int AtomInitializeICUandStartNode(int argc, char* argv[]) {
-  base::AtExitManager atexit_manager;
-  base::mac::ScopedNSAutoreleasePool pool;
-  base::mac::SetOverrideFrameworkBundlePath(
-      brightray::MainApplicationBundlePath()
-          .Append("Contents")
-          .Append("Frameworks")
-          .Append(ATOM_PRODUCT_NAME " Framework.framework"));
-  base::i18n::InitializeICU();
-  return atom::NodeMain(argc, argv);
-}
-#endif
removed in remote
  base   100644 cbd0a85d57685e548b00a74f7133692cc92059e6 atom/app/atom_main.cc
  our    100644 fc77100d9acb58221c35f364c4db7866a44d347d atom/app/atom_main.cc
@@ -1,187 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main.h"
-
-#include <cstdlib>
-#include <vector>
-
-#if defined(OS_WIN)
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>  // ensures that ATL statics like `_AtlWinModule` are initialized (it's an issue in static debug build)
-#include <shellapi.h>
-#include <shellscalingapi.h>
-#include <tchar.h>
-
-#include "atom/app/atom_main_delegate.h"
-#include "atom/app/command_line_args.h"
-#include "atom/common/crash_reporter/win/crash_service_main.h"
-#include "base/environment.h"
-#include "base/process/launch.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/windows_version.h"
-#include "content/public/app/sandbox_helper_win.h"
-#include "sandbox/win/src/sandbox_types.h"
-#elif defined(OS_LINUX)                   // defined(OS_WIN)
-#include "atom/app/atom_main_delegate.h"  // NOLINT
-#include "content/public/app/content_main.h"
-#else  // defined(OS_LINUX)
-#include "atom/app/atom_library_main.h"
-#endif  // defined(OS_MACOSX)
-
-#include "atom/app/node_main.h"
-#include "atom/common/atom_command_line.h"
-#include "base/at_exit.h"
-#include "base/i18n/icu_util.h"
-
-namespace {
-
-#ifdef ENABLE_RUN_AS_NODE
-const char kRunAsNode[] = "ELECTRON_RUN_AS_NODE";
-#endif
-
-#if defined(ENABLE_RUN_AS_NODE) || defined(OS_WIN)
-bool IsEnvSet(const char* name) {
-#if defined(OS_WIN)
-  size_t required_size;
-  getenv_s(&required_size, nullptr, 0, name);
-  return required_size != 0;
-#else
-  char* indicator = getenv(name);
-  return indicator && indicator[0] != '\0';
-#endif
-}
-#endif
-
-}  // namespace
-
-#if defined(OS_WIN)
-int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE, wchar_t* cmd, int) {
-  struct Arguments {
-    int argc = 0;
-    wchar_t** argv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
-
-    ~Arguments() { LocalFree(argv); }
-  } arguments;
-
-  if (!arguments.argv)
-    return -1;
-
-#ifdef _DEBUG
-  // Don't display assert dialog boxes in CI test runs
-  static const char* kCI = "ELECTRON_CI";
-  bool is_ci = IsEnvSet(kCI);
-  if (!is_ci) {
-    for (int i = 0; i < arguments.argc; ++i) {
-      if (!_wcsicmp(arguments.argv[i], L"--ci")) {
-        is_ci = true;
-        _putenv_s(kCI, "1");  // set flag for child processes
-        break;
-      }
-    }
-  }
-  if (is_ci) {
-    _CrtSetReportMode(_CRT_ERROR, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ERROR, _CRTDBG_FILE_STDERR);
-
-    _CrtSetReportMode(_CRT_ASSERT, _CRTDBG_MODE_DEBUG | _CRTDBG_MODE_FILE);
-    _CrtSetReportFile(_CRT_ASSERT, _CRTDBG_FILE_STDERR);
-
-    _set_error_mode(_OUT_TO_STDERR);
-  }
-#endif
-
-#ifdef ENABLE_RUN_AS_NODE
-  bool run_as_node = IsEnvSet(kRunAsNode);
-#else
-  bool run_as_node = false;
-#endif
-
-  // Make sure the output is printed to console.
-  if (run_as_node || !IsEnvSet("ELECTRON_NO_ATTACH_CONSOLE"))
-    base::RouteStdioToConsole(false);
-
-#ifndef DEBUG
-  // Chromium has its own TLS subsystem which supports automatic destruction
-  // of thread-local data, and also depends on memory allocation routines
-  // provided by the CRT. The problem is that the auto-destruction mechanism
-  // uses a hidden feature of the OS loader which calls a callback on thread
-  // exit, but only after all loaded DLLs have been detached. Since the CRT is
-  // also a DLL, it happens that by the time Chromium's `OnThreadExit` function
-  // is called, the heap functions, though still in memory, no longer perform
-  // their duties, and when Chromium calls `free` on its buffer, it triggers
-  // an access violation error.
-  // We work around this problem by invoking Chromium's `OnThreadExit` in time
-  // from within the CRT's atexit facility, ensuring the heap functions are
-  // still active. The second invocation from the OS loader will be a no-op.
-  extern void NTAPI OnThreadExit(PVOID module, DWORD reason, PVOID reserved);
-  atexit([]() { OnThreadExit(nullptr, DLL_THREAD_DETACH, nullptr); });
-#endif
-
-#ifdef ENABLE_RUN_AS_NODE
-  if (run_as_node) {
-    std::vector<char*> argv(arguments.argc);
-    std::transform(
-        arguments.argv, arguments.argv + arguments.argc, argv.begin(),
-        [](auto& a) { return _strdup(base::WideToUTF8(a).c_str()); });
-
-    base::AtExitManager atexit_manager;
-    base::i18n::InitializeICU();
-    auto ret = atom::NodeMain(argv.size(), argv.data());
-    std::for_each(argv.begin(), argv.end(), free);
-    return ret;
-  }
-#endif
-
-  if (IsEnvSet("ELECTRON_INTERNAL_CRASH_SERVICE")) {
-    return crash_service::Main(cmd);
-  }
-
-  if (!atom::CheckCommandLineArguments(arguments.argc, arguments.argv))
-    return -1;
-
-  sandbox::SandboxInterfaceInfo sandbox_info = {0};
-  content::InitializeSandboxInfo(&sandbox_info);
-  atom::AtomMainDelegate delegate;
-
-  content::ContentMainParams params(&delegate);
-  params.instance = instance;
-  params.sandbox_info = &sandbox_info;
-  atom::AtomCommandLine::Init(arguments.argc, arguments.argv);
-  return content::ContentMain(params);
-}
-
-#elif defined(OS_LINUX)  // defined(OS_WIN)
-
-int main(int argc, char* argv[]) {
-#ifdef ENABLE_RUN_AS_NODE
-  if (IsEnvSet(kRunAsNode)) {
-    base::i18n::InitializeICU();
-    base::AtExitManager atexit_manager;
-    return atom::NodeMain(argc, argv);
-  }
-#endif
-
-  atom::AtomMainDelegate delegate;
-  content::ContentMainParams params(&delegate);
-  params.argc = argc;
-  params.argv = const_cast<const char**>(argv);
-  atom::AtomCommandLine::Init(argc, argv);
-  return content::ContentMain(params);
-}
-
-#else  // defined(OS_LINUX)
-
-int main(int argc, char* argv[]) {
-#ifdef ENABLE_RUN_AS_NODE
-  if (IsEnvSet(kRunAsNode)) {
-    return AtomInitializeICUandStartNode(argc, argv);
-  }
-#endif
-
-  return AtomMain(argc, argv);
-}
-
-#endif  // defined(OS_MACOSX)
removed in remote
  base   100644 30663a429e936cd26efa35a188f293f34a783d92 atom/app/atom_main.h
  our    100644 30663a429e936cd26efa35a188f293f34a783d92 atom/app/atom_main.h
@@ -1,10 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_MAIN_H_
-#define ATOM_APP_ATOM_MAIN_H_
-
-#include "content/public/app/content_main.h"
-
-#endif  // ATOM_APP_ATOM_MAIN_H_
removed in remote
  base   100644 221d59c1619cc440671083dc74ab52fc5cc948a8 atom/app/atom_main_delegate.cc
  our    100644 b3b5b8f2a8f24b8928f69a286c80e8a3b8464366 atom/app/atom_main_delegate.cc
@@ -1,209 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main_delegate.h"
-
-#include <iostream>
-#include <string>
-
-#include "atom/app/atom_content_client.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/relauncher.h"
-#include "atom/common/google_api_key.h"
-#include "atom/common/options_switches.h"
-#include "atom/renderer/atom_renderer_client.h"
-#include "atom/renderer/atom_sandboxed_renderer_client.h"
-#include "atom/utility/atom_content_utility_client.h"
-#include "base/command_line.h"
-#include "base/debug/stack_trace.h"
-#include "base/environment.h"
-#include "base/logging.h"
-#include "chrome/common/chrome_paths.h"
-#include "content/public/common/content_switches.h"
-#include "ipc/ipc_features.h"
-#include "services/service_manager/sandbox/switches.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/base/resource/resource_bundle.h"
-
-#if BUILDFLAG(IPC_MESSAGE_LOG_ENABLED)
-#define IPC_MESSAGE_MACROS_LOG_ENABLED
-#include "content/public/common/content_ipc_logging.h"
-#define IPC_LOG_TABLE_ADD_ENTRY(msg_id, logger) \
-  content::RegisterIPCLogger(msg_id, logger)
-#include "atom/common/common_message_generator.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-const char* kRelauncherProcess = "relauncher";
-
-bool IsBrowserProcess(base::CommandLine* cmd) {
-  std::string process_type = cmd->GetSwitchValueASCII(::switches::kProcessType);
-  return process_type.empty();
-}
-
-#if defined(OS_WIN)
-void InvalidParameterHandler(const wchar_t*,
-                             const wchar_t*,
-                             const wchar_t*,
-                             unsigned int,
-                             uintptr_t) {
-  // noop.
-}
-#endif
-
-}  // namespace
-
-AtomMainDelegate::AtomMainDelegate() {}
-
-AtomMainDelegate::~AtomMainDelegate() {}
-
-bool AtomMainDelegate::BasicStartupComplete(int* exit_code) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  logging::LoggingSettings settings;
-#if defined(OS_WIN)
-  // On Windows the terminal returns immediately, so we add a new line to
-  // prevent output in the same line as the prompt.
-  if (IsBrowserProcess(command_line))
-    std::wcout << std::endl;
-#if defined(DEBUG)
-  // Print logging to debug.log on Windows
-  settings.logging_dest = logging::LOG_TO_ALL;
-  settings.log_file = L"debug.log";
-  settings.lock_log = logging::LOCK_LOG_FILE;
-  settings.delete_old = logging::DELETE_OLD_LOG_FILE;
-#else
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-#endif  // defined(DEBUG)
-#else   // defined(OS_WIN)
-  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
-#endif  // !defined(OS_WIN)
-
-  // Only enable logging when --enable-logging is specified.
-  auto env = base::Environment::Create();
-  if (!command_line->HasSwitch(::switches::kEnableLogging) &&
-      !env->HasVar("ELECTRON_ENABLE_LOGGING")) {
-    settings.logging_dest = logging::LOG_NONE;
-    logging::SetMinLogLevel(logging::LOG_NUM_SEVERITIES);
-  }
-
-  logging::InitLogging(settings);
-
-  // Logging with pid and timestamp.
-  logging::SetLogItems(true, false, true, false);
-
-  // Enable convient stack printing.
-#if defined(DEBUG) && defined(OS_LINUX)
-  bool enable_stack_dumping = true;
-#else
-  bool enable_stack_dumping = env->HasVar("ELECTRON_ENABLE_STACK_DUMPING");
-#endif
-#if defined(ARCH_CPU_ARM_FAMILY) && defined(ARCH_CPU_32_BITS)
-  // For 32bit ARM enabling stack printing would end up crashing.
-  // https://github.com/electron/electron/pull/11230#issuecomment-363232482
-  enable_stack_dumping = false;
-#endif
-  if (enable_stack_dumping)
-    base::debug::EnableInProcessStackDumping();
-
-  chrome::RegisterPathProvider();
-
-#if defined(OS_MACOSX)
-  SetUpBundleOverrides();
-#endif
-
-#if defined(OS_WIN)
-  // Ignore invalid parameter errors.
-  _set_invalid_parameter_handler(InvalidParameterHandler);
-  // Disable the ActiveVerifier, which is used by Chrome to track possible
-  // bugs, but no use in Electron.
-  base::win::DisableHandleVerifier();
-#endif
-
-  return brightray::MainDelegate::BasicStartupComplete(exit_code);
-}
-
-void AtomMainDelegate::PreSandboxStartup() {
-  brightray::MainDelegate::PreSandboxStartup();
-
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  // Only append arguments for browser process.
-  if (!IsBrowserProcess(command_line))
-    return;
-
-  if (!command_line->HasSwitch(switches::kEnableMixedSandbox)) {
-    if (command_line->HasSwitch(switches::kEnableSandbox)) {
-      // Disable setuid sandbox since it is not longer required on
-      // linux(namespace sandbox is available on most distros).
-      command_line->AppendSwitch(
-          service_manager::switches::kDisableSetuidSandbox);
-    } else {
-      // Disable renderer sandbox for most of node's functions.
-      command_line->AppendSwitch(::switches::kNoSandbox);
-    }
-  }
-
-  // Allow file:// URIs to read other file:// URIs by default.
-  command_line->AppendSwitch(::switches::kAllowFileAccessFromFiles);
-
-#if defined(OS_MACOSX)
-  // Enable AVFoundation.
-  command_line->AppendSwitch("enable-avfoundation");
-#endif
-}
-
-content::ContentBrowserClient* AtomMainDelegate::CreateContentBrowserClient() {
-  browser_client_.reset(new AtomBrowserClient);
-  return browser_client_.get();
-}
-
-content::ContentRendererClient*
-AtomMainDelegate::CreateContentRendererClient() {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnableSandbox) ||
-      !base::CommandLine::ForCurrentProcess()->HasSwitch(
-          ::switches::kNoSandbox)) {
-    renderer_client_.reset(new AtomSandboxedRendererClient);
-  } else {
-    renderer_client_.reset(new AtomRendererClient);
-  }
-
-  return renderer_client_.get();
-}
-
-content::ContentUtilityClient* AtomMainDelegate::CreateContentUtilityClient() {
-  utility_client_.reset(new AtomContentUtilityClient);
-  return utility_client_.get();
-}
-
-int AtomMainDelegate::RunProcess(
-    const std::string& process_type,
-    const content::MainFunctionParams& main_function_params) {
-  if (process_type == kRelauncherProcess)
-    return relauncher::RelauncherMain(main_function_params);
-  else
-    return -1;
-}
-
-#if defined(OS_MACOSX)
-bool AtomMainDelegate::ShouldSendMachPort(const std::string& process_type) {
-  return process_type != kRelauncherProcess;
-}
-
-bool AtomMainDelegate::DelaySandboxInitialization(
-    const std::string& process_type) {
-  return process_type == kRelauncherProcess;
-}
-#endif
-
-std::unique_ptr<brightray::ContentClient>
-AtomMainDelegate::CreateContentClient() {
-  return std::make_unique<AtomContentClient>();
-}
-
-}  // namespace atom
removed in remote
  base   100644 5f4369302f5f6d0b6e03f0f0fe90f3f7b222d54a atom/app/atom_main_delegate.h
  our    100644 affdea01eec2ecb340a9d48c1fd1b6c22ed15e11 atom/app/atom_main_delegate.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_ATOM_MAIN_DELEGATE_H_
-#define ATOM_APP_ATOM_MAIN_DELEGATE_H_
-
-#include <string>
-
-#include "brightray/common/content_client.h"
-#include "brightray/common/main_delegate.h"
-
-namespace atom {
-
-class AtomMainDelegate : public brightray::MainDelegate {
- public:
-  AtomMainDelegate();
-  ~AtomMainDelegate() override;
-
- protected:
-  // content::ContentMainDelegate:
-  bool BasicStartupComplete(int* exit_code) override;
-  void PreSandboxStartup() override;
-  content::ContentBrowserClient* CreateContentBrowserClient() override;
-  content::ContentRendererClient* CreateContentRendererClient() override;
-  content::ContentUtilityClient* CreateContentUtilityClient() override;
-  int RunProcess(
-      const std::string& process_type,
-      const content::MainFunctionParams& main_function_params) override;
-#if defined(OS_MACOSX)
-  bool ShouldSendMachPort(const std::string& process_type) override;
-  bool DelaySandboxInitialization(const std::string& process_type) override;
-#endif
-
-  // brightray::MainDelegate:
-  std::unique_ptr<brightray::ContentClient> CreateContentClient() override;
-#if defined(OS_MACOSX)
-  void OverrideChildProcessPath() override;
-  void OverrideFrameworkBundlePath() override;
-#endif
-
- private:
-#if defined(OS_MACOSX)
-  void SetUpBundleOverrides();
-#endif
-
-  std::unique_ptr<content::ContentBrowserClient> browser_client_;
-  std::unique_ptr<content::ContentRendererClient> renderer_client_;
-  std::unique_ptr<content::ContentUtilityClient> utility_client_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomMainDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_ATOM_MAIN_DELEGATE_H_
removed in remote
  base   100644 33a8dea4aabb9733b768bf3e2610ab82f3c8fafe atom/app/atom_main_delegate_mac.mm
  our    100644 3fcf6db68b6714b07b400c9b016055beb47174f4 atom/app/atom_main_delegate_mac.mm
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/app/atom_main_delegate.h"
-
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/scoped_nsautorelease_pool.h"
-#include "base/path_service.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "brightray/common/mac/main_application_bundle.h"
-#include "content/public/common/content_paths.h"
-
-namespace atom {
-
-namespace {
-
-base::FilePath GetFrameworksPath() {
-  return brightray::MainApplicationBundlePath()
-      .Append("Contents")
-      .Append("Frameworks");
-}
-
-base::FilePath GetHelperAppPath(const base::FilePath& frameworks_path,
-                                const std::string& name) {
-  return frameworks_path.Append(name + " Helper.app")
-      .Append("Contents")
-      .Append("MacOS")
-      .Append(name + " Helper");
-}
-
-}  // namespace
-
-void AtomMainDelegate::OverrideFrameworkBundlePath() {
-  base::mac::SetOverrideFrameworkBundlePath(
-      GetFrameworksPath().Append(ATOM_PRODUCT_NAME " Framework.framework"));
-}
-
-void AtomMainDelegate::OverrideChildProcessPath() {
-  base::FilePath frameworks_path = GetFrameworksPath();
-  base::FilePath helper_path =
-      GetHelperAppPath(frameworks_path, ATOM_PRODUCT_NAME);
-  if (!base::PathExists(helper_path))
-    helper_path =
-        GetHelperAppPath(frameworks_path, brightray::GetApplicationName());
-  if (!base::PathExists(helper_path))
-    LOG(FATAL) << "Unable to find helper app";
-  PathService::Override(content::CHILD_PROCESS_EXE, helper_path);
-}
-
-void AtomMainDelegate::SetUpBundleOverrides() {
-  base::mac::ScopedNSAutoreleasePool pool;
-  NSBundle* bundle = brightray::MainApplicationBundle();
-  std::string base_bundle_id =
-      base::SysNSStringToUTF8([bundle bundleIdentifier]);
-  NSString* team_id = [bundle objectForInfoDictionaryKey:@"ElectronTeamID"];
-  if (team_id)
-    base_bundle_id = base::SysNSStringToUTF8(team_id) + "." + base_bundle_id;
-  base::mac::SetBaseBundleID(base_bundle_id.c_str());
-}
-
-}  // namespace atom
removed in remote
  base   100644 b946ae28ff94a08cfb9bd7bb9159170c78001ee8 atom/app/node_main.cc
  our    100644 9a95165f77a2585b06975bb3dfd0f5e573329410 atom/app/node_main.cc
@@ -1,120 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifdef ENABLE_RUN_AS_NODE
-
-#include "atom/app/node_main.h"
-
-#include "atom/app/uv_task_runner.h"
-#include "atom/browser/javascript_environment.h"
-#include "atom/browser/node_debugger.h"
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_bindings.h"
-#include "base/command_line.h"
-#include "base/feature_list.h"
-#include "base/task_scheduler/task_scheduler.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "gin/array_buffer.h"
-#include "gin/public/isolate_holder.h"
-#include "gin/v8_initializer.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-int NodeMain(int argc, char* argv[]) {
-  base::CommandLine::Init(argc, argv);
-
-  int exit_code = 1;
-  {
-    // Feed gin::PerIsolateData with a task runner.
-    argv = uv_setup_args(argc, argv);
-    uv_loop_t* loop = uv_default_loop();
-    scoped_refptr<UvTaskRunner> uv_task_runner(new UvTaskRunner(loop));
-    base::ThreadTaskRunnerHandle handle(uv_task_runner);
-
-    // Initialize feature list.
-    auto feature_list = std::make_unique<base::FeatureList>();
-    feature_list->InitializeFromCommandLine("", "");
-    base::FeatureList::SetInstance(std::move(feature_list));
-
-    gin::V8Initializer::LoadV8Snapshot(
-        gin::V8Initializer::V8SnapshotFileType::kWithAdditionalContext);
-    gin::V8Initializer::LoadV8Natives();
-
-    // V8 requires a task scheduler apparently
-    base::TaskScheduler::CreateAndStartWithDefaultParams("Electron");
-
-    // Initialize gin::IsolateHolder.
-    JavascriptEnvironment gin_env;
-
-    // Explicitly register electron's builtin modules.
-    NodeBindings::RegisterBuiltinModules();
-
-    int exec_argc;
-    const char** exec_argv;
-    node::Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);
-
-    node::Environment* env = node::CreateEnvironment(
-        node::CreateIsolateData(gin_env.isolate(), loop, gin_env.platform()),
-        gin_env.context(), argc, argv, exec_argc, exec_argv);
-
-    // Enable support for v8 inspector.
-    NodeDebugger node_debugger(env);
-    node_debugger.Start(gin_env.platform());
-
-    mate::Dictionary process(gin_env.isolate(), env->process_object());
-#if defined(OS_WIN)
-    process.SetMethod("log", &AtomBindings::Log);
-#endif
-    process.SetMethod("crash", &AtomBindings::Crash);
-
-    // Setup process.crashReporter.start in child node processes
-    auto reporter = mate::Dictionary::CreateEmpty(gin_env.isolate());
-    reporter.SetMethod("start", &crash_reporter::CrashReporter::StartInstance);
-    process.Set("crashReporter", reporter);
-
-    node::LoadEnvironment(env);
-
-    bool more;
-    do {
-      more = uv_run(env->event_loop(), UV_RUN_ONCE);
-      gin_env.platform()->DrainBackgroundTasks(env->isolate());
-      if (more == false) {
-        node::EmitBeforeExit(env);
-
-        // Emit `beforeExit` if the loop became alive either after emitting
-        // event, or after running some callbacks.
-        more = uv_loop_alive(env->event_loop());
-        if (uv_run(env->event_loop(), UV_RUN_NOWAIT) != 0)
-          more = true;
-      }
-    } while (more == true);
-
-    exit_code = node::EmitExit(env);
-    node::RunAtExit(env);
-    gin_env.platform()->DrainBackgroundTasks(env->isolate());
-    gin_env.platform()->CancelPendingDelayedTasks(env->isolate());
-
-    node::FreeEnvironment(env);
-  }
-
-  // According to "src/gin/shell/gin_main.cc":
-  //
-  // gin::IsolateHolder waits for tasks running in TaskScheduler in its
-  // destructor and thus must be destroyed before TaskScheduler starts skipping
-  // CONTINUE_ON_SHUTDOWN tasks.
-  base::TaskScheduler::GetInstance()->Shutdown();
-
-  v8::V8::Dispose();
-
-  return exit_code;
-}
-
-}  // namespace atom
-
-#endif  // ENABLE_RUN_AS_NODE
removed in remote
  base   100644 a4e047de39f180b9022dc178fc58979f5b879aa3 atom/app/node_main.h
  our    100644 68fe25f6df6acc2e59d0379454c69ca227dae020 atom/app/node_main.h
@@ -1,18 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_NODE_MAIN_H_
-#define ATOM_APP_NODE_MAIN_H_
-
-#ifdef ENABLE_RUN_AS_NODE
-
-namespace atom {
-
-int NodeMain(int argc, char* argv[]);
-
-}  // namespace atom
-
-#endif  // ENABLE_RUN_AS_NODE
-
-#endif  // ATOM_APP_NODE_MAIN_H_
removed in remote
  base   100644 097cc3bcda182c36ffeffa5cbb3cf3442ebaedbe atom/app/uv_task_runner.cc
  our    100644 60befc6db8ff4773f9aecfa890271940bfa29634 atom/app/uv_task_runner.cc
@@ -1,60 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <utility>
-
-#include "atom/app/uv_task_runner.h"
-
-#include "base/stl_util.h"
-
-namespace atom {
-
-UvTaskRunner::UvTaskRunner(uv_loop_t* loop) : loop_(loop) {}
-
-UvTaskRunner::~UvTaskRunner() {
-  for (auto& iter : tasks_) {
-    uv_unref(reinterpret_cast<uv_handle_t*>(iter.first));
-    delete iter.first;
-  }
-}
-
-bool UvTaskRunner::PostDelayedTask(const base::Location& from_here,
-                                   base::OnceClosure task,
-                                   base::TimeDelta delay) {
-  auto* timer = new uv_timer_t;
-  timer->data = this;
-  uv_timer_init(loop_, timer);
-  uv_timer_start(timer, UvTaskRunner::OnTimeout, delay.InMilliseconds(), 0);
-  tasks_[timer] = std::move(task);
-  return true;
-}
-
-bool UvTaskRunner::RunsTasksInCurrentSequence() const {
-  return true;
-}
-
-bool UvTaskRunner::PostNonNestableDelayedTask(const base::Location& from_here,
-                                              base::OnceClosure task,
-                                              base::TimeDelta delay) {
-  return PostDelayedTask(from_here, std::move(task), delay);
-}
-
-// static
-void UvTaskRunner::OnTimeout(uv_timer_t* timer) {
-  UvTaskRunner* self = static_cast<UvTaskRunner*>(timer->data);
-  if (!ContainsKey(self->tasks_, timer))
-    return;
-
-  std::move(self->tasks_[timer]).Run();
-  self->tasks_.erase(timer);
-  uv_timer_stop(timer);
-  uv_close(reinterpret_cast<uv_handle_t*>(timer), UvTaskRunner::OnClose);
-}
-
-// static
-void UvTaskRunner::OnClose(uv_handle_t* handle) {
-  delete reinterpret_cast<uv_timer_t*>(handle);
-}
-
-}  // namespace atom
removed in remote
  base   100644 c7302766c2d1786cc00d58c56ca529574f09ac8d atom/app/uv_task_runner.h
  our    100644 578024d70486ba2f4a3cf9dc643a19bc857158db atom/app/uv_task_runner.h
@@ -1,45 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_APP_UV_TASK_RUNNER_H_
-#define ATOM_APP_UV_TASK_RUNNER_H_
-
-#include <map>
-
-#include "base/callback.h"
-#include "base/location.h"
-#include "base/single_thread_task_runner.h"
-#include "uv.h"  // NOLINT(build/include)
-
-namespace atom {
-
-// TaskRunner implementation that posts tasks into libuv's default loop.
-class UvTaskRunner : public base::SingleThreadTaskRunner {
- public:
-  explicit UvTaskRunner(uv_loop_t* loop);
-
-  // base::SingleThreadTaskRunner:
-  bool PostDelayedTask(const base::Location& from_here,
-                       base::OnceClosure task,
-                       base::TimeDelta delay) override;
-  bool RunsTasksInCurrentSequence() const override;
-  bool PostNonNestableDelayedTask(const base::Location& from_here,
-                                  base::OnceClosure task,
-                                  base::TimeDelta delay) override;
-
- private:
-  ~UvTaskRunner() override;
-  static void OnTimeout(uv_timer_t* timer);
-  static void OnClose(uv_handle_t* handle);
-
-  uv_loop_t* loop_;
-
-  std::map<uv_timer_t*, base::OnceClosure> tasks_;
-
-  DISALLOW_COPY_AND_ASSIGN(UvTaskRunner);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_APP_UV_TASK_RUNNER_H_
removed in remote
  base   100644 ad5b7214ccd724927f25292463c2972b7391313b atom/browser/api/atom_api_app.cc
  our    100644 089a2b63d1bae3afebea925582a3aac81ddeaa4f atom/browser/api/atom_api_app.cc
@@ -1,1378 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_app.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/login_handler.h"
-#include "atom/browser/relauncher.h"
-#include "atom/common/atom_command_line.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/network_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/path_service.h"
-#include "base/strings/string_util.h"
-#include "base/sys_info.h"
-#include "brightray/browser/brightray_paths.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/icon_manager.h"
-#include "chrome/common/chrome_paths.h"
-#include "content/browser/gpu/compositor_util.h"
-#include "content/browser/gpu/gpu_data_manager_impl.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "content/public/browser/browser_child_process_host.h"
-#include "content/public/browser/child_process_data.h"
-#include "content/public/browser/client_certificate_delegate.h"
-#include "content/public/browser/gpu_data_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/common/content_switches.h"
-#include "media/audio/audio_manager.h"
-#include "native_mate/object_template_builder.h"
-#include "net/ssl/client_cert_identity.h"
-#include "net/ssl/ssl_cert_request_info.h"
-#include "services/network/public/cpp/network_switches.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "ui/gfx/image/image.h"
-
-#if defined(OS_WIN)
-#include "atom/browser/ui/win/jump_list.h"
-#include "base/strings/utf_string_conversions.h"
-#endif
-
-#if defined(OS_MACOSX)
-#include "atom/browser/ui/cocoa/atom_bundle_mover.h"
-#endif
-
-using atom::Browser;
-
-namespace mate {
-
-#if defined(OS_WIN)
-template <>
-struct Converter<Browser::UserTask> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     Browser::UserTask* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    if (!dict.Get("program", &(out->program)) ||
-        !dict.Get("title", &(out->title)))
-      return false;
-    if (dict.Get("iconPath", &(out->icon_path)) &&
-        !dict.Get("iconIndex", &(out->icon_index)))
-      return false;
-    dict.Get("arguments", &(out->arguments));
-    dict.Get("description", &(out->description));
-    return true;
-  }
-};
-
-using atom::JumpListCategory;
-using atom::JumpListItem;
-using atom::JumpListResult;
-
-template <>
-struct Converter<JumpListItem::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListItem::Type* out) {
-    std::string item_type;
-    if (!ConvertFromV8(isolate, val, &item_type))
-      return false;
-
-    if (item_type == "task")
-      *out = JumpListItem::Type::TASK;
-    else if (item_type == "separator")
-      *out = JumpListItem::Type::SEPARATOR;
-    else if (item_type == "file")
-      *out = JumpListItem::Type::FILE;
-    else
-      return false;
-
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   JumpListItem::Type val) {
-    std::string item_type;
-    switch (val) {
-      case JumpListItem::Type::TASK:
-        item_type = "task";
-        break;
-
-      case JumpListItem::Type::SEPARATOR:
-        item_type = "separator";
-        break;
-
-      case JumpListItem::Type::FILE:
-        item_type = "file";
-        break;
-    }
-    return mate::ConvertToV8(isolate, item_type);
-  }
-};
-
-template <>
-struct Converter<JumpListItem> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListItem* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    if (!dict.Get("type", &(out->type)))
-      return false;
-
-    switch (out->type) {
-      case JumpListItem::Type::TASK:
-        if (!dict.Get("program", &(out->path)) ||
-            !dict.Get("title", &(out->title)))
-          return false;
-
-        if (dict.Get("iconPath", &(out->icon_path)) &&
-            !dict.Get("iconIndex", &(out->icon_index)))
-          return false;
-
-        dict.Get("args", &(out->arguments));
-        dict.Get("description", &(out->description));
-        return true;
-
-      case JumpListItem::Type::SEPARATOR:
-        return true;
-
-      case JumpListItem::Type::FILE:
-        return dict.Get("path", &(out->path));
-    }
-
-    assert(false);
-    return false;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const JumpListItem& val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("type", val.type);
-
-    switch (val.type) {
-      case JumpListItem::Type::TASK:
-        dict.Set("program", val.path);
-        dict.Set("args", val.arguments);
-        dict.Set("title", val.title);
-        dict.Set("iconPath", val.icon_path);
-        dict.Set("iconIndex", val.icon_index);
-        dict.Set("description", val.description);
-        break;
-
-      case JumpListItem::Type::SEPARATOR:
-        break;
-
-      case JumpListItem::Type::FILE:
-        dict.Set("path", val.path);
-        break;
-    }
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<JumpListCategory::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListCategory::Type* out) {
-    std::string category_type;
-    if (!ConvertFromV8(isolate, val, &category_type))
-      return false;
-
-    if (category_type == "tasks")
-      *out = JumpListCategory::Type::TASKS;
-    else if (category_type == "frequent")
-      *out = JumpListCategory::Type::FREQUENT;
-    else if (category_type == "recent")
-      *out = JumpListCategory::Type::RECENT;
-    else if (category_type == "custom")
-      *out = JumpListCategory::Type::CUSTOM;
-    else
-      return false;
-
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   JumpListCategory::Type val) {
-    std::string category_type;
-    switch (val) {
-      case JumpListCategory::Type::TASKS:
-        category_type = "tasks";
-        break;
-
-      case JumpListCategory::Type::FREQUENT:
-        category_type = "frequent";
-        break;
-
-      case JumpListCategory::Type::RECENT:
-        category_type = "recent";
-        break;
-
-      case JumpListCategory::Type::CUSTOM:
-        category_type = "custom";
-        break;
-    }
-    return mate::ConvertToV8(isolate, category_type);
-  }
-};
-
-template <>
-struct Converter<JumpListCategory> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     JumpListCategory* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    if (dict.Get("name", &(out->name)) && out->name.empty())
-      return false;
-
-    if (!dict.Get("type", &(out->type))) {
-      if (out->name.empty())
-        out->type = JumpListCategory::Type::TASKS;
-      else
-        out->type = JumpListCategory::Type::CUSTOM;
-    }
-
-    if ((out->type == JumpListCategory::Type::TASKS) ||
-        (out->type == JumpListCategory::Type::CUSTOM)) {
-      if (!dict.Get("items", &(out->items)))
-        return false;
-    }
-
-    return true;
-  }
-};
-
-// static
-template <>
-struct Converter<JumpListResult> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, JumpListResult val) {
-    std::string result_code;
-    switch (val) {
-      case JumpListResult::SUCCESS:
-        result_code = "ok";
-        break;
-
-      case JumpListResult::ARGUMENT_ERROR:
-        result_code = "argumentError";
-        break;
-
-      case JumpListResult::GENERIC_ERROR:
-        result_code = "error";
-        break;
-
-      case JumpListResult::CUSTOM_CATEGORY_SEPARATOR_ERROR:
-        result_code = "invalidSeparatorError";
-        break;
-
-      case JumpListResult::MISSING_FILE_TYPE_REGISTRATION_ERROR:
-        result_code = "fileTypeRegistrationError";
-        break;
-
-      case JumpListResult::CUSTOM_CATEGORY_ACCESS_DENIED_ERROR:
-        result_code = "customCategoryAccessDeniedError";
-        break;
-    }
-    return ConvertToV8(isolate, result_code);
-  }
-};
-#endif
-
-template <>
-struct Converter<Browser::LoginItemSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     Browser::LoginItemSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-
-    dict.Get("openAtLogin", &(out->open_at_login));
-    dict.Get("openAsHidden", &(out->open_as_hidden));
-    dict.Get("path", &(out->path));
-    dict.Get("args", &(out->args));
-    return true;
-  }
-
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   Browser::LoginItemSettings val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("openAtLogin", val.open_at_login);
-    dict.Set("openAsHidden", val.open_as_hidden);
-    dict.Set("restoreState", val.restore_state);
-    dict.Set("wasOpenedAtLogin", val.opened_at_login);
-    dict.Set("wasOpenedAsHidden", val.opened_as_hidden);
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<content::CertificateRequestResultType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::CertificateRequestResultType* out) {
-    bool b;
-    if (!ConvertFromV8(isolate, val, &b))
-      return false;
-    *out = b ? content::CERTIFICATE_REQUEST_RESULT_TYPE_CONTINUE
-             : content::CERTIFICATE_REQUEST_RESULT_TYPE_CANCEL;
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-ProcessMetric::ProcessMetric(int type,
-                             base::ProcessId pid,
-                             std::unique_ptr<base::ProcessMetrics> metrics) {
-  this->type = type;
-  this->pid = pid;
-  this->metrics = std::move(metrics);
-}
-
-ProcessMetric::~ProcessMetric() = default;
-
-namespace api {
-
-namespace {
-
-class AppIdProcessIterator : public base::ProcessIterator {
- public:
-  AppIdProcessIterator() : base::ProcessIterator(nullptr) {}
-
- protected:
-  bool IncludeEntry() override {
-    return (entry().parent_pid() == base::GetCurrentProcId() ||
-            entry().pid() == base::GetCurrentProcId());
-  }
-};
-
-IconLoader::IconSize GetIconSizeByString(const std::string& size) {
-  if (size == "small") {
-    return IconLoader::IconSize::SMALL;
-  } else if (size == "large") {
-    return IconLoader::IconSize::LARGE;
-  }
-  return IconLoader::IconSize::NORMAL;
-}
-
-// Return the path constant from string.
-int GetPathConstant(const std::string& name) {
-  if (name == "appData")
-    return brightray::DIR_APP_DATA;
-  else if (name == "userData")
-    return brightray::DIR_USER_DATA;
-  else if (name == "cache")
-    return brightray::DIR_CACHE;
-  else if (name == "userCache")
-    return brightray::DIR_USER_CACHE;
-  else if (name == "logs")
-    return brightray::DIR_APP_LOGS;
-  else if (name == "home")
-    return base::DIR_HOME;
-  else if (name == "temp")
-    return base::DIR_TEMP;
-  else if (name == "userDesktop" || name == "desktop")
-    return base::DIR_USER_DESKTOP;
-  else if (name == "exe")
-    return base::FILE_EXE;
-  else if (name == "module")
-    return base::FILE_MODULE;
-  else if (name == "documents")
-    return chrome::DIR_USER_DOCUMENTS;
-  else if (name == "downloads")
-    return chrome::DIR_DEFAULT_DOWNLOADS;
-  else if (name == "music")
-    return chrome::DIR_USER_MUSIC;
-  else if (name == "pictures")
-    return chrome::DIR_USER_PICTURES;
-  else if (name == "videos")
-    return chrome::DIR_USER_VIDEOS;
-  else if (name == "pepperFlashSystemPlugin")
-    return chrome::FILE_PEPPER_FLASH_SYSTEM_PLUGIN;
-  else
-    return -1;
-}
-
-bool NotificationCallbackWrapper(
-    const base::Callback<
-        void(const base::CommandLine::StringVector& command_line,
-             const base::FilePath& current_directory)>& callback,
-    const base::CommandLine::StringVector& cmd,
-    const base::FilePath& cwd) {
-  // Make sure the callback is called after app gets ready.
-  if (Browser::Get()->is_ready()) {
-    callback.Run(cmd, cwd);
-  } else {
-    scoped_refptr<base::SingleThreadTaskRunner> task_runner(
-        base::ThreadTaskRunnerHandle::Get());
-    task_runner->PostTask(
-        FROM_HERE, base::BindOnce(base::IgnoreResult(callback), cmd, cwd));
-  }
-  // ProcessSingleton needs to know whether current process is quiting.
-  return !Browser::Get()->is_shutting_down();
-}
-
-void GotPrivateKey(std::shared_ptr<content::ClientCertificateDelegate> delegate,
-                   scoped_refptr<net::X509Certificate> cert,
-                   scoped_refptr<net::SSLPrivateKey> private_key) {
-  delegate->ContinueWithCertificate(cert, private_key);
-}
-
-void OnClientCertificateSelected(
-    v8::Isolate* isolate,
-    std::shared_ptr<content::ClientCertificateDelegate> delegate,
-    std::shared_ptr<net::ClientCertIdentityList> identities,
-    mate::Arguments* args) {
-  if (args->Length() == 2) {
-    delegate->ContinueWithCertificate(nullptr, nullptr);
-    return;
-  }
-
-  v8::Local<v8::Value> val;
-  args->GetNext(&val);
-  if (val->IsNull()) {
-    delegate->ContinueWithCertificate(nullptr, nullptr);
-    return;
-  }
-
-  mate::Dictionary cert_data;
-  if (!mate::ConvertFromV8(isolate, val, &cert_data)) {
-    args->ThrowError("Must pass valid certificate object.");
-    return;
-  }
-
-  std::string data;
-  if (!cert_data.Get("data", &data))
-    return;
-
-  auto certs = net::X509Certificate::CreateCertificateListFromBytes(
-      data.c_str(), data.length(), net::X509Certificate::FORMAT_AUTO);
-  if (!certs.empty()) {
-    scoped_refptr<net::X509Certificate> cert(certs[0].get());
-    for (size_t i = 0; i < identities->size(); ++i) {
-      if (cert->Equals((*identities)[i]->certificate())) {
-        net::ClientCertIdentity::SelfOwningAcquirePrivateKey(
-            std::move((*identities)[i]),
-            base::Bind(&GotPrivateKey, delegate, std::move(cert)));
-        break;
-      }
-    }
-  }
-}
-
-void PassLoginInformation(scoped_refptr<LoginHandler> login_handler,
-                          mate::Arguments* args) {
-  base::string16 username, password;
-  if (args->GetNext(&username) && args->GetNext(&password))
-    login_handler->Login(username, password);
-  else
-    login_handler->CancelAuth();
-}
-
-#if defined(USE_NSS_CERTS)
-int ImportIntoCertStore(CertificateManagerModel* model,
-                        const base::DictionaryValue& options) {
-  std::string file_data, cert_path;
-  base::string16 password;
-  net::ScopedCERTCertificateList imported_certs;
-  int rv = -1;
-  options.GetString("certificate", &cert_path);
-  options.GetString("password", &password);
-
-  if (!cert_path.empty()) {
-    if (base::ReadFileToString(base::FilePath(cert_path), &file_data)) {
-      auto module = model->cert_db()->GetPrivateSlot();
-      rv = model->ImportFromPKCS12(module.get(), file_data, password, true,
-                                   &imported_certs);
-      if (imported_certs.size() > 1) {
-        auto it = imported_certs.begin();
-        ++it;  // skip first which would  be the client certificate.
-        for (; it != imported_certs.end(); ++it)
-          rv &= model->SetCertTrust(it->get(), net::CA_CERT,
-                                    net::NSSCertDatabase::TRUSTED_SSL);
-      }
-    }
-  }
-  return rv;
-}
-#endif
-
-void OnIconDataAvailable(v8::Isolate* isolate,
-                         const App::FileIconCallback& callback,
-                         gfx::Image* icon) {
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-
-  if (icon && !icon->IsEmpty()) {
-    callback.Run(v8::Null(isolate), *icon);
-  } else {
-    v8::Local<v8::String> error_message =
-        v8::String::NewFromUtf8(isolate, "Failed to get file icon.");
-    callback.Run(v8::Exception::Error(error_message), gfx::Image());
-  }
-}
-
-}  // namespace
-
-App::App(v8::Isolate* isolate) {
-  static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())->set_delegate(this);
-  Browser::Get()->AddObserver(this);
-  content::GpuDataManager::GetInstance()->AddObserver(this);
-  base::ProcessId pid = base::GetCurrentProcId();
-  auto process_metric = std::make_unique<atom::ProcessMetric>(
-      content::PROCESS_TYPE_BROWSER, pid,
-      base::ProcessMetrics::CreateCurrentProcessMetrics());
-  app_metrics_[pid] = std::move(process_metric);
-  Init(isolate);
-}
-
-App::~App() {
-  static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())
-      ->set_delegate(nullptr);
-  Browser::Get()->RemoveObserver(this);
-  content::GpuDataManager::GetInstance()->RemoveObserver(this);
-  content::BrowserChildProcessObserver::Remove(this);
-}
-
-void App::OnBeforeQuit(bool* prevent_default) {
-  if (Emit("before-quit")) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnWillQuit(bool* prevent_default) {
-  if (Emit("will-quit")) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnWindowAllClosed() {
-  Emit("window-all-closed");
-}
-
-void App::OnQuit() {
-  int exitCode = AtomBrowserMainParts::Get()->GetExitCode();
-  Emit("quit", exitCode);
-
-  if (process_singleton_) {
-    process_singleton_->Cleanup();
-    process_singleton_.reset();
-  }
-}
-
-void App::OnOpenFile(bool* prevent_default, const std::string& file_path) {
-  if (Emit("open-file", file_path)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnOpenURL(const std::string& url) {
-  Emit("open-url", url);
-}
-
-void App::OnActivate(bool has_visible_windows) {
-  Emit("activate", has_visible_windows);
-}
-
-void App::OnWillFinishLaunching() {
-  Emit("will-finish-launching");
-}
-
-void App::OnFinishLaunching(const base::DictionaryValue& launch_info) {
-#if defined(OS_LINUX)
-  // Set the application name for audio streams shown in external
-  // applications. Only affects pulseaudio currently.
-  media::AudioManager::SetGlobalAppName(Browser::Get()->GetName());
-#endif
-  Emit("ready", launch_info);
-}
-
-void App::OnPreMainMessageLoopRun() {
-  content::BrowserChildProcessObserver::Add(this);
-  if (process_singleton_) {
-    process_singleton_->OnBrowserReady();
-  }
-}
-
-void App::OnAccessibilitySupportChanged() {
-  Emit("accessibility-support-changed", IsAccessibilitySupportEnabled());
-}
-
-#if defined(OS_MACOSX)
-void App::OnWillContinueUserActivity(bool* prevent_default,
-                                     const std::string& type) {
-  if (Emit("will-continue-activity", type)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnDidFailToContinueUserActivity(const std::string& type,
-                                          const std::string& error) {
-  Emit("continue-activity-error", type, error);
-}
-
-void App::OnContinueUserActivity(bool* prevent_default,
-                                 const std::string& type,
-                                 const base::DictionaryValue& user_info) {
-  if (Emit("continue-activity", type, user_info)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnUserActivityWasContinued(const std::string& type,
-                                     const base::DictionaryValue& user_info) {
-  Emit("activity-was-continued", type, user_info);
-}
-
-void App::OnUpdateUserActivityState(bool* prevent_default,
-                                    const std::string& type,
-                                    const base::DictionaryValue& user_info) {
-  if (Emit("update-activity-state", type, user_info)) {
-    *prevent_default = true;
-  }
-}
-
-void App::OnNewWindowForTab() {
-  Emit("new-window-for-tab");
-}
-#endif
-
-void App::OnLogin(scoped_refptr<LoginHandler> login_handler,
-                  const base::DictionaryValue& request_details) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  bool prevent_default = false;
-  content::WebContents* web_contents = login_handler->GetWebContents();
-  if (web_contents) {
-    prevent_default = Emit(
-        "login", WebContents::CreateFrom(isolate(), web_contents),
-        request_details, login_handler->auth_info(),
-        base::Bind(&PassLoginInformation, base::RetainedRef(login_handler)));
-  }
-
-  // Default behavior is to always cancel the auth.
-  if (!prevent_default)
-    login_handler->CancelAuth();
-}
-
-bool App::CanCreateWindow(
-    content::RenderFrameHost* opener,
-    const GURL& opener_url,
-    const GURL& opener_top_level_frame_url,
-    const GURL& source_origin,
-    content::mojom::WindowContainerType container_type,
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const blink::mojom::WindowFeatures& features,
-    const std::vector<std::string>& additional_features,
-    const scoped_refptr<network::ResourceRequestBody>& body,
-    bool user_gesture,
-    bool opener_suppressed,
-    bool* no_javascript_access) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  content::WebContents* web_contents =
-      content::WebContents::FromRenderFrameHost(opener);
-  if (web_contents) {
-    auto api_web_contents = WebContents::CreateFrom(isolate(), web_contents);
-    api_web_contents->OnCreateWindow(target_url, referrer, frame_name,
-                                     disposition, additional_features, body);
-  }
-
-  return false;
-}
-
-void App::AllowCertificateError(
-    content::WebContents* web_contents,
-    int cert_error,
-    const net::SSLInfo& ssl_info,
-    const GURL& request_url,
-    content::ResourceType resource_type,
-    bool strict_enforcement,
-    bool expired_previous_decision,
-    const base::Callback<void(content::CertificateRequestResultType)>&
-        callback) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  bool prevent_default = Emit(
-      "certificate-error", WebContents::CreateFrom(isolate(), web_contents),
-      request_url, net::ErrorToString(cert_error), ssl_info.cert, callback);
-
-  // Deny the certificate by default.
-  if (!prevent_default)
-    callback.Run(content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY);
-}
-
-void App::SelectClientCertificate(
-    content::WebContents* web_contents,
-    net::SSLCertRequestInfo* cert_request_info,
-    net::ClientCertIdentityList identities,
-    std::unique_ptr<content::ClientCertificateDelegate> delegate) {
-  std::shared_ptr<content::ClientCertificateDelegate> shared_delegate(
-      delegate.release());
-
-  // Convert the ClientCertIdentityList to a CertificateList
-  // to avoid changes in the API.
-  auto client_certs = net::CertificateList();
-  for (const std::unique_ptr<net::ClientCertIdentity>& identity : identities)
-    client_certs.push_back(identity->certificate());
-
-  auto shared_identities =
-      std::make_shared<net::ClientCertIdentityList>(std::move(identities));
-
-  bool prevent_default =
-      Emit("select-client-certificate",
-           WebContents::CreateFrom(isolate(), web_contents),
-           cert_request_info->host_and_port.ToString(), std::move(client_certs),
-           base::Bind(&OnClientCertificateSelected, isolate(), shared_delegate,
-                      shared_identities));
-
-  // Default to first certificate from the platform store.
-  if (!prevent_default) {
-    scoped_refptr<net::X509Certificate> cert =
-        (*shared_identities)[0]->certificate();
-    net::ClientCertIdentity::SelfOwningAcquirePrivateKey(
-        std::move((*shared_identities)[0]),
-        base::Bind(&GotPrivateKey, shared_delegate, std::move(cert)));
-  }
-}
-
-void App::OnGpuProcessCrashed(base::TerminationStatus status) {
-  Emit("gpu-process-crashed",
-       status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);
-}
-
-void App::BrowserChildProcessLaunchedAndConnected(
-    const content::ChildProcessData& data) {
-  ChildProcessLaunched(data.process_type, data.handle);
-}
-
-void App::BrowserChildProcessHostDisconnected(
-    const content::ChildProcessData& data) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::BrowserChildProcessCrashed(const content::ChildProcessData& data,
-                                     int exit_code) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::BrowserChildProcessKilled(const content::ChildProcessData& data,
-                                    int exit_code) {
-  ChildProcessDisconnected(base::GetProcId(data.handle));
-}
-
-void App::RenderProcessReady(content::RenderProcessHost* host) {
-  ChildProcessLaunched(content::PROCESS_TYPE_RENDERER, host->GetHandle());
-}
-
-void App::RenderProcessDisconnected(base::ProcessId host_pid) {
-  ChildProcessDisconnected(host_pid);
-}
-
-void App::ChildProcessLaunched(int process_type, base::ProcessHandle handle) {
-  auto pid = base::GetProcId(handle);
-
-#if defined(OS_MACOSX)
-  std::unique_ptr<base::ProcessMetrics> metrics(
-      base::ProcessMetrics::CreateProcessMetrics(
-          handle, content::BrowserChildProcessHost::GetPortProvider()));
-#else
-  std::unique_ptr<base::ProcessMetrics> metrics(
-      base::ProcessMetrics::CreateProcessMetrics(handle));
-#endif
-  app_metrics_[pid] = std::make_unique<atom::ProcessMetric>(process_type, pid,
-                                                            std::move(metrics));
-}
-
-void App::ChildProcessDisconnected(base::ProcessId pid) {
-  app_metrics_.erase(pid);
-}
-
-base::FilePath App::GetAppPath() const {
-  return app_path_;
-}
-
-void App::SetAppPath(const base::FilePath& app_path) {
-  app_path_ = app_path;
-}
-
-base::FilePath App::GetPath(mate::Arguments* args, const std::string& name) {
-  bool succeed = false;
-  base::FilePath path;
-  int key = GetPathConstant(name);
-  if (key >= 0)
-    succeed = PathService::Get(key, &path);
-  if (!succeed)
-    args->ThrowError("Failed to get '" + name + "' path");
-  return path;
-}
-
-void App::SetPath(mate::Arguments* args,
-                  const std::string& name,
-                  const base::FilePath& path) {
-  if (!path.IsAbsolute()) {
-    args->ThrowError("Path must be absolute");
-    return;
-  }
-
-  bool succeed = false;
-  int key = GetPathConstant(name);
-  if (key >= 0)
-    succeed = PathService::OverrideAndCreateIfNeeded(key, path, true, false);
-  if (!succeed)
-    args->ThrowError("Failed to set path");
-}
-
-void App::SetDesktopName(const std::string& desktop_name) {
-#if defined(OS_LINUX)
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  env->SetVar("CHROME_DESKTOP", desktop_name);
-#endif
-}
-
-std::string App::GetLocale() {
-  return g_browser_process->GetApplicationLocale();
-}
-
-void App::OnSecondInstance(const base::CommandLine::StringVector& cmd,
-                           const base::FilePath& cwd) {
-  Emit("second-instance", cmd, cwd);
-}
-
-bool App::HasSingleInstanceLock() const {
-  if (process_singleton_)
-    return true;
-  return false;
-}
-
-bool App::RequestSingleInstanceLock() {
-  if (HasSingleInstanceLock())
-    return true;
-
-  base::FilePath user_dir;
-  PathService::Get(brightray::DIR_USER_DATA, &user_dir);
-
-  auto cb = base::Bind(&App::OnSecondInstance, base::Unretained(this));
-
-  process_singleton_.reset(new ProcessSingleton(
-      user_dir, base::Bind(NotificationCallbackWrapper, cb)));
-
-  switch (process_singleton_->NotifyOtherProcessOrCreate()) {
-    case ProcessSingleton::NotifyResult::LOCK_ERROR:
-    case ProcessSingleton::NotifyResult::PROFILE_IN_USE:
-    case ProcessSingleton::NotifyResult::PROCESS_NOTIFIED: {
-      process_singleton_.reset();
-      return false;
-    }
-    case ProcessSingleton::NotifyResult::PROCESS_NONE:
-    default:  // Shouldn't be needed, but VS warns if it is not there.
-      return true;
-  }
-}
-
-void App::ReleaseSingleInstanceLock() {
-  if (process_singleton_) {
-    process_singleton_->Cleanup();
-    process_singleton_.reset();
-  }
-}
-
-bool App::Relaunch(mate::Arguments* js_args) {
-  // Parse parameters.
-  bool override_argv = false;
-  base::FilePath exec_path;
-  relauncher::StringVector args;
-
-  mate::Dictionary options;
-  if (js_args->GetNext(&options)) {
-    if (options.Get("execPath", &exec_path) | options.Get("args", &args))
-      override_argv = true;
-  }
-
-  if (!override_argv) {
-    const relauncher::StringVector& argv = atom::AtomCommandLine::argv();
-    return relauncher::RelaunchApp(argv);
-  }
-
-  relauncher::StringVector argv;
-  argv.reserve(1 + args.size());
-
-  if (exec_path.empty()) {
-    base::FilePath current_exe_path;
-    PathService::Get(base::FILE_EXE, &current_exe_path);
-    argv.push_back(current_exe_path.value());
-  } else {
-    argv.push_back(exec_path.value());
-  }
-
-  argv.insert(argv.end(), args.begin(), args.end());
-
-  return relauncher::RelaunchApp(argv);
-}
-
-void App::DisableHardwareAcceleration(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.disableHardwareAcceleration() can only be called "
-        "before app is ready");
-    return;
-  }
-  content::GpuDataManager::GetInstance()->DisableHardwareAcceleration();
-}
-
-void App::DisableDomainBlockingFor3DAPIs(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.disableDomainBlockingFor3DAPIs() can only be called "
-        "before app is ready");
-    return;
-  }
-  content::GpuDataManagerImpl::GetInstance()
-      ->DisableDomainBlockingFor3DAPIsForTesting();
-}
-
-bool App::IsAccessibilitySupportEnabled() {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-  return ax_state->IsAccessibleBrowser();
-}
-
-void App::SetAccessibilitySupportEnabled(bool enabled) {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-  if (enabled) {
-    ax_state->OnScreenReaderDetected();
-  } else {
-    ax_state->DisableAccessibility();
-  }
-  Browser::Get()->OnAccessibilitySupportChanged();
-}
-
-Browser::LoginItemSettings App::GetLoginItemSettings(mate::Arguments* args) {
-  Browser::LoginItemSettings options;
-  args->GetNext(&options);
-  return Browser::Get()->GetLoginItemSettings(options);
-}
-
-#if defined(USE_NSS_CERTS)
-void App::ImportCertificate(const base::DictionaryValue& options,
-                            const net::CompletionCallback& callback) {
-  auto browser_context = AtomBrowserContext::From("", false);
-  if (!certificate_manager_model_) {
-    auto copy = base::DictionaryValue::From(
-        base::Value::ToUniquePtrValue(options.Clone()));
-    CertificateManagerModel::Create(
-        browser_context.get(),
-        base::Bind(&App::OnCertificateManagerModelCreated,
-                   base::Unretained(this), base::Passed(&copy), callback));
-    return;
-  }
-
-  int rv = ImportIntoCertStore(certificate_manager_model_.get(), options);
-  callback.Run(rv);
-}
-
-void App::OnCertificateManagerModelCreated(
-    std::unique_ptr<base::DictionaryValue> options,
-    const net::CompletionCallback& callback,
-    std::unique_ptr<CertificateManagerModel> model) {
-  certificate_manager_model_ = std::move(model);
-  int rv =
-      ImportIntoCertStore(certificate_manager_model_.get(), *(options.get()));
-  callback.Run(rv);
-}
-#endif
-
-#if defined(OS_WIN)
-v8::Local<v8::Value> App::GetJumpListSettings() {
-  JumpList jump_list(Browser::Get()->GetAppUserModelID());
-
-  int min_items = 10;
-  std::vector<JumpListItem> removed_items;
-  if (jump_list.Begin(&min_items, &removed_items)) {
-    // We don't actually want to change anything, so abort the transaction.
-    jump_list.Abort();
-  } else {
-    LOG(ERROR) << "Failed to begin Jump List transaction.";
-  }
-
-  auto dict = mate::Dictionary::CreateEmpty(isolate());
-  dict.Set("minItems", min_items);
-  dict.Set("removedItems", mate::ConvertToV8(isolate(), removed_items));
-  return dict.GetHandle();
-}
-
-JumpListResult App::SetJumpList(v8::Local<v8::Value> val,
-                                mate::Arguments* args) {
-  std::vector<JumpListCategory> categories;
-  bool delete_jump_list = val->IsNull();
-  if (!delete_jump_list &&
-      !mate::ConvertFromV8(args->isolate(), val, &categories)) {
-    args->ThrowError("Argument must be null or an array of categories");
-    return JumpListResult::ARGUMENT_ERROR;
-  }
-
-  JumpList jump_list(Browser::Get()->GetAppUserModelID());
-
-  if (delete_jump_list) {
-    return jump_list.Delete() ? JumpListResult::SUCCESS
-                              : JumpListResult::GENERIC_ERROR;
-  }
-
-  // Start a transaction that updates the JumpList of this application.
-  if (!jump_list.Begin())
-    return JumpListResult::GENERIC_ERROR;
-
-  JumpListResult result = jump_list.AppendCategories(categories);
-  // AppendCategories may have failed to add some categories, but it's better
-  // to have something than nothing so try to commit the changes anyway.
-  if (!jump_list.Commit()) {
-    LOG(ERROR) << "Failed to commit changes to custom Jump List.";
-    // It's more useful to return the earlier error code that might give
-    // some indication as to why the transaction actually failed, so don't
-    // overwrite it with a "generic error" code here.
-    if (result == JumpListResult::SUCCESS)
-      result = JumpListResult::GENERIC_ERROR;
-  }
-
-  return result;
-}
-#endif  // defined(OS_WIN)
-
-void App::GetFileIcon(const base::FilePath& path, mate::Arguments* args) {
-  mate::Dictionary options;
-  IconLoader::IconSize icon_size;
-  FileIconCallback callback;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  base::FilePath normalized_path = path.NormalizePathSeparators();
-
-  if (!args->GetNext(&options)) {
-    icon_size = IconLoader::IconSize::NORMAL;
-  } else {
-    std::string icon_size_string;
-    options.Get("size", &icon_size_string);
-    icon_size = GetIconSizeByString(icon_size_string);
-  }
-
-  if (!args->GetNext(&callback)) {
-    args->ThrowError("Missing required callback function");
-    return;
-  }
-
-  auto* icon_manager = g_browser_process->GetIconManager();
-  gfx::Image* icon =
-      icon_manager->LookupIconFromFilepath(normalized_path, icon_size);
-  if (icon) {
-    callback.Run(v8::Null(isolate()), *icon);
-  } else {
-    icon_manager->LoadIcon(
-        normalized_path, icon_size,
-        base::Bind(&OnIconDataAvailable, isolate(), callback),
-        &cancelable_task_tracker_);
-  }
-}
-
-std::vector<mate::Dictionary> App::GetAppMetrics(v8::Isolate* isolate) {
-  std::vector<mate::Dictionary> result;
-  int processor_count = base::SysInfo::NumberOfProcessors();
-
-  for (const auto& process_metric : app_metrics_) {
-    mate::Dictionary pid_dict = mate::Dictionary::CreateEmpty(isolate);
-    mate::Dictionary memory_dict = mate::Dictionary::CreateEmpty(isolate);
-    mate::Dictionary cpu_dict = mate::Dictionary::CreateEmpty(isolate);
-
-    pid_dict.SetHidden("simple", true);
-    memory_dict.SetHidden("simple", true);
-    cpu_dict.SetHidden("simple", true);
-
-    memory_dict.Set(
-        "workingSetSize",
-        static_cast<double>(
-            process_metric.second->metrics->GetWorkingSetSize() >> 10));
-    memory_dict.Set(
-        "peakWorkingSetSize",
-        static_cast<double>(
-            process_metric.second->metrics->GetPeakWorkingSetSize() >> 10));
-
-    size_t private_bytes, shared_bytes;
-    if (process_metric.second->metrics->GetMemoryBytes(&private_bytes,
-                                                       &shared_bytes)) {
-      memory_dict.Set("privateBytes", static_cast<double>(private_bytes >> 10));
-      memory_dict.Set("sharedBytes", static_cast<double>(shared_bytes >> 10));
-    }
-
-    pid_dict.Set("memory", memory_dict);
-    cpu_dict.Set(
-        "percentCPUUsage",
-        process_metric.second->metrics->GetPlatformIndependentCPUUsage() /
-            processor_count);
-
-#if !defined(OS_WIN)
-    cpu_dict.Set("idleWakeupsPerSecond",
-                 process_metric.second->metrics->GetIdleWakeupsPerSecond());
-#else
-    // Chrome's underlying process_metrics.cc will throw a non-fatal warning
-    // that this method isn't implemented on Windows, so set it to 0 instead
-    // of calling it
-    cpu_dict.Set("idleWakeupsPerSecond", 0);
-#endif
-
-    pid_dict.Set("cpu", cpu_dict);
-    pid_dict.Set("pid", process_metric.second->pid);
-    pid_dict.Set("type", content::GetProcessTypeNameInEnglish(
-                             process_metric.second->type));
-    result.push_back(pid_dict);
-  }
-
-  return result;
-}
-
-v8::Local<v8::Value> App::GetGPUFeatureStatus(v8::Isolate* isolate) {
-  auto status = content::GetFeatureStatus();
-  base::DictionaryValue temp;
-  return mate::ConvertToV8(isolate, status ? *status : temp);
-}
-
-void App::EnableMixedSandbox(mate::Arguments* args) {
-  if (Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "app.enableMixedSandbox() can only be called "
-        "before app is ready");
-    return;
-  }
-
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  if (command_line->HasSwitch(::switches::kNoSandbox)) {
-#if defined(OS_WIN)
-    const base::CommandLine::CharType* noSandboxArg = L"--no-sandbox";
-#else
-    const base::CommandLine::CharType* noSandboxArg = "--no-sandbox";
-#endif
-
-    // Remove the --no-sandbox switch
-    base::CommandLine::StringVector modified_command_line;
-    for (auto& arg : command_line->argv()) {
-      if (arg.compare(noSandboxArg) != 0) {
-        modified_command_line.push_back(arg);
-      }
-    }
-    command_line->InitFromArgv(modified_command_line);
-  }
-  command_line->AppendSwitch(switches::kEnableMixedSandbox);
-}
-
-#if defined(OS_MACOSX)
-bool App::MoveToApplicationsFolder(mate::Arguments* args) {
-  return ui::cocoa::AtomBundleMover::Move(args);
-}
-
-bool App::IsInApplicationsFolder() {
-  return ui::cocoa::AtomBundleMover::IsCurrentAppInApplicationsFolder();
-}
-#endif
-
-// static
-mate::Handle<App> App::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new App(isolate));
-}
-
-// static
-void App::BuildPrototype(v8::Isolate* isolate,
-                         v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "App"));
-  auto browser = base::Unretained(Browser::Get());
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("quit", base::Bind(&Browser::Quit, browser))
-      .SetMethod("exit", base::Bind(&Browser::Exit, browser))
-      .SetMethod("focus", base::Bind(&Browser::Focus, browser))
-      .SetMethod("getVersion", base::Bind(&Browser::GetVersion, browser))
-      .SetMethod("setVersion", base::Bind(&Browser::SetVersion, browser))
-      .SetMethod("getName", base::Bind(&Browser::GetName, browser))
-      .SetMethod("setName", base::Bind(&Browser::SetName, browser))
-      .SetMethod("isReady", base::Bind(&Browser::is_ready, browser))
-      .SetMethod("whenReady", base::Bind(&Browser::WhenReady, browser))
-      .SetMethod("addRecentDocument",
-                 base::Bind(&Browser::AddRecentDocument, browser))
-      .SetMethod("clearRecentDocuments",
-                 base::Bind(&Browser::ClearRecentDocuments, browser))
-      .SetMethod("setAppUserModelId",
-                 base::Bind(&Browser::SetAppUserModelID, browser))
-      .SetMethod("isDefaultProtocolClient",
-                 base::Bind(&Browser::IsDefaultProtocolClient, browser))
-      .SetMethod("setAsDefaultProtocolClient",
-                 base::Bind(&Browser::SetAsDefaultProtocolClient, browser))
-      .SetMethod("removeAsDefaultProtocolClient",
-                 base::Bind(&Browser::RemoveAsDefaultProtocolClient, browser))
-      .SetMethod("setBadgeCount", base::Bind(&Browser::SetBadgeCount, browser))
-      .SetMethod("getBadgeCount", base::Bind(&Browser::GetBadgeCount, browser))
-      .SetMethod("getLoginItemSettings", &App::GetLoginItemSettings)
-      .SetMethod("setLoginItemSettings",
-                 base::Bind(&Browser::SetLoginItemSettings, browser))
-#if defined(OS_MACOSX)
-      .SetMethod("hide", base::Bind(&Browser::Hide, browser))
-      .SetMethod("show", base::Bind(&Browser::Show, browser))
-      .SetMethod("setUserActivity",
-                 base::Bind(&Browser::SetUserActivity, browser))
-      .SetMethod("getCurrentActivityType",
-                 base::Bind(&Browser::GetCurrentActivityType, browser))
-      .SetMethod("invalidateCurrentActivity",
-                 base::Bind(&Browser::InvalidateCurrentActivity, browser))
-      .SetMethod("updateCurrentActivity",
-                 base::Bind(&Browser::UpdateCurrentActivity, browser))
-      .SetMethod("setAboutPanelOptions",
-                 base::Bind(&Browser::SetAboutPanelOptions, browser))
-#endif
-#if defined(OS_WIN)
-      .SetMethod("setUserTasks", base::Bind(&Browser::SetUserTasks, browser))
-      .SetMethod("getJumpListSettings", &App::GetJumpListSettings)
-      .SetMethod("setJumpList", &App::SetJumpList)
-#endif
-#if defined(OS_LINUX)
-      .SetMethod("isUnityRunning",
-                 base::Bind(&Browser::IsUnityRunning, browser))
-#endif
-      .SetMethod("setAppPath", &App::SetAppPath)
-      .SetMethod("getAppPath", &App::GetAppPath)
-      .SetMethod("setPath", &App::SetPath)
-      .SetMethod("getPath", &App::GetPath)
-      .SetMethod("setDesktopName", &App::SetDesktopName)
-      .SetMethod("getLocale", &App::GetLocale)
-#if defined(USE_NSS_CERTS)
-      .SetMethod("importCertificate", &App::ImportCertificate)
-#endif
-      .SetMethod("hasSingleInstanceLock", &App::HasSingleInstanceLock)
-      .SetMethod("requestSingleInstanceLock", &App::RequestSingleInstanceLock)
-      .SetMethod("releaseSingleInstanceLock", &App::ReleaseSingleInstanceLock)
-      .SetMethod("relaunch", &App::Relaunch)
-      .SetMethod("isAccessibilitySupportEnabled",
-                 &App::IsAccessibilitySupportEnabled)
-      .SetMethod("setAccessibilitySupportEnabled",
-                 &App::SetAccessibilitySupportEnabled)
-      .SetMethod("disableHardwareAcceleration",
-                 &App::DisableHardwareAcceleration)
-      .SetMethod("disableDomainBlockingFor3DAPIs",
-                 &App::DisableDomainBlockingFor3DAPIs)
-      .SetMethod("getFileIcon", &App::GetFileIcon)
-      .SetMethod("getAppMetrics", &App::GetAppMetrics)
-      .SetMethod("getGPUFeatureStatus", &App::GetGPUFeatureStatus)
-// TODO(juturu): Remove in 2.0, deprecate before then with warnings
-#if defined(OS_MACOSX)
-      .SetMethod("moveToApplicationsFolder", &App::MoveToApplicationsFolder)
-      .SetMethod("isInApplicationsFolder", &App::IsInApplicationsFolder)
-#endif
-#if defined(MAS_BUILD)
-      .SetMethod("startAccessingSecurityScopedResource",
-                 &App::StartAccessingSecurityScopedResource)
-#endif
-      .SetMethod("enableMixedSandbox", &App::EnableMixedSandbox);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void AppendSwitch(const std::string& switch_string, mate::Arguments* args) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  if (base::EndsWith(switch_string, "-path",
-                     base::CompareCase::INSENSITIVE_ASCII) ||
-      switch_string == network::switches::kLogNetLog) {
-    base::FilePath path;
-    args->GetNext(&path);
-    command_line->AppendSwitchPath(switch_string, path);
-    return;
-  }
-
-  std::string value;
-  if (args->GetNext(&value))
-    command_line->AppendSwitchASCII(switch_string, value);
-  else
-    command_line->AppendSwitch(switch_string);
-}
-
-#if defined(OS_MACOSX)
-int DockBounce(const std::string& type) {
-  int request_id = -1;
-  if (type == "critical")
-    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_CRITICAL);
-  else if (type == "informational")
-    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_INFORMATIONAL);
-  return request_id;
-}
-
-void DockSetMenu(atom::api::Menu* menu) {
-  Browser::Get()->DockSetMenu(menu->model());
-}
-#endif
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("App", atom::api::App::GetConstructor(isolate)->GetFunction());
-  dict.Set("app", atom::api::App::Create(isolate));
-  dict.SetMethod("appendSwitch", &AppendSwitch);
-  dict.SetMethod("appendArgument", base::Bind(&base::CommandLine::AppendArg,
-                                              base::Unretained(command_line)));
-#if defined(OS_MACOSX)
-  auto browser = base::Unretained(Browser::Get());
-  dict.SetMethod("dockBounce", &DockBounce);
-  dict.SetMethod("dockCancelBounce",
-                 base::Bind(&Browser::DockCancelBounce, browser));
-  dict.SetMethod("dockDownloadFinished",
-                 base::Bind(&Browser::DockDownloadFinished, browser));
-  dict.SetMethod("dockSetBadgeText",
-                 base::Bind(&Browser::DockSetBadgeText, browser));
-  dict.SetMethod("dockGetBadgeText",
-                 base::Bind(&Browser::DockGetBadgeText, browser));
-  dict.SetMethod("dockHide", base::Bind(&Browser::DockHide, browser));
-  dict.SetMethod("dockShow", base::Bind(&Browser::DockShow, browser));
-  dict.SetMethod("dockIsVisible", base::Bind(&Browser::DockIsVisible, browser));
-  dict.SetMethod("dockSetMenu", &DockSetMenu);
-  dict.SetMethod("dockSetIcon", base::Bind(&Browser::DockSetIcon, browser));
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_app, Initialize)
removed in remote
  base   100644 5faf8ebb10e2cc48d6b2f7c259ed727906235d1f atom/browser/api/atom_api_app.h
  our    100644 ee0ad42c05fe33be17146b79cbe3422953516621 atom/browser/api/atom_api_app.h
@@ -1,242 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_APP_H_
-#define ATOM_BROWSER_API_ATOM_API_APP_H_
-
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/browser_observer.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/promise_util.h"
-#include "base/process/process_iterator.h"
-#include "base/task/cancelable_task_tracker.h"
-#include "chrome/browser/icon_manager.h"
-#include "chrome/browser/process_singleton.h"
-#include "content/public/browser/browser_child_process_observer.h"
-#include "content/public/browser/gpu_data_manager_observer.h"
-#include "content/public/browser/render_process_host.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "net/base/completion_callback.h"
-#include "net/ssl/client_cert_identity.h"
-
-#if defined(USE_NSS_CERTS)
-#include "chrome/browser/certificate_manager_model.h"
-#endif
-
-namespace base {
-class FilePath;
-}
-
-namespace mate {
-class Arguments;
-}  // namespace mate
-
-namespace atom {
-
-#if defined(OS_WIN)
-enum class JumpListResult : int;
-#endif
-
-struct ProcessMetric {
-  int type;
-  base::ProcessId pid;
-  std::unique_ptr<base::ProcessMetrics> metrics;
-
-  ProcessMetric(int type,
-                base::ProcessId pid,
-                std::unique_ptr<base::ProcessMetrics> metrics);
-  ~ProcessMetric();
-};
-
-namespace api {
-
-class App : public AtomBrowserClient::Delegate,
-            public mate::EventEmitter<App>,
-            public BrowserObserver,
-            public content::GpuDataManagerObserver,
-            public content::BrowserChildProcessObserver {
- public:
-  using FileIconCallback =
-      base::Callback<void(v8::Local<v8::Value>, const gfx::Image&)>;
-
-  static mate::Handle<App> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(USE_NSS_CERTS)
-  void OnCertificateManagerModelCreated(
-      std::unique_ptr<base::DictionaryValue> options,
-      const net::CompletionCallback& callback,
-      std::unique_ptr<CertificateManagerModel> model);
-#endif
-
-  base::FilePath GetAppPath() const;
-  void RenderProcessReady(content::RenderProcessHost* host);
-  void RenderProcessDisconnected(base::ProcessId host_pid);
-  void PreMainMessageLoopRun();
-
- protected:
-  explicit App(v8::Isolate* isolate);
-  ~App() override;
-
-  // BrowserObserver:
-  void OnBeforeQuit(bool* prevent_default) override;
-  void OnWillQuit(bool* prevent_default) override;
-  void OnWindowAllClosed() override;
-  void OnQuit() override;
-  void OnOpenFile(bool* prevent_default, const std::string& file_path) override;
-  void OnOpenURL(const std::string& url) override;
-  void OnActivate(bool has_visible_windows) override;
-  void OnWillFinishLaunching() override;
-  void OnFinishLaunching(const base::DictionaryValue& launch_info) override;
-  void OnLogin(scoped_refptr<LoginHandler> login_handler,
-               const base::DictionaryValue& request_details) override;
-  void OnAccessibilitySupportChanged() override;
-  void OnPreMainMessageLoopRun() override;
-#if defined(OS_MACOSX)
-  void OnWillContinueUserActivity(bool* prevent_default,
-                                  const std::string& type) override;
-  void OnDidFailToContinueUserActivity(const std::string& type,
-                                       const std::string& error) override;
-  void OnContinueUserActivity(bool* prevent_default,
-                              const std::string& type,
-                              const base::DictionaryValue& user_info) override;
-  void OnUserActivityWasContinued(
-      const std::string& type,
-      const base::DictionaryValue& user_info) override;
-  void OnUpdateUserActivityState(
-      bool* prevent_default,
-      const std::string& type,
-      const base::DictionaryValue& user_info) override;
-  void OnNewWindowForTab() override;
-#endif
-
-  // content::ContentBrowserClient:
-  void AllowCertificateError(
-      content::WebContents* web_contents,
-      int cert_error,
-      const net::SSLInfo& ssl_info,
-      const GURL& request_url,
-      content::ResourceType resource_type,
-      bool strict_enforcement,
-      bool expired_previous_decision,
-      const base::Callback<void(content::CertificateRequestResultType)>&
-          callback) override;
-  void SelectClientCertificate(
-      content::WebContents* web_contents,
-      net::SSLCertRequestInfo* cert_request_info,
-      net::ClientCertIdentityList client_certs,
-      std::unique_ptr<content::ClientCertificateDelegate> delegate) override;
-  bool CanCreateWindow(content::RenderFrameHost* opener,
-                       const GURL& opener_url,
-                       const GURL& opener_top_level_frame_url,
-                       const GURL& source_origin,
-                       content::mojom::WindowContainerType container_type,
-                       const GURL& target_url,
-                       const content::Referrer& referrer,
-                       const std::string& frame_name,
-                       WindowOpenDisposition disposition,
-                       const blink::mojom::WindowFeatures& features,
-                       const std::vector<std::string>& additional_features,
-                       const scoped_refptr<network::ResourceRequestBody>& body,
-                       bool user_gesture,
-                       bool opener_suppressed,
-                       bool* no_javascript_access) override;
-
-  // content::GpuDataManagerObserver:
-  void OnGpuProcessCrashed(base::TerminationStatus status) override;
-
-  // content::BrowserChildProcessObserver:
-  void BrowserChildProcessLaunchedAndConnected(
-      const content::ChildProcessData& data) override;
-  void BrowserChildProcessHostDisconnected(
-      const content::ChildProcessData& data) override;
-  void BrowserChildProcessCrashed(const content::ChildProcessData& data,
-                                  int exit_code) override;
-  void BrowserChildProcessKilled(const content::ChildProcessData& data,
-                                 int exit_code) override;
-
- private:
-  void SetAppPath(const base::FilePath& app_path);
-  void ChildProcessLaunched(int process_type, base::ProcessHandle handle);
-  void ChildProcessDisconnected(base::ProcessId pid);
-
-  // Get/Set the pre-defined path in PathService.
-  base::FilePath GetPath(mate::Arguments* args, const std::string& name);
-  void SetPath(mate::Arguments* args,
-               const std::string& name,
-               const base::FilePath& path);
-
-  void SetDesktopName(const std::string& desktop_name);
-  std::string GetLocale();
-  void OnSecondInstance(const base::CommandLine::StringVector& cmd,
-                        const base::FilePath& cwd);
-  bool HasSingleInstanceLock() const;
-  bool RequestSingleInstanceLock();
-  void ReleaseSingleInstanceLock();
-  bool Relaunch(mate::Arguments* args);
-  void DisableHardwareAcceleration(mate::Arguments* args);
-  void DisableDomainBlockingFor3DAPIs(mate::Arguments* args);
-  bool IsAccessibilitySupportEnabled();
-  void SetAccessibilitySupportEnabled(bool enabled);
-  Browser::LoginItemSettings GetLoginItemSettings(mate::Arguments* args);
-#if defined(USE_NSS_CERTS)
-  void ImportCertificate(const base::DictionaryValue& options,
-                         const net::CompletionCallback& callback);
-#endif
-  void GetFileIcon(const base::FilePath& path, mate::Arguments* args);
-
-  std::vector<mate::Dictionary> GetAppMetrics(v8::Isolate* isolate);
-  v8::Local<v8::Value> GetGPUFeatureStatus(v8::Isolate* isolate);
-  void EnableMixedSandbox(mate::Arguments* args);
-
-#if defined(OS_MACOSX)
-  bool MoveToApplicationsFolder(mate::Arguments* args);
-  bool IsInApplicationsFolder();
-#endif
-#if defined(MAS_BUILD)
-  base::Callback<void()> StartAccessingSecurityScopedResource(
-      mate::Arguments* args);
-#endif
-
-#if defined(OS_WIN)
-  // Get the current Jump List settings.
-  v8::Local<v8::Value> GetJumpListSettings();
-
-  // Set or remove a custom Jump List for the application.
-  JumpListResult SetJumpList(v8::Local<v8::Value> val, mate::Arguments* args);
-#endif  // defined(OS_WIN)
-
-  std::unique_ptr<ProcessSingleton> process_singleton_;
-
-#if defined(USE_NSS_CERTS)
-  std::unique_ptr<CertificateManagerModel> certificate_manager_model_;
-#endif
-
-  // Tracks tasks requesting file icons.
-  base::CancelableTaskTracker cancelable_task_tracker_;
-
-  base::FilePath app_path_;
-
-  using ProcessMetricMap =
-      std::unordered_map<base::ProcessId, std::unique_ptr<atom::ProcessMetric>>;
-  ProcessMetricMap app_metrics_;
-
-  DISALLOW_COPY_AND_ASSIGN(App);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_APP_H_
removed in remote
  base   100644 1a02a54d45337fb64aefe91db454e77a7edf8fb7 atom/browser/api/atom_api_auto_updater.cc
  our    100644 3bee34247e9289fcf5349854c5e6cd69f4b66a0d atom/browser/api/atom_api_auto_updater.cc
@@ -1,155 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_auto_updater.h"
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/node_includes.h"
-#include "base/time/time.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::Time> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::Time& val) {
-    v8::MaybeLocal<v8::Value> date =
-        v8::Date::New(isolate->GetCurrentContext(), val.ToJsTime());
-    if (date.IsEmpty())
-      return v8::Null(isolate);
-    else
-      return date.ToLocalChecked();
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-AutoUpdater::AutoUpdater(v8::Isolate* isolate) {
-  auto_updater::AutoUpdater::SetDelegate(this);
-  Init(isolate);
-}
-
-AutoUpdater::~AutoUpdater() {
-  auto_updater::AutoUpdater::SetDelegate(nullptr);
-}
-
-void AutoUpdater::OnError(const std::string& message) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
-  mate::EmitEvent(
-      isolate(), GetWrapper(), "error",
-      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked(),
-      // Message is also emitted to keep compatibility with old code.
-      message);
-}
-
-void AutoUpdater::OnError(const std::string& message,
-                          const int code,
-                          const std::string& domain) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
-  auto errorObject =
-      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked();
-
-  // add two new params for better error handling
-  errorObject->Set(mate::StringToV8(isolate(), "code"),
-                   v8::Integer::New(isolate(), code));
-  errorObject->Set(mate::StringToV8(isolate(), "domain"),
-                   mate::StringToV8(isolate(), domain));
-
-  mate::EmitEvent(isolate(), GetWrapper(), "error", errorObject, message);
-}
-
-void AutoUpdater::OnCheckingForUpdate() {
-  Emit("checking-for-update");
-}
-
-void AutoUpdater::OnUpdateAvailable() {
-  Emit("update-available");
-}
-
-void AutoUpdater::OnUpdateNotAvailable() {
-  Emit("update-not-available");
-}
-
-void AutoUpdater::OnUpdateDownloaded(const std::string& release_notes,
-                                     const std::string& release_name,
-                                     const base::Time& release_date,
-                                     const std::string& url) {
-  Emit("update-downloaded", release_notes, release_name, release_date, url,
-       // Keep compatibility with old APIs.
-       base::Bind(&AutoUpdater::QuitAndInstall, base::Unretained(this)));
-}
-
-void AutoUpdater::OnWindowAllClosed() {
-  QuitAndInstall();
-}
-
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {
-  auto_updater::AutoUpdater::SetFeedURL(args);
-}
-
-void AutoUpdater::QuitAndInstall() {
-  Emit("before-quit-for-update");
-
-  // If we don't have any window then quitAndInstall immediately.
-  if (WindowList::IsEmpty()) {
-    auto_updater::AutoUpdater::QuitAndInstall();
-    return;
-  }
-
-  // Otherwise do the restart after all windows have been closed.
-  WindowList::AddObserver(this);
-  WindowList::CloseAllWindows();
-}
-
-// static
-mate::Handle<AutoUpdater> AutoUpdater::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new AutoUpdater(isolate));
-}
-
-// static
-void AutoUpdater::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "AutoUpdater"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("checkForUpdates", &auto_updater::AutoUpdater::CheckForUpdates)
-      .SetMethod("getFeedURL", &auto_updater::AutoUpdater::GetFeedURL)
-      .SetMethod("setFeedURL", &AutoUpdater::SetFeedURL)
-      .SetMethod("quitAndInstall", &AutoUpdater::QuitAndInstall);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::AutoUpdater;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("autoUpdater", AutoUpdater::Create(isolate));
-  dict.Set("AutoUpdater", AutoUpdater::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_auto_updater, Initialize)
removed in remote
  base   100644 95b91041e9e36c3a1b21cbcd8f8b559eca193f8a atom/browser/api/atom_api_auto_updater.h
  our    100644 d8875ae0e38457365e0b55d854aae9f672a025e2 atom/browser/api/atom_api_auto_updater.h
@@ -1,61 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
-#define ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
-
-#include <string>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/browser/auto_updater.h"
-#include "atom/browser/window_list_observer.h"
-#include "native_mate/arguments.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-namespace api {
-
-class AutoUpdater : public mate::EventEmitter<AutoUpdater>,
-                    public auto_updater::Delegate,
-                    public WindowListObserver {
- public:
-  static mate::Handle<AutoUpdater> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit AutoUpdater(v8::Isolate* isolate);
-  ~AutoUpdater() override;
-
-  // Delegate implementations.
-  void OnError(const std::string& error) override;
-  void OnError(const std::string& message,
-               const int code,
-               const std::string& domain) override;
-  void OnCheckingForUpdate() override;
-  void OnUpdateAvailable() override;
-  void OnUpdateNotAvailable() override;
-  void OnUpdateDownloaded(const std::string& release_notes,
-                          const std::string& release_name,
-                          const base::Time& release_date,
-                          const std::string& update_url) override;
-
-  // WindowListObserver:
-  void OnWindowAllClosed() override;
-
- private:
-  std::string GetFeedURL();
-  void SetFeedURL(mate::Arguments* args);
-  void QuitAndInstall();
-
-  DISALLOW_COPY_AND_ASSIGN(AutoUpdater);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_AUTO_UPDATER_H_
removed in remote
  base   100644 937a87ea2131194d5edef3e9cab6ecfcff8fc34e atom/browser/api/atom_api_content_tracing.cc
  our    100644 d340b167a5f35fa05280c1195c81542bfc74f0b6 atom/browser/api/atom_api_content_tracing.cc
@@ -1,79 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <set>
-#include <string>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "content/public/browser/tracing_controller.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using content::TracingController;
-
-namespace mate {
-
-template <>
-struct Converter<base::trace_event::TraceConfig> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::trace_event::TraceConfig* out) {
-    Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    std::string category_filter, trace_options;
-    if (!options.Get("categoryFilter", &category_filter) ||
-        !options.Get("traceOptions", &trace_options))
-      return false;
-    *out = base::trace_event::TraceConfig(category_filter, trace_options);
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-using CompletionCallback = base::Callback<void(const base::FilePath&)>;
-
-scoped_refptr<TracingController::TraceDataEndpoint> GetTraceDataEndpoint(
-    const base::FilePath& path,
-    const CompletionCallback& callback) {
-  base::FilePath result_file_path = path;
-  if (result_file_path.empty() && !base::CreateTemporaryFile(&result_file_path))
-    LOG(ERROR) << "Creating temporary file failed";
-
-  return TracingController::CreateFileEndpoint(
-      result_file_path, base::Bind(callback, result_file_path));
-}
-
-void StopRecording(const base::FilePath& path,
-                   const CompletionCallback& callback) {
-  TracingController::GetInstance()->StopTracing(
-      GetTraceDataEndpoint(path, callback));
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  auto controller = base::Unretained(TracingController::GetInstance());
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("getCategories",
-                 base::Bind(&TracingController::GetCategories, controller));
-  dict.SetMethod("startRecording",
-                 base::Bind(&TracingController::StartTracing, controller));
-  dict.SetMethod("stopRecording", &StopRecording);
-  dict.SetMethod(
-      "getTraceBufferUsage",
-      base::Bind(&TracingController::GetTraceBufferUsage, controller));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_content_tracing, Initialize)
removed in remote
  base   100644 e49a2ee2f6763dba123ca45aead308c1955f6bb3 atom/browser/api/atom_api_cookies.cc
  our    100644 daccf443927abdf444845613b6e2916d167f96f3 atom/browser/api/atom_api_cookies.cc
@@ -1,328 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_cookies.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/request_context_delegate.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/time/time.h"
-#include "base/values.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/cookies/canonical_cookie.h"
-#include "net/cookies/cookie_store.h"
-#include "net/cookies/cookie_util.h"
-#include "net/url_request/url_request_context.h"
-#include "net/url_request/url_request_context_getter.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-template <>
-struct Converter<atom::api::Cookies::Error> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::api::Cookies::Error val) {
-    if (val == atom::api::Cookies::SUCCESS)
-      return v8::Null(isolate);
-    else
-      return v8::Exception::Error(StringToV8(isolate, "Setting cookie failed"));
-  }
-};
-
-template <>
-struct Converter<net::CanonicalCookie> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CanonicalCookie& val) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("name", val.Name());
-    dict.Set("value", val.Value());
-    dict.Set("domain", val.Domain());
-    dict.Set("hostOnly", net::cookie_util::DomainIsHostOnly(val.Domain()));
-    dict.Set("path", val.Path());
-    dict.Set("secure", val.IsSecure());
-    dict.Set("httpOnly", val.IsHttpOnly());
-    dict.Set("session", !val.IsPersistent());
-    if (val.IsPersistent())
-      dict.Set("expirationDate", val.ExpiryDate().ToDoubleT());
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<net::CookieChangeCause> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CookieChangeCause& val) {
-    switch (val) {
-      case net::CookieChangeCause::INSERTED:
-      case net::CookieChangeCause::EXPLICIT:
-        return mate::StringToV8(isolate, "explicit");
-      case net::CookieChangeCause::OVERWRITE:
-        return mate::StringToV8(isolate, "overwrite");
-      case net::CookieChangeCause::EXPIRED:
-        return mate::StringToV8(isolate, "expired");
-      case net::CookieChangeCause::EVICTED:
-        return mate::StringToV8(isolate, "evicted");
-      case net::CookieChangeCause::EXPIRED_OVERWRITE:
-        return mate::StringToV8(isolate, "expired-overwrite");
-      default:
-        return mate::StringToV8(isolate, "unknown");
-    }
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// Returns whether |domain| matches |filter|.
-bool MatchesDomain(std::string filter, const std::string& domain) {
-  // Add a leading '.' character to the filter domain if it doesn't exist.
-  if (net::cookie_util::DomainIsHostOnly(filter))
-    filter.insert(0, ".");
-
-  std::string sub_domain(domain);
-  // Strip any leading '.' character from the input cookie domain.
-  if (!net::cookie_util::DomainIsHostOnly(sub_domain))
-    sub_domain = sub_domain.substr(1);
-
-  // Now check whether the domain argument is a subdomain of the filter domain.
-  for (sub_domain.insert(0, "."); sub_domain.length() >= filter.length();) {
-    if (sub_domain == filter)
-      return true;
-    const size_t next_dot = sub_domain.find('.', 1);  // Skip over leading dot.
-    sub_domain.erase(0, next_dot);
-  }
-  return false;
-}
-
-// Returns whether |cookie| matches |filter|.
-bool MatchesCookie(const base::DictionaryValue* filter,
-                   const net::CanonicalCookie& cookie) {
-  std::string str;
-  bool b;
-  if (filter->GetString("name", &str) && str != cookie.Name())
-    return false;
-  if (filter->GetString("path", &str) && str != cookie.Path())
-    return false;
-  if (filter->GetString("domain", &str) && !MatchesDomain(str, cookie.Domain()))
-    return false;
-  if (filter->GetBoolean("secure", &b) && b != cookie.IsSecure())
-    return false;
-  if (filter->GetBoolean("session", &b) && b != !cookie.IsPersistent())
-    return false;
-  return true;
-}
-
-// Helper to returns the CookieStore.
-inline net::CookieStore* GetCookieStore(
-    scoped_refptr<net::URLRequestContextGetter> getter) {
-  return getter->GetURLRequestContext()->cookie_store();
-}
-
-// Run |callback| on UI thread.
-void RunCallbackInUI(const base::Closure& callback) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
-}
-
-// Remove cookies from |list| not matching |filter|, and pass it to |callback|.
-void FilterCookies(std::unique_ptr<base::DictionaryValue> filter,
-                   const Cookies::GetCallback& callback,
-                   const net::CookieList& list) {
-  net::CookieList result;
-  for (const auto& cookie : list) {
-    if (MatchesCookie(filter.get(), cookie))
-      result.push_back(cookie);
-  }
-  RunCallbackInUI(base::Bind(callback, Cookies::SUCCESS, result));
-}
-
-// Receives cookies matching |filter| in IO thread.
-void GetCookiesOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                    std::unique_ptr<base::DictionaryValue> filter,
-                    const Cookies::GetCallback& callback) {
-  std::string url;
-  filter->GetString("url", &url);
-
-  auto filtered_callback =
-      base::Bind(FilterCookies, base::Passed(&filter), callback);
-
-  // Empty url will match all url cookies.
-  if (url.empty())
-    GetCookieStore(getter)->GetAllCookiesAsync(filtered_callback);
-  else
-    GetCookieStore(getter)->GetAllCookiesForURLAsync(GURL(url),
-                                                     filtered_callback);
-}
-
-// Removes cookie with |url| and |name| in IO thread.
-void RemoveCookieOnIOThread(scoped_refptr<net::URLRequestContextGetter> getter,
-                            const GURL& url,
-                            const std::string& name,
-                            const base::Closure& callback) {
-  GetCookieStore(getter)->DeleteCookieAsync(
-      url, name, base::BindOnce(RunCallbackInUI, callback));
-}
-
-// Callback of SetCookie.
-void OnSetCookie(const Cookies::SetCallback& callback, bool success) {
-  RunCallbackInUI(
-      base::Bind(callback, success ? Cookies::SUCCESS : Cookies::FAILED));
-}
-
-// Flushes cookie store in IO thread.
-void FlushCookieStoreOnIOThread(
-    scoped_refptr<net::URLRequestContextGetter> getter,
-    const base::Closure& callback) {
-  GetCookieStore(getter)->FlushStore(base::BindOnce(RunCallbackInUI, callback));
-}
-
-// Sets cookie with |details| in IO thread.
-void SetCookieOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                   std::unique_ptr<base::DictionaryValue> details,
-                   const Cookies::SetCallback& callback) {
-  std::string url, name, value, domain, path;
-  bool secure = false;
-  bool http_only = false;
-  double creation_date;
-  double expiration_date;
-  double last_access_date;
-  details->GetString("url", &url);
-  details->GetString("name", &name);
-  details->GetString("value", &value);
-  details->GetString("domain", &domain);
-  details->GetString("path", &path);
-  details->GetBoolean("secure", &secure);
-  details->GetBoolean("httpOnly", &http_only);
-
-  base::Time creation_time;
-  if (details->GetDouble("creationDate", &creation_date)) {
-    creation_time = (creation_date == 0)
-                        ? base::Time::UnixEpoch()
-                        : base::Time::FromDoubleT(creation_date);
-  }
-
-  base::Time expiration_time;
-  if (details->GetDouble("expirationDate", &expiration_date)) {
-    expiration_time = (expiration_date == 0)
-                          ? base::Time::UnixEpoch()
-                          : base::Time::FromDoubleT(expiration_date);
-  }
-
-  base::Time last_access_time;
-  if (details->GetDouble("lastAccessDate", &last_access_date)) {
-    last_access_time = (last_access_date == 0)
-                           ? base::Time::UnixEpoch()
-                           : base::Time::FromDoubleT(last_access_date);
-  }
-
-  std::unique_ptr<net::CanonicalCookie> canonical_cookie(
-      net::CanonicalCookie::CreateSanitizedCookie(
-          GURL(url), name, value, domain, path, creation_time, expiration_time,
-          last_access_time, secure, http_only,
-          net::CookieSameSite::DEFAULT_MODE, net::COOKIE_PRIORITY_DEFAULT));
-  auto completion_callback = base::BindOnce(OnSetCookie, callback);
-  if (!canonical_cookie || !canonical_cookie->IsCanonical()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  if (url.empty()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  if (name.empty()) {
-    std::move(completion_callback).Run(false);
-    return;
-  }
-  GetCookieStore(getter)->SetCanonicalCookieAsync(
-      std::move(canonical_cookie), secure, http_only,
-      std::move(completion_callback));
-}
-
-}  // namespace
-
-Cookies::Cookies(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : browser_context_(browser_context) {
-  Init(isolate);
-  cookie_change_subscription_ =
-      browser_context->GetRequestContextDelegate()
-          ->RegisterCookieChangeCallback(
-              base::Bind(&Cookies::OnCookieChanged, base::Unretained(this)));
-}
-
-Cookies::~Cookies() {}
-
-void Cookies::Get(const base::DictionaryValue& filter,
-                  const GetCallback& callback) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(filter.Clone()));
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(GetCookiesOnIO, base::RetainedRef(getter), std::move(copy),
-                     callback));
-}
-
-void Cookies::Remove(const GURL& url,
-                     const std::string& name,
-                     const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(RemoveCookieOnIOThread, base::RetainedRef(getter), url,
-                     name, callback));
-}
-
-void Cookies::Set(const base::DictionaryValue& details,
-                  const SetCallback& callback) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(details.Clone()));
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(SetCookieOnIO, base::RetainedRef(getter), std::move(copy),
-                     callback));
-}
-
-void Cookies::FlushStore(const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(FlushCookieStoreOnIOThread, base::RetainedRef(getter),
-                     callback));
-}
-
-void Cookies::OnCookieChanged(const CookieDetails* details) {
-  Emit("changed", *(details->cookie), details->cause, details->removed);
-}
-
-// static
-mate::Handle<Cookies> Cookies::Create(v8::Isolate* isolate,
-                                      AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new Cookies(isolate, browser_context));
-}
-
-// static
-void Cookies::BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Cookies"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("get", &Cookies::Get)
-      .SetMethod("remove", &Cookies::Remove)
-      .SetMethod("set", &Cookies::Set)
-      .SetMethod("flushStore", &Cookies::FlushStore);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 302fd1b25110ceec6a1124c02c35d8475ed623b6 atom/browser/api/atom_api_cookies.h
  our    100644 8a83a64ca1012e11cb9629ea172f578eca545abe atom/browser/api/atom_api_cookies.h
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_COOKIES_H_
-#define ATOM_BROWSER_API_ATOM_API_COOKIES_H_
-
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/net/cookie_details.h"
-#include "base/callback_list.h"
-#include "native_mate/handle.h"
-#include "net/cookies/canonical_cookie.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace net {
-class URLRequestContextGetter;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class Cookies : public mate::TrackableObject<Cookies> {
- public:
-  enum Error {
-    SUCCESS,
-    FAILED,
-  };
-
-  using GetCallback = base::Callback<void(Error, const net::CookieList&)>;
-  using SetCallback = base::Callback<void(Error)>;
-
-  static mate::Handle<Cookies> Create(v8::Isolate* isolate,
-                                      AtomBrowserContext* browser_context);
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Cookies(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Cookies() override;
-
-  void Get(const base::DictionaryValue& filter, const GetCallback& callback);
-  void Remove(const GURL& url,
-              const std::string& name,
-              const base::Closure& callback);
-  void Set(const base::DictionaryValue& details, const SetCallback& callback);
-  void FlushStore(const base::Closure& callback);
-
-  // AtomBrowserContext::RegisterCookieChangeCallback subscription:
-  void OnCookieChanged(const CookieDetails*);
-
- private:
-  std::unique_ptr<base::CallbackList<void(const CookieDetails*)>::Subscription>
-      cookie_change_subscription_;
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(Cookies);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_COOKIES_H_
removed in remote
  base   100644 eab60311f3dd16070428a4fbd3bc4ba942f23c51 atom/browser/api/atom_api_debugger.cc
  our    100644 603382d8a7ac5de596cfdc4ca419f5243287166e atom/browser/api/atom_api_debugger.cc
@@ -1,177 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_debugger.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/json/json_reader.h"
-#include "base/json/json_writer.h"
-#include "base/memory/ptr_util.h"
-#include "content/public/browser/devtools_agent_host.h"
-#include "content/public/browser/web_contents.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-#include "atom/common/node_includes.h"
-
-using content::DevToolsAgentHost;
-
-namespace atom {
-
-namespace api {
-
-Debugger::Debugger(v8::Isolate* isolate, content::WebContents* web_contents)
-    : web_contents_(web_contents) {
-  Init(isolate);
-}
-
-Debugger::~Debugger() {}
-
-void Debugger::AgentHostClosed(DevToolsAgentHost* agent_host) {
-  std::string detach_reason = "target closed";
-  Emit("detach", detach_reason);
-}
-
-void Debugger::DispatchProtocolMessage(DevToolsAgentHost* agent_host,
-                                       const std::string& message) {
-  DCHECK(agent_host == agent_host_.get());
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  std::unique_ptr<base::Value> parsed_message = base::JSONReader::Read(message);
-  if (!parsed_message || !parsed_message->is_dict())
-    return;
-  base::DictionaryValue* dict =
-      static_cast<base::DictionaryValue*>(parsed_message.get());
-  int id;
-  if (!dict->GetInteger("id", &id)) {
-    std::string method;
-    if (!dict->GetString("method", &method))
-      return;
-    base::DictionaryValue* params_value = nullptr;
-    base::DictionaryValue params;
-    if (dict->GetDictionary("params", &params_value))
-      params.Swap(params_value);
-    Emit("message", method, params);
-  } else {
-    auto send_command_callback = pending_requests_[id];
-    pending_requests_.erase(id);
-    if (send_command_callback.is_null())
-      return;
-    base::DictionaryValue* error_body = nullptr;
-    base::DictionaryValue error;
-    if (dict->GetDictionary("error", &error_body))
-      error.Swap(error_body);
-
-    base::DictionaryValue* result_body = nullptr;
-    base::DictionaryValue result;
-    if (dict->GetDictionary("result", &result_body))
-      result.Swap(result_body);
-    send_command_callback.Run(error, result);
-  }
-}
-
-void Debugger::Attach(mate::Arguments* args) {
-  std::string protocol_version;
-  args->GetNext(&protocol_version);
-
-  if (!protocol_version.empty() &&
-      !DevToolsAgentHost::IsSupportedProtocolVersion(protocol_version)) {
-    args->ThrowError("Requested protocol version is not supported");
-    return;
-  }
-  agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents_);
-  if (!agent_host_.get()) {
-    args->ThrowError("No target available");
-    return;
-  }
-  if (agent_host_->IsAttached()) {
-    args->ThrowError("Another debugger is already attached to this target");
-    return;
-  }
-
-  agent_host_->AttachClient(this);
-}
-
-bool Debugger::IsAttached() {
-  return agent_host_.get() ? agent_host_->IsAttached() : false;
-}
-
-void Debugger::Detach() {
-  if (!agent_host_.get())
-    return;
-  agent_host_->DetachClient(this);
-  AgentHostClosed(agent_host_.get());
-  agent_host_ = nullptr;
-}
-
-void Debugger::SendCommand(mate::Arguments* args) {
-  if (!agent_host_.get())
-    return;
-
-  std::string method;
-  if (!args->GetNext(&method)) {
-    args->ThrowError();
-    return;
-  }
-  base::DictionaryValue command_params;
-  args->GetNext(&command_params);
-  SendCommandCallback callback;
-  args->GetNext(&callback);
-
-  base::DictionaryValue request;
-  int request_id = ++previous_request_id_;
-  pending_requests_[request_id] = callback;
-  request.SetInteger("id", request_id);
-  request.SetString("method", method);
-  if (!command_params.empty())
-    request.Set("params", base::WrapUnique(command_params.DeepCopy()));
-
-  std::string json_args;
-  base::JSONWriter::Write(request, &json_args);
-  agent_host_->DispatchProtocolMessage(this, json_args);
-}
-
-// static
-mate::Handle<Debugger> Debugger::Create(v8::Isolate* isolate,
-                                        content::WebContents* web_contents) {
-  return mate::CreateHandle(isolate, new Debugger(isolate, web_contents));
-}
-
-// static
-void Debugger::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Debugger"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("attach", &Debugger::Attach)
-      .SetMethod("isAttached", &Debugger::IsAttached)
-      .SetMethod("detach", &Debugger::Detach)
-      .SetMethod("sendCommand", &Debugger::SendCommand);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Debugger;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary(isolate, exports)
-      .Set("Debugger", Debugger::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_debugger, Initialize);
removed in remote
  base   100644 5454108e8b0907056f69f95ac40bfd0ffd59e4a6 atom/browser/api/atom_api_debugger.h
  our    100644 d3774dae9dc58ed005274bd756b1b40cb7ca7b0e atom/browser/api/atom_api_debugger.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
-#define ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/callback.h"
-#include "base/values.h"
-#include "content/public/browser/devtools_agent_host_client.h"
-#include "native_mate/handle.h"
-
-namespace content {
-class DevToolsAgentHost;
-class WebContents;
-}  // namespace content
-
-namespace mate {
-class Arguments;
-}
-
-namespace atom {
-
-namespace api {
-
-class Debugger : public mate::TrackableObject<Debugger>,
-                 public content::DevToolsAgentHostClient {
- public:
-  using SendCommandCallback =
-      base::Callback<void(const base::DictionaryValue&,
-                          const base::DictionaryValue&)>;
-
-  static mate::Handle<Debugger> Create(v8::Isolate* isolate,
-                                       content::WebContents* web_contents);
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Debugger(v8::Isolate* isolate, content::WebContents* web_contents);
-  ~Debugger() override;
-
-  // content::DevToolsAgentHostClient:
-  void AgentHostClosed(content::DevToolsAgentHost* agent_host) override;
-  void DispatchProtocolMessage(content::DevToolsAgentHost* agent_host,
-                               const std::string& message) override;
-
- private:
-  using PendingRequestMap = std::map<int, SendCommandCallback>;
-
-  void Attach(mate::Arguments* args);
-  bool IsAttached();
-  void Detach();
-  void SendCommand(mate::Arguments* args);
-
-  content::WebContents* web_contents_;  // Weak Reference.
-  scoped_refptr<content::DevToolsAgentHost> agent_host_;
-
-  PendingRequestMap pending_requests_;
-  int previous_request_id_ = 0;
-
-  DISALLOW_COPY_AND_ASSIGN(Debugger);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DEBUGGER_H_
removed in remote
  base   100644 cdae6f0c44cd962f0a512df70bfe2bd79f603a5f atom/browser/api/atom_api_desktop_capturer.cc
  our    100644 135b4edd11048a4635f9017f569f4b4ae644a09c atom/browser/api/atom_api_desktop_capturer.cc
@@ -1,207 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_desktop_capturer.h"
-
-#include <vector>
-
-using base::PlatformThreadRef;
-
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/media/desktop_media_list.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/desktop_capture.h"
-#include "native_mate/dictionary.h"
-#include "third_party/webrtc/modules/desktop_capture/desktop_capture_options.h"
-#include "third_party/webrtc/modules/desktop_capture/desktop_capturer.h"
-#if defined(OS_WIN)
-#include "third_party/webrtc/modules/desktop_capture/win/dxgi_duplicator_controller.h"
-#include "third_party/webrtc/modules/desktop_capture/win/screen_capturer_win_directx.h"
-#include "ui/display/win/display_info.h"
-#endif  // defined(OS_WIN)
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<atom::api::DesktopCapturer::Source> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const atom::api::DesktopCapturer::Source& source) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    content::DesktopMediaID id = source.media_list_source.id;
-    dict.Set("name", base::UTF16ToUTF8(source.media_list_source.name));
-    dict.Set("id", id.ToString());
-    dict.Set("thumbnail",
-             atom::api::NativeImage::Create(
-                 isolate, gfx::Image(source.media_list_source.thumbnail)));
-    dict.Set("display_id", source.display_id);
-    return ConvertToV8(isolate, dict);
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void EmitFinished(
-    const std::vector<atom::api::DesktopCapturer::Source>& sources,
-    atom::api::DesktopCapturer* cap) {
-  cap->Emit("finished", sources);
-}
-
-void StartHandlingTask(bool capture_window,
-                       bool capture_screen,
-                       const gfx::Size& thumbnail_size,
-                       atom::api::DesktopCapturer* cap) {
-#if defined(OS_WIN)
-  if (content::desktop_capture::CreateDesktopCaptureOptions()
-      .allow_directx_capturer()) {
-    // DxgiDuplicatorController should be alive in this scope according to
-    // screen_capturer_win.cc.
-    auto duplicator = webrtc::DxgiDuplicatorController::Instance();
-    cap->using_directx_capturer_ =
-        webrtc::ScreenCapturerWinDirectx::IsSupported();
-  }
-#endif  // defined(OS_WIN)
-  std::unique_ptr<webrtc::DesktopCapturer> screen_capturer(
-      capture_screen ? content::desktop_capture::CreateScreenCapturer()
-                     : nullptr);
-  std::unique_ptr<webrtc::DesktopCapturer> window_capturer(
-      capture_window ? content::desktop_capture::CreateWindowCapturer()
-                     : nullptr);
-  cap->media_list_.reset(new NativeDesktopMediaList(
-      std::move(screen_capturer), std::move(window_capturer)));
-
-  cap->media_list_->SetThumbnailSize(thumbnail_size);
-  cap->media_list_->StartUpdating(cap);
-}
-
-void OnRefreshFinishedTask(atom::api::DesktopCapturer* cap) {
-  const auto media_list_sources = cap->media_list_->GetSources();
-  std::vector<atom::api::DesktopCapturer::Source> sources;
-  for (const auto& media_list_source : media_list_sources) {
-    sources.emplace_back(
-        atom::api::DesktopCapturer::Source{media_list_source, std::string()});
-  }
-
-#if defined(OS_WIN)
-  // Gather the same unique screen IDs used by the electron.screen API in order
-  // to provide an association between it and desktopCapturer/getUserMedia.
-  // This is only required when using the DirectX capturer, otherwise the IDs
-  // across the APIs already match.
-  if (cap->using_directx_capturer_) {
-    std::vector<std::string> device_names;
-    // Crucially, this list of device names will be in the same order as
-    // |media_list_sources|.
-    webrtc::DxgiDuplicatorController::Instance()->GetDeviceNames(&device_names);
-    int device_name_index = 0;
-    for (auto& source : sources) {
-      if (source.media_list_source.id.type ==
-          content::DesktopMediaID::TYPE_SCREEN) {
-        const auto& device_name = device_names[device_name_index++];
-        std::wstring wide_device_name;
-        base::UTF8ToWide(device_name.c_str(), device_name.size(),
-                         &wide_device_name);
-        const int64_t device_id =
-            display::win::DisplayInfo::DeviceIdFromDeviceName(
-                wide_device_name.c_str());
-        source.display_id = base::Int64ToString(device_id);
-      }
-    }
-  }
-#elif defined(OS_MACOSX)
-  // On Mac, the IDs across the APIs match.
-  for (auto& source : sources) {
-    if (source.media_list_source.id.type ==
-        content::DesktopMediaID::TYPE_SCREEN) {
-      source.display_id = base::Int64ToString(source.media_list_source.id.id);
-    }
-  }
-#endif  // defined(OS_WIN)
-  // TODO(ajmacd): Add Linux support. The IDs across APIs differ but Chrome only
-  // supports capturing the entire desktop on Linux. Revisit this if individual
-  // screen support is added.
-
-  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
-                                   base::Bind(EmitFinished, sources, cap));
-}
-
-}  // namespace
-
-namespace atom {
-
-namespace api {
-
-DesktopCapturer::DesktopCapturer(v8::Isolate* isolate) {
-  Init(isolate);
-  capture_thread_ = base::CreateSequencedTaskRunnerWithTraits(
-      {base::WithBaseSyncPrimitives(), base::MayBlock(),
-       base::TaskPriority::USER_VISIBLE});
-}
-
-DesktopCapturer::~DesktopCapturer() {}
-
-void DesktopCapturer::StartHandling(bool capture_window,
-                                    bool capture_screen,
-                                    const gfx::Size& thumbnail_size) {
-  capture_thread_->PostTask(
-      FROM_HERE, base::BindOnce(StartHandlingTask, capture_window,
-                                capture_screen, thumbnail_size, this));
-}
-
-void DesktopCapturer::OnSourceAdded(int index) {}
-
-void DesktopCapturer::OnSourceRemoved(int index) {}
-
-void DesktopCapturer::OnSourceMoved(int old_index, int new_index) {}
-
-void DesktopCapturer::OnSourceNameChanged(int index) {}
-
-void DesktopCapturer::OnSourceThumbnailChanged(int index) {}
-
-bool DesktopCapturer::OnRefreshFinished() {
-  capture_thread_->PostTask(FROM_HERE,
-                            base::BindOnce(OnRefreshFinishedTask, this));
-  return false;
-}
-
-// static
-mate::Handle<DesktopCapturer> DesktopCapturer::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new DesktopCapturer(isolate));
-}
-
-// static
-void DesktopCapturer::BuildPrototype(
-    v8::Isolate* isolate,
-    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "DesktopCapturer"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("startHandling", &DesktopCapturer::StartHandling);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("desktopCapturer", atom::api::DesktopCapturer::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_desktop_capturer, Initialize);
removed in remote
  base   100644 c22c8a44835f66cb44a711ff5775b7274809ebe3 atom/browser/api/atom_api_desktop_capturer.h
  our    100644 88960e46d49dd0b68c51647be18066a2d097ce79 atom/browser/api/atom_api_desktop_capturer.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
-#define ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
-
-#include <string>
-
-#include "atom/browser/api/event_emitter.h"
-#include "chrome/browser/media/desktop_media_list_observer.h"
-#include "chrome/browser/media/native_desktop_media_list.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-namespace api {
-
-class DesktopCapturer : public mate::EventEmitter<DesktopCapturer>,
-                        public DesktopMediaListObserver {
- public:
-  struct Source {
-    DesktopMediaList::Source media_list_source;
-    // Will be an empty string if not available.
-    std::string display_id;
-  };
-
-  static mate::Handle<DesktopCapturer> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  void StartHandling(bool capture_window,
-                     bool capture_screen,
-                     const gfx::Size& thumbnail_size);
-
-  std::unique_ptr<DesktopMediaList> media_list_;
-#if defined(OS_WIN)
-  bool using_directx_capturer_ = false;
-#endif  // defined(OS_WIN)
-
- protected:
-  explicit DesktopCapturer(v8::Isolate* isolate);
-  ~DesktopCapturer() override;
-
-  // DesktopMediaListObserver overrides.
-  void OnSourceAdded(int index) override;
-  void OnSourceRemoved(int index) override;
-  void OnSourceMoved(int old_index, int new_index) override;
-  void OnSourceNameChanged(int index) override;
-  void OnSourceThumbnailChanged(int index) override;
-  bool OnRefreshFinished() override;
-
- private:
-  scoped_refptr<base::SequencedTaskRunner> capture_thread_;
-
-  DISALLOW_COPY_AND_ASSIGN(DesktopCapturer);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DESKTOP_CAPTURER_H_
removed in remote
  base   100644 0a544c56468cb67dce5793a15535a772bc2b17de atom/browser/api/atom_api_dialog.cc
  our    100644 bdbaffbb5bd3889082a985189a3688ca1f91e66d atom/browser/api/atom_api_dialog.cc
@@ -1,142 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/certificate_trust.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/ui/message_box.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<file_dialog::Filter> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     file_dialog::Filter* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    if (!dict.Get("name", &(out->first)))
-      return false;
-    if (!dict.Get("extensions", &(out->second)))
-      return false;
-    return true;
-  }
-};
-
-template <>
-struct Converter<file_dialog::DialogSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     file_dialog::DialogSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    dict.Get("window", &(out->parent_window));
-    dict.Get("title", &(out->title));
-    dict.Get("message", &(out->message));
-    dict.Get("buttonLabel", &(out->button_label));
-    dict.Get("nameFieldLabel", &(out->name_field_label));
-    dict.Get("defaultPath", &(out->default_path));
-    dict.Get("filters", &(out->filters));
-    dict.Get("properties", &(out->properties));
-    dict.Get("showsTagField", &(out->shows_tag_field));
-#if defined(MAS_BUILD)
-    dict.Get("securityScopedBookmarks", &(out->security_scoped_bookmarks));
-#endif
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void ShowMessageBox(int type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    atom::NativeWindow* window,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  atom::MessageBoxCallback callback;
-  if (mate::Converter<atom::MessageBoxCallback>::FromV8(args->isolate(), peek,
-                                                        &callback)) {
-    atom::ShowMessageBox(window, static_cast<atom::MessageBoxType>(type),
-                         buttons, default_id, cancel_id, options, title,
-                         message, detail, checkbox_label, checkbox_checked,
-                         icon, callback);
-  } else {
-    int chosen = atom::ShowMessageBox(
-        window, static_cast<atom::MessageBoxType>(type), buttons, default_id,
-        cancel_id, options, title, message, detail, icon);
-    args->Return(chosen);
-  }
-}
-
-void ShowOpenDialog(const file_dialog::DialogSettings& settings,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  file_dialog::OpenDialogCallback callback;
-  if (mate::Converter<file_dialog::OpenDialogCallback>::FromV8(
-          args->isolate(), peek, &callback)) {
-    file_dialog::ShowOpenDialog(settings, callback);
-  } else {
-    std::vector<base::FilePath> paths;
-    if (file_dialog::ShowOpenDialog(settings, &paths))
-      args->Return(paths);
-  }
-}
-
-void ShowSaveDialog(const file_dialog::DialogSettings& settings,
-                    mate::Arguments* args) {
-  v8::Local<v8::Value> peek = args->PeekNext();
-  file_dialog::SaveDialogCallback callback;
-  if (mate::Converter<file_dialog::SaveDialogCallback>::FromV8(
-          args->isolate(), peek, &callback)) {
-    file_dialog::ShowSaveDialog(settings, callback);
-  } else {
-    base::FilePath path;
-    if (file_dialog::ShowSaveDialog(settings, &path))
-      args->Return(path);
-  }
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("showMessageBox", &ShowMessageBox);
-  dict.SetMethod("showErrorBox", &atom::ShowErrorBox);
-  dict.SetMethod("showOpenDialog", &ShowOpenDialog);
-  dict.SetMethod("showSaveDialog", &ShowSaveDialog);
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  dict.SetMethod("showCertificateTrustDialog",
-                 &certificate_trust::ShowCertificateTrust);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_dialog, Initialize)
removed in remote
  base   100644 3edd5f9c25492f490dbda270295b17040d4c4e38 atom/browser/api/atom_api_download_item.cc
  our    100644 4fa4d5517b4adbf5ee7e3f68489f53d3de9d5e12 atom/browser/api/atom_api_download_item.cc
@@ -1,241 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_download_item.h"
-
-#include <map>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/dictionary.h"
-#include "net/base/filename_util.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<download::DownloadItem::DownloadState> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      download::DownloadItem::DownloadState state) {
-    std::string download_state;
-    switch (state) {
-      case download::DownloadItem::IN_PROGRESS:
-        download_state = "progressing";
-        break;
-      case download::DownloadItem::COMPLETE:
-        download_state = "completed";
-        break;
-      case download::DownloadItem::CANCELLED:
-        download_state = "cancelled";
-        break;
-      case download::DownloadItem::INTERRUPTED:
-        download_state = "interrupted";
-        break;
-      default:
-        break;
-    }
-    return ConvertToV8(isolate, download_state);
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-std::map<uint32_t, v8::Global<v8::Object>> g_download_item_objects;
-
-}  // namespace
-
-DownloadItem::DownloadItem(v8::Isolate* isolate,
-                           download::DownloadItem* download_item)
-    : download_item_(download_item) {
-  download_item_->AddObserver(this);
-  Init(isolate);
-  AttachAsUserData(download_item);
-}
-
-DownloadItem::~DownloadItem() {
-  if (download_item_) {
-    // Destroyed by either garbage collection or destroy().
-    download_item_->RemoveObserver(this);
-    download_item_->Remove();
-  }
-
-  // Remove from the global map.
-  g_download_item_objects.erase(weak_map_id());
-}
-
-void DownloadItem::OnDownloadUpdated(download::DownloadItem* item) {
-  if (download_item_->IsDone()) {
-    Emit("done", item->GetState());
-    // Destroy the item once item is downloaded.
-    base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE,
-                                                  GetDestroyClosure());
-  } else {
-    Emit("updated", item->GetState());
-  }
-}
-
-void DownloadItem::OnDownloadDestroyed(download::DownloadItem* download_item) {
-  download_item_ = nullptr;
-  // Destroy the native class immediately when downloadItem is destroyed.
-  delete this;
-}
-
-void DownloadItem::Pause() {
-  download_item_->Pause();
-}
-
-bool DownloadItem::IsPaused() const {
-  return download_item_->IsPaused();
-}
-
-void DownloadItem::Resume() {
-  download_item_->Resume();
-}
-
-bool DownloadItem::CanResume() const {
-  return download_item_->CanResume();
-}
-
-void DownloadItem::Cancel() {
-  download_item_->Cancel(true);
-}
-
-int64_t DownloadItem::GetReceivedBytes() const {
-  return download_item_->GetReceivedBytes();
-}
-
-int64_t DownloadItem::GetTotalBytes() const {
-  return download_item_->GetTotalBytes();
-}
-
-std::string DownloadItem::GetMimeType() const {
-  return download_item_->GetMimeType();
-}
-
-bool DownloadItem::HasUserGesture() const {
-  return download_item_->HasUserGesture();
-}
-
-std::string DownloadItem::GetFilename() const {
-  return base::UTF16ToUTF8(
-      net::GenerateFileName(GetURL(), GetContentDisposition(), std::string(),
-                            download_item_->GetSuggestedFilename(),
-                            GetMimeType(), "download")
-          .LossyDisplayName());
-}
-
-std::string DownloadItem::GetContentDisposition() const {
-  return download_item_->GetContentDisposition();
-}
-
-const GURL& DownloadItem::GetURL() const {
-  return download_item_->GetURL();
-}
-
-const std::vector<GURL>& DownloadItem::GetURLChain() const {
-  return download_item_->GetUrlChain();
-}
-
-download::DownloadItem::DownloadState DownloadItem::GetState() const {
-  return download_item_->GetState();
-}
-
-bool DownloadItem::IsDone() const {
-  return download_item_->IsDone();
-}
-
-void DownloadItem::SetSavePath(const base::FilePath& path) {
-  save_path_ = path;
-}
-
-base::FilePath DownloadItem::GetSavePath() const {
-  return save_path_;
-}
-
-std::string DownloadItem::GetLastModifiedTime() const {
-  return download_item_->GetLastModifiedTime();
-}
-
-std::string DownloadItem::GetETag() const {
-  return download_item_->GetETag();
-}
-
-double DownloadItem::GetStartTime() const {
-  return download_item_->GetStartTime().ToDoubleT();
-}
-
-// static
-void DownloadItem::BuildPrototype(v8::Isolate* isolate,
-                                  v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "DownloadItem"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("pause", &DownloadItem::Pause)
-      .SetMethod("isPaused", &DownloadItem::IsPaused)
-      .SetMethod("resume", &DownloadItem::Resume)
-      .SetMethod("canResume", &DownloadItem::CanResume)
-      .SetMethod("cancel", &DownloadItem::Cancel)
-      .SetMethod("getReceivedBytes", &DownloadItem::GetReceivedBytes)
-      .SetMethod("getTotalBytes", &DownloadItem::GetTotalBytes)
-      .SetMethod("getMimeType", &DownloadItem::GetMimeType)
-      .SetMethod("hasUserGesture", &DownloadItem::HasUserGesture)
-      .SetMethod("getFilename", &DownloadItem::GetFilename)
-      .SetMethod("getContentDisposition", &DownloadItem::GetContentDisposition)
-      .SetMethod("getURL", &DownloadItem::GetURL)
-      .SetMethod("getURLChain", &DownloadItem::GetURLChain)
-      .SetMethod("getState", &DownloadItem::GetState)
-      .SetMethod("isDone", &DownloadItem::IsDone)
-      .SetMethod("setSavePath", &DownloadItem::SetSavePath)
-      .SetMethod("getSavePath", &DownloadItem::GetSavePath)
-      .SetMethod("getLastModifiedTime", &DownloadItem::GetLastModifiedTime)
-      .SetMethod("getETag", &DownloadItem::GetETag)
-      .SetMethod("getStartTime", &DownloadItem::GetStartTime);
-}
-
-// static
-mate::Handle<DownloadItem> DownloadItem::Create(v8::Isolate* isolate,
-                                                download::DownloadItem* item) {
-  auto* existing = TrackableObject::FromWrappedClass(isolate, item);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<DownloadItem*>(existing));
-
-  auto handle = mate::CreateHandle(isolate, new DownloadItem(isolate, item));
-
-  // Reference this object in case it got garbage collected.
-  g_download_item_objects[handle->weak_map_id()] =
-      v8::Global<v8::Object>(isolate, handle.ToV8());
-  return handle;
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary(isolate, exports)
-      .Set("DownloadItem",
-           atom::api::DownloadItem::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_download_item, Initialize);
removed in remote
  base   100644 64469b9b34d1bd413ee7a4af3873da6a6f3e0132 atom/browser/api/atom_api_download_item.h
  our    100644 45ed54faf1918f877b953db86b1dd250cbd80879 atom/browser/api/atom_api_download_item.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
-#define ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/files/file_path.h"
-#include "components/download/public/common/download_item.h"
-#include "native_mate/handle.h"
-#include "url/gurl.h"
-
-namespace atom {
-
-namespace api {
-
-class DownloadItem : public mate::TrackableObject<DownloadItem>,
-                     public download::DownloadItem::Observer {
- public:
-  static mate::Handle<DownloadItem> Create(v8::Isolate* isolate,
-                                           download::DownloadItem* item);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  void Pause();
-  bool IsPaused() const;
-  void Resume();
-  bool CanResume() const;
-  void Cancel();
-  int64_t GetReceivedBytes() const;
-  int64_t GetTotalBytes() const;
-  std::string GetMimeType() const;
-  bool HasUserGesture() const;
-  std::string GetFilename() const;
-  std::string GetContentDisposition() const;
-  const GURL& GetURL() const;
-  const std::vector<GURL>& GetURLChain() const;
-  download::DownloadItem::DownloadState GetState() const;
-  bool IsDone() const;
-  void SetSavePath(const base::FilePath& path);
-  base::FilePath GetSavePath() const;
-  std::string GetLastModifiedTime() const;
-  std::string GetETag() const;
-  double GetStartTime() const;
-
- protected:
-  DownloadItem(v8::Isolate* isolate, download::DownloadItem* download_item);
-  ~DownloadItem() override;
-
-  // Override download::DownloadItem::Observer methods
-  void OnDownloadUpdated(download::DownloadItem* download) override;
-  void OnDownloadDestroyed(download::DownloadItem* download) override;
-
- private:
-  base::FilePath save_path_;
-  download::DownloadItem* download_item_;
-
-  DISALLOW_COPY_AND_ASSIGN(DownloadItem);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_DOWNLOAD_ITEM_H_
removed in remote
  base   100644 f5a03e4abf9010c3bd371e0778ab684d2dd2418e atom/browser/api/atom_api_global_shortcut.cc
  our    100644 4fc7532d9e346ee9d2c02cfac450042073897b99 atom/browser/api/atom_api_global_shortcut.cc
@@ -1,103 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_global_shortcut.h"
-
-#include <string>
-
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "base/stl_util.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using extensions::GlobalShortcutListener;
-
-namespace atom {
-
-namespace api {
-
-GlobalShortcut::GlobalShortcut(v8::Isolate* isolate) {
-  Init(isolate);
-}
-
-GlobalShortcut::~GlobalShortcut() {
-  UnregisterAll();
-}
-
-void GlobalShortcut::OnKeyPressed(const ui::Accelerator& accelerator) {
-  if (accelerator_callback_map_.find(accelerator) ==
-      accelerator_callback_map_.end()) {
-    // This should never occur, because if it does, GlobalGlobalShortcutListener
-    // notifes us with wrong accelerator.
-    NOTREACHED();
-    return;
-  }
-  accelerator_callback_map_[accelerator].Run();
-}
-
-bool GlobalShortcut::Register(const ui::Accelerator& accelerator,
-                              const base::Closure& callback) {
-  if (!GlobalShortcutListener::GetInstance()->RegisterAccelerator(accelerator,
-                                                                  this)) {
-    return false;
-  }
-
-  accelerator_callback_map_[accelerator] = callback;
-  return true;
-}
-
-void GlobalShortcut::Unregister(const ui::Accelerator& accelerator) {
-  if (!ContainsKey(accelerator_callback_map_, accelerator))
-    return;
-
-  accelerator_callback_map_.erase(accelerator);
-  GlobalShortcutListener::GetInstance()->UnregisterAccelerator(accelerator,
-                                                               this);
-}
-
-bool GlobalShortcut::IsRegistered(const ui::Accelerator& accelerator) {
-  return ContainsKey(accelerator_callback_map_, accelerator);
-}
-
-void GlobalShortcut::UnregisterAll() {
-  accelerator_callback_map_.clear();
-  GlobalShortcutListener::GetInstance()->UnregisterAccelerators(this);
-}
-
-// static
-mate::Handle<GlobalShortcut> GlobalShortcut::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new GlobalShortcut(isolate));
-}
-
-// static
-void GlobalShortcut::BuildPrototype(v8::Isolate* isolate,
-                                    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "GlobalShortcut"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("register", &GlobalShortcut::Register)
-      .SetMethod("isRegistered", &GlobalShortcut::IsRegistered)
-      .SetMethod("unregister", &GlobalShortcut::Unregister)
-      .SetMethod("unregisterAll", &GlobalShortcut::UnregisterAll);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("globalShortcut", atom::api::GlobalShortcut::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_global_shortcut, Initialize)
removed in remote
  base   100644 d7057b0003208a1915d4912827dc7595722e258e atom/browser/api/atom_api_global_shortcut.h
  our    100644 b023aec4a8436b83152c812c9ec1d3af478cda80 atom/browser/api/atom_api_global_shortcut.h
@@ -1,54 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
-#define ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/api/trackable_object.h"
-#include "base/callback.h"
-#include "chrome/browser/extensions/global_shortcut_listener.h"
-#include "native_mate/handle.h"
-#include "ui/base/accelerators/accelerator.h"
-
-namespace atom {
-
-namespace api {
-
-class GlobalShortcut : public extensions::GlobalShortcutListener::Observer,
-                       public mate::TrackableObject<GlobalShortcut> {
- public:
-  static mate::Handle<GlobalShortcut> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit GlobalShortcut(v8::Isolate* isolate);
-  ~GlobalShortcut() override;
-
- private:
-  typedef std::map<ui::Accelerator, base::Closure> AcceleratorCallbackMap;
-
-  bool Register(const ui::Accelerator& accelerator,
-                const base::Closure& callback);
-  bool IsRegistered(const ui::Accelerator& accelerator);
-  void Unregister(const ui::Accelerator& accelerator);
-  void UnregisterAll();
-
-  // GlobalShortcutListener::Observer implementation.
-  void OnKeyPressed(const ui::Accelerator& accelerator) override;
-
-  AcceleratorCallbackMap accelerator_callback_map_;
-
-  DISALLOW_COPY_AND_ASSIGN(GlobalShortcut);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_GLOBAL_SHORTCUT_H_
removed in remote
  base   100644 e40ba17f464fe562f644d0cf2222c63281b5d48e atom/browser/api/atom_api_menu.cc
  our    100644 1c4f4fcf41e55be7d355d8940d14f3e9cb1c2b28 atom/browser/api/atom_api_menu.cc
@@ -1,231 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_menu.h"
-
-#include "atom/browser/native_window.h"
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "native_mate/constructor.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-Menu::Menu(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : model_(new AtomMenuModel(this)) {
-  InitWith(isolate, wrapper);
-  model_->AddObserver(this);
-}
-
-Menu::~Menu() {
-  if (model_) {
-    model_->RemoveObserver(this);
-  }
-}
-
-void Menu::AfterInit(v8::Isolate* isolate) {
-  mate::Dictionary wrappable(isolate, GetWrapper());
-  mate::Dictionary delegate;
-  if (!wrappable.Get("delegate", &delegate))
-    return;
-
-  delegate.Get("isCommandIdChecked", &is_checked_);
-  delegate.Get("isCommandIdEnabled", &is_enabled_);
-  delegate.Get("isCommandIdVisible", &is_visible_);
-  delegate.Get("getAcceleratorForCommandId", &get_accelerator_);
-  delegate.Get("executeCommand", &execute_command_);
-  delegate.Get("menuWillShow", &menu_will_show_);
-}
-
-bool Menu::IsCommandIdChecked(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_checked_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::IsCommandIdEnabled(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_enabled_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::IsCommandIdVisible(int command_id) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  return is_visible_.Run(GetWrapper(), command_id);
-}
-
-bool Menu::GetAcceleratorForCommandIdWithParams(
-    int command_id,
-    bool use_default_accelerator,
-    ui::Accelerator* accelerator) const {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  v8::Local<v8::Value> val =
-      get_accelerator_.Run(GetWrapper(), command_id, use_default_accelerator);
-  return mate::ConvertFromV8(isolate(), val, accelerator);
-}
-
-void Menu::ExecuteCommand(int command_id, int flags) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  execute_command_.Run(GetWrapper(),
-                       mate::internal::CreateEventFromFlags(isolate(), flags),
-                       command_id);
-}
-
-void Menu::MenuWillShow(ui::SimpleMenuModel* source) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  menu_will_show_.Run(GetWrapper());
-}
-
-void Menu::InsertItemAt(int index,
-                        int command_id,
-                        const base::string16& label) {
-  model_->InsertItemAt(index, command_id, label);
-}
-
-void Menu::InsertSeparatorAt(int index) {
-  model_->InsertSeparatorAt(index, ui::NORMAL_SEPARATOR);
-}
-
-void Menu::InsertCheckItemAt(int index,
-                             int command_id,
-                             const base::string16& label) {
-  model_->InsertCheckItemAt(index, command_id, label);
-}
-
-void Menu::InsertRadioItemAt(int index,
-                             int command_id,
-                             const base::string16& label,
-                             int group_id) {
-  model_->InsertRadioItemAt(index, command_id, label, group_id);
-}
-
-void Menu::InsertSubMenuAt(int index,
-                           int command_id,
-                           const base::string16& label,
-                           Menu* menu) {
-  menu->parent_ = this;
-  model_->InsertSubMenuAt(index, command_id, label, menu->model_.get());
-}
-
-void Menu::SetIcon(int index, const gfx::Image& image) {
-  model_->SetIcon(index, image);
-}
-
-void Menu::SetSublabel(int index, const base::string16& sublabel) {
-  model_->SetSublabel(index, sublabel);
-}
-
-void Menu::SetRole(int index, const base::string16& role) {
-  model_->SetRole(index, role);
-}
-
-void Menu::Clear() {
-  model_->Clear();
-}
-
-int Menu::GetIndexOfCommandId(int command_id) {
-  return model_->GetIndexOfCommandId(command_id);
-}
-
-int Menu::GetItemCount() const {
-  return model_->GetItemCount();
-}
-
-int Menu::GetCommandIdAt(int index) const {
-  return model_->GetCommandIdAt(index);
-}
-
-base::string16 Menu::GetLabelAt(int index) const {
-  return model_->GetLabelAt(index);
-}
-
-base::string16 Menu::GetSublabelAt(int index) const {
-  return model_->GetSublabelAt(index);
-}
-
-bool Menu::IsItemCheckedAt(int index) const {
-  return model_->IsItemCheckedAt(index);
-}
-
-bool Menu::IsEnabledAt(int index) const {
-  return model_->IsEnabledAt(index);
-}
-
-bool Menu::IsVisibleAt(int index) const {
-  return model_->IsVisibleAt(index);
-}
-
-void Menu::OnMenuWillClose() {
-  Emit("menu-will-close");
-}
-
-void Menu::OnMenuWillShow() {
-  Emit("menu-will-show");
-}
-
-// static
-void Menu::BuildPrototype(v8::Isolate* isolate,
-                          v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Menu"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("insertItem", &Menu::InsertItemAt)
-      .SetMethod("insertCheckItem", &Menu::InsertCheckItemAt)
-      .SetMethod("insertRadioItem", &Menu::InsertRadioItemAt)
-      .SetMethod("insertSeparator", &Menu::InsertSeparatorAt)
-      .SetMethod("insertSubMenu", &Menu::InsertSubMenuAt)
-      .SetMethod("setIcon", &Menu::SetIcon)
-      .SetMethod("setSublabel", &Menu::SetSublabel)
-      .SetMethod("setRole", &Menu::SetRole)
-      .SetMethod("clear", &Menu::Clear)
-      .SetMethod("getIndexOfCommandId", &Menu::GetIndexOfCommandId)
-      .SetMethod("getItemCount", &Menu::GetItemCount)
-      .SetMethod("getCommandIdAt", &Menu::GetCommandIdAt)
-      .SetMethod("getLabelAt", &Menu::GetLabelAt)
-      .SetMethod("getSublabelAt", &Menu::GetSublabelAt)
-      .SetMethod("isItemCheckedAt", &Menu::IsItemCheckedAt)
-      .SetMethod("isEnabledAt", &Menu::IsEnabledAt)
-      .SetMethod("isVisibleAt", &Menu::IsVisibleAt)
-      .SetMethod("popupAt", &Menu::PopupAt)
-      .SetMethod("closePopupAt", &Menu::ClosePopupAt);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Menu;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  Menu::SetConstructor(isolate, base::Bind(&Menu::New));
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Menu", Menu::GetConstructor(isolate)->GetFunction());
-#if defined(OS_MACOSX)
-  dict.SetMethod("setApplicationMenu", &Menu::SetApplicationMenu);
-  dict.SetMethod("sendActionToFirstResponder",
-                 &Menu::SendActionToFirstResponder);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_menu, Initialize)
removed in remote
  base   100644 1ae708863a732c55d9a6fc56c70bcd691350a921 atom/browser/api/atom_api_menu.h
  our    100644 26f2b679b6b7fc561e7f6e454afb2c40f475ee94 atom/browser/api/atom_api_menu.h
@@ -1,138 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/browser/api/atom_api_top_level_window.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/callback.h"
-
-namespace atom {
-
-namespace api {
-
-class Menu : public mate::TrackableObject<Menu>,
-             public AtomMenuModel::Delegate,
-             public AtomMenuModel::Observer {
- public:
-  static mate::WrappableBase* New(mate::Arguments* args);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(OS_MACOSX)
-  // Set the global menubar.
-  static void SetApplicationMenu(Menu* menu);
-
-  // Fake sending an action from the application menu.
-  static void SendActionToFirstResponder(const std::string& action);
-#endif
-
-  AtomMenuModel* model() const { return model_.get(); }
-
- protected:
-  Menu(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~Menu() override;
-
-  // mate::Wrappable:
-  void AfterInit(v8::Isolate* isolate) override;
-
-  // ui::SimpleMenuModel::Delegate:
-  bool IsCommandIdChecked(int command_id) const override;
-  bool IsCommandIdEnabled(int command_id) const override;
-  bool IsCommandIdVisible(int command_id) const override;
-  bool GetAcceleratorForCommandIdWithParams(
-      int command_id,
-      bool use_default_accelerator,
-      ui::Accelerator* accelerator) const override;
-  void ExecuteCommand(int command_id, int event_flags) override;
-  void MenuWillShow(ui::SimpleMenuModel* source) override;
-
-  virtual void PopupAt(TopLevelWindow* window,
-                       int x,
-                       int y,
-                       int positioning_item,
-                       const base::Closure& callback) = 0;
-  virtual void ClosePopupAt(int32_t window_id) = 0;
-
-  std::unique_ptr<AtomMenuModel> model_;
-  Menu* parent_ = nullptr;
-
-  // Observable:
-  void OnMenuWillClose() override;
-  void OnMenuWillShow() override;
-
- private:
-  void InsertItemAt(int index, int command_id, const base::string16& label);
-  void InsertSeparatorAt(int index);
-  void InsertCheckItemAt(int index,
-                         int command_id,
-                         const base::string16& label);
-  void InsertRadioItemAt(int index,
-                         int command_id,
-                         const base::string16& label,
-                         int group_id);
-  void InsertSubMenuAt(int index,
-                       int command_id,
-                       const base::string16& label,
-                       Menu* menu);
-  void SetIcon(int index, const gfx::Image& image);
-  void SetSublabel(int index, const base::string16& sublabel);
-  void SetRole(int index, const base::string16& role);
-  void Clear();
-  int GetIndexOfCommandId(int command_id);
-  int GetItemCount() const;
-  int GetCommandIdAt(int index) const;
-  base::string16 GetLabelAt(int index) const;
-  base::string16 GetSublabelAt(int index) const;
-  bool IsItemCheckedAt(int index) const;
-  bool IsEnabledAt(int index) const;
-  bool IsVisibleAt(int index) const;
-
-  // Stored delegate methods.
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_checked_;
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_enabled_;
-  base::Callback<bool(v8::Local<v8::Value>, int)> is_visible_;
-  base::Callback<v8::Local<v8::Value>(v8::Local<v8::Value>, int, bool)>
-      get_accelerator_;
-  base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>, int)>
-      execute_command_;
-  base::Callback<void(v8::Local<v8::Value>)> menu_will_show_;
-
-  DISALLOW_COPY_AND_ASSIGN(Menu);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-template <>
-struct Converter<atom::AtomMenuModel*> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::AtomMenuModel** out) {
-    // null would be tranfered to NULL.
-    if (val->IsNull()) {
-      *out = nullptr;
-      return true;
-    }
-
-    atom::api::Menu* menu;
-    if (!Converter<atom::api::Menu*>::FromV8(isolate, val, &menu))
-      return false;
-    *out = menu->model();
-    return true;
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_H_
removed in remote
  base   100644 85227fa2a9d9fe74c2b8f0cc0255e95fbbc47bf8 atom/browser/api/atom_api_menu_mac.h
  our    100644 6ba895676c54d6f05f819ddd084a1d2400e054ea atom/browser/api/atom_api_menu_mac.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
-
-#include "atom/browser/api/atom_api_menu.h"
-
-#include <map>
-#include <string>
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-using base::scoped_nsobject;
-
-namespace atom {
-
-namespace api {
-
-class MenuMac : public Menu {
- protected:
-  MenuMac(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~MenuMac() override;
-
-  void PopupAt(TopLevelWindow* window,
-               int x,
-               int y,
-               int positioning_item,
-               const base::Closure& callback) override;
-  void PopupOnUI(const base::WeakPtr<NativeWindow>& native_window,
-                 int32_t window_id,
-                 int x,
-                 int y,
-                 int positioning_item,
-                 base::Closure callback);
-  void ClosePopupAt(int32_t window_id) override;
-
- private:
-  friend class Menu;
-
-  void OnClosed(int32_t window_id, base::Closure callback);
-
-  scoped_nsobject<AtomMenuController> menu_controller_;
-
-  // window ID -> open context menu
-  std::map<int32_t, scoped_nsobject<AtomMenuController>> popup_controllers_;
-
-  base::WeakPtrFactory<MenuMac> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuMac);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_MAC_H_
removed in remote
  base   100644 71c677b0476e642eeb98122304318fd0e553d83b atom/browser/api/atom_api_menu_mac.mm
  our    100644 2b63b8a6cefe6265d96399dc6b70ab3ffdc352c3 atom/browser/api/atom_api_menu_mac.mm
@@ -1,171 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/api/atom_api_menu_mac.h"
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/mac/scoped_sending_event.h"
-#include "base/message_loop/message_loop.h"
-#include "base/strings/sys_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/web_contents.h"
-
-#include "atom/common/node_includes.h"
-
-using content::BrowserThread;
-
-namespace {
-
-static scoped_nsobject<NSMenu> applicationMenu_;
-
-}  // namespace
-
-namespace atom {
-
-namespace api {
-
-MenuMac::MenuMac(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : Menu(isolate, wrapper), weak_factory_(this) {}
-
-MenuMac::~MenuMac() = default;
-
-void MenuMac::PopupAt(TopLevelWindow* window,
-                      int x,
-                      int y,
-                      int positioning_item,
-                      const base::Closure& callback) {
-  NativeWindow* native_window = window->window();
-  if (!native_window)
-    return;
-
-  auto popup = base::Bind(&MenuMac::PopupOnUI, weak_factory_.GetWeakPtr(),
-                          native_window->GetWeakPtr(), window->weak_map_id(), x,
-                          y, positioning_item, callback);
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, popup);
-}
-
-void MenuMac::PopupOnUI(const base::WeakPtr<NativeWindow>& native_window,
-                        int32_t window_id,
-                        int x,
-                        int y,
-                        int positioning_item,
-                        base::Closure callback) {
-  if (!native_window)
-    return;
-  NSWindow* nswindow = native_window->GetNativeWindow();
-
-  auto close_callback = base::Bind(
-      &MenuMac::OnClosed, weak_factory_.GetWeakPtr(), window_id, callback);
-  popup_controllers_[window_id] = base::scoped_nsobject<AtomMenuController>([
-      [AtomMenuController alloc] initWithModel:model()
-                         useDefaultAccelerator:NO]);
-  NSMenu* menu = [popup_controllers_[window_id] menu];
-  NSView* view = [nswindow contentView];
-
-  // Which menu item to show.
-  NSMenuItem* item = nil;
-  if (positioning_item < [menu numberOfItems] && positioning_item >= 0)
-    item = [menu itemAtIndex:positioning_item];
-
-  // (-1, -1) means showing on mouse location.
-  NSPoint position;
-  if (x == -1 || y == -1) {
-    position = [view convertPoint:[nswindow mouseLocationOutsideOfEventStream]
-                         fromView:nil];
-  } else {
-    position = NSMakePoint(x, [view frame].size.height - y);
-  }
-
-  // If no preferred item is specified, try to show all of the menu items.
-  if (!positioning_item) {
-    CGFloat windowBottom = CGRectGetMinY([view window].frame);
-    CGFloat lowestMenuPoint = windowBottom + position.y - [menu size].height;
-    CGFloat screenBottom = CGRectGetMinY([view window].screen.frame);
-    CGFloat distanceFromBottom = lowestMenuPoint - screenBottom;
-    if (distanceFromBottom < 0)
-      position.y = position.y - distanceFromBottom + 4;
-  }
-
-  // Place the menu left of cursor if it is overflowing off right of screen.
-  CGFloat windowLeft = CGRectGetMinX([view window].frame);
-  CGFloat rightmostMenuPoint = windowLeft + position.x + [menu size].width;
-  CGFloat screenRight = CGRectGetMaxX([view window].screen.frame);
-  if (rightmostMenuPoint > screenRight)
-    position.x = position.x - [menu size].width;
-
-  [popup_controllers_[window_id] setCloseCallback:close_callback];
-  // Make sure events can be pumped while the menu is up.
-  base::MessageLoop::ScopedNestableTaskAllower allow(
-      base::MessageLoop::current());
-
-  // One of the events that could be pumped is |window.close()|.
-  // User-initiated event-tracking loops protect against this by
-  // setting flags in -[CrApplication sendEvent:], but since
-  // web-content menus are initiated by IPC message the setup has to
-  // be done manually.
-  base::mac::ScopedSendingEvent sendingEventScoper;
-
-  // Don't emit unresponsive event when showing menu.
-  atom::UnresponsiveSuppressor suppressor;
-  [menu popUpMenuPositioningItem:item atLocation:position inView:view];
-}
-
-void MenuMac::ClosePopupAt(int32_t window_id) {
-  auto controller = popup_controllers_.find(window_id);
-  if (controller != popup_controllers_.end()) {
-    // Close the controller for the window.
-    [controller->second cancel];
-  } else if (window_id == -1) {
-    // Or just close all opened controllers.
-    for (auto it = popup_controllers_.begin();
-         it != popup_controllers_.end();) {
-      // The iterator is invalidated after the call.
-      [(it++)->second cancel];
-    }
-  }
-}
-
-void MenuMac::OnClosed(int32_t window_id, base::Closure callback) {
-  popup_controllers_.erase(window_id);
-  callback.Run();
-}
-
-// static
-void Menu::SetApplicationMenu(Menu* base_menu) {
-  MenuMac* menu = static_cast<MenuMac*>(base_menu);
-  base::scoped_nsobject<AtomMenuController> menu_controller([
-      [AtomMenuController alloc] initWithModel:menu->model_.get()
-                         useDefaultAccelerator:YES]);
-
-  NSRunLoop* currentRunLoop = [NSRunLoop currentRunLoop];
-  [currentRunLoop cancelPerformSelector:@selector(setMainMenu:)
-                                 target:NSApp
-                               argument:applicationMenu_];
-  applicationMenu_.reset([[menu_controller menu] retain]);
-  [[NSRunLoop currentRunLoop]
-      performSelector:@selector(setMainMenu:)
-               target:NSApp
-             argument:applicationMenu_
-                order:0
-                modes:[NSArray arrayWithObject:NSDefaultRunLoopMode]];
-
-  // Ensure the menu_controller_ is destroyed after main menu is set.
-  menu_controller.swap(menu->menu_controller_);
-}
-
-// static
-void Menu::SendActionToFirstResponder(const std::string& action) {
-  SEL selector = NSSelectorFromString(base::SysUTF8ToNSString(action));
-  [NSApp sendAction:selector to:nil from:[NSApp mainMenu]];
-}
-
-// static
-mate::WrappableBase* Menu::New(mate::Arguments* args) {
-  return new MenuMac(args->isolate(), args->GetThis());
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 4a3a97dd906e6f2fb1ad27df2cdc7d79d53e2e46 atom/browser/api/atom_api_menu_views.cc
  our    100644 3da7dc2842fa4561e037aa67f290d0cc6ca71014 atom/browser/api/atom_api_menu_views.cc
@@ -1,82 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_menu_views.h"
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "ui/display/screen.h"
-
-using views::MenuRunner;
-
-namespace atom {
-
-namespace api {
-
-MenuViews::MenuViews(v8::Isolate* isolate, v8::Local<v8::Object> wrapper)
-    : Menu(isolate, wrapper), weak_factory_(this) {}
-
-MenuViews::~MenuViews() = default;
-
-void MenuViews::PopupAt(TopLevelWindow* window,
-                        int x,
-                        int y,
-                        int positioning_item,
-                        const base::Closure& callback) {
-  auto* native_window = static_cast<NativeWindowViews*>(window->window());
-  if (!native_window)
-    return;
-
-  // (-1, -1) means showing on mouse location.
-  gfx::Point location;
-  if (x == -1 || y == -1) {
-    location = display::Screen::GetScreen()->GetCursorScreenPoint();
-  } else {
-    gfx::Point origin = native_window->GetContentBounds().origin();
-    location = gfx::Point(origin.x() + x, origin.y() + y);
-  }
-
-  int flags = MenuRunner::CONTEXT_MENU | MenuRunner::HAS_MNEMONICS;
-
-  // Don't emit unresponsive event when showing menu.
-  atom::UnresponsiveSuppressor suppressor;
-
-  // Show the menu.
-  int32_t window_id = window->weak_map_id();
-  auto close_callback = base::Bind(
-      &MenuViews::OnClosed, weak_factory_.GetWeakPtr(), window_id, callback);
-  menu_runners_[window_id] =
-      std::make_unique<MenuRunner>(model(), flags, close_callback);
-  menu_runners_[window_id]->RunMenuAt(
-      native_window->widget(), NULL, gfx::Rect(location, gfx::Size()),
-      views::MENU_ANCHOR_TOPLEFT, ui::MENU_SOURCE_MOUSE);
-}
-
-void MenuViews::ClosePopupAt(int32_t window_id) {
-  auto runner = menu_runners_.find(window_id);
-  if (runner != menu_runners_.end()) {
-    // Close the runner for the window.
-    runner->second->Cancel();
-  } else if (window_id == -1) {
-    // Or just close all opened runners.
-    for (auto it = menu_runners_.begin(); it != menu_runners_.end();) {
-      // The iterator is invalidated after the call.
-      (it++)->second->Cancel();
-    }
-  }
-}
-
-void MenuViews::OnClosed(int32_t window_id, base::Closure callback) {
-  menu_runners_.erase(window_id);
-  callback.Run();
-}
-
-// static
-mate::WrappableBase* Menu::New(mate::Arguments* args) {
-  return new MenuViews(args->isolate(), args->GetThis());
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 e4d17c77ca6555dd9e1cd34763e53999485e432f atom/browser/api/atom_api_menu_views.h
  our    100644 0a34c19cef31db7fb0d6e05a3ff0cb8d31fc31da atom/browser/api/atom_api_menu_views.h
@@ -1,47 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
-#define ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
-
-#include <map>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "base/memory/weak_ptr.h"
-#include "ui/display/screen.h"
-#include "ui/views/controls/menu/menu_runner.h"
-
-namespace atom {
-
-namespace api {
-
-class MenuViews : public Menu {
- public:
-  MenuViews(v8::Isolate* isolate, v8::Local<v8::Object> wrapper);
-  ~MenuViews() override;
-
- protected:
-  void PopupAt(TopLevelWindow* window,
-               int x,
-               int y,
-               int positioning_item,
-               const base::Closure& callback) override;
-  void ClosePopupAt(int32_t window_id) override;
-
- private:
-  void OnClosed(int32_t window_id, base::Closure callback);
-
-  // window ID -> open context menu
-  std::map<int32_t, std::unique_ptr<views::MenuRunner>> menu_runners_;
-
-  base::WeakPtrFactory<MenuViews> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuViews);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_MENU_VIEWS_H_
removed in remote
  base   100644 31b35e10cea8ae631406aa28e98937694b9739f7 atom/browser/api/atom_api_power_monitor.cc
  our    100644 8145a09501fc5ac24b7fe66985c1b892d5806772 atom/browser/api/atom_api_power_monitor.cc
@@ -1,150 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_power_monitor.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "base/power_monitor/power_monitor.h"
-#include "base/power_monitor/power_monitor_device_source.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-template <>
-struct Converter<ui::IdleState> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const ui::IdleState& in) {
-    switch (in) {
-      case ui::IDLE_STATE_ACTIVE:
-        return mate::StringToV8(isolate, "active");
-      case ui::IDLE_STATE_IDLE:
-        return mate::StringToV8(isolate, "idle");
-      case ui::IDLE_STATE_LOCKED:
-        return mate::StringToV8(isolate, "locked");
-      case ui::IDLE_STATE_UNKNOWN:
-      default:
-        return mate::StringToV8(isolate, "unknown");
-    }
-  }
-};
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-PowerMonitor::PowerMonitor(v8::Isolate* isolate) {
-#if defined(OS_LINUX)
-  SetShutdownHandler(
-      base::Bind(&PowerMonitor::ShouldShutdown, base::Unretained(this)));
-#elif defined(OS_MACOSX)
-  Browser::Get()->SetShutdownHandler(
-      base::Bind(&PowerMonitor::ShouldShutdown, base::Unretained(this)));
-#endif
-  base::PowerMonitor::Get()->AddObserver(this);
-  Init(isolate);
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  InitPlatformSpecificMonitors();
-#endif
-}
-
-PowerMonitor::~PowerMonitor() {
-  base::PowerMonitor::Get()->RemoveObserver(this);
-}
-
-bool PowerMonitor::ShouldShutdown() {
-  return !Emit("shutdown");
-}
-
-#if defined(OS_LINUX)
-void PowerMonitor::BlockShutdown() {
-  PowerObserverLinux::BlockShutdown();
-}
-
-void PowerMonitor::UnblockShutdown() {
-  PowerObserverLinux::UnblockShutdown();
-}
-#endif
-
-void PowerMonitor::OnPowerStateChange(bool on_battery_power) {
-  if (on_battery_power)
-    Emit("on-battery");
-  else
-    Emit("on-ac");
-}
-
-void PowerMonitor::OnSuspend() {
-  Emit("suspend");
-}
-
-void PowerMonitor::OnResume() {
-  Emit("resume");
-}
-
-void PowerMonitor::QuerySystemIdleState(v8::Isolate* isolate,
-                                        int idle_threshold,
-                                        const ui::IdleCallback& callback) {
-  if (idle_threshold > 0) {
-    ui::CalculateIdleState(idle_threshold, callback);
-  } else {
-    isolate->ThrowException(v8::Exception::TypeError(mate::StringToV8(
-        isolate, "Invalid idle threshold, must be greater than 0")));
-  }
-}
-
-void PowerMonitor::QuerySystemIdleTime(const ui::IdleTimeCallback& callback) {
-  ui::CalculateIdleTime(callback);
-}
-
-// static
-v8::Local<v8::Value> PowerMonitor::Create(v8::Isolate* isolate) {
-  if (!Browser::Get()->is_ready()) {
-    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate,
-        "Cannot require \"powerMonitor\" module before app is ready")));
-    return v8::Null(isolate);
-  }
-
-  return mate::CreateHandle(isolate, new PowerMonitor(isolate)).ToV8();
-}
-
-// static
-void PowerMonitor::BuildPrototype(v8::Isolate* isolate,
-                                  v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "PowerMonitor"));
-
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-#if defined(OS_LINUX)
-      .SetMethod("blockShutdown", &PowerMonitor::BlockShutdown)
-      .SetMethod("unblockShutdown", &PowerMonitor::UnblockShutdown)
-#endif
-      .SetMethod("querySystemIdleState", &PowerMonitor::QuerySystemIdleState)
-      .SetMethod("querySystemIdleTime", &PowerMonitor::QuerySystemIdleTime);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::PowerMonitor;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("powerMonitor", PowerMonitor::Create(isolate));
-  dict.Set("PowerMonitor",
-           PowerMonitor::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_power_monitor, Initialize)
removed in remote
  base   100644 8fb52eeec95eecb193130e3692d535f539420e81 atom/browser/api/atom_api_power_monitor.h
  our    100644 c7a6169d88b712cbcb9600c4458959ea38fb15fb atom/browser/api/atom_api_power_monitor.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
-#define ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/lib/power_observer.h"
-#include "base/compiler_specific.h"
-#include "native_mate/handle.h"
-#include "ui/base/idle/idle.h"
-
-namespace atom {
-
-namespace api {
-
-class PowerMonitor : public mate::TrackableObject<PowerMonitor>,
-                     public PowerObserver {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit PowerMonitor(v8::Isolate* isolate);
-  ~PowerMonitor() override;
-
-  // Called by native calles.
-  bool ShouldShutdown();
-
-#if defined(OS_LINUX)
-  // Private JS APIs.
-  void BlockShutdown();
-  void UnblockShutdown();
-#endif
-
-#if defined(OS_MACOSX) || defined(OS_WIN)
-  void InitPlatformSpecificMonitors();
-#endif
-
-  // base::PowerObserver implementations:
-  void OnPowerStateChange(bool on_battery_power) override;
-  void OnSuspend() override;
-  void OnResume() override;
-
- private:
-  void QuerySystemIdleState(v8::Isolate* isolate,
-                            int idle_threshold,
-                            const ui::IdleCallback& callback);
-  void QuerySystemIdleTime(const ui::IdleTimeCallback& callback);
-
-#if defined(OS_WIN)
-  // Static callback invoked when a message comes in to our messaging window.
-  static LRESULT CALLBACK WndProcStatic(HWND hwnd,
-                                        UINT message,
-                                        WPARAM wparam,
-                                        LPARAM lparam);
-
-  LRESULT CALLBACK WndProc(HWND hwnd,
-                           UINT message,
-                           WPARAM wparam,
-                           LPARAM lparam);
-
-  // The window class of |window_|.
-  ATOM atom_;
-
-  // The handle of the module that contains the window procedure of |window_|.
-  HMODULE instance_;
-
-  // The window used for processing events.
-  HWND window_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(PowerMonitor);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_POWER_MONITOR_H_
removed in remote
  base   100644 58983e6c846a8b161b4f74b271ba978846bfa2dc atom/browser/api/atom_api_power_save_blocker.cc
  our    100644 0b06a9f583782b55296498159059e35b8f27f186 atom/browser/api/atom_api_power_save_blocker.cc
@@ -1,137 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_power_save_blocker.h"
-
-#include <string>
-
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<device::mojom::WakeLockType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     device::mojom::WakeLockType* out) {
-    std::string type;
-    if (!ConvertFromV8(isolate, val, &type))
-      return false;
-    if (type == "prevent-app-suspension")
-      *out = device::mojom::WakeLockType::kPreventAppSuspension;
-    else if (type == "prevent-display-sleep")
-      *out = device::mojom::WakeLockType::kPreventDisplaySleep;
-    else
-      return false;
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-PowerSaveBlocker::PowerSaveBlocker(v8::Isolate* isolate)
-    : current_blocker_type_(
-          device::mojom::WakeLockType::kPreventAppSuspension) {
-  Init(isolate);
-}
-
-PowerSaveBlocker::~PowerSaveBlocker() {}
-
-void PowerSaveBlocker::UpdatePowerSaveBlocker() {
-  if (power_save_blocker_types_.empty()) {
-    power_save_blocker_.reset();
-    return;
-  }
-
-  // |WakeLockType::kPreventAppSuspension| keeps system active, but allows
-  // screen to be turned off.
-  // |WakeLockType::kPreventDisplaySleep| keeps system and screen active, has a
-  // higher precedence level than |WakeLockType::kPreventAppSuspension|.
-  //
-  // Only the highest-precedence blocker type takes effect.
-  device::mojom::WakeLockType new_blocker_type =
-      device::mojom::WakeLockType::kPreventAppSuspension;
-  for (const auto& element : power_save_blocker_types_) {
-    if (element.second ==
-        device::mojom::WakeLockType::kPreventDisplaySleep) {
-      new_blocker_type =
-          device::mojom::WakeLockType::kPreventDisplaySleep;
-      break;
-    }
-  }
-
-  if (!power_save_blocker_ || new_blocker_type != current_blocker_type_) {
-    auto new_blocker = std::make_unique<device::PowerSaveBlocker>(
-        new_blocker_type, device::mojom::WakeLockReason::kOther,
-        ATOM_PRODUCT_NAME, base::ThreadTaskRunnerHandle::Get(),
-        // This task runner may be used by some device service
-        // implementation bits to interface with dbus client code, which in
-        // turn imposes some subtle thread affinity on the clients. We
-        // therefore require a single-thread runner.
-        base::CreateSingleThreadTaskRunnerWithTraits(
-            {base::MayBlock(), base::TaskPriority::BACKGROUND}));
-    power_save_blocker_.swap(new_blocker);
-    current_blocker_type_ = new_blocker_type;
-  }
-}
-
-int PowerSaveBlocker::Start(device::mojom::WakeLockType type) {
-  static int count = 0;
-  power_save_blocker_types_[count] = type;
-  UpdatePowerSaveBlocker();
-  return count++;
-}
-
-bool PowerSaveBlocker::Stop(int id) {
-  bool success = power_save_blocker_types_.erase(id) > 0;
-  UpdatePowerSaveBlocker();
-  return success;
-}
-
-bool PowerSaveBlocker::IsStarted(int id) {
-  return power_save_blocker_types_.find(id) != power_save_blocker_types_.end();
-}
-
-// static
-mate::Handle<PowerSaveBlocker> PowerSaveBlocker::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new PowerSaveBlocker(isolate));
-}
-
-// static
-void PowerSaveBlocker::BuildPrototype(
-    v8::Isolate* isolate,
-    v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "PowerSaveBlocker"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("start", &PowerSaveBlocker::Start)
-      .SetMethod("stop", &PowerSaveBlocker::Stop)
-      .SetMethod("isStarted", &PowerSaveBlocker::IsStarted);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("powerSaveBlocker", atom::api::PowerSaveBlocker::Create(isolate));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_power_save_blocker, Initialize);
removed in remote
  base   100644 a698d746ceb0a64ed4a29aa87f512cc64f5a6b86 atom/browser/api/atom_api_power_save_blocker.h
  our    100644 d56222db95dedca78f3274bf509c6384c3ff833e atom/browser/api/atom_api_power_save_blocker.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
-#define ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
-
-#include <map>
-#include <memory>
-
-#include "atom/browser/api/trackable_object.h"
-#include "native_mate/handle.h"
-#include "services/device/wake_lock/power_save_blocker/power_save_blocker.h"
-
-namespace mate {
-class Dictionary;
-}
-
-namespace atom {
-
-namespace api {
-
-class PowerSaveBlocker : public mate::TrackableObject<PowerSaveBlocker> {
- public:
-  static mate::Handle<PowerSaveBlocker> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  explicit PowerSaveBlocker(v8::Isolate* isolate);
-  ~PowerSaveBlocker() override;
-
- private:
-  void UpdatePowerSaveBlocker();
-  int Start(device::mojom::WakeLockType type);
-  bool Stop(int id);
-  bool IsStarted(int id);
-
-  std::unique_ptr<device::PowerSaveBlocker> power_save_blocker_;
-
-  // Current blocker type used by |power_save_blocker_|
-  device::mojom::WakeLockType current_blocker_type_;
-
-  // Map from id to the corresponding blocker type for each request.
-  using WakeLockTypeMap = std::map<int, device::mojom::WakeLockType>;
-  WakeLockTypeMap power_save_blocker_types_;
-
-  DISALLOW_COPY_AND_ASSIGN(PowerSaveBlocker);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_POWER_SAVE_BLOCKER_H_
removed in remote
  base   100644 09da9c71cadbc204787cf20a4fec584d45696476 atom/browser/api/atom_api_protocol.cc
  our    100644 5e1f991ad8dcd611467b691fff48656e3cc299ff atom/browser/api/atom_api_protocol.cc
@@ -1,248 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_protocol.h"
-
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/net/url_request_async_asar_job.h"
-#include "atom/browser/net/url_request_buffer_job.h"
-#include "atom/browser/net/url_request_fetch_job.h"
-#include "atom/browser/net/url_request_stream_job.h"
-#include "atom/browser/net/url_request_string_job.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/strings/string_util.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "native_mate/dictionary.h"
-#include "url/url_util.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// List of registered custom standard schemes.
-std::vector<std::string> g_standard_schemes;
-
-}  // namespace
-
-std::vector<std::string> GetStandardSchemes() {
-  return g_standard_schemes;
-}
-
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args) {
-  g_standard_schemes = schemes;
-
-  mate::Dictionary opts;
-  bool secure = false;
-  args->GetNext(&opts) && opts.Get("secure", &secure);
-
-  // Dynamically register the schemes.
-  auto* policy = content::ChildProcessSecurityPolicy::GetInstance();
-  for (const std::string& scheme : schemes) {
-    url::AddStandardScheme(scheme.c_str(), url::SCHEME_WITHOUT_PORT);
-    if (secure) {
-      url::AddSecureScheme(scheme.c_str());
-    }
-    policy->RegisterWebSafeScheme(scheme);
-  }
-
-  // Add the schemes to command line switches, so child processes can also
-  // register them.
-  base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
-      atom::switches::kStandardSchemes, base::JoinString(schemes, ","));
-  if (secure) {
-    base::CommandLine::ForCurrentProcess()->AppendSwitchASCII(
-        atom::switches::kSecureSchemes, base::JoinString(schemes, ","));
-  }
-}
-
-Protocol::Protocol(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : browser_context_(browser_context), weak_factory_(this) {
-  Init(isolate);
-}
-
-Protocol::~Protocol() {}
-
-void Protocol::RegisterServiceWorkerSchemes(
-    const std::vector<std::string>& schemes) {
-  atom::AtomBrowserClient::SetCustomServiceWorkerSchemes(schemes);
-}
-
-void Protocol::UnregisterProtocol(const std::string& scheme,
-                                  mate::Arguments* args) {
-  CompletionCallback callback;
-  args->GetNext(&callback);
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&Protocol::UnregisterProtocolInIO,
-                     base::RetainedRef(getter), scheme),
-      base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-}
-
-// static
-Protocol::ProtocolError Protocol::UnregisterProtocolInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-      request_context_getter->job_factory());
-  if (!job_factory->HasProtocolHandler(scheme))
-    return PROTOCOL_NOT_REGISTERED;
-  job_factory->SetProtocolHandler(scheme, nullptr);
-  return PROTOCOL_OK;
-}
-
-void Protocol::IsProtocolHandled(const std::string& scheme,
-                                 const BooleanCallback& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::Bind(&Protocol::IsProtocolHandledInIO, base::RetainedRef(getter),
-                 scheme),
-      callback);
-}
-
-// static
-bool Protocol::IsProtocolHandledInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  return request_context_getter->job_factory()->IsHandledProtocol(scheme);
-}
-
-void Protocol::UninterceptProtocol(const std::string& scheme,
-                                   mate::Arguments* args) {
-  CompletionCallback callback;
-  args->GetNext(&callback);
-  auto* getter = browser_context_->GetRequestContext();
-  content::BrowserThread::PostTaskAndReplyWithResult(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&Protocol::UninterceptProtocolInIO,
-                     base::RetainedRef(getter), scheme),
-      base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-}
-
-// static
-Protocol::ProtocolError Protocol::UninterceptProtocolInIO(
-    scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-    const std::string& scheme) {
-  return static_cast<AtomURLRequestJobFactory*>(
-             request_context_getter->job_factory())
-                 ->UninterceptProtocol(scheme)
-             ? PROTOCOL_OK
-             : PROTOCOL_NOT_INTERCEPTED;
-}
-
-void Protocol::OnIOCompleted(const CompletionCallback& callback,
-                             ProtocolError error) {
-  // The completion callback is optional.
-  if (callback.is_null())
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-
-  if (error == PROTOCOL_OK) {
-    callback.Run(v8::Null(isolate()));
-  } else {
-    std::string str = ErrorCodeToString(error);
-    callback.Run(v8::Exception::Error(mate::StringToV8(isolate(), str)));
-  }
-}
-
-std::string Protocol::ErrorCodeToString(ProtocolError error) {
-  switch (error) {
-    case PROTOCOL_FAIL:
-      return "Failed to manipulate protocol factory";
-    case PROTOCOL_REGISTERED:
-      return "The scheme has been registered";
-    case PROTOCOL_NOT_REGISTERED:
-      return "The scheme has not been registered";
-    case PROTOCOL_INTERCEPTED:
-      return "The scheme has been intercepted";
-    case PROTOCOL_NOT_INTERCEPTED:
-      return "The scheme has not been intercepted";
-    default:
-      return "Unexpected error";
-  }
-}
-
-// static
-mate::Handle<Protocol> Protocol::Create(v8::Isolate* isolate,
-                                        AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new Protocol(isolate, browser_context));
-}
-
-// static
-void Protocol::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Protocol"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("registerServiceWorkerSchemes",
-                 &Protocol::RegisterServiceWorkerSchemes)
-      .SetMethod("registerStringProtocol",
-                 &Protocol::RegisterProtocol<URLRequestStringJob>)
-      .SetMethod("registerBufferProtocol",
-                 &Protocol::RegisterProtocol<URLRequestBufferJob>)
-      .SetMethod("registerFileProtocol",
-                 &Protocol::RegisterProtocol<URLRequestAsyncAsarJob>)
-      .SetMethod("registerHttpProtocol",
-                 &Protocol::RegisterProtocol<URLRequestFetchJob>)
-      .SetMethod("registerStreamProtocol",
-                 &Protocol::RegisterProtocol<URLRequestStreamJob>)
-      .SetMethod("unregisterProtocol", &Protocol::UnregisterProtocol)
-      .SetMethod("isProtocolHandled", &Protocol::IsProtocolHandled)
-      .SetMethod("interceptStringProtocol",
-                 &Protocol::InterceptProtocol<URLRequestStringJob>)
-      .SetMethod("interceptBufferProtocol",
-                 &Protocol::InterceptProtocol<URLRequestBufferJob>)
-      .SetMethod("interceptFileProtocol",
-                 &Protocol::InterceptProtocol<URLRequestAsyncAsarJob>)
-      .SetMethod("interceptHttpProtocol",
-                 &Protocol::InterceptProtocol<URLRequestFetchJob>)
-      .SetMethod("interceptStreamProtocol",
-                 &Protocol::InterceptProtocol<URLRequestStreamJob>)
-      .SetMethod("uninterceptProtocol", &Protocol::UninterceptProtocol);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args) {
-  if (atom::Browser::Get()->is_ready()) {
-    args->ThrowError(
-        "protocol.registerStandardSchemes should be called before "
-        "app is ready");
-    return;
-  }
-
-  atom::api::RegisterStandardSchemes(schemes, args);
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.SetMethod("registerStandardSchemes", &RegisterStandardSchemes);
-  dict.SetMethod("getStandardSchemes", &atom::api::GetStandardSchemes);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_protocol, Initialize)
removed in remote
  base   100644 107fbf1ce7125ab3426edc893acb358ec8edfeee atom/browser/api/atom_api_protocol.h
  our    100644 deaf680c996ce0dd74af45e7c7c95f711884bb07 atom/browser/api/atom_api_protocol.h
@@ -1,199 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
-#define ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/net/atom_url_request_job_factory.h"
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "net/url_request/url_request_context.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace atom {
-
-namespace api {
-
-std::vector<std::string> GetStandardSchemes();
-void RegisterStandardSchemes(const std::vector<std::string>& schemes,
-                             mate::Arguments* args);
-
-class Protocol : public mate::TrackableObject<Protocol> {
- public:
-  using Handler =
-      base::Callback<void(const base::DictionaryValue&, v8::Local<v8::Value>)>;
-  using CompletionCallback = base::Callback<void(v8::Local<v8::Value>)>;
-  using BooleanCallback = base::Callback<void(bool)>;
-
-  static mate::Handle<Protocol> Create(v8::Isolate* isolate,
-                                       AtomBrowserContext* browser_context);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Protocol(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Protocol() override;
-
- private:
-  // Possible errors.
-  enum ProtocolError {
-    PROTOCOL_OK,    // no error
-    PROTOCOL_FAIL,  // operation failed, should never occur
-    PROTOCOL_REGISTERED,
-    PROTOCOL_NOT_REGISTERED,
-    PROTOCOL_INTERCEPTED,
-    PROTOCOL_NOT_INTERCEPTED,
-  };
-
-  // The protocol handler that will create a protocol handler for certain
-  // request job.
-  template <typename RequestJob>
-  class CustomProtocolHandler
-      : public net::URLRequestJobFactory::ProtocolHandler {
-   public:
-    CustomProtocolHandler(v8::Isolate* isolate,
-                          net::URLRequestContextGetter* request_context,
-                          const Handler& handler)
-        : isolate_(isolate),
-          request_context_(request_context),
-          handler_(handler) {}
-    ~CustomProtocolHandler() override {}
-
-    net::URLRequestJob* MaybeCreateJob(
-        net::URLRequest* request,
-        net::NetworkDelegate* network_delegate) const override {
-      RequestJob* request_job = new RequestJob(request, network_delegate);
-      request_job->SetHandlerInfo(isolate_, request_context_, handler_);
-      return request_job;
-    }
-
-   private:
-    v8::Isolate* isolate_;
-    net::URLRequestContextGetter* request_context_;
-    Protocol::Handler handler_;
-
-    DISALLOW_COPY_AND_ASSIGN(CustomProtocolHandler);
-  };
-
-  // Register schemes that can handle service worker.
-  void RegisterServiceWorkerSchemes(const std::vector<std::string>& schemes);
-
-  // Register the protocol with certain request job.
-  template <typename RequestJob>
-  void RegisterProtocol(const std::string& scheme,
-                        const Handler& handler,
-                        mate::Arguments* args) {
-    CompletionCallback callback;
-    args->GetNext(&callback);
-    auto* getter = browser_context_->GetRequestContext();
-    content::BrowserThread::PostTaskAndReplyWithResult(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&Protocol::RegisterProtocolInIO<RequestJob>,
-                       base::RetainedRef(getter), isolate(), scheme, handler),
-        base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-  }
-  template <typename RequestJob>
-  static ProtocolError RegisterProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      v8::Isolate* isolate,
-      const std::string& scheme,
-      const Handler& handler) {
-    auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-        request_context_getter->job_factory());
-    if (job_factory->IsHandledProtocol(scheme))
-      return PROTOCOL_REGISTERED;
-    auto protocol_handler = std::make_unique<CustomProtocolHandler<RequestJob>>(
-        isolate, request_context_getter.get(), handler);
-    if (job_factory->SetProtocolHandler(scheme, std::move(protocol_handler)))
-      return PROTOCOL_OK;
-    else
-      return PROTOCOL_FAIL;
-  }
-
-  // Unregister the protocol handler that handles |scheme|.
-  void UnregisterProtocol(const std::string& scheme, mate::Arguments* args);
-  static ProtocolError UnregisterProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Whether the protocol has handler registered.
-  void IsProtocolHandled(const std::string& scheme,
-                         const BooleanCallback& callback);
-  static bool IsProtocolHandledInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Replace the protocol handler with a new one.
-  template <typename RequestJob>
-  void InterceptProtocol(const std::string& scheme,
-                         const Handler& handler,
-                         mate::Arguments* args) {
-    CompletionCallback callback;
-    args->GetNext(&callback);
-    auto* getter = browser_context_->GetRequestContext();
-    content::BrowserThread::PostTaskAndReplyWithResult(
-        content::BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&Protocol::InterceptProtocolInIO<RequestJob>,
-                       base::RetainedRef(getter), isolate(), scheme, handler),
-        base::BindOnce(&Protocol::OnIOCompleted, GetWeakPtr(), callback));
-  }
-  template <typename RequestJob>
-  static ProtocolError InterceptProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      v8::Isolate* isolate,
-      const std::string& scheme,
-      const Handler& handler) {
-    auto* job_factory = static_cast<AtomURLRequestJobFactory*>(
-        request_context_getter->job_factory());
-    if (!job_factory->IsHandledProtocol(scheme))
-      return PROTOCOL_NOT_REGISTERED;
-    // It is possible a protocol is handled but can not be intercepted.
-    if (!job_factory->HasProtocolHandler(scheme))
-      return PROTOCOL_FAIL;
-    auto protocol_handler = std::make_unique<CustomProtocolHandler<RequestJob>>(
-        isolate, request_context_getter.get(), handler);
-    if (!job_factory->InterceptProtocol(scheme, std::move(protocol_handler)))
-      return PROTOCOL_INTERCEPTED;
-    return PROTOCOL_OK;
-  }
-
-  // Restore the |scheme| to its original protocol handler.
-  void UninterceptProtocol(const std::string& scheme, mate::Arguments* args);
-  static ProtocolError UninterceptProtocolInIO(
-      scoped_refptr<brightray::URLRequestContextGetter> request_context_getter,
-      const std::string& scheme);
-
-  // Convert error code to JS exception and call the callback.
-  void OnIOCompleted(const CompletionCallback& callback, ProtocolError error);
-
-  // Convert error code to string.
-  std::string ErrorCodeToString(ProtocolError error);
-
-  base::WeakPtr<Protocol> GetWeakPtr() { return weak_factory_.GetWeakPtr(); }
-
-  scoped_refptr<AtomBrowserContext> browser_context_;
-  base::WeakPtrFactory<Protocol> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(Protocol);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_PROTOCOL_H_
removed in remote
  base   100644 407a71f0cc4134a0eeaabfd69e3240e0cee83367 atom/browser/api/atom_api_screen.cc
  our    100644 65a11eed0cce32cc08b188155a97f6a51f2c03f1 atom/browser/api/atom_api_screen.cc
@@ -1,172 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_screen.h"
-
-#include <algorithm>
-#include <string>
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "base/bind.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/gfx/geometry/point.h"
-
-#if defined(OS_WIN)
-#include "ui/display/win/screen_win.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-// Find an item in container according to its ID.
-template <class T>
-typename T::iterator FindById(T* container, int id) {
-  auto predicate = [id](const typename T::value_type& item) -> bool {
-    return item.id() == id;
-  };
-  return std::find_if(container->begin(), container->end(), predicate);
-}
-
-// Convert the changed_metrics bitmask to string array.
-std::vector<std::string> MetricsToArray(uint32_t metrics) {
-  std::vector<std::string> array;
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_BOUNDS)
-    array.push_back("bounds");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_WORK_AREA)
-    array.push_back("workArea");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR)
-    array.push_back("scaleFactor");
-  if (metrics & display::DisplayObserver::DISPLAY_METRIC_ROTATION)
-    array.push_back("rotation");
-  return array;
-}
-
-}  // namespace
-
-Screen::Screen(v8::Isolate* isolate, display::Screen* screen)
-    : screen_(screen) {
-  screen_->AddObserver(this);
-  Init(isolate);
-}
-
-Screen::~Screen() {
-  screen_->RemoveObserver(this);
-}
-
-gfx::Point Screen::GetCursorScreenPoint() {
-  return screen_->GetCursorScreenPoint();
-}
-
-display::Display Screen::GetPrimaryDisplay() {
-  return screen_->GetPrimaryDisplay();
-}
-
-std::vector<display::Display> Screen::GetAllDisplays() {
-  return screen_->GetAllDisplays();
-}
-
-display::Display Screen::GetDisplayNearestPoint(const gfx::Point& point) {
-  return screen_->GetDisplayNearestPoint(point);
-}
-
-display::Display Screen::GetDisplayMatching(const gfx::Rect& match_rect) {
-  return screen_->GetDisplayMatching(match_rect);
-}
-
-#if defined(OS_WIN)
-
-static gfx::Rect ScreenToDIPRect(atom::NativeWindow* window,
-                                 const gfx::Rect& rect) {
-  HWND hwnd = window ? window->GetAcceleratedWidget() : nullptr;
-  return display::win::ScreenWin::ScreenToDIPRect(hwnd, rect);
-}
-
-static gfx::Rect DIPToScreenRect(atom::NativeWindow* window,
-                                 const gfx::Rect& rect) {
-  HWND hwnd = window ? window->GetAcceleratedWidget() : nullptr;
-  return display::win::ScreenWin::DIPToScreenRect(hwnd, rect);
-}
-
-#endif
-
-void Screen::OnDisplayAdded(const display::Display& new_display) {
-  Emit("display-added", new_display);
-}
-
-void Screen::OnDisplayRemoved(const display::Display& old_display) {
-  Emit("display-removed", old_display);
-}
-
-void Screen::OnDisplayMetricsChanged(const display::Display& display,
-                                     uint32_t changed_metrics) {
-  Emit("display-metrics-changed", display, MetricsToArray(changed_metrics));
-}
-
-// static
-v8::Local<v8::Value> Screen::Create(v8::Isolate* isolate) {
-  if (!Browser::Get()->is_ready()) {
-    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate, "Cannot require \"screen\" module before app is ready")));
-    return v8::Null(isolate);
-  }
-
-  display::Screen* screen = display::Screen::GetScreen();
-  if (!screen) {
-    isolate->ThrowException(v8::Exception::Error(
-        mate::StringToV8(isolate, "Failed to get screen information")));
-    return v8::Null(isolate);
-  }
-
-  return mate::CreateHandle(isolate, new Screen(isolate, screen)).ToV8();
-}
-
-// static
-void Screen::BuildPrototype(v8::Isolate* isolate,
-                            v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Screen"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("getCursorScreenPoint", &Screen::GetCursorScreenPoint)
-      .SetMethod("getPrimaryDisplay", &Screen::GetPrimaryDisplay)
-      .SetMethod("getAllDisplays", &Screen::GetAllDisplays)
-      .SetMethod("getDisplayNearestPoint", &Screen::GetDisplayNearestPoint)
-#if defined(OS_WIN)
-      .SetMethod("screenToDipPoint", &display::win::ScreenWin::ScreenToDIPPoint)
-      .SetMethod("dipToScreenPoint", &display::win::ScreenWin::DIPToScreenPoint)
-      .SetMethod("screenToDipRect", &ScreenToDIPRect)
-      .SetMethod("dipToScreenRect", &DIPToScreenRect)
-#endif
-      .SetMethod("getDisplayMatching", &Screen::GetDisplayMatching);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Screen;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("screen", Screen::Create(isolate));
-  dict.Set("Screen", Screen::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_screen, Initialize)
removed in remote
  base   100644 f724130fa7fca10cd2d088d05eadd15d0e9016c7 atom/browser/api/atom_api_screen.h
  our    100644 33c322abf4dc072f187004e28dd5f5a2583b45ce atom/browser/api/atom_api_screen.h
@@ -1,59 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_SCREEN_H_
-#define ATOM_BROWSER_API_ATOM_API_SCREEN_H_
-
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "native_mate/handle.h"
-#include "ui/display/display_observer.h"
-#include "ui/display/screen.h"
-
-namespace gfx {
-class Point;
-class Rect;
-class Screen;
-}  // namespace gfx
-
-namespace atom {
-
-namespace api {
-
-class Screen : public mate::EventEmitter<Screen>,
-               public display::DisplayObserver {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Screen(v8::Isolate* isolate, display::Screen* screen);
-  ~Screen() override;
-
-  gfx::Point GetCursorScreenPoint();
-  display::Display GetPrimaryDisplay();
-  std::vector<display::Display> GetAllDisplays();
-  display::Display GetDisplayNearestPoint(const gfx::Point& point);
-  display::Display GetDisplayMatching(const gfx::Rect& match_rect);
-
-  // display::DisplayObserver:
-  void OnDisplayAdded(const display::Display& new_display) override;
-  void OnDisplayRemoved(const display::Display& old_display) override;
-  void OnDisplayMetricsChanged(const display::Display& display,
-                               uint32_t changed_metrics) override;
-
- private:
-  display::Screen* screen_;
-
-  DISALLOW_COPY_AND_ASSIGN(Screen);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_SCREEN_H_
removed in remote
  base   100644 0f104c760724cb83d421f9ed0225eaa8568898fe atom/browser/api/atom_api_session.cc
  our    100644 658f913bb60b66ae1bf3aae97d7d9158e56f7ee0 atom/browser/api/atom_api_session.cc
@@ -1,865 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_session.h"
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_cookies.h"
-#include "atom/browser/api/atom_api_download_item.h"
-#include "atom/browser/api/atom_api_protocol.h"
-#include "atom/browser/api/atom_api_web_request.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/net/atom_cert_verifier.h"
-#include "atom/browser/session_preferences.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/files/file_path.h"
-#include "base/guid.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "brightray/browser/media/media_device_id_salt.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/common/pref_names.h"
-#include "components/download/public/common/download_danger_type.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_item_utils.h"
-#include "content/public/browser/download_manager_delegate.h"
-#include "content/public/browser/storage_partition.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/base/load_flags.h"
-#include "net/disk_cache/disk_cache.h"
-#include "net/dns/host_cache.h"
-#include "net/http/http_auth_handler_factory.h"
-#include "net/http/http_auth_preferences.h"
-#include "net/proxy_resolution/proxy_config_service_fixed.h"
-#include "net/proxy_resolution/proxy_service.h"
-#include "net/url_request/static_http_user_agent_settings.h"
-#include "net/url_request/url_request_context.h"
-#include "net/url_request/url_request_context_getter.h"
-#include "services/network/throttling/network_conditions.h"
-#include "services/network/throttling/throttling_controller.h"
-#include "ui/base/l10n/l10n_util.h"
-
-using atom::api::Cookies;
-using content::BrowserThread;
-using content::StoragePartition;
-
-namespace {
-
-struct ClearStorageDataOptions {
-  GURL origin;
-  uint32_t storage_types = StoragePartition::REMOVE_DATA_MASK_ALL;
-  uint32_t quota_types = StoragePartition::QUOTA_MANAGED_STORAGE_MASK_ALL;
-};
-
-struct ClearAuthCacheOptions {
-  std::string type;
-  GURL origin;
-  std::string realm;
-  base::string16 username;
-  base::string16 password;
-  net::HttpAuth::Scheme auth_scheme;
-};
-
-uint32_t GetStorageMask(const std::vector<std::string>& storage_types) {
-  uint32_t storage_mask = 0;
-  for (const auto& it : storage_types) {
-    auto type = base::ToLowerASCII(it);
-    if (type == "appcache")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_APPCACHE;
-    else if (type == "cookies")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_COOKIES;
-    else if (type == "filesystem")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;
-    else if (type == "indexdb")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;
-    else if (type == "localstorage")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;
-    else if (type == "shadercache")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;
-    else if (type == "websql")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_WEBSQL;
-    else if (type == "serviceworkers")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;
-    else if (type == "cachestorage")
-      storage_mask |= StoragePartition::REMOVE_DATA_MASK_CACHE_STORAGE;
-  }
-  return storage_mask;
-}
-
-uint32_t GetQuotaMask(const std::vector<std::string>& quota_types) {
-  uint32_t quota_mask = 0;
-  for (const auto& it : quota_types) {
-    auto type = base::ToLowerASCII(it);
-    if (type == "temporary")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY;
-    else if (type == "persistent")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;
-    else if (type == "syncable")
-      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_SYNCABLE;
-  }
-  return quota_mask;
-}
-
-net::HttpAuth::Scheme GetAuthSchemeFromString(const std::string& scheme) {
-  if (scheme == "basic")
-    return net::HttpAuth::AUTH_SCHEME_BASIC;
-  if (scheme == "digest")
-    return net::HttpAuth::AUTH_SCHEME_DIGEST;
-  if (scheme == "ntlm")
-    return net::HttpAuth::AUTH_SCHEME_NTLM;
-  if (scheme == "negotiate")
-    return net::HttpAuth::AUTH_SCHEME_NEGOTIATE;
-  return net::HttpAuth::AUTH_SCHEME_MAX;
-}
-
-void SetUserAgentInIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                      const std::string& accept_lang,
-                      const std::string& user_agent) {
-  getter->GetURLRequestContext()->set_http_user_agent_settings(
-      new net::StaticHttpUserAgentSettings(
-          net::HttpUtil::GenerateAcceptLanguageHeader(accept_lang),
-          user_agent));
-}
-
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<ClearStorageDataOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ClearStorageDataOptions* out) {
-    mate::Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    options.Get("origin", &out->origin);
-    std::vector<std::string> types;
-    if (options.Get("storages", &types))
-      out->storage_types = GetStorageMask(types);
-    if (options.Get("quotas", &types))
-      out->quota_types = GetQuotaMask(types);
-    return true;
-  }
-};
-
-template <>
-struct Converter<ClearAuthCacheOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ClearAuthCacheOptions* out) {
-    mate::Dictionary options;
-    if (!ConvertFromV8(isolate, val, &options))
-      return false;
-    options.Get("type", &out->type);
-    options.Get("origin", &out->origin);
-    options.Get("realm", &out->realm);
-    options.Get("username", &out->username);
-    options.Get("password", &out->password);
-    std::string scheme;
-    if (options.Get("scheme", &scheme))
-      out->auth_scheme = GetAuthSchemeFromString(scheme);
-    return true;
-  }
-};
-
-template <>
-struct Converter<net::ProxyConfig> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     net::ProxyConfig* out) {
-    std::string proxy_rules, proxy_bypass_rules;
-    GURL pac_url;
-    mate::Dictionary options;
-    // Fallback to previous API when passed String.
-    // https://git.io/vuhjj
-    if (ConvertFromV8(isolate, val, &proxy_rules)) {
-      pac_url = GURL(proxy_rules);  // Assume it is PAC script if it is URL.
-    } else if (ConvertFromV8(isolate, val, &options)) {
-      options.Get("pacScript", &pac_url);
-      options.Get("proxyRules", &proxy_rules);
-      options.Get("proxyBypassRules", &proxy_bypass_rules);
-    } else {
-      return false;
-    }
-
-    // pacScript takes precedence over proxyRules.
-    if (!pac_url.is_empty() && pac_url.is_valid()) {
-      out->set_pac_url(pac_url);
-    } else {
-      out->proxy_rules().ParseFromString(proxy_rules);
-      out->proxy_rules().bypass_rules.ParseFromString(proxy_bypass_rules);
-    }
-    return true;
-  }
-};
-
-template <>
-struct Converter<atom::VerifyRequestParams> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::VerifyRequestParams val) {
-    mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-    dict.Set("hostname", val.hostname);
-    dict.Set("certificate", val.certificate);
-    dict.Set("verificationResult", val.default_result);
-    dict.Set("errorCode", val.error_code);
-    return dict.GetHandle();
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-const char kPersistPrefix[] = "persist:";
-
-// Referenced session objects.
-std::map<uint32_t, v8::Global<v8::Object>> g_sessions;
-
-class ResolveProxyHelper {
- public:
-  ResolveProxyHelper(AtomBrowserContext* browser_context,
-                     const GURL& url,
-                     const Session::ResolveProxyCallback& callback)
-      : callback_(callback),
-        original_thread_(base::ThreadTaskRunnerHandle::Get()) {
-    scoped_refptr<net::URLRequestContextGetter> context_getter =
-        browser_context->GetRequestContext();
-    context_getter->GetNetworkTaskRunner()->PostTask(
-        FROM_HERE, base::BindOnce(&ResolveProxyHelper::ResolveProxy,
-                                  base::Unretained(this), context_getter, url));
-  }
-
-  void OnResolveProxyCompleted(int result) {
-    std::string proxy;
-    if (result == net::OK)
-      proxy = proxy_info_.ToPacString();
-    original_thread_->PostTask(FROM_HERE, base::BindOnce(callback_, proxy));
-    delete this;
-  }
-
- private:
-  void ResolveProxy(scoped_refptr<net::URLRequestContextGetter> context_getter,
-                    const GURL& url) {
-    DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
-
-    net::ProxyResolutionService* proxy_service =
-        context_getter->GetURLRequestContext()->proxy_resolution_service();
-    net::CompletionCallback completion_callback = base::Bind(
-        &ResolveProxyHelper::OnResolveProxyCompleted, base::Unretained(this));
-
-    // Start the request.
-    int result = proxy_service->ResolveProxy(url, "GET", &proxy_info_,
-                                             completion_callback, &pac_req_,
-                                             nullptr, net::NetLogWithSource());
-
-    // Completed synchronously.
-    if (result != net::ERR_IO_PENDING)
-      completion_callback.Run(result);
-  }
-
-  Session::ResolveProxyCallback callback_;
-  net::ProxyInfo proxy_info_;
-  net::ProxyResolutionService::Request* pac_req_;
-  scoped_refptr<base::SingleThreadTaskRunner> original_thread_;
-
-  DISALLOW_COPY_AND_ASSIGN(ResolveProxyHelper);
-};
-
-// Runs the callback in UI thread.
-void RunCallbackInUI(const base::Callback<void()>& callback) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
-}
-template <typename... T>
-void RunCallbackInUI(const base::Callback<void(T...)>& callback, T... result) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(callback, result...));
-}
-
-// Callback of HttpCache::GetBackend.
-void OnGetBackend(disk_cache::Backend** backend_ptr,
-                  Session::CacheAction action,
-                  const net::CompletionCallback& callback,
-                  int result) {
-  if (result != net::OK) {
-    RunCallbackInUI(callback, result);
-  } else if (backend_ptr && *backend_ptr) {
-    if (action == Session::CacheAction::CLEAR) {
-      (*backend_ptr)
-          ->DoomAllEntries(base::Bind(&RunCallbackInUI<int>, callback));
-    } else if (action == Session::CacheAction::STATS) {
-      base::StringPairs stats;
-      (*backend_ptr)->GetStats(&stats);
-      for (const auto& stat : stats) {
-        if (stat.first == "Current size") {
-          int current_size;
-          base::StringToInt(stat.second, &current_size);
-          RunCallbackInUI(callback, current_size);
-          break;
-        }
-      }
-    }
-  } else {
-    RunCallbackInUI<int>(callback, net::ERR_FAILED);
-  }
-}
-
-void DoCacheActionInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    Session::CacheAction action,
-    const net::CompletionCallback& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* http_cache = request_context->http_transaction_factory()->GetCache();
-  if (!http_cache)
-    RunCallbackInUI<int>(callback, net::ERR_FAILED);
-
-  // Call GetBackend and make the backend's ptr accessable in OnGetBackend.
-  using BackendPtr = disk_cache::Backend*;
-  auto** backend_ptr = new BackendPtr(nullptr);
-  net::CompletionCallback on_get_backend =
-      base::Bind(&OnGetBackend, base::Owned(backend_ptr), action, callback);
-  int rv = http_cache->GetBackend(backend_ptr, on_get_backend);
-  if (rv != net::ERR_IO_PENDING)
-    on_get_backend.Run(net::OK);
-}
-
-void SetProxyInIO(scoped_refptr<net::URLRequestContextGetter> getter,
-                  const net::ProxyConfig& config,
-                  const base::Closure& callback) {
-  auto* proxy_service =
-      getter->GetURLRequestContext()->proxy_resolution_service();
-  proxy_service->ResetConfigService(
-      base::WrapUnique(new net::ProxyConfigServiceFixed(config)));
-  // Refetches and applies the new pac script if provided.
-  proxy_service->ForceReloadProxyConfig();
-  RunCallbackInUI(callback);
-}
-
-void SetCertVerifyProcInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const AtomCertVerifier::VerifyProc& proc) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  static_cast<AtomCertVerifier*>(request_context->cert_verifier())
-      ->SetVerifyProc(proc);
-}
-
-void ClearHostResolverCacheInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const base::Closure& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* cache = request_context->host_resolver()->GetHostCache();
-  if (cache) {
-    cache->clear();
-    DCHECK_EQ(0u, cache->size());
-    if (!callback.is_null())
-      RunCallbackInUI(callback);
-  }
-}
-
-void ClearAuthCacheInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const ClearAuthCacheOptions& options,
-    const base::Closure& callback) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* network_session =
-      request_context->http_transaction_factory()->GetSession();
-  if (network_session) {
-    if (options.type == "password") {
-      auto* auth_cache = network_session->http_auth_cache();
-      if (!options.origin.is_empty()) {
-        auth_cache->Remove(
-            options.origin, options.realm, options.auth_scheme,
-            net::AuthCredentials(options.username, options.password));
-      } else {
-        auth_cache->ClearEntriesAddedWithin(base::TimeDelta::Max());
-      }
-    } else if (options.type == "clientCertificate") {
-      auto* client_auth_cache = network_session->ssl_client_auth_cache();
-      client_auth_cache->Remove(net::HostPortPair::FromURL(options.origin));
-    }
-    network_session->CloseAllConnections();
-  }
-  if (!callback.is_null())
-    RunCallbackInUI(callback);
-}
-
-void AllowNTLMCredentialsForDomainsInIO(
-    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
-    const std::string& domains) {
-  auto* request_context = context_getter->GetURLRequestContext();
-  auto* auth_handler = request_context->http_auth_handler_factory();
-  if (auth_handler) {
-    auto* auth_preferences = const_cast<net::HttpAuthPreferences*>(
-        auth_handler->http_auth_preferences());
-    if (auth_preferences)
-      auth_preferences->SetServerWhitelist(domains);
-  }
-}
-
-void OnClearStorageDataDone(const base::Closure& callback) {
-  if (!callback.is_null())
-    callback.Run();
-}
-
-void DownloadIdCallback(content::DownloadManager* download_manager,
-                        const base::FilePath& path,
-                        const std::vector<GURL>& url_chain,
-                        const std::string& mime_type,
-                        int64_t offset,
-                        int64_t length,
-                        const std::string& last_modified,
-                        const std::string& etag,
-                        const base::Time& start_time,
-                        uint32_t id) {
-  download_manager->CreateDownloadItem(
-      base::GenerateGUID(), id, path, path, url_chain, GURL(), GURL(), GURL(),
-      GURL(), mime_type, mime_type, start_time, base::Time(), etag,
-      last_modified, offset, length, std::string(),
-      download::DownloadItem::INTERRUPTED,
-      download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-      download::DOWNLOAD_INTERRUPT_REASON_NETWORK_TIMEOUT, false, base::Time(),
-      false, std::vector<download::DownloadItem::ReceivedSlice>());
-}
-
-void SetDevToolsNetworkEmulationClientIdInIO(
-    brightray::URLRequestContextGetter* url_request_context_getter,
-    const std::string& client_id) {
-  if (!url_request_context_getter)
-    return;
-  net::URLRequestContext* context =
-      url_request_context_getter->GetURLRequestContext();
-  AtomNetworkDelegate* network_delegate =
-      static_cast<AtomNetworkDelegate*>(context->network_delegate());
-  network_delegate->SetDevToolsNetworkEmulationClientId(client_id);
-}
-
-void DestroyGlobalHandle(v8::Isolate* isolate,
-                         const v8::Global<v8::Value>& global_handle) {
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  if (!global_handle.IsEmpty()) {
-    v8::Local<v8::Value> local_handle = global_handle.Get(isolate);
-    if (local_handle->IsObject()) {
-      v8::Local<v8::Object> object = local_handle->ToObject();
-      void* ptr = object->GetAlignedPointerFromInternalField(0);
-      if (!ptr)
-        return;
-      delete static_cast<mate::WrappableBase*>(ptr);
-      object->SetAlignedPointerInInternalField(0, nullptr);
-    }
-  }
-}
-
-}  // namespace
-
-Session::Session(v8::Isolate* isolate, AtomBrowserContext* browser_context)
-    : devtools_network_emulation_client_id_(base::GenerateGUID()),
-      browser_context_(browser_context) {
-  // Observe DownloadManager to get download notifications.
-  content::BrowserContext::GetDownloadManager(browser_context)
-      ->AddObserver(this);
-
-  new SessionPreferences(browser_context);
-
-  Init(isolate);
-  AttachAsUserData(browser_context);
-}
-
-Session::~Session() {
-  content::BrowserContext::GetDownloadManager(browser_context())
-      ->RemoveObserver(this);
-  DestroyGlobalHandle(isolate(), cookies_);
-  DestroyGlobalHandle(isolate(), web_request_);
-  DestroyGlobalHandle(isolate(), protocol_);
-  g_sessions.erase(weak_map_id());
-}
-
-void Session::OnDownloadCreated(content::DownloadManager* manager,
-                                download::DownloadItem* item) {
-  if (item->IsSavePackageDownload())
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto handle = DownloadItem::Create(isolate(), item);
-  if (item->GetState() == download::DownloadItem::INTERRUPTED)
-    handle->SetSavePath(item->GetTargetFilePath());
-  content::WebContents* web_contents =
-      content::DownloadItemUtils::GetWebContents(item);
-  bool prevent_default = Emit("will-download", handle, web_contents);
-  if (prevent_default) {
-    item->Cancel(true);
-    item->Remove();
-  }
-}
-
-void Session::ResolveProxy(const GURL& url, ResolveProxyCallback callback) {
-  new ResolveProxyHelper(browser_context(), url, callback);
-}
-
-template <Session::CacheAction action>
-void Session::DoCacheAction(const net::CompletionCallback& callback) {
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&DoCacheActionInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     action, callback));
-}
-
-void Session::ClearStorageData(mate::Arguments* args) {
-  // clearStorageData([options, callback])
-  ClearStorageDataOptions options;
-  base::Closure callback;
-  args->GetNext(&options);
-  args->GetNext(&callback);
-
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
-  if (options.storage_types & StoragePartition::REMOVE_DATA_MASK_COOKIES) {
-    // Reset media device id salt when cookies are cleared.
-    // https://w3c.github.io/mediacapture-main/#dom-mediadeviceinfo-deviceid
-    brightray::MediaDeviceIDSalt::Reset(browser_context()->prefs());
-  }
-  storage_partition->ClearData(
-      options.storage_types, options.quota_types, options.origin,
-      content::StoragePartition::OriginMatcherFunction(), base::Time(),
-      base::Time::Max(), base::Bind(&OnClearStorageDataDone, callback));
-}
-
-void Session::FlushStorageData() {
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
-  storage_partition->Flush();
-}
-
-void Session::SetProxy(const net::ProxyConfig& config,
-                       const base::Closure& callback) {
-  auto* getter = browser_context_->GetRequestContext();
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetProxyInIO, base::RetainedRef(getter), config,
-                     callback));
-}
-
-void Session::SetDownloadPath(const base::FilePath& path) {
-  browser_context_->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
-                                         path);
-}
-
-void Session::EnableNetworkEmulation(const mate::Dictionary& options) {
-  std::unique_ptr<network::NetworkConditions> conditions;
-  bool offline = false;
-  double latency = 0.0, download_throughput = 0.0, upload_throughput = 0.0;
-  if (options.Get("offline", &offline) && offline) {
-    conditions.reset(new network::NetworkConditions(offline));
-  } else {
-    options.Get("latency", &latency);
-    options.Get("downloadThroughput", &download_throughput);
-    options.Get("uploadThroughput", &upload_throughput);
-    conditions.reset(new network::NetworkConditions(
-        false, latency, download_throughput, upload_throughput));
-  }
-
-  network::ThrottlingController::SetConditions(
-      devtools_network_emulation_client_id_, std::move(conditions));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetDevToolsNetworkEmulationClientIdInIO,
-                     base::RetainedRef(browser_context_->GetRequestContext()),
-                     devtools_network_emulation_client_id_));
-}
-
-void Session::DisableNetworkEmulation() {
-  auto conditions = std::make_unique<network::NetworkConditions>();
-  network::ThrottlingController::SetConditions(
-      devtools_network_emulation_client_id_, std::move(conditions));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetDevToolsNetworkEmulationClientIdInIO,
-                     base::RetainedRef(browser_context_->GetRequestContext()),
-                     std::string()));
-}
-
-void Session::SetCertVerifyProc(v8::Local<v8::Value> val,
-                                mate::Arguments* args) {
-  AtomCertVerifier::VerifyProc proc;
-  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &proc))) {
-    args->ThrowError("Must pass null or function");
-    return;
-  }
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&SetCertVerifyProcInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     proc));
-}
-
-void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,
-                                          mate::Arguments* args) {
-  AtomPermissionManager::RequestHandler handler;
-  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &handler))) {
-    args->ThrowError("Must pass null or function");
-    return;
-  }
-  auto* permission_manager = static_cast<AtomPermissionManager*>(
-      browser_context()->GetPermissionManager());
-  permission_manager->SetPermissionRequestHandler(handler);
-}
-
-void Session::ClearHostResolverCache(mate::Arguments* args) {
-  base::Closure callback;
-  args->GetNext(&callback);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&ClearHostResolverCacheInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     callback));
-}
-
-void Session::ClearAuthCache(mate::Arguments* args) {
-  ClearAuthCacheOptions options;
-  if (!args->GetNext(&options)) {
-    args->ThrowError("Must specify options object");
-    return;
-  }
-  base::Closure callback;
-  args->GetNext(&callback);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&ClearAuthCacheInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     options, callback));
-}
-
-void Session::AllowNTLMCredentialsForDomains(const std::string& domains) {
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AllowNTLMCredentialsForDomainsInIO,
-                     WrapRefCounted(browser_context_->GetRequestContext()),
-                     domains));
-}
-
-void Session::SetUserAgent(const std::string& user_agent,
-                           mate::Arguments* args) {
-  browser_context_->SetUserAgent(user_agent);
-
-  std::string accept_lang = g_browser_process->GetApplicationLocale();
-  args->GetNext(&accept_lang);
-
-  scoped_refptr<brightray::URLRequestContextGetter> getter(
-      browser_context_->GetRequestContext());
-  getter->GetNetworkTaskRunner()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&SetUserAgentInIO, getter, accept_lang, user_agent));
-}
-
-std::string Session::GetUserAgent() {
-  return browser_context_->GetUserAgent();
-}
-
-void Session::GetBlobData(const std::string& uuid,
-                          const AtomBlobReader::CompletionCallback& callback) {
-  if (callback.is_null())
-    return;
-
-  AtomBlobReader* blob_reader = browser_context()->GetBlobReader();
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AtomBlobReader::StartReading,
-                     base::Unretained(blob_reader), uuid, callback));
-}
-
-void Session::CreateInterruptedDownload(const mate::Dictionary& options) {
-  int64_t offset = 0, length = 0;
-  double start_time = 0.0;
-  std::string mime_type, last_modified, etag;
-  base::FilePath path;
-  std::vector<GURL> url_chain;
-  options.Get("path", &path);
-  options.Get("urlChain", &url_chain);
-  options.Get("mimeType", &mime_type);
-  options.Get("offset", &offset);
-  options.Get("length", &length);
-  options.Get("lastModified", &last_modified);
-  options.Get("eTag", &etag);
-  options.Get("startTime", &start_time);
-  if (path.empty() || url_chain.empty() || length == 0) {
-    isolate()->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate(), "Must pass non-empty path, urlChain and length.")));
-    return;
-  }
-  if (offset >= length) {
-    isolate()->ThrowException(v8::Exception::Error(mate::StringToV8(
-        isolate(), "Must pass an offset value less than length.")));
-    return;
-  }
-  auto* download_manager =
-      content::BrowserContext::GetDownloadManager(browser_context());
-  download_manager->GetDelegate()->GetNextId(base::Bind(
-      &DownloadIdCallback, download_manager, path, url_chain, mime_type, offset,
-      length, last_modified, etag, base::Time::FromDoubleT(start_time)));
-}
-
-void Session::SetPreloads(
-    const std::vector<base::FilePath::StringType>& preloads) {
-  auto* prefs = SessionPreferences::FromBrowserContext(browser_context());
-  DCHECK(prefs);
-  prefs->set_preloads(preloads);
-}
-
-std::vector<base::FilePath::StringType> Session::GetPreloads() const {
-  auto* prefs = SessionPreferences::FromBrowserContext(browser_context());
-  DCHECK(prefs);
-  return prefs->preloads();
-}
-
-v8::Local<v8::Value> Session::Cookies(v8::Isolate* isolate) {
-  if (cookies_.IsEmpty()) {
-    auto handle = Cookies::Create(isolate, browser_context());
-    cookies_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, cookies_);
-}
-
-v8::Local<v8::Value> Session::Protocol(v8::Isolate* isolate) {
-  if (protocol_.IsEmpty()) {
-    auto handle = atom::api::Protocol::Create(isolate, browser_context());
-    protocol_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, protocol_);
-}
-
-v8::Local<v8::Value> Session::WebRequest(v8::Isolate* isolate) {
-  if (web_request_.IsEmpty()) {
-    auto handle = atom::api::WebRequest::Create(isolate, browser_context());
-    web_request_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, web_request_);
-}
-
-// static
-mate::Handle<Session> Session::CreateFrom(v8::Isolate* isolate,
-                                          AtomBrowserContext* browser_context) {
-  auto* existing = TrackableObject::FromWrappedClass(isolate, browser_context);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<Session*>(existing));
-
-  auto handle =
-      mate::CreateHandle(isolate, new Session(isolate, browser_context));
-
-  // The Sessions should never be garbage collected, since the common pattern is
-  // to use partition strings, instead of using the Session object directly.
-  g_sessions[handle->weak_map_id()] =
-      v8::Global<v8::Object>(isolate, handle.ToV8());
-
-  return handle;
-}
-
-// static
-mate::Handle<Session> Session::FromPartition(
-    v8::Isolate* isolate,
-    const std::string& partition,
-    const base::DictionaryValue& options) {
-  scoped_refptr<AtomBrowserContext> browser_context;
-  if (partition.empty()) {
-    browser_context = AtomBrowserContext::From("", false, options);
-  } else if (base::StartsWith(partition, kPersistPrefix,
-                              base::CompareCase::SENSITIVE)) {
-    std::string name = partition.substr(8);
-    browser_context = AtomBrowserContext::From(name, false, options);
-  } else {
-    browser_context = AtomBrowserContext::From(partition, true, options);
-  }
-  return CreateFrom(isolate, browser_context.get());
-}
-
-// static
-void Session::BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Session"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("resolveProxy", &Session::ResolveProxy)
-      .SetMethod("getCacheSize", &Session::DoCacheAction<CacheAction::STATS>)
-      .SetMethod("clearCache", &Session::DoCacheAction<CacheAction::CLEAR>)
-      .SetMethod("clearStorageData", &Session::ClearStorageData)
-      .SetMethod("flushStorageData", &Session::FlushStorageData)
-      .SetMethod("setProxy", &Session::SetProxy)
-      .SetMethod("setDownloadPath", &Session::SetDownloadPath)
-      .SetMethod("enableNetworkEmulation", &Session::EnableNetworkEmulation)
-      .SetMethod("disableNetworkEmulation", &Session::DisableNetworkEmulation)
-      .SetMethod("setCertificateVerifyProc", &Session::SetCertVerifyProc)
-      .SetMethod("setPermissionRequestHandler",
-                 &Session::SetPermissionRequestHandler)
-      .SetMethod("clearHostResolverCache", &Session::ClearHostResolverCache)
-      .SetMethod("clearAuthCache", &Session::ClearAuthCache)
-      .SetMethod("allowNTLMCredentialsForDomains",
-                 &Session::AllowNTLMCredentialsForDomains)
-      .SetMethod("setUserAgent", &Session::SetUserAgent)
-      .SetMethod("getUserAgent", &Session::GetUserAgent)
-      .SetMethod("getBlobData", &Session::GetBlobData)
-      .SetMethod("createInterruptedDownload",
-                 &Session::CreateInterruptedDownload)
-      .SetMethod("setPreloads", &Session::SetPreloads)
-      .SetMethod("getPreloads", &Session::GetPreloads)
-      .SetProperty("cookies", &Session::Cookies)
-      .SetProperty("protocol", &Session::Protocol)
-      .SetProperty("webRequest", &Session::WebRequest);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Session;
-
-v8::Local<v8::Value> FromPartition(const std::string& partition,
-                                   mate::Arguments* args) {
-  if (!atom::Browser::Get()->is_ready()) {
-    args->ThrowError("Session can only be received when app is ready");
-    return v8::Null(args->isolate());
-  }
-  base::DictionaryValue options;
-  args->GetNext(&options);
-  return Session::FromPartition(args->isolate(), partition, options).ToV8();
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Session", Session::GetConstructor(isolate)->GetFunction());
-  dict.Set("Cookies", Cookies::GetConstructor(isolate)->GetFunction());
-  dict.SetMethod("fromPartition", &FromPartition);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_session, Initialize)
removed in remote
  base   100644 02d8ba5cdec0dca3a0c11cf128ab12d61684b61d atom/browser/api/atom_api_session.h
  our    100644 6c8247c5c4a90e643712dd47d000d37d181a147b atom/browser/api/atom_api_session.h
@@ -1,118 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_SESSION_H_
-#define ATOM_BROWSER_API_ATOM_API_SESSION_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_blob_reader.h"
-#include "base/values.h"
-#include "content/public/browser/download_manager.h"
-#include "native_mate/handle.h"
-#include "net/base/completion_callback.h"
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace net {
-class ProxyConfig;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class Session : public mate::TrackableObject<Session>,
-                public content::DownloadManager::Observer {
- public:
-  using ResolveProxyCallback = base::Callback<void(std::string)>;
-
-  enum class CacheAction {
-    CLEAR,
-    STATS,
-  };
-
-  // Gets or creates Session from the |browser_context|.
-  static mate::Handle<Session> CreateFrom(v8::Isolate* isolate,
-                                          AtomBrowserContext* browser_context);
-
-  // Gets the Session of |partition|.
-  static mate::Handle<Session> FromPartition(
-      v8::Isolate* isolate,
-      const std::string& partition,
-      const base::DictionaryValue& options = base::DictionaryValue());
-
-  AtomBrowserContext* browser_context() const { return browser_context_.get(); }
-
-  // mate::TrackableObject:
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Methods.
-  void ResolveProxy(const GURL& url, ResolveProxyCallback callback);
-  template <CacheAction action>
-  void DoCacheAction(const net::CompletionCallback& callback);
-  void ClearStorageData(mate::Arguments* args);
-  void FlushStorageData();
-  void SetProxy(const net::ProxyConfig& config, const base::Closure& callback);
-  void SetDownloadPath(const base::FilePath& path);
-  void EnableNetworkEmulation(const mate::Dictionary& options);
-  void DisableNetworkEmulation();
-  void SetCertVerifyProc(v8::Local<v8::Value> proc, mate::Arguments* args);
-  void SetPermissionRequestHandler(v8::Local<v8::Value> val,
-                                   mate::Arguments* args);
-  void ClearHostResolverCache(mate::Arguments* args);
-  void ClearAuthCache(mate::Arguments* args);
-  void AllowNTLMCredentialsForDomains(const std::string& domains);
-  void SetUserAgent(const std::string& user_agent, mate::Arguments* args);
-  std::string GetUserAgent();
-  void GetBlobData(const std::string& uuid,
-                   const AtomBlobReader::CompletionCallback& callback);
-  void CreateInterruptedDownload(const mate::Dictionary& options);
-  void SetPreloads(const std::vector<base::FilePath::StringType>& preloads);
-  std::vector<base::FilePath::StringType> GetPreloads() const;
-  v8::Local<v8::Value> Cookies(v8::Isolate* isolate);
-  v8::Local<v8::Value> Protocol(v8::Isolate* isolate);
-  v8::Local<v8::Value> WebRequest(v8::Isolate* isolate);
-
- protected:
-  Session(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~Session() override;
-
-  // content::DownloadManager::Observer:
-  void OnDownloadCreated(content::DownloadManager* manager,
-                         download::DownloadItem* item) override;
-
- private:
-  // Cached object.
-  v8::Global<v8::Value> cookies_;
-  v8::Global<v8::Value> protocol_;
-  v8::Global<v8::Value> web_request_;
-
-  // The X-DevTools-Emulate-Network-Conditions-Client-Id.
-  std::string devtools_network_emulation_client_id_;
-
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(Session);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_SESSION_H_
removed in remote
  base   100644 5f351f4850499922ca36ae3643561cdb0d08b8d0 atom/browser/api/atom_api_tray.cc
  our    100644 552563bacfcda3120cbb6aa63822fff8b4a9beaa atom/browser/api/atom_api_tray.cc
@@ -1,262 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_tray.h"
-
-#include <string>
-
-#include "atom/browser/api/atom_api_menu.h"
-#include "atom/browser/browser.h"
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "native_mate/constructor.h"
-#include "native_mate/dictionary.h"
-#include "ui/gfx/image/image.h"
-
-namespace mate {
-
-template <>
-struct Converter<atom::TrayIcon::HighlightMode> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::TrayIcon::HighlightMode* out) {
-    std::string mode;
-    if (ConvertFromV8(isolate, val, &mode)) {
-      if (mode == "always") {
-        *out = atom::TrayIcon::HighlightMode::ALWAYS;
-        return true;
-      }
-      if (mode == "selection") {
-        *out = atom::TrayIcon::HighlightMode::SELECTION;
-        return true;
-      }
-      if (mode == "never") {
-        *out = atom::TrayIcon::HighlightMode::NEVER;
-        return true;
-      }
-    }
-    return false;
-  }
-};
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-Tray::Tray(v8::Isolate* isolate,
-           v8::Local<v8::Object> wrapper,
-           mate::Handle<NativeImage> image)
-    : tray_icon_(TrayIcon::Create()) {
-  SetImage(isolate, image);
-  tray_icon_->AddObserver(this);
-
-  InitWith(isolate, wrapper);
-}
-
-Tray::~Tray() {
-  // Destroy the native tray in next tick.
-  base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE,
-                                                  tray_icon_.release());
-}
-
-// static
-mate::WrappableBase* Tray::New(mate::Handle<NativeImage> image,
-                               mate::Arguments* args) {
-  if (!Browser::Get()->is_ready()) {
-    args->ThrowError("Cannot create Tray before app is ready");
-    return nullptr;
-  }
-  return new Tray(args->isolate(), args->GetThis(), image);
-}
-
-void Tray::OnClicked(const gfx::Rect& bounds,
-                     const gfx::Point& location,
-                     int modifiers) {
-  EmitWithFlags("click", modifiers, bounds, location);
-}
-
-void Tray::OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {
-  EmitWithFlags("double-click", modifiers, bounds);
-}
-
-void Tray::OnRightClicked(const gfx::Rect& bounds, int modifiers) {
-  EmitWithFlags("right-click", modifiers, bounds);
-}
-
-void Tray::OnBalloonShow() {
-  Emit("balloon-show");
-}
-
-void Tray::OnBalloonClicked() {
-  Emit("balloon-click");
-}
-
-void Tray::OnBalloonClosed() {
-  Emit("balloon-closed");
-}
-
-void Tray::OnDrop() {
-  Emit("drop");
-}
-
-void Tray::OnDropFiles(const std::vector<std::string>& files) {
-  Emit("drop-files", files);
-}
-
-void Tray::OnDropText(const std::string& text) {
-  Emit("drop-text", text);
-}
-
-void Tray::OnMouseEntered(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-enter", modifiers, location);
-}
-
-void Tray::OnMouseExited(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-leave", modifiers, location);
-}
-
-void Tray::OnMouseMoved(const gfx::Point& location, int modifiers) {
-  EmitWithFlags("mouse-move", modifiers, location);
-}
-
-void Tray::OnDragEntered() {
-  Emit("drag-enter");
-}
-
-void Tray::OnDragExited() {
-  Emit("drag-leave");
-}
-
-void Tray::OnDragEnded() {
-  Emit("drag-end");
-}
-
-void Tray::SetImage(v8::Isolate* isolate, mate::Handle<NativeImage> image) {
-#if defined(OS_WIN)
-  tray_icon_->SetImage(image->GetHICON(GetSystemMetrics(SM_CXSMICON)));
-#else
-  tray_icon_->SetImage(image->image());
-#endif
-}
-
-void Tray::SetPressedImage(v8::Isolate* isolate,
-                           mate::Handle<NativeImage> image) {
-#if defined(OS_WIN)
-  tray_icon_->SetPressedImage(image->GetHICON(GetSystemMetrics(SM_CXSMICON)));
-#else
-  tray_icon_->SetPressedImage(image->image());
-#endif
-}
-
-void Tray::SetToolTip(const std::string& tool_tip) {
-  tray_icon_->SetToolTip(tool_tip);
-}
-
-void Tray::SetTitle(const std::string& title) {
-  tray_icon_->SetTitle(title);
-}
-
-void Tray::SetHighlightMode(TrayIcon::HighlightMode mode) {
-  tray_icon_->SetHighlightMode(mode);
-}
-
-void Tray::SetIgnoreDoubleClickEvents(bool ignore) {
-#if defined(OS_MACOSX)
-  tray_icon_->SetIgnoreDoubleClickEvents(ignore);
-#endif
-}
-
-bool Tray::GetIgnoreDoubleClickEvents() {
-#if defined(OS_MACOSX)
-  return tray_icon_->GetIgnoreDoubleClickEvents();
-#else
-  return false;
-#endif
-}
-
-void Tray::DisplayBalloon(mate::Arguments* args,
-                          const mate::Dictionary& options) {
-  mate::Handle<NativeImage> icon;
-  options.Get("icon", &icon);
-  base::string16 title, content;
-  if (!options.Get("title", &title) || !options.Get("content", &content)) {
-    args->ThrowError("'title' and 'content' must be defined");
-    return;
-  }
-
-#if defined(OS_WIN)
-  tray_icon_->DisplayBalloon(
-      icon.IsEmpty() ? NULL : icon->GetHICON(GetSystemMetrics(SM_CXSMICON)),
-      title, content);
-#else
-  tray_icon_->DisplayBalloon(icon.IsEmpty() ? gfx::Image() : icon->image(),
-                             title, content);
-#endif
-}
-
-void Tray::PopUpContextMenu(mate::Arguments* args) {
-  mate::Handle<Menu> menu;
-  args->GetNext(&menu);
-  gfx::Point pos;
-  args->GetNext(&pos);
-  tray_icon_->PopUpContextMenu(pos, menu.IsEmpty() ? nullptr : menu->model());
-}
-
-void Tray::SetContextMenu(v8::Isolate* isolate, mate::Handle<Menu> menu) {
-  menu_.Reset(isolate, menu.ToV8());
-  tray_icon_->SetContextMenu(menu->model());
-}
-
-gfx::Rect Tray::GetBounds() {
-  return tray_icon_->GetBounds();
-}
-
-// static
-void Tray::BuildPrototype(v8::Isolate* isolate,
-                          v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Tray"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("setImage", &Tray::SetImage)
-      .SetMethod("setPressedImage", &Tray::SetPressedImage)
-      .SetMethod("setToolTip", &Tray::SetToolTip)
-      .SetMethod("setTitle", &Tray::SetTitle)
-      .SetMethod("setHighlightMode", &Tray::SetHighlightMode)
-      .SetMethod("setIgnoreDoubleClickEvents",
-                 &Tray::SetIgnoreDoubleClickEvents)
-      .SetMethod("getIgnoreDoubleClickEvents",
-                 &Tray::GetIgnoreDoubleClickEvents)
-      .SetMethod("displayBalloon", &Tray::DisplayBalloon)
-      .SetMethod("popUpContextMenu", &Tray::PopUpContextMenu)
-      .SetMethod("setContextMenu", &Tray::SetContextMenu)
-      .SetMethod("getBounds", &Tray::GetBounds);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::Tray;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  Tray::SetConstructor(isolate, base::Bind(&Tray::New));
-
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("Tray", Tray::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_tray, Initialize)
removed in remote
  base   100644 0e0d153ad0d3adf3944961d2482f554cc8e01650 atom/browser/api/atom_api_tray.h
  our    100644 2ccb836d6299ef4b88c652f3c14c47d4f50a689c atom/browser/api/atom_api_tray.h
@@ -1,91 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_TRAY_H_
-#define ATOM_BROWSER_API_ATOM_API_TRAY_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/ui/tray_icon.h"
-#include "atom/browser/ui/tray_icon_observer.h"
-#include "native_mate/handle.h"
-
-namespace gfx {
-class Image;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace atom {
-
-class TrayIcon;
-
-namespace api {
-
-class Menu;
-class NativeImage;
-
-class Tray : public mate::TrackableObject<Tray>, public TrayIconObserver {
- public:
-  static mate::WrappableBase* New(mate::Handle<NativeImage> image,
-                                  mate::Arguments* args);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  Tray(v8::Isolate* isolate,
-       v8::Local<v8::Object> wrapper,
-       mate::Handle<NativeImage> image);
-  ~Tray() override;
-
-  // TrayIconObserver:
-  void OnClicked(const gfx::Rect& bounds,
-                 const gfx::Point& location,
-                 int modifiers) override;
-  void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) override;
-  void OnRightClicked(const gfx::Rect& bounds, int modifiers) override;
-  void OnBalloonShow() override;
-  void OnBalloonClicked() override;
-  void OnBalloonClosed() override;
-  void OnDrop() override;
-  void OnDropFiles(const std::vector<std::string>& files) override;
-  void OnDropText(const std::string& text) override;
-  void OnDragEntered() override;
-  void OnDragExited() override;
-  void OnDragEnded() override;
-  void OnMouseEntered(const gfx::Point& location, int modifiers) override;
-  void OnMouseExited(const gfx::Point& location, int modifiers) override;
-  void OnMouseMoved(const gfx::Point& location, int modifiers) override;
-
-  void SetImage(v8::Isolate* isolate, mate::Handle<NativeImage> image);
-  void SetPressedImage(v8::Isolate* isolate, mate::Handle<NativeImage> image);
-  void SetToolTip(const std::string& tool_tip);
-  void SetTitle(const std::string& title);
-  void SetHighlightMode(TrayIcon::HighlightMode mode);
-  void SetIgnoreDoubleClickEvents(bool ignore);
-  bool GetIgnoreDoubleClickEvents();
-  void DisplayBalloon(mate::Arguments* args, const mate::Dictionary& options);
-  void PopUpContextMenu(mate::Arguments* args);
-  void SetContextMenu(v8::Isolate* isolate, mate::Handle<Menu> menu);
-  gfx::Rect GetBounds();
-
- private:
-  v8::Global<v8::Object> menu_;
-  std::unique_ptr<TrayIcon> tray_icon_;
-
-  DISALLOW_COPY_AND_ASSIGN(Tray);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_TRAY_H_
removed in remote
  base   100644 db561708086ec253d80ba6d961556eaf892ff106 atom/browser/api/atom_api_web_contents.cc
  our    100644 20a1ac2e672f08ffea528b6e094ba530ff8083d1 atom/browser/api/atom_api_web_contents.cc
@@ -1,2132 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_web_contents.h"
-
-#include <set>
-#include <string>
-
-// We have problems with redefinition of ssize_t between node.h and
-// port_chromium.h, and the latter was introduced by leveldb.mojom.h.
-// The best solution is to not include content/browser/frame_host/ headers
-// and node.h in the same file, but for now I'm just working around the
-// problem.
-#if defined(OS_WIN)
-#define COMPONENTS_SERVICES_LEVELDB_PUBLIC_INTERFACES_LEVELDB_MOJOM_H_
-#define COMPONENTS_LEVELDB_PUBLIC_INTERFACES_LEVELDB_MOJOM_H_
-#endif
-
-#include "atom/browser/api/atom_api_browser_window.h"
-#include "atom/browser/api/atom_api_debugger.h"
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_javascript_dialog_manager.h"
-#include "atom/browser/child_web_contents_tracker.h"
-#include "atom/browser/lib/bluetooth_chooser.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#if defined(ENABLE_OSR)
-#include "atom/browser/osr/osr_output_device.h"
-#include "atom/browser/osr/osr_render_widget_host_view.h"
-#include "atom/browser/osr/osr_web_contents_view.h"
-#endif
-#include "atom/browser/ui/drag_util.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "atom/browser/web_view_guest_delegate.h"
-#include "atom/common/api/api_messages.h"
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/color_util.h"
-#include "atom/common/mouse_util.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/network_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/message_loop/message_loop.h"
-#include "base/process/process_handle.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/values.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "chrome/browser/browser_process.h"
-#include "chrome/browser/printing/print_preview_message_handler.h"
-#include "chrome/browser/printing/print_view_manager_basic.h"
-#include "chrome/browser/ssl/security_state_tab_helper.h"
-#include "content/browser/frame_host/frame_tree_node.h"
-#include "content/browser/frame_host/render_frame_host_manager.h"
-#include "content/browser/renderer_host/render_widget_host_impl.h"
-#include "content/browser/renderer_host/render_widget_host_view_base.h"
-#include "content/common/view_messages.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/download_request_utils.h"
-#include "content/public/browser/favicon_status.h"
-#include "content/public/browser/native_web_keyboard_event.h"
-#include "content/public/browser/navigation_details.h"
-#include "content/public/browser/navigation_entry.h"
-#include "content/public/browser/navigation_handle.h"
-#include "content/public/browser/plugin_service.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/render_widget_host_view.h"
-#include "content/public/browser/service_worker_context.h"
-#include "content/public/browser/site_instance.h"
-#include "content/public/browser/storage_partition.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/context_menu_params.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "net/url_request/url_request_context.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/web/WebFindOptions.h"
-#include "ui/display/screen.h"
-#include "ui/events/base_event_utils.h"
-
-#if !defined(OS_MACOSX)
-#include "ui/aura/window.h"
-#endif
-
-#if defined(OS_LINUX) || defined(OS_WIN)
-#include "content/public/common/renderer_preferences.h"
-#include "ui/gfx/font_render_params.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace {
-
-struct PrintSettings {
-  bool silent;
-  bool print_background;
-  base::string16 device_name;
-};
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<PrintSettings> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     PrintSettings* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    dict.Get("silent", &(out->silent));
-    dict.Get("printBackground", &(out->print_background));
-    dict.Get("deviceName", &(out->device_name));
-    return true;
-  }
-};
-
-template <>
-struct Converter<printing::PrinterBasicInfo> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const printing::PrinterBasicInfo& val) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("name", val.printer_name);
-    dict.Set("description", val.printer_description);
-    dict.Set("status", val.printer_status);
-    dict.Set("isDefault", val.is_default ? true : false);
-    dict.Set("options", val.options);
-    return dict.GetHandle();
-  }
-};
-
-template <>
-struct Converter<WindowOpenDisposition> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   WindowOpenDisposition val) {
-    std::string disposition = "other";
-    switch (val) {
-      case WindowOpenDisposition::CURRENT_TAB:
-        disposition = "default";
-        break;
-      case WindowOpenDisposition::NEW_FOREGROUND_TAB:
-        disposition = "foreground-tab";
-        break;
-      case WindowOpenDisposition::NEW_BACKGROUND_TAB:
-        disposition = "background-tab";
-        break;
-      case WindowOpenDisposition::NEW_POPUP:
-      case WindowOpenDisposition::NEW_WINDOW:
-        disposition = "new-window";
-        break;
-      case WindowOpenDisposition::SAVE_TO_DISK:
-        disposition = "save-to-disk";
-        break;
-      default:
-        break;
-    }
-    return mate::ConvertToV8(isolate, disposition);
-  }
-};
-
-template <>
-struct Converter<content::SavePageType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::SavePageType* out) {
-    std::string save_type;
-    if (!ConvertFromV8(isolate, val, &save_type))
-      return false;
-    save_type = base::ToLowerASCII(save_type);
-    if (save_type == "htmlonly") {
-      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;
-    } else if (save_type == "htmlcomplete") {
-      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;
-    } else if (save_type == "mhtml") {
-      *out = content::SAVE_PAGE_TYPE_AS_MHTML;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-template <>
-struct Converter<atom::api::WebContents::Type> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   atom::api::WebContents::Type val) {
-    using Type = atom::api::WebContents::Type;
-    std::string type = "";
-    switch (val) {
-      case Type::BACKGROUND_PAGE:
-        type = "backgroundPage";
-        break;
-      case Type::BROWSER_WINDOW:
-        type = "window";
-        break;
-      case Type::BROWSER_VIEW:
-        type = "browserView";
-        break;
-      case Type::REMOTE:
-        type = "remote";
-        break;
-      case Type::WEB_VIEW:
-        type = "webview";
-        break;
-      case Type::OFF_SCREEN:
-        type = "offscreen";
-        break;
-      default:
-        break;
-    }
-    return mate::ConvertToV8(isolate, type);
-  }
-
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     atom::api::WebContents::Type* out) {
-    using Type = atom::api::WebContents::Type;
-    std::string type;
-    if (!ConvertFromV8(isolate, val, &type))
-      return false;
-    if (type == "backgroundPage") {
-      *out = Type::BACKGROUND_PAGE;
-    } else if (type == "browserView") {
-      *out = Type::BROWSER_VIEW;
-    } else if (type == "webview") {
-      *out = Type::WEB_VIEW;
-#if defined(ENABLE_OSR)
-    } else if (type == "offscreen") {
-      *out = Type::OFF_SCREEN;
-#endif
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-content::ServiceWorkerContext* GetServiceWorkerContext(
-    const content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  auto* site_instance = web_contents->GetSiteInstance();
-  if (!context || !site_instance)
-    return nullptr;
-
-  auto* storage_partition =
-      content::BrowserContext::GetStoragePartition(context, site_instance);
-  if (!storage_partition)
-    return nullptr;
-
-  return storage_partition->GetServiceWorkerContext();
-}
-
-// Called when CapturePage is done.
-void OnCapturePageDone(const base::Callback<void(const gfx::Image&)>& callback,
-                       const SkBitmap& bitmap) {
-  // Hack to enable transparency in captured image
-  // TODO(nitsakh) Remove hack once fixed in chromium
-  const_cast<SkBitmap&>(bitmap).setAlphaType(kPremul_SkAlphaType);
-  callback.Run(gfx::Image::CreateFrom1xBitmap(bitmap));
-}
-
-}  // namespace
-
-struct WebContents::FrameDispatchHelper {
-  WebContents* api_web_contents;
-  content::RenderFrameHost* rfh;
-
-  bool Send(IPC::Message* msg) { return rfh->Send(msg); }
-
-  void OnSetTemporaryZoomLevel(double level, IPC::Message* reply_msg) {
-    api_web_contents->OnSetTemporaryZoomLevel(rfh, level, reply_msg);
-  }
-
-  void OnGetZoomLevel(IPC::Message* reply_msg) {
-    api_web_contents->OnGetZoomLevel(rfh, reply_msg);
-  }
-
-  void OnRendererMessageSync(const base::string16& channel,
-                             const base::ListValue& args,
-                             IPC::Message* message) {
-    api_web_contents->OnRendererMessageSync(rfh, channel, args, message);
-  }
-};
-
-WebContents::WebContents(v8::Isolate* isolate,
-                         content::WebContents* web_contents,
-                         Type type)
-    : content::WebContentsObserver(web_contents), type_(type) {
-  const mate::Dictionary options = mate::Dictionary::CreateEmpty(isolate);
-  if (type == REMOTE) {
-    web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
-    Init(isolate);
-    AttachAsUserData(web_contents);
-    InitZoomController(web_contents, options);
-  } else {
-    auto session = Session::CreateFrom(isolate, GetBrowserContext());
-    session_.Reset(isolate, session.ToV8());
-    InitWithSessionAndOptions(isolate, web_contents, session, options);
-  }
-}
-
-WebContents::WebContents(v8::Isolate* isolate,
-                         const mate::Dictionary& options) {
-  // Read options.
-  options.Get("backgroundThrottling", &background_throttling_);
-
-  // FIXME(zcbenz): We should read "type" parameter for better design, but
-  // on Windows we have encountered a compiler bug that if we read "type"
-  // from |options| and then set |type_|, a memory corruption will happen
-  // and Electron will soon crash.
-  // Remvoe this after we upgraded to use VS 2015 Update 3.
-  bool b = false;
-  if (options.Get("isGuest", &b) && b)
-    type_ = WEB_VIEW;
-  else if (options.Get("isBackgroundPage", &b) && b)
-    type_ = BACKGROUND_PAGE;
-  else if (options.Get("isBrowserView", &b) && b)
-    type_ = BROWSER_VIEW;
-#if defined(ENABLE_OSR)
-  else if (options.Get(options::kOffscreen, &b) && b)
-    type_ = OFF_SCREEN;
-#endif
-
-  // Init embedder earlier
-  options.Get("embedder", &embedder_);
-
-  // Whether to enable DevTools.
-  options.Get("devTools", &enable_devtools_);
-
-  // Obtain the session.
-  std::string partition;
-  mate::Handle<api::Session> session;
-  if (options.Get("session", &session) && !session.IsEmpty()) {
-  } else if (options.Get("partition", &partition)) {
-    session = Session::FromPartition(isolate, partition);
-  } else {
-    // Use the default session if not specified.
-    session = Session::FromPartition(isolate, "");
-  }
-  session_.Reset(isolate, session.ToV8());
-
-  content::WebContents* web_contents;
-  if (IsGuest()) {
-    scoped_refptr<content::SiteInstance> site_instance =
-        content::SiteInstance::CreateForURL(session->browser_context(),
-                                            GURL("chrome-guest://fake-host"));
-    content::WebContents::CreateParams params(session->browser_context(),
-                                              site_instance);
-    guest_delegate_.reset(
-        new WebViewGuestDelegate(embedder_->web_contents(), this));
-    params.guest_delegate = guest_delegate_.get();
-
-#if defined(ENABLE_OSR)
-    if (embedder_ && embedder_->IsOffScreen()) {
-      auto* view = new OffScreenWebContentsView(
-          false, base::Bind(&WebContents::OnPaint, base::Unretained(this)));
-      params.view = view;
-      params.delegate_view = view;
-
-      web_contents = content::WebContents::Create(params);
-      view->SetWebContents(web_contents);
-    } else {
-#endif
-      web_contents = content::WebContents::Create(params);
-#if defined(ENABLE_OSR)
-    }
-  } else if (IsOffScreen()) {
-    bool transparent = false;
-    options.Get("transparent", &transparent);
-
-    content::WebContents::CreateParams params(session->browser_context());
-    auto* view = new OffScreenWebContentsView(
-        transparent, base::Bind(&WebContents::OnPaint, base::Unretained(this)));
-    params.view = view;
-    params.delegate_view = view;
-
-    web_contents = content::WebContents::Create(params);
-    view->SetWebContents(web_contents);
-#endif
-  } else {
-    content::WebContents::CreateParams params(session->browser_context());
-    web_contents = content::WebContents::Create(params);
-  }
-
-  InitWithSessionAndOptions(isolate, web_contents, session, options);
-}
-
-void WebContents::InitZoomController(content::WebContents* web_contents,
-                                     const mate::Dictionary& options) {
-  WebContentsZoomController::CreateForWebContents(web_contents);
-  zoom_controller_ = WebContentsZoomController::FromWebContents(web_contents);
-  double zoom_factor;
-  if (options.Get(options::kZoomFactor, &zoom_factor))
-    zoom_controller_->SetDefaultZoomFactor(zoom_factor);
-}
-
-void WebContents::InitWithSessionAndOptions(v8::Isolate* isolate,
-                                            content::WebContents* web_contents,
-                                            mate::Handle<api::Session> session,
-                                            const mate::Dictionary& options) {
-  Observe(web_contents);
-  InitWithWebContents(web_contents, session->browser_context(), IsGuest());
-
-  managed_web_contents()->GetView()->SetDelegate(this);
-
-  auto* prefs = web_contents->GetMutableRendererPrefs();
-  prefs->accept_languages = g_browser_process->GetApplicationLocale();
-
-#if defined(OS_LINUX) || defined(OS_WIN)
-  // Update font settings.
-  CR_DEFINE_STATIC_LOCAL(
-      const gfx::FontRenderParams, params,
-      (gfx::GetFontRenderParams(gfx::FontRenderParamsQuery(), nullptr)));
-  prefs->should_antialias_text = params.antialiasing;
-  prefs->use_subpixel_positioning = params.subpixel_positioning;
-  prefs->hinting = params.hinting;
-  prefs->use_autohinter = params.autohinter;
-  prefs->use_bitmaps = params.use_bitmaps;
-  prefs->subpixel_rendering = params.subpixel_rendering;
-#endif
-
-  // Save the preferences in C++.
-  new WebContentsPreferences(web_contents, options);
-
-  // Initialize permission helper.
-  WebContentsPermissionHelper::CreateForWebContents(web_contents);
-  // Initialize security state client.
-  SecurityStateTabHelper::CreateForWebContents(web_contents);
-  // Initialize zoom controller.
-  InitZoomController(web_contents, options);
-
-  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
-
-  if (IsGuest()) {
-    NativeWindow* owner_window = nullptr;
-    if (embedder_) {
-      // New WebContents's owner_window is the embedder's owner_window.
-      auto* relay =
-          NativeWindowRelay::FromWebContents(embedder_->web_contents());
-      if (relay)
-        owner_window = relay->window.get();
-    }
-    if (owner_window)
-      SetOwnerWindow(owner_window);
-  }
-
-  Init(isolate);
-  AttachAsUserData(web_contents);
-}
-
-WebContents::~WebContents() {
-  // The destroy() is called.
-  if (managed_web_contents()) {
-    managed_web_contents()->GetView()->SetDelegate(nullptr);
-
-    RenderViewDeleted(web_contents()->GetRenderViewHost());
-
-    if (type_ == BROWSER_WINDOW && owner_window()) {
-      for (ExtendedWebContentsObserver& observer : observers_)
-        observer.OnCloseContents();
-    } else {
-      DestroyWebContents(!IsGuest() /* async */);
-    }
-    // The WebContentsDestroyed will not be called automatically because we
-    // destroy the webContents in the next tick. So we have to manually
-    // call it here to make sure "destroyed" event is emitted.
-    WebContentsDestroyed();
-  }
-}
-
-void WebContents::DestroyWebContents(bool async) {
-  // This event is only for internal use, which is emitted when WebContents is
-  // being destroyed.
-  Emit("will-destroy");
-  ResetManagedWebContents(async);
-}
-
-bool WebContents::DidAddMessageToConsole(content::WebContents* source,
-                                         int32_t level,
-                                         const base::string16& message,
-                                         int32_t line_no,
-                                         const base::string16& source_id) {
-  return Emit("console-message", level, message, line_no, source_id);
-}
-
-void WebContents::OnCreateWindow(
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const std::vector<std::string>& features,
-    const scoped_refptr<network::ResourceRequestBody>& body) {
-  if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-    Emit("-new-window", target_url, frame_name, disposition, features, body,
-         referrer);
-  else
-    Emit("new-window", target_url, frame_name, disposition, features);
-}
-
-void WebContents::WebContentsCreated(content::WebContents* source_contents,
-                                     int opener_render_process_id,
-                                     int opener_render_frame_id,
-                                     const std::string& frame_name,
-                                     const GURL& target_url,
-                                     content::WebContents* new_contents) {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto api_web_contents = CreateFrom(isolate(), new_contents, BROWSER_WINDOW);
-  Emit("-web-contents-created", api_web_contents, target_url, frame_name);
-}
-
-void WebContents::AddNewContents(content::WebContents* source,
-                                 content::WebContents* new_contents,
-                                 WindowOpenDisposition disposition,
-                                 const gfx::Rect& initial_rect,
-                                 bool user_gesture,
-                                 bool* was_blocked) {
-  new ChildWebContentsTracker(new_contents);
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto api_web_contents = CreateFrom(isolate(), new_contents);
-  if (Emit("-add-new-contents", api_web_contents, disposition, user_gesture,
-           initial_rect.x(), initial_rect.y(), initial_rect.width(),
-           initial_rect.height())) {
-    api_web_contents->DestroyWebContents(true /* async */);
-  }
-}
-
-content::WebContents* WebContents::OpenURLFromTab(
-    content::WebContents* source,
-    const content::OpenURLParams& params) {
-  if (params.disposition != WindowOpenDisposition::CURRENT_TAB) {
-    if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-      Emit("-new-window", params.url, "", params.disposition);
-    else
-      Emit("new-window", params.url, "", params.disposition);
-    return nullptr;
-  }
-
-  // Give user a chance to cancel navigation.
-  if (Emit("will-navigate", params.url))
-    return nullptr;
-
-  // Don't load the URL if the web contents was marked as destroyed from a
-  // will-navigate event listener
-  if (IsDestroyed())
-    return nullptr;
-
-  return CommonWebContentsDelegate::OpenURLFromTab(source, params);
-}
-
-void WebContents::BeforeUnloadFired(content::WebContents* tab,
-                                    bool proceed,
-                                    bool* proceed_to_fire_unload) {
-  if (type_ == BROWSER_WINDOW || type_ == OFF_SCREEN)
-    *proceed_to_fire_unload = proceed;
-  else
-    *proceed_to_fire_unload = true;
-}
-
-void WebContents::MoveContents(content::WebContents* source,
-                               const gfx::Rect& pos) {
-  Emit("move", pos);
-}
-
-void WebContents::CloseContents(content::WebContents* source) {
-  Emit("close");
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  HideAutofillPopup();
-#endif
-  if (managed_web_contents())
-    managed_web_contents()->GetView()->SetDelegate(nullptr);
-  for (ExtendedWebContentsObserver& observer : observers_)
-    observer.OnCloseContents();
-}
-
-void WebContents::ActivateContents(content::WebContents* source) {
-  Emit("activate");
-}
-
-void WebContents::UpdateTargetURL(content::WebContents* source,
-                                  const GURL& url) {
-  Emit("update-target-url", url);
-}
-
-bool WebContents::IsPopupOrPanel(const content::WebContents* source) const {
-  return type_ == BROWSER_WINDOW;
-}
-
-void WebContents::HandleKeyboardEvent(
-    content::WebContents* source,
-    const content::NativeWebKeyboardEvent& event) {
-  if (type_ == WEB_VIEW && embedder_) {
-    // Send the unhandled keyboard events back to the embedder.
-    embedder_->HandleKeyboardEvent(source, event);
-  } else {
-    // Go to the default keyboard handling.
-    CommonWebContentsDelegate::HandleKeyboardEvent(source, event);
-  }
-}
-
-content::KeyboardEventProcessingResult WebContents::PreHandleKeyboardEvent(
-    content::WebContents* source,
-    const content::NativeWebKeyboardEvent& event) {
-  if (event.GetType() == blink::WebInputEvent::Type::kRawKeyDown ||
-      event.GetType() == blink::WebInputEvent::Type::kKeyUp) {
-    bool prevent_default = Emit("before-input-event", event);
-    if (prevent_default) {
-      return content::KeyboardEventProcessingResult::HANDLED;
-    }
-  }
-
-  return content::KeyboardEventProcessingResult::NOT_HANDLED;
-}
-
-void WebContents::EnterFullscreenModeForTab(content::WebContents* source,
-                                            const GURL& origin) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(source);
-  auto callback = base::Bind(&WebContents::OnEnterFullscreenModeForTab,
-                             base::Unretained(this), source, origin);
-  permission_helper->RequestFullscreenPermission(callback);
-}
-
-void WebContents::OnEnterFullscreenModeForTab(content::WebContents* source,
-                                              const GURL& origin,
-                                              bool allowed) {
-  if (!allowed)
-    return;
-  CommonWebContentsDelegate::EnterFullscreenModeForTab(source, origin);
-  Emit("enter-html-full-screen");
-}
-
-void WebContents::ExitFullscreenModeForTab(content::WebContents* source) {
-  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);
-  Emit("leave-html-full-screen");
-}
-
-void WebContents::RendererUnresponsive(
-    content::WebContents* source,
-    content::RenderWidgetHost* render_widget_host) {
-  Emit("unresponsive");
-}
-
-void WebContents::RendererResponsive(
-    content::WebContents* source,
-    content::RenderWidgetHost* render_widget_host) {
-  Emit("responsive");
-  for (ExtendedWebContentsObserver& observer : observers_)
-    observer.OnRendererResponsive();
-}
-
-bool WebContents::HandleContextMenu(const content::ContextMenuParams& params) {
-  if (params.custom_context.is_pepper_menu) {
-    Emit("pepper-context-menu", std::make_pair(params, web_contents()),
-         base::Bind(&content::WebContents::NotifyContextMenuClosed,
-                    base::Unretained(web_contents()), params.custom_context));
-  } else {
-    Emit("context-menu", std::make_pair(params, web_contents()));
-  }
-
-  return true;
-}
-
-bool WebContents::OnGoToEntryOffset(int offset) {
-  GoToOffset(offset);
-  return false;
-}
-
-void WebContents::FindReply(content::WebContents* web_contents,
-                            int request_id,
-                            int number_of_matches,
-                            const gfx::Rect& selection_rect,
-                            int active_match_ordinal,
-                            bool final_update) {
-  if (!final_update)
-    return;
-
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate());
-  result.Set("requestId", request_id);
-  result.Set("matches", number_of_matches);
-  result.Set("selectionArea", selection_rect);
-  result.Set("activeMatchOrdinal", active_match_ordinal);
-  result.Set("finalUpdate", final_update);  // Deprecate after 2.0
-  Emit("found-in-page", result);
-}
-
-bool WebContents::CheckMediaAccessPermission(content::WebContents* web_contents,
-                                             const GURL& security_origin,
-                                             content::MediaStreamType type) {
-  return true;
-}
-
-void WebContents::RequestMediaAccessPermission(
-    content::WebContents* web_contents,
-    const content::MediaStreamRequest& request,
-    const content::MediaResponseCallback& callback) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  permission_helper->RequestMediaAccessPermission(request, callback);
-}
-
-void WebContents::RequestToLockMouse(content::WebContents* web_contents,
-                                     bool user_gesture,
-                                     bool last_unlocked_by_target) {
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  permission_helper->RequestPointerLockPermission(user_gesture);
-}
-
-std::unique_ptr<content::BluetoothChooser> WebContents::RunBluetoothChooser(
-    content::RenderFrameHost* frame,
-    const content::BluetoothChooser::EventHandler& event_handler) {
-  return std::make_unique<BluetoothChooser>(this, event_handler);
-}
-
-content::JavaScriptDialogManager* WebContents::GetJavaScriptDialogManager(
-    content::WebContents* source) {
-  if (!dialog_manager_)
-    dialog_manager_.reset(new AtomJavaScriptDialogManager(this));
-
-  return dialog_manager_.get();
-}
-
-void WebContents::BeforeUnloadFired(const base::TimeTicks& proceed_time) {
-  // Do nothing, we override this method just to avoid compilation error since
-  // there are two virtual functions named BeforeUnloadFired.
-}
-
-void WebContents::RenderViewCreated(content::RenderViewHost* render_view_host) {
-  auto* const impl = content::RenderWidgetHostImpl::FromID(
-      render_view_host->GetProcess()->GetID(),
-      render_view_host->GetRoutingID());
-  if (impl)
-    impl->disable_hidden_ = !background_throttling_;
-}
-
-void WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {
-  Emit("render-view-deleted", render_view_host->GetProcess()->GetID());
-}
-
-void WebContents::RenderProcessGone(base::TerminationStatus status) {
-  Emit("crashed", status == base::TERMINATION_STATUS_PROCESS_WAS_KILLED);
-}
-
-void WebContents::PluginCrashed(const base::FilePath& plugin_path,
-                                base::ProcessId plugin_pid) {
-  content::WebPluginInfo info;
-  auto* plugin_service = content::PluginService::GetInstance();
-  plugin_service->GetPluginInfoByPath(plugin_path, &info);
-  Emit("plugin-crashed", info.name, info.version);
-}
-
-void WebContents::MediaStartedPlaying(const MediaPlayerInfo& video_type,
-                                      const MediaPlayerId& id) {
-  Emit("media-started-playing");
-}
-
-void WebContents::MediaStoppedPlaying(
-    const MediaPlayerInfo& video_type,
-    const MediaPlayerId& id,
-    content::WebContentsObserver::MediaStoppedReason reason) {
-  Emit("media-paused");
-}
-
-void WebContents::DidChangeThemeColor(SkColor theme_color) {
-  if (theme_color != SK_ColorTRANSPARENT) {
-    Emit("did-change-theme-color", atom::ToRGBHex(theme_color));
-  } else {
-    Emit("did-change-theme-color", nullptr);
-  }
-}
-
-void WebContents::DocumentLoadedInFrame(
-    content::RenderFrameHost* render_frame_host) {
-  if (!render_frame_host->GetParent())
-    Emit("dom-ready");
-}
-
-void WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,
-                                const GURL& validated_url) {
-  bool is_main_frame = !render_frame_host->GetParent();
-  int frame_process_id = render_frame_host->GetProcess()->GetID();
-  int frame_routing_id = render_frame_host->GetRoutingID();
-  Emit("did-frame-finish-load", is_main_frame, frame_process_id,
-       frame_routing_id);
-
-  if (is_main_frame)
-    Emit("did-finish-load");
-}
-
-void WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,
-                              const GURL& url,
-                              int error_code,
-                              const base::string16& error_description) {
-  bool is_main_frame = !render_frame_host->GetParent();
-  int frame_process_id = render_frame_host->GetProcess()->GetID();
-  int frame_routing_id = render_frame_host->GetRoutingID();
-  Emit("did-fail-load", error_code, error_description, url, is_main_frame,
-       frame_process_id, frame_routing_id);
-}
-
-void WebContents::DidStartLoading() {
-  Emit("did-start-loading");
-}
-
-void WebContents::DidStopLoading() {
-  Emit("did-stop-loading");
-}
-
-void WebContents::DidStartNavigation(
-    content::NavigationHandle* navigation_handle) {
-  bool is_main_frame = navigation_handle->IsInMainFrame();
-  int frame_tree_node_id = navigation_handle->GetFrameTreeNodeId();
-  content::FrameTreeNode* frame_tree_node =
-      content::FrameTreeNode::GloballyFindByID(frame_tree_node_id);
-  content::RenderFrameHostManager* render_manager =
-      frame_tree_node->render_manager();
-  content::RenderFrameHost* frame_host = nullptr;
-  if (render_manager) {
-    frame_host = render_manager->speculative_frame_host();
-    if (!frame_host)
-      frame_host = render_manager->current_frame_host();
-  }
-  int frame_process_id = -1, frame_routing_id = -1;
-  if (frame_host) {
-    frame_process_id = frame_host->GetProcess()->GetID();
-    frame_routing_id = frame_host->GetRoutingID();
-  }
-  bool is_same_document = navigation_handle->IsSameDocument();
-  auto url = navigation_handle->GetURL();
-  Emit("did-start-navigation", url, is_same_document, is_main_frame,
-       frame_process_id, frame_routing_id);
-}
-
-void WebContents::DidFinishNavigation(
-    content::NavigationHandle* navigation_handle) {
-  if (!navigation_handle->HasCommitted())
-    return;
-  bool is_main_frame = navigation_handle->IsInMainFrame();
-  content::RenderFrameHost* frame_host =
-      navigation_handle->GetRenderFrameHost();
-  int frame_process_id = -1, frame_routing_id = -1;
-  if (frame_host) {
-    frame_process_id = frame_host->GetProcess()->GetID();
-    frame_routing_id = frame_host->GetRoutingID();
-  }
-  if (!navigation_handle->IsErrorPage()) {
-    auto url = navigation_handle->GetURL();
-    bool is_same_document = navigation_handle->IsSameDocument();
-    if (is_same_document) {
-      Emit("did-navigate-in-page", url, is_main_frame, frame_process_id,
-           frame_routing_id);
-    } else {
-      const net::HttpResponseHeaders* http_response =
-          navigation_handle->GetResponseHeaders();
-      std::string http_status_text;
-      int http_response_code = -1;
-      if (http_response) {
-        http_status_text = http_response->GetStatusText();
-        http_response_code = http_response->response_code();
-      }
-      Emit("did-frame-navigate", url, http_response_code, http_status_text,
-           is_main_frame, frame_process_id, frame_routing_id);
-      if (is_main_frame) {
-        Emit("did-navigate", url, http_response_code, http_status_text);
-      }
-    }
-    if (IsGuest())
-      Emit("load-commit", url, is_main_frame);
-  } else {
-    auto url = navigation_handle->GetURL();
-    int code = navigation_handle->GetNetErrorCode();
-    auto description = net::ErrorToShortString(code);
-    Emit("did-fail-provisional-load", code, description, url, is_main_frame,
-         frame_process_id, frame_routing_id);
-
-    // Do not emit "did-fail-load" for canceled requests.
-    if (code != net::ERR_ABORTED)
-      Emit("did-fail-load", code, description, url, is_main_frame,
-           frame_process_id, frame_routing_id);
-  }
-}
-
-void WebContents::TitleWasSet(content::NavigationEntry* entry) {
-  base::string16 final_title;
-  bool explicit_set = true;
-  if (entry) {
-    auto title = entry->GetTitle();
-    auto url = entry->GetURL();
-    if (url.SchemeIsFile() && title.empty()) {
-      final_title = base::UTF8ToUTF16(url.ExtractFileName());
-      explicit_set = false;
-    } else {
-      final_title = title;
-    }
-  }
-  Emit("page-title-updated", final_title, explicit_set);
-}
-
-void WebContents::DidUpdateFaviconURL(
-    const std::vector<content::FaviconURL>& urls) {
-  std::set<GURL> unique_urls;
-  for (const auto& iter : urls) {
-    if (iter.icon_type != content::FaviconURL::IconType::kFavicon)
-      continue;
-    const GURL& url = iter.icon_url;
-    if (url.is_valid())
-      unique_urls.insert(url);
-  }
-  Emit("page-favicon-updated", unique_urls);
-}
-
-void WebContents::DevToolsReloadPage() {
-  Emit("devtools-reload-page");
-}
-
-void WebContents::DevToolsFocused() {
-  Emit("devtools-focused");
-}
-
-void WebContents::DevToolsOpened() {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  auto handle = WebContents::CreateFrom(
-      isolate(), managed_web_contents()->GetDevToolsWebContents());
-  devtools_web_contents_.Reset(isolate(), handle.ToV8());
-
-  // Set inspected tabID.
-  base::Value tab_id(ID());
-  managed_web_contents()->CallClientFunction("DevToolsAPI.setInspectedTabId",
-                                             &tab_id, nullptr, nullptr);
-
-  // Inherit owner window in devtools when it doesn't have one.
-  auto* devtools = managed_web_contents()->GetDevToolsWebContents();
-  bool has_window = devtools->GetUserData(NativeWindowRelay::UserDataKey());
-  if (owner_window() && !has_window)
-    handle->SetOwnerWindow(devtools, owner_window());
-
-  Emit("devtools-opened");
-}
-
-void WebContents::DevToolsClosed() {
-  v8::Locker locker(isolate());
-  v8::HandleScope handle_scope(isolate());
-  devtools_web_contents_.Reset();
-
-  Emit("devtools-closed");
-}
-
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-void WebContents::ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                                    const gfx::RectF& bounds,
-                                    const std::vector<base::string16>& values,
-                                    const std::vector<base::string16>& labels) {
-  bool offscreen = IsOffScreen() || (embedder_ && embedder_->IsOffScreen());
-  gfx::RectF popup_bounds(bounds);
-  content::RenderFrameHost* embedder_frame_host = nullptr;
-  if (embedder_) {
-    auto* embedder_view = embedder_->web_contents()->GetMainFrame()->GetView();
-    auto* view = web_contents()->GetMainFrame()->GetView();
-    auto offset = view->GetViewBounds().origin() -
-                  embedder_view->GetViewBounds().origin();
-    popup_bounds.Offset(offset.x(), offset.y());
-    embedder_frame_host = embedder_->web_contents()->GetMainFrame();
-  }
-
-  CommonWebContentsDelegate::ShowAutofillPopup(
-      frame_host, embedder_frame_host, offscreen, popup_bounds, values, labels);
-}
-#endif
-
-bool WebContents::OnMessageReceived(const IPC::Message& message) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(WebContents, message)
-    IPC_MESSAGE_HANDLER_CODE(ViewHostMsg_SetCursor, OnCursorChange,
-                             handled = false)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-bool WebContents::OnMessageReceived(const IPC::Message& message,
-                                    content::RenderFrameHost* frame_host) {
-  bool handled = true;
-  FrameDispatchHelper helper = {this, frame_host};
-  IPC_BEGIN_MESSAGE_MAP_WITH_PARAM(WebContents, message, frame_host)
-    IPC_MESSAGE_HANDLER(AtomFrameHostMsg_Message, OnRendererMessage)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(AtomFrameHostMsg_Message_Sync, &helper,
-                                    FrameDispatchHelper::OnRendererMessageSync)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(
-        AtomFrameHostMsg_SetTemporaryZoomLevel, &helper,
-        FrameDispatchHelper::OnSetTemporaryZoomLevel)
-    IPC_MESSAGE_FORWARD_DELAY_REPLY(AtomFrameHostMsg_GetZoomLevel, &helper,
-                                    FrameDispatchHelper::OnGetZoomLevel)
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-    IPC_MESSAGE_HANDLER(AtomAutofillFrameHostMsg_ShowPopup, ShowAutofillPopup)
-    IPC_MESSAGE_HANDLER(AtomAutofillFrameHostMsg_HidePopup, HideAutofillPopup)
-#endif
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-// There are three ways of destroying a webContents:
-// 1. call webContents.destroy();
-// 2. garbage collection;
-// 3. user closes the window of webContents;
-// 4. the embedder detaches the frame.
-// For webview only #4 will happen, for BrowserWindow both #1 and #3 may
-// happen. The #2 should never happen for webContents, because webview is
-// managed by GuestViewManager, and BrowserWindow's webContents is managed
-// by api::BrowserWindow.
-// For #1, the destructor will do the cleanup work and we only need to make
-// sure "destroyed" event is emitted. For #3, the content::WebContents will
-// be destroyed on close, and WebContentsDestroyed would be called for it, so
-// we need to make sure the api::WebContents is also deleted.
-// For #4, the WebContents will be destroyed by embedder.
-void WebContents::WebContentsDestroyed() {
-  // Cleanup relationships with other parts.
-  RemoveFromWeakMap();
-
-  // We can not call Destroy here because we need to call Emit first, but we
-  // also do not want any method to be used, so just mark as destroyed here.
-  MarkDestroyed();
-
-  Emit("destroyed");
-
-  // For guest view based on OOPIF, the WebContents is released by the embedder
-  // frame, and we need to clear the reference to the memory.
-  if (IsGuest() && managed_web_contents()) {
-    managed_web_contents()->ReleaseWebContents();
-    ResetManagedWebContents(false);
-  }
-
-  // Destroy the native class in next tick.
-  base::ThreadTaskRunnerHandle::Get()->PostTask(FROM_HERE, GetDestroyClosure());
-}
-
-void WebContents::NavigationEntryCommitted(
-    const content::LoadCommittedDetails& details) {
-  Emit("navigation-entry-commited", details.entry->GetURL(),
-       details.is_same_document, details.did_replace_entry);
-}
-
-int WebContents::GetProcessID() const {
-  return web_contents()->GetMainFrame()->GetProcess()->GetID();
-}
-
-base::ProcessId WebContents::GetOSProcessID() const {
-  base::ProcessHandle process_handle =
-      web_contents()->GetMainFrame()->GetProcess()->GetHandle();
-  return base::GetProcId(process_handle);
-}
-
-WebContents::Type WebContents::GetType() const {
-  return type_;
-}
-
-bool WebContents::Equal(const WebContents* web_contents) const {
-  return ID() == web_contents->ID();
-}
-
-void WebContents::LoadURL(const GURL& url, const mate::Dictionary& options) {
-  if (!url.is_valid() || url.spec().size() > url::kMaxURLChars) {
-    Emit("did-fail-load", static_cast<int>(net::ERR_INVALID_URL),
-         net::ErrorToShortString(net::ERR_INVALID_URL),
-         url.possibly_invalid_spec(), true);
-    return;
-  }
-
-  content::NavigationController::LoadURLParams params(url);
-
-  if (!options.Get("httpReferrer", &params.referrer)) {
-    GURL http_referrer;
-    if (options.Get("httpReferrer", &http_referrer))
-      params.referrer = content::Referrer(http_referrer.GetAsReferrer(),
-                                          blink::kWebReferrerPolicyDefault);
-  }
-
-  std::string user_agent;
-  if (options.Get("userAgent", &user_agent))
-    web_contents()->SetUserAgentOverride(user_agent);
-
-  std::string extra_headers;
-  if (options.Get("extraHeaders", &extra_headers))
-    params.extra_headers = extra_headers;
-
-  scoped_refptr<network::ResourceRequestBody> body;
-  if (options.Get("postData", &body)) {
-    params.post_data = body;
-    params.load_type = content::NavigationController::LOAD_TYPE_HTTP_POST;
-  }
-
-  GURL base_url_for_data_url;
-  if (options.Get("baseURLForDataURL", &base_url_for_data_url)) {
-    params.base_url_for_data_url = base_url_for_data_url;
-    params.load_type = content::NavigationController::LOAD_TYPE_DATA;
-  }
-
-  params.transition_type = ui::PAGE_TRANSITION_TYPED;
-  params.should_clear_history_list = true;
-  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
-  web_contents()->GetController().LoadURLWithParams(params);
-
-  // Set the background color of RenderWidgetHostView.
-  // We have to call it right after LoadURL because the RenderViewHost is only
-  // created after loading a page.
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (view) {
-    auto* web_preferences = WebContentsPreferences::From(web_contents());
-    std::string color_name;
-    if (web_preferences->GetPreference(options::kBackgroundColor,
-                                       &color_name)) {
-      view->SetBackgroundColor(ParseHexColor(color_name));
-    } else {
-      view->SetBackgroundColor(SK_ColorTRANSPARENT);
-    }
-  }
-}
-
-void WebContents::DownloadURL(const GURL& url) {
-  auto* browser_context = web_contents()->GetBrowserContext();
-  auto* download_manager =
-      content::BrowserContext::GetDownloadManager(browser_context);
-  std::unique_ptr<download::DownloadUrlParameters> download_params(
-      content::DownloadRequestUtils::CreateDownloadForWebContentsMainFrame(
-          web_contents(), url, NO_TRAFFIC_ANNOTATION_YET));
-  download_manager->DownloadUrl(std::move(download_params));
-}
-
-GURL WebContents::GetURL() const {
-  return web_contents()->GetURL();
-}
-
-base::string16 WebContents::GetTitle() const {
-  return web_contents()->GetTitle();
-}
-
-bool WebContents::IsLoading() const {
-  return web_contents()->IsLoading();
-}
-
-bool WebContents::IsLoadingMainFrame() const {
-  return web_contents()->IsLoadingToDifferentDocument();
-}
-
-bool WebContents::IsWaitingForResponse() const {
-  return web_contents()->IsWaitingForResponse();
-}
-
-void WebContents::Stop() {
-  web_contents()->Stop();
-}
-
-void WebContents::GoBack() {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoBack();
-}
-
-void WebContents::GoForward() {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoForward();
-}
-
-void WebContents::GoToOffset(int offset) {
-  atom::AtomBrowserClient::SuppressRendererProcessRestartForOnce();
-  web_contents()->GetController().GoToOffset(offset);
-}
-
-const std::string WebContents::GetWebRTCIPHandlingPolicy() const {
-  return web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy;
-}
-
-void WebContents::SetWebRTCIPHandlingPolicy(
-    const std::string& webrtc_ip_handling_policy) {
-  if (GetWebRTCIPHandlingPolicy() == webrtc_ip_handling_policy)
-    return;
-  web_contents()->GetMutableRendererPrefs()->webrtc_ip_handling_policy =
-      webrtc_ip_handling_policy;
-
-  content::RenderViewHost* host = web_contents()->GetRenderViewHost();
-  if (host)
-    host->SyncRendererPrefs();
-}
-
-bool WebContents::IsCrashed() const {
-  return web_contents()->IsCrashed();
-}
-
-void WebContents::SetUserAgent(const std::string& user_agent,
-                               mate::Arguments* args) {
-  web_contents()->SetUserAgentOverride(user_agent);
-}
-
-std::string WebContents::GetUserAgent() {
-  return web_contents()->GetUserAgentOverride();
-}
-
-bool WebContents::SavePage(const base::FilePath& full_file_path,
-                           const content::SavePageType& save_type,
-                           const SavePageHandler::SavePageCallback& callback) {
-  auto* handler = new SavePageHandler(web_contents(), callback);
-  return handler->Handle(full_file_path, save_type);
-}
-
-void WebContents::OpenDevTools(mate::Arguments* args) {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  std::string state;
-  if (type_ == WEB_VIEW || !owner_window()) {
-    state = "detach";
-  }
-  if (args && args->Length() == 1) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("mode", &state);
-    }
-  }
-  managed_web_contents()->SetDockState(state);
-  managed_web_contents()->ShowDevTools();
-}
-
-void WebContents::CloseDevTools() {
-  if (type_ == REMOTE)
-    return;
-
-  managed_web_contents()->CloseDevTools();
-}
-
-bool WebContents::IsDevToolsOpened() {
-  if (type_ == REMOTE)
-    return false;
-
-  return managed_web_contents()->IsDevToolsViewShowing();
-}
-
-bool WebContents::IsDevToolsFocused() {
-  if (type_ == REMOTE)
-    return false;
-
-  return managed_web_contents()->GetView()->IsDevToolsViewFocused();
-}
-
-void WebContents::EnableDeviceEmulation(
-    const blink::WebDeviceEmulationParams& params) {
-  if (type_ == REMOTE)
-    return;
-
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    auto* widget_host =
-        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;
-    if (!widget_host)
-      return;
-    widget_host->Send(
-        new ViewMsg_EnableDeviceEmulation(widget_host->GetRoutingID(), params));
-  }
-}
-
-void WebContents::DisableDeviceEmulation() {
-  if (type_ == REMOTE)
-    return;
-
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    auto* widget_host =
-        frame_host ? frame_host->GetView()->GetRenderWidgetHost() : nullptr;
-    if (!widget_host)
-      return;
-    widget_host->Send(
-        new ViewMsg_DisableDeviceEmulation(widget_host->GetRoutingID()));
-  }
-}
-
-void WebContents::ToggleDevTools() {
-  if (IsDevToolsOpened())
-    CloseDevTools();
-  else
-    OpenDevTools(nullptr);
-}
-
-void WebContents::InspectElement(int x, int y) {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  if (!managed_web_contents()->GetDevToolsWebContents())
-    OpenDevTools(nullptr);
-  managed_web_contents()->InspectElement(x, y);
-}
-
-void WebContents::InspectServiceWorker() {
-  if (type_ == REMOTE)
-    return;
-
-  if (!enable_devtools_)
-    return;
-
-  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {
-    if (agent_host->GetType() ==
-        content::DevToolsAgentHost::kTypeServiceWorker) {
-      OpenDevTools(nullptr);
-      managed_web_contents()->AttachTo(agent_host);
-      break;
-    }
-  }
-}
-
-void WebContents::HasServiceWorker(const base::Callback<void(bool)>& callback) {
-  auto* context = GetServiceWorkerContext(web_contents());
-  if (!context)
-    return;
-
-  struct WrappedCallback {
-    base::Callback<void(bool)> callback_;
-    explicit WrappedCallback(const base::Callback<void(bool)>& callback)
-        : callback_(callback) {}
-    void Run(content::ServiceWorkerCapability capability) {
-      callback_.Run(capability !=
-                    content::ServiceWorkerCapability::NO_SERVICE_WORKER);
-      delete this;
-    }
-  };
-
-  auto* wrapped_callback = new WrappedCallback(callback);
-
-  context->CheckHasServiceWorker(
-      web_contents()->GetLastCommittedURL(), GURL::EmptyGURL(),
-      base::BindOnce(&WrappedCallback::Run,
-                     base::Unretained(wrapped_callback)));
-}
-
-void WebContents::UnregisterServiceWorker(
-    const base::Callback<void(bool)>& callback) {
-  auto* context = GetServiceWorkerContext(web_contents());
-  if (!context)
-    return;
-
-  context->UnregisterServiceWorker(web_contents()->GetLastCommittedURL(),
-                                   callback);
-}
-
-void WebContents::SetIgnoreMenuShortcuts(bool ignore) {
-  set_ignore_menu_shortcuts(ignore);
-}
-
-void WebContents::SetAudioMuted(bool muted) {
-  web_contents()->SetAudioMuted(muted);
-}
-
-bool WebContents::IsAudioMuted() {
-  return web_contents()->IsAudioMuted();
-}
-
-bool WebContents::IsCurrentlyAudible() {
-  return web_contents()->IsCurrentlyAudible();
-}
-
-void WebContents::Print(mate::Arguments* args) {
-  PrintSettings settings = {false, false, base::string16()};
-  if (args->Length() >= 1 && !args->GetNext(&settings)) {
-    args->ThrowError();
-    return;
-  }
-  auto* print_view_manager_basic_ptr =
-      printing::PrintViewManagerBasic::FromWebContents(web_contents());
-  if (args->Length() == 2) {
-    base::Callback<void(bool)> callback;
-    if (!args->GetNext(&callback)) {
-      args->ThrowError();
-      return;
-    }
-    print_view_manager_basic_ptr->SetCallback(callback);
-  }
-  print_view_manager_basic_ptr->PrintNow(
-      web_contents()->GetMainFrame(), settings.silent,
-      settings.print_background, settings.device_name);
-}
-
-std::vector<printing::PrinterBasicInfo> WebContents::GetPrinterList() {
-  std::vector<printing::PrinterBasicInfo> printers;
-  auto print_backend = printing::PrintBackend::CreateInstance(nullptr);
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  print_backend->EnumeratePrinters(&printers);
-  return printers;
-}
-
-void WebContents::PrintToPDF(const base::DictionaryValue& setting,
-                             const PrintToPDFCallback& callback) {
-  printing::PrintPreviewMessageHandler::FromWebContents(web_contents())
-      ->PrintToPDF(setting, callback);
-}
-
-void WebContents::AddWorkSpace(mate::Arguments* args,
-                               const base::FilePath& path) {
-  if (path.empty()) {
-    args->ThrowError("path cannot be empty");
-    return;
-  }
-  DevToolsAddFileSystem(path);
-}
-
-void WebContents::RemoveWorkSpace(mate::Arguments* args,
-                                  const base::FilePath& path) {
-  if (path.empty()) {
-    args->ThrowError("path cannot be empty");
-    return;
-  }
-  DevToolsRemoveFileSystem(path);
-}
-
-void WebContents::Undo() {
-  web_contents()->Undo();
-}
-
-void WebContents::Redo() {
-  web_contents()->Redo();
-}
-
-void WebContents::Cut() {
-  web_contents()->Cut();
-}
-
-void WebContents::Copy() {
-  web_contents()->Copy();
-}
-
-void WebContents::Paste() {
-  web_contents()->Paste();
-}
-
-void WebContents::PasteAndMatchStyle() {
-  web_contents()->PasteAndMatchStyle();
-}
-
-void WebContents::Delete() {
-  web_contents()->Delete();
-}
-
-void WebContents::SelectAll() {
-  web_contents()->SelectAll();
-}
-
-void WebContents::Unselect() {
-  web_contents()->CollapseSelection();
-}
-
-void WebContents::Replace(const base::string16& word) {
-  web_contents()->Replace(word);
-}
-
-void WebContents::ReplaceMisspelling(const base::string16& word) {
-  web_contents()->ReplaceMisspelling(word);
-}
-
-uint32_t WebContents::FindInPage(mate::Arguments* args) {
-  uint32_t request_id = GetNextRequestId();
-  base::string16 search_text;
-  blink::WebFindOptions options;
-  if (!args->GetNext(&search_text) || search_text.empty()) {
-    args->ThrowError("Must provide a non-empty search content");
-    return 0;
-  }
-
-  args->GetNext(&options);
-
-  web_contents()->Find(request_id, search_text, options);
-  return request_id;
-}
-
-void WebContents::StopFindInPage(content::StopFindAction action) {
-  web_contents()->StopFinding(action);
-}
-
-void WebContents::ShowDefinitionForSelection() {
-#if defined(OS_MACOSX)
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (view)
-    view->ShowDefinitionForSelection();
-#endif
-}
-
-void WebContents::CopyImageAt(int x, int y) {
-  auto* const host = web_contents()->GetMainFrame();
-  if (host)
-    host->CopyImageAt(x, y);
-}
-
-void WebContents::Focus() {
-  web_contents()->Focus();
-}
-
-#if !defined(OS_MACOSX)
-bool WebContents::IsFocused() const {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (!view)
-    return false;
-
-  if (GetType() != BACKGROUND_PAGE) {
-    auto* window = web_contents()->GetNativeView()->GetToplevelWindow();
-    if (window && !window->IsVisible())
-      return false;
-  }
-
-  return view->HasFocus();
-}
-#endif
-
-void WebContents::TabTraverse(bool reverse) {
-  web_contents()->FocusThroughTabTraversal(reverse);
-}
-
-bool WebContents::SendIPCMessage(bool all_frames,
-                                 const base::string16& channel,
-                                 const base::ListValue& args) {
-  auto* frame_host = web_contents()->GetMainFrame();
-  if (frame_host) {
-    return frame_host->Send(new AtomFrameMsg_Message(
-        frame_host->GetRoutingID(), all_frames, channel, args));
-  }
-  return false;
-}
-
-void WebContents::SendInputEvent(v8::Isolate* isolate,
-                                 v8::Local<v8::Value> input_event) {
-  content::RenderWidgetHostView* view =
-      web_contents()->GetRenderWidgetHostView();
-  if (!view)
-    return;
-
-  content::RenderWidgetHost* rwh = view->GetRenderWidgetHost();
-  blink::WebInputEvent::Type type =
-      mate::GetWebInputEventType(isolate, input_event);
-  if (blink::WebInputEvent::IsMouseEventType(type)) {
-    blink::WebMouseEvent mouse_event;
-    if (mate::ConvertFromV8(isolate, input_event, &mouse_event)) {
-      if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-        GetOffScreenRenderWidgetHostView()->SendMouseEvent(mouse_event);
-#endif
-      } else {
-        rwh->ForwardMouseEvent(mouse_event);
-      }
-      return;
-    }
-  } else if (blink::WebInputEvent::IsKeyboardEventType(type)) {
-    content::NativeWebKeyboardEvent keyboard_event(
-        blink::WebKeyboardEvent::kRawKeyDown,
-        blink::WebInputEvent::kNoModifiers, ui::EventTimeForNow());
-    if (mate::ConvertFromV8(isolate, input_event, &keyboard_event)) {
-      rwh->ForwardKeyboardEvent(keyboard_event);
-      return;
-    }
-  } else if (type == blink::WebInputEvent::kMouseWheel) {
-    blink::WebMouseWheelEvent mouse_wheel_event;
-    if (mate::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {
-      if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-        GetOffScreenRenderWidgetHostView()->SendMouseWheelEvent(
-            mouse_wheel_event);
-#endif
-      } else {
-        rwh->ForwardWheelEvent(mouse_wheel_event);
-      }
-      return;
-    }
-  }
-
-  isolate->ThrowException(
-      v8::Exception::Error(mate::StringToV8(isolate, "Invalid event object")));
-}
-
-void WebContents::BeginFrameSubscription(mate::Arguments* args) {
-  bool only_dirty = false;
-  FrameSubscriber::FrameCaptureCallback callback;
-
-  args->GetNext(&only_dirty);
-  if (!args->GetNext(&callback)) {
-    args->ThrowError();
-    return;
-  }
-
-  frame_subscriber_.reset(
-      new FrameSubscriber(isolate(), web_contents(), callback, only_dirty));
-}
-
-void WebContents::EndFrameSubscription() {
-  frame_subscriber_.reset();
-}
-
-void WebContents::StartDrag(const mate::Dictionary& item,
-                            mate::Arguments* args) {
-  base::FilePath file;
-  std::vector<base::FilePath> files;
-  if (!item.Get("files", &files) && item.Get("file", &file)) {
-    files.push_back(file);
-  }
-
-  mate::Handle<NativeImage> icon;
-  if (!item.Get("icon", &icon) && !file.empty()) {
-    // TODO(zcbenz): Set default icon from file.
-  }
-
-  // Error checking.
-  if (icon.IsEmpty()) {
-    args->ThrowError("Must specify 'icon' option");
-    return;
-  }
-
-#if defined(OS_MACOSX)
-  // NSWindow.dragImage requires a non-empty NSImage
-  if (icon->image().IsEmpty()) {
-    args->ThrowError("Must specify non-empty 'icon' option");
-    return;
-  }
-#endif
-
-  // Start dragging.
-  if (!files.empty()) {
-    base::MessageLoop::ScopedNestableTaskAllower allow(
-        base::MessageLoop::current());
-    DragFileItems(files, icon->image(), web_contents()->GetNativeView());
-  } else {
-    args->ThrowError("Must specify either 'file' or 'files' option");
-  }
-}
-
-void WebContents::CapturePage(mate::Arguments* args) {
-  gfx::Rect rect;
-  base::Callback<void(const gfx::Image&)> callback;
-
-  if (!(args->Length() == 1 && args->GetNext(&callback)) &&
-      !(args->Length() == 2 && args->GetNext(&rect) &&
-        args->GetNext(&callback))) {
-    args->ThrowError();
-    return;
-  }
-
-  auto* const view = web_contents()->GetRenderWidgetHostView();
-  if (!view) {
-    callback.Run(gfx::Image());
-    return;
-  }
-
-  // Capture full page if user doesn't specify a |rect|.
-  const gfx::Size view_size =
-      rect.IsEmpty() ? view->GetViewBounds().size() : rect.size();
-
-  // By default, the requested bitmap size is the view size in screen
-  // coordinates.  However, if there's more pixel detail available on the
-  // current system, increase the requested bitmap size to capture it all.
-  gfx::Size bitmap_size = view_size;
-  const gfx::NativeView native_view = view->GetNativeView();
-  const float scale = display::Screen::GetScreen()
-                          ->GetDisplayNearestView(native_view)
-                          .device_scale_factor();
-  if (scale > 1.0f)
-    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);
-
-  view->CopyFromSurface(gfx::Rect(rect.origin(), view_size), bitmap_size,
-                        base::BindOnce(&OnCapturePageDone, callback));
-}
-
-void WebContents::OnCursorChange(const content::WebCursor& cursor) {
-  content::CursorInfo info;
-  cursor.GetCursorInfo(&info);
-
-  if (cursor.IsCustom()) {
-    Emit("cursor-changed", CursorTypeToString(info),
-         gfx::Image::CreateFrom1xBitmap(info.custom_image),
-         info.image_scale_factor,
-         gfx::Size(info.custom_image.width(), info.custom_image.height()),
-         info.hotspot);
-  } else {
-    Emit("cursor-changed", CursorTypeToString(info));
-  }
-}
-
-bool WebContents::IsGuest() const {
-  return type_ == WEB_VIEW;
-}
-
-void WebContents::AttachToIframe(content::WebContents* embedder_web_contents,
-                                 int embedder_frame_id) {
-  if (guest_delegate_)
-    guest_delegate_->AttachToIframe(embedder_web_contents, embedder_frame_id);
-}
-
-bool WebContents::IsOffScreen() const {
-#if defined(ENABLE_OSR)
-  return type_ == OFF_SCREEN;
-#else
-  return false;
-#endif
-}
-
-void WebContents::OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap) {
-  Emit("paint", dirty_rect, gfx::Image::CreateFrom1xBitmap(bitmap));
-}
-
-void WebContents::StartPainting() {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetPainting(true);
-#endif
-}
-
-void WebContents::StopPainting() {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetPainting(false);
-#endif
-}
-
-bool WebContents::IsPainting() const {
-  if (!IsOffScreen())
-    return false;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  return osr_wcv && osr_wcv->IsPainting();
-#else
-  return false;
-#endif
-}
-
-void WebContents::SetFrameRate(int frame_rate) {
-  if (!IsOffScreen())
-    return;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  if (osr_wcv)
-    osr_wcv->SetFrameRate(frame_rate);
-#endif
-}
-
-int WebContents::GetFrameRate() const {
-  if (!IsOffScreen())
-    return 0;
-
-#if defined(ENABLE_OSR)
-  auto* osr_wcv = GetOffScreenWebContentsView();
-  return osr_wcv ? osr_wcv->GetFrameRate() : 0;
-#else
-  return 0;
-#endif
-}
-
-void WebContents::Invalidate() {
-  if (IsOffScreen()) {
-#if defined(ENABLE_OSR)
-    auto* osr_rwhv = GetOffScreenRenderWidgetHostView();
-    if (osr_rwhv)
-      osr_rwhv->Invalidate();
-#endif
-  } else {
-    auto* const window = owner_window();
-    if (window)
-      window->Invalidate();
-  }
-}
-
-gfx::Size WebContents::GetSizeForNewRenderView(content::WebContents* wc) const {
-  if (IsOffScreen() && wc == web_contents()) {
-    auto* relay = NativeWindowRelay::FromWebContents(web_contents());
-    if (relay) {
-      return relay->window->GetSize();
-    }
-  }
-
-  return gfx::Size();
-}
-
-void WebContents::SetZoomLevel(double level) {
-  zoom_controller_->SetZoomLevel(level);
-}
-
-double WebContents::GetZoomLevel() const {
-  return zoom_controller_->GetZoomLevel();
-}
-
-void WebContents::SetZoomFactor(double factor) {
-  auto level = content::ZoomFactorToZoomLevel(factor);
-  SetZoomLevel(level);
-}
-
-double WebContents::GetZoomFactor() const {
-  auto level = GetZoomLevel();
-  return content::ZoomLevelToZoomFactor(level);
-}
-
-void WebContents::OnSetTemporaryZoomLevel(content::RenderFrameHost* rfh,
-                                          double level,
-                                          IPC::Message* reply_msg) {
-  zoom_controller_->SetTemporaryZoomLevel(level);
-  double new_level = zoom_controller_->GetZoomLevel();
-  AtomFrameHostMsg_SetTemporaryZoomLevel::WriteReplyParams(reply_msg,
-                                                           new_level);
-  rfh->Send(reply_msg);
-}
-
-void WebContents::OnGetZoomLevel(content::RenderFrameHost* rfh,
-                                 IPC::Message* reply_msg) {
-  AtomFrameHostMsg_GetZoomLevel::WriteReplyParams(reply_msg, GetZoomLevel());
-  rfh->Send(reply_msg);
-}
-
-v8::Local<v8::Value> WebContents::GetPreloadPath(v8::Isolate* isolate) const {
-  if (auto* web_preferences = WebContentsPreferences::From(web_contents())) {
-    base::FilePath::StringType preload;
-    if (web_preferences->GetPreloadPath(&preload)) {
-      return mate::ConvertToV8(isolate, preload);
-    }
-  }
-  return v8::Null(isolate);
-}
-
-v8::Local<v8::Value> WebContents::GetWebPreferences(
-    v8::Isolate* isolate) const {
-  auto* web_preferences = WebContentsPreferences::From(web_contents());
-  if (!web_preferences)
-    return v8::Null(isolate);
-  return mate::ConvertToV8(isolate, *web_preferences->preference());
-}
-
-v8::Local<v8::Value> WebContents::GetLastWebPreferences(
-    v8::Isolate* isolate) const {
-  auto* web_preferences = WebContentsPreferences::From(web_contents());
-  if (!web_preferences)
-    return v8::Null(isolate);
-  return mate::ConvertToV8(isolate, *web_preferences->last_preference());
-}
-
-v8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() const {
-  if (owner_window())
-    return BrowserWindow::From(isolate(), owner_window());
-  else
-    return v8::Null(isolate());
-}
-
-int32_t WebContents::ID() const {
-  return weak_map_id();
-}
-
-v8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {
-  return v8::Local<v8::Value>::New(isolate, session_);
-}
-
-content::WebContents* WebContents::HostWebContents() {
-  if (!embedder_)
-    return nullptr;
-  return embedder_->web_contents();
-}
-
-void WebContents::SetEmbedder(const WebContents* embedder) {
-  if (embedder) {
-    NativeWindow* owner_window = nullptr;
-    auto* relay = NativeWindowRelay::FromWebContents(embedder->web_contents());
-    if (relay) {
-      owner_window = relay->window.get();
-    }
-    if (owner_window)
-      SetOwnerWindow(owner_window);
-
-    content::RenderWidgetHostView* rwhv =
-        web_contents()->GetRenderWidgetHostView();
-    if (rwhv) {
-      rwhv->Hide();
-      rwhv->Show();
-    }
-  }
-}
-
-void WebContents::SetDevToolsWebContents(const WebContents* devtools) {
-  if (managed_web_contents())
-    managed_web_contents()->SetDevToolsWebContents(devtools->web_contents());
-}
-
-v8::Local<v8::Value> WebContents::GetNativeView() const {
-  gfx::NativeView ptr = web_contents()->GetNativeView();
-  auto buffer = node::Buffer::Copy(isolate(), reinterpret_cast<char*>(&ptr),
-                                   sizeof(gfx::NativeView));
-  if (buffer.IsEmpty())
-    return v8::Null(isolate());
-  else
-    return buffer.ToLocalChecked();
-}
-
-v8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {
-  if (devtools_web_contents_.IsEmpty())
-    return v8::Null(isolate);
-  else
-    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);
-}
-
-v8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {
-  if (debugger_.IsEmpty()) {
-    auto handle = atom::api::Debugger::Create(isolate, web_contents());
-    debugger_.Reset(isolate, handle.ToV8());
-  }
-  return v8::Local<v8::Value>::New(isolate, debugger_);
-}
-
-void WebContents::GrantOriginAccess(const GURL& url) {
-  content::ChildProcessSecurityPolicy::GetInstance()->GrantOrigin(
-      web_contents()->GetMainFrame()->GetProcess()->GetID(),
-      url::Origin::Create(url));
-}
-
-// static
-void WebContents::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebContents"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .MakeDestroyable()
-      .SetMethod("getProcessId", &WebContents::GetProcessID)
-      .SetMethod("getOSProcessId", &WebContents::GetOSProcessID)
-      .SetMethod("equal", &WebContents::Equal)
-      .SetMethod("_loadURL", &WebContents::LoadURL)
-      .SetMethod("downloadURL", &WebContents::DownloadURL)
-      .SetMethod("_getURL", &WebContents::GetURL)
-      .SetMethod("getTitle", &WebContents::GetTitle)
-      .SetMethod("isLoading", &WebContents::IsLoading)
-      .SetMethod("isLoadingMainFrame", &WebContents::IsLoadingMainFrame)
-      .SetMethod("isWaitingForResponse", &WebContents::IsWaitingForResponse)
-      .SetMethod("_stop", &WebContents::Stop)
-      .SetMethod("_goBack", &WebContents::GoBack)
-      .SetMethod("_goForward", &WebContents::GoForward)
-      .SetMethod("_goToOffset", &WebContents::GoToOffset)
-      .SetMethod("isCrashed", &WebContents::IsCrashed)
-      .SetMethod("setUserAgent", &WebContents::SetUserAgent)
-      .SetMethod("getUserAgent", &WebContents::GetUserAgent)
-      .SetMethod("savePage", &WebContents::SavePage)
-      .SetMethod("openDevTools", &WebContents::OpenDevTools)
-      .SetMethod("closeDevTools", &WebContents::CloseDevTools)
-      .SetMethod("isDevToolsOpened", &WebContents::IsDevToolsOpened)
-      .SetMethod("isDevToolsFocused", &WebContents::IsDevToolsFocused)
-      .SetMethod("enableDeviceEmulation", &WebContents::EnableDeviceEmulation)
-      .SetMethod("disableDeviceEmulation", &WebContents::DisableDeviceEmulation)
-      .SetMethod("toggleDevTools", &WebContents::ToggleDevTools)
-      .SetMethod("inspectElement", &WebContents::InspectElement)
-      .SetMethod("setIgnoreMenuShortcuts", &WebContents::SetIgnoreMenuShortcuts)
-      .SetMethod("setAudioMuted", &WebContents::SetAudioMuted)
-      .SetMethod("isAudioMuted", &WebContents::IsAudioMuted)
-      .SetMethod("isCurrentlyAudible", &WebContents::IsCurrentlyAudible)
-      .SetMethod("undo", &WebContents::Undo)
-      .SetMethod("redo", &WebContents::Redo)
-      .SetMethod("cut", &WebContents::Cut)
-      .SetMethod("copy", &WebContents::Copy)
-      .SetMethod("paste", &WebContents::Paste)
-      .SetMethod("pasteAndMatchStyle", &WebContents::PasteAndMatchStyle)
-      .SetMethod("delete", &WebContents::Delete)
-      .SetMethod("selectAll", &WebContents::SelectAll)
-      .SetMethod("unselect", &WebContents::Unselect)
-      .SetMethod("replace", &WebContents::Replace)
-      .SetMethod("replaceMisspelling", &WebContents::ReplaceMisspelling)
-      .SetMethod("findInPage", &WebContents::FindInPage)
-      .SetMethod("stopFindInPage", &WebContents::StopFindInPage)
-      .SetMethod("focus", &WebContents::Focus)
-      .SetMethod("isFocused", &WebContents::IsFocused)
-      .SetMethod("tabTraverse", &WebContents::TabTraverse)
-      .SetMethod("_send", &WebContents::SendIPCMessage)
-      .SetMethod("sendInputEvent", &WebContents::SendInputEvent)
-      .SetMethod("beginFrameSubscription", &WebContents::BeginFrameSubscription)
-      .SetMethod("endFrameSubscription", &WebContents::EndFrameSubscription)
-      .SetMethod("startDrag", &WebContents::StartDrag)
-      .SetMethod("isGuest", &WebContents::IsGuest)
-      .SetMethod("attachToIframe", &WebContents::AttachToIframe)
-      .SetMethod("isOffscreen", &WebContents::IsOffScreen)
-      .SetMethod("startPainting", &WebContents::StartPainting)
-      .SetMethod("stopPainting", &WebContents::StopPainting)
-      .SetMethod("isPainting", &WebContents::IsPainting)
-      .SetMethod("setFrameRate", &WebContents::SetFrameRate)
-      .SetMethod("getFrameRate", &WebContents::GetFrameRate)
-      .SetMethod("invalidate", &WebContents::Invalidate)
-      .SetMethod("setZoomLevel", &WebContents::SetZoomLevel)
-      .SetMethod("_getZoomLevel", &WebContents::GetZoomLevel)
-      .SetMethod("setZoomFactor", &WebContents::SetZoomFactor)
-      .SetMethod("_getZoomFactor", &WebContents::GetZoomFactor)
-      .SetMethod("getType", &WebContents::GetType)
-      .SetMethod("_getPreloadPath", &WebContents::GetPreloadPath)
-      .SetMethod("getWebPreferences", &WebContents::GetWebPreferences)
-      .SetMethod("getLastWebPreferences", &WebContents::GetLastWebPreferences)
-      .SetMethod("getOwnerBrowserWindow", &WebContents::GetOwnerBrowserWindow)
-      .SetMethod("hasServiceWorker", &WebContents::HasServiceWorker)
-      .SetMethod("unregisterServiceWorker",
-                 &WebContents::UnregisterServiceWorker)
-      .SetMethod("inspectServiceWorker", &WebContents::InspectServiceWorker)
-      .SetMethod("print", &WebContents::Print)
-      .SetMethod("getPrinters", &WebContents::GetPrinterList)
-      .SetMethod("_printToPDF", &WebContents::PrintToPDF)
-      .SetMethod("addWorkSpace", &WebContents::AddWorkSpace)
-      .SetMethod("removeWorkSpace", &WebContents::RemoveWorkSpace)
-      .SetMethod("showDefinitionForSelection",
-                 &WebContents::ShowDefinitionForSelection)
-      .SetMethod("copyImageAt", &WebContents::CopyImageAt)
-      .SetMethod("capturePage", &WebContents::CapturePage)
-      .SetMethod("setEmbedder", &WebContents::SetEmbedder)
-      .SetMethod("setDevToolsWebContents", &WebContents::SetDevToolsWebContents)
-      .SetMethod("getNativeView", &WebContents::GetNativeView)
-      .SetMethod("setWebRTCIPHandlingPolicy",
-                 &WebContents::SetWebRTCIPHandlingPolicy)
-      .SetMethod("getWebRTCIPHandlingPolicy",
-                 &WebContents::GetWebRTCIPHandlingPolicy)
-      .SetMethod("_grantOriginAccess", &WebContents::GrantOriginAccess)
-      .SetProperty("id", &WebContents::ID)
-      .SetProperty("session", &WebContents::Session)
-      .SetProperty("hostWebContents", &WebContents::HostWebContents)
-      .SetProperty("devToolsWebContents", &WebContents::DevToolsWebContents)
-      .SetProperty("debugger", &WebContents::Debugger);
-}
-
-AtomBrowserContext* WebContents::GetBrowserContext() const {
-  return static_cast<AtomBrowserContext*>(web_contents()->GetBrowserContext());
-}
-
-void WebContents::OnRendererMessage(content::RenderFrameHost* frame_host,
-                                    const base::string16& channel,
-                                    const base::ListValue& args) {
-  // webContents.emit(channel, new Event(), args...);
-  Emit(base::UTF16ToUTF8(channel), args);
-}
-
-void WebContents::OnRendererMessageSync(content::RenderFrameHost* frame_host,
-                                        const base::string16& channel,
-                                        const base::ListValue& args,
-                                        IPC::Message* message) {
-  // webContents.emit(channel, new Event(sender, message), args...);
-  EmitWithSender(base::UTF16ToUTF8(channel), frame_host, message, args);
-}
-
-// static
-mate::Handle<WebContents> WebContents::CreateFrom(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents) {
-  // We have an existing WebContents object in JS.
-  auto* existing = TrackableObject::FromWrappedClass(isolate, web_contents);
-  if (existing)
-    return mate::CreateHandle(isolate, static_cast<WebContents*>(existing));
-
-  // Otherwise create a new WebContents wrapper object.
-  return mate::CreateHandle(isolate,
-                            new WebContents(isolate, web_contents, REMOTE));
-}
-
-mate::Handle<WebContents> WebContents::CreateFrom(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents,
-    Type type) {
-  // Otherwise create a new WebContents wrapper object.
-  return mate::CreateHandle(isolate,
-                            new WebContents(isolate, web_contents, type));
-}
-
-// static
-mate::Handle<WebContents> WebContents::Create(v8::Isolate* isolate,
-                                              const mate::Dictionary& options) {
-  return mate::CreateHandle(isolate, new WebContents(isolate, options));
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::WebContents;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("WebContents", WebContents::GetConstructor(isolate)->GetFunction());
-  dict.SetMethod("create", &WebContents::Create);
-  dict.SetMethod("fromId", &mate::TrackableObject<WebContents>::FromWeakMapID);
-  dict.SetMethod("getAllWebContents",
-                 &mate::TrackableObject<WebContents>::GetAll);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_web_contents, Initialize)
removed in remote
  base   100644 b734dc304dffc731456fcdf519ad0448eca6695a atom/browser/api/atom_api_web_contents.h
  our    100644 7939f8268aa8c3371623e0c15f3b6001d7f1efa4 atom/browser/api/atom_api_web_contents.h
@@ -1,473 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
-#define ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/frame_subscriber.h"
-#include "atom/browser/api/save_page_handler.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/common_web_contents_delegate.h"
-#include "atom/browser/ui/autofill_popup.h"
-#include "base/observer_list.h"
-#include "content/common/cursors/webcursor.h"
-#include "content/public/browser/keyboard_event_processing_result.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/browser/web_contents_observer.h"
-#include "content/public/common/favicon_url.h"
-#include "native_mate/handle.h"
-#include "printing/backend/print_backend.h"
-#include "ui/gfx/image/image.h"
-
-namespace blink {
-struct WebDeviceEmulationParams;
-}
-
-namespace brightray {
-class InspectableWebContents;
-}
-
-namespace mate {
-class Arguments;
-class Dictionary;
-}  // namespace mate
-
-namespace network {
-class ResourceRequestBody;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-class AtomJavaScriptDialogManager;
-class WebContentsZoomController;
-class WebViewGuestDelegate;
-class FrameSubscriber;
-
-#if defined(ENABLE_OSR)
-class OffScreenWebContentsView;
-class OffScreenRenderWidgetHostView;
-#endif
-
-namespace api {
-
-// Certain events are only in WebContentsDelegate, provide our own Observer to
-// dispatch those events.
-class ExtendedWebContentsObserver {
- public:
-  virtual void OnCloseContents() {}
-  virtual void OnRendererResponsive() {}
-};
-
-// Wrapper around the content::WebContents.
-class WebContents : public mate::TrackableObject<WebContents>,
-                    public CommonWebContentsDelegate,
-                    public content::WebContentsObserver {
- public:
-  enum Type {
-    BACKGROUND_PAGE,  // A DevTools extension background page.
-    BROWSER_WINDOW,   // Used by BrowserWindow.
-    BROWSER_VIEW,     // Used by BrowserView.
-    REMOTE,           // Thin wrap around an existing WebContents.
-    WEB_VIEW,         // Used by <webview>.
-    OFF_SCREEN,       // Used for offscreen rendering
-  };
-
-  // For node.js callback function type: function(error, buffer)
-  using PrintToPDFCallback =
-      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
-
-  // Create from an existing WebContents.
-  static mate::Handle<WebContents> CreateFrom(
-      v8::Isolate* isolate,
-      content::WebContents* web_contents);
-  static mate::Handle<WebContents> CreateFrom(
-      v8::Isolate* isolate,
-      content::WebContents* web_contents,
-      Type type);
-
-  // Create a new WebContents.
-  static mate::Handle<WebContents> Create(v8::Isolate* isolate,
-                                          const mate::Dictionary& options);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Notifies to destroy any guest web contents before destroying self.
-  void DestroyWebContents(bool async);
-
-  int GetProcessID() const;
-  base::ProcessId GetOSProcessID() const;
-  Type GetType() const;
-  bool Equal(const WebContents* web_contents) const;
-  void LoadURL(const GURL& url, const mate::Dictionary& options);
-  void DownloadURL(const GURL& url);
-  GURL GetURL() const;
-  base::string16 GetTitle() const;
-  bool IsLoading() const;
-  bool IsLoadingMainFrame() const;
-  bool IsWaitingForResponse() const;
-  void Stop();
-  void ReloadIgnoringCache();
-  void GoBack();
-  void GoForward();
-  void GoToOffset(int offset);
-  const std::string GetWebRTCIPHandlingPolicy() const;
-  void SetWebRTCIPHandlingPolicy(const std::string& webrtc_ip_handling_policy);
-  bool IsCrashed() const;
-  void SetUserAgent(const std::string& user_agent, mate::Arguments* args);
-  std::string GetUserAgent();
-  void InsertCSS(const std::string& css);
-  bool SavePage(const base::FilePath& full_file_path,
-                const content::SavePageType& save_type,
-                const SavePageHandler::SavePageCallback& callback);
-  void OpenDevTools(mate::Arguments* args);
-  void CloseDevTools();
-  bool IsDevToolsOpened();
-  bool IsDevToolsFocused();
-  void ToggleDevTools();
-  void EnableDeviceEmulation(const blink::WebDeviceEmulationParams& params);
-  void DisableDeviceEmulation();
-  void InspectElement(int x, int y);
-  void InspectServiceWorker();
-  void HasServiceWorker(const base::Callback<void(bool)>&);
-  void UnregisterServiceWorker(const base::Callback<void(bool)>&);
-  void SetIgnoreMenuShortcuts(bool ignore);
-  void SetAudioMuted(bool muted);
-  bool IsAudioMuted();
-  bool IsCurrentlyAudible();
-  void Print(mate::Arguments* args);
-  std::vector<printing::PrinterBasicInfo> GetPrinterList();
-  void SetEmbedder(const WebContents* embedder);
-  void SetDevToolsWebContents(const WebContents* devtools);
-  v8::Local<v8::Value> GetNativeView() const;
-
-  // Print current page as PDF.
-  void PrintToPDF(const base::DictionaryValue& setting,
-                  const PrintToPDFCallback& callback);
-
-  // DevTools workspace api.
-  void AddWorkSpace(mate::Arguments* args, const base::FilePath& path);
-  void RemoveWorkSpace(mate::Arguments* args, const base::FilePath& path);
-
-  // Editing commands.
-  void Undo();
-  void Redo();
-  void Cut();
-  void Copy();
-  void Paste();
-  void PasteAndMatchStyle();
-  void Delete();
-  void SelectAll();
-  void Unselect();
-  void Replace(const base::string16& word);
-  void ReplaceMisspelling(const base::string16& word);
-  uint32_t FindInPage(mate::Arguments* args);
-  void StopFindInPage(content::StopFindAction action);
-  void ShowDefinitionForSelection();
-  void CopyImageAt(int x, int y);
-
-  // Focus.
-  void Focus();
-  bool IsFocused() const;
-  void TabTraverse(bool reverse);
-
-  // Send messages to browser.
-  bool SendIPCMessage(bool all_frames,
-                      const base::string16& channel,
-                      const base::ListValue& args);
-
-  // Send WebInputEvent to the page.
-  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);
-
-  // Subscribe to the frame updates.
-  void BeginFrameSubscription(mate::Arguments* args);
-  void EndFrameSubscription();
-
-  // Dragging native items.
-  void StartDrag(const mate::Dictionary& item, mate::Arguments* args);
-
-  // Captures the page with |rect|, |callback| would be called when capturing is
-  // done.
-  void CapturePage(mate::Arguments* args);
-
-  // Methods for creating <webview>.
-  bool IsGuest() const;
-  void AttachToIframe(content::WebContents* embedder_web_contents,
-                      int embedder_frame_id);
-
-  // Methods for offscreen rendering
-  bool IsOffScreen() const;
-  void OnPaint(const gfx::Rect& dirty_rect, const SkBitmap& bitmap);
-  void StartPainting();
-  void StopPainting();
-  bool IsPainting() const;
-  void SetFrameRate(int frame_rate);
-  int GetFrameRate() const;
-  void Invalidate();
-  gfx::Size GetSizeForNewRenderView(content::WebContents*) const override;
-
-  // Methods for zoom handling.
-  void SetZoomLevel(double level);
-  double GetZoomLevel() const;
-  void SetZoomFactor(double factor);
-  double GetZoomFactor() const;
-
-  // Callback triggered on permission response.
-  void OnEnterFullscreenModeForTab(content::WebContents* source,
-                                   const GURL& origin,
-                                   bool allowed);
-
-  // Create window with the given disposition.
-  void OnCreateWindow(const GURL& target_url,
-                      const content::Referrer& referrer,
-                      const std::string& frame_name,
-                      WindowOpenDisposition disposition,
-                      const std::vector<std::string>& features,
-                      const scoped_refptr<network::ResourceRequestBody>& body);
-
-  // Returns the preload script path of current WebContents.
-  v8::Local<v8::Value> GetPreloadPath(v8::Isolate* isolate) const;
-
-  // Returns the web preferences of current WebContents.
-  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate) const;
-  v8::Local<v8::Value> GetLastWebPreferences(v8::Isolate* isolate) const;
-
-  // Returns the owner window.
-  v8::Local<v8::Value> GetOwnerBrowserWindow() const;
-
-  // Grants the child process the capability to access URLs with the origin of
-  // the specified URL.
-  void GrantOriginAccess(const GURL& url);
-
-  // Properties.
-  int32_t ID() const;
-  v8::Local<v8::Value> Session(v8::Isolate* isolate);
-  content::WebContents* HostWebContents();
-  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);
-  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);
-
-  WebContentsZoomController* GetZoomController() { return zoom_controller_; }
-
-  void AddObserver(ExtendedWebContentsObserver* obs) {
-    observers_.AddObserver(obs);
-  }
-  void RemoveObserver(ExtendedWebContentsObserver* obs) {
-    observers_.RemoveObserver(obs);
-  }
-
- protected:
-  WebContents(v8::Isolate* isolate,
-              content::WebContents* web_contents,
-              Type type);
-  WebContents(v8::Isolate* isolate, const mate::Dictionary& options);
-  ~WebContents() override;
-
-  void InitWithSessionAndOptions(v8::Isolate* isolate,
-                                 content::WebContents* web_contents,
-                                 mate::Handle<class Session> session,
-                                 const mate::Dictionary& options);
-
-  // content::WebContentsDelegate:
-  bool DidAddMessageToConsole(content::WebContents* source,
-                              int32_t level,
-                              const base::string16& message,
-                              int32_t line_no,
-                              const base::string16& source_id) override;
-  void WebContentsCreated(content::WebContents* source_contents,
-                          int opener_render_process_id,
-                          int opener_render_frame_id,
-                          const std::string& frame_name,
-                          const GURL& target_url,
-                          content::WebContents* new_contents) override;
-  void AddNewContents(content::WebContents* source,
-                      content::WebContents* new_contents,
-                      WindowOpenDisposition disposition,
-                      const gfx::Rect& initial_rect,
-                      bool user_gesture,
-                      bool* was_blocked) override;
-  content::WebContents* OpenURLFromTab(
-      content::WebContents* source,
-      const content::OpenURLParams& params) override;
-  void BeforeUnloadFired(content::WebContents* tab,
-                         bool proceed,
-                         bool* proceed_to_fire_unload) override;
-  void MoveContents(content::WebContents* source,
-                    const gfx::Rect& pos) override;
-  void CloseContents(content::WebContents* source) override;
-  void ActivateContents(content::WebContents* contents) override;
-  void UpdateTargetURL(content::WebContents* source, const GURL& url) override;
-  bool IsPopupOrPanel(const content::WebContents* source) const override;
-  void HandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-  content::KeyboardEventProcessingResult PreHandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-  void EnterFullscreenModeForTab(content::WebContents* source,
-                                 const GURL& origin) override;
-  void ExitFullscreenModeForTab(content::WebContents* source) override;
-  void RendererUnresponsive(
-      content::WebContents* source,
-      content::RenderWidgetHost* render_widget_host) override;
-  void RendererResponsive(
-      content::WebContents* source,
-      content::RenderWidgetHost* render_widget_host) override;
-  bool HandleContextMenu(const content::ContextMenuParams& params) override;
-  bool OnGoToEntryOffset(int offset) override;
-  void FindReply(content::WebContents* web_contents,
-                 int request_id,
-                 int number_of_matches,
-                 const gfx::Rect& selection_rect,
-                 int active_match_ordinal,
-                 bool final_update) override;
-  bool CheckMediaAccessPermission(content::WebContents* web_contents,
-                                  const GURL& security_origin,
-                                  content::MediaStreamType type) override;
-  void RequestMediaAccessPermission(
-      content::WebContents* web_contents,
-      const content::MediaStreamRequest& request,
-      const content::MediaResponseCallback& callback) override;
-  void RequestToLockMouse(content::WebContents* web_contents,
-                          bool user_gesture,
-                          bool last_unlocked_by_target) override;
-  std::unique_ptr<content::BluetoothChooser> RunBluetoothChooser(
-      content::RenderFrameHost* frame,
-      const content::BluetoothChooser::EventHandler& handler) override;
-  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
-      content::WebContents* source) override;
-
-  // content::WebContentsObserver:
-  void BeforeUnloadFired(const base::TimeTicks& proceed_time) override;
-  void RenderViewCreated(content::RenderViewHost*) override;
-  void RenderViewDeleted(content::RenderViewHost*) override;
-  void RenderProcessGone(base::TerminationStatus status) override;
-  void DocumentLoadedInFrame(
-      content::RenderFrameHost* render_frame_host) override;
-  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
-                     const GURL& validated_url) override;
-  void DidFailLoad(content::RenderFrameHost* render_frame_host,
-                   const GURL& validated_url,
-                   int error_code,
-                   const base::string16& error_description) override;
-  void DidStartLoading() override;
-  void DidStopLoading() override;
-  void DidStartNavigation(
-      content::NavigationHandle* navigation_handle) override;
-  void DidFinishNavigation(
-      content::NavigationHandle* navigation_handle) override;
-  bool OnMessageReceived(const IPC::Message& message) override;
-  bool OnMessageReceived(const IPC::Message& message,
-                         content::RenderFrameHost* frame_host) override;
-  void WebContentsDestroyed() override;
-  void NavigationEntryCommitted(
-      const content::LoadCommittedDetails& load_details) override;
-  void TitleWasSet(content::NavigationEntry* entry) override;
-  void DidUpdateFaviconURL(
-      const std::vector<content::FaviconURL>& urls) override;
-  void PluginCrashed(const base::FilePath& plugin_path,
-                     base::ProcessId plugin_pid) override;
-  void MediaStartedPlaying(const MediaPlayerInfo& video_type,
-                           const MediaPlayerId& id) override;
-  void MediaStoppedPlaying(
-      const MediaPlayerInfo& video_type,
-      const MediaPlayerId& id,
-      content::WebContentsObserver::MediaStoppedReason reason) override;
-  void DidChangeThemeColor(SkColor theme_color) override;
-
-  // brightray::InspectableWebContentsDelegate:
-  void DevToolsReloadPage() override;
-
-  // brightray::InspectableWebContentsViewDelegate:
-  void DevToolsFocused() override;
-  void DevToolsOpened() override;
-  void DevToolsClosed() override;
-
-#if defined(TOOLKIT_VIEWS)
-  void ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                         const gfx::RectF& bounds,
-                         const std::vector<base::string16>& values,
-                         const std::vector<base::string16>& labels);
-#endif
-
- private:
-  struct FrameDispatchHelper;
-  AtomBrowserContext* GetBrowserContext() const;
-
-  uint32_t GetNextRequestId() { return ++request_id_; }
-
-#if defined(ENABLE_OSR)
-  OffScreenWebContentsView* GetOffScreenWebContentsView() const;
-  OffScreenRenderWidgetHostView* GetOffScreenRenderWidgetHostView() const;
-#endif
-
-  // Called when we receive a CursorChange message from chromium.
-  void OnCursorChange(const content::WebCursor& cursor);
-
-  // Called when received a message from renderer.
-  void OnRendererMessage(content::RenderFrameHost* frame_host,
-                         const base::string16& channel,
-                         const base::ListValue& args);
-
-  // Called when received a synchronous message from renderer.
-  void OnRendererMessageSync(content::RenderFrameHost* frame_host,
-                             const base::string16& channel,
-                             const base::ListValue& args,
-                             IPC::Message* message);
-
-  // Called when received a synchronous message from renderer to
-  // set temporary zoom level.
-  void OnSetTemporaryZoomLevel(content::RenderFrameHost* frame_host,
-                               double level,
-                               IPC::Message* reply_msg);
-
-  // Called when received a synchronous message from renderer to
-  // get the zoom level.
-  void OnGetZoomLevel(content::RenderFrameHost* frame_host,
-                      IPC::Message* reply_msg);
-
-  void InitZoomController(content::WebContents* web_contents,
-                          const mate::Dictionary& options);
-
-  v8::Global<v8::Value> session_;
-  v8::Global<v8::Value> devtools_web_contents_;
-  v8::Global<v8::Value> debugger_;
-
-  std::unique_ptr<AtomJavaScriptDialogManager> dialog_manager_;
-  std::unique_ptr<WebViewGuestDelegate> guest_delegate_;
-
-  std::unique_ptr<FrameSubscriber> frame_subscriber_;
-
-  // The host webcontents that may contain this webcontents.
-  WebContents* embedder_ = nullptr;
-
-  // The zoom controller for this webContents.
-  WebContentsZoomController* zoom_controller_ = nullptr;
-
-  // The type of current WebContents.
-  Type type_ = BROWSER_WINDOW;
-
-  // Request id used for findInPage request.
-  uint32_t request_id_ = 0;
-
-  // Whether background throttling is disabled.
-  bool background_throttling_ = true;
-
-  // Whether to enable devtools.
-  bool enable_devtools_ = true;
-
-  // Observers of this WebContents.
-  base::ObserverList<ExtendedWebContentsObserver> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContents);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_WEB_CONTENTS_H_
removed in remote
  base   100644 a987369ed82de17033e6dde512ddec31aa4e3dd9 atom/browser/api/atom_api_web_request.cc
  our    100644 c088196f833160ac964e67030fa083302dd090b0 atom/browser/api/atom_api_web_request.cc
@@ -1,146 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/atom_api_web_request.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-template <>
-struct Converter<URLPattern> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     URLPattern* out) {
-    std::string pattern;
-    if (!ConvertFromV8(isolate, val, &pattern))
-      return false;
-    *out = URLPattern(URLPattern::SCHEME_ALL);
-    return out->Parse(pattern) == URLPattern::PARSE_SUCCESS;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-template <typename Method, typename Event, typename Listener>
-void CallNetworkDelegateMethod(
-    brightray::URLRequestContextGetter* url_request_context_getter,
-    Method method,
-    Event type,
-    URLPatterns patterns,
-    Listener listener) {
-  // Force creating network delegate.
-  net::URLRequestContext* context =
-      url_request_context_getter->GetURLRequestContext();
-  // Then call the method.
-  AtomNetworkDelegate* network_delegate =
-      static_cast<AtomNetworkDelegate*>(context->network_delegate());
-  (network_delegate->*method)(type, std::move(patterns), std::move(listener));
-}
-
-}  // namespace
-
-WebRequest::WebRequest(v8::Isolate* isolate,
-                       AtomBrowserContext* browser_context)
-    : browser_context_(browser_context) {
-  Init(isolate);
-}
-
-WebRequest::~WebRequest() {}
-
-template <AtomNetworkDelegate::SimpleEvent type>
-void WebRequest::SetSimpleListener(mate::Arguments* args) {
-  SetListener<AtomNetworkDelegate::SimpleListener>(
-      &AtomNetworkDelegate::SetSimpleListenerInIO, type, args);
-}
-
-template <AtomNetworkDelegate::ResponseEvent type>
-void WebRequest::SetResponseListener(mate::Arguments* args) {
-  SetListener<AtomNetworkDelegate::ResponseListener>(
-      &AtomNetworkDelegate::SetResponseListenerInIO, type, args);
-}
-
-template <typename Listener, typename Method, typename Event>
-void WebRequest::SetListener(Method method, Event type, mate::Arguments* args) {
-  // { urls }.
-  URLPatterns patterns;
-  mate::Dictionary dict;
-  args->GetNext(&dict) && dict.Get("urls", &patterns);
-
-  // Function or null.
-  v8::Local<v8::Value> value;
-  Listener listener;
-  if (!args->GetNext(&listener) &&
-      !(args->GetNext(&value) && value->IsNull())) {
-    args->ThrowError("Must pass null or a Function");
-    return;
-  }
-
-  brightray::URLRequestContextGetter* url_request_context_getter =
-      browser_context_->GetRequestContext();
-  if (!url_request_context_getter)
-    return;
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&CallNetworkDelegateMethod<Method, Event, Listener>,
-                     base::RetainedRef(url_request_context_getter), method,
-                     type, std::move(patterns), std::move(listener)));
-}
-
-// static
-mate::Handle<WebRequest> WebRequest::Create(
-    v8::Isolate* isolate,
-    AtomBrowserContext* browser_context) {
-  return mate::CreateHandle(isolate, new WebRequest(isolate, browser_context));
-}
-
-// static
-void WebRequest::BuildPrototype(v8::Isolate* isolate,
-                                v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebRequest"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("onBeforeRequest", &WebRequest::SetResponseListener<
-                                        AtomNetworkDelegate::kOnBeforeRequest>)
-      .SetMethod("onBeforeSendHeaders",
-                 &WebRequest::SetResponseListener<
-                     AtomNetworkDelegate::kOnBeforeSendHeaders>)
-      .SetMethod("onHeadersReceived",
-                 &WebRequest::SetResponseListener<
-                     AtomNetworkDelegate::kOnHeadersReceived>)
-      .SetMethod(
-          "onSendHeaders",
-          &WebRequest::SetSimpleListener<AtomNetworkDelegate::kOnSendHeaders>)
-      .SetMethod("onBeforeRedirect",
-                 &WebRequest::SetSimpleListener<
-                     AtomNetworkDelegate::kOnBeforeRedirect>)
-      .SetMethod("onResponseStarted",
-                 &WebRequest::SetSimpleListener<
-                     AtomNetworkDelegate::kOnResponseStarted>)
-      .SetMethod(
-          "onCompleted",
-          &WebRequest::SetSimpleListener<AtomNetworkDelegate::kOnCompleted>)
-      .SetMethod("onErrorOccurred", &WebRequest::SetSimpleListener<
-                                        AtomNetworkDelegate::kOnErrorOccurred>);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 9a6e17a0460585693465ae4a8f6f75c2871a738a atom/browser/api/atom_api_web_request.h
  our    100644 87fa08815877c80330e3155804295638b2da1094 atom/browser/api/atom_api_web_request.h
@@ -1,49 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
-#define ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
-
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/net/atom_network_delegate.h"
-#include "native_mate/arguments.h"
-#include "native_mate/handle.h"
-
-namespace atom {
-
-class AtomBrowserContext;
-
-namespace api {
-
-class WebRequest : public mate::TrackableObject<WebRequest> {
- public:
-  static mate::Handle<WebRequest> Create(v8::Isolate* isolate,
-                                         AtomBrowserContext* browser_context);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- protected:
-  WebRequest(v8::Isolate* isolate, AtomBrowserContext* browser_context);
-  ~WebRequest() override;
-
-  // C++ can not distinguish overloaded member function.
-  template <AtomNetworkDelegate::SimpleEvent type>
-  void SetSimpleListener(mate::Arguments* args);
-  template <AtomNetworkDelegate::ResponseEvent type>
-  void SetResponseListener(mate::Arguments* args);
-  template <typename Listener, typename Method, typename Event>
-  void SetListener(Method method, Event type, mate::Arguments* args);
-
- private:
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebRequest);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_ATOM_API_WEB_REQUEST_H_
removed in remote
  base   100644 e57c5ffb6bb4aea16b72f29e53ec48a269d2d08e atom/browser/api/atom_api_web_view_manager.cc
  our    100644 e24d6306f62a63331304617c969db410db0ae0c4 atom/browser/api/atom_api_web_view_manager.cc
@@ -1,58 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "content/public/browser/browser_context.h"
-#include "native_mate/dictionary.h"
-
-// Must be the last in the includes list.
-// See https://github.com/electron/electron/issues/10363
-#include "atom/common/node_includes.h"
-
-using atom::WebContentsPreferences;
-
-namespace {
-
-void AddGuest(int guest_instance_id,
-              int element_instance_id,
-              content::WebContents* embedder,
-              content::WebContents* guest_web_contents,
-              const base::DictionaryValue& options) {
-  auto* manager = atom::WebViewManager::GetWebViewManager(embedder);
-  if (manager)
-    manager->AddGuest(guest_instance_id, element_instance_id, embedder,
-                      guest_web_contents);
-
-  double zoom_factor;
-  if (options.GetDouble(atom::options::kZoomFactor, &zoom_factor)) {
-    atom::WebContentsZoomController::FromWebContents(guest_web_contents)
-        ->SetDefaultZoomFactor(zoom_factor);
-  }
-
-  WebContentsPreferences::From(guest_web_contents)->Merge(options);
-}
-
-void RemoveGuest(content::WebContents* embedder, int guest_instance_id) {
-  auto* manager = atom::WebViewManager::GetWebViewManager(embedder);
-  if (manager)
-    manager->RemoveGuest(guest_instance_id);
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("addGuest", &AddGuest);
-  dict.SetMethod("removeGuest", &RemoveGuest);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_browser_web_view_manager, Initialize)
removed in remote
  base   100644 5c87292ea52ed33340846ab255d48ab2edfeebb6 atom/browser/api/event.cc
  our    100644 7b617034eca5a229fc9323bfd6d531ebded752d6 atom/browser/api/event.cc
@@ -1,81 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/event.h"
-
-#include "atom/common/api/api_messages.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/web_contents.h"
-#include "native_mate/object_template_builder.h"
-
-namespace mate {
-
-Event::Event(v8::Isolate* isolate) {
-  Init(isolate);
-}
-
-Event::~Event() {}
-
-void Event::SetSenderAndMessage(content::RenderFrameHost* sender,
-                                IPC::Message* message) {
-  DCHECK(!sender_);
-  DCHECK(!message_);
-  sender_ = sender;
-  message_ = message;
-
-  Observe(content::WebContents::FromRenderFrameHost(sender));
-}
-
-void Event::RenderFrameDeleted(content::RenderFrameHost* rfh) {
-  if (sender_ != rfh)
-    return;
-  sender_ = nullptr;
-  message_ = nullptr;
-}
-
-void Event::RenderFrameHostChanged(content::RenderFrameHost* old_rfh,
-                                   content::RenderFrameHost* new_rfh) {
-  if (sender_ && sender_ == old_rfh)
-    sender_ = new_rfh;
-}
-
-void Event::FrameDeleted(content::RenderFrameHost* rfh) {
-  if (sender_ != rfh)
-    return;
-  sender_ = nullptr;
-  message_ = nullptr;
-}
-
-void Event::PreventDefault(v8::Isolate* isolate) {
-  GetWrapper()->Set(StringToV8(isolate, "defaultPrevented"), v8::True(isolate));
-}
-
-bool Event::SendReply(const base::ListValue& result) {
-  if (message_ == nullptr || sender_ == nullptr)
-    return false;
-
-  AtomFrameHostMsg_Message_Sync::WriteReplyParams(message_, result);
-  bool success = sender_->Send(message_);
-  message_ = nullptr;
-  sender_ = nullptr;
-  return success;
-}
-
-// static
-Handle<Event> Event::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new Event(isolate));
-}
-
-// static
-void Event::BuildPrototype(v8::Isolate* isolate,
-                           v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "Event"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("preventDefault", &Event::PreventDefault)
-      .SetMethod("sendReply", &Event::SendReply);
-}
-
-}  // namespace mate
removed in remote
  base   100644 5cdc08324b72e4f20d5fb4e02af97624c2599c9d atom/browser/api/event.h
  our    100644 fbec8f27574691005d203adbafb50709f5c2d010 atom/browser/api/event.h
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_EVENT_H_
-#define ATOM_BROWSER_API_EVENT_H_
-
-#include "content/public/browser/web_contents_observer.h"
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-
-namespace IPC {
-class Message;
-}
-
-namespace mate {
-
-class Event : public Wrappable<Event>, public content::WebContentsObserver {
- public:
-  static Handle<Event> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-  // Pass the sender and message to be replied.
-  void SetSenderAndMessage(content::RenderFrameHost* sender,
-                           IPC::Message* message);
-
-  // event.PreventDefault().
-  void PreventDefault(v8::Isolate* isolate);
-
-  // event.sendReply(array), used for replying synchronous message.
-  bool SendReply(const base::ListValue& result);
-
- protected:
-  explicit Event(v8::Isolate* isolate);
-  ~Event() override;
-
-  // content::WebContentsObserver implementations:
-  void RenderFrameDeleted(content::RenderFrameHost* rfh) override;
-  void RenderFrameHostChanged(content::RenderFrameHost* old_rfh,
-                              content::RenderFrameHost* new_rfh) override;
-  void FrameDeleted(content::RenderFrameHost* rfh) override;
-
- private:
-  // Replyer for the synchronous messages.
-  content::RenderFrameHost* sender_ = nullptr;
-  IPC::Message* message_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(Event);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_EVENT_H_
removed in remote
  base   100644 be7018dafa44af1d7e30b4722126e8ca0faea443 atom/browser/api/event_emitter.cc
  our    100644 c6e810b51225c8f89eaf53ac3e46381b52ba63b5 atom/browser/api/event_emitter.cc
@@ -1,82 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/event_emitter.h"
-
-#include "atom/browser/api/event.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "ui/events/event_constants.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace {
-
-v8::Persistent<v8::ObjectTemplate> event_template;
-
-void PreventDefault(mate::Arguments* args) {
-  mate::Dictionary self(args->isolate(), args->GetThis());
-  self.Set("defaultPrevented", true);
-}
-
-// Create a pure JavaScript Event object.
-v8::Local<v8::Object> CreateEventObject(v8::Isolate* isolate) {
-  if (event_template.IsEmpty()) {
-    event_template.Reset(
-        isolate,
-        ObjectTemplateBuilder(isolate, v8::ObjectTemplate::New(isolate))
-            .SetMethod("preventDefault", &PreventDefault)
-            .Build());
-  }
-
-  return v8::Local<v8::ObjectTemplate>::New(isolate, event_template)
-      ->NewInstance();
-}
-
-}  // namespace
-
-namespace internal {
-
-v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    content::RenderFrameHost* sender,
-                                    IPC::Message* message) {
-  v8::Local<v8::Object> event;
-  bool use_native_event = sender && message;
-
-  if (use_native_event) {
-    mate::Handle<mate::Event> native_event = mate::Event::Create(isolate);
-    native_event->SetSenderAndMessage(sender, message);
-    event = v8::Local<v8::Object>::Cast(native_event.ToV8());
-  } else {
-    event = CreateEventObject(isolate);
-  }
-  mate::Dictionary(isolate, event).Set("sender", object);
-  return event;
-}
-
-v8::Local<v8::Object> CreateCustomEvent(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> object,
-                                        v8::Local<v8::Object> custom_event) {
-  v8::Local<v8::Object> event = CreateEventObject(isolate);
-  (void)event->SetPrototype(custom_event->CreationContext(), custom_event);
-  mate::Dictionary(isolate, event).Set("sender", object);
-  return event;
-}
-
-v8::Local<v8::Object> CreateEventFromFlags(v8::Isolate* isolate, int flags) {
-  mate::Dictionary obj = mate::Dictionary::CreateEmpty(isolate);
-  obj.Set("shiftKey", static_cast<bool>(flags & ui::EF_SHIFT_DOWN));
-  obj.Set("ctrlKey", static_cast<bool>(flags & ui::EF_CONTROL_DOWN));
-  obj.Set("altKey", static_cast<bool>(flags & ui::EF_ALT_DOWN));
-  obj.Set("metaKey", static_cast<bool>(flags & ui::EF_COMMAND_DOWN));
-  return obj.GetHandle();
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 42816d42a45bd378be558f93f9e63c5bc28070ad atom/browser/api/event_emitter.h
  our    100644 5e4ca3b4ffcb184583ef386100eabda7a9e00da0 atom/browser/api/event_emitter.h
@@ -1,112 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_EVENT_EMITTER_H_
-#define ATOM_BROWSER_API_EVENT_EMITTER_H_
-
-#include <vector>
-
-#include "atom/common/api/event_emitter_caller.h"
-#include "native_mate/wrappable.h"
-
-namespace content {
-class RenderFrameHost;
-}
-
-namespace IPC {
-class Message;
-}
-
-namespace mate {
-
-namespace internal {
-
-v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    content::RenderFrameHost* sender,
-                                    IPC::Message* message);
-v8::Local<v8::Object> CreateCustomEvent(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> object,
-                                        v8::Local<v8::Object> event);
-v8::Local<v8::Object> CreateEventFromFlags(v8::Isolate* isolate, int flags);
-
-}  // namespace internal
-
-// Provide helperers to emit event in JavaScript.
-template <typename T>
-class EventEmitter : public Wrappable<T> {
- public:
-  typedef std::vector<v8::Local<v8::Value>> ValueArray;
-
-  // Make the convinient methods visible:
-  // https://isocpp.org/wiki/faq/templates#nondependent-name-lookup-members
-  v8::Isolate* isolate() const { return Wrappable<T>::isolate(); }
-  v8::Local<v8::Object> GetWrapper() const {
-    return Wrappable<T>::GetWrapper();
-  }
-
-  // this.emit(name, event, args...);
-  template <typename... Args>
-  bool EmitCustomEvent(const base::StringPiece& name,
-                       v8::Local<v8::Object> event,
-                       const Args&... args) {
-    return EmitWithEvent(
-        name, internal::CreateCustomEvent(isolate(), GetWrapper(), event),
-        args...);
-  }
-
-  // this.emit(name, new Event(flags), args...);
-  template <typename... Args>
-  bool EmitWithFlags(const base::StringPiece& name,
-                     int flags,
-                     const Args&... args) {
-    return EmitCustomEvent(
-        name, internal::CreateEventFromFlags(isolate(), flags), args...);
-  }
-
-  // this.emit(name, new Event(), args...);
-  template <typename... Args>
-  bool Emit(const base::StringPiece& name, const Args&... args) {
-    return EmitWithSender(name, nullptr, nullptr, args...);
-  }
-
-  // this.emit(name, new Event(sender, message), args...);
-  template <typename... Args>
-  bool EmitWithSender(const base::StringPiece& name,
-                      content::RenderFrameHost* sender,
-                      IPC::Message* message,
-                      const Args&... args) {
-    v8::Locker locker(isolate());
-    v8::HandleScope handle_scope(isolate());
-    v8::Local<v8::Object> wrapper = GetWrapper();
-    if (wrapper.IsEmpty()) {
-      return false;
-    }
-    v8::Local<v8::Object> event =
-        internal::CreateJSEvent(isolate(), wrapper, sender, message);
-    return EmitWithEvent(name, event, args...);
-  }
-
- protected:
-  EventEmitter() {}
-
- private:
-  // this.emit(name, event, args...);
-  template <typename... Args>
-  bool EmitWithEvent(const base::StringPiece& name,
-                     v8::Local<v8::Object> event,
-                     const Args&... args) {
-    v8::Locker locker(isolate());
-    v8::HandleScope handle_scope(isolate());
-    EmitEvent(isolate(), GetWrapper(), name, event, args...);
-    return event->Get(StringToV8(isolate(), "defaultPrevented"))
-        ->BooleanValue();
-  }
-
-  DISALLOW_COPY_AND_ASSIGN(EventEmitter);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_EVENT_EMITTER_H_
removed in remote
  base   100644 f81a8bea8b1a4f38f1dd842fb3bb588ed43c2ce9 atom/browser/api/frame_subscriber.cc
  our    100644 7bcb7ab9370a8b3fe245c9569c93dbbdac0a0697 atom/browser/api/frame_subscriber.cc
@@ -1,100 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/frame_subscriber.h"
-
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "components/viz/common/frame_sinks/copy_output_request.h"
-#include "components/viz/service/frame_sinks/frame_sink_manager_impl.h"
-#include "components/viz/service/surfaces/surface_manager.h"
-#include "content/browser/compositor/surface_utils.h"
-#include "content/browser/renderer_host/render_widget_host_view_base.h"
-#include "ui/gfx/geometry/rect_conversions.h"
-#include "ui/gfx/skbitmap_operations.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-FrameSubscriber::FrameSubscriber(v8::Isolate* isolate,
-                                 content::WebContents* web_contents,
-                                 const FrameCaptureCallback& callback,
-                                 bool only_dirty)
-    : content::WebContentsObserver(web_contents),
-      isolate_(isolate),
-      callback_(callback),
-      only_dirty_(only_dirty),
-      weak_ptr_factory_(this) {}
-
-FrameSubscriber::~FrameSubscriber() = default;
-
-gfx::Rect FrameSubscriber::GetDamageRect() {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (view == nullptr)
-    return gfx::Rect();
-
-  auto* view_base = static_cast<content::RenderWidgetHostViewBase*>(view);
-  viz::SurfaceManager* surface_manager =
-      content::GetFrameSinkManager()->surface_manager();
-  viz::Surface* surface =
-      surface_manager->GetSurfaceForId(view_base->GetCurrentSurfaceId());
-  if (surface == nullptr)
-    return gfx::Rect();
-
-  if (surface->HasActiveFrame()) {
-    const viz::CompositorFrame& frame = surface->GetActiveFrame();
-    viz::RenderPass* root_pass = frame.render_pass_list.back().get();
-    gfx::Size frame_size = root_pass->output_rect.size();
-    gfx::Rect damage_rect =
-        gfx::ToEnclosingRect(gfx::RectF(root_pass->damage_rect));
-    damage_rect.Intersect(gfx::Rect(frame_size));
-    return gfx::ScaleToEnclosedRect(damage_rect,
-                                    1.0f / frame.device_scale_factor());
-  } else {
-    return gfx::Rect();
-  }
-}
-
-void FrameSubscriber::DidReceiveCompositorFrame() {
-  auto* view = web_contents()->GetRenderWidgetHostView();
-  if (view == nullptr)
-    return;
-
-  view->CopyFromSurface(
-      gfx::Rect(), view->GetViewBounds().size(),
-      base::BindOnce(&FrameSubscriber::Done, weak_ptr_factory_.GetWeakPtr(),
-                     GetDamageRect()));
-}
-
-void FrameSubscriber::Done(const gfx::Rect& damage, const SkBitmap& frame) {
-  if (frame.drawsNothing())
-    return;
-
-  v8::Locker locker(isolate_);
-  v8::HandleScope handle_scope(isolate_);
-
-  const_cast<SkBitmap&>(frame).setAlphaType(kPremul_SkAlphaType);
-  const SkBitmap& bitmap = only_dirty_ ? SkBitmapOperations::CreateTiledBitmap(
-                                             frame, damage.x(), damage.y(),
-                                             damage.width(), damage.height())
-                                       : frame;
-
-  size_t rgb_row_size = bitmap.width() * bitmap.bytesPerPixel();
-  auto* source = static_cast<const char*>(bitmap.getPixels());
-
-  v8::MaybeLocal<v8::Object> buffer =
-      node::Buffer::Copy(isolate_, source, rgb_row_size * bitmap.height());
-  auto local_buffer = buffer.ToLocalChecked();
-
-  v8::Local<v8::Value> damage_rect =
-      mate::Converter<gfx::Rect>::ToV8(isolate_, damage);
-
-  callback_.Run(local_buffer, damage_rect);
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 a803d75dff20f211df6708e2e27a58495ed9821f atom/browser/api/frame_subscriber.h
  our    100644 d3e82855417cb59c0449f1c1b685970ffaea2af6 atom/browser/api/frame_subscriber.h
@@ -1,52 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
-#define ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
-
-#include "content/public/browser/web_contents.h"
-
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "components/viz/common/frame_sinks/copy_output_result.h"
-#include "content/public/browser/web_contents_observer.h"
-#include "ui/gfx/image/image.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-namespace api {
-
-class WebContents;
-
-class FrameSubscriber : public content::WebContentsObserver {
- public:
-  using FrameCaptureCallback =
-      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
-
-  FrameSubscriber(v8::Isolate* isolate,
-                  content::WebContents* web_contents,
-                  const FrameCaptureCallback& callback,
-                  bool only_dirty);
-  ~FrameSubscriber() override;
-
- private:
-  gfx::Rect GetDamageRect();
-  void DidReceiveCompositorFrame() override;
-  void Done(const gfx::Rect& damage, const SkBitmap& frame);
-
-  v8::Isolate* isolate_;
-  FrameCaptureCallback callback_;
-  bool only_dirty_;
-
-  base::WeakPtrFactory<FrameSubscriber> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(FrameSubscriber);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_FRAME_SUBSCRIBER_H_
removed in remote
  base   100644 1e5bc094cf63f04bc98602a8ad29b1c34024b595 atom/browser/api/save_page_handler.cc
  our    100644 a0d8e283961d7ff79f78918907ab436d1e426b49 atom/browser/api/save_page_handler.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/save_page_handler.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_context.h"
-#include "base/callback.h"
-#include "base/files/file_path.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-namespace api {
-
-SavePageHandler::SavePageHandler(content::WebContents* web_contents,
-                                 const SavePageCallback& callback)
-    : web_contents_(web_contents), callback_(callback) {}
-
-SavePageHandler::~SavePageHandler() {}
-
-void SavePageHandler::OnDownloadCreated(content::DownloadManager* manager,
-                                        download::DownloadItem* item) {
-  // OnDownloadCreated is invoked during WebContents::SavePage, so the |item|
-  // here is the one stated by WebContents::SavePage.
-  item->AddObserver(this);
-}
-
-bool SavePageHandler::Handle(const base::FilePath& full_path,
-                             const content::SavePageType& save_type) {
-  auto* download_manager = content::BrowserContext::GetDownloadManager(
-      web_contents_->GetBrowserContext());
-  download_manager->AddObserver(this);
-  // Chromium will create a 'foo_files' directory under the directory of saving
-  // page 'foo.html' for holding other resource files of 'foo.html'.
-  base::FilePath saved_main_directory_path = full_path.DirName().Append(
-      full_path.RemoveExtension().BaseName().value() +
-      FILE_PATH_LITERAL("_files"));
-  bool result =
-      web_contents_->SavePage(full_path, saved_main_directory_path, save_type);
-  download_manager->RemoveObserver(this);
-  // If initialization fails which means fail to create |DownloadItem|, we need
-  // to delete the |SavePageHandler| instance to avoid memory-leak.
-  if (!result)
-    delete this;
-  return result;
-}
-
-void SavePageHandler::OnDownloadUpdated(download::DownloadItem* item) {
-  if (item->IsDone()) {
-    v8::Isolate* isolate = v8::Isolate::GetCurrent();
-    v8::Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    if (item->GetState() == download::DownloadItem::COMPLETE) {
-      callback_.Run(v8::Null(isolate));
-    } else {
-      v8::Local<v8::String> error_message =
-          v8::String::NewFromUtf8(isolate, "Fail to save page");
-      callback_.Run(v8::Exception::Error(error_message));
-    }
-    Destroy(item);
-  }
-}
-
-void SavePageHandler::Destroy(download::DownloadItem* item) {
-  item->RemoveObserver(this);
-  delete this;
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 dd1692a8badc4091578e8edb7d37e3618a4cf0fe atom/browser/api/save_page_handler.h
  our    100644 204d65bd6b1865686cd6600caa3423a75b5295fb atom/browser/api/save_page_handler.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
-#define ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
-
-#include <string>
-
-#include "components/download/public/common/download_item.h"
-#include "content/public/browser/download_manager.h"
-#include "content/public/browser/save_page_type.h"
-#include "v8/include/v8.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-namespace api {
-
-// A self-destroyed class for handling save page request.
-class SavePageHandler : public content::DownloadManager::Observer,
-                        public download::DownloadItem::Observer {
- public:
-  using SavePageCallback = base::Callback<void(v8::Local<v8::Value>)>;
-
-  SavePageHandler(content::WebContents* web_contents,
-                  const SavePageCallback& callback);
-  ~SavePageHandler() override;
-
-  bool Handle(const base::FilePath& full_path,
-              const content::SavePageType& save_type);
-
- private:
-  void Destroy(download::DownloadItem* item);
-
-  // content::DownloadManager::Observer:
-  void OnDownloadCreated(content::DownloadManager* manager,
-                         download::DownloadItem* item) override;
-
-  // download::DownloadItem::Observer:
-  void OnDownloadUpdated(download::DownloadItem* item) override;
-
-  content::WebContents* web_contents_;  // weak
-  SavePageCallback callback_;
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_API_SAVE_PAGE_HANDLER_H_
removed in remote
  base   100644 77a936cde02cdbe5d845f9ab5b91abf9afaf359a atom/browser/api/trackable_object.cc
  our    100644 7955ddefcabe1a106d7dc7fd4d821d75a5f72300 atom/browser/api/trackable_object.cc
@@ -1,64 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/api/trackable_object.h"
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "base/bind.h"
-#include "base/supports_user_data.h"
-
-namespace mate {
-
-namespace {
-
-const char* kTrackedObjectKey = "TrackedObjectKey";
-
-class IDUserData : public base::SupportsUserData::Data {
- public:
-  explicit IDUserData(int32_t id) : id_(id) {}
-
-  operator int32_t() const { return id_; }
-
- private:
-  int32_t id_;
-
-  DISALLOW_COPY_AND_ASSIGN(IDUserData);
-};
-
-}  // namespace
-
-TrackableObjectBase::TrackableObjectBase() : weak_factory_(this) {
-  atom::AtomBrowserMainParts::Get()->RegisterDestructionCallback(
-      GetDestroyClosure());
-}
-
-TrackableObjectBase::~TrackableObjectBase() {}
-
-base::OnceClosure TrackableObjectBase::GetDestroyClosure() {
-  return base::BindOnce(&TrackableObjectBase::Destroy,
-                        weak_factory_.GetWeakPtr());
-}
-
-void TrackableObjectBase::Destroy() {
-  delete this;
-}
-
-void TrackableObjectBase::AttachAsUserData(base::SupportsUserData* wrapped) {
-  wrapped->SetUserData(kTrackedObjectKey,
-                       std::make_unique<IDUserData>(weak_map_id_));
-}
-
-// static
-int32_t TrackableObjectBase::GetIDFromWrappedClass(
-    base::SupportsUserData* wrapped) {
-  if (wrapped) {
-    auto* id =
-        static_cast<IDUserData*>(wrapped->GetUserData(kTrackedObjectKey));
-    if (id)
-      return *id;
-  }
-  return 0;
-}
-
-}  // namespace mate
removed in remote
  base   100644 7c4ed03fe052ee3299ed96742577ad68153a135e atom/browser/api/trackable_object.h
  our    100644 f0fd86d344cf34b9cece734cc9f0b25284cfd8d8 atom/browser/api/trackable_object.h
@@ -1,137 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
-#define ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
-
-#include <vector>
-
-#include "atom/browser/api/event_emitter.h"
-#include "atom/common/key_weak_map.h"
-#include "base/bind.h"
-#include "base/memory/weak_ptr.h"
-#include "native_mate/object_template_builder.h"
-
-namespace base {
-class SupportsUserData;
-}
-
-namespace mate {
-
-// Users should use TrackableObject instead.
-class TrackableObjectBase {
- public:
-  TrackableObjectBase();
-
-  // The ID in weak map.
-  int32_t weak_map_id() const { return weak_map_id_; }
-
-  // Wrap TrackableObject into a class that SupportsUserData.
-  void AttachAsUserData(base::SupportsUserData* wrapped);
-
-  // Get the weak_map_id from SupportsUserData.
-  static int32_t GetIDFromWrappedClass(base::SupportsUserData* wrapped);
-
- protected:
-  virtual ~TrackableObjectBase();
-
-  // Returns a closure that can destroy the native class.
-  base::OnceClosure GetDestroyClosure();
-
-  int32_t weak_map_id_ = 0;
-
- private:
-  void Destroy();
-
-  base::WeakPtrFactory<TrackableObjectBase> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrackableObjectBase);
-};
-
-// All instances of TrackableObject will be kept in a weak map and can be got
-// from its ID.
-template <typename T>
-class TrackableObject : public TrackableObjectBase,
-                        public mate::EventEmitter<T> {
- public:
-  // Mark the JS object as destroyed.
-  void MarkDestroyed() {
-    v8::Local<v8::Object> wrapper = Wrappable<T>::GetWrapper();
-    if (!wrapper.IsEmpty()) {
-      wrapper->SetAlignedPointerInInternalField(0, nullptr);
-    }
-  }
-
-  bool IsDestroyed() {
-    v8::Local<v8::Object> wrapper = Wrappable<T>::GetWrapper();
-    return wrapper->InternalFieldCount() == 0 ||
-           wrapper->GetAlignedPointerFromInternalField(0) == nullptr;
-  }
-
-  // Finds out the TrackableObject from its ID in weak map.
-  static T* FromWeakMapID(v8::Isolate* isolate, int32_t id) {
-    if (!weak_map_)
-      return nullptr;
-
-    v8::MaybeLocal<v8::Object> object = weak_map_->Get(isolate, id);
-    if (object.IsEmpty())
-      return nullptr;
-
-    T* self = nullptr;
-    mate::ConvertFromV8(isolate, object.ToLocalChecked(), &self);
-    return self;
-  }
-
-  // Finds out the TrackableObject from the class it wraps.
-  static T* FromWrappedClass(v8::Isolate* isolate,
-                             base::SupportsUserData* wrapped) {
-    int32_t id = GetIDFromWrappedClass(wrapped);
-    if (!id)
-      return nullptr;
-    return FromWeakMapID(isolate, id);
-  }
-
-  // Returns all objects in this class's weak map.
-  static std::vector<v8::Local<v8::Object>> GetAll(v8::Isolate* isolate) {
-    if (weak_map_)
-      return weak_map_->Values(isolate);
-    else
-      return std::vector<v8::Local<v8::Object>>();
-  }
-
-  // Removes this instance from the weak map.
-  void RemoveFromWeakMap() {
-    if (weak_map_ && weak_map_->Has(weak_map_id()))
-      weak_map_->Remove(weak_map_id());
-  }
-
- protected:
-  TrackableObject() { weak_map_id_ = ++next_id_; }
-
-  ~TrackableObject() override { RemoveFromWeakMap(); }
-
-  void InitWith(v8::Isolate* isolate, v8::Local<v8::Object> wrapper) override {
-    WrappableBase::InitWith(isolate, wrapper);
-    if (!weak_map_) {
-      weak_map_ = new atom::KeyWeakMap<int32_t>;
-    }
-    weak_map_->Set(isolate, weak_map_id_, wrapper);
-  }
-
- private:
-  static int32_t next_id_;
-  static atom::KeyWeakMap<int32_t>* weak_map_;  // leaked on purpose
-
-  DISALLOW_COPY_AND_ASSIGN(TrackableObject);
-};
-
-template <typename T>
-int32_t TrackableObject<T>::next_id_ = 0;
-
-template <typename T>
-atom::KeyWeakMap<int32_t>* TrackableObject<T>::weak_map_ = nullptr;
-
-}  // namespace mate
-
-#endif  // ATOM_BROWSER_API_TRACKABLE_OBJECT_H_
removed in remote
  base   100644 63a1ea46b163725ef2fa4797c6f4170f6ec23a99 atom/browser/atom_browser_client.cc
  our    100644 57c4ee582405e6d501ec23940ccb10689ecd64a1 atom/browser/atom_browser_client.cc
@@ -1,550 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_client.h"
-
-#if defined(OS_WIN)
-#include <shlobj.h>
-#endif
-
-#include "atom/browser/api/atom_api_app.h"
-#include "atom/browser/api/atom_api_protocol.h"
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_quota_permission_context.h"
-#include "atom/browser/atom_resource_dispatcher_host_delegate.h"
-#include "atom/browser/atom_speech_recognition_manager_delegate.h"
-#include "atom/browser/child_web_contents_tracker.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/session_preferences.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/google_api_key.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/files/file_util.h"
-#include "base/stl_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/printing/printing_message_filter.h"
-#include "chrome/browser/speech/tts_message_filter.h"
-#include "content/public/browser/browser_ppapi_host.h"
-#include "content/public/browser/client_certificate_delegate.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/resource_dispatcher_host.h"
-#include "content/public/browser/site_instance.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/content_paths.h"
-#include "content/public/common/content_switches.h"
-#include "content/public/common/url_constants.h"
-#include "content/public/common/web_preferences.h"
-#include "net/ssl/ssl_cert_request_info.h"
-#include "ppapi/host/ppapi_host.h"
-#include "services/network/public/cpp/resource_request_body.h"
-#include "ui/base/l10n/l10n_util.h"
-#include "v8/include/v8.h"
-
-#if defined(USE_NSS_CERTS)
-#include "net/ssl/client_cert_store_nss.h"
-#elif defined(OS_WIN)
-#include "net/ssl/client_cert_store_win.h"
-#elif defined(OS_MACOSX)
-#include "net/ssl/client_cert_store_mac.h"
-#elif defined(USE_OPENSSL)
-#include "net/ssl/client_cert_store.h"
-#endif
-
-#if defined(ENABLE_PEPPER_FLASH)
-#include "chrome/browser/renderer_host/pepper/chrome_browser_pepper_host_factory.h"
-#endif  // defined(ENABLE_PEPPER_FLASH)
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// Next navigation should not restart renderer process.
-bool g_suppress_renderer_process_restart = false;
-
-// Custom schemes to be registered to handle service worker.
-std::string g_custom_service_worker_schemes = "";
-
-bool IsSameWebSite(content::BrowserContext* browser_context,
-                   const GURL& src_url,
-                   const GURL& dest_url) {
-  return content::SiteInstance::IsSameWebSite(browser_context, src_url,
-                                              dest_url) ||
-         // `IsSameWebSite` doesn't seem to work for some URIs such as `file:`,
-         // handle these scenarios by comparing only the site as defined by
-         // `GetSiteForURL`.
-         content::SiteInstance::GetSiteForURL(browser_context, dest_url) ==
-             src_url;
-}
-
-}  // namespace
-
-// static
-void AtomBrowserClient::SuppressRendererProcessRestartForOnce() {
-  g_suppress_renderer_process_restart = true;
-}
-
-void AtomBrowserClient::SetCustomServiceWorkerSchemes(
-    const std::vector<std::string>& schemes) {
-  g_custom_service_worker_schemes = base::JoinString(schemes, ",");
-}
-
-AtomBrowserClient::AtomBrowserClient() {}
-
-AtomBrowserClient::~AtomBrowserClient() {}
-
-content::WebContents* AtomBrowserClient::GetWebContentsFromProcessID(
-    int process_id) {
-  // If the process is a pending process, we should use the web contents
-  // for the frame host passed into OverrideSiteInstanceForNavigation.
-  if (base::ContainsKey(pending_processes_, process_id))
-    return pending_processes_[process_id];
-
-  // Certain render process will be created with no associated render view,
-  // for example: ServiceWorker.
-  return WebContentsPreferences::GetWebContentsFromProcessID(process_id);
-}
-
-bool AtomBrowserClient::ShouldCreateNewSiteInstance(
-    content::RenderFrameHost* render_frame_host,
-    content::BrowserContext* browser_context,
-    content::SiteInstance* current_instance,
-    const GURL& url) {
-  if (url.SchemeIs(url::kJavaScriptScheme))
-    // "javacript:" scheme should always use same SiteInstance
-    return false;
-
-  int process_id = current_instance->GetProcess()->GetID();
-  if (!IsRendererSandboxed(process_id)) {
-    if (!RendererUsesNativeWindowOpen(process_id)) {
-      // non-sandboxed renderers without native window.open should always create
-      // a new SiteInstance
-      return true;
-    }
-    auto* web_contents =
-        content::WebContents::FromRenderFrameHost(render_frame_host);
-    if (!ChildWebContentsTracker::IsChildWebContents(web_contents)) {
-      // Root WebContents should always create new process to make sure
-      // native addons are loaded correctly after reload / navigation.
-      // (Non-root WebContents opened by window.open() should try to
-      //  reuse process to allow synchronous cross-window scripting.)
-      return true;
-    }
-  }
-
-  // Create new a SiteInstance if navigating to a different site.
-  auto src_url = current_instance->GetSiteURL();
-  return !IsSameWebSite(browser_context, src_url, url);
-}
-
-void AtomBrowserClient::AddProcessPreferences(
-    int process_id,
-    AtomBrowserClient::ProcessPreferences prefs) {
-  process_preferences_[process_id] = prefs;
-}
-
-void AtomBrowserClient::RemoveProcessPreferences(int process_id) {
-  process_preferences_.erase(process_id);
-}
-
-bool AtomBrowserClient::IsProcessObserved(int process_id) {
-  return process_preferences_.find(process_id) != process_preferences_.end();
-}
-
-bool AtomBrowserClient::IsRendererSandboxed(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.sandbox;
-}
-
-bool AtomBrowserClient::RendererUsesNativeWindowOpen(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.native_window_open;
-}
-
-bool AtomBrowserClient::RendererDisablesPopups(int process_id) {
-  auto it = process_preferences_.find(process_id);
-  return it != process_preferences_.end() && it->second.disable_popups;
-}
-
-void AtomBrowserClient::RenderProcessWillLaunch(
-    content::RenderProcessHost* host,
-    service_manager::mojom::ServiceRequest* service_request) {
-  // When a render process is crashed, it might be reused.
-  int process_id = host->GetID();
-  if (IsProcessObserved(process_id))
-    return;
-
-  host->AddFilter(new printing::PrintingMessageFilter(process_id));
-  host->AddFilter(new TtsMessageFilter(process_id, host->GetBrowserContext()));
-
-  ProcessPreferences prefs;
-  auto* web_preferences =
-      WebContentsPreferences::From(GetWebContentsFromProcessID(process_id));
-  if (web_preferences) {
-    prefs.sandbox = web_preferences->IsEnabled(options::kSandbox);
-    prefs.native_window_open =
-        web_preferences->IsEnabled(options::kNativeWindowOpen);
-    prefs.disable_popups = web_preferences->IsEnabled("disablePopups");
-  }
-  AddProcessPreferences(host->GetID(), prefs);
-  // ensure the ProcessPreferences is removed later
-  host->AddObserver(this);
-}
-
-content::SpeechRecognitionManagerDelegate*
-AtomBrowserClient::CreateSpeechRecognitionManagerDelegate() {
-  return new AtomSpeechRecognitionManagerDelegate;
-}
-
-void AtomBrowserClient::OverrideWebkitPrefs(content::RenderViewHost* host,
-                                            content::WebPreferences* prefs) {
-  prefs->javascript_enabled = true;
-  prefs->web_security_enabled = true;
-  prefs->plugins_enabled = true;
-  prefs->dom_paste_enabled = true;
-  prefs->allow_scripts_to_close_windows = true;
-  prefs->javascript_can_access_clipboard = true;
-  prefs->local_storage_enabled = true;
-  prefs->databases_enabled = true;
-  prefs->application_cache_enabled = true;
-  prefs->allow_universal_access_from_file_urls = true;
-  prefs->allow_file_access_from_file_urls = true;
-  prefs->webgl1_enabled = true;
-  prefs->webgl2_enabled = true;
-  prefs->allow_running_insecure_content = false;
-  prefs->default_minimum_page_scale_factor = 1.f;
-  prefs->default_maximum_page_scale_factor = 1.f;
-  prefs->navigate_on_drag_drop = false;
-
-  // Custom preferences of guest page.
-  auto* web_contents = content::WebContents::FromRenderViewHost(host);
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  if (web_preferences)
-    web_preferences->OverrideWebkitPrefs(prefs);
-}
-
-void AtomBrowserClient::OverrideSiteInstanceForNavigation(
-    content::RenderFrameHost* rfh,
-    content::BrowserContext* browser_context,
-    const GURL& url,
-    bool has_request_started,
-    content::SiteInstance* candidate_instance,
-    content::SiteInstance** new_instance) {
-  if (g_suppress_renderer_process_restart) {
-    g_suppress_renderer_process_restart = false;
-    return;
-  }
-
-  content::SiteInstance* current_instance = rfh->GetSiteInstance();
-  if (!ShouldCreateNewSiteInstance(rfh, browser_context, current_instance, url))
-    return;
-
-  // Do we have an affinity site to manage ?
-  auto* web_contents = content::WebContents::FromRenderFrameHost(rfh);
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  std::string affinity;
-  if (web_preferences &&
-      web_preferences->GetPreference("affinity", &affinity) &&
-      !affinity.empty()) {
-    affinity = base::ToLowerASCII(affinity);
-    auto iter = site_per_affinities.find(affinity);
-    GURL dest_site = content::SiteInstance::GetSiteForURL(browser_context, url);
-    if (iter != site_per_affinities.end() &&
-        IsSameWebSite(browser_context, iter->second->GetSiteURL(), dest_site)) {
-      *new_instance = iter->second;
-    } else {
-      site_per_affinities[affinity] = candidate_instance;
-      *new_instance = candidate_instance;
-      // Remember the original web contents for the pending renderer process.
-      auto* pending_process = candidate_instance->GetProcess();
-      pending_processes_[pending_process->GetID()] = web_contents;
-    }
-  } else {
-    // OverrideSiteInstanceForNavigation will be called more than once during a
-    // navigation (currently twice, on request and when it's about to commit in
-    // the renderer), look at RenderFrameHostManager::GetFrameHostForNavigation.
-    // In the default mode we should resuse the same site instance until the
-    // request commits otherwise it will get destroyed. Currently there is no
-    // unique lifetime tracker for a navigation request during site instance
-    // creation. We check for the state of the request, which should be one of
-    // (WAITING_FOR_RENDERER_RESPONSE, STARTED, RESPONSE_STARTED, FAILED) along
-    // with the availability of a speculative render frame host.
-    if (has_request_started) {
-      *new_instance = current_instance;
-      return;
-    }
-
-    *new_instance = candidate_instance;
-    // Remember the original web contents for the pending renderer process.
-    auto* pending_process = candidate_instance->GetProcess();
-    pending_processes_[pending_process->GetID()] = web_contents;
-  }
-}
-
-void AtomBrowserClient::AppendExtraCommandLineSwitches(
-    base::CommandLine* command_line,
-    int process_id) {
-  // Make sure we're about to launch a known executable
-  {
-    base::FilePath child_path;
-    PathService::Get(content::CHILD_PROCESS_EXE, &child_path);
-
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    CHECK(base::MakeAbsoluteFilePath(command_line->GetProgram()) == child_path);
-  }
-
-  std::string process_type =
-      command_line->GetSwitchValueASCII(::switches::kProcessType);
-  if (process_type != ::switches::kRendererProcess)
-    return;
-
-  // Copy following switches to child process.
-  static const char* const kCommonSwitchNames[] = {switches::kStandardSchemes,
-                                                   switches::kEnableSandbox,
-                                                   switches::kSecureSchemes};
-  command_line->CopySwitchesFrom(*base::CommandLine::ForCurrentProcess(),
-                                 kCommonSwitchNames,
-                                 arraysize(kCommonSwitchNames));
-
-  // The registered service worker schemes.
-  if (!g_custom_service_worker_schemes.empty())
-    command_line->AppendSwitchASCII(switches::kRegisterServiceWorkerSchemes,
-                                    g_custom_service_worker_schemes);
-
-#if defined(OS_WIN)
-  // Append --app-user-model-id.
-  PWSTR current_app_id;
-  if (SUCCEEDED(GetCurrentProcessExplicitAppUserModelID(&current_app_id))) {
-    command_line->AppendSwitchNative(switches::kAppUserModelId, current_app_id);
-    CoTaskMemFree(current_app_id);
-  }
-#endif
-
-  if (delegate_) {
-    auto app_path = static_cast<api::App*>(delegate_)->GetAppPath();
-    command_line->AppendSwitchPath(switches::kAppPath, app_path);
-  }
-
-  content::WebContents* web_contents = GetWebContentsFromProcessID(process_id);
-  if (web_contents) {
-    auto* web_preferences = WebContentsPreferences::From(web_contents);
-    if (web_preferences)
-      web_preferences->AppendCommandLineSwitches(command_line);
-    SessionPreferences::AppendExtraCommandLineSwitches(
-        web_contents->GetBrowserContext(), command_line);
-  }
-}
-
-void AtomBrowserClient::DidCreatePpapiPlugin(content::BrowserPpapiHost* host) {
-#if defined(ENABLE_PEPPER_FLASH)
-  host->GetPpapiHost()->AddHostFactoryFilter(
-      base::WrapUnique(new ChromeBrowserPepperHostFactory(host)));
-#endif
-}
-
-void AtomBrowserClient::GetGeolocationRequestContext(
-    base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)>
-        callback) {
-  auto* io_thread = AtomBrowserMainParts::Get()->io_thread();
-  auto* context = io_thread->GetRequestContext();
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE,
-      base::BindOnce(std::move(callback), base::RetainedRef(context)));
-}
-
-std::string AtomBrowserClient::GetGeolocationApiKey() {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  std::string api_key;
-  if (!env->GetVar("GOOGLE_API_KEY", &api_key))
-    api_key = GOOGLEAPIS_API_KEY;
-  return api_key;
-}
-
-content::QuotaPermissionContext*
-AtomBrowserClient::CreateQuotaPermissionContext() {
-  return new AtomQuotaPermissionContext;
-}
-
-void AtomBrowserClient::AllowCertificateError(
-    content::WebContents* web_contents,
-    int cert_error,
-    const net::SSLInfo& ssl_info,
-    const GURL& request_url,
-    content::ResourceType resource_type,
-    bool strict_enforcement,
-    bool expired_previous_decision,
-    const base::Callback<void(content::CertificateRequestResultType)>&
-        callback) {
-  if (delegate_) {
-    delegate_->AllowCertificateError(
-        web_contents, cert_error, ssl_info, request_url, resource_type,
-        strict_enforcement, expired_previous_decision, callback);
-  }
-}
-
-void AtomBrowserClient::SelectClientCertificate(
-    content::WebContents* web_contents,
-    net::SSLCertRequestInfo* cert_request_info,
-    net::ClientCertIdentityList client_certs,
-    std::unique_ptr<content::ClientCertificateDelegate> delegate) {
-  if (!client_certs.empty() && delegate_) {
-    delegate_->SelectClientCertificate(web_contents, cert_request_info,
-                                       std::move(client_certs),
-                                       std::move(delegate));
-  }
-}
-
-void AtomBrowserClient::ResourceDispatcherHostCreated() {
-  resource_dispatcher_host_delegate_.reset(
-      new AtomResourceDispatcherHostDelegate);
-  content::ResourceDispatcherHost::Get()->SetDelegate(
-      resource_dispatcher_host_delegate_.get());
-}
-
-bool AtomBrowserClient::CanCreateWindow(
-    content::RenderFrameHost* opener,
-    const GURL& opener_url,
-    const GURL& opener_top_level_frame_url,
-    const GURL& source_origin,
-    content::mojom::WindowContainerType container_type,
-    const GURL& target_url,
-    const content::Referrer& referrer,
-    const std::string& frame_name,
-    WindowOpenDisposition disposition,
-    const blink::mojom::WindowFeatures& features,
-    const std::vector<std::string>& additional_features,
-    const scoped_refptr<network::ResourceRequestBody>& body,
-    bool user_gesture,
-    bool opener_suppressed,
-    bool* no_javascript_access) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  int opener_render_process_id = opener->GetProcess()->GetID();
-
-  if (IsRendererSandboxed(opener_render_process_id)) {
-    *no_javascript_access = false;
-    return true;
-  }
-
-  if (RendererUsesNativeWindowOpen(opener_render_process_id)) {
-    if (RendererDisablesPopups(opener_render_process_id)) {
-      // <webview> without allowpopups attribute should return
-      // null from window.open calls
-      return false;
-    } else {
-      *no_javascript_access = false;
-      return true;
-    }
-  }
-
-  if (delegate_) {
-    return delegate_->CanCreateWindow(
-        opener, opener_url, opener_top_level_frame_url, source_origin,
-        container_type, target_url, referrer, frame_name, disposition, features,
-        additional_features, body, user_gesture, opener_suppressed,
-        no_javascript_access);
-  }
-
-  return false;
-}
-
-void AtomBrowserClient::GetAdditionalAllowedSchemesForFileSystem(
-    std::vector<std::string>* additional_schemes) {
-  auto schemes_list = api::GetStandardSchemes();
-  if (!schemes_list.empty())
-    additional_schemes->insert(additional_schemes->end(), schemes_list.begin(),
-                               schemes_list.end());
-  additional_schemes->push_back(content::kChromeDevToolsScheme);
-}
-
-void AtomBrowserClient::SiteInstanceDeleting(
-    content::SiteInstance* site_instance) {
-  // We are storing weak_ptr, is it fundamental to maintain the map up-to-date
-  // when an instance is destroyed.
-  for (auto iter = site_per_affinities.begin();
-       iter != site_per_affinities.end(); ++iter) {
-    if (iter->second == site_instance) {
-      site_per_affinities.erase(iter);
-      break;
-    }
-  }
-}
-
-std::unique_ptr<net::ClientCertStore> AtomBrowserClient::CreateClientCertStore(
-    content::ResourceContext* resource_context) {
-#if defined(USE_NSS_CERTS)
-  return std::make_unique<net::ClientCertStoreNSS>(
-      net::ClientCertStoreNSS::PasswordDelegateFactory());
-#elif defined(OS_WIN)
-  return std::make_unique<net::ClientCertStoreWin>();
-#elif defined(OS_MACOSX)
-  return std::make_unique<net::ClientCertStoreMac>();
-#elif defined(USE_OPENSSL)
-  return std::unique_ptr<net::ClientCertStore>();
-#endif
-}
-
-brightray::BrowserMainParts* AtomBrowserClient::OverrideCreateBrowserMainParts(
-    const content::MainFunctionParams&) {
-  v8::V8::Initialize();  // Init V8 before creating main parts.
-  return new AtomBrowserMainParts;
-}
-
-void AtomBrowserClient::WebNotificationAllowed(
-    int render_process_id,
-    const base::Callback<void(bool, bool)>& callback) {
-  content::WebContents* web_contents =
-      WebContentsPreferences::GetWebContentsFromProcessID(render_process_id);
-  if (!web_contents) {
-    callback.Run(false, false);
-    return;
-  }
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  if (!permission_helper) {
-    callback.Run(false, false);
-    return;
-  }
-  permission_helper->RequestWebNotificationPermission(
-      base::Bind(callback, web_contents->IsAudioMuted()));
-}
-
-void AtomBrowserClient::RenderProcessHostDestroyed(
-    content::RenderProcessHost* host) {
-  int process_id = host->GetID();
-  pending_processes_.erase(process_id);
-  RemoveProcessPreferences(process_id);
-}
-
-void AtomBrowserClient::RenderProcessReady(content::RenderProcessHost* host) {
-  render_process_host_pids_[host->GetID()] = base::GetProcId(host->GetHandle());
-  if (delegate_) {
-    static_cast<api::App*>(delegate_)->RenderProcessReady(host);
-  }
-}
-
-void AtomBrowserClient::RenderProcessExited(content::RenderProcessHost* host,
-                                            base::TerminationStatus status,
-                                            int exit_code) {
-  auto host_pid = render_process_host_pids_.find(host->GetID());
-  if (host_pid != render_process_host_pids_.end()) {
-    if (delegate_) {
-      static_cast<api::App*>(delegate_)->RenderProcessDisconnected(
-          host_pid->second);
-    }
-    render_process_host_pids_.erase(host_pid);
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 8f62887ff6807f18226842d7042dbcef76d8a835 atom/browser/atom_browser_client.h
  our    100644 a0284cf3f72e9cd4292b636948f92bb09b97f0ae atom/browser/atom_browser_client.h
@@ -1,161 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
-#define ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
-
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "brightray/browser/browser_client.h"
-#include "content/public/browser/render_process_host_observer.h"
-#include "net/ssl/client_cert_identity.h"
-
-namespace content {
-class QuotaPermissionContext;
-class ClientCertificateDelegate;
-}  // namespace content
-
-namespace net {
-class SSLCertRequestInfo;
-}
-
-namespace atom {
-
-class AtomResourceDispatcherHostDelegate;
-
-class AtomBrowserClient : public brightray::BrowserClient,
-                          public content::RenderProcessHostObserver {
- public:
-  AtomBrowserClient();
-  ~AtomBrowserClient() override;
-
-  using Delegate = content::ContentBrowserClient;
-  void set_delegate(Delegate* delegate) { delegate_ = delegate; }
-
-  // Returns the WebContents for pending render processes.
-  content::WebContents* GetWebContentsFromProcessID(int process_id);
-
-  // Don't force renderer process to restart for once.
-  static void SuppressRendererProcessRestartForOnce();
-
-  // Custom schemes to be registered to handle service worker.
-  static void SetCustomServiceWorkerSchemes(
-      const std::vector<std::string>& schemes);
-
- protected:
-  // content::ContentBrowserClient:
-  void RenderProcessWillLaunch(
-      content::RenderProcessHost* host,
-      service_manager::mojom::ServiceRequest* service_request) override;
-  content::SpeechRecognitionManagerDelegate*
-  CreateSpeechRecognitionManagerDelegate() override;
-  void OverrideWebkitPrefs(content::RenderViewHost* render_view_host,
-                           content::WebPreferences* prefs) override;
-  void OverrideSiteInstanceForNavigation(
-      content::RenderFrameHost* render_frame_host,
-      content::BrowserContext* browser_context,
-      const GURL& dest_url,
-      bool has_request_started,
-      content::SiteInstance* candidate_instance,
-      content::SiteInstance** new_instance) override;
-  void AppendExtraCommandLineSwitches(base::CommandLine* command_line,
-                                      int child_process_id) override;
-  void DidCreatePpapiPlugin(content::BrowserPpapiHost* browser_host) override;
-  void GetGeolocationRequestContext(
-      base::OnceCallback<void(scoped_refptr<net::URLRequestContextGetter>)>
-          callback) override;
-  std::string GetGeolocationApiKey() override;
-  content::QuotaPermissionContext* CreateQuotaPermissionContext() override;
-  void AllowCertificateError(
-      content::WebContents* web_contents,
-      int cert_error,
-      const net::SSLInfo& ssl_info,
-      const GURL& request_url,
-      content::ResourceType resource_type,
-      bool strict_enforcement,
-      bool expired_previous_decision,
-      const base::Callback<void(content::CertificateRequestResultType)>&
-          callback) override;
-  void SelectClientCertificate(
-      content::WebContents* web_contents,
-      net::SSLCertRequestInfo* cert_request_info,
-      net::ClientCertIdentityList client_certs,
-      std::unique_ptr<content::ClientCertificateDelegate> delegate) override;
-  void ResourceDispatcherHostCreated() override;
-  bool CanCreateWindow(content::RenderFrameHost* opener,
-                       const GURL& opener_url,
-                       const GURL& opener_top_level_frame_url,
-                       const GURL& source_origin,
-                       content::mojom::WindowContainerType container_type,
-                       const GURL& target_url,
-                       const content::Referrer& referrer,
-                       const std::string& frame_name,
-                       WindowOpenDisposition disposition,
-                       const blink::mojom::WindowFeatures& features,
-                       const std::vector<std::string>& additional_features,
-                       const scoped_refptr<network::ResourceRequestBody>& body,
-                       bool user_gesture,
-                       bool opener_suppressed,
-                       bool* no_javascript_access) override;
-  void GetAdditionalAllowedSchemesForFileSystem(
-      std::vector<std::string>* schemes) override;
-  void SiteInstanceDeleting(content::SiteInstance* site_instance) override;
-  std::unique_ptr<net::ClientCertStore> CreateClientCertStore(
-      content::ResourceContext* resource_context) override;
-
-  // brightray::BrowserClient:
-  brightray::BrowserMainParts* OverrideCreateBrowserMainParts(
-      const content::MainFunctionParams&) override;
-  void WebNotificationAllowed(
-      int render_process_id,
-      const base::Callback<void(bool, bool)>& callback) override;
-
-  // content::RenderProcessHostObserver:
-  void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
-  void RenderProcessReady(content::RenderProcessHost* host) override;
-  void RenderProcessExited(content::RenderProcessHost* host,
-                           base::TerminationStatus status,
-                           int exit_code) override;
-
- private:
-  struct ProcessPreferences {
-    bool sandbox = false;
-    bool native_window_open = false;
-    bool disable_popups = false;
-  };
-
-  bool ShouldCreateNewSiteInstance(content::RenderFrameHost* render_frame_host,
-                                   content::BrowserContext* browser_context,
-                                   content::SiteInstance* current_instance,
-                                   const GURL& dest_url);
-  void AddProcessPreferences(int process_id, ProcessPreferences prefs);
-  void RemoveProcessPreferences(int process_id);
-  bool IsProcessObserved(int process_id);
-  bool IsRendererSandboxed(int process_id);
-  bool RendererUsesNativeWindowOpen(int process_id);
-  bool RendererDisablesPopups(int process_id);
-
-  // pending_render_process => web contents.
-  std::map<int, content::WebContents*> pending_processes_;
-
-  std::map<int, ProcessPreferences> process_preferences_;
-  std::map<int, base::ProcessId> render_process_host_pids_;
-
-  // list of site per affinity. weak_ptr to prevent instance locking
-  std::map<std::string, content::SiteInstance*> site_per_affinities;
-
-  std::unique_ptr<AtomResourceDispatcherHostDelegate>
-      resource_dispatcher_host_delegate_;
-
-  Delegate* delegate_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_CLIENT_H_
removed in remote
  base   100644 d6724ff533841932f792488f19a3118dba5f379e atom/browser/atom_browser_context.cc
  our    100644 e036cbc8103f19a034ce386940462f8a23ea6807 atom/browser/atom_browser_context.cc
@@ -1,148 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_context.h"
-
-#include "atom/browser/atom_blob_reader.h"
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/atom_download_manager_delegate.h"
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/request_context_delegate.h"
-#include "atom/browser/special_storage_policy.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/files/file_path.h"
-#include "base/path_service.h"
-#include "base/strings/stringprintf.h"
-#include "chrome/common/chrome_paths.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_registry_simple.h"
-#include "content/browser/blob_storage/chrome_blob_storage_context.h"
-#include "content/public/common/user_agent.h"
-
-namespace atom {
-
-namespace {
-
-std::string RemoveWhitespace(const std::string& str) {
-  std::string trimmed;
-  if (base::RemoveChars(str, " ", &trimmed))
-    return trimmed;
-  else
-    return str;
-}
-
-}  // namespace
-
-AtomBrowserContext::AtomBrowserContext(const std::string& partition,
-                                       bool in_memory,
-                                       const base::DictionaryValue& options)
-    : brightray::BrowserContext(partition, in_memory),
-      url_request_context_getter_(nullptr),
-      storage_policy_(new SpecialStoragePolicy) {
-  // Construct user agent string.
-  Browser* browser = Browser::Get();
-  std::string name = RemoveWhitespace(browser->GetName());
-  std::string user_agent;
-  if (name == ATOM_PRODUCT_NAME) {
-    user_agent = "Chrome/" CHROME_VERSION_STRING " " ATOM_PRODUCT_NAME
-                 "/" ATOM_VERSION_STRING;
-  } else {
-    user_agent = base::StringPrintf(
-        "%s/%s Chrome/%s " ATOM_PRODUCT_NAME "/" ATOM_VERSION_STRING,
-        name.c_str(), browser->GetVersion().c_str(), CHROME_VERSION_STRING);
-  }
-  user_agent_ = content::BuildUserAgentFromProduct(user_agent);
-
-  // Read options.
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-  bool use_cache = !command_line->HasSwitch(switches::kDisableHttpCache);
-  options.GetBoolean("cache", &use_cache);
-
-  request_context_delegate_.reset(new RequestContextDelegate(use_cache));
-
-  // Initialize Pref Registry in brightray.
-  InitPrefs();
-}
-
-AtomBrowserContext::~AtomBrowserContext() {
-  url_request_context_getter_->set_delegate(nullptr);
-}
-
-void AtomBrowserContext::SetUserAgent(const std::string& user_agent) {
-  user_agent_ = user_agent;
-}
-
-content::DownloadManagerDelegate*
-AtomBrowserContext::GetDownloadManagerDelegate() {
-  if (!download_manager_delegate_.get()) {
-    auto* download_manager = content::BrowserContext::GetDownloadManager(this);
-    download_manager_delegate_.reset(
-        new AtomDownloadManagerDelegate(download_manager));
-  }
-  return download_manager_delegate_.get();
-}
-
-content::BrowserPluginGuestManager* AtomBrowserContext::GetGuestManager() {
-  if (!guest_manager_)
-    guest_manager_.reset(new WebViewManager);
-  return guest_manager_.get();
-}
-
-content::PermissionManager* AtomBrowserContext::GetPermissionManager() {
-  if (!permission_manager_.get())
-    permission_manager_.reset(new AtomPermissionManager);
-  return permission_manager_.get();
-}
-
-storage::SpecialStoragePolicy* AtomBrowserContext::GetSpecialStoragePolicy() {
-  return storage_policy_.get();
-}
-
-void AtomBrowserContext::RegisterPrefs(PrefRegistrySimple* pref_registry) {
-  pref_registry->RegisterFilePathPref(prefs::kSelectFileLastDirectory,
-                                      base::FilePath());
-  base::FilePath download_dir;
-  PathService::Get(chrome::DIR_DEFAULT_DOWNLOADS, &download_dir);
-  pref_registry->RegisterFilePathPref(prefs::kDownloadDefaultDirectory,
-                                      download_dir);
-  pref_registry->RegisterDictionaryPref(prefs::kDevToolsFileSystemPaths);
-}
-
-std::string AtomBrowserContext::GetUserAgent() const {
-  return user_agent_;
-}
-
-void AtomBrowserContext::OnMainRequestContextCreated(
-    brightray::URLRequestContextGetter* getter) {
-  getter->set_delegate(request_context_delegate_.get());
-  url_request_context_getter_ = getter;
-}
-
-AtomBlobReader* AtomBrowserContext::GetBlobReader() {
-  if (!blob_reader_.get()) {
-    content::ChromeBlobStorageContext* blob_context =
-        content::ChromeBlobStorageContext::GetFor(this);
-    blob_reader_.reset(new AtomBlobReader(blob_context));
-  }
-  return blob_reader_.get();
-}
-
-// static
-scoped_refptr<AtomBrowserContext> AtomBrowserContext::From(
-    const std::string& partition,
-    bool in_memory,
-    const base::DictionaryValue& options) {
-  auto browser_context = brightray::BrowserContext::Get(partition, in_memory);
-  if (browser_context)
-    return static_cast<AtomBrowserContext*>(browser_context.get());
-
-  return new AtomBrowserContext(partition, in_memory, options);
-}
-
-}  // namespace atom
removed in remote
  base   100644 d959adbc753a6e4c4302f9013ede952c41439c1a atom/browser/atom_browser_context.h
  our    100644 9e6a841ceb8d11069a1a094bf7dbbd3a788918b3 atom/browser/atom_browser_context.h
@@ -1,78 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
-#define ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
-
-#include <string>
-#include <vector>
-
-#include "base/memory/scoped_refptr.h"
-#include "brightray/browser/browser_context.h"
-
-namespace storage {
-class SpecialStoragePolicy;
-}
-
-namespace atom {
-
-class AtomBlobReader;
-class AtomDownloadManagerDelegate;
-class AtomPermissionManager;
-class RequestContextDelegate;
-class SpecialStoragePolicy;
-class WebViewManager;
-
-class AtomBrowserContext : public brightray::BrowserContext {
- public:
-  // Get or create the BrowserContext according to its |partition| and
-  // |in_memory|. The |options| will be passed to constructor when there is no
-  // existing BrowserContext.
-  static scoped_refptr<AtomBrowserContext> From(
-      const std::string& partition,
-      bool in_memory,
-      const base::DictionaryValue& options = base::DictionaryValue());
-
-  void SetUserAgent(const std::string& user_agent);
-  AtomBlobReader* GetBlobReader();
-
-  // content::BrowserContext:
-  content::DownloadManagerDelegate* GetDownloadManagerDelegate() override;
-  content::BrowserPluginGuestManager* GetGuestManager() override;
-  content::PermissionManager* GetPermissionManager() override;
-  storage::SpecialStoragePolicy* GetSpecialStoragePolicy() override;
-
-  // brightray::BrowserContext:
-  void RegisterPrefs(PrefRegistrySimple* pref_registry) override;
-  std::string GetUserAgent() const override;
-  void OnMainRequestContextCreated(
-      brightray::URLRequestContextGetter* getter) override;
-
-  RequestContextDelegate* GetRequestContextDelegate() const {
-    return request_context_delegate_.get();
-  }
-
- protected:
-  AtomBrowserContext(const std::string& partition,
-                     bool in_memory,
-                     const base::DictionaryValue& options);
-  ~AtomBrowserContext() override;
-
- private:
-  brightray::URLRequestContextGetter* url_request_context_getter_;
-
-  std::unique_ptr<AtomDownloadManagerDelegate> download_manager_delegate_;
-  std::unique_ptr<WebViewManager> guest_manager_;
-  std::unique_ptr<AtomPermissionManager> permission_manager_;
-  scoped_refptr<storage::SpecialStoragePolicy> storage_policy_;
-  std::unique_ptr<AtomBlobReader> blob_reader_;
-  std::unique_ptr<RequestContextDelegate> request_context_delegate_;
-  std::string user_agent_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserContext);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_CONTEXT_H_
removed in remote
  base   100644 f45f6492a849486fd009b60f3e07918b76bda34e atom/browser/atom_browser_main_parts.cc
  our    100644 5229b19ca9af7845a3f2f13b7e0913f633b68b1d atom/browser/atom_browser_main_parts.cc
@@ -1,282 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include "atom/browser/api/atom_api_app.h"
-#include "atom/browser/api/trackable_object.h"
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/bridge_task_runner.h"
-#include "atom/browser/browser.h"
-#include "atom/browser/javascript_environment.h"
-#include "atom/browser/node_debugger.h"
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/node_bindings.h"
-#include "base/command_line.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/browser/browser_process.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/common/result_codes.h"
-#include "content/public/common/service_manager_connection.h"
-#include "services/device/public/mojom/constants.mojom.h"
-#include "services/service_manager/public/cpp/connector.h"
-#include "ui/base/idle/idle.h"
-#include "ui/base/l10n/l10n_util.h"
-
-#if defined(USE_X11)
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "ui/events/devices/x11/touch_factory_x11.h"
-#endif
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/browser/atom_web_ui_controller_factory.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-#if defined(OS_MACOSX)
-#include "atom/browser/ui/cocoa/views_delegate_mac.h"
-#else
-#include "brightray/browser/views/views_delegate.h"
-#endif
-
-// Must be included after all other headers.
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace {
-
-template <typename T>
-void Erase(T* container, typename T::iterator iter) {
-  container->erase(iter);
-}
-
-}  // namespace
-
-// static
-AtomBrowserMainParts* AtomBrowserMainParts::self_ = nullptr;
-
-AtomBrowserMainParts::AtomBrowserMainParts()
-    : fake_browser_process_(new BrowserProcess),
-      browser_(new Browser),
-      node_bindings_(NodeBindings::Create(NodeBindings::BROWSER)),
-      atom_bindings_(new AtomBindings(uv_default_loop())),
-      gc_timer_(true, true) {
-  DCHECK(!self_) << "Cannot have two AtomBrowserMainParts";
-  self_ = this;
-  // Register extension scheme as web safe scheme.
-  content::ChildProcessSecurityPolicy::GetInstance()->RegisterWebSafeScheme(
-      "chrome-extension");
-}
-
-AtomBrowserMainParts::~AtomBrowserMainParts() {
-  asar::ClearArchives();
-  // Leak the JavascriptEnvironment on exit.
-  // This is to work around the bug that V8 would be waiting for background
-  // tasks to finish on exit, while somehow it waits forever in Electron, more
-  // about this can be found at
-  // https://github.com/electron/electron/issues/4767. On the other handle there
-  // is actually no need to gracefully shutdown V8 on exit in the main process,
-  // we already ensured all necessary resources get cleaned up, and it would
-  // make quitting faster.
-  ignore_result(js_env_.release());
-}
-
-// static
-AtomBrowserMainParts* AtomBrowserMainParts::Get() {
-  DCHECK(self_);
-  return self_;
-}
-
-bool AtomBrowserMainParts::SetExitCode(int code) {
-  if (!exit_code_)
-    return false;
-
-  *exit_code_ = code;
-  return true;
-}
-
-int AtomBrowserMainParts::GetExitCode() {
-  return exit_code_ != nullptr ? *exit_code_ : 0;
-}
-
-void AtomBrowserMainParts::RegisterDestructionCallback(
-    base::OnceClosure callback) {
-  // The destructors should be called in reversed order, so dependencies between
-  // JavaScript objects can be correctly resolved.
-  // For example WebContentsView => WebContents => Session.
-  destructors_.insert(destructors_.begin(), std::move(callback));
-}
-
-int AtomBrowserMainParts::PreEarlyInitialization() {
-  const int result = brightray::BrowserMainParts::PreEarlyInitialization();
-  if (result != content::RESULT_CODE_NORMAL_EXIT)
-    return result;
-
-#if defined(OS_POSIX)
-  HandleSIGCHLD();
-#endif
-
-  return content::RESULT_CODE_NORMAL_EXIT;
-}
-
-void AtomBrowserMainParts::PostEarlyInitialization() {
-  brightray::BrowserMainParts::PostEarlyInitialization();
-
-  // Temporary set the bridge_task_runner_ as current thread's task runner,
-  // so we can fool gin::PerIsolateData to use it as its task runner, instead
-  // of getting current message loop's task runner, which is null for now.
-  bridge_task_runner_ = new BridgeTaskRunner;
-  base::ThreadTaskRunnerHandle handle(bridge_task_runner_);
-
-  // The ProxyResolverV8 has setup a complete V8 environment, in order to
-  // avoid conflicts we only initialize our V8 environment after that.
-  js_env_.reset(new JavascriptEnvironment);
-
-  node_bindings_->Initialize();
-
-  // Create the global environment.
-  node::Environment* env = node_bindings_->CreateEnvironment(
-      js_env_->context(), js_env_->platform());
-  node_env_.reset(new NodeEnvironment(env));
-
-  // Enable support for v8 inspector
-  node_debugger_.reset(new NodeDebugger(env));
-  node_debugger_->Start(js_env_->platform());
-
-  // Add Electron extended APIs.
-  atom_bindings_->BindTo(js_env_->isolate(), env->process_object());
-
-  // Load everything.
-  node_bindings_->LoadEnvironment(env);
-
-  // Wrap the uv loop with global env.
-  node_bindings_->set_uv_env(env);
-
-  // We already initialized the feature list in
-  // brightray::BrowserMainParts::PreEarlyInitialization(), but
-  // the user JS script would not have had a chance to alter the command-line
-  // switches at that point. Lets reinitialize it here to pick up the
-  // command-line changes.
-  base::FeatureList::ClearInstanceForTesting();
-  brightray::BrowserMainParts::InitializeFeatureList();
-}
-
-int AtomBrowserMainParts::PreCreateThreads() {
-  const int result = brightray::BrowserMainParts::PreCreateThreads();
-  if (!result) {
-    fake_browser_process_->SetApplicationLocale(
-        brightray::BrowserClient::Get()->GetApplicationLocale());
-  }
-
-#if defined(OS_MACOSX)
-  ui::InitIdleMonitor();
-#endif
-
-  return result;
-}
-
-void AtomBrowserMainParts::ToolkitInitialized() {
-  brightray::BrowserMainParts::ToolkitInitialized();
-#if defined(OS_MACOSX)
-  views_delegate_.reset(new ViewsDelegateMac);
-#else
-  views_delegate_.reset(new brightray::ViewsDelegate);
-#endif
-}
-
-void AtomBrowserMainParts::PreMainMessageLoopRun() {
-  js_env_->OnMessageLoopCreated();
-
-  // Run user's main script before most things get initialized, so we can have
-  // a chance to setup everything.
-  node_bindings_->PrepareMessageLoop();
-  node_bindings_->RunMessageLoop();
-
-#if defined(USE_X11)
-  ui::TouchFactory::SetTouchDeviceListFromCommandLine();
-#endif
-
-  // Start idle gc.
-  gc_timer_.Start(FROM_HERE, base::TimeDelta::FromMinutes(1),
-                  base::Bind(&v8::Isolate::LowMemoryNotification,
-                             base::Unretained(js_env_->isolate())));
-
-#if defined(ENABLE_PDF_VIEWER)
-  content::WebUIControllerFactory::RegisterFactory(
-      AtomWebUIControllerFactory::GetInstance());
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-  brightray::BrowserMainParts::PreMainMessageLoopRun();
-  bridge_task_runner_->MessageLoopIsReady();
-  bridge_task_runner_ = nullptr;
-
-#if defined(USE_X11)
-  libgtkui::GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
-#endif
-
-#if !defined(OS_MACOSX)
-  // The corresponding call in macOS is in AtomApplicationDelegate.
-  Browser::Get()->WillFinishLaunching();
-  Browser::Get()->DidFinishLaunching(base::DictionaryValue());
-#endif
-
-  // Notify observers that main thread message loop was initialized.
-  Browser::Get()->PreMainMessageLoopRun();
-}
-
-bool AtomBrowserMainParts::MainMessageLoopRun(int* result_code) {
-  exit_code_ = result_code;
-  return brightray::BrowserMainParts::MainMessageLoopRun(result_code);
-}
-
-void AtomBrowserMainParts::PostMainMessageLoopStart() {
-  brightray::BrowserMainParts::PostMainMessageLoopStart();
-#if defined(OS_POSIX)
-  HandleShutdownSignals();
-#endif
-  // TODO(deepak1556): Enable this optionally based on response
-  // from AtomPermissionManager.
-  GetGeolocationControl()->UserDidOptIntoLocationServices();
-}
-
-void AtomBrowserMainParts::PostMainMessageLoopRun() {
-  brightray::BrowserMainParts::PostMainMessageLoopRun();
-
-  js_env_->OnMessageLoopDestroying();
-
-#if defined(OS_MACOSX)
-  FreeAppDelegate();
-#endif
-
-  // Make sure destruction callbacks are called before message loop is
-  // destroyed, otherwise some objects that need to be deleted on IO thread
-  // won't be freed.
-  // We don't use ranged for loop because iterators are getting invalided when
-  // the callback runs.
-  for (auto iter = destructors_.begin(); iter != destructors_.end();) {
-    base::OnceClosure callback = std::move(*iter);
-    if (!callback.is_null())
-      std::move(callback).Run();
-    ++iter;
-  }
-}
-
-device::mojom::GeolocationControl*
-AtomBrowserMainParts::GetGeolocationControl() {
-  if (geolocation_control_)
-    return geolocation_control_.get();
-
-  auto request = mojo::MakeRequest(&geolocation_control_);
-  if (!content::ServiceManagerConnection::GetForProcess())
-    return geolocation_control_.get();
-
-  service_manager::Connector* connector =
-      content::ServiceManagerConnection::GetForProcess()->GetConnector();
-  connector->BindInterface(device::mojom::kServiceName, std::move(request));
-  return geolocation_control_.get();
-}
-
-}  // namespace atom
removed in remote
  base   100644 e1053a257b9130b6ff16560297a4dc1826ae9ea2 atom/browser/atom_browser_main_parts.h
  our    100644 e73f4581202e6853ffc6a51dbd9116c0ab2097d6 atom/browser/atom_browser_main_parts.h
@@ -1,123 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
-#define ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
-
-#include <list>
-#include <string>
-
-#include "base/callback.h"
-#include "base/timer/timer.h"
-#include "brightray/browser/browser_main_parts.h"
-#include "content/public/browser/browser_context.h"
-#include "services/device/public/mojom/geolocation_control.mojom.h"
-
-class BrowserProcess;
-
-#if defined(TOOLKIT_VIEWS)
-namespace brightray {
-class ViewsDelegate;
-}
-#endif
-
-namespace atom {
-
-class AtomBindings;
-class Browser;
-class JavascriptEnvironment;
-class NodeBindings;
-class NodeDebugger;
-class NodeEnvironment;
-class BridgeTaskRunner;
-
-#if defined(OS_MACOSX)
-class ViewsDelegateMac;
-#endif
-
-class AtomBrowserMainParts : public brightray::BrowserMainParts {
- public:
-  AtomBrowserMainParts();
-  ~AtomBrowserMainParts() override;
-
-  static AtomBrowserMainParts* Get();
-
-  // Sets the exit code, will fail if the message loop is not ready.
-  bool SetExitCode(int code);
-
-  // Gets the exit code
-  int GetExitCode();
-
-  // Register a callback that should be destroyed before JavaScript environment
-  // gets destroyed.
-  // Returns a closure that can be used to remove |callback| from the list.
-  void RegisterDestructionCallback(base::OnceClosure callback);
-
-  Browser* browser() { return browser_.get(); }
-
- protected:
-  // content::BrowserMainParts:
-  int PreEarlyInitialization() override;
-  void PostEarlyInitialization() override;
-  int PreCreateThreads() override;
-  void ToolkitInitialized() override;
-  void PreMainMessageLoopRun() override;
-  bool MainMessageLoopRun(int* result_code) override;
-  void PostMainMessageLoopStart() override;
-  void PostMainMessageLoopRun() override;
-#if defined(OS_MACOSX)
-  void PreMainMessageLoopStart() override;
-#endif
-
- private:
-#if defined(OS_POSIX)
-  // Set signal handlers.
-  void HandleSIGCHLD();
-  void HandleShutdownSignals();
-#endif
-
-#if defined(OS_MACOSX)
-  void FreeAppDelegate();
-#endif
-
-#if defined(OS_MACOSX)
-  std::unique_ptr<ViewsDelegateMac> views_delegate_;
-#else
-  std::unique_ptr<brightray::ViewsDelegate> views_delegate_;
-#endif
-
-  device::mojom::GeolocationControl* GetGeolocationControl();
-
-  // A fake BrowserProcess object that used to feed the source code from chrome.
-  std::unique_ptr<BrowserProcess> fake_browser_process_;
-
-  // The gin::PerIsolateData requires a task runner to create, so we feed it
-  // with a task runner that will post all work to main loop.
-  scoped_refptr<BridgeTaskRunner> bridge_task_runner_;
-
-  // Pointer to exit code.
-  int* exit_code_ = nullptr;
-
-  std::unique_ptr<Browser> browser_;
-  std::unique_ptr<JavascriptEnvironment> js_env_;
-  std::unique_ptr<NodeBindings> node_bindings_;
-  std::unique_ptr<AtomBindings> atom_bindings_;
-  std::unique_ptr<NodeEnvironment> node_env_;
-  std::unique_ptr<NodeDebugger> node_debugger_;
-
-  base::Timer gc_timer_;
-
-  // List of callbacks should be executed before destroying JS env.
-  std::list<base::OnceClosure> destructors_;
-
-  device::mojom::GeolocationControlPtr geolocation_control_;
-
-  static AtomBrowserMainParts* self_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBrowserMainParts);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_BROWSER_MAIN_PARTS_H_
removed in remote
  base   100644 d6e83fd968b0de926d54ab4a795bdb3e1adcfb2f atom/browser/atom_browser_main_parts_mac.mm
  our    100644 17a5681a16a987a3a0d490f15a021bfbfdc88861 atom/browser/atom_browser_main_parts_mac.mm
@@ -1,37 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/atom_application_delegate.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "ui/base/l10n/l10n_util_mac.h"
-
-namespace atom {
-
-void AtomBrowserMainParts::PreMainMessageLoopStart() {
-  // Force the NSApplication subclass to be used.
-  [AtomApplication sharedApplication];
-
-  // Set our own application delegate.
-  AtomApplicationDelegate* delegate = [[AtomApplicationDelegate alloc] init];
-  [NSApp setDelegate:delegate];
-
-  brightray::BrowserMainParts::PreMainMessageLoopStart();
-
-  // Prevent Cocoa from turning command-line arguments into
-  // |-application:openFiles:|, since we already handle them directly.
-  [[NSUserDefaults standardUserDefaults]
-      setObject:@"NO"
-         forKey:@"NSTreatUnknownArgumentsAsOpen"];
-}
-
-void AtomBrowserMainParts::FreeAppDelegate() {
-  [[NSApp delegate] release];
-  [NSApp setDelegate:nil];
-}
-
-}  // namespace atom
removed in remote
  base   100644 2a0dddc474837972c702399da259a8b44bb01369 atom/browser/atom_browser_main_parts_posix.cc
  our    100644 d79e60049f4db41b7b992c412cf271d461227115 atom/browser/atom_browser_main_parts_posix.cc
@@ -1,222 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Most code came from: chrome/browser/chrome_browser_main_posix.cc.
-
-#include "atom/browser/atom_browser_main_parts.h"
-
-#include <errno.h>
-#include <limits.h>
-#include <pthread.h>
-#include <signal.h>
-#include <sys/resource.h>
-#include <unistd.h>
-
-#include "atom/browser/browser.h"
-#include "base/posix/eintr_wrapper.h"
-#include "content/public/browser/browser_thread.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// See comment in |PreEarlyInitialization()|, where sigaction is called.
-void SIGCHLDHandler(int signal) {}
-
-// The OSX fork() implementation can crash in the child process before
-// fork() returns.  In that case, the shutdown pipe will still be
-// shared with the parent process.  To prevent child crashes from
-// causing parent shutdowns, |g_pipe_pid| is the pid for the process
-// which registered |g_shutdown_pipe_write_fd|.
-// See <http://crbug.com/175341>.
-pid_t g_pipe_pid = -1;
-int g_shutdown_pipe_write_fd = -1;
-int g_shutdown_pipe_read_fd = -1;
-
-// Common code between SIG{HUP, INT, TERM}Handler.
-void GracefulShutdownHandler(int signal) {
-  // Reinstall the default handler.  We had one shot at graceful shutdown.
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIG_DFL;
-  RAW_CHECK(sigaction(signal, &action, nullptr) == 0);
-
-  RAW_CHECK(g_pipe_pid == getpid());
-  RAW_CHECK(g_shutdown_pipe_write_fd != -1);
-  RAW_CHECK(g_shutdown_pipe_read_fd != -1);
-  size_t bytes_written = 0;
-  do {
-    int rv = HANDLE_EINTR(
-        write(g_shutdown_pipe_write_fd,
-              reinterpret_cast<const char*>(&signal) + bytes_written,
-              sizeof(signal) - bytes_written));
-    RAW_CHECK(rv >= 0);
-    bytes_written += rv;
-  } while (bytes_written < sizeof(signal));
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGHUPHandler(int signal) {
-  RAW_CHECK(signal == SIGHUP);
-  GracefulShutdownHandler(signal);
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGINTHandler(int signal) {
-  RAW_CHECK(signal == SIGINT);
-  GracefulShutdownHandler(signal);
-}
-
-// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
-void SIGTERMHandler(int signal) {
-  RAW_CHECK(signal == SIGTERM);
-  GracefulShutdownHandler(signal);
-}
-
-class ShutdownDetector : public base::PlatformThread::Delegate {
- public:
-  explicit ShutdownDetector(int shutdown_fd);
-
-  void ThreadMain() override;
-
- private:
-  const int shutdown_fd_;
-
-  DISALLOW_COPY_AND_ASSIGN(ShutdownDetector);
-};
-
-ShutdownDetector::ShutdownDetector(int shutdown_fd)
-    : shutdown_fd_(shutdown_fd) {
-  CHECK_NE(shutdown_fd_, -1);
-}
-
-// These functions are used to help us diagnose crash dumps that happen
-// during the shutdown process.
-NOINLINE void ShutdownFDReadError() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-NOINLINE void ShutdownFDClosedError() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-NOINLINE void ExitPosted() {
-  // Ensure function isn't optimized away.
-  asm("");
-  sleep(UINT_MAX);
-}
-
-void ShutdownDetector::ThreadMain() {
-  base::PlatformThread::SetName("CrShutdownDetector");
-
-  int signal;
-  size_t bytes_read = 0;
-  do {
-    ssize_t ret = HANDLE_EINTR(
-        read(shutdown_fd_, reinterpret_cast<char*>(&signal) + bytes_read,
-             sizeof(signal) - bytes_read));
-    if (ret < 0) {
-      NOTREACHED() << "Unexpected error: " << strerror(errno);
-      ShutdownFDReadError();
-      break;
-    } else if (ret == 0) {
-      NOTREACHED() << "Unexpected closure of shutdown pipe.";
-      ShutdownFDClosedError();
-      break;
-    }
-    bytes_read += ret;
-  } while (bytes_read < sizeof(signal));
-  VLOG(1) << "Handling shutdown for signal " << signal << ".";
-  base::Closure task =
-      base::Bind(&Browser::Quit, base::Unretained(Browser::Get()));
-
-  if (!BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, task)) {
-    // Without a UI thread to post the exit task to, there aren't many
-    // options.  Raise the signal again.  The default handler will pick it up
-    // and cause an ungraceful exit.
-    RAW_LOG(WARNING, "No UI thread, exiting ungracefully.");
-    kill(getpid(), signal);
-
-    // The signal may be handled on another thread.  Give that a chance to
-    // happen.
-    sleep(3);
-
-    // We really should be dead by now.  For whatever reason, we're not. Exit
-    // immediately, with the exit status set to the signal number with bit 8
-    // set.  On the systems that we care about, this exit status is what is
-    // normally used to indicate an exit by this signal's default handler.
-    // This mechanism isn't a de jure standard, but even in the worst case, it
-    // should at least result in an immediate exit.
-    RAW_LOG(WARNING, "Still here, exiting really ungracefully.");
-    _exit(signal | (1 << 7));
-  }
-  ExitPosted();
-}
-
-}  // namespace
-
-void AtomBrowserMainParts::HandleSIGCHLD() {
-  // We need to accept SIGCHLD, even though our handler is a no-op because
-  // otherwise we cannot wait on children. (According to POSIX 2001.)
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIGCHLDHandler;
-  CHECK_EQ(sigaction(SIGCHLD, &action, nullptr), 0);
-}
-
-void AtomBrowserMainParts::HandleShutdownSignals() {
-  int pipefd[2];
-  int ret = pipe(pipefd);
-  if (ret < 0) {
-    PLOG(DFATAL) << "Failed to create pipe";
-  } else {
-    g_pipe_pid = getpid();
-    g_shutdown_pipe_read_fd = pipefd[0];
-    g_shutdown_pipe_write_fd = pipefd[1];
-#if !defined(ADDRESS_SANITIZER) && !defined(KEEP_SHADOW_STACKS)
-    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
-#else
-    // ASan instrumentation and -finstrument-functions (used for keeping the
-    // shadow stacks) bloat the stack frames, so we need to increase the stack
-    // size to avoid hitting the guard page.
-    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
-#endif
-    // TODO(viettrungluu,willchan): crbug.com/29675 - This currently leaks, so
-    // if you change this, you'll probably need to change the suppression.
-    if (!base::PlatformThread::CreateNonJoinable(
-            kShutdownDetectorThreadStackSize,
-            new ShutdownDetector(g_shutdown_pipe_read_fd))) {
-      LOG(DFATAL) << "Failed to create shutdown detector task.";
-    }
-  }
-  // Setup signal handlers for shutdown AFTER shutdown pipe is setup because
-  // it may be called right away after handler is set.
-
-  // If adding to this list of signal handlers, note the new signal probably
-  // needs to be reset in child processes. See
-  // base/process_util_posix.cc:LaunchProcess.
-
-  // We need to handle SIGTERM, because that is how many POSIX-based distros ask
-  // processes to quit gracefully at shutdown time.
-  struct sigaction action;
-  memset(&action, 0, sizeof(action));
-  action.sa_handler = SIGTERMHandler;
-  CHECK_EQ(sigaction(SIGTERM, &action, nullptr), 0);
-  // Also handle SIGINT - when the user terminates the browser via Ctrl+C. If
-  // the browser process is being debugged, GDB will catch the SIGINT first.
-  action.sa_handler = SIGINTHandler;
-  CHECK_EQ(sigaction(SIGINT, &action, nullptr), 0);
-  // And SIGHUP, for when the terminal disappears. On shutdown, many Linux
-  // distros send SIGHUP, SIGTERM, and then SIGKILL.
-  action.sa_handler = SIGHUPHandler;
-  CHECK_EQ(sigaction(SIGHUP, &action, nullptr), 0);
-}
-
-}  // namespace atom
removed in remote
  base   100644 16c0cf708b856286ed177b976141b8c87ad9a403 atom/browser/atom_download_manager_delegate.cc
  our    100644 83276affb18df31ebe64fad6c53960baad498582 atom/browser/atom_download_manager_delegate.cc
@@ -1,189 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_download_manager_delegate.h"
-
-#include <string>
-
-#include "atom/browser/api/atom_api_download_item.h"
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/options_switches.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "base/task_scheduler/post_task.h"
-#include "chrome/common/pref_names.h"
-#include "components/download/public/common/download_danger_type.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_item_utils.h"
-#include "content/public/browser/download_manager.h"
-#include "net/base/filename_util.h"
-
-namespace atom {
-
-namespace {
-
-// Generate default file path to save the download.
-base::FilePath CreateDownloadPath(const GURL& url,
-                                  const std::string& content_disposition,
-                                  const std::string& suggested_filename,
-                                  const std::string& mime_type,
-                                  const base::FilePath& default_download_path) {
-  auto generated_name =
-      net::GenerateFileName(url, content_disposition, std::string(),
-                            suggested_filename, mime_type, "download");
-
-  if (!base::PathExists(default_download_path))
-    base::CreateDirectory(default_download_path);
-
-  return default_download_path.Append(generated_name);
-}
-
-}  // namespace
-
-AtomDownloadManagerDelegate::AtomDownloadManagerDelegate(
-    content::DownloadManager* manager)
-    : download_manager_(manager), weak_ptr_factory_(this) {}
-
-AtomDownloadManagerDelegate::~AtomDownloadManagerDelegate() {
-  if (download_manager_) {
-    DCHECK_EQ(static_cast<content::DownloadManagerDelegate*>(this),
-              download_manager_->GetDelegate());
-    download_manager_->SetDelegate(nullptr);
-    download_manager_ = nullptr;
-  }
-}
-
-void AtomDownloadManagerDelegate::GetItemSavePath(download::DownloadItem* item,
-                                                  base::FilePath* path) {
-  v8::Isolate* isolate = v8::Isolate::GetCurrent();
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  api::DownloadItem* download =
-      api::DownloadItem::FromWrappedClass(isolate, item);
-  if (download)
-    *path = download->GetSavePath();
-}
-
-void AtomDownloadManagerDelegate::OnDownloadPathGenerated(
-    uint32_t download_id,
-    const content::DownloadTargetCallback& callback,
-    const base::FilePath& default_path) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  auto* item = download_manager_->GetDownload(download_id);
-  if (!item)
-    return;
-
-  NativeWindow* window = nullptr;
-  content::WebContents* web_contents =
-      content::DownloadItemUtils::GetWebContents(item);
-  auto* relay =
-      web_contents ? NativeWindowRelay::FromWebContents(web_contents) : nullptr;
-  if (relay)
-    window = relay->window.get();
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  bool offscreen =
-      !web_preferences || web_preferences->IsEnabled(options::kOffscreen);
-
-  base::FilePath path;
-  GetItemSavePath(item, &path);
-  // Show save dialog if save path was not set already on item
-  file_dialog::DialogSettings settings;
-  settings.parent_window = window;
-  settings.force_detached = offscreen;
-  settings.title = item->GetURL().spec();
-  settings.default_path = default_path;
-  if (path.empty() && file_dialog::ShowSaveDialog(settings, &path)) {
-    // Remember the last selected download directory.
-    AtomBrowserContext* browser_context = static_cast<AtomBrowserContext*>(
-        download_manager_->GetBrowserContext());
-    browser_context->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
-                                          path.DirName());
-
-    v8::Isolate* isolate = v8::Isolate::GetCurrent();
-    v8::Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    api::DownloadItem* download_item =
-        api::DownloadItem::FromWrappedClass(isolate, item);
-    if (download_item)
-      download_item->SetSavePath(path);
-  }
-
-  // Running the DownloadTargetCallback with an empty FilePath signals that the
-  // download should be cancelled.
-  // If user cancels the file save dialog, run the callback with empty FilePath.
-  callback.Run(path, download::DownloadItem::TARGET_DISPOSITION_PROMPT,
-               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS, path,
-               path.empty() ? download::DOWNLOAD_INTERRUPT_REASON_USER_CANCELED
-                            : download::DOWNLOAD_INTERRUPT_REASON_NONE);
-}
-
-void AtomDownloadManagerDelegate::Shutdown() {
-  weak_ptr_factory_.InvalidateWeakPtrs();
-  download_manager_ = nullptr;
-}
-
-bool AtomDownloadManagerDelegate::DetermineDownloadTarget(
-    download::DownloadItem* download,
-    const content::DownloadTargetCallback& callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  if (!download->GetForcedFilePath().empty()) {
-    callback.Run(download->GetForcedFilePath(),
-                 download::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
-                 download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-                 download->GetForcedFilePath(),
-                 download::DOWNLOAD_INTERRUPT_REASON_NONE);
-    return true;
-  }
-
-  // Try to get the save path from JS wrapper.
-  base::FilePath save_path;
-  GetItemSavePath(download, &save_path);
-  if (!save_path.empty()) {
-    callback.Run(save_path,
-                 download::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
-                 download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
-                 save_path, download::DOWNLOAD_INTERRUPT_REASON_NONE);
-    return true;
-  }
-
-  AtomBrowserContext* browser_context =
-      static_cast<AtomBrowserContext*>(download_manager_->GetBrowserContext());
-  base::FilePath default_download_path =
-      browser_context->prefs()->GetFilePath(prefs::kDownloadDefaultDirectory);
-
-  base::PostTaskWithTraitsAndReplyWithResult(
-      FROM_HERE,
-      {base::MayBlock(), base::TaskPriority::BACKGROUND,
-       base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN},
-      base::BindOnce(&CreateDownloadPath, download->GetURL(),
-                     download->GetContentDisposition(),
-                     download->GetSuggestedFilename(), download->GetMimeType(),
-                     default_download_path),
-      base::BindOnce(&AtomDownloadManagerDelegate::OnDownloadPathGenerated,
-                     weak_ptr_factory_.GetWeakPtr(), download->GetId(),
-                     callback));
-  return true;
-}
-
-bool AtomDownloadManagerDelegate::ShouldOpenDownload(
-    download::DownloadItem* download,
-    const content::DownloadOpenDelayedCallback& callback) {
-  return true;
-}
-
-void AtomDownloadManagerDelegate::GetNextId(
-    const content::DownloadIdCallback& callback) {
-  static uint32_t next_id = download::DownloadItem::kInvalidId + 1;
-  callback.Run(next_id++);
-}
-
-}  // namespace atom
removed in remote
  base   100644 5ea3d50d5aee391e9eb8b975055e81e7b9a757b6 atom/browser/atom_download_manager_delegate.h
  our    100644 f1cc1190d4bfe26a1a906b1552c9ab46d71e5e50 atom/browser/atom_download_manager_delegate.h
@@ -1,53 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
-
-#include <string>
-
-#include "base/memory/weak_ptr.h"
-#include "content/public/browser/download_manager_delegate.h"
-
-namespace content {
-class DownloadManager;
-}
-
-namespace atom {
-
-class AtomDownloadManagerDelegate : public content::DownloadManagerDelegate {
- public:
-  using CreateDownloadPathCallback =
-      base::Callback<void(const base::FilePath&)>;
-
-  explicit AtomDownloadManagerDelegate(content::DownloadManager* manager);
-  ~AtomDownloadManagerDelegate() override;
-
-  void OnDownloadPathGenerated(uint32_t download_id,
-                               const content::DownloadTargetCallback& callback,
-                               const base::FilePath& default_path);
-
-  // content::DownloadManagerDelegate:
-  void Shutdown() override;
-  bool DetermineDownloadTarget(
-      download::DownloadItem* download,
-      const content::DownloadTargetCallback& callback) override;
-  bool ShouldOpenDownload(
-      download::DownloadItem* download,
-      const content::DownloadOpenDelayedCallback& callback) override;
-  void GetNextId(const content::DownloadIdCallback& callback) override;
-
- private:
-  // Get the save path set on the associated api::DownloadItem object
-  void GetItemSavePath(download::DownloadItem* item, base::FilePath* path);
-
-  content::DownloadManager* download_manager_;
-  base::WeakPtrFactory<AtomDownloadManagerDelegate> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomDownloadManagerDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_DOWNLOAD_MANAGER_DELEGATE_H_
removed in remote
  base   100644 c21d1fb1181622c999e0072ef990465a35072aea atom/browser/atom_javascript_dialog_manager.cc
  our    100644 25fc326ebac3f2a5beb9199194067dae12c8229b atom/browser/atom_javascript_dialog_manager.cc
@@ -1,110 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_javascript_dialog_manager.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/message_box.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/options_switches.h"
-#include "base/bind.h"
-#include "base/strings/utf_string_conversions.h"
-#include "ui/gfx/image/image_skia.h"
-
-using content::JavaScriptDialogType;
-
-namespace atom {
-
-namespace {
-
-constexpr int kUserWantsNoMoreDialogs = -1;
-
-}  // namespace
-
-AtomJavaScriptDialogManager::AtomJavaScriptDialogManager(
-    api::WebContents* api_web_contents)
-    : api_web_contents_(api_web_contents) {}
-AtomJavaScriptDialogManager::~AtomJavaScriptDialogManager() = default;
-
-void AtomJavaScriptDialogManager::RunJavaScriptDialog(
-    content::WebContents* web_contents,
-    content::RenderFrameHost* rfh,
-    JavaScriptDialogType dialog_type,
-    const base::string16& message_text,
-    const base::string16& default_prompt_text,
-    DialogClosedCallback callback,
-    bool* did_suppress_message) {
-  auto origin_url = rfh->GetLastCommittedURL();
-  const std::string& origin = origin_url.GetOrigin().spec();
-  if (origin_counts_[origin] == kUserWantsNoMoreDialogs) {
-    return std::move(callback).Run(false, base::string16());
-  }
-
-  if (dialog_type != JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_ALERT &&
-      dialog_type != JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_CONFIRM) {
-    std::move(callback).Run(false, base::string16());
-    return;
-  }
-
-  std::vector<std::string> buttons = {"OK"};
-  if (dialog_type == JavaScriptDialogType::JAVASCRIPT_DIALOG_TYPE_CONFIRM) {
-    buttons.push_back("Cancel");
-  }
-
-  origin_counts_[origin]++;
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  std::string checkbox;
-  if (origin_counts_[origin] > 1 && web_preferences &&
-      web_preferences->IsEnabled("safeDialogs") &&
-      !web_preferences->GetPreference("safeDialogsMessage", &checkbox)) {
-    checkbox = "Prevent this app from creating additional dialogs";
-  }
-
-  // Don't set parent for offscreen window.
-  NativeWindow* window = nullptr;
-  if (web_preferences && !web_preferences->IsEnabled(options::kOffscreen)) {
-    auto* relay = NativeWindowRelay::FromWebContents(web_contents);
-    if (relay)
-      window = relay->window.get();
-  }
-
-  atom::ShowMessageBox(
-      window, atom::MessageBoxType::MESSAGE_BOX_TYPE_NONE, buttons, -1, 0,
-      atom::MessageBoxOptions::MESSAGE_BOX_NONE, "",
-      base::UTF16ToUTF8(message_text), "", checkbox, false, gfx::ImageSkia(),
-      base::Bind(&AtomJavaScriptDialogManager::OnMessageBoxCallback,
-                 base::Unretained(this), base::Passed(std::move(callback)),
-                 origin));
-}
-
-void AtomJavaScriptDialogManager::RunBeforeUnloadDialog(
-    content::WebContents* web_contents,
-    content::RenderFrameHost* rfh,
-    bool is_reload,
-    DialogClosedCallback callback) {
-  bool default_prevented = api_web_contents_->Emit("will-prevent-unload");
-  std::move(callback).Run(default_prevented, base::string16());
-  return;
-}
-
-void AtomJavaScriptDialogManager::CancelDialogs(
-    content::WebContents* web_contents,
-    bool reset_state) {}
-
-void AtomJavaScriptDialogManager::OnMessageBoxCallback(
-    DialogClosedCallback callback,
-    const std::string& origin,
-    int code,
-    bool checkbox_checked) {
-  if (checkbox_checked)
-    origin_counts_[origin] = kUserWantsNoMoreDialogs;
-  std::move(callback).Run(code == 0, base::string16());
-}
-
-}  // namespace atom
removed in remote
  base   100644 c0a0dccf0fa9a3fa1a7e7504f81a9f9eef6b0fb9 atom/browser/atom_javascript_dialog_manager.h
  our    100644 2996b5d206ede6b19769ca0be224a59a6082a7bb atom/browser/atom_javascript_dialog_manager.h
@@ -1,51 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
-#define ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
-
-#include <map>
-#include <string>
-
-#include "content/public/browser/javascript_dialog_manager.h"
-
-namespace atom {
-
-namespace api {
-class WebContents;
-}
-
-class AtomJavaScriptDialogManager : public content::JavaScriptDialogManager {
- public:
-  explicit AtomJavaScriptDialogManager(api::WebContents* api_web_contents);
-  ~AtomJavaScriptDialogManager() override;
-
-  // content::JavaScriptDialogManager implementations.
-  void RunJavaScriptDialog(content::WebContents* web_contents,
-                           content::RenderFrameHost* rfh,
-                           content::JavaScriptDialogType dialog_type,
-                           const base::string16& message_text,
-                           const base::string16& default_prompt_text,
-                           DialogClosedCallback callback,
-                           bool* did_suppress_message) override;
-  void RunBeforeUnloadDialog(content::WebContents* web_contents,
-                             content::RenderFrameHost* rfh,
-                             bool is_reload,
-                             DialogClosedCallback callback) override;
-  void CancelDialogs(content::WebContents* web_contents,
-                     bool reset_state) override;
-
- private:
-  void OnMessageBoxCallback(DialogClosedCallback callback,
-                            const std::string& origin,
-                            int code,
-                            bool checkbox_checked);
-
-  api::WebContents* api_web_contents_;
-  std::map<std::string, int> origin_counts_;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_JAVASCRIPT_DIALOG_MANAGER_H_
removed in remote
  base   100644 f7523c07ff8333e2582c6a492f154dd93982b489 atom/browser/atom_permission_manager.cc
  our    100644 218404434142cf1b0ab29610e873782712e3a876 atom/browser/atom_permission_manager.cc
@@ -1,212 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_permission_manager.h"
-
-#include <vector>
-
-#include "atom/browser/atom_browser_client.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/permission_type.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-namespace {
-
-bool WebContentsDestroyed(int process_id) {
-  content::WebContents* web_contents =
-      static_cast<AtomBrowserClient*>(AtomBrowserClient::Get())
-          ->GetWebContentsFromProcessID(process_id);
-  if (!web_contents)
-    return true;
-  return web_contents->IsBeingDestroyed();
-}
-
-void PermissionRequestResponseCallbackWrapper(
-    const AtomPermissionManager::StatusCallback& callback,
-    const std::vector<blink::mojom::PermissionStatus>& vector) {
-  callback.Run(vector[0]);
-}
-
-}  // namespace
-
-class AtomPermissionManager::PendingRequest {
- public:
-  PendingRequest(content::RenderFrameHost* render_frame_host,
-                 const std::vector<content::PermissionType>& permissions,
-                 const StatusesCallback& callback)
-      : render_process_id_(render_frame_host->GetProcess()->GetID()),
-        callback_(callback),
-        results_(permissions.size(), blink::mojom::PermissionStatus::DENIED),
-        remaining_results_(permissions.size()) {}
-
-  void SetPermissionStatus(int permission_id,
-                           blink::mojom::PermissionStatus status) {
-    DCHECK(!IsComplete());
-
-    results_[permission_id] = status;
-    --remaining_results_;
-  }
-
-  int render_process_id() const { return render_process_id_; }
-
-  bool IsComplete() const { return remaining_results_ == 0; }
-
-  void RunCallback() const { callback_.Run(results_); }
-
- private:
-  int render_process_id_;
-  const StatusesCallback callback_;
-  std::vector<blink::mojom::PermissionStatus> results_;
-  size_t remaining_results_;
-};
-
-AtomPermissionManager::AtomPermissionManager() {}
-
-AtomPermissionManager::~AtomPermissionManager() {}
-
-void AtomPermissionManager::SetPermissionRequestHandler(
-    const RequestHandler& handler) {
-  if (handler.is_null() && !pending_requests_.IsEmpty()) {
-    for (PendingRequestsMap::const_iterator iter(&pending_requests_);
-         !iter.IsAtEnd(); iter.Advance()) {
-      auto* request = iter.GetCurrentValue();
-      if (!WebContentsDestroyed(request->render_process_id()))
-        request->RunCallback();
-    }
-    pending_requests_.Clear();
-  }
-  request_handler_ = handler;
-}
-
-int AtomPermissionManager::RequestPermission(
-    content::PermissionType permission,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const StatusCallback& response_callback) {
-  return RequestPermissionWithDetails(permission, render_frame_host,
-                                      requesting_origin, user_gesture, nullptr,
-                                      response_callback);
-}
-
-int AtomPermissionManager::RequestPermissionWithDetails(
-    content::PermissionType permission,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const base::DictionaryValue* details,
-    const StatusCallback& response_callback) {
-  return RequestPermissionsWithDetails(
-      std::vector<content::PermissionType>(1, permission), render_frame_host,
-      requesting_origin, user_gesture, details,
-      base::Bind(&PermissionRequestResponseCallbackWrapper, response_callback));
-}
-
-int AtomPermissionManager::RequestPermissions(
-    const std::vector<content::PermissionType>& permissions,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const StatusesCallback& response_callback) {
-  return RequestPermissionsWithDetails(permissions, render_frame_host,
-                                       requesting_origin, user_gesture, nullptr,
-                                       response_callback);
-}
-
-int AtomPermissionManager::RequestPermissionsWithDetails(
-    const std::vector<content::PermissionType>& permissions,
-    content::RenderFrameHost* render_frame_host,
-    const GURL& requesting_origin,
-    bool user_gesture,
-    const base::DictionaryValue* details,
-    const StatusesCallback& response_callback) {
-  if (permissions.empty()) {
-    response_callback.Run(std::vector<blink::mojom::PermissionStatus>());
-    return kNoPendingOperation;
-  }
-
-  if (request_handler_.is_null()) {
-    std::vector<blink::mojom::PermissionStatus> statuses;
-    for (auto permission : permissions) {
-      if (permission == content::PermissionType::MIDI_SYSEX) {
-        content::ChildProcessSecurityPolicy::GetInstance()
-            ->GrantSendMidiSysExMessage(
-                render_frame_host->GetProcess()->GetID());
-      }
-      statuses.push_back(blink::mojom::PermissionStatus::GRANTED);
-    }
-    response_callback.Run(statuses);
-    return kNoPendingOperation;
-  }
-
-  auto* web_contents =
-      content::WebContents::FromRenderFrameHost(render_frame_host);
-  int request_id = pending_requests_.Add(std::make_unique<PendingRequest>(
-      render_frame_host, permissions, response_callback));
-
-  for (size_t i = 0; i < permissions.size(); ++i) {
-    auto permission = permissions[i];
-    if (permission == content::PermissionType::MIDI_SYSEX) {
-      content::ChildProcessSecurityPolicy::GetInstance()
-          ->GrantSendMidiSysExMessage(render_frame_host->GetProcess()->GetID());
-    }
-    const auto callback =
-        base::Bind(&AtomPermissionManager::OnPermissionResponse,
-                   base::Unretained(this), request_id, i);
-    if (details == nullptr) {
-      request_handler_.Run(web_contents, permission, callback,
-                           base::DictionaryValue());
-    } else {
-      request_handler_.Run(web_contents, permission, callback, *details);
-    }
-  }
-
-  return request_id;
-}
-
-void AtomPermissionManager::OnPermissionResponse(
-    int request_id,
-    int permission_id,
-    blink::mojom::PermissionStatus status) {
-  auto* pending_request = pending_requests_.Lookup(request_id);
-  if (!pending_request)
-    return;
-
-  pending_request->SetPermissionStatus(permission_id, status);
-  if (pending_request->IsComplete()) {
-    pending_request->RunCallback();
-    pending_requests_.Remove(request_id);
-  }
-}
-
-
-void AtomPermissionManager::ResetPermission(content::PermissionType permission,
-                                            const GURL& requesting_origin,
-                                            const GURL& embedding_origin) {}
-
-blink::mojom::PermissionStatus AtomPermissionManager::GetPermissionStatus(
-    content::PermissionType permission,
-    const GURL& requesting_origin,
-    const GURL& embedding_origin) {
-  return blink::mojom::PermissionStatus::GRANTED;
-}
-
-int AtomPermissionManager::SubscribePermissionStatusChange(
-    content::PermissionType permission,
-    const GURL& requesting_origin,
-    const GURL& embedding_origin,
-    const StatusCallback& callback) {
-  return -1;
-}
-
-void AtomPermissionManager::UnsubscribePermissionStatusChange(
-    int subscription_id) {}
-
-}  // namespace atom
removed in remote
  base   100644 e16893fd8bb5d9357f2648626f29d2d212db4048 atom/browser/atom_permission_manager.h
  our    100644 de23837330535539c2ab93a2bba4796be3f36e1e atom/browser/atom_permission_manager.h
@@ -1,104 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
-#define ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
-
-#include <map>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/containers/id_map.h"
-#include "base/values.h"
-#include "content/public/browser/permission_manager.h"
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-class AtomPermissionManager : public content::PermissionManager {
- public:
-  AtomPermissionManager();
-  ~AtomPermissionManager() override;
-
-  using StatusCallback = base::Callback<void(blink::mojom::PermissionStatus)>;
-  using StatusesCallback =
-      base::Callback<void(const std::vector<blink::mojom::PermissionStatus>&)>;
-  using RequestHandler = base::Callback<void(content::WebContents*,
-                                             content::PermissionType,
-                                             const StatusCallback&,
-                                             const base::DictionaryValue&)>;
-
-  // Handler to dispatch permission requests in JS.
-  void SetPermissionRequestHandler(const RequestHandler& handler);
-
-  // content::PermissionManager:
-  int RequestPermission(
-      content::PermissionType permission,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback)
-      override;
-  int RequestPermissionWithDetails(
-      content::PermissionType permission,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::DictionaryValue* details,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback);
-  int RequestPermissions(
-      const std::vector<content::PermissionType>& permissions,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::Callback<
-          void(const std::vector<blink::mojom::PermissionStatus>&)>& callback)
-      override;
-  int RequestPermissionsWithDetails(
-      const std::vector<content::PermissionType>& permissions,
-      content::RenderFrameHost* render_frame_host,
-      const GURL& requesting_origin,
-      bool user_gesture,
-      const base::DictionaryValue* details,
-      const base::Callback<
-          void(const std::vector<blink::mojom::PermissionStatus>&)>& callback);
-
- protected:
-  void OnPermissionResponse(int request_id,
-                            int permission_id,
-                            blink::mojom::PermissionStatus status);
-
-  // content::PermissionManager:
-  void ResetPermission(content::PermissionType permission,
-                       const GURL& requesting_origin,
-                       const GURL& embedding_origin) override;
-  blink::mojom::PermissionStatus GetPermissionStatus(
-      content::PermissionType permission,
-      const GURL& requesting_origin,
-      const GURL& embedding_origin) override;
-  int SubscribePermissionStatusChange(
-      content::PermissionType permission,
-      const GURL& requesting_origin,
-      const GURL& embedding_origin,
-      const base::Callback<void(blink::mojom::PermissionStatus)>& callback)
-      override;
-  void UnsubscribePermissionStatusChange(int subscription_id) override;
-
- private:
-  class PendingRequest;
-  using PendingRequestsMap = base::IDMap<std::unique_ptr<PendingRequest>>;
-
-  RequestHandler request_handler_;
-
-  PendingRequestsMap pending_requests_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomPermissionManager);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_PERMISSION_MANAGER_H_
removed in remote
  base   100644 8775f950ca9a0a1b00976d86b8045e1b49366ddc atom/browser/atom_quota_permission_context.cc
  our    100644 b8bf9d53f5653c68a4b867ed37c06330d7c9a0fb atom/browser/atom_quota_permission_context.cc
@@ -1,20 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_quota_permission_context.h"
-
-namespace atom {
-
-AtomQuotaPermissionContext::AtomQuotaPermissionContext() {}
-
-AtomQuotaPermissionContext::~AtomQuotaPermissionContext() {}
-
-void AtomQuotaPermissionContext::RequestQuotaPermission(
-    const content::StorageQuotaParams& params,
-    int render_process_id,
-    const PermissionCallback& callback) {
-  callback.Run(response::QUOTA_PERMISSION_RESPONSE_ALLOW);
-}
-
-}  // namespace atom
removed in remote
  base   100644 1246ea7bad589bbc1d7c76fa535fc4d449ee4a2c atom/browser/atom_quota_permission_context.h
  our    100644 1b04f8e05b16306be7dda4d646b2fed13a22ae5e atom/browser/atom_quota_permission_context.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
-#define ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
-
-#include "content/public/browser/quota_permission_context.h"
-#include "content/public/common/storage_quota_params.h"
-
-namespace atom {
-
-class AtomQuotaPermissionContext : public content::QuotaPermissionContext {
- public:
-  typedef content::QuotaPermissionContext::QuotaPermissionResponse response;
-
-  AtomQuotaPermissionContext();
-
-  // content::QuotaPermissionContext:
-  void RequestQuotaPermission(const content::StorageQuotaParams& params,
-                              int render_process_id,
-                              const PermissionCallback& callback) override;
-
- private:
-  ~AtomQuotaPermissionContext() override;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomQuotaPermissionContext);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_QUOTA_PERMISSION_CONTEXT_H_
removed in remote
  base   100644 68576a52f248f69a1af66ebb901589d89a144ee9 atom/browser/atom_resource_dispatcher_host_delegate.cc
  our    100644 934b0ebaa49b711490c58fc73b91985633cba439 atom/browser/atom_resource_dispatcher_host_delegate.cc
@@ -1,145 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_resource_dispatcher_host_delegate.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/common/platform_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/download_manager.h"
-#include "content/public/browser/render_frame_host.h"
-#include "net/base/escape.h"
-#include "url/gurl.h"
-
-#if defined(ENABLE_PDF_VIEWER)
-#include "atom/common/atom_constants.h"
-#include "base/strings/stringprintf.h"
-#include "content/public/browser/stream_info.h"
-#include "net/url_request/url_request.h"
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-void OnOpenExternal(const GURL& escaped_url, bool allowed) {
-  if (allowed)
-    platform_util::OpenExternal(
-#if defined(OS_WIN)
-        base::UTF8ToUTF16(escaped_url.spec()),
-#else
-        escaped_url,
-#endif
-        true);
-}
-
-void HandleExternalProtocolInUI(
-    const GURL& url,
-    const content::ResourceRequestInfo::WebContentsGetter& web_contents_getter,
-    bool has_user_gesture) {
-  content::WebContents* web_contents = web_contents_getter.Run();
-  if (!web_contents)
-    return;
-
-  auto* permission_helper =
-      WebContentsPermissionHelper::FromWebContents(web_contents);
-  if (!permission_helper)
-    return;
-
-  GURL escaped_url(net::EscapeExternalHandlerValue(url.spec()));
-  auto callback = base::Bind(&OnOpenExternal, escaped_url);
-  permission_helper->RequestOpenExternalPermission(callback, has_user_gesture,
-                                                   url);
-}
-
-#if defined(ENABLE_PDF_VIEWER)
-void OnPdfResourceIntercepted(
-    const GURL& original_url,
-    int render_process_host_id,
-    int render_frame_id,
-    const content::ResourceRequestInfo::WebContentsGetter&
-        web_contents_getter) {
-  content::WebContents* web_contents = web_contents_getter.Run();
-  if (!web_contents)
-    return;
-
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  if (!web_preferences || !web_preferences->IsEnabled(options::kPlugins)) {
-    auto* browser_context = web_contents->GetBrowserContext();
-    auto* download_manager =
-        content::BrowserContext::GetDownloadManager(browser_context);
-
-    download_manager->DownloadUrl(
-        content::DownloadUrlParameters::CreateForWebContentsMainFrame(
-            web_contents, original_url, NO_TRAFFIC_ANNOTATION_YET));
-    return;
-  }
-
-  // The URL passes the original pdf resource url, that will be requested
-  // by the webui page.
-  // chrome://pdf-viewer/index.html?src=https://somepage/123.pdf
-  content::NavigationController::LoadURLParams params(GURL(base::StringPrintf(
-      "%sindex.html?%s=%s", kPdfViewerUIOrigin, kPdfPluginSrc,
-      net::EscapeUrlEncodedData(original_url.spec(), false).c_str())));
-
-  content::RenderFrameHost* frame_host =
-      content::RenderFrameHost::FromID(render_process_host_id, render_frame_id);
-  if (!frame_host) {
-    return;
-  }
-
-  params.frame_tree_node_id = frame_host->GetFrameTreeNodeId();
-  web_contents->GetController().LoadURLWithParams(params);
-}
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace
-
-AtomResourceDispatcherHostDelegate::AtomResourceDispatcherHostDelegate() {}
-
-bool AtomResourceDispatcherHostDelegate::HandleExternalProtocol(
-    const GURL& url,
-    content::ResourceRequestInfo* info) {
-  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
-                          base::BindOnce(&HandleExternalProtocolInUI, url,
-                                         info->GetWebContentsGetterForRequest(),
-                                         info->HasUserGesture()));
-  return true;
-}
-
-bool AtomResourceDispatcherHostDelegate::ShouldInterceptResourceAsStream(
-    net::URLRequest* request,
-    const std::string& mime_type,
-    GURL* origin,
-    std::string* payload) {
-#if defined(ENABLE_PDF_VIEWER)
-  const content::ResourceRequestInfo* info =
-      content::ResourceRequestInfo::ForRequest(request);
-
-  int render_process_host_id;
-  int render_frame_id;
-  if (!info->GetAssociatedRenderFrame(&render_process_host_id,
-                                      &render_frame_id)) {
-    return false;
-  }
-
-  if (mime_type == "application/pdf") {
-    *origin = GURL(kPdfViewerUIOrigin);
-    content::BrowserThread::PostTask(
-        BrowserThread::UI, FROM_HERE,
-        base::Bind(&OnPdfResourceIntercepted, request->url(),
-                   render_process_host_id, render_frame_id,
-                   info->GetWebContentsGetterForRequest()));
-    return true;
-  }
-#endif  // defined(ENABLE_PDF_VIEWER)
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 408b83c92d90565c1278192d0d9f85ac9d287849 atom/browser/atom_resource_dispatcher_host_delegate.h
  our    100644 eb91b27921e2bcc9761a6f20c949abfa49fcfd77 atom/browser/atom_resource_dispatcher_host_delegate.h
@@ -1,33 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
-
-#include <string>
-
-#include "content/public/browser/resource_dispatcher_host_delegate.h"
-
-namespace atom {
-
-class AtomResourceDispatcherHostDelegate
-    : public content::ResourceDispatcherHostDelegate {
- public:
-  AtomResourceDispatcherHostDelegate();
-
-  // content::ResourceDispatcherHostDelegate:
-  bool HandleExternalProtocol(const GURL& url,
-                              content::ResourceRequestInfo* info) override;
-  bool ShouldInterceptResourceAsStream(net::URLRequest* request,
-                                       const std::string& mime_type,
-                                       GURL* origin,
-                                       std::string* payload) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomResourceDispatcherHostDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
removed in remote
  base   100644 06727332f061a56811fc96ebfd61d8e1d2a14d52 atom/browser/atom_speech_recognition_manager_delegate.cc
  our    100644 8333211d9ed8295d5bf4b565962a0488044cad53 atom/browser/atom_speech_recognition_manager_delegate.cc
@@ -1,61 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/atom_speech_recognition_manager_delegate.h"
-
-#include <string>
-
-#include "base/callback.h"
-
-namespace atom {
-
-AtomSpeechRecognitionManagerDelegate::AtomSpeechRecognitionManagerDelegate() {}
-
-AtomSpeechRecognitionManagerDelegate::~AtomSpeechRecognitionManagerDelegate() {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnEnvironmentEstimationComplete(
-    int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnSoundStart(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnSoundEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionEnd(int session_id) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionResults(
-    int session_id,
-    const content::SpeechRecognitionResults& result) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnRecognitionError(
-    int session_id,
-    const content::SpeechRecognitionError& error) {}
-
-void AtomSpeechRecognitionManagerDelegate::OnAudioLevelsChange(
-    int session_id,
-    float volume,
-    float noise_volume) {}
-
-void AtomSpeechRecognitionManagerDelegate::CheckRecognitionIsAllowed(
-    int session_id,
-    base::OnceCallback<void(bool ask_user, bool is_allowed)> callback) {
-  std::move(callback).Run(true, true);
-}
-
-content::SpeechRecognitionEventListener*
-AtomSpeechRecognitionManagerDelegate::GetEventListener() {
-  return this;
-}
-
-bool AtomSpeechRecognitionManagerDelegate::FilterProfanities(
-    int render_process_id) {
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 4c78e0eead107e1679184d855d032f10d5791f6d atom/browser/atom_speech_recognition_manager_delegate.h
  our    100644 10f812a99b8e0d420a99b89b137a460e68d00618 atom/browser/atom_speech_recognition_manager_delegate.h
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
-#define ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
-
-#include <string>
-
-#include "base/macros.h"
-#include "content/public/browser/speech_recognition_event_listener.h"
-#include "content/public/browser/speech_recognition_manager_delegate.h"
-
-namespace atom {
-
-class AtomSpeechRecognitionManagerDelegate
-    : public content::SpeechRecognitionManagerDelegate,
-      public content::SpeechRecognitionEventListener {
- public:
-  AtomSpeechRecognitionManagerDelegate();
-  ~AtomSpeechRecognitionManagerDelegate() override;
-
-  // content::SpeechRecognitionEventListener:
-  void OnRecognitionStart(int session_id) override;
-  void OnAudioStart(int session_id) override;
-  void OnEnvironmentEstimationComplete(int session_id) override;
-  void OnSoundStart(int session_id) override;
-  void OnSoundEnd(int session_id) override;
-  void OnAudioEnd(int session_id) override;
-  void OnRecognitionEnd(int session_id) override;
-  void OnRecognitionResults(
-      int session_id,
-      const content::SpeechRecognitionResults& result) override;
-  void OnRecognitionError(
-      int session_id,
-      const content::SpeechRecognitionError& error) override;
-  void OnAudioLevelsChange(int session_id,
-                           float volume,
-                           float noise_volume) override;
-
-  // content::SpeechRecognitionManagerDelegate:
-  void CheckRecognitionIsAllowed(
-      int session_id,
-      base::OnceCallback<void(bool ask_user, bool is_allowed)> callback)
-      override;
-  content::SpeechRecognitionEventListener* GetEventListener() override;
-  bool FilterProfanities(int render_process_id) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(AtomSpeechRecognitionManagerDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_ATOM_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
removed in remote
  base   100644 7dbfc5a6feba1b3ff343c10fda82e22ed3df596d atom/browser/auto_updater.cc
  our    100644 90ff157477890b572c917b26ce8d76f29feedef6 atom/browser/auto_updater.cc
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/auto_updater.h"
-
-namespace auto_updater {
-
-Delegate* AutoUpdater::delegate_ = nullptr;
-
-Delegate* AutoUpdater::GetDelegate() {
-  return delegate_;
-}
-
-void AutoUpdater::SetDelegate(Delegate* delegate) {
-  delegate_ = delegate;
-}
-
-#if !defined(OS_MACOSX) || defined(MAS_BUILD)
-std::string AutoUpdater::GetFeedURL() {
-  return "";
-}
-
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {}
-
-void AutoUpdater::CheckForUpdates() {}
-
-void AutoUpdater::QuitAndInstall() {}
-#endif
-
-}  // namespace auto_updater
removed in remote
  base   100644 d13c6f0c3305ca7d165708616a233a7004b13aa0 atom/browser/auto_updater.h
  our    100644 7be3e56db3e948e980c0647dc5c562416de4db16 atom/browser/auto_updater.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_AUTO_UPDATER_H_
-#define ATOM_BROWSER_AUTO_UPDATER_H_
-
-#include <map>
-#include <string>
-
-#include "base/macros.h"
-#include "build/build_config.h"
-#include "native_mate/arguments.h"
-
-namespace base {
-class Time;
-}
-
-namespace auto_updater {
-
-class Delegate {
- public:
-  // An error happened.
-  virtual void OnError(const std::string& error) {}
-
-  virtual void OnError(const std::string& error,
-                       const int code,
-                       const std::string& domain) {}
-
-  // Checking to see if there is an update
-  virtual void OnCheckingForUpdate() {}
-
-  // There is an update available and it is being downloaded
-  virtual void OnUpdateAvailable() {}
-
-  // There is no available update.
-  virtual void OnUpdateNotAvailable() {}
-
-  // There is a new update which has been downloaded.
-  virtual void OnUpdateDownloaded(const std::string& release_notes,
-                                  const std::string& release_name,
-                                  const base::Time& release_date,
-                                  const std::string& update_url) {}
-
- protected:
-  virtual ~Delegate() {}
-};
-
-class AutoUpdater {
- public:
-  typedef std::map<std::string, std::string> HeaderMap;
-
-  // Gets/Sets the delegate.
-  static Delegate* GetDelegate();
-  static void SetDelegate(Delegate* delegate);
-
-  static std::string GetFeedURL();
-  static void SetFeedURL(mate::Arguments* args);
-  static void CheckForUpdates();
-  static void QuitAndInstall();
-
- private:
-  static Delegate* delegate_;
-
-  DISALLOW_IMPLICIT_CONSTRUCTORS(AutoUpdater);
-};
-
-}  // namespace auto_updater
-
-#endif  // ATOM_BROWSER_AUTO_UPDATER_H_
removed in remote
  base   100644 a55cdd281265d2c5b1bad20e72dbdd135f886995 atom/browser/auto_updater_mac.mm
  our    100644 ff8ffb86373f44b8c1b7276a2459444de3aaff5b atom/browser/auto_updater_mac.mm
@@ -1,174 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/auto_updater.h"
-
-#import <ReactiveCocoa/NSObject+RACPropertySubscribing.h>
-#import <ReactiveCocoa/RACCommand.h>
-#import <ReactiveCocoa/RACSignal.h>
-#import <Squirrel/Squirrel.h>
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/bind.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/time/time.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-
-namespace auto_updater {
-
-namespace {
-
-// The gloal SQRLUpdater object.
-SQRLUpdater* g_updater = nil;
-
-}  // namespace
-
-namespace {
-
-bool g_update_available = false;
-std::string update_url_ = "";
-
-}  // namespace
-
-std::string AutoUpdater::GetFeedURL() {
-  return update_url_;
-}
-
-// static
-void AutoUpdater::SetFeedURL(mate::Arguments* args) {
-  mate::Dictionary opts;
-  std::string feed;
-  HeaderMap requestHeaders;
-  std::string serverType = "default";
-  if (args->GetNext(&opts)) {
-    if (!opts.Get("url", &feed)) {
-      args->ThrowError(
-          "Expected options object to contain a 'url' string property in "
-          "setFeedUrl call");
-      return;
-    }
-    opts.Get("headers", &requestHeaders);
-    opts.Get("serverType", &serverType);
-    if (serverType != "default" && serverType != "json") {
-      args->ThrowError("Expected serverType to be 'default' or 'json'");
-      return;
-    }
-  } else if (args->GetNext(&feed)) {
-    args->GetNext(&requestHeaders);
-  } else {
-    args->ThrowError(
-        "Expected an options object with a 'url' property to be provided");
-    return;
-  }
-
-  Delegate* delegate = GetDelegate();
-  if (!delegate)
-    return;
-
-  update_url_ = feed;
-
-  NSURL* url = [NSURL URLWithString:base::SysUTF8ToNSString(feed)];
-  NSMutableURLRequest* urlRequest = [NSMutableURLRequest requestWithURL:url];
-
-  for (const auto& it : requestHeaders) {
-    [urlRequest setValue:base::SysUTF8ToNSString(it.second)
-        forHTTPHeaderField:base::SysUTF8ToNSString(it.first)];
-  }
-
-  if (g_updater)
-    [g_updater release];
-
-  // Initialize the SQRLUpdater.
-  @try {
-    if (serverType == "json") {
-      NSString* nsAppVersion =
-          base::SysUTF8ToNSString(atom::Browser::Get()->GetVersion());
-      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest
-                                                  forVersion:nsAppVersion];
-    } else {
-      // default
-      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest];
-    }
-  } @catch (NSException* error) {
-    delegate->OnError(base::SysNSStringToUTF8(error.reason));
-    return;
-  }
-
-  [[g_updater rac_valuesForKeyPath:@"state" observer:g_updater]
-      subscribeNext:^(NSNumber* stateNumber) {
-        int state = [stateNumber integerValue];
-        // Dispatching the event on main thread.
-        dispatch_async(dispatch_get_main_queue(), ^{
-          if (state == SQRLUpdaterStateCheckingForUpdate)
-            delegate->OnCheckingForUpdate();
-          else if (state == SQRLUpdaterStateDownloadingUpdate)
-            delegate->OnUpdateAvailable();
-        });
-      }];
-}
-
-// static
-void AutoUpdater::CheckForUpdates() {
-  Delegate* delegate = GetDelegate();
-  if (!delegate)
-    return;
-
-  [[[[g_updater.checkForUpdatesCommand execute:nil]
-      // Send a `nil` after everything...
-      concat:[RACSignal return:nil]]
-      // But only take the first value. If an update is sent, we'll get that.
-      // Otherwise, we'll get our inserted `nil` value.
-      take:1]
-      subscribeNext:^(SQRLDownloadedUpdate* downloadedUpdate) {
-        if (downloadedUpdate) {
-          g_update_available = true;
-          SQRLUpdate* update = downloadedUpdate.update;
-          // There is a new update that has been downloaded.
-          delegate->OnUpdateDownloaded(
-              base::SysNSStringToUTF8(update.releaseNotes),
-              base::SysNSStringToUTF8(update.releaseName),
-              base::Time::FromDoubleT(update.releaseDate.timeIntervalSince1970),
-              base::SysNSStringToUTF8(update.updateURL.absoluteString));
-        } else {
-          g_update_available = false;
-          // When the completed event is sent with no update, then we know there
-          // is no update available.
-          delegate->OnUpdateNotAvailable();
-        }
-      }
-      error:^(NSError* error) {
-        NSMutableString* failureString =
-            [NSMutableString stringWithString:error.localizedDescription];
-        if (error.localizedFailureReason) {
-          [failureString appendString:@": "];
-          [failureString appendString:error.localizedFailureReason];
-        }
-        if (error.localizedRecoverySuggestion) {
-          if (![failureString hasSuffix:@"."])
-            [failureString appendString:@"."];
-          [failureString appendString:@" "];
-          [failureString appendString:error.localizedRecoverySuggestion];
-        }
-        delegate->OnError(base::SysNSStringToUTF8(failureString), error.code,
-                          base::SysNSStringToUTF8(error.domain));
-      }];
-}
-
-void AutoUpdater::QuitAndInstall() {
-  Delegate* delegate = AutoUpdater::GetDelegate();
-  if (g_update_available) {
-    [[g_updater relaunchToInstallUpdate] subscribeError:^(NSError* error) {
-      if (delegate)
-        delegate->OnError(base::SysNSStringToUTF8(error.localizedDescription),
-                          error.code, base::SysNSStringToUTF8(error.domain));
-    }];
-  } else {
-    if (delegate)
-      delegate->OnError("No update available, can't quit and install");
-  }
-}
-
-}  // namespace auto_updater
removed in remote
  base   100644 36c8d17359e8eef3a52a682dcba692b51ce82378 atom/browser/bridge_task_runner.cc
  our    100644 c0b3cd750d9da13d2957865fd98b094ffbe7bcaf atom/browser/bridge_task_runner.cc
@@ -1,63 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/bridge_task_runner.h"
-
-#include "base/message_loop/message_loop.h"
-
-namespace atom {
-
-BridgeTaskRunner::BridgeTaskRunner() = default;
-BridgeTaskRunner::~BridgeTaskRunner() = default;
-
-void BridgeTaskRunner::MessageLoopIsReady() {
-  auto* message_loop = base::MessageLoop::current();
-  CHECK(message_loop);
-  for (TaskPair& task : tasks_) {
-    message_loop->task_runner()->PostDelayedTask(
-        std::get<0>(task), std::move(std::get<1>(task)), std::get<2>(task));
-  }
-  for (TaskPair& task : non_nestable_tasks_) {
-    message_loop->task_runner()->PostNonNestableDelayedTask(
-        std::get<0>(task), std::move(std::get<1>(task)), std::get<2>(task));
-  }
-}
-
-bool BridgeTaskRunner::PostDelayedTask(const base::Location& from_here,
-                                       base::OnceClosure task,
-                                       base::TimeDelta delay) {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop) {
-    tasks_.push_back(std::make_tuple(from_here, std::move(task), delay));
-    return true;
-  }
-
-  return message_loop->task_runner()->PostDelayedTask(from_here,
-                                                      std::move(task), delay);
-}
-
-bool BridgeTaskRunner::RunsTasksInCurrentSequence() const {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop)
-    return true;
-
-  return message_loop->task_runner()->RunsTasksInCurrentSequence();
-}
-
-bool BridgeTaskRunner::PostNonNestableDelayedTask(
-    const base::Location& from_here,
-    base::OnceClosure task,
-    base::TimeDelta delay) {
-  auto* message_loop = base::MessageLoop::current();
-  if (!message_loop) {
-    non_nestable_tasks_.push_back(
-        std::make_tuple(from_here, std::move(task), delay));
-    return true;
-  }
-
-  return message_loop->task_runner()->PostNonNestableDelayedTask(
-      from_here, std::move(task), delay);
-}
-
-}  // namespace atom
removed in remote
  base   100644 b69b33b29516a7bb866b7cca9e09d7a3d1726b3a atom/browser/bridge_task_runner.h
  our    100644 7c3049b3f8c2d22fa4803b409f2f62f840e8ea72 atom/browser/bridge_task_runner.h
@@ -1,48 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
-#define ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
-
-#include <tuple>
-#include <vector>
-
-#include "base/location.h"
-#include "base/single_thread_task_runner.h"
-#include "base/tuple.h"
-
-namespace atom {
-
-// Post all tasks to the current message loop's task runner if available,
-// otherwise delay the work until message loop is ready.
-class BridgeTaskRunner : public base::SingleThreadTaskRunner {
- public:
-  BridgeTaskRunner();
-
-  // Called when message loop is ready.
-  void MessageLoopIsReady();
-
-  // base::SingleThreadTaskRunner:
-  bool PostDelayedTask(const base::Location& from_here,
-                       base::OnceClosure task,
-                       base::TimeDelta delay) override;
-  bool RunsTasksInCurrentSequence() const override;
-  bool PostNonNestableDelayedTask(const base::Location& from_here,
-                                  base::OnceClosure task,
-                                  base::TimeDelta delay) override;
-
- private:
-  using TaskPair =
-      std::tuple<base::Location, base::OnceClosure, base::TimeDelta>;
-  ~BridgeTaskRunner() override;
-
-  std::vector<TaskPair> tasks_;
-  std::vector<TaskPair> non_nestable_tasks_;
-
-  DISALLOW_COPY_AND_ASSIGN(BridgeTaskRunner);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BRIDGE_TASK_RUNNER_H_
removed in remote
  base   100644 e89f52283b3c8168ecc1e2d5340c81b75957630a atom/browser/browser.cc
  our    100644 ce35de64d60c6767ac52596c1b32e7bde5ceefa0 atom/browser/browser.cc
@@ -1,242 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <string>
-
-#include "atom/browser/atom_browser_main_parts.h"
-#include "atom/browser/browser_observer.h"
-#include "atom/browser/login_handler.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "base/files/file_util.h"
-#include "base/message_loop/message_loop.h"
-#include "base/path_service.h"
-#include "base/run_loop.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "brightray/browser/brightray_paths.h"
-#include "brightray/common/application_info.h"
-
-namespace atom {
-
-Browser::LoginItemSettings::LoginItemSettings() = default;
-Browser::LoginItemSettings::~LoginItemSettings() = default;
-Browser::LoginItemSettings::LoginItemSettings(const LoginItemSettings& other) =
-    default;
-
-Browser::Browser() {
-  WindowList::AddObserver(this);
-}
-
-Browser::~Browser() {
-  WindowList::RemoveObserver(this);
-}
-
-// static
-Browser* Browser::Get() {
-  return AtomBrowserMainParts::Get()->browser();
-}
-
-void Browser::Quit() {
-  if (is_quiting_)
-    return;
-
-  is_quiting_ = HandleBeforeQuit();
-  if (!is_quiting_)
-    return;
-
-  if (atom::WindowList::IsEmpty())
-    NotifyAndShutdown();
-  else
-    atom::WindowList::CloseAllWindows();
-}
-
-void Browser::Exit(mate::Arguments* args) {
-  int code = 0;
-  args->GetNext(&code);
-
-  if (!AtomBrowserMainParts::Get()->SetExitCode(code)) {
-    // Message loop is not ready, quit directly.
-    exit(code);
-  } else {
-    // Prepare to quit when all windows have been closed.
-    is_quiting_ = true;
-
-    // Remember this caller so that we don't emit unrelated events.
-    is_exiting_ = true;
-
-    // Must destroy windows before quitting, otherwise bad things can happen.
-    if (atom::WindowList::IsEmpty()) {
-      Shutdown();
-    } else {
-      // Unlike Quit(), we do not ask to close window, but destroy the window
-      // without asking.
-      atom::WindowList::DestroyAllWindows();
-    }
-  }
-}
-
-void Browser::Shutdown() {
-  if (is_shutdown_)
-    return;
-
-  is_shutdown_ = true;
-  is_quiting_ = true;
-
-  for (BrowserObserver& observer : observers_)
-    observer.OnQuit();
-
-  if (base::ThreadTaskRunnerHandle::IsSet()) {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::MessageLoop::QuitWhenIdleClosure());
-  } else {
-    // There is no message loop available so we are in early stage.
-    exit(0);
-  }
-}
-
-std::string Browser::GetVersion() const {
-  std::string ret = brightray::GetOverriddenApplicationVersion();
-  if (ret.empty())
-    ret = GetExecutableFileVersion();
-  return ret;
-}
-
-void Browser::SetVersion(const std::string& version) {
-  brightray::OverrideApplicationVersion(version);
-}
-
-std::string Browser::GetName() const {
-  std::string ret = brightray::GetOverriddenApplicationName();
-  if (ret.empty())
-    ret = GetExecutableFileProductName();
-  return ret;
-}
-
-void Browser::SetName(const std::string& name) {
-  brightray::OverrideApplicationName(name);
-}
-
-int Browser::GetBadgeCount() {
-  return badge_count_;
-}
-
-bool Browser::OpenFile(const std::string& file_path) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnOpenFile(&prevent_default, file_path);
-
-  return prevent_default;
-}
-
-void Browser::OpenURL(const std::string& url) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnOpenURL(url);
-}
-
-void Browser::Activate(bool has_visible_windows) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnActivate(has_visible_windows);
-}
-
-void Browser::WillFinishLaunching() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillFinishLaunching();
-}
-
-void Browser::DidFinishLaunching(const base::DictionaryValue& launch_info) {
-  // Make sure the userData directory is created.
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  base::FilePath user_data;
-  if (PathService::Get(brightray::DIR_USER_DATA, &user_data))
-    base::CreateDirectoryAndGetError(user_data, nullptr);
-
-  is_ready_ = true;
-  if (ready_promise_) {
-    ready_promise_->Resolve();
-  }
-  for (BrowserObserver& observer : observers_)
-    observer.OnFinishLaunching(launch_info);
-}
-
-util::Promise* Browser::WhenReady(v8::Isolate* isolate) {
-  if (!ready_promise_) {
-    ready_promise_ = new util::Promise(isolate);
-    if (is_ready()) {
-      ready_promise_->Resolve();
-    }
-  }
-  return ready_promise_;
-}
-
-void Browser::OnAccessibilitySupportChanged() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnAccessibilitySupportChanged();
-}
-
-void Browser::RequestLogin(
-    scoped_refptr<LoginHandler> login_handler,
-    std::unique_ptr<base::DictionaryValue> request_details) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnLogin(login_handler, *(request_details.get()));
-}
-
-void Browser::PreMainMessageLoopRun() {
-  for (BrowserObserver& observer : observers_) {
-    observer.OnPreMainMessageLoopRun();
-  }
-}
-
-void Browser::NotifyAndShutdown() {
-  if (is_shutdown_)
-    return;
-
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillQuit(&prevent_default);
-
-  if (prevent_default) {
-    is_quiting_ = false;
-    return;
-  }
-
-  Shutdown();
-}
-
-bool Browser::HandleBeforeQuit() {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnBeforeQuit(&prevent_default);
-
-  return !prevent_default;
-}
-
-void Browser::OnWindowCloseCancelled(NativeWindow* window) {
-  if (is_quiting_)
-    // Once a beforeunload handler has prevented the closing, we think the quit
-    // is cancelled too.
-    is_quiting_ = false;
-}
-
-void Browser::OnWindowAllClosed() {
-  if (is_exiting_) {
-    Shutdown();
-  } else if (is_quiting_) {
-    NotifyAndShutdown();
-  } else {
-    for (BrowserObserver& observer : observers_)
-      observer.OnWindowAllClosed();
-  }
-}
-
-#if defined(OS_MACOSX)
-void Browser::NewWindowForTab() {
-  for (BrowserObserver& observer : observers_)
-    observer.OnNewWindowForTab();
-}
-#endif
-
-}  // namespace atom
removed in remote
  base   100644 634e14e60262a3531bc99acf5ba74e2cf22d9b54 atom/browser/browser.h
  our    100644 aed7d25c37da59c0dd5e09940a064c329353a0b2 atom/browser/browser.h
@@ -1,295 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BROWSER_H_
-#define ATOM_BROWSER_BROWSER_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/browser_observer.h"
-#include "atom/browser/window_list_observer.h"
-#include "atom/common/promise_util.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "base/observer_list.h"
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "native_mate/arguments.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#include "base/files/file_path.h"
-#endif
-
-namespace base {
-class FilePath;
-}
-
-namespace gfx {
-class Image;
-}
-
-namespace atom {
-
-class AtomMenuModel;
-
-// This class is used for control application-wide operations.
-class Browser : public WindowListObserver {
- public:
-  Browser();
-  ~Browser() override;
-
-  static Browser* Get();
-
-  // Try to close all windows and quit the application.
-  void Quit();
-
-  // Exit the application immediately and set exit code.
-  void Exit(mate::Arguments* args);
-
-  // Cleanup everything and shutdown the application gracefully.
-  void Shutdown();
-
-  // Focus the application.
-  void Focus();
-
-  // Returns the version of the executable (or bundle).
-  std::string GetVersion() const;
-
-  // Overrides the application version.
-  void SetVersion(const std::string& version);
-
-  // Returns the application's name, default is just Electron.
-  std::string GetName() const;
-
-  // Overrides the application name.
-  void SetName(const std::string& name);
-
-  // Add the |path| to recent documents list.
-  void AddRecentDocument(const base::FilePath& path);
-
-  // Clear the recent documents list.
-  void ClearRecentDocuments();
-
-  // Set the application user model ID.
-  void SetAppUserModelID(const base::string16& name);
-
-  // Remove the default protocol handler registry key
-  bool RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                     mate::Arguments* args);
-
-  // Set as default handler for a protocol.
-  bool SetAsDefaultProtocolClient(const std::string& protocol,
-                                  mate::Arguments* args);
-
-  // Query the current state of default handler for a protocol.
-  bool IsDefaultProtocolClient(const std::string& protocol,
-                               mate::Arguments* args);
-
-  // Set/Get the badge count.
-  bool SetBadgeCount(int count);
-  int GetBadgeCount();
-
-  // Set/Get the login item settings of the app
-  struct LoginItemSettings {
-    bool open_at_login = false;
-    bool open_as_hidden = false;
-    bool restore_state = false;
-    bool opened_at_login = false;
-    bool opened_as_hidden = false;
-    base::string16 path;
-    std::vector<base::string16> args;
-
-    LoginItemSettings();
-    ~LoginItemSettings();
-    LoginItemSettings(const LoginItemSettings&);
-  };
-  void SetLoginItemSettings(LoginItemSettings settings);
-  LoginItemSettings GetLoginItemSettings(const LoginItemSettings& options);
-
-#if defined(OS_MACOSX)
-  // Set the handler which decides whether to shutdown.
-  void SetShutdownHandler(base::Callback<bool()> handler);
-
-  // Hide the application.
-  void Hide();
-
-  // Show the application.
-  void Show();
-
-  // Creates an activity and sets it as the one currently in use.
-  void SetUserActivity(const std::string& type,
-                       const base::DictionaryValue& user_info,
-                       mate::Arguments* args);
-
-  // Returns the type name of the current user activity.
-  std::string GetCurrentActivityType();
-
-  // Invalidates the current user activity.
-  void InvalidateCurrentActivity();
-
-  // Updates the current user activity
-  void UpdateCurrentActivity(const std::string& type,
-                             const base::DictionaryValue& user_info);
-
-  // Indicates that an user activity is about to be resumed.
-  bool WillContinueUserActivity(const std::string& type);
-
-  // Indicates a failure to resume a Handoff activity.
-  void DidFailToContinueUserActivity(const std::string& type,
-                                     const std::string& error);
-
-  // Resumes an activity via hand-off.
-  bool ContinueUserActivity(const std::string& type,
-                            const base::DictionaryValue& user_info);
-
-  // Indicates that an activity was continued on another device.
-  void UserActivityWasContinued(const std::string& type,
-                                const base::DictionaryValue& user_info);
-
-  // Gives an oportunity to update the Handoff payload.
-  bool UpdateUserActivityState(const std::string& type,
-                               const base::DictionaryValue& user_info);
-
-  // Bounce the dock icon.
-  enum BounceType {
-    BOUNCE_CRITICAL = 0,
-    BOUNCE_INFORMATIONAL = 10,
-  };
-  int DockBounce(BounceType type);
-  void DockCancelBounce(int request_id);
-
-  // Bounce the Downloads stack.
-  void DockDownloadFinished(const std::string& filePath);
-
-  // Set/Get dock's badge text.
-  void DockSetBadgeText(const std::string& label);
-  std::string DockGetBadgeText();
-
-  // Hide/Show dock.
-  void DockHide();
-  void DockShow();
-  bool DockIsVisible();
-
-  // Set docks' menu.
-  void DockSetMenu(AtomMenuModel* model);
-
-  // Set docks' icon.
-  void DockSetIcon(const gfx::Image& image);
-
-  void ShowAboutPanel();
-  void SetAboutPanelOptions(const base::DictionaryValue& options);
-#endif  // defined(OS_MACOSX)
-
-#if defined(OS_WIN)
-  struct UserTask {
-    base::FilePath program;
-    base::string16 arguments;
-    base::string16 title;
-    base::string16 description;
-    base::FilePath icon_path;
-    int icon_index;
-
-    UserTask();
-    UserTask(const UserTask&);
-    ~UserTask();
-  };
-
-  // Add a custom task to jump list.
-  bool SetUserTasks(const std::vector<UserTask>& tasks);
-
-  // Returns the application user model ID, if there isn't one, then create
-  // one from app's name.
-  // The returned string managed by Browser, and should not be modified.
-  PCWSTR GetAppUserModelID();
-#endif  // defined(OS_WIN)
-
-#if defined(OS_LINUX)
-  // Whether Unity launcher is running.
-  bool IsUnityRunning();
-#endif  // defined(OS_LINUX)
-
-  // Tell the application to open a file.
-  bool OpenFile(const std::string& file_path);
-
-  // Tell the application to open a url.
-  void OpenURL(const std::string& url);
-
-#if defined(OS_MACOSX)
-  // Tell the application to create a new window for a tab.
-  void NewWindowForTab();
-#endif  // defined(OS_MACOSX)
-
-  // Tell the application that application is activated with visible/invisible
-  // windows.
-  void Activate(bool has_visible_windows);
-
-  // Tell the application the loading has been done.
-  void WillFinishLaunching();
-  void DidFinishLaunching(const base::DictionaryValue& launch_info);
-
-  void OnAccessibilitySupportChanged();
-
-  // Request basic auth login.
-  void RequestLogin(scoped_refptr<LoginHandler> login_handler,
-                    std::unique_ptr<base::DictionaryValue> request_details);
-
-  void PreMainMessageLoopRun();
-
-  void AddObserver(BrowserObserver* obs) { observers_.AddObserver(obs); }
-
-  void RemoveObserver(BrowserObserver* obs) { observers_.RemoveObserver(obs); }
-
-  bool is_shutting_down() const { return is_shutdown_; }
-  bool is_quiting() const { return is_quiting_; }
-  bool is_ready() const { return is_ready_; }
-  util::Promise* WhenReady(v8::Isolate* isolate);
-
- protected:
-  // Returns the version of application bundle or executable file.
-  std::string GetExecutableFileVersion() const;
-
-  // Returns the name of application bundle or executable file.
-  std::string GetExecutableFileProductName() const;
-
-  // Send the will-quit message and then shutdown the application.
-  void NotifyAndShutdown();
-
-  // Send the before-quit message and start closing windows.
-  bool HandleBeforeQuit();
-
-  bool is_quiting_ = false;
-
- private:
-  // WindowListObserver implementations:
-  void OnWindowCloseCancelled(NativeWindow* window) override;
-  void OnWindowAllClosed() override;
-
-  // Observers of the browser.
-  base::ObserverList<BrowserObserver> observers_;
-
-  // Whether `app.exit()` has been called
-  bool is_exiting_ = false;
-
-  // Whether "ready" event has been emitted.
-  bool is_ready_ = false;
-
-  // The browser is being shutdown.
-  bool is_shutdown_ = false;
-
-  int badge_count_ = 0;
-
-  util::Promise* ready_promise_ = nullptr;
-
-#if defined(OS_MACOSX)
-  base::DictionaryValue about_panel_options_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(Browser);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BROWSER_H_
removed in remote
  base   100644 6c7d4abaf6456d96a25a68b153bcb4a40b63fff6 atom/browser/browser_linux.cc
  our    100644 0b4868f711ec24e6db3bf37f751c505c0ccc4115 atom/browser/browser_linux.cc
@@ -1,145 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <fcntl.h>
-#include <stdlib.h>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/atom_version.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/process/launch.h"
-#include "brightray/common/application_info.h"
-
-#if defined(USE_X11)
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "chrome/browser/ui/libgtkui/unity_service.h"
-#endif
-
-namespace atom {
-
-const char kXdgSettings[] = "xdg-settings";
-const char kXdgSettingsDefaultSchemeHandler[] = "default-url-scheme-handler";
-
-bool LaunchXdgUtility(const std::vector<std::string>& argv, int* exit_code) {
-  *exit_code = EXIT_FAILURE;
-  int devnull = open("/dev/null", O_RDONLY);
-  if (devnull < 0)
-    return false;
-
-  base::LaunchOptions options;
-  options.fds_to_remap.push_back(std::make_pair(devnull, STDIN_FILENO));
-
-  base::Process process = base::LaunchProcess(argv, options);
-  close(devnull);
-
-  if (!process.IsValid())
-    return false;
-  return process.WaitForExit(exit_code);
-}
-
-bool SetDefaultWebClient(const std::string& protocol) {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-
-  std::vector<std::string> argv;
-  argv.push_back(kXdgSettings);
-  argv.push_back("set");
-  if (!protocol.empty()) {
-    argv.push_back(kXdgSettingsDefaultSchemeHandler);
-    argv.push_back(protocol);
-  }
-  argv.push_back(libgtkui::GetDesktopName(env.get()));
-
-  int exit_code;
-  bool ran_ok = LaunchXdgUtility(argv, &exit_code);
-  return ran_ok && exit_code == EXIT_SUCCESS;
-}
-
-void Browser::Focus() {
-  // Focus on the first visible window.
-  for (auto* const window : WindowList::GetWindows()) {
-    if (window->IsVisible()) {
-      window->Focus(true);
-      break;
-    }
-  }
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {}
-
-void Browser::ClearRecentDocuments() {}
-
-void Browser::SetAppUserModelID(const base::string16& name) {}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  return SetDefaultWebClient(protocol);
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-
-  if (protocol.empty())
-    return false;
-
-  std::vector<std::string> argv;
-  argv.push_back(kXdgSettings);
-  argv.push_back("check");
-  argv.push_back(kXdgSettingsDefaultSchemeHandler);
-  argv.push_back(protocol);
-  argv.push_back(libgtkui::GetDesktopName(env.get()));
-
-  std::string reply;
-  int success_code;
-  bool ran_ok = base::GetAppOutputWithExitCode(base::CommandLine(argv), &reply,
-                                               &success_code);
-
-  if (!ran_ok || success_code != EXIT_SUCCESS)
-    return false;
-
-  // Allow any reply that starts with "yes".
-  return base::StartsWith(reply, "yes", base::CompareCase::SENSITIVE) ? true
-                                                                      : false;
-}
-
-// Todo implement
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  return false;
-}
-
-bool Browser::SetBadgeCount(int count) {
-  if (IsUnityRunning()) {
-    unity::SetDownloadCount(count);
-    badge_count_ = count;
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  return LoginItemSettings();
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  return brightray::GetApplicationVersion();
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-bool Browser::IsUnityRunning() {
-  return unity::IsRunning();
-}
-
-}  // namespace atom
removed in remote
  base   100644 0294894fcd61a7255cd28ad6797ef4e32a279490 atom/browser/browser_mac.mm
  our    100644 27e347eccebf006336d5d110c81717ecc45af9c3 atom/browser/browser_mac.mm
@@ -1,346 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/atom_application_delegate.h"
-#include "atom/browser/mac/dict_util.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/platform_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "net/base/mac/url_conversions.h"
-#include "ui/gfx/image/image.h"
-#include "url/gurl.h"
-
-namespace atom {
-
-void Browser::SetShutdownHandler(base::Callback<bool()> handler) {
-  [[AtomApplication sharedApplication] setShutdownHandler:std::move(handler)];
-}
-
-void Browser::Focus() {
-  [[AtomApplication sharedApplication] activateIgnoringOtherApps:YES];
-}
-
-void Browser::Hide() {
-  [[AtomApplication sharedApplication] hide:nil];
-}
-
-void Browser::Show() {
-  [[AtomApplication sharedApplication] unhide:nil];
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {
-  NSString* path_string = base::mac::FilePathToNSString(path);
-  if (!path_string)
-    return;
-  NSURL* u = [NSURL fileURLWithPath:path_string];
-  if (!u)
-    return;
-  [[NSDocumentController sharedDocumentController] noteNewRecentDocumentURL:u];
-}
-
-void Browser::ClearRecentDocuments() {
-  [[NSDocumentController sharedDocumentController] clearRecentDocuments:nil];
-}
-
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  if (!Browser::IsDefaultProtocolClient(protocol, args))
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-  CFStringRef protocol_cf = base::mac::NSToCFCast(protocol_ns);
-  CFArrayRef bundleList = LSCopyAllHandlersForURLScheme(protocol_cf);
-  if (!bundleList) {
-    return false;
-  }
-  // On macOS, we can't query the default, but the handlers list seems to put
-  // Apple's defaults first, so we'll use the first option that isn't our bundle
-  CFStringRef other = nil;
-  for (CFIndex i = 0; i < CFArrayGetCount(bundleList); ++i) {
-    other =
-        base::mac::CFCast<CFStringRef>(CFArrayGetValueAtIndex(bundleList, i));
-    if (![identifier isEqualToString:(__bridge NSString*)other]) {
-      break;
-    }
-  }
-
-  // No other app was found set it to none instead of setting it back to itself.
-  if ([identifier isEqualToString:(__bridge NSString*)other]) {
-    other = base::mac::NSToCFCast(@"None");
-  }
-
-  OSStatus return_code = LSSetDefaultHandlerForURLScheme(protocol_cf, other);
-  return return_code == noErr;
-}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-  OSStatus return_code = LSSetDefaultHandlerForURLScheme(
-      base::mac::NSToCFCast(protocol_ns), base::mac::NSToCFCast(identifier));
-  return return_code == noErr;
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
-  if (!identifier)
-    return false;
-
-  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
-
-  CFStringRef bundle =
-      LSCopyDefaultHandlerForURLScheme(base::mac::NSToCFCast(protocol_ns));
-  NSString* bundleId =
-      static_cast<NSString*>(base::mac::CFTypeRefToNSObjectAutorelease(bundle));
-  if (!bundleId)
-    return false;
-
-  // Ensure the comparison is case-insensitive
-  // as LS does not persist the case of the bundle id.
-  NSComparisonResult result = [bundleId caseInsensitiveCompare:identifier];
-  return result == NSOrderedSame;
-}
-
-void Browser::SetAppUserModelID(const base::string16& name) {}
-
-bool Browser::SetBadgeCount(int count) {
-  DockSetBadgeText(count != 0 ? base::IntToString(count) : "");
-  badge_count_ = count;
-  return true;
-}
-
-void Browser::SetUserActivity(const std::string& type,
-                              const base::DictionaryValue& user_info,
-                              mate::Arguments* args) {
-  std::string url_string;
-  args->GetNext(&url_string);
-
-  [[AtomApplication sharedApplication]
-      setCurrentActivity:base::SysUTF8ToNSString(type)
-            withUserInfo:DictionaryValueToNSDictionary(user_info)
-          withWebpageURL:net::NSURLWithGURL(GURL(url_string))];
-}
-
-std::string Browser::GetCurrentActivityType() {
-  if (@available(macOS 10.10, *)) {
-    NSUserActivity* userActivity =
-        [[AtomApplication sharedApplication] getCurrentActivity];
-    return base::SysNSStringToUTF8(userActivity.activityType);
-  } else {
-    return std::string();
-  }
-}
-
-void Browser::InvalidateCurrentActivity() {
-  [[AtomApplication sharedApplication] invalidateCurrentActivity];
-}
-
-void Browser::UpdateCurrentActivity(const std::string& type,
-                                    const base::DictionaryValue& user_info) {
-  [[AtomApplication sharedApplication]
-      updateCurrentActivity:base::SysUTF8ToNSString(type)
-               withUserInfo:DictionaryValueToNSDictionary(user_info)];
-}
-
-bool Browser::WillContinueUserActivity(const std::string& type) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnWillContinueUserActivity(&prevent_default, type);
-  return prevent_default;
-}
-
-void Browser::DidFailToContinueUserActivity(const std::string& type,
-                                            const std::string& error) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnDidFailToContinueUserActivity(type, error);
-}
-
-bool Browser::ContinueUserActivity(const std::string& type,
-                                   const base::DictionaryValue& user_info) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnContinueUserActivity(&prevent_default, type, user_info);
-  return prevent_default;
-}
-
-void Browser::UserActivityWasContinued(const std::string& type,
-                                       const base::DictionaryValue& user_info) {
-  for (BrowserObserver& observer : observers_)
-    observer.OnUserActivityWasContinued(type, user_info);
-}
-
-bool Browser::UpdateUserActivityState(const std::string& type,
-                                      const base::DictionaryValue& user_info) {
-  bool prevent_default = false;
-  for (BrowserObserver& observer : observers_)
-    observer.OnUpdateUserActivityState(&prevent_default, type, user_info);
-  return prevent_default;
-}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  LoginItemSettings settings;
-#if defined(MAS_BUILD)
-  settings.open_at_login = platform_util::GetLoginItemEnabled();
-#else
-  settings.open_at_login =
-      base::mac::CheckLoginItemStatus(&settings.open_as_hidden);
-  settings.restore_state = base::mac::WasLaunchedAsLoginItemRestoreState();
-  settings.opened_at_login = base::mac::WasLaunchedAsLoginOrResumeItem();
-  settings.opened_as_hidden = base::mac::WasLaunchedAsHiddenLoginItem();
-#endif
-  return settings;
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {
-#if defined(MAS_BUILD)
-  platform_util::SetLoginItemEnabled(settings.open_at_login);
-#else
-  if (settings.open_at_login)
-    base::mac::AddToLoginItems(settings.open_as_hidden);
-  else
-    base::mac::RemoveFromLoginItems();
-#endif
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  return brightray::GetApplicationVersion();
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-int Browser::DockBounce(BounceType type) {
-  return [[AtomApplication sharedApplication]
-      requestUserAttention:static_cast<NSRequestUserAttentionType>(type)];
-}
-
-void Browser::DockCancelBounce(int request_id) {
-  [[AtomApplication sharedApplication] cancelUserAttentionRequest:request_id];
-}
-
-void Browser::DockSetBadgeText(const std::string& label) {
-  NSDockTile* tile = [[AtomApplication sharedApplication] dockTile];
-  [tile setBadgeLabel:base::SysUTF8ToNSString(label)];
-}
-
-void Browser::DockDownloadFinished(const std::string& filePath) {
-  [[NSDistributedNotificationCenter defaultCenter]
-      postNotificationName:@"com.apple.DownloadFileFinished"
-                    object:base::SysUTF8ToNSString(filePath)];
-}
-
-std::string Browser::DockGetBadgeText() {
-  NSDockTile* tile = [[AtomApplication sharedApplication] dockTile];
-  return base::SysNSStringToUTF8([tile badgeLabel]);
-}
-
-void Browser::DockHide() {
-  for (auto* const& window : WindowList::GetWindows())
-    [window->GetNativeWindow() setCanHide:NO];
-
-  ProcessSerialNumber psn = {0, kCurrentProcess};
-  TransformProcessType(&psn, kProcessTransformToUIElementApplication);
-}
-
-bool Browser::DockIsVisible() {
-  // Because DockShow has a slight delay this may not be true immediately
-  // after that call.
-  return ([[NSRunningApplication currentApplication] activationPolicy] ==
-          NSApplicationActivationPolicyRegular);
-}
-
-void Browser::DockShow() {
-  BOOL active = [[NSRunningApplication currentApplication] isActive];
-  ProcessSerialNumber psn = {0, kCurrentProcess};
-  if (active) {
-    // Workaround buggy behavior of TransformProcessType.
-    // http://stackoverflow.com/questions/7596643/
-    NSArray* runningApps = [NSRunningApplication
-        runningApplicationsWithBundleIdentifier:@"com.apple.dock"];
-    for (NSRunningApplication* app in runningApps) {
-      [app activateWithOptions:NSApplicationActivateIgnoringOtherApps];
-      break;
-    }
-    dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
-    dispatch_after(one_ms, dispatch_get_main_queue(), ^{
-      TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-      dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
-      dispatch_after(one_ms, dispatch_get_main_queue(), ^{
-        [[NSRunningApplication currentApplication]
-            activateWithOptions:NSApplicationActivateIgnoringOtherApps];
-      });
-    });
-  } else {
-    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
-  }
-}
-
-void Browser::DockSetMenu(AtomMenuModel* model) {
-  AtomApplicationDelegate* delegate =
-      (AtomApplicationDelegate*)[NSApp delegate];
-  [delegate setApplicationDockMenu:model];
-}
-
-void Browser::DockSetIcon(const gfx::Image& image) {
-  [[AtomApplication sharedApplication]
-      setApplicationIconImage:image.AsNSImage()];
-}
-
-void Browser::ShowAboutPanel() {
-  NSDictionary* options = DictionaryValueToNSDictionary(about_panel_options_);
-
-  // Credits must be a NSAttributedString instead of NSString
-  id credits = options[@"Credits"];
-  if (credits != nil) {
-    NSMutableDictionary* mutable_options = [options mutableCopy];
-    mutable_options[@"Credits"] = [[[NSAttributedString alloc]
-        initWithString:(NSString*)credits] autorelease];
-    options = [NSDictionary dictionaryWithDictionary:mutable_options];
-  }
-
-  [[AtomApplication sharedApplication]
-      orderFrontStandardAboutPanelWithOptions:options];
-}
-
-void Browser::SetAboutPanelOptions(const base::DictionaryValue& options) {
-  about_panel_options_.Clear();
-
-  // Upper case option keys for orderFrontStandardAboutPanelWithOptions format
-  for (base::DictionaryValue::Iterator iter(options); !iter.IsAtEnd();
-       iter.Advance()) {
-    std::string key = iter.key();
-    if (!key.empty() && iter.value().is_string()) {
-      key[0] = base::ToUpperASCII(key[0]);
-      about_panel_options_.SetString(key, iter.value().GetString());
-    }
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 da327eb90a02ef65b1df28bff1c5169585417aa0 atom/browser/browser_observer.h
  our    100644 d518e8d6a7c6e8e30c09498883719a58c8a9f5e8 atom/browser/browser_observer.h
@@ -1,91 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_BROWSER_OBSERVER_H_
-#define ATOM_BROWSER_BROWSER_OBSERVER_H_
-
-#include <string>
-
-#include "atom/browser/login_handler.h"
-#include "base/memory/scoped_refptr.h"
-#include "build/build_config.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace atom {
-
-class BrowserObserver {
- public:
-  // The browser is about to close all windows.
-  virtual void OnBeforeQuit(bool* prevent_default) {}
-
-  // The browser has closed all windows and will quit.
-  virtual void OnWillQuit(bool* prevent_default) {}
-
-  // The browser has closed all windows. If the browser is quiting, then this
-  // method will not be called, instead it will call OnWillQuit.
-  virtual void OnWindowAllClosed() {}
-
-  // The browser is quitting.
-  virtual void OnQuit() {}
-
-  // The browser has opened a file by double clicking in Finder or dragging the
-  // file to the Dock icon. (macOS only)
-  virtual void OnOpenFile(bool* prevent_default, const std::string& file_path) {
-  }
-
-  // Browser is used to open a url.
-  virtual void OnOpenURL(const std::string& url) {}
-
-  // The browser is activated with visible/invisible windows (usually by
-  // clicking on the dock icon).
-  virtual void OnActivate(bool has_visible_windows) {}
-
-  // The browser has finished loading.
-  virtual void OnWillFinishLaunching() {}
-  virtual void OnFinishLaunching(const base::DictionaryValue& launch_info) {}
-
-  // The browser requests HTTP login.
-  virtual void OnLogin(scoped_refptr<LoginHandler> login_handler,
-                       const base::DictionaryValue& request_details) {}
-
-  // The browser's accessibility suppport has changed.
-  virtual void OnAccessibilitySupportChanged() {}
-
-  // The app message loop is ready
-  virtual void OnPreMainMessageLoopRun() {}
-
-#if defined(OS_MACOSX)
-  // The browser wants to report that an user activity will resume. (macOS only)
-  virtual void OnWillContinueUserActivity(bool* prevent_default,
-                                          const std::string& type) {}
-  // The browser wants to report an user activity resuming error. (macOS only)
-  virtual void OnDidFailToContinueUserActivity(const std::string& type,
-                                               const std::string& error) {}
-  // The browser wants to resume a user activity via handoff. (macOS only)
-  virtual void OnContinueUserActivity(bool* prevent_default,
-                                      const std::string& type,
-                                      const base::DictionaryValue& user_info) {}
-  // The browser wants to notify that an user activity was resumed. (macOS only)
-  virtual void OnUserActivityWasContinued(
-      const std::string& type,
-      const base::DictionaryValue& user_info) {}
-  // The browser wants to update an user activity payload. (macOS only)
-  virtual void OnUpdateUserActivityState(
-      bool* prevent_default,
-      const std::string& type,
-      const base::DictionaryValue& user_info) {}
-  // User clicked the native macOS new tab button. (macOS only)
-  virtual void OnNewWindowForTab() {}
-#endif
-
- protected:
-  virtual ~BrowserObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_BROWSER_OBSERVER_H_
removed in remote
  base   100644 9531406f8cd46494099b7e432ac6e96d610f9eee atom/browser/browser_win.cc
  our    100644 fc3b9f330a4958b0b1e30d41c2bebe091b135856 atom/browser/browser_win.cc
@@ -1,346 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>
-#include <shlobj.h>
-#include <shobjidl.h>
-
-#include "atom/browser/ui/win/jump_list.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/base_paths.h"
-#include "base/file_version_info.h"
-#include "base/files/file_path.h"
-#include "base/path_service.h"
-#include "base/strings/string_util.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/win/registry.h"
-#include "base/win/win_util.h"
-#include "base/win/windows_version.h"
-#include "brightray/common/application_info.h"
-
-namespace atom {
-
-namespace {
-
-BOOL CALLBACK WindowsEnumerationHandler(HWND hwnd, LPARAM param) {
-  DWORD target_process_id = *reinterpret_cast<DWORD*>(param);
-  DWORD process_id = 0;
-
-  GetWindowThreadProcessId(hwnd, &process_id);
-  if (process_id == target_process_id) {
-    SetFocus(hwnd);
-    return FALSE;
-  }
-
-  return TRUE;
-}
-
-bool GetProcessExecPath(base::string16* exe) {
-  base::FilePath path;
-  if (!PathService::Get(base::FILE_EXE, &path)) {
-    LOG(ERROR) << "Error getting app exe path";
-    return false;
-  }
-  *exe = path.value();
-  return true;
-}
-
-bool GetProtocolLaunchPath(mate::Arguments* args, base::string16* exe) {
-  if (!args->GetNext(exe) && !GetProcessExecPath(exe)) {
-    return false;
-  }
-
-  // Read in optional args arg
-  std::vector<base::string16> launch_args;
-  if (args->GetNext(&launch_args) && !launch_args.empty())
-    *exe = base::StringPrintf(L"\"%ls\" %ls \"%%1\"", exe->c_str(),
-                              base::JoinString(launch_args, L" ").c_str());
-  else
-    *exe = base::StringPrintf(L"\"%ls\" \"%%1\"", exe->c_str());
-  return true;
-}
-
-bool FormatCommandLineString(base::string16* exe,
-                             const std::vector<base::string16>& launch_args) {
-  if (exe->empty() && !GetProcessExecPath(exe)) {
-    return false;
-  }
-
-  if (!launch_args.empty()) {
-    *exe = base::StringPrintf(L"%ls %ls", exe->c_str(),
-                              base::JoinString(launch_args, L" ").c_str());
-  }
-
-  return true;
-}
-
-}  // namespace
-
-Browser::UserTask::UserTask() = default;
-Browser::UserTask::UserTask(const UserTask&) = default;
-Browser::UserTask::~UserTask() = default;
-
-void Browser::Focus() {
-  // On Windows we just focus on the first window found for this process.
-  DWORD pid = GetCurrentProcessId();
-  EnumWindows(&WindowsEnumerationHandler, reinterpret_cast<LPARAM>(&pid));
-}
-
-void Browser::AddRecentDocument(const base::FilePath& path) {
-  if (base::win::GetVersion() < base::win::VERSION_WIN7)
-    return;
-
-  CComPtr<IShellItem> item;
-  HRESULT hr = SHCreateItemFromParsingName(path.value().c_str(), NULL,
-                                           IID_PPV_ARGS(&item));
-  if (SUCCEEDED(hr)) {
-    SHARDAPPIDINFO info;
-    info.psi = item;
-    info.pszAppID = GetAppUserModelID();
-    SHAddToRecentDocs(SHARD_APPIDINFO, &info);
-  }
-}
-
-void Browser::ClearRecentDocuments() {
-  CComPtr<IApplicationDestinations> destinations;
-  if (FAILED(destinations.CoCreateInstance(CLSID_ApplicationDestinations, NULL,
-                                           CLSCTX_INPROC_SERVER)))
-    return;
-  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
-    return;
-  destinations->RemoveAllDestinations();
-}
-
-void Browser::SetAppUserModelID(const base::string16& name) {
-  brightray::SetAppUserModelID(name);
-}
-
-bool Browser::SetUserTasks(const std::vector<UserTask>& tasks) {
-  JumpList jump_list(GetAppUserModelID());
-  if (!jump_list.Begin())
-    return false;
-
-  JumpListCategory category;
-  category.type = JumpListCategory::Type::TASKS;
-  category.items.reserve(tasks.size());
-  JumpListItem item;
-  item.type = JumpListItem::Type::TASK;
-  for (const auto& task : tasks) {
-    item.title = task.title;
-    item.path = task.program;
-    item.arguments = task.arguments;
-    item.icon_path = task.icon_path;
-    item.icon_index = task.icon_index;
-    item.description = task.description;
-    category.items.push_back(item);
-  }
-
-  jump_list.AppendCategory(category);
-  return jump_list.Commit();
-}
-
-bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol,
-                                            mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = L"Software\\Classes\\";
-
-  // Command Key
-  base::string16 wprotocol = base::UTF8ToUTF16(protocol);
-  base::string16 shellPath = wprotocol + L"\\shell";
-  base::string16 cmdPath = keyPath + shellPath + L"\\open\\command";
-
-  base::win::RegKey classesKey;
-  base::win::RegKey commandKey;
-
-  if (FAILED(classesKey.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
-    // Classes key doesn't exist, that's concerning, but I guess
-    // we're not the default handler
-    return true;
-
-  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't even exist, we can confirm that it is not set
-    return true;
-
-  base::string16 keyVal;
-  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
-    // Default value not set, we can confirm that it is not set
-    return true;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  if (keyVal == exe) {
-    // Let's kill the key
-    if (FAILED(classesKey.DeleteKey(shellPath.c_str())))
-      return false;
-
-    // Let's clean up after ourselves
-    base::win::RegKey protocolKey;
-    base::string16 protocolPath = keyPath + wprotocol;
-
-    if (SUCCEEDED(
-            protocolKey.Open(root, protocolPath.c_str(), KEY_ALL_ACCESS))) {
-      protocolKey.DeleteValue(L"URL Protocol");
-
-      // Overwrite the default value to be empty, we can't delete it right away
-      protocolKey.WriteValue(L"", L"");
-      protocolKey.DeleteValue(L"");
-    }
-
-    // If now empty, delete the whole key
-    classesKey.DeleteEmptyKey(wprotocol.c_str());
-
-    return true;
-  } else {
-    return true;
-  }
-}
-
-bool Browser::SetAsDefaultProtocolClient(const std::string& protocol,
-                                         mate::Arguments* args) {
-  // HKEY_CLASSES_ROOT
-  //    $PROTOCOL
-  //       (Default) = "URL:$NAME"
-  //       URL Protocol = ""
-  //       shell
-  //          open
-  //             command
-  //                (Default) = "$COMMAND" "%1"
-  //
-  // However, the "HKEY_CLASSES_ROOT" key can only be written by the
-  // Administrator user. So, we instead write to "HKEY_CURRENT_USER\
-  // Software\Classes", which is inherited by "HKEY_CLASSES_ROOT"
-  // anyway, and can be written by unprivileged users.
-
-  if (protocol.empty())
-    return false;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = base::UTF8ToUTF16("Software\\Classes\\" + protocol);
-  base::string16 urlDecl = base::UTF8ToUTF16("URL:" + protocol);
-
-  // Command Key
-  base::string16 cmdPath = keyPath + L"\\shell\\open\\command";
-
-  // Write information to registry
-  base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS);
-  if (FAILED(key.WriteValue(L"URL Protocol", L"")) ||
-      FAILED(key.WriteValue(L"", urlDecl.c_str())))
-    return false;
-
-  base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS);
-  if (FAILED(commandKey.WriteValue(L"", exe.c_str())))
-    return false;
-
-  return true;
-}
-
-bool Browser::IsDefaultProtocolClient(const std::string& protocol,
-                                      mate::Arguments* args) {
-  if (protocol.empty())
-    return false;
-
-  base::string16 exe;
-  if (!GetProtocolLaunchPath(args, &exe))
-    return false;
-
-  // Main Registry Key
-  HKEY root = HKEY_CURRENT_USER;
-  base::string16 keyPath = base::UTF8ToUTF16("Software\\Classes\\" + protocol);
-
-  // Command Key
-  base::string16 cmdPath = keyPath + L"\\shell\\open\\command";
-
-  base::win::RegKey key;
-  base::win::RegKey commandKey;
-  if (FAILED(key.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't exist, we can confirm that it is not set
-    return false;
-
-  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
-    // Key doesn't exist, we can confirm that it is not set
-    return false;
-
-  base::string16 keyVal;
-  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
-    // Default value not set, we can confirm that it is not set
-    return false;
-
-  // Default value is the same as current file path
-  return keyVal == exe;
-}
-
-bool Browser::SetBadgeCount(int count) {
-  return false;
-}
-
-void Browser::SetLoginItemSettings(LoginItemSettings settings) {
-  base::string16 keyPath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
-  base::win::RegKey key(HKEY_CURRENT_USER, keyPath.c_str(), KEY_ALL_ACCESS);
-
-  if (settings.open_at_login) {
-    base::string16 exe = settings.path;
-    if (FormatCommandLineString(&exe, settings.args)) {
-      key.WriteValue(GetAppUserModelID(), exe.c_str());
-    }
-  } else {
-    key.DeleteValue(GetAppUserModelID());
-  }
-}
-
-Browser::LoginItemSettings Browser::GetLoginItemSettings(
-    const LoginItemSettings& options) {
-  LoginItemSettings settings;
-  base::string16 keyPath = L"Software\\Microsoft\\Windows\\CurrentVersion\\Run";
-  base::win::RegKey key(HKEY_CURRENT_USER, keyPath.c_str(), KEY_ALL_ACCESS);
-  base::string16 keyVal;
-
-  if (!FAILED(key.ReadValue(GetAppUserModelID(), &keyVal))) {
-    base::string16 exe = options.path;
-    if (FormatCommandLineString(&exe, options.args)) {
-      settings.open_at_login = keyVal == exe;
-    }
-  }
-
-  return settings;
-}
-
-PCWSTR Browser::GetAppUserModelID() {
-  return brightray::GetRawAppUserModelID();
-}
-
-std::string Browser::GetExecutableFileVersion() const {
-  base::FilePath path;
-  if (PathService::Get(base::FILE_EXE, &path)) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    std::unique_ptr<FileVersionInfo> version_info(
-        FileVersionInfo::CreateFileVersionInfo(path));
-    return base::UTF16ToUTF8(version_info->product_version());
-  }
-
-  return ATOM_VERSION_STRING;
-}
-
-std::string Browser::GetExecutableFileProductName() const {
-  return brightray::GetApplicationName();
-}
-
-}  // namespace atom
removed in remote
  base   100644 62e854ac5655fb96bc5e3191425528e0ca222d96 atom/browser/common_web_contents_delegate.cc
  our    100644 b3b1195e044cd2c74b246aa13e9e85953d694477 atom/browser/common_web_contents_delegate.cc
@@ -1,536 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/common_web_contents_delegate.h"
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_dialog_helper.h"
-#include "atom/common/atom_constants.h"
-#include "atom/common/options_switches.h"
-#include "base/files/file_util.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/sequenced_task_runner_handle.h"
-#include "chrome/browser/printing/print_preview_message_handler.h"
-#include "chrome/browser/printing/print_view_manager_basic.h"
-#include "chrome/browser/ssl/security_state_tab_helper.h"
-#include "chrome/browser/ui/browser_dialogs.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_service.h"
-#include "components/prefs/scoped_user_pref_update.h"
-#include "components/security_state/content/content_utils.h"
-#include "components/security_state/core/security_state.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/child_process_security_policy.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/security_style_explanation.h"
-#include "content/public/browser/security_style_explanations.h"
-#include "storage/browser/fileapi/isolated_context.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-const char kRootName[] = "<root>";
-
-struct FileSystem {
-  FileSystem() {}
-  FileSystem(const std::string& file_system_name,
-             const std::string& root_url,
-             const std::string& file_system_path)
-      : file_system_name(file_system_name),
-        root_url(root_url),
-        file_system_path(file_system_path) {}
-
-  std::string file_system_name;
-  std::string root_url;
-  std::string file_system_path;
-};
-
-std::string RegisterFileSystem(content::WebContents* web_contents,
-                               const base::FilePath& path) {
-  auto* isolated_context = storage::IsolatedContext::GetInstance();
-  std::string root_name(kRootName);
-  std::string file_system_id = isolated_context->RegisterFileSystemForPath(
-      storage::kFileSystemTypeNativeLocal, std::string(), path, &root_name);
-
-  content::ChildProcessSecurityPolicy* policy =
-      content::ChildProcessSecurityPolicy::GetInstance();
-  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
-  int renderer_id = render_view_host->GetProcess()->GetID();
-  policy->GrantReadFileSystem(renderer_id, file_system_id);
-  policy->GrantWriteFileSystem(renderer_id, file_system_id);
-  policy->GrantCreateFileForFileSystem(renderer_id, file_system_id);
-  policy->GrantDeleteFromFileSystem(renderer_id, file_system_id);
-
-  if (!policy->CanReadFile(renderer_id, path))
-    policy->GrantReadFile(renderer_id, path);
-
-  return file_system_id;
-}
-
-FileSystem CreateFileSystemStruct(content::WebContents* web_contents,
-                                  const std::string& file_system_id,
-                                  const std::string& file_system_path) {
-  const GURL origin = web_contents->GetURL().GetOrigin();
-  std::string file_system_name =
-      storage::GetIsolatedFileSystemName(origin, file_system_id);
-  std::string root_url = storage::GetIsolatedFileSystemRootURIString(
-      origin, file_system_id, kRootName);
-  return FileSystem(file_system_name, root_url, file_system_path);
-}
-
-std::unique_ptr<base::DictionaryValue> CreateFileSystemValue(
-    const FileSystem& file_system) {
-  std::unique_ptr<base::DictionaryValue> file_system_value(
-      new base::DictionaryValue());
-  file_system_value->SetString("fileSystemName", file_system.file_system_name);
-  file_system_value->SetString("rootURL", file_system.root_url);
-  file_system_value->SetString("fileSystemPath", file_system.file_system_path);
-  return file_system_value;
-}
-
-void WriteToFile(const base::FilePath& path, const std::string& content) {
-  base::AssertBlockingAllowed();
-  DCHECK(!path.empty());
-
-  base::WriteFile(path, content.data(), content.size());
-}
-
-void AppendToFile(const base::FilePath& path, const std::string& content) {
-  base::AssertBlockingAllowed();
-  DCHECK(!path.empty());
-
-  base::AppendToFile(path, content.data(), content.size());
-}
-
-PrefService* GetPrefService(content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  return static_cast<atom::AtomBrowserContext*>(context)->prefs();
-}
-
-std::set<std::string> GetAddedFileSystemPaths(
-    content::WebContents* web_contents) {
-  auto* pref_service = GetPrefService(web_contents);
-  const base::DictionaryValue* file_system_paths_value =
-      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);
-  std::set<std::string> result;
-  if (file_system_paths_value) {
-    base::DictionaryValue::Iterator it(*file_system_paths_value);
-    for (; !it.IsAtEnd(); it.Advance()) {
-      result.insert(it.key());
-    }
-  }
-  return result;
-}
-
-bool IsDevToolsFileSystemAdded(content::WebContents* web_contents,
-                               const std::string& file_system_path) {
-  auto file_system_paths = GetAddedFileSystemPaths(web_contents);
-  return file_system_paths.find(file_system_path) != file_system_paths.end();
-}
-
-}  // namespace
-
-CommonWebContentsDelegate::CommonWebContentsDelegate()
-    : devtools_file_system_indexer_(new DevToolsFileSystemIndexer),
-      file_task_runner_(
-          base::CreateSequencedTaskRunnerWithTraits({base::MayBlock()})) {}
-
-CommonWebContentsDelegate::~CommonWebContentsDelegate() {}
-
-void CommonWebContentsDelegate::InitWithWebContents(
-    content::WebContents* web_contents,
-    AtomBrowserContext* browser_context,
-    bool is_guest) {
-  browser_context_ = browser_context;
-  web_contents->SetDelegate(this);
-
-  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
-  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
-
-  // Determien whether the WebContents is offscreen.
-  auto* web_preferences = WebContentsPreferences::From(web_contents);
-  offscreen_ =
-      !web_preferences || web_preferences->IsEnabled(options::kOffscreen);
-
-  // Create InspectableWebContents.
-  web_contents_.reset(
-      brightray::InspectableWebContents::Create(web_contents, is_guest));
-  web_contents_->SetDelegate(this);
-}
-
-void CommonWebContentsDelegate::SetOwnerWindow(NativeWindow* owner_window) {
-  SetOwnerWindow(GetWebContents(), owner_window);
-}
-
-void CommonWebContentsDelegate::SetOwnerWindow(
-    content::WebContents* web_contents,
-    NativeWindow* owner_window) {
-  owner_window_ = owner_window ? owner_window->GetWeakPtr() : nullptr;
-  auto relay = std::make_unique<NativeWindowRelay>(owner_window_);
-  auto* relay_key = relay->key;
-  if (owner_window) {
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-    autofill_popup_.reset(new AutofillPopup());
-#endif
-    web_contents->SetUserData(relay_key, std::move(relay));
-  } else {
-    web_contents->RemoveUserData(relay_key);
-    relay.reset();
-  }
-}
-
-void CommonWebContentsDelegate::ResetManagedWebContents(bool async) {
-  if (async) {
-    base::ThreadTaskRunnerHandle::Get()->DeleteSoon(FROM_HERE,
-                                                    web_contents_.release());
-  } else {
-    web_contents_.reset();
-  }
-}
-
-content::WebContents* CommonWebContentsDelegate::GetWebContents() const {
-  if (!web_contents_)
-    return nullptr;
-  return web_contents_->GetWebContents();
-}
-
-content::WebContents* CommonWebContentsDelegate::GetDevToolsWebContents()
-    const {
-  if (!web_contents_)
-    return nullptr;
-  return web_contents_->GetDevToolsWebContents();
-}
-
-content::WebContents* CommonWebContentsDelegate::OpenURLFromTab(
-    content::WebContents* source,
-    const content::OpenURLParams& params) {
-  content::NavigationController::LoadURLParams load_url_params(params.url);
-  load_url_params.referrer = params.referrer;
-  load_url_params.transition_type = params.transition;
-  load_url_params.extra_headers = params.extra_headers;
-  load_url_params.should_replace_current_entry =
-      params.should_replace_current_entry;
-  load_url_params.is_renderer_initiated = params.is_renderer_initiated;
-  load_url_params.should_clear_history_list = true;
-
-  source->GetController().LoadURLWithParams(load_url_params);
-  return source;
-}
-
-bool CommonWebContentsDelegate::CanOverscrollContent() const {
-  return false;
-}
-
-content::ColorChooser* CommonWebContentsDelegate::OpenColorChooser(
-    content::WebContents* web_contents,
-    SkColor color,
-    const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions) {
-  return chrome::ShowColorChooser(web_contents, color);
-}
-
-void CommonWebContentsDelegate::RunFileChooser(
-    content::RenderFrameHost* render_frame_host,
-    const content::FileChooserParams& params) {
-  if (!web_dialog_helper_)
-    web_dialog_helper_.reset(new WebDialogHelper(owner_window(), offscreen_));
-  web_dialog_helper_->RunFileChooser(render_frame_host, params);
-}
-
-void CommonWebContentsDelegate::EnumerateDirectory(content::WebContents* guest,
-                                                   int request_id,
-                                                   const base::FilePath& path) {
-  if (!web_dialog_helper_)
-    web_dialog_helper_.reset(new WebDialogHelper(owner_window(), offscreen_));
-  web_dialog_helper_->EnumerateDirectory(guest, request_id, path);
-}
-
-void CommonWebContentsDelegate::EnterFullscreenModeForTab(
-    content::WebContents* source,
-    const GURL& origin) {
-  if (!owner_window_)
-    return;
-  SetHtmlApiFullscreen(true);
-  owner_window_->NotifyWindowEnterHtmlFullScreen();
-  source->GetRenderViewHost()->GetWidget()->WasResized();
-}
-
-void CommonWebContentsDelegate::ExitFullscreenModeForTab(
-    content::WebContents* source) {
-  if (!owner_window_)
-    return;
-  SetHtmlApiFullscreen(false);
-  owner_window_->NotifyWindowLeaveHtmlFullScreen();
-  source->GetRenderViewHost()->GetWidget()->WasResized();
-}
-
-bool CommonWebContentsDelegate::IsFullscreenForTabOrPending(
-    const content::WebContents* source) const {
-  return html_fullscreen_;
-}
-
-blink::WebSecurityStyle CommonWebContentsDelegate::GetSecurityStyle(
-    content::WebContents* web_contents,
-    content::SecurityStyleExplanations* security_style_explanations) {
-  SecurityStateTabHelper* helper =
-      SecurityStateTabHelper::FromWebContents(web_contents);
-  DCHECK(helper);
-  security_state::SecurityInfo security_info;
-  helper->GetSecurityInfo(&security_info);
-  return security_state::GetSecurityStyle(security_info,
-                                          security_style_explanations);
-}
-
-void CommonWebContentsDelegate::DevToolsSaveToFile(const std::string& url,
-                                                   const std::string& content,
-                                                   bool save_as) {
-  base::FilePath path;
-  auto it = saved_files_.find(url);
-  if (it != saved_files_.end() && !save_as) {
-    path = it->second;
-  } else {
-    file_dialog::DialogSettings settings;
-    settings.parent_window = owner_window();
-    settings.force_detached = offscreen_;
-    settings.title = url;
-    settings.default_path = base::FilePath::FromUTF8Unsafe(url);
-    if (!file_dialog::ShowSaveDialog(settings, &path)) {
-      base::Value url_value(url);
-      web_contents_->CallClientFunction("DevToolsAPI.canceledSaveURL",
-                                        &url_value, nullptr, nullptr);
-      return;
-    }
-  }
-
-  saved_files_[url] = path;
-  // Notify DevTools.
-  base::Value url_value(url);
-  base::Value file_system_path_value(path.AsUTF8Unsafe());
-  web_contents_->CallClientFunction("DevToolsAPI.savedURL", &url_value,
-                                    &file_system_path_value, nullptr);
-  file_task_runner_->PostTask(FROM_HERE,
-                              base::BindOnce(&WriteToFile, path, content));
-}
-
-void CommonWebContentsDelegate::DevToolsAppendToFile(
-    const std::string& url,
-    const std::string& content) {
-  auto it = saved_files_.find(url);
-  if (it == saved_files_.end())
-    return;
-
-  // Notify DevTools.
-  base::Value url_value(url);
-  web_contents_->CallClientFunction("DevToolsAPI.appendedToURL", &url_value,
-                                    nullptr, nullptr);
-  file_task_runner_->PostTask(
-      FROM_HERE, base::BindOnce(&AppendToFile, it->second, content));
-}
-
-void CommonWebContentsDelegate::DevToolsRequestFileSystems() {
-  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
-  if (file_system_paths.empty()) {
-    base::ListValue empty_file_system_value;
-    web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
-                                      &empty_file_system_value, nullptr,
-                                      nullptr);
-    return;
-  }
-
-  std::vector<FileSystem> file_systems;
-  for (const auto& file_system_path : file_system_paths) {
-    base::FilePath path = base::FilePath::FromUTF8Unsafe(file_system_path);
-    std::string file_system_id =
-        RegisterFileSystem(GetDevToolsWebContents(), path);
-    FileSystem file_system = CreateFileSystemStruct(
-        GetDevToolsWebContents(), file_system_id, file_system_path);
-    file_systems.push_back(file_system);
-  }
-
-  base::ListValue file_system_value;
-  for (const auto& file_system : file_systems)
-    file_system_value.Append(CreateFileSystemValue(file_system));
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
-                                    &file_system_value, nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsAddFileSystem(
-    const base::FilePath& file_system_path) {
-  base::FilePath path = file_system_path;
-  if (path.empty()) {
-    std::vector<base::FilePath> paths;
-    file_dialog::DialogSettings settings;
-    settings.parent_window = owner_window();
-    settings.force_detached = offscreen_;
-    settings.properties = file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
-    if (!file_dialog::ShowOpenDialog(settings, &paths))
-      return;
-
-    path = paths[0];
-  }
-
-  std::string file_system_id =
-      RegisterFileSystem(GetDevToolsWebContents(), path);
-  if (IsDevToolsFileSystemAdded(GetDevToolsWebContents(), path.AsUTF8Unsafe()))
-    return;
-
-  FileSystem file_system = CreateFileSystemStruct(
-      GetDevToolsWebContents(), file_system_id, path.AsUTF8Unsafe());
-  std::unique_ptr<base::DictionaryValue> file_system_value(
-      CreateFileSystemValue(file_system));
-
-  auto* pref_service = GetPrefService(GetDevToolsWebContents());
-  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
-  update.Get()->SetWithoutPathExpansion(path.AsUTF8Unsafe(),
-                                        std::make_unique<base::Value>());
-
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemAdded",
-                                    file_system_value.get(), nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsRemoveFileSystem(
-    const base::FilePath& file_system_path) {
-  if (!web_contents_)
-    return;
-
-  std::string path = file_system_path.AsUTF8Unsafe();
-  storage::IsolatedContext::GetInstance()->RevokeFileSystemByPath(
-      file_system_path);
-
-  auto* pref_service = GetPrefService(GetDevToolsWebContents());
-  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
-  update.Get()->RemoveWithoutPathExpansion(path, nullptr);
-
-  base::Value file_system_path_value(path);
-  web_contents_->CallClientFunction("DevToolsAPI.fileSystemRemoved",
-                                    &file_system_path_value, nullptr, nullptr);
-}
-
-void CommonWebContentsDelegate::DevToolsIndexPath(
-    int request_id,
-    const std::string& file_system_path) {
-  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {
-    OnDevToolsIndexingDone(request_id, file_system_path);
-    return;
-  }
-  if (devtools_indexing_jobs_.count(request_id) != 0)
-    return;
-  devtools_indexing_jobs_[request_id] =
-      scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>(
-          devtools_file_system_indexer_->IndexPath(
-              file_system_path,
-              base::Bind(
-                  &CommonWebContentsDelegate::OnDevToolsIndexingWorkCalculated,
-                  base::Unretained(this), request_id, file_system_path),
-              base::Bind(&CommonWebContentsDelegate::OnDevToolsIndexingWorked,
-                         base::Unretained(this), request_id, file_system_path),
-              base::Bind(&CommonWebContentsDelegate::OnDevToolsIndexingDone,
-                         base::Unretained(this), request_id,
-                         file_system_path)));
-}
-
-void CommonWebContentsDelegate::DevToolsStopIndexing(int request_id) {
-  auto it = devtools_indexing_jobs_.find(request_id);
-  if (it == devtools_indexing_jobs_.end())
-    return;
-  it->second->Stop();
-  devtools_indexing_jobs_.erase(it);
-}
-
-void CommonWebContentsDelegate::DevToolsSearchInPath(
-    int request_id,
-    const std::string& file_system_path,
-    const std::string& query) {
-  if (!IsDevToolsFileSystemAdded(GetDevToolsWebContents(), file_system_path)) {
-    OnDevToolsSearchCompleted(request_id, file_system_path,
-                              std::vector<std::string>());
-    return;
-  }
-  devtools_file_system_indexer_->SearchInPath(
-      file_system_path, query,
-      base::Bind(&CommonWebContentsDelegate::OnDevToolsSearchCompleted,
-                 base::Unretained(this), request_id, file_system_path));
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingWorkCalculated(
-    int request_id,
-    const std::string& file_system_path,
-    int total_work) {
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  base::Value total_work_value(total_work);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingTotalWorkCalculated",
-                                    &request_id_value, &file_system_path_value,
-                                    &total_work_value);
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingWorked(
-    int request_id,
-    const std::string& file_system_path,
-    int worked) {
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  base::Value worked_value(worked);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingWorked",
-                                    &request_id_value, &file_system_path_value,
-                                    &worked_value);
-}
-
-void CommonWebContentsDelegate::OnDevToolsIndexingDone(
-    int request_id,
-    const std::string& file_system_path) {
-  devtools_indexing_jobs_.erase(request_id);
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  web_contents_->CallClientFunction("DevToolsAPI.indexingDone",
-                                    &request_id_value, &file_system_path_value,
-                                    nullptr);
-}
-
-void CommonWebContentsDelegate::OnDevToolsSearchCompleted(
-    int request_id,
-    const std::string& file_system_path,
-    const std::vector<std::string>& file_paths) {
-  base::ListValue file_paths_value;
-  for (const auto& file_path : file_paths) {
-    file_paths_value.AppendString(file_path);
-  }
-  base::Value request_id_value(request_id);
-  base::Value file_system_path_value(file_system_path);
-  web_contents_->CallClientFunction("DevToolsAPI.searchCompleted",
-                                    &request_id_value, &file_system_path_value,
-                                    &file_paths_value);
-}
-
-void CommonWebContentsDelegate::SetHtmlApiFullscreen(bool enter_fullscreen) {
-  // Window is already in fullscreen mode, save the state.
-  if (enter_fullscreen && owner_window_->IsFullscreen()) {
-    native_fullscreen_ = true;
-    html_fullscreen_ = true;
-    return;
-  }
-
-  // Exit html fullscreen state but not window's fullscreen mode.
-  if (!enter_fullscreen && native_fullscreen_) {
-    html_fullscreen_ = false;
-    return;
-  }
-
-  owner_window_->SetFullScreen(enter_fullscreen);
-  html_fullscreen_ = enter_fullscreen;
-  native_fullscreen_ = false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 61ff63793df5f1b83155aa56d64a7da6b34fa7da atom/browser/common_web_contents_delegate.h
  our    100644 5da5d20975b8e795e34c9d8c7649f6f0eb3d0a50 atom/browser/common_web_contents_delegate.h
@@ -1,202 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
-#define ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "brightray/browser/devtools_file_system_indexer.h"
-#include "brightray/browser/inspectable_web_contents_delegate.h"
-#include "brightray/browser/inspectable_web_contents_impl.h"
-#include "brightray/browser/inspectable_web_contents_view_delegate.h"
-#include "content/public/browser/web_contents_delegate.h"
-
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-#include "atom/browser/ui/autofill_popup.h"
-#endif
-
-using brightray::DevToolsFileSystemIndexer;
-
-namespace base {
-class SequencedTaskRunner;
-}
-
-namespace atom {
-
-class AtomBrowserContext;
-class NativeWindow;
-class WebDialogHelper;
-
-class CommonWebContentsDelegate
-    : public content::WebContentsDelegate,
-      public brightray::InspectableWebContentsDelegate,
-      public brightray::InspectableWebContentsViewDelegate {
- public:
-  CommonWebContentsDelegate();
-  ~CommonWebContentsDelegate() override;
-
-  // Creates a InspectableWebContents object and takes onwership of
-  // |web_contents|.
-  void InitWithWebContents(content::WebContents* web_contents,
-                           AtomBrowserContext* browser_context,
-                           bool is_guest);
-
-  // Set the window as owner window.
-  void SetOwnerWindow(NativeWindow* owner_window);
-  void SetOwnerWindow(content::WebContents* web_contents,
-                      NativeWindow* owner_window);
-
-  // Returns the WebContents managed by this delegate.
-  content::WebContents* GetWebContents() const;
-
-  // Returns the WebContents of devtools.
-  content::WebContents* GetDevToolsWebContents() const;
-
-  brightray::InspectableWebContents* managed_web_contents() const {
-    return web_contents_.get();
-  }
-
-  NativeWindow* owner_window() const { return owner_window_.get(); }
-
-  void set_ignore_menu_shortcuts(bool ignore) {
-    ignore_menu_shortcuts_ = ignore;
-  }
-
-  bool is_html_fullscreen() const { return html_fullscreen_; }
-
- protected:
-  // content::WebContentsDelegate:
-  content::WebContents* OpenURLFromTab(
-      content::WebContents* source,
-      const content::OpenURLParams& params) override;
-  bool CanOverscrollContent() const override;
-  content::ColorChooser* OpenColorChooser(
-      content::WebContents* web_contents,
-      SkColor color,
-      const std::vector<blink::mojom::ColorSuggestionPtr>& suggestions)
-      override;
-  void RunFileChooser(content::RenderFrameHost* render_frame_host,
-                      const content::FileChooserParams& params) override;
-  void EnumerateDirectory(content::WebContents* web_contents,
-                          int request_id,
-                          const base::FilePath& path) override;
-  void EnterFullscreenModeForTab(content::WebContents* source,
-                                 const GURL& origin) override;
-  void ExitFullscreenModeForTab(content::WebContents* source) override;
-  bool IsFullscreenForTabOrPending(
-      const content::WebContents* source) const override;
-  blink::WebSecurityStyle GetSecurityStyle(
-      content::WebContents* web_contents,
-      content::SecurityStyleExplanations* explanations) override;
-  void HandleKeyboardEvent(
-      content::WebContents* source,
-      const content::NativeWebKeyboardEvent& event) override;
-
-  // Autofill related events.
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  void ShowAutofillPopup(content::RenderFrameHost* frame_host,
-                         content::RenderFrameHost* embedder_frame_host,
-                         bool offscreen,
-                         const gfx::RectF& bounds,
-                         const std::vector<base::string16>& values,
-                         const std::vector<base::string16>& labels);
-  void HideAutofillPopup();
-#endif
-
-  // brightray::InspectableWebContentsDelegate:
-  void DevToolsSaveToFile(const std::string& url,
-                          const std::string& content,
-                          bool save_as) override;
-  void DevToolsAppendToFile(const std::string& url,
-                            const std::string& content) override;
-  void DevToolsRequestFileSystems() override;
-  void DevToolsAddFileSystem(const base::FilePath& path) override;
-  void DevToolsRemoveFileSystem(
-      const base::FilePath& file_system_path) override;
-  void DevToolsIndexPath(int request_id,
-                         const std::string& file_system_path) override;
-  void DevToolsStopIndexing(int request_id) override;
-  void DevToolsSearchInPath(int request_id,
-                            const std::string& file_system_path,
-                            const std::string& query) override;
-
-  // brightray::InspectableWebContentsViewDelegate:
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  gfx::ImageSkia GetDevToolsWindowIcon() override;
-#endif
-#if defined(USE_X11)
-  void GetDevToolsWindowWMClass(std::string* name,
-                                std::string* class_name) override;
-#endif
-
-  // Destroy the managed InspectableWebContents object.
-  void ResetManagedWebContents(bool async);
-
- private:
-  // DevTools index event callbacks.
-  void OnDevToolsIndexingWorkCalculated(int request_id,
-                                        const std::string& file_system_path,
-                                        int total_work);
-  void OnDevToolsIndexingWorked(int request_id,
-                                const std::string& file_system_path,
-                                int worked);
-  void OnDevToolsIndexingDone(int request_id,
-                              const std::string& file_system_path);
-  void OnDevToolsSearchCompleted(int request_id,
-                                 const std::string& file_system_path,
-                                 const std::vector<std::string>& file_paths);
-
-  // Set fullscreen mode triggered by html api.
-  void SetHtmlApiFullscreen(bool enter_fullscreen);
-
-  // The window that this WebContents belongs to.
-  base::WeakPtr<NativeWindow> owner_window_;
-
-  bool offscreen_ = false;
-  bool ignore_menu_shortcuts_ = false;
-
-  // Whether window is fullscreened by HTML5 api.
-  bool html_fullscreen_ = false;
-
-  // Whether window is fullscreened by window api.
-  bool native_fullscreen_ = false;
-
-  // UI related helper classes.
-#if defined(TOOLKIT_VIEWS) && !defined(OS_MACOSX)
-  std::unique_ptr<AutofillPopup> autofill_popup_;
-#endif
-  std::unique_ptr<WebDialogHelper> web_dialog_helper_;
-
-  scoped_refptr<DevToolsFileSystemIndexer> devtools_file_system_indexer_;
-
-  // Make sure BrowserContext is alwasys destroyed after WebContents.
-  scoped_refptr<AtomBrowserContext> browser_context_;
-
-  // The stored InspectableWebContents object.
-  // Notice that web_contents_ must be placed after dialog_manager_, so we can
-  // make sure web_contents_ is destroyed before dialog_manager_, otherwise a
-  // crash would happen.
-  std::unique_ptr<brightray::InspectableWebContents> web_contents_;
-
-  // Maps url to file path, used by the file requests sent from devtools.
-  typedef std::map<std::string, base::FilePath> PathsMap;
-  PathsMap saved_files_;
-
-  // Map id to index job, used for file system indexing requests from devtools.
-  typedef std::
-      map<int, scoped_refptr<DevToolsFileSystemIndexer::FileSystemIndexingJob>>
-          DevToolsIndexingJobsMap;
-  DevToolsIndexingJobsMap devtools_indexing_jobs_;
-
-  scoped_refptr<base::SequencedTaskRunner> file_task_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(CommonWebContentsDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
removed in remote
  base   100644 970132b47c1513883141989d38743284bbbe597a atom/browser/javascript_environment.cc
  our    100644 ddb689236bdfd958b05f28e5f5cb8c35ad47902a atom/browser/javascript_environment.cc
@@ -1,70 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/javascript_environment.h"
-
-#include <string>
-
-#include "base/command_line.h"
-#include "base/message_loop/message_loop.h"
-#include "base/task_scheduler/initialization_util.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "content/public/common/content_switches.h"
-#include "gin/array_buffer.h"
-#include "gin/v8_initializer.h"
-
-#include "atom/common/node_includes.h"
-#include "tracing/trace_event.h"
-
-namespace atom {
-
-JavascriptEnvironment::JavascriptEnvironment()
-    : initialized_(Initialize()),
-      isolate_holder_(base::ThreadTaskRunnerHandle::Get()),
-      isolate_(isolate_holder_.isolate()),
-      isolate_scope_(isolate_),
-      locker_(isolate_),
-      handle_scope_(isolate_),
-      context_(isolate_, v8::Context::New(isolate_)),
-      context_scope_(v8::Local<v8::Context>::New(isolate_, context_)) {}
-
-JavascriptEnvironment::~JavascriptEnvironment() = default;
-
-void JavascriptEnvironment::OnMessageLoopCreated() {
-  isolate_holder_.AddRunMicrotasksObserver();
-}
-
-void JavascriptEnvironment::OnMessageLoopDestroying() {
-  isolate_holder_.RemoveRunMicrotasksObserver();
-}
-
-bool JavascriptEnvironment::Initialize() {
-  auto* cmd = base::CommandLine::ForCurrentProcess();
-
-  // --js-flags.
-  std::string js_flags = cmd->GetSwitchValueASCII(switches::kJavaScriptFlags);
-  if (!js_flags.empty())
-    v8::V8::SetFlagsFromString(js_flags.c_str(), js_flags.size());
-
-  // The V8Platform of gin relies on Chromium's task schedule, which has not
-  // been started at this point, so we have to rely on Node's V8Platform.
-  platform_ = node::CreatePlatform(
-      base::RecommendedMaxNumberOfThreadsInPool(3, 8, 0.1, 0), nullptr);
-  v8::V8::InitializePlatform(platform_);
-  node::tracing::TraceEventHelper::SetTracingController(
-      new v8::TracingController());
-  gin::IsolateHolder::Initialize(
-      gin::IsolateHolder::kNonStrictMode, gin::IsolateHolder::kStableV8Extras,
-      gin::ArrayBufferAllocator::SharedInstance(),
-      nullptr /* external_reference_table */, false /* create_v8_platform */);
-  return true;
-}
-
-NodeEnvironment::NodeEnvironment(node::Environment* env) : env_(env) {}
-
-NodeEnvironment::~NodeEnvironment() {
-  node::FreeEnvironment(env_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 07cd602cf00dfd35aa03c3ffe821ebd267ff115e atom/browser/javascript_environment.h
  our    100644 bf05b687f8b338f25d37efcef39becd4346cb9e9 atom/browser/javascript_environment.h
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
-#define ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
-
-#include "base/macros.h"
-#include "gin/public/isolate_holder.h"
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-// Manage the V8 isolate and context automatically.
-class JavascriptEnvironment {
- public:
-  JavascriptEnvironment();
-  ~JavascriptEnvironment();
-
-  void OnMessageLoopCreated();
-  void OnMessageLoopDestroying();
-
-  node::MultiIsolatePlatform* platform() const { return platform_; }
-  v8::Isolate* isolate() const { return isolate_; }
-  v8::Local<v8::Context> context() const {
-    return v8::Local<v8::Context>::New(isolate_, context_);
-  }
-
- private:
-  bool Initialize();
-
-  // Leaked on exit.
-  node::MultiIsolatePlatform* platform_;
-
-  bool initialized_;
-  gin::IsolateHolder isolate_holder_;
-  v8::Isolate* isolate_;
-  v8::Isolate::Scope isolate_scope_;
-  v8::Locker locker_;
-  v8::HandleScope handle_scope_;
-  v8::UniquePersistent<v8::Context> context_;
-  v8::Context::Scope context_scope_;
-
-  DISALLOW_COPY_AND_ASSIGN(JavascriptEnvironment);
-};
-
-// Manage the Node Environment automatically.
-class NodeEnvironment {
- public:
-  explicit NodeEnvironment(node::Environment* env);
-  ~NodeEnvironment();
-
- private:
-  node::Environment* env_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeEnvironment);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
removed in remote
  base   100644 7a1a77cc2b1333ccfd56c77b98f8cfa7c5d8631d atom/browser/login_handler.cc
  our    100644 2063c6197fce449d1692f1b067c17e043b1d37e4 atom/browser/login_handler.cc
@@ -1,91 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/login_handler.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/values.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/web_contents.h"
-#include "net/base/auth.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-LoginHandler::LoginHandler(
-    net::URLRequest* request,
-    const net::AuthChallengeInfo& auth_info,
-    const net::NetworkDelegate::AuthCallback& callback,
-    net::AuthCredentials* credentials,
-    const content::ResourceRequestInfo* resource_request_info)
-    : credentials_(credentials),
-      auth_info_(auth_info),
-      auth_callback_(std::move(callback)),
-      weak_factory_(this) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  std::unique_ptr<base::DictionaryValue> request_details(
-      new base::DictionaryValue);
-  FillRequestDetails(request_details.get(), request);
-
-  web_contents_getter_ =
-      resource_request_info->GetWebContentsGetterForRequest();
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(&Browser::RequestLogin, base::Unretained(Browser::Get()),
-                     base::RetainedRef(this), std::move(request_details)));
-}
-
-LoginHandler::~LoginHandler() {}
-
-void LoginHandler::Login(const base::string16& username,
-                         const base::string16& password) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&LoginHandler::DoLogin, weak_factory_.GetWeakPtr(),
-                     username, password));
-}
-
-void LoginHandler::CancelAuth() {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&LoginHandler::DoCancelAuth, weak_factory_.GetWeakPtr()));
-}
-
-void LoginHandler::NotifyRequestDestroyed() {
-  auth_callback_.Reset();
-  credentials_ = nullptr;
-  weak_factory_.InvalidateWeakPtrs();
-}
-
-content::WebContents* LoginHandler::GetWebContents() const {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  return web_contents_getter_.Run();
-}
-
-void LoginHandler::DoCancelAuth() {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  if (!auth_callback_.is_null())
-    std::move(auth_callback_)
-        .Run(net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_CANCEL_AUTH);
-}
-
-void LoginHandler::DoLogin(const base::string16& username,
-                           const base::string16& password) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-  if (!auth_callback_.is_null()) {
-    credentials_->Set(username, password);
-    std::move(auth_callback_)
-        .Run(net::NetworkDelegate::AUTH_REQUIRED_RESPONSE_SET_AUTH);
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 52ec1abf5b1a8e5353dd294b946275dc229ef6ab atom/browser/login_handler.h
  our    100644 e7f1c5be0094506e01d2cccc0073fa864dfefb56 atom/browser/login_handler.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_LOGIN_HANDLER_H_
-#define ATOM_BROWSER_LOGIN_HANDLER_H_
-
-#include "base/callback.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "base/strings/string16.h"
-#include "content/public/browser/resource_request_info.h"
-#include "net/base/network_delegate.h"
-
-namespace content {
-class WebContents;
-}
-
-namespace atom {
-
-// Handles the HTTP basic auth, must be created on IO thread.
-class LoginHandler : public base::RefCountedThreadSafe<LoginHandler> {
- public:
-  LoginHandler(net::URLRequest* request,
-               const net::AuthChallengeInfo& auth_info,
-               const net::NetworkDelegate::AuthCallback& callback,
-               net::AuthCredentials* credentials,
-               const content::ResourceRequestInfo* resource_request_info);
-
-  // The auth is cancelled, must be called on UI thread.
-  void CancelAuth();
-
-  // The URLRequest associated with the auth is destroyed.
-  void NotifyRequestDestroyed();
-
-  // Login with |username| and |password|, must be called on UI thread.
-  void Login(const base::string16& username, const base::string16& password);
-
-  // Returns the WebContents associated with the request, must be called on UI
-  // thread.
-  content::WebContents* GetWebContents() const;
-
-  const net::AuthChallengeInfo* auth_info() const { return &auth_info_; }
-
- private:
-  friend class base::RefCountedThreadSafe<LoginHandler>;
-  friend class base::DeleteHelper<LoginHandler>;
-
-  ~LoginHandler();
-
-  // Must be called on IO thread.
-  void DoCancelAuth();
-  void DoLogin(const base::string16& username, const base::string16& password);
-
-  // Credentials to be used for the auth.
-  net::AuthCredentials* credentials_;
-
-  // Who/where/what asked for the authentication.
-  const net::AuthChallengeInfo& auth_info_;
-
-  // WebContents associated with the login request.
-  content::ResourceRequestInfo::WebContentsGetter web_contents_getter_;
-
-  // Called with preferred value of net::NetworkDelegate::AuthRequiredResponse.
-  net::NetworkDelegate::AuthCallback auth_callback_;
-
-  base::WeakPtrFactory<LoginHandler> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(LoginHandler);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_LOGIN_HANDLER_H_
removed in remote
  base   100644 9fafb054b09abce8b3ef6a4af1f778c80d919f3d atom/browser/mac/atom_application.h
  our    100644 b0a8742ee98bc4990bf38a25218e87e386f115e0 atom/browser/mac/atom_application.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/mac/scoped_sending_event.h"
-
-@interface AtomApplication : NSApplication <CrAppProtocol,
-                                            CrAppControlProtocol,
-                                            NSUserActivityDelegate> {
- @private
-  BOOL handlingSendEvent_;
-  base::scoped_nsobject<NSUserActivity> currentActivity_ API_AVAILABLE(macosx(10.10));
-  NSCondition* handoffLock_;
-  BOOL updateReceived_;
-  base::Callback<bool()> shouldShutdown_;
-}
-
-+ (AtomApplication*)sharedApplication;
-
-- (void)setShutdownHandler:(base::Callback<bool()>)handler;
-
-// CrAppProtocol:
-- (BOOL)isHandlingSendEvent;
-
-// CrAppControlProtocol:
-- (void)setHandlingSendEvent:(BOOL)handlingSendEvent;
-
-- (NSUserActivity*)getCurrentActivity API_AVAILABLE(macosx(10.10));
-- (void)setCurrentActivity:(NSString*)type
-              withUserInfo:(NSDictionary*)userInfo
-            withWebpageURL:(NSURL*)webpageURL;
-- (void)invalidateCurrentActivity;
-- (void)updateCurrentActivity:(NSString*)type
-                 withUserInfo:(NSDictionary*)userInfo;
-
-@end
removed in remote
  base   100644 cc9c6accc83dcb7260413fcc9a1184368724a3fa atom/browser/mac/atom_application.mm
  our    100644 eb00a415bf243853a78b3c4e4eafa66905a2ccf3 atom/browser/mac/atom_application.mm
@@ -1,191 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/mac/atom_application.h"
-
-#include "atom/browser/browser.h"
-#import "atom/browser/mac/atom_application_delegate.h"
-#include "atom/browser/mac/dict_util.h"
-#include "base/auto_reset.h"
-#include "base/strings/sys_string_conversions.h"
-#include "content/public/browser/browser_accessibility_state.h"
-
-namespace {
-
-inline void dispatch_sync_main(dispatch_block_t block) {
-  if ([NSThread isMainThread])
-    block();
-  else
-    dispatch_sync(dispatch_get_main_queue(), block);
-}
-
-}  // namespace
-
-@implementation AtomApplication
-
-+ (AtomApplication*)sharedApplication {
-  return (AtomApplication*)[super sharedApplication];
-}
-
-- (void)terminate:(id)sender {
-  if (shouldShutdown_ && !shouldShutdown_.Run())
-    return;  // User will call Quit later.
-
-  // We simply try to close the browser, which in turn will try to close the
-  // windows. Termination can proceed if all windows are closed or window close
-  // can be cancelled which will abort termination.
-  atom::Browser::Get()->Quit();
-}
-
-- (void)setShutdownHandler:(base::Callback<bool()>)handler {
-  shouldShutdown_ = std::move(handler);
-}
-
-- (BOOL)isHandlingSendEvent {
-  return handlingSendEvent_;
-}
-
-- (void)sendEvent:(NSEvent*)event {
-  base::AutoReset<BOOL> scoper(&handlingSendEvent_, YES);
-  [super sendEvent:event];
-}
-
-- (void)setHandlingSendEvent:(BOOL)handlingSendEvent {
-  handlingSendEvent_ = handlingSendEvent;
-}
-
-- (void)setCurrentActivity:(NSString*)type
-              withUserInfo:(NSDictionary*)userInfo
-            withWebpageURL:(NSURL*)webpageURL {
-  if (@available(macOS 10.10, *)) {
-    currentActivity_ = base::scoped_nsobject<NSUserActivity>(
-        [[NSUserActivity alloc] initWithActivityType:type]);
-    [currentActivity_ setUserInfo:userInfo];
-    [currentActivity_ setWebpageURL:webpageURL];
-    [currentActivity_ setDelegate:self];
-    [currentActivity_ becomeCurrent];
-    [currentActivity_ setNeedsSave:YES];
-  }
-}
-
-- (NSUserActivity*)getCurrentActivity {
-  return currentActivity_.get();
-}
-
-- (void)invalidateCurrentActivity {
-  if (currentActivity_) {
-    [currentActivity_ invalidate];
-    currentActivity_.reset();
-  }
-}
-
-- (void)updateCurrentActivity:(NSString*)type
-                 withUserInfo:(NSDictionary*)userInfo {
-  if (currentActivity_) {
-    [currentActivity_ addUserInfoEntriesFromDictionary:userInfo];
-  }
-
-  [handoffLock_ lock];
-  updateReceived_ = YES;
-  [handoffLock_ signal];
-  [handoffLock_ unlock];
-}
-
-- (void)userActivityWillSave:(NSUserActivity*)userActivity
-    API_AVAILABLE(macosx(10.10)) {
-  __block BOOL shouldWait = NO;
-  dispatch_sync_main(^{
-    std::string activity_type(
-        base::SysNSStringToUTF8(userActivity.activityType));
-    std::unique_ptr<base::DictionaryValue> user_info =
-        atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-
-    atom::Browser* browser = atom::Browser::Get();
-    shouldWait =
-        browser->UpdateUserActivityState(activity_type, *user_info) ? YES : NO;
-  });
-
-  if (shouldWait) {
-    [handoffLock_ lock];
-    updateReceived_ = NO;
-    while (!updateReceived_) {
-      BOOL isSignaled =
-          [handoffLock_ waitUntilDate:[NSDate dateWithTimeIntervalSinceNow:1]];
-      if (!isSignaled)
-        break;
-    }
-    [handoffLock_ unlock];
-  }
-
-  [userActivity setNeedsSave:YES];
-}
-
-- (void)userActivityWasContinued:(NSUserActivity*)userActivity
-    API_AVAILABLE(macosx(10.10)) {
-  dispatch_async(dispatch_get_main_queue(), ^{
-    std::string activity_type(
-        base::SysNSStringToUTF8(userActivity.activityType));
-    std::unique_ptr<base::DictionaryValue> user_info =
-        atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-
-    atom::Browser* browser = atom::Browser::Get();
-    browser->UserActivityWasContinued(activity_type, *user_info);
-  });
-  [userActivity setNeedsSave:YES];
-}
-
-- (void)awakeFromNib {
-  [[NSAppleEventManager sharedAppleEventManager]
-      setEventHandler:self
-          andSelector:@selector(handleURLEvent:withReplyEvent:)
-        forEventClass:kInternetEventClass
-           andEventID:kAEGetURL];
-
-  handoffLock_ = [NSCondition new];
-}
-
-- (void)handleURLEvent:(NSAppleEventDescriptor*)event
-        withReplyEvent:(NSAppleEventDescriptor*)replyEvent {
-  NSString* url =
-      [[event paramDescriptorForKeyword:keyDirectObject] stringValue];
-  atom::Browser::Get()->OpenURL(base::SysNSStringToUTF8(url));
-}
-
-- (bool)voiceOverEnabled {
-  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
-  [defaults addSuiteNamed:@"com.apple.universalaccess"];
-  [defaults synchronize];
-
-  return [defaults boolForKey:@"voiceOverOnOffKey"];
-}
-
-- (void)accessibilitySetValue:(id)value forAttribute:(NSString*)attribute {
-  // Undocumented attribute that VoiceOver happens to set while running.
-  // Chromium uses this too, even though it's not exactly right.
-  if ([attribute isEqualToString:@"AXEnhancedUserInterface"]) {
-    bool enableAccessibility = ([self voiceOverEnabled] && [value boolValue]);
-    [self updateAccessibilityEnabled:enableAccessibility];
-  } else if ([attribute isEqualToString:@"AXManualAccessibility"]) {
-    [self updateAccessibilityEnabled:[value boolValue]];
-  }
-  return [super accessibilitySetValue:value forAttribute:attribute];
-}
-
-- (void)updateAccessibilityEnabled:(BOOL)enabled {
-  auto* ax_state = content::BrowserAccessibilityState::GetInstance();
-
-  if (enabled) {
-    ax_state->OnScreenReaderDetected();
-  } else {
-    ax_state->DisableAccessibility();
-  }
-
-  atom::Browser::Get()->OnAccessibilitySupportChanged();
-}
-
-- (void)orderFrontStandardAboutPanel:(id)sender {
-  atom::Browser::Get()->ShowAboutPanel();
-}
-
-@end
removed in remote
  base   100644 3e5c59c3ff3dd287f94837de14391d7d6fb56b79 atom/browser/mac/atom_application_delegate.h
  our    100644 835b63f8308e93353ee39a4c249824dfda9cb62c atom/browser/mac/atom_application_delegate.h
@@ -1,17 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import <Cocoa/Cocoa.h>
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-@interface AtomApplicationDelegate : NSObject <NSApplicationDelegate> {
- @private
-  base::scoped_nsobject<AtomMenuController> menu_controller_;
-}
-
-// Sets the menu that will be returned in "applicationDockMenu:".
-- (void)setApplicationDockMenu:(atom::AtomMenuModel*)model;
-
-@end
removed in remote
  base   100644 f4db929bf575e88575e38d08d9961e1b02ef05dc atom/browser/mac/atom_application_delegate.mm
  our    100644 683f7a84bcaa2c47bb78cf299314a5afeb15639b atom/browser/mac/atom_application_delegate.mm
@@ -1,136 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/mac/atom_application_delegate.h"
-
-#include "atom/browser/browser.h"
-#import "atom/browser/mac/atom_application.h"
-#include "atom/browser/mac/dict_util.h"
-#include "base/allocator/allocator_shim.h"
-#include "base/allocator/buildflags.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_objc_class_swizzler.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/values.h"
-
-#if BUILDFLAG(USE_ALLOCATOR_SHIM)
-// On macOS 10.12, the IME system attempts to allocate a 2^64 size buffer,
-// which would typically cause an OOM crash. To avoid this, the problematic
-// method is swizzled out and the make-OOM-fatal bit is disabled for the
-// duration of the original call. https://crbug.com/654695
-static base::mac::ScopedObjCClassSwizzler* g_swizzle_imk_input_session;
-@interface OOMDisabledIMKInputSession : NSObject
-@end
-@implementation OOMDisabledIMKInputSession
-- (void)_coreAttributesFromRange:(NSRange)range
-                 whichAttributes:(long long)attributes
-               completionHandler:(void (^)(void))block {
-  // The allocator flag is per-process, so other threads may temporarily
-  // not have fatal OOM occur while this method executes, but it is better
-  // than crashing when using IME.
-  base::allocator::SetCallNewHandlerOnMallocFailure(false);
-  g_swizzle_imk_input_session->GetOriginalImplementation()(self, _cmd, range,
-                                                           attributes, block);
-  base::allocator::SetCallNewHandlerOnMallocFailure(true);
-}
-@end
-#endif  // BUILDFLAG(USE_ALLOCATOR_SHIM)
-
-@implementation AtomApplicationDelegate
-
-- (void)setApplicationDockMenu:(atom::AtomMenuModel*)model {
-  menu_controller_.reset([[AtomMenuController alloc] initWithModel:model
-                                             useDefaultAccelerator:NO]);
-}
-
-- (void)applicationWillFinishLaunching:(NSNotification*)notify {
-  // Don't add the "Enter Full Screen" menu item automatically.
-  [[NSUserDefaults standardUserDefaults]
-      setBool:NO
-       forKey:@"NSFullScreenMenuItemEverywhere"];
-
-  atom::Browser::Get()->WillFinishLaunching();
-}
-
-- (void)applicationDidFinishLaunching:(NSNotification*)notify {
-  NSUserNotification* user_notification =
-      [notify userInfo][(id) @"NSApplicationLaunchUserNotificationKey"];
-
-  if (user_notification.userInfo != nil) {
-    std::unique_ptr<base::DictionaryValue> launch_info =
-        atom::NSDictionaryToDictionaryValue(user_notification.userInfo);
-    atom::Browser::Get()->DidFinishLaunching(*launch_info);
-  } else {
-    atom::Browser::Get()->DidFinishLaunching(base::DictionaryValue());
-  }
-
-#if BUILDFLAG(USE_ALLOCATOR_SHIM)
-  // Disable fatal OOM to hack around an OS bug https://crbug.com/654695.
-  if (base::mac::IsOS10_12()) {
-    g_swizzle_imk_input_session = new base::mac::ScopedObjCClassSwizzler(
-        NSClassFromString(@"IMKInputSession"),
-        [OOMDisabledIMKInputSession class],
-        @selector(_coreAttributesFromRange:whichAttributes:completionHandler:));
-  }
-#endif
-}
-
-- (NSMenu*)applicationDockMenu:(NSApplication*)sender {
-  if (menu_controller_)
-    return [menu_controller_ menu];
-  else
-    return nil;
-}
-
-- (BOOL)application:(NSApplication*)sender openFile:(NSString*)filename {
-  std::string filename_str(base::SysNSStringToUTF8(filename));
-  return atom::Browser::Get()->OpenFile(filename_str) ? YES : NO;
-}
-
-- (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
-                    hasVisibleWindows:(BOOL)flag {
-  atom::Browser* browser = atom::Browser::Get();
-  browser->Activate(static_cast<bool>(flag));
-  return flag;
-}
-
-- (BOOL)application:(NSApplication*)sender
-    continueUserActivity:(NSUserActivity*)userActivity
-      restorationHandler:
-          (void (^)(NSArray* restorableObjects))restorationHandler
-    API_AVAILABLE(macosx(10.10)) {
-  std::string activity_type(base::SysNSStringToUTF8(userActivity.activityType));
-  std::unique_ptr<base::DictionaryValue> user_info =
-      atom::NSDictionaryToDictionaryValue(userActivity.userInfo);
-  if (!user_info)
-    return NO;
-
-  atom::Browser* browser = atom::Browser::Get();
-  return browser->ContinueUserActivity(activity_type, *user_info) ? YES : NO;
-}
-
-- (BOOL)application:(NSApplication*)application
-    willContinueUserActivityWithType:(NSString*)userActivityType {
-  std::string activity_type(base::SysNSStringToUTF8(userActivityType));
-
-  atom::Browser* browser = atom::Browser::Get();
-  return browser->WillContinueUserActivity(activity_type) ? YES : NO;
-}
-
-- (void)application:(NSApplication*)application
-    didFailToContinueUserActivityWithType:(NSString*)userActivityType
-                                    error:(NSError*)error {
-  std::string activity_type(base::SysNSStringToUTF8(userActivityType));
-  std::string error_message(
-      base::SysNSStringToUTF8([error localizedDescription]));
-
-  atom::Browser* browser = atom::Browser::Get();
-  browser->DidFailToContinueUserActivity(activity_type, error_message);
-}
-
-- (IBAction)newWindowForTab:(id)sender {
-  atom::Browser::Get()->NewWindowForTab();
-}
-
-@end
removed in remote
  base   100644 2627c704d21fef9df262d4062deaef12650f21f6 atom/browser/native_window.cc
  our    100644 4ff2bcfcabfd34d8563f9ed213c03655a99dd9c6 atom/browser/native_window.cc
@@ -1,567 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window.h"
-
-#include <algorithm>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/color_util.h"
-#include "atom/common/options_switches.h"
-#include "native_mate/dictionary.h"
-#include "ui/views/widget/widget.h"
-
-#if defined(OS_WIN)
-#include "ui/base/win/shell.h"
-#include "ui/display/win/screen_win.h"
-#endif
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::NativeWindowRelay);
-
-namespace atom {
-
-namespace {
-
-#if defined(OS_WIN)
-gfx::Size GetExpandedWindowSize(const NativeWindow* window, gfx::Size size) {
-  if (!window->transparent() || !ui::win::IsAeroGlassEnabled())
-    return size;
-
-  gfx::Size min_size = display::win::ScreenWin::ScreenToDIPSize(
-      window->GetAcceleratedWidget(), gfx::Size(64, 64));
-
-  // Some AMD drivers can't display windows that are less than 64x64 pixels,
-  // so expand them to be at least that size. http://crbug.com/286609
-  gfx::Size expanded(std::max(size.width(), min_size.width()),
-                     std::max(size.height(), min_size.height()));
-  return expanded;
-}
-#endif
-
-}  // namespace
-
-NativeWindow::NativeWindow(const mate::Dictionary& options,
-                           NativeWindow* parent)
-    : widget_(new views::Widget), parent_(parent), weak_factory_(this) {
-  options.Get(options::kFrame, &has_frame_);
-  options.Get(options::kTransparent, &transparent_);
-  options.Get(options::kEnableLargerThanScreen, &enable_larger_than_screen_);
-
-  if (parent)
-    options.Get("modal", &is_modal_);
-
-  WindowList::AddWindow(this);
-}
-
-NativeWindow::~NativeWindow() {
-  // It's possible that the windows gets destroyed before it's closed, in that
-  // case we need to ensure the OnWindowClosed message is still notified.
-  NotifyWindowClosed();
-}
-
-void NativeWindow::InitFromOptions(const mate::Dictionary& options) {
-  // Setup window from options.
-  int x = -1, y = -1;
-  bool center;
-  if (options.Get(options::kX, &x) && options.Get(options::kY, &y)) {
-    SetPosition(gfx::Point(x, y));
-
-#if defined(OS_WIN)
-    // FIXME(felixrieseberg): Dirty, dirty workaround for
-    // https://github.com/electron/electron/issues/10862
-    // Somehow, we need to call `SetBounds` twice to get
-    // usable results. The root cause is still unknown.
-    SetPosition(gfx::Point(x, y));
-#endif
-  } else if (options.Get(options::kCenter, &center) && center) {
-    Center();
-  }
-  // On Linux and Window we may already have maximum size defined.
-  extensions::SizeConstraints size_constraints(GetContentSizeConstraints());
-  int min_height = 0, min_width = 0;
-  if (options.Get(options::kMinHeight, &min_height) |
-      options.Get(options::kMinWidth, &min_width)) {
-    size_constraints.set_minimum_size(gfx::Size(min_width, min_height));
-  }
-  int max_height = INT_MAX, max_width = INT_MAX;
-  if (options.Get(options::kMaxHeight, &max_height) |
-      options.Get(options::kMaxWidth, &max_width)) {
-    size_constraints.set_maximum_size(gfx::Size(max_width, max_height));
-  }
-  bool use_content_size = false;
-  options.Get(options::kUseContentSize, &use_content_size);
-  if (use_content_size) {
-    SetContentSizeConstraints(size_constraints);
-  } else {
-    SetSizeConstraints(size_constraints);
-  }
-#if defined(OS_WIN) || defined(USE_X11)
-  bool resizable;
-  if (options.Get(options::kResizable, &resizable)) {
-    SetResizable(resizable);
-  }
-  bool closable;
-  if (options.Get(options::kClosable, &closable)) {
-    SetClosable(closable);
-  }
-#endif
-  bool movable;
-  if (options.Get(options::kMovable, &movable)) {
-    SetMovable(movable);
-  }
-  bool has_shadow;
-  if (options.Get(options::kHasShadow, &has_shadow)) {
-    SetHasShadow(has_shadow);
-  }
-  double opacity;
-  if (options.Get(options::kOpacity, &opacity)) {
-    SetOpacity(opacity);
-  }
-  bool top;
-  if (options.Get(options::kAlwaysOnTop, &top) && top) {
-    SetAlwaysOnTop(true);
-  }
-  bool fullscreenable = true;
-  bool fullscreen = false;
-  if (options.Get(options::kFullscreen, &fullscreen) && !fullscreen) {
-    // Disable fullscreen button if 'fullscreen' is specified to false.
-#if defined(OS_MACOSX)
-    fullscreenable = false;
-#endif
-  }
-  // Overriden by 'fullscreenable'.
-  options.Get(options::kFullScreenable, &fullscreenable);
-  SetFullScreenable(fullscreenable);
-  if (fullscreen) {
-    SetFullScreen(true);
-  }
-  bool skip;
-  if (options.Get(options::kSkipTaskbar, &skip)) {
-    SetSkipTaskbar(skip);
-  }
-  bool kiosk;
-  if (options.Get(options::kKiosk, &kiosk) && kiosk) {
-    SetKiosk(kiosk);
-  }
-#if defined(OS_MACOSX)
-  std::string type;
-  if (options.Get(options::kVibrancyType, &type)) {
-    SetVibrancy(type);
-  }
-#endif
-  std::string color;
-  if (options.Get(options::kBackgroundColor, &color)) {
-    SetBackgroundColor(ParseHexColor(color));
-  } else if (!transparent()) {
-    // For normal window, use white as default background.
-    SetBackgroundColor(SK_ColorWHITE);
-  }
-  std::string title(Browser::Get()->GetName());
-  options.Get(options::kTitle, &title);
-  SetTitle(title);
-
-  // Then show it.
-  bool show = true;
-  options.Get(options::kShow, &show);
-  if (show)
-    Show();
-}
-
-bool NativeWindow::IsClosed() const {
-  return is_closed_;
-}
-
-void NativeWindow::SetSize(const gfx::Size& size, bool animate) {
-  SetBounds(gfx::Rect(GetPosition(), size), animate);
-}
-
-gfx::Size NativeWindow::GetSize() {
-  return GetBounds().size();
-}
-
-void NativeWindow::SetPosition(const gfx::Point& position, bool animate) {
-  SetBounds(gfx::Rect(position, GetSize()), animate);
-}
-
-gfx::Point NativeWindow::GetPosition() {
-  return GetBounds().origin();
-}
-
-void NativeWindow::SetContentSize(const gfx::Size& size, bool animate) {
-  SetSize(ContentBoundsToWindowBounds(gfx::Rect(size)).size(), animate);
-}
-
-gfx::Size NativeWindow::GetContentSize() {
-  return GetContentBounds().size();
-}
-
-void NativeWindow::SetContentBounds(const gfx::Rect& bounds, bool animate) {
-  SetBounds(ContentBoundsToWindowBounds(bounds), animate);
-}
-
-gfx::Rect NativeWindow::GetContentBounds() {
-  return WindowBoundsToContentBounds(GetBounds());
-}
-
-void NativeWindow::SetSizeConstraints(
-    const extensions::SizeConstraints& window_constraints) {
-  extensions::SizeConstraints content_constraints(GetContentSizeConstraints());
-  if (window_constraints.HasMaximumSize()) {
-    gfx::Rect max_bounds = WindowBoundsToContentBounds(
-        gfx::Rect(window_constraints.GetMaximumSize()));
-    content_constraints.set_maximum_size(max_bounds.size());
-  }
-  if (window_constraints.HasMinimumSize()) {
-    gfx::Rect min_bounds = WindowBoundsToContentBounds(
-        gfx::Rect(window_constraints.GetMinimumSize()));
-    content_constraints.set_minimum_size(min_bounds.size());
-  }
-  SetContentSizeConstraints(content_constraints);
-}
-
-extensions::SizeConstraints NativeWindow::GetSizeConstraints() const {
-  extensions::SizeConstraints content_constraints = GetContentSizeConstraints();
-  extensions::SizeConstraints window_constraints;
-  if (content_constraints.HasMaximumSize()) {
-    gfx::Rect max_bounds = ContentBoundsToWindowBounds(
-        gfx::Rect(content_constraints.GetMaximumSize()));
-    window_constraints.set_maximum_size(max_bounds.size());
-  }
-  if (content_constraints.HasMinimumSize()) {
-    gfx::Rect min_bounds = ContentBoundsToWindowBounds(
-        gfx::Rect(content_constraints.GetMinimumSize()));
-    window_constraints.set_minimum_size(min_bounds.size());
-  }
-  return window_constraints;
-}
-
-void NativeWindow::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  size_constraints_ = size_constraints;
-}
-
-extensions::SizeConstraints NativeWindow::GetContentSizeConstraints() const {
-  return size_constraints_;
-}
-
-void NativeWindow::SetMinimumSize(const gfx::Size& size) {
-  extensions::SizeConstraints size_constraints;
-  size_constraints.set_minimum_size(size);
-  SetSizeConstraints(size_constraints);
-}
-
-gfx::Size NativeWindow::GetMinimumSize() const {
-  return GetSizeConstraints().GetMinimumSize();
-}
-
-void NativeWindow::SetMaximumSize(const gfx::Size& size) {
-  extensions::SizeConstraints size_constraints;
-  size_constraints.set_maximum_size(size);
-  SetSizeConstraints(size_constraints);
-}
-
-gfx::Size NativeWindow::GetMaximumSize() const {
-  return GetSizeConstraints().GetMaximumSize();
-}
-
-gfx::Size NativeWindow::GetContentMinimumSize() const {
-  return GetContentSizeConstraints().GetMinimumSize();
-}
-
-gfx::Size NativeWindow::GetContentMaximumSize() const {
-  gfx::Size maximum_size = GetContentSizeConstraints().GetMaximumSize();
-#if defined(OS_WIN)
-  return GetContentSizeConstraints().HasMaximumSize()
-             ? GetExpandedWindowSize(this, maximum_size)
-             : maximum_size;
-#else
-  return maximum_size;
-#endif
-}
-
-void NativeWindow::SetSheetOffset(const double offsetX, const double offsetY) {
-  sheet_offset_x_ = offsetX;
-  sheet_offset_y_ = offsetY;
-}
-
-double NativeWindow::GetSheetOffsetX() {
-  return sheet_offset_x_;
-}
-
-double NativeWindow::GetSheetOffsetY() {
-  return sheet_offset_y_;
-}
-
-void NativeWindow::SetRepresentedFilename(const std::string& filename) {}
-
-std::string NativeWindow::GetRepresentedFilename() {
-  return "";
-}
-
-void NativeWindow::SetDocumentEdited(bool edited) {}
-
-bool NativeWindow::IsDocumentEdited() {
-  return false;
-}
-
-void NativeWindow::SetFocusable(bool focusable) {}
-
-void NativeWindow::SetMenu(AtomMenuModel* menu) {}
-
-void NativeWindow::SetParentWindow(NativeWindow* parent) {
-  parent_ = parent;
-}
-
-void NativeWindow::SetAutoHideCursor(bool auto_hide) {}
-
-void NativeWindow::SelectPreviousTab() {}
-
-void NativeWindow::SelectNextTab() {}
-
-void NativeWindow::MergeAllWindows() {}
-
-void NativeWindow::MoveTabToNewWindow() {}
-
-void NativeWindow::ToggleTabBar() {}
-
-bool NativeWindow::AddTabbedWindow(NativeWindow* window) {
-  return true;  // for non-Mac platforms
-}
-
-void NativeWindow::SetVibrancy(const std::string& filename) {}
-
-void NativeWindow::SetTouchBar(
-    const std::vector<mate::PersistentDictionary>& items) {}
-
-void NativeWindow::RefreshTouchBarItem(const std::string& item_id) {}
-
-void NativeWindow::SetEscapeTouchBarItem(
-    const mate::PersistentDictionary& item) {}
-
-void NativeWindow::SetAutoHideMenuBar(bool auto_hide) {}
-
-bool NativeWindow::IsMenuBarAutoHide() {
-  return false;
-}
-
-void NativeWindow::SetMenuBarVisibility(bool visible) {}
-
-bool NativeWindow::IsMenuBarVisible() {
-  return true;
-}
-
-bool NativeWindow::SetWindowButtonVisibility(bool visible) {
-  return false;
-}
-
-double NativeWindow::GetAspectRatio() {
-  return aspect_ratio_;
-}
-
-gfx::Size NativeWindow::GetAspectRatioExtraSize() {
-  return aspect_ratio_extraSize_;
-}
-
-void NativeWindow::SetAspectRatio(double aspect_ratio,
-                                  const gfx::Size& extra_size) {
-  aspect_ratio_ = aspect_ratio;
-  aspect_ratio_extraSize_ = extra_size;
-}
-
-void NativeWindow::PreviewFile(const std::string& path,
-                               const std::string& display_name) {}
-
-void NativeWindow::CloseFilePreview() {}
-
-void NativeWindow::NotifyWindowRequestPreferredWith(int* width) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.RequestPreferredWidth(width);
-}
-
-void NativeWindow::NotifyWindowCloseButtonClicked() {
-  // First ask the observers whether we want to close.
-  bool prevent_default = false;
-  for (NativeWindowObserver& observer : observers_)
-    observer.WillCloseWindow(&prevent_default);
-  if (prevent_default) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  // Then ask the observers how should we close the window.
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnCloseButtonClicked(&prevent_default);
-  if (prevent_default)
-    return;
-
-  CloseImmediately();
-}
-
-void NativeWindow::NotifyWindowClosed() {
-  if (is_closed_)
-    return;
-
-  WindowList::RemoveWindow(this);
-
-  is_closed_ = true;
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowClosed();
-}
-
-void NativeWindow::NotifyWindowEndSession() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEndSession();
-}
-
-void NativeWindow::NotifyWindowBlur() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowBlur();
-}
-
-void NativeWindow::NotifyWindowFocus() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowFocus();
-}
-
-void NativeWindow::NotifyWindowShow() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowShow();
-}
-
-void NativeWindow::NotifyWindowHide() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowHide();
-}
-
-void NativeWindow::NotifyWindowMaximize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMaximize();
-}
-
-void NativeWindow::NotifyWindowUnmaximize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowUnmaximize();
-}
-
-void NativeWindow::NotifyWindowMinimize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMinimize();
-}
-
-void NativeWindow::NotifyWindowRestore() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowRestore();
-}
-
-void NativeWindow::NotifyWindowWillResize(const gfx::Rect& new_bounds,
-                                          bool* prevent_default) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowWillResize(new_bounds, prevent_default);
-}
-
-void NativeWindow::NotifyWindowResize() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowResize();
-}
-
-void NativeWindow::NotifyWindowMove() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMove();
-}
-
-void NativeWindow::NotifyWindowMoved() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMoved();
-}
-
-void NativeWindow::NotifyWindowEnterFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEnterFullScreen();
-}
-
-void NativeWindow::NotifyWindowScrollTouchBegin() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowScrollTouchBegin();
-}
-
-void NativeWindow::NotifyWindowScrollTouchEnd() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowScrollTouchEnd();
-}
-
-void NativeWindow::NotifyWindowSwipe(const std::string& direction) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSwipe(direction);
-}
-
-void NativeWindow::NotifyWindowSheetBegin() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSheetBegin();
-}
-
-void NativeWindow::NotifyWindowSheetEnd() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowSheetEnd();
-}
-
-void NativeWindow::NotifyWindowLeaveFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowLeaveFullScreen();
-}
-
-void NativeWindow::NotifyWindowEnterHtmlFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowEnterHtmlFullScreen();
-}
-
-void NativeWindow::NotifyWindowLeaveHtmlFullScreen() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowLeaveHtmlFullScreen();
-}
-
-void NativeWindow::NotifyWindowExecuteWindowsCommand(
-    const std::string& command) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnExecuteWindowsCommand(command);
-}
-
-void NativeWindow::NotifyTouchBarItemInteraction(
-    const std::string& item_id,
-    const base::DictionaryValue& details) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnTouchBarItemResult(item_id, details);
-}
-
-void NativeWindow::NotifyNewWindowForTab() {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnNewWindowForTab();
-}
-
-#if defined(OS_WIN)
-void NativeWindow::NotifyWindowMessage(UINT message,
-                                       WPARAM w_param,
-                                       LPARAM l_param) {
-  for (NativeWindowObserver& observer : observers_)
-    observer.OnWindowMessage(message, w_param, l_param);
-}
-#endif
-
-views::Widget* NativeWindow::GetWidget() {
-  return widget();
-}
-
-const views::Widget* NativeWindow::GetWidget() const {
-  return widget();
-}
-
-NativeWindowRelay::NativeWindowRelay(base::WeakPtr<NativeWindow> window)
-    : key(UserDataKey()), window(window) {}
-
-NativeWindowRelay::~NativeWindowRelay() = default;
-
-}  // namespace atom
removed in remote
  base   100644 49e1e71d5df685a2ccafba51dcc395534d2f34bd atom/browser/native_window.h
  our    100644 35b67e2dd230692c415a32aae5f0a5e99ab74ac0 atom/browser/native_window.h
@@ -1,359 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_H_
-
-#include <map>
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window_observer.h"
-#include "base/memory/weak_ptr.h"
-#include "base/observer_list.h"
-#include "base/supports_user_data.h"
-#include "content/public/browser/web_contents_user_data.h"
-#include "extensions/browser/app_window/size_constraints.h"
-#include "ui/views/widget/widget_delegate.h"
-
-class SkRegion;
-
-namespace content {
-struct NativeWebKeyboardEvent;
-}
-
-namespace gfx {
-class Image;
-class Point;
-class Rect;
-class RectF;
-class Size;
-}  // namespace gfx
-
-namespace mate {
-class Dictionary;
-class PersistentDictionary;
-}  // namespace mate
-
-namespace atom {
-
-class AtomMenuModel;
-class NativeBrowserView;
-
-struct DraggableRegion;
-
-class NativeWindow : public base::SupportsUserData,
-                     public views::WidgetDelegate {
- public:
-  ~NativeWindow() override;
-
-  // Create window with existing WebContents, the caller is responsible for
-  // managing the window's live.
-  static NativeWindow* Create(const mate::Dictionary& options,
-                              NativeWindow* parent = nullptr);
-
-  void InitFromOptions(const mate::Dictionary& options);
-
-  virtual void SetContentView(views::View* view) = 0;
-
-  virtual void Close() = 0;
-  virtual void CloseImmediately() = 0;
-  virtual bool IsClosed() const;
-  virtual void Focus(bool focus) = 0;
-  virtual bool IsFocused() = 0;
-  virtual void Show() = 0;
-  virtual void ShowInactive() = 0;
-  virtual void Hide() = 0;
-  virtual bool IsVisible() = 0;
-  virtual bool IsEnabled() = 0;
-  virtual void SetEnabled(bool enable) = 0;
-  virtual void Maximize() = 0;
-  virtual void Unmaximize() = 0;
-  virtual bool IsMaximized() = 0;
-  virtual void Minimize() = 0;
-  virtual void Restore() = 0;
-  virtual bool IsMinimized() = 0;
-  virtual void SetFullScreen(bool fullscreen) = 0;
-  virtual bool IsFullscreen() const = 0;
-  virtual void SetBounds(const gfx::Rect& bounds, bool animate = false) = 0;
-  virtual gfx::Rect GetBounds() = 0;
-  virtual void SetSize(const gfx::Size& size, bool animate = false);
-  virtual gfx::Size GetSize();
-  virtual void SetPosition(const gfx::Point& position, bool animate = false);
-  virtual gfx::Point GetPosition();
-  virtual void SetContentSize(const gfx::Size& size, bool animate = false);
-  virtual gfx::Size GetContentSize();
-  virtual void SetContentBounds(const gfx::Rect& bounds, bool animate = false);
-  virtual gfx::Rect GetContentBounds();
-  virtual void SetSizeConstraints(
-      const extensions::SizeConstraints& size_constraints);
-  virtual extensions::SizeConstraints GetSizeConstraints() const;
-  virtual void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints);
-  virtual extensions::SizeConstraints GetContentSizeConstraints() const;
-  virtual void SetMinimumSize(const gfx::Size& size);
-  virtual gfx::Size GetMinimumSize() const;
-  virtual void SetMaximumSize(const gfx::Size& size);
-  virtual gfx::Size GetMaximumSize() const;
-  virtual gfx::Size GetContentMinimumSize() const;
-  virtual gfx::Size GetContentMaximumSize() const;
-  virtual void SetSheetOffset(const double offsetX, const double offsetY);
-  virtual double GetSheetOffsetX();
-  virtual double GetSheetOffsetY();
-  virtual void SetResizable(bool resizable) = 0;
-#if defined(OS_WIN) || defined(OS_MACOSX)
-  virtual void MoveTop() = 0;
-#endif
-  virtual bool IsResizable() = 0;
-  virtual void SetMovable(bool movable) = 0;
-  virtual bool IsMovable() = 0;
-  virtual void SetMinimizable(bool minimizable) = 0;
-  virtual bool IsMinimizable() = 0;
-  virtual void SetMaximizable(bool maximizable) = 0;
-  virtual bool IsMaximizable() = 0;
-  virtual void SetFullScreenable(bool fullscreenable) = 0;
-  virtual bool IsFullScreenable() = 0;
-  virtual void SetClosable(bool closable) = 0;
-  virtual bool IsClosable() = 0;
-  virtual void SetAlwaysOnTop(bool top,
-                              const std::string& level = "floating",
-                              int relativeLevel = 0,
-                              std::string* error = nullptr) = 0;
-  virtual bool IsAlwaysOnTop() = 0;
-  virtual void Center() = 0;
-  virtual void Invalidate() = 0;
-  virtual void SetTitle(const std::string& title) = 0;
-  virtual std::string GetTitle() = 0;
-  virtual void FlashFrame(bool flash) = 0;
-  virtual void SetSkipTaskbar(bool skip) = 0;
-  virtual void SetSimpleFullScreen(bool simple_fullscreen) = 0;
-  virtual bool IsSimpleFullScreen() = 0;
-  virtual void SetKiosk(bool kiosk) = 0;
-  virtual bool IsKiosk() = 0;
-  virtual void SetBackgroundColor(SkColor color) = 0;
-  virtual void SetHasShadow(bool has_shadow) = 0;
-  virtual bool HasShadow() = 0;
-  virtual void SetOpacity(const double opacity) = 0;
-  virtual double GetOpacity() = 0;
-  virtual void SetRepresentedFilename(const std::string& filename);
-  virtual std::string GetRepresentedFilename();
-  virtual void SetDocumentEdited(bool edited);
-  virtual bool IsDocumentEdited();
-  virtual void SetIgnoreMouseEvents(bool ignore, bool forward) = 0;
-  virtual void SetContentProtection(bool enable) = 0;
-  virtual void SetFocusable(bool focusable);
-  virtual void SetMenu(AtomMenuModel* menu);
-  virtual void SetParentWindow(NativeWindow* parent);
-  virtual void SetBrowserView(NativeBrowserView* browser_view) = 0;
-  virtual gfx::NativeView GetNativeView() const = 0;
-  virtual gfx::NativeWindow GetNativeWindow() const = 0;
-  virtual gfx::AcceleratedWidget GetAcceleratedWidget() const = 0;
-
-  // Taskbar/Dock APIs.
-  enum ProgressState {
-    PROGRESS_NONE,           // no progress, no marking
-    PROGRESS_INDETERMINATE,  // progress, indeterminate
-    PROGRESS_ERROR,          // progress, errored (red)
-    PROGRESS_PAUSED,         // progress, paused (yellow)
-    PROGRESS_NORMAL,         // progress, not marked (green)
-  };
-
-  virtual void SetProgressBar(double progress, const ProgressState state) = 0;
-  virtual void SetOverlayIcon(const gfx::Image& overlay,
-                              const std::string& description) = 0;
-
-  // Workspace APIs.
-  virtual void SetVisibleOnAllWorkspaces(bool visible) = 0;
-  virtual bool IsVisibleOnAllWorkspaces() = 0;
-
-  virtual void SetAutoHideCursor(bool auto_hide);
-
-  // Vibrancy API
-  virtual void SetVibrancy(const std::string& type);
-
-  // Touchbar API
-  virtual void SetTouchBar(
-      const std::vector<mate::PersistentDictionary>& items);
-  virtual void RefreshTouchBarItem(const std::string& item_id);
-  virtual void SetEscapeTouchBarItem(const mate::PersistentDictionary& item);
-
-  // Native Tab API
-  virtual void SelectPreviousTab();
-  virtual void SelectNextTab();
-  virtual void MergeAllWindows();
-  virtual void MoveTabToNewWindow();
-  virtual void ToggleTabBar();
-  virtual bool AddTabbedWindow(NativeWindow* window);
-
-  // Returns false if unsupported.
-  virtual bool SetWindowButtonVisibility(bool visible);
-
-  // Toggle the menu bar.
-  virtual void SetAutoHideMenuBar(bool auto_hide);
-  virtual bool IsMenuBarAutoHide();
-  virtual void SetMenuBarVisibility(bool visible);
-  virtual bool IsMenuBarVisible();
-
-  // Set the aspect ratio when resizing window.
-  double GetAspectRatio();
-  gfx::Size GetAspectRatioExtraSize();
-  virtual void SetAspectRatio(double aspect_ratio, const gfx::Size& extra_size);
-
-  // File preview APIs.
-  virtual void PreviewFile(const std::string& path,
-                           const std::string& display_name);
-  virtual void CloseFilePreview();
-
-  // Converts between content bounds and window bounds.
-  virtual gfx::Rect ContentBoundsToWindowBounds(
-      const gfx::Rect& bounds) const = 0;
-  virtual gfx::Rect WindowBoundsToContentBounds(
-      const gfx::Rect& bounds) const = 0;
-
-  base::WeakPtr<NativeWindow> GetWeakPtr() {
-    return weak_factory_.GetWeakPtr();
-  }
-
-  // Methods called by the WebContents.
-  virtual void HandleKeyboardEvent(
-      content::WebContents*,
-      const content::NativeWebKeyboardEvent& event) {}
-
-  // Public API used by platform-dependent delegates and observers to send UI
-  // related notifications.
-  void NotifyWindowRequestPreferredWith(int* width);
-  void NotifyWindowCloseButtonClicked();
-  void NotifyWindowClosed();
-  void NotifyWindowEndSession();
-  void NotifyWindowBlur();
-  void NotifyWindowFocus();
-  void NotifyWindowShow();
-  void NotifyWindowHide();
-  void NotifyWindowMaximize();
-  void NotifyWindowUnmaximize();
-  void NotifyWindowMinimize();
-  void NotifyWindowRestore();
-  void NotifyWindowMove();
-  void NotifyWindowWillResize(const gfx::Rect& new_bounds,
-                              bool* prevent_default);
-  void NotifyWindowResize();
-  void NotifyWindowMoved();
-  void NotifyWindowScrollTouchBegin();
-  void NotifyWindowScrollTouchEnd();
-  void NotifyWindowSwipe(const std::string& direction);
-  void NotifyWindowSheetBegin();
-  void NotifyWindowSheetEnd();
-  void NotifyWindowEnterFullScreen();
-  void NotifyWindowLeaveFullScreen();
-  void NotifyWindowEnterHtmlFullScreen();
-  void NotifyWindowLeaveHtmlFullScreen();
-  void NotifyWindowExecuteWindowsCommand(const std::string& command);
-  void NotifyTouchBarItemInteraction(const std::string& item_id,
-                                     const base::DictionaryValue& details);
-  void NotifyNewWindowForTab();
-
-#if defined(OS_WIN)
-  void NotifyWindowMessage(UINT message, WPARAM w_param, LPARAM l_param);
-#endif
-
-  void AddObserver(NativeWindowObserver* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(NativeWindowObserver* obs) {
-    observers_.RemoveObserver(obs);
-  }
-
-  views::Widget* widget() const { return widget_.get(); }
-  views::View* content_view() const { return content_view_; }
-
-  bool has_frame() const { return has_frame_; }
-  void set_has_frame(bool has_frame) { has_frame_ = has_frame; }
-
-  bool transparent() const { return transparent_; }
-  bool enable_larger_than_screen() const { return enable_larger_than_screen_; }
-
-  NativeBrowserView* browser_view() const { return browser_view_; }
-  NativeWindow* parent() const { return parent_; }
-  bool is_modal() const { return is_modal_; }
-
- protected:
-  NativeWindow(const mate::Dictionary& options, NativeWindow* parent);
-
-  // views::WidgetDelegate:
-  views::Widget* GetWidget() override;
-  const views::Widget* GetWidget() const override;
-
-  void set_content_view(views::View* view) { content_view_ = view; }
-  void set_browser_view(NativeBrowserView* browser_view) {
-    browser_view_ = browser_view;
-  }
-
- private:
-  std::unique_ptr<views::Widget> widget_;
-
-  // The content view, weak ref.
-  views::View* content_view_ = nullptr;
-
-  // Whether window has standard frame.
-  bool has_frame_ = true;
-
-  // Whether window is transparent.
-  bool transparent_ = false;
-
-  // Minimum and maximum size, stored as content size.
-  extensions::SizeConstraints size_constraints_;
-
-  // Whether window can be resized larger than screen.
-  bool enable_larger_than_screen_ = false;
-
-  // The windows has been closed.
-  bool is_closed_ = false;
-
-  // Used to display sheets at the appropriate horizontal and vertical offsets
-  // on macOS.
-  double sheet_offset_x_ = 0.0;
-  double sheet_offset_y_ = 0.0;
-
-  // Used to maintain the aspect ratio of a view which is inside of the
-  // content view.
-  double aspect_ratio_ = 0.0;
-  gfx::Size aspect_ratio_extraSize_;
-
-  // The parent window, it is guaranteed to be valid during this window's life.
-  NativeWindow* parent_ = nullptr;
-
-  // Is this a modal window.
-  bool is_modal_ = false;
-
-  // The browser view layer.
-  NativeBrowserView* browser_view_ = nullptr;
-
-  // Observers of this window.
-  base::ObserverList<NativeWindowObserver> observers_;
-
-  base::WeakPtrFactory<NativeWindow> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindow);
-};
-
-// This class provides a hook to get a NativeWindow from a WebContents.
-class NativeWindowRelay
-    : public content::WebContentsUserData<NativeWindowRelay> {
- public:
-  explicit NativeWindowRelay(base::WeakPtr<NativeWindow> window);
-  ~NativeWindowRelay() override;
-
-  static void* UserDataKey() {
-    return content::WebContentsUserData<NativeWindowRelay>::UserDataKey();
-  }
-
-  void* key;
-  base::WeakPtr<NativeWindow> window;
-
- private:
-  friend class content::WebContentsUserData<NativeWindow>;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_H_
removed in remote
  base   100644 93d03e4c157cace08ef1792246a875e6e94eea6e atom/browser/native_window_mac.h
  our    100644 44a78198f44cdba9875e3fb27c8e2c87eaa6f33b atom/browser/native_window_mac.h
@@ -1,221 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "base/mac/scoped_nsobject.h"
-#include "ui/views/controls/native/native_view_host.h"
-
-@class AtomNSWindow;
-@class AtomNSWindowDelegate;
-@class AtomPreviewItem;
-@class AtomTouchBar;
-@class CustomWindowButtonView;
-@class FullSizeContentView;
-
-namespace atom {
-
-class RootViewMac;
-
-class NativeWindowMac : public NativeWindow {
- public:
-  NativeWindowMac(const mate::Dictionary& options, NativeWindow* parent);
-  ~NativeWindowMac() override;
-
-  // NativeWindow:
-  void SetContentView(views::View* view) override;
-  void Close() override;
-  void CloseImmediately() override;
-  void Focus(bool focus) override;
-  bool IsFocused() override;
-  void Show() override;
-  void ShowInactive() override;
-  void Hide() override;
-  bool IsVisible() override;
-  bool IsEnabled() override;
-  void SetEnabled(bool enable) override;
-  void Maximize() override;
-  void Unmaximize() override;
-  bool IsMaximized() override;
-  void Minimize() override;
-  void Restore() override;
-  bool IsMinimized() override;
-  void SetFullScreen(bool fullscreen) override;
-  bool IsFullscreen() const override;
-  void SetBounds(const gfx::Rect& bounds, bool animate = false) override;
-  gfx::Rect GetBounds() override;
-  void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints) override;
-  void SetResizable(bool resizable) override;
-  void MoveTop() override;
-  bool IsResizable() override;
-  void SetMovable(bool movable) override;
-  void SetAspectRatio(double aspect_ratio,
-                      const gfx::Size& extra_size) override;
-  void PreviewFile(const std::string& path,
-                   const std::string& display_name) override;
-  void CloseFilePreview() override;
-  bool IsMovable() override;
-  void SetMinimizable(bool minimizable) override;
-  bool IsMinimizable() override;
-  void SetMaximizable(bool maximizable) override;
-  bool IsMaximizable() override;
-  void SetFullScreenable(bool fullscreenable) override;
-  bool IsFullScreenable() override;
-  void SetClosable(bool closable) override;
-  bool IsClosable() override;
-  void SetAlwaysOnTop(bool top,
-                      const std::string& level,
-                      int relativeLevel,
-                      std::string* error) override;
-  bool IsAlwaysOnTop() override;
-  void Center() override;
-  void Invalidate() override;
-  void SetTitle(const std::string& title) override;
-  std::string GetTitle() override;
-  void FlashFrame(bool flash) override;
-  void SetSkipTaskbar(bool skip) override;
-  void SetSimpleFullScreen(bool simple_fullscreen) override;
-  bool IsSimpleFullScreen() override;
-  void SetKiosk(bool kiosk) override;
-  bool IsKiosk() override;
-  void SetBackgroundColor(SkColor color) override;
-  void SetHasShadow(bool has_shadow) override;
-  bool HasShadow() override;
-  void SetOpacity(const double opacity) override;
-  double GetOpacity() override;
-  void SetRepresentedFilename(const std::string& filename) override;
-  std::string GetRepresentedFilename() override;
-  void SetDocumentEdited(bool edited) override;
-  bool IsDocumentEdited() override;
-  void SetIgnoreMouseEvents(bool ignore, bool forward) override;
-  void SetContentProtection(bool enable) override;
-  void SetBrowserView(NativeBrowserView* browser_view) override;
-  void SetParentWindow(NativeWindow* parent) override;
-  gfx::NativeView GetNativeView() const override;
-  gfx::NativeWindow GetNativeWindow() const override;
-  gfx::AcceleratedWidget GetAcceleratedWidget() const override;
-  void SetProgressBar(double progress, const ProgressState state) override;
-  void SetOverlayIcon(const gfx::Image& overlay,
-                      const std::string& description) override;
-
-  void SetVisibleOnAllWorkspaces(bool visible) override;
-  bool IsVisibleOnAllWorkspaces() override;
-
-  void SetAutoHideCursor(bool auto_hide) override;
-
-  void SelectPreviousTab() override;
-  void SelectNextTab() override;
-  void MergeAllWindows() override;
-  void MoveTabToNewWindow() override;
-  void ToggleTabBar() override;
-  bool AddTabbedWindow(NativeWindow* window) override;
-
-  bool SetWindowButtonVisibility(bool visible) override;
-
-  void SetVibrancy(const std::string& type) override;
-  void SetTouchBar(
-      const std::vector<mate::PersistentDictionary>& items) override;
-  void RefreshTouchBarItem(const std::string& item_id) override;
-  void SetEscapeTouchBarItem(const mate::PersistentDictionary& item) override;
-
-  gfx::Rect ContentBoundsToWindowBounds(const gfx::Rect& bounds) const override;
-  gfx::Rect WindowBoundsToContentBounds(const gfx::Rect& bounds) const override;
-
-  // Use a custom content view instead of Chromium's BridgedContentView.
-  void OverrideNSWindowContentView();
-
-  // Set the attribute of NSWindow while work around a bug of zoom button.
-  void SetStyleMask(bool on, NSUInteger flag);
-  void SetCollectionBehavior(bool on, NSUInteger flag);
-
-  enum TitleBarStyle {
-    NORMAL,
-    HIDDEN,
-    HIDDEN_INSET,
-    CUSTOM_BUTTONS_ON_HOVER,
-  };
-  TitleBarStyle title_bar_style() const { return title_bar_style_; }
-
-  AtomPreviewItem* preview_item() const { return preview_item_.get(); }
-  AtomTouchBar* touch_bar() const { return touch_bar_.get(); }
-  bool zoom_to_page_width() const { return zoom_to_page_width_; }
-  bool fullscreen_window_title() const { return fullscreen_window_title_; }
-  bool simple_fullscreen() const { return always_simple_fullscreen_; }
-
- protected:
-  // views::WidgetDelegate:
-  bool CanResize() const override;
-  views::View* GetContentsView() override;
-
- private:
-  // Add custom layers to the content view.
-  void AddContentViewLayers();
-
-  void InternalSetParentWindow(NativeWindow* parent, bool attach);
-  void ShowWindowButton(NSWindowButton button);
-
-  void SetForwardMouseMessages(bool forward);
-
-  AtomNSWindow* window_;  // Weak ref, managed by widget_.
-
-  base::scoped_nsobject<AtomNSWindowDelegate> window_delegate_;
-  base::scoped_nsobject<AtomPreviewItem> preview_item_;
-  base::scoped_nsobject<AtomTouchBar> touch_bar_;
-  base::scoped_nsobject<CustomWindowButtonView> buttons_view_;
-
-  // Event monitor for scroll wheel event.
-  id wheel_event_monitor_;
-
-  // The view that will fill the whole frameless window.
-  base::scoped_nsobject<FullSizeContentView> container_view_;
-
-  // The view that fills the client area.
-  std::unique_ptr<RootViewMac> root_view_;
-
-  bool is_kiosk_ = false;
-  bool was_fullscreen_ = false;
-  bool zoom_to_page_width_ = false;
-  bool fullscreen_window_title_ = false;
-  bool resizable_ = true;
-
-  NSInteger attention_request_id_ = 0;  // identifier from requestUserAttention
-
-  // The presentation options before entering kiosk mode.
-  NSApplicationPresentationOptions kiosk_options_;
-
-  // The "titleBarStyle" option.
-  TitleBarStyle title_bar_style_ = NORMAL;
-
-  // The visibility mode of window button controls when explicitly set through
-  // setWindowButtonVisibility().
-  base::Optional<bool> window_button_visibility_;
-
-  // Simple (pre-Lion) Fullscreen Settings
-  bool always_simple_fullscreen_ = false;
-  bool is_simple_fullscreen_ = false;
-  bool was_maximizable_ = false;
-  bool was_movable_ = false;
-  NSRect original_frame_;
-  NSUInteger simple_fullscreen_mask_;
-
-  base::scoped_nsobject<NSColor> background_color_before_vibrancy_;
-  bool transparency_before_vibrancy_ = false;
-
-  // The presentation options before entering simple fullscreen mode.
-  NSApplicationPresentationOptions simple_fullscreen_options_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowMac);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_MAC_H_
removed in remote
  base   100644 2044ee7d7189076a93975231ef9c54662cf3ee3e atom/browser/native_window_mac.mm
  our    100644 004263ec127709067e903ffbf31003b8844226b4 atom/browser/native_window_mac.mm
@@ -1,1444 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window_mac.h"
-
-#include <AvailabilityMacros.h>
-#include <objc/objc-runtime.h>
-
-#include <string>
-
-#include "atom/browser/native_browser_view_mac.h"
-#include "atom/browser/ui/cocoa/atom_native_widget_mac.h"
-#include "atom/browser/ui/cocoa/atom_ns_window.h"
-#include "atom/browser/ui/cocoa/atom_ns_window_delegate.h"
-#include "atom/browser/ui/cocoa/atom_preview_item.h"
-#include "atom/browser/ui/cocoa/atom_touch_bar.h"
-#include "atom/browser/ui/cocoa/root_view_mac.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/options_switches.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/strings/sys_string_conversions.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "native_mate/dictionary.h"
-#include "skia/ext/skia_utils_mac.h"
-#include "ui/gfx/skia_util.h"
-#include "ui/gl/gpu_switching_manager.h"
-#include "ui/views/background.h"
-#include "ui/views/cocoa/bridged_native_widget.h"
-#include "ui/views/widget/widget.h"
-
-// This view always takes the size of its superview. It is intended to be used
-// as a NSWindow's contentView.  It is needed because NSWindow's implementation
-// explicitly resizes the contentView at inopportune times.
-@interface FullSizeContentView : NSView
-@end
-
-@implementation FullSizeContentView
-
-// This method is directly called by NSWindow during a window resize on OSX
-// 10.10.0, beta 2. We must override it to prevent the content view from
-// shrinking.
-- (void)setFrameSize:(NSSize)size {
-  if ([self superview])
-    size = [[self superview] bounds].size;
-  [super setFrameSize:size];
-}
-
-// The contentView gets moved around during certain full-screen operations.
-// This is less than ideal, and should eventually be removed.
-- (void)viewDidMoveToSuperview {
-  [self setFrame:[[self superview] bounds]];
-}
-
-@end
-
-// Custom Quit, Minimize and Full Screen button container for frameless
-// windows.
-@interface CustomWindowButtonView : NSView {
- @private
-  BOOL mouse_inside_;
-}
-@end
-
-@implementation CustomWindowButtonView
-
-- (id)initWithFrame:(NSRect)frame {
-  self = [super initWithFrame:frame];
-
-  NSButton* close_button = [NSWindow standardWindowButton:NSWindowCloseButton
-                                             forStyleMask:NSTitledWindowMask];
-  NSButton* miniaturize_button =
-      [NSWindow standardWindowButton:NSWindowMiniaturizeButton
-                        forStyleMask:NSTitledWindowMask];
-  NSButton* zoom_button = [NSWindow standardWindowButton:NSWindowZoomButton
-                                            forStyleMask:NSTitledWindowMask];
-
-  CGFloat x = 0;
-  const CGFloat space_between = 20;
-
-  [close_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:close_button];
-
-  [miniaturize_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:miniaturize_button];
-
-  [zoom_button setFrameOrigin:NSMakePoint(x, 0)];
-  x += space_between;
-  [self addSubview:zoom_button];
-
-  const auto last_button_frame = zoom_button.frame;
-  [self setFrameSize:NSMakeSize(last_button_frame.origin.x +
-                                    last_button_frame.size.width,
-                                last_button_frame.size.height)];
-
-  mouse_inside_ = NO;
-  [self setNeedsDisplayForButtons];
-
-  return self;
-}
-
-- (void)viewDidMoveToWindow {
-  if (!self.window) {
-    return;
-  }
-
-  // Stay in upper left corner.
-  const CGFloat top_margin = 3;
-  const CGFloat left_margin = 7;
-  [self setAutoresizingMask:NSViewMaxXMargin | NSViewMinYMargin];
-  [self setFrameOrigin:NSMakePoint(left_margin, self.window.frame.size.height -
-                                                    self.frame.size.height -
-                                                    top_margin)];
-}
-
-- (BOOL)_mouseInGroup:(NSButton*)button {
-  return mouse_inside_;
-}
-
-- (void)updateTrackingAreas {
-  auto tracking_area = [[[NSTrackingArea alloc]
-      initWithRect:NSZeroRect
-           options:NSTrackingMouseEnteredAndExited | NSTrackingActiveAlways |
-                   NSTrackingInVisibleRect
-             owner:self
-          userInfo:nil] autorelease];
-  [self addTrackingArea:tracking_area];
-}
-
-- (void)mouseEntered:(NSEvent*)event {
-  [super mouseEntered:event];
-  mouse_inside_ = YES;
-  [self setNeedsDisplayForButtons];
-}
-
-- (void)mouseExited:(NSEvent*)event {
-  [super mouseExited:event];
-  mouse_inside_ = NO;
-  [self setNeedsDisplayForButtons];
-}
-
-- (void)setNeedsDisplayForButtons {
-  for (NSView* subview in self.subviews) {
-    [subview setHidden:!mouse_inside_];
-    [subview setNeedsDisplay:YES];
-  }
-}
-
-@end
-
-#if !defined(AVAILABLE_MAC_OS_X_VERSION_10_12_AND_LATER)
-
-enum { NSWindowTabbingModeDisallowed = 2 };
-
-@interface NSWindow (SierraSDK)
-- (void)setTabbingMode:(NSInteger)mode;
-- (void)setTabbingIdentifier:(NSString*)identifier;
-- (void)addTabbedWindow:(NSWindow*)window ordered:(NSWindowOrderingMode)ordered;
-- (IBAction)selectPreviousTab:(id)sender;
-- (IBAction)selectNextTab:(id)sender;
-- (IBAction)mergeAllWindows:(id)sender;
-- (IBAction)moveTabToNewWindow:(id)sender;
-- (IBAction)toggleTabBar:(id)sender;
-@end
-
-#endif
-
-@interface AtomProgressBar : NSProgressIndicator
-@end
-
-@implementation AtomProgressBar
-
-- (void)drawRect:(NSRect)dirtyRect {
-  if (self.style != NSProgressIndicatorBarStyle)
-    return;
-  // Draw edges of rounded rect.
-  NSRect rect = NSInsetRect([self bounds], 1.0, 1.0);
-  CGFloat radius = rect.size.height / 2;
-  NSBezierPath* bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect
-                                                              xRadius:radius
-                                                              yRadius:radius];
-  [bezier_path setLineWidth:2.0];
-  [[NSColor grayColor] set];
-  [bezier_path stroke];
-
-  // Fill the rounded rect.
-  rect = NSInsetRect(rect, 2.0, 2.0);
-  radius = rect.size.height / 2;
-  bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect
-                                                xRadius:radius
-                                                yRadius:radius];
-  [bezier_path setLineWidth:1.0];
-  [bezier_path addClip];
-
-  // Calculate the progress width.
-  rect.size.width =
-      floor(rect.size.width * ([self doubleValue] / [self maxValue]));
-
-  // Fill the progress bar with color blue.
-  [[NSColor colorWithSRGBRed:0.2 green:0.6 blue:1 alpha:1] set];
-  NSRectFill(rect);
-}
-
-@end
-
-namespace mate {
-
-template <>
-struct Converter<atom::NativeWindowMac::TitleBarStyle> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     atom::NativeWindowMac::TitleBarStyle* out) {
-    std::string title_bar_style;
-    if (!ConvertFromV8(isolate, val, &title_bar_style))
-      return false;
-    if (title_bar_style == "hidden") {
-      *out = atom::NativeWindowMac::HIDDEN;
-    } else if (title_bar_style == "hiddenInset") {
-      *out = atom::NativeWindowMac::HIDDEN_INSET;
-    } else if (title_bar_style == "customButtonsOnHover") {
-      *out = atom::NativeWindowMac::CUSTOM_BUTTONS_ON_HOVER;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace {
-
-bool IsFramelessWindow(NSView* view) {
-  NativeWindow* window = [static_cast<AtomNSWindow*>([view window]) shell];
-  return window && !window->has_frame();
-}
-
-IMP original_set_frame_size = nullptr;
-IMP original_view_did_move_to_superview = nullptr;
-
-// This method is directly called by NSWindow during a window resize on OSX
-// 10.10.0, beta 2. We must override it to prevent the content view from
-// shrinking.
-void SetFrameSize(NSView* self, SEL _cmd, NSSize size) {
-  if (!IsFramelessWindow(self)) {
-    auto original =
-        reinterpret_cast<decltype(&SetFrameSize)>(original_set_frame_size);
-    return original(self, _cmd, size);
-  }
-  // For frameless window, resize the view to cover full window.
-  if ([self superview])
-    size = [[self superview] bounds].size;
-  auto super_impl = reinterpret_cast<decltype(&SetFrameSize)>(
-      [[self superclass] instanceMethodForSelector:_cmd]);
-  super_impl(self, _cmd, size);
-}
-
-// The contentView gets moved around during certain full-screen operations.
-// This is less than ideal, and should eventually be removed.
-void ViewDidMoveToSuperview(NSView* self, SEL _cmd) {
-  if (!IsFramelessWindow(self)) {
-    // [BridgedContentView viewDidMoveToSuperview];
-    auto original = reinterpret_cast<decltype(&ViewDidMoveToSuperview)>(
-        original_view_did_move_to_superview);
-    if (original)
-      original(self, _cmd);
-    return;
-  }
-  [self setFrame:[[self superview] bounds]];
-}
-
-}  // namespace
-
-NativeWindowMac::NativeWindowMac(const mate::Dictionary& options,
-                                 NativeWindow* parent)
-    : NativeWindow(options, parent), root_view_(new RootViewMac(this)) {
-  int width = 800, height = 600;
-  options.Get(options::kWidth, &width);
-  options.Get(options::kHeight, &height);
-
-  NSRect main_screen_rect = [[[NSScreen screens] firstObject] frame];
-  gfx::Rect bounds(round((NSWidth(main_screen_rect) - width) / 2),
-                   round((NSHeight(main_screen_rect) - height) / 2), width,
-                   height);
-
-  options.Get(options::kResizable, &resizable_);
-  options.Get(options::kTitleBarStyle, &title_bar_style_);
-  options.Get(options::kZoomToPageWidth, &zoom_to_page_width_);
-  options.Get(options::kFullscreenWindowTitle, &fullscreen_window_title_);
-  options.Get(options::kSimpleFullScreen, &always_simple_fullscreen_);
-
-  bool minimizable = true;
-  options.Get(options::kMinimizable, &minimizable);
-
-  bool maximizable = true;
-  options.Get(options::kMaximizable, &maximizable);
-
-  bool closable = true;
-  options.Get(options::kClosable, &closable);
-
-  std::string tabbingIdentifier;
-  options.Get(options::kTabbingIdentifier, &tabbingIdentifier);
-
-  std::string windowType;
-  options.Get(options::kType, &windowType);
-
-  bool useStandardWindow = true;
-  // eventually deprecate separate "standardWindow" option in favor of
-  // standard / textured window types
-  options.Get(options::kStandardWindow, &useStandardWindow);
-  if (windowType == "textured") {
-    useStandardWindow = false;
-  }
-
-  NSUInteger styleMask = NSTitledWindowMask;
-  if (@available(macOS 10.10, *)) {
-    if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER &&
-        (!useStandardWindow || transparent() || !has_frame())) {
-      styleMask = NSFullSizeContentViewWindowMask;
-    }
-  }
-  if (minimizable) {
-    styleMask |= NSMiniaturizableWindowMask;
-  }
-  if (closable) {
-    styleMask |= NSClosableWindowMask;
-  }
-  if (title_bar_style_ != NORMAL) {
-    // The window without titlebar is treated the same with frameless window.
-    set_has_frame(false);
-  }
-  if (!useStandardWindow || transparent() || !has_frame()) {
-    styleMask |= NSTexturedBackgroundWindowMask;
-  }
-
-  // Create views::Widget and assign window_ with it.
-  // TODO(zcbenz): Get rid of the window_ in future.
-  views::Widget::InitParams params;
-  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.bounds = bounds;
-  params.delegate = this;
-  params.type = views::Widget::InitParams::TYPE_WINDOW;
-  params.native_widget = new AtomNativeWidgetMac(this, styleMask, widget());
-  widget()->Init(params);
-  window_ = static_cast<AtomNSWindow*>(widget()->GetNativeWindow());
-
-  [window_ setEnableLargerThanScreen:enable_larger_than_screen()];
-
-  window_delegate_.reset([[AtomNSWindowDelegate alloc] initWithShell:this]);
-  [window_ setDelegate:window_delegate_];
-
-  // Only use native parent window for non-modal windows.
-  if (parent && !is_modal()) {
-    SetParentWindow(parent);
-  }
-
-  if (transparent()) {
-    // Setting the background color to clear will also hide the shadow.
-    [window_ setBackgroundColor:[NSColor clearColor]];
-  }
-
-  if (windowType == "desktop") {
-    [window_ setLevel:kCGDesktopWindowLevel - 1];
-    [window_ setDisableKeyOrMainWindow:YES];
-    [window_ setCollectionBehavior:(NSWindowCollectionBehaviorCanJoinAllSpaces |
-                                    NSWindowCollectionBehaviorStationary |
-                                    NSWindowCollectionBehaviorIgnoresCycle)];
-  }
-
-  bool focusable;
-  if (options.Get(options::kFocusable, &focusable) && !focusable)
-    [window_ setDisableKeyOrMainWindow:YES];
-
-  if (transparent() || !has_frame()) {
-    if (@available(macOS 10.10, *)) {
-      // Don't show title bar.
-      [window_ setTitlebarAppearsTransparent:YES];
-      [window_ setTitleVisibility:NSWindowTitleHidden];
-    }
-    // Remove non-transparent corners, see http://git.io/vfonD.
-    [window_ setOpaque:NO];
-  }
-
-  // Create a tab only if tabbing identifier is specified and window has
-  // a native title bar.
-  if (tabbingIdentifier.empty() || transparent() || !has_frame()) {
-    if (@available(macOS 10.12, *)) {
-      [window_ setTabbingMode:NSWindowTabbingModeDisallowed];
-    }
-  } else {
-    if (@available(macOS 10.12, *)) {
-      [window_ setTabbingIdentifier:base::SysUTF8ToNSString(tabbingIdentifier)];
-    }
-  }
-
-  // Hide the title bar background
-  if (title_bar_style_ != NORMAL) {
-    if (@available(macOS 10.10, *)) {
-      [window_ setTitlebarAppearsTransparent:YES];
-    }
-  }
-
-  // Hide the title bar.
-  if (title_bar_style_ == HIDDEN_INSET) {
-    if (@available(macOS 10.10, *)) {
-      base::scoped_nsobject<NSToolbar> toolbar(
-          [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
-      [toolbar setShowsBaselineSeparator:NO];
-      [window_ setToolbar:toolbar];
-    } else {
-      [window_ enableWindowButtonsOffset];
-      [window_ setWindowButtonsOffset:NSMakePoint(12, 10)];
-    }
-  }
-
-  // Resize to content bounds.
-  bool use_content_size = false;
-  options.Get(options::kUseContentSize, &use_content_size);
-  if (!has_frame() || use_content_size)
-    SetContentSize(gfx::Size(width, height));
-
-  // Enable the NSView to accept first mouse event.
-  bool acceptsFirstMouse = false;
-  options.Get(options::kAcceptFirstMouse, &acceptsFirstMouse);
-  [window_ setAcceptsFirstMouse:acceptsFirstMouse];
-
-  // Disable auto-hiding cursor.
-  bool disableAutoHideCursor = false;
-  options.Get(options::kDisableAutoHideCursor, &disableAutoHideCursor);
-  [window_ setDisableAutoHideCursor:disableAutoHideCursor];
-
-  // Use an NSEvent monitor to listen for the wheel event.
-  BOOL __block began = NO;
-  wheel_event_monitor_ = [NSEvent
-      addLocalMonitorForEventsMatchingMask:NSScrollWheelMask
-                                   handler:^(NSEvent* event) {
-                                     if ([[event window] windowNumber] !=
-                                         [window_ windowNumber])
-                                       return event;
-
-                                     if (!began && (([event phase] ==
-                                                     NSEventPhaseMayBegin) ||
-                                                    ([event phase] ==
-                                                     NSEventPhaseBegan))) {
-                                       this->NotifyWindowScrollTouchBegin();
-                                       began = YES;
-                                     } else if (began &&
-                                                (([event phase] ==
-                                                  NSEventPhaseEnded) ||
-                                                 ([event phase] ==
-                                                  NSEventPhaseCancelled))) {
-                                       this->NotifyWindowScrollTouchEnd();
-                                       began = NO;
-                                     }
-                                     return event;
-                                   }];
-
-  // Set maximizable state last to ensure zoom button does not get reset
-  // by calls to other APIs.
-  SetMaximizable(maximizable);
-
-  // Default content view.
-  SetContentView(new views::View());
-  AddContentViewLayers();
-}
-
-NativeWindowMac::~NativeWindowMac() {
-  [NSEvent removeMonitor:wheel_event_monitor_];
-}
-
-void NativeWindowMac::SetContentView(views::View* view) {
-  views::View* root_view = GetContentsView();
-  if (content_view())
-    root_view->RemoveChildView(content_view());
-
-  set_content_view(view);
-  root_view->AddChildView(content_view());
-
-  if (buttons_view_) {
-    // Ensure the buttons view are always floated on the top.
-    [buttons_view_ removeFromSuperview];
-    [[window_ contentView] addSubview:buttons_view_];
-  }
-
-  root_view->Layout();
-}
-
-void NativeWindowMac::Close() {
-  // When this is a sheet showing, performClose won't work.
-  if (is_modal() && parent() && IsVisible()) {
-    [parent()->GetNativeWindow() endSheet:window_];
-    CloseImmediately();
-    return;
-  }
-
-  if (!IsClosable()) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  [window_ performClose:nil];
-}
-
-void NativeWindowMac::CloseImmediately() {
-  [window_ close];
-}
-
-void NativeWindowMac::Focus(bool focus) {
-  if (!IsVisible())
-    return;
-
-  if (focus) {
-    [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
-    [window_ makeKeyAndOrderFront:nil];
-  } else {
-    [window_ orderBack:nil];
-  }
-}
-
-bool NativeWindowMac::IsFocused() {
-  return [window_ isKeyWindow];
-}
-
-void NativeWindowMac::Show() {
-  if (is_modal() && parent()) {
-    if ([window_ sheetParent] == nil)
-      [parent()->GetNativeWindow() beginSheet:window_
-                            completionHandler:^(NSModalResponse){
-                            }];
-    return;
-  }
-
-  // Reattach the window to the parent to actually show it.
-  if (parent())
-    InternalSetParentWindow(parent(), true);
-
-  // This method is supposed to put focus on window, however if the app does not
-  // have focus then "makeKeyAndOrderFront" will only show the window.
-  [NSApp activateIgnoringOtherApps:YES];
-
-  [window_ makeKeyAndOrderFront:nil];
-}
-
-void NativeWindowMac::ShowInactive() {
-  // Reattach the window to the parent to actually show it.
-  if (parent())
-    InternalSetParentWindow(parent(), true);
-
-  [window_ orderFrontRegardless];
-}
-
-void NativeWindowMac::Hide() {
-  if (is_modal() && parent()) {
-    [window_ orderOut:nil];
-    [parent()->GetNativeWindow() endSheet:window_];
-    return;
-  }
-
-  // Deattach the window from the parent before.
-  if (parent())
-    InternalSetParentWindow(parent(), false);
-
-  [window_ orderOut:nil];
-}
-
-bool NativeWindowMac::IsVisible() {
-  return [window_ isVisible];
-}
-
-bool NativeWindowMac::IsEnabled() {
-  return [window_ attachedSheet] == nil;
-}
-
-void NativeWindowMac::SetEnabled(bool enable) {
-  if (enable) {
-    [window_ beginSheet:window_
-        completionHandler:^(NSModalResponse returnCode) {
-          NSLog(@"modal enabled");
-          return;
-        }];
-  } else {
-    [window_ endSheet:[window_ attachedSheet]];
-  }
-}
-
-void NativeWindowMac::Maximize() {
-  if (IsMaximized())
-    return;
-
-  [window_ zoom:nil];
-}
-
-void NativeWindowMac::Unmaximize() {
-  if (!IsMaximized())
-    return;
-
-  [window_ zoom:nil];
-}
-
-bool NativeWindowMac::IsMaximized() {
-  if (([window_ styleMask] & NSResizableWindowMask) != 0) {
-    return [window_ isZoomed];
-  } else {
-    NSRect rectScreen = [[NSScreen mainScreen] visibleFrame];
-    NSRect rectWindow = [window_ frame];
-    return (rectScreen.origin.x == rectWindow.origin.x &&
-            rectScreen.origin.y == rectWindow.origin.y &&
-            rectScreen.size.width == rectWindow.size.width &&
-            rectScreen.size.height == rectWindow.size.height);
-  }
-}
-
-void NativeWindowMac::Minimize() {
-  [window_ miniaturize:nil];
-}
-
-void NativeWindowMac::Restore() {
-  [window_ deminiaturize:nil];
-}
-
-bool NativeWindowMac::IsMinimized() {
-  return [window_ isMiniaturized];
-}
-
-void NativeWindowMac::SetFullScreen(bool fullscreen) {
-  if (fullscreen == IsFullscreen())
-    return;
-
-  [window_ toggleFullScreenMode:nil];
-}
-
-bool NativeWindowMac::IsFullscreen() const {
-  return [window_ styleMask] & NSFullScreenWindowMask;
-}
-
-void NativeWindowMac::SetBounds(const gfx::Rect& bounds, bool animate) {
-  // Do nothing if in fullscreen mode.
-  if (IsFullscreen())
-    return;
-
-  // Check size constraints since setFrame does not check it.
-  gfx::Size size = bounds.size();
-  size.SetToMax(GetMinimumSize());
-  gfx::Size max_size = GetMaximumSize();
-  if (!max_size.IsEmpty())
-    size.SetToMin(max_size);
-
-  NSRect cocoa_bounds = NSMakeRect(bounds.x(), 0, size.width(), size.height());
-  // Flip coordinates based on the primary screen.
-  NSScreen* screen = [[NSScreen screens] firstObject];
-  cocoa_bounds.origin.y = NSHeight([screen frame]) - size.height() - bounds.y();
-
-  [window_ setFrame:cocoa_bounds display:YES animate:animate];
-}
-
-gfx::Rect NativeWindowMac::GetBounds() {
-  NSRect frame = [window_ frame];
-  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
-  NSScreen* screen = [[NSScreen screens] firstObject];
-  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
-  return bounds;
-}
-
-void NativeWindowMac::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  auto convertSize = [this](const gfx::Size& size) {
-    // Our frameless window still has titlebar attached, so setting contentSize
-    // will result in actual content size being larger.
-    if (!has_frame()) {
-      NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
-      NSRect content = [window_ originalContentRectForFrameRect:frame];
-      return content.size;
-    } else {
-      return NSMakeSize(size.width(), size.height());
-    }
-  };
-
-  NSView* content = [window_ contentView];
-  if (size_constraints.HasMinimumSize()) {
-    NSSize min_size = convertSize(size_constraints.GetMinimumSize());
-    [window_ setContentMinSize:[content convertSize:min_size toView:nil]];
-  }
-  if (size_constraints.HasMaximumSize()) {
-    NSSize max_size = convertSize(size_constraints.GetMaximumSize());
-    [window_ setContentMaxSize:[content convertSize:max_size toView:nil]];
-  }
-  NativeWindow::SetContentSizeConstraints(size_constraints);
-}
-
-void NativeWindowMac::MoveTop() {
-  [window_ orderWindow:NSWindowAbove relativeTo:0];
-}
-
-void NativeWindowMac::SetResizable(bool resizable) {
-  SetStyleMask(resizable, NSResizableWindowMask);
-}
-
-bool NativeWindowMac::IsResizable() {
-  return [window_ styleMask] & NSResizableWindowMask;
-}
-
-void NativeWindowMac::SetAspectRatio(double aspect_ratio,
-                                     const gfx::Size& extra_size) {
-  NativeWindow::SetAspectRatio(aspect_ratio, extra_size);
-
-  // Reset the behaviour to default if aspect_ratio is set to 0 or less.
-  if (aspect_ratio > 0.0)
-    [window_ setAspectRatio:NSMakeSize(aspect_ratio, 1.0)];
-  else
-    [window_ setResizeIncrements:NSMakeSize(1.0, 1.0)];
-}
-
-void NativeWindowMac::PreviewFile(const std::string& path,
-                                  const std::string& display_name) {
-  preview_item_.reset([[AtomPreviewItem alloc]
-      initWithURL:[NSURL fileURLWithPath:base::SysUTF8ToNSString(path)]
-            title:base::SysUTF8ToNSString(display_name)]);
-  [[QLPreviewPanel sharedPreviewPanel] makeKeyAndOrderFront:nil];
-}
-
-void NativeWindowMac::CloseFilePreview() {
-  if ([QLPreviewPanel sharedPreviewPanelExists]) {
-    [[QLPreviewPanel sharedPreviewPanel] close];
-  }
-}
-
-void NativeWindowMac::SetMovable(bool movable) {
-  [window_ setMovable:movable];
-}
-
-bool NativeWindowMac::IsMovable() {
-  return [window_ isMovable];
-}
-
-void NativeWindowMac::SetMinimizable(bool minimizable) {
-  SetStyleMask(minimizable, NSMiniaturizableWindowMask);
-}
-
-bool NativeWindowMac::IsMinimizable() {
-  return [window_ styleMask] & NSMiniaturizableWindowMask;
-}
-
-void NativeWindowMac::SetMaximizable(bool maximizable) {
-  [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:maximizable];
-}
-
-bool NativeWindowMac::IsMaximizable() {
-  return [[window_ standardWindowButton:NSWindowZoomButton] isEnabled];
-}
-
-void NativeWindowMac::SetFullScreenable(bool fullscreenable) {
-  SetCollectionBehavior(fullscreenable,
-                        NSWindowCollectionBehaviorFullScreenPrimary);
-  // On EL Capitan this flag is required to hide fullscreen button.
-  SetCollectionBehavior(!fullscreenable,
-                        NSWindowCollectionBehaviorFullScreenAuxiliary);
-}
-
-bool NativeWindowMac::IsFullScreenable() {
-  NSUInteger collectionBehavior = [window_ collectionBehavior];
-  return collectionBehavior & NSWindowCollectionBehaviorFullScreenPrimary;
-}
-
-void NativeWindowMac::SetClosable(bool closable) {
-  SetStyleMask(closable, NSClosableWindowMask);
-}
-
-bool NativeWindowMac::IsClosable() {
-  return [window_ styleMask] & NSClosableWindowMask;
-}
-
-void NativeWindowMac::SetAlwaysOnTop(bool top,
-                                     const std::string& level,
-                                     int relativeLevel,
-                                     std::string* error) {
-  int windowLevel = NSNormalWindowLevel;
-  CGWindowLevel maxWindowLevel = CGWindowLevelForKey(kCGMaximumWindowLevelKey);
-  CGWindowLevel minWindowLevel = CGWindowLevelForKey(kCGMinimumWindowLevelKey);
-
-  if (top) {
-    if (level == "floating") {
-      windowLevel = NSFloatingWindowLevel;
-    } else if (level == "torn-off-menu") {
-      windowLevel = NSTornOffMenuWindowLevel;
-    } else if (level == "modal-panel") {
-      windowLevel = NSModalPanelWindowLevel;
-    } else if (level == "main-menu") {
-      windowLevel = NSMainMenuWindowLevel;
-    } else if (level == "status") {
-      windowLevel = NSStatusWindowLevel;
-    } else if (level == "pop-up-menu") {
-      windowLevel = NSPopUpMenuWindowLevel;
-    } else if (level == "screen-saver") {
-      windowLevel = NSScreenSaverWindowLevel;
-    } else if (level == "dock") {
-      // Deprecated by macOS, but kept for backwards compatibility
-      windowLevel = NSDockWindowLevel;
-    }
-  }
-
-  NSInteger newLevel = windowLevel + relativeLevel;
-  if (newLevel >= minWindowLevel && newLevel <= maxWindowLevel) {
-    [window_ setLevel:newLevel];
-  } else {
-    *error = std::string([
-        [NSString stringWithFormat:@"relativeLevel must be between %d and %d",
-                                   minWindowLevel, maxWindowLevel] UTF8String]);
-  }
-}
-
-bool NativeWindowMac::IsAlwaysOnTop() {
-  return [window_ level] != NSNormalWindowLevel;
-}
-
-void NativeWindowMac::Center() {
-  [window_ center];
-}
-
-void NativeWindowMac::Invalidate() {
-  [window_ flushWindow];
-  [[window_ contentView] setNeedsDisplay:YES];
-}
-
-void NativeWindowMac::SetTitle(const std::string& title) {
-  // For macOS <= 10.9, the setTitleVisibility API is not available, we have
-  // to avoid calling setTitle for frameless window.
-  if (!base::mac::IsAtLeastOS10_10() && (transparent() || !has_frame()))
-    return;
-
-  [window_ setTitle:base::SysUTF8ToNSString(title)];
-}
-
-std::string NativeWindowMac::GetTitle() {
-  return base::SysNSStringToUTF8([window_ title]);
-  ;
-}
-
-void NativeWindowMac::FlashFrame(bool flash) {
-  if (flash) {
-    attention_request_id_ = [NSApp requestUserAttention:NSInformationalRequest];
-  } else {
-    [NSApp cancelUserAttentionRequest:attention_request_id_];
-    attention_request_id_ = 0;
-  }
-}
-
-void NativeWindowMac::SetSkipTaskbar(bool skip) {}
-
-void NativeWindowMac::SetSimpleFullScreen(bool simple_fullscreen) {
-  NSWindow* window = GetNativeWindow();
-
-  if (simple_fullscreen && !is_simple_fullscreen_) {
-    is_simple_fullscreen_ = true;
-
-    // Take note of the current window size
-    original_frame_ = [window frame];
-
-    simple_fullscreen_options_ = [NSApp currentSystemPresentationOptions];
-    simple_fullscreen_mask_ = [window styleMask];
-
-    // We can simulate the pre-Lion fullscreen by auto-hiding the dock and menu
-    // bar
-    NSApplicationPresentationOptions options =
-        NSApplicationPresentationAutoHideDock +
-        NSApplicationPresentationAutoHideMenuBar;
-    [NSApp setPresentationOptions:options];
-
-    was_maximizable_ = IsMaximizable();
-    was_movable_ = IsMovable();
-
-    NSRect fullscreenFrame = [window.screen frame];
-
-    if (!fullscreen_window_title()) {
-      // Hide the titlebar
-      SetStyleMask(false, NSTitledWindowMask);
-
-      // Resize the window to accomodate the _entire_ screen size
-      fullscreenFrame.size.height -=
-          [[[NSApplication sharedApplication] mainMenu] menuBarHeight];
-    } else if (!window_button_visibility_.has_value()) {
-      // Lets keep previous behaviour - hide window controls in titled
-      // fullscreen mode when not specified otherwise.
-      [[window standardWindowButton:NSWindowZoomButton] setHidden:YES];
-      [[window standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
-      [[window standardWindowButton:NSWindowCloseButton] setHidden:YES];
-    }
-
-    [window setFrame:fullscreenFrame display:YES animate:YES];
-
-    // Fullscreen windows can't be resized, minimized, maximized, or moved
-    SetMinimizable(false);
-    SetResizable(false);
-    SetMaximizable(false);
-    SetMovable(false);
-  } else if (!simple_fullscreen && is_simple_fullscreen_) {
-    is_simple_fullscreen_ = false;
-
-    if (!fullscreen_window_title()) {
-      // Restore the titlebar
-      SetStyleMask(true, NSTitledWindowMask);
-    }
-
-    // Restore window controls visibility state
-    const bool window_button_hidden = !window_button_visibility_.value_or(true);
-    [[window standardWindowButton:NSWindowZoomButton]
-        setHidden:window_button_hidden];
-    [[window standardWindowButton:NSWindowMiniaturizeButton]
-        setHidden:window_button_hidden];
-    [[window standardWindowButton:NSWindowCloseButton]
-        setHidden:window_button_hidden];
-
-    [window setFrame:original_frame_ display:YES animate:YES];
-
-    [NSApp setPresentationOptions:simple_fullscreen_options_];
-
-    // Restore original style mask
-    ScopedDisableResize disable_resize;
-    [window_ setStyleMask:simple_fullscreen_mask_];
-
-    // Restore window manipulation abilities
-    SetMaximizable(was_maximizable_);
-    SetMovable(was_movable_);
-  }
-}
-
-bool NativeWindowMac::IsSimpleFullScreen() {
-  return is_simple_fullscreen_;
-}
-
-void NativeWindowMac::SetKiosk(bool kiosk) {
-  if (kiosk && !is_kiosk_) {
-    kiosk_options_ = [NSApp currentSystemPresentationOptions];
-    NSApplicationPresentationOptions options =
-        NSApplicationPresentationHideDock +
-        NSApplicationPresentationHideMenuBar +
-        NSApplicationPresentationDisableAppleMenu +
-        NSApplicationPresentationDisableProcessSwitching +
-        NSApplicationPresentationDisableForceQuit +
-        NSApplicationPresentationDisableSessionTermination +
-        NSApplicationPresentationDisableHideApplication;
-    [NSApp setPresentationOptions:options];
-    is_kiosk_ = true;
-    was_fullscreen_ = IsFullscreen();
-    if (!was_fullscreen_)
-      SetFullScreen(true);
-  } else if (!kiosk && is_kiosk_) {
-    is_kiosk_ = false;
-    if (!was_fullscreen_)
-      SetFullScreen(false);
-    [NSApp setPresentationOptions:kiosk_options_];
-  }
-}
-
-bool NativeWindowMac::IsKiosk() {
-  return is_kiosk_;
-}
-
-void NativeWindowMac::SetBackgroundColor(SkColor color) {
-  base::ScopedCFTypeRef<CGColorRef> cgcolor(
-      skia::CGColorCreateFromSkColor(color));
-  // views::Widget adds a layer for the content view.
-  auto* bridge = views::NativeWidgetMac::GetBridgeForNativeWindow(window_);
-  NSView* compositor_superview =
-      static_cast<ui::AcceleratedWidgetMacNSView*>(bridge)
-          ->AcceleratedWidgetGetNSView();
-  [[compositor_superview layer] setBackgroundColor:cgcolor];
-  // When using WebContents as content view, the contentView also has layer.
-  if ([[window_ contentView] wantsLayer])
-    [[[window_ contentView] layer] setBackgroundColor:cgcolor];
-}
-
-void NativeWindowMac::SetHasShadow(bool has_shadow) {
-  [window_ setHasShadow:has_shadow];
-}
-
-bool NativeWindowMac::HasShadow() {
-  return [window_ hasShadow];
-}
-
-void NativeWindowMac::SetOpacity(const double opacity) {
-  [window_ setAlphaValue:opacity];
-}
-
-double NativeWindowMac::GetOpacity() {
-  return [window_ alphaValue];
-}
-
-void NativeWindowMac::SetRepresentedFilename(const std::string& filename) {
-  [window_ setRepresentedFilename:base::SysUTF8ToNSString(filename)];
-}
-
-std::string NativeWindowMac::GetRepresentedFilename() {
-  return base::SysNSStringToUTF8([window_ representedFilename]);
-}
-
-void NativeWindowMac::SetDocumentEdited(bool edited) {
-  [window_ setDocumentEdited:edited];
-}
-
-bool NativeWindowMac::IsDocumentEdited() {
-  return [window_ isDocumentEdited];
-}
-
-void NativeWindowMac::SetIgnoreMouseEvents(bool ignore, bool forward) {
-  [window_ setIgnoresMouseEvents:ignore];
-
-  if (!ignore) {
-    SetForwardMouseMessages(NO);
-  } else {
-    SetForwardMouseMessages(forward);
-  }
-}
-
-void NativeWindowMac::SetContentProtection(bool enable) {
-  [window_
-      setSharingType:enable ? NSWindowSharingNone : NSWindowSharingReadOnly];
-}
-
-void NativeWindowMac::SetBrowserView(NativeBrowserView* view) {
-  if (browser_view()) {
-    [browser_view()->GetInspectableWebContentsView()->GetNativeView()
-            removeFromSuperview];
-    set_browser_view(nullptr);
-  }
-
-  if (!view) {
-    return;
-  }
-
-  set_browser_view(view);
-  auto* native_view = view->GetInspectableWebContentsView()->GetNativeView();
-  [[window_ contentView] addSubview:native_view
-                         positioned:NSWindowAbove
-                         relativeTo:nil];
-  native_view.hidden = NO;
-}
-
-void NativeWindowMac::SetParentWindow(NativeWindow* parent) {
-  InternalSetParentWindow(parent, IsVisible());
-}
-
-gfx::NativeView NativeWindowMac::GetNativeView() const {
-  return [window_ contentView];
-}
-
-gfx::NativeWindow NativeWindowMac::GetNativeWindow() const {
-  return window_;
-}
-
-gfx::AcceleratedWidget NativeWindowMac::GetAcceleratedWidget() const {
-  return gfx::kNullAcceleratedWidget;
-}
-
-void NativeWindowMac::SetProgressBar(double progress,
-                                     const NativeWindow::ProgressState state) {
-  NSDockTile* dock_tile = [NSApp dockTile];
-
-  // For the first time API invoked, we need to create a ContentView in
-  // DockTile.
-  if (dock_tile.contentView == nullptr) {
-    NSImageView* image_view = [[NSImageView alloc] init];
-    [image_view setImage:[NSApp applicationIconImage]];
-    [dock_tile setContentView:image_view];
-  }
-
-  if ([[dock_tile.contentView subviews] count] == 0) {
-    NSProgressIndicator* progress_indicator = [[AtomProgressBar alloc]
-        initWithFrame:NSMakeRect(0.0f, 0.0f, dock_tile.size.width, 15.0)];
-    [progress_indicator setStyle:NSProgressIndicatorBarStyle];
-    [progress_indicator setIndeterminate:NO];
-    [progress_indicator setBezeled:YES];
-    [progress_indicator setMinValue:0];
-    [progress_indicator setMaxValue:1];
-    [progress_indicator setHidden:NO];
-    [dock_tile.contentView addSubview:progress_indicator];
-  }
-
-  NSProgressIndicator* progress_indicator = static_cast<NSProgressIndicator*>(
-      [[[dock_tile contentView] subviews] objectAtIndex:0]);
-  if (progress < 0) {
-    [progress_indicator setHidden:YES];
-  } else if (progress > 1) {
-    [progress_indicator setHidden:NO];
-    [progress_indicator setIndeterminate:YES];
-    [progress_indicator setDoubleValue:1];
-  } else {
-    [progress_indicator setHidden:NO];
-    [progress_indicator setDoubleValue:progress];
-  }
-  [dock_tile display];
-}
-
-void NativeWindowMac::SetOverlayIcon(const gfx::Image& overlay,
-                                     const std::string& description) {}
-
-void NativeWindowMac::SetVisibleOnAllWorkspaces(bool visible) {
-  SetCollectionBehavior(visible, NSWindowCollectionBehaviorCanJoinAllSpaces);
-}
-
-bool NativeWindowMac::IsVisibleOnAllWorkspaces() {
-  NSUInteger collectionBehavior = [window_ collectionBehavior];
-  return collectionBehavior & NSWindowCollectionBehaviorCanJoinAllSpaces;
-}
-
-void NativeWindowMac::SetAutoHideCursor(bool auto_hide) {
-  [window_ setDisableAutoHideCursor:!auto_hide];
-}
-
-void NativeWindowMac::SelectPreviousTab() {
-  if (@available(macOS 10.12, *)) {
-    [window_ selectPreviousTab:nil];
-  }
-}
-
-void NativeWindowMac::SelectNextTab() {
-  if (@available(macOS 10.12, *)) {
-    [window_ selectNextTab:nil];
-  }
-}
-
-void NativeWindowMac::MergeAllWindows() {
-  if (@available(macOS 10.12, *)) {
-    [window_ mergeAllWindows:nil];
-  }
-}
-
-void NativeWindowMac::MoveTabToNewWindow() {
-  if (@available(macOS 10.12, *)) {
-    [window_ moveTabToNewWindow:nil];
-  }
-}
-
-void NativeWindowMac::ToggleTabBar() {
-  if (@available(macOS 10.12, *)) {
-    [window_ toggleTabBar:nil];
-  }
-}
-
-bool NativeWindowMac::AddTabbedWindow(NativeWindow* window) {
-  if (window_ == window->GetNativeWindow()) {
-    return false;
-  } else {
-    if (@available(macOS 10.12, *))
-      [window_ addTabbedWindow:window->GetNativeWindow() ordered:NSWindowAbove];
-  }
-  return true;
-}
-
-bool NativeWindowMac::SetWindowButtonVisibility(bool visible) {
-  if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER) {
-    return false;
-  }
-
-  window_button_visibility_ = visible;
-
-  [[window_ standardWindowButton:NSWindowCloseButton] setHidden:!visible];
-  [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:!visible];
-  [[window_ standardWindowButton:NSWindowZoomButton] setHidden:!visible];
-  return true;
-}
-
-void NativeWindowMac::SetVibrancy(const std::string& type) {
-  if (@available(macOS 10.10, *)) {
-    NSView* vibrant_view = [window_ vibrantView];
-
-    if (type.empty()) {
-      if (background_color_before_vibrancy_) {
-        [window_ setBackgroundColor:background_color_before_vibrancy_];
-        [window_ setTitlebarAppearsTransparent:transparency_before_vibrancy_];
-      }
-      if (vibrant_view == nil)
-        return;
-
-      [vibrant_view removeFromSuperview];
-      [window_ setVibrantView:nil];
-      ui::GpuSwitchingManager::SetTransparent(transparent());
-
-      return;
-    }
-
-    background_color_before_vibrancy_.reset([[window_ backgroundColor] retain]);
-    transparency_before_vibrancy_ = [window_ titlebarAppearsTransparent];
-    ui::GpuSwitchingManager::SetTransparent(true);
-
-    if (title_bar_style_ != NORMAL) {
-      [window_ setTitlebarAppearsTransparent:YES];
-      [window_ setBackgroundColor:[NSColor clearColor]];
-    }
-
-    NSVisualEffectView* effect_view = (NSVisualEffectView*)vibrant_view;
-    if (effect_view == nil) {
-      effect_view = [[[NSVisualEffectView alloc]
-          initWithFrame:[[window_ contentView] bounds]] autorelease];
-      [window_ setVibrantView:(NSView*)effect_view];
-
-      [effect_view
-          setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-      [effect_view setBlendingMode:NSVisualEffectBlendingModeBehindWindow];
-      [effect_view setState:NSVisualEffectStateActive];
-      [[window_ contentView] addSubview:effect_view
-                             positioned:NSWindowBelow
-                             relativeTo:nil];
-    }
-
-    NSVisualEffectMaterial vibrancyType = NSVisualEffectMaterialLight;
-
-    if (type == "appearance-based") {
-      vibrancyType = NSVisualEffectMaterialAppearanceBased;
-    } else if (type == "light") {
-      vibrancyType = NSVisualEffectMaterialLight;
-    } else if (type == "dark") {
-      vibrancyType = NSVisualEffectMaterialDark;
-    } else if (type == "titlebar") {
-      vibrancyType = NSVisualEffectMaterialTitlebar;
-    }
-
-    if (@available(macOS 10.11, *)) {
-      // TODO(kevinsawicki): Use NSVisualEffectMaterial* constants directly once
-      // they are available in the minimum SDK version
-      if (type == "selection") {
-        // NSVisualEffectMaterialSelection
-        vibrancyType = static_cast<NSVisualEffectMaterial>(4);
-      } else if (type == "menu") {
-        // NSVisualEffectMaterialMenu
-        vibrancyType = static_cast<NSVisualEffectMaterial>(5);
-      } else if (type == "popover") {
-        // NSVisualEffectMaterialPopover
-        vibrancyType = static_cast<NSVisualEffectMaterial>(6);
-      } else if (type == "sidebar") {
-        // NSVisualEffectMaterialSidebar
-        vibrancyType = static_cast<NSVisualEffectMaterial>(7);
-      } else if (type == "medium-light") {
-        // NSVisualEffectMaterialMediumLight
-        vibrancyType = static_cast<NSVisualEffectMaterial>(8);
-      } else if (type == "ultra-dark") {
-        // NSVisualEffectMaterialUltraDark
-        vibrancyType = static_cast<NSVisualEffectMaterial>(9);
-      }
-    }
-
-    [effect_view setMaterial:vibrancyType];
-  }
-}
-
-void NativeWindowMac::SetTouchBar(
-    const std::vector<mate::PersistentDictionary>& items) {
-  if (@available(macOS 10.12.2, *)) {
-    touch_bar_.reset([[AtomTouchBar alloc]
-        initWithDelegate:window_delegate_.get()
-                  window:this
-                settings:items]);
-    [window_ setTouchBar:nil];
-  }
-}
-
-void NativeWindowMac::RefreshTouchBarItem(const std::string& item_id) {
-  if (@available(macOS 10.12.2, *)) {
-    if (touch_bar_ && [window_ touchBar])
-      [touch_bar_ refreshTouchBarItem:[window_ touchBar] id:item_id];
-  }
-}
-
-void NativeWindowMac::SetEscapeTouchBarItem(
-    const mate::PersistentDictionary& item) {
-  if (@available(macOS 10.12.2, *)) {
-    if (touch_bar_ && [window_ touchBar])
-      [touch_bar_ setEscapeTouchBarItem:item forTouchBar:[window_ touchBar]];
-  }
-}
-
-gfx::Rect NativeWindowMac::ContentBoundsToWindowBounds(
-    const gfx::Rect& bounds) const {
-  if (has_frame()) {
-    gfx::Rect window_bounds(
-        [window_ frameRectForContentRect:bounds.ToCGRect()]);
-    int frame_height = window_bounds.height() - bounds.height();
-    window_bounds.set_y(window_bounds.y() - frame_height);
-    return window_bounds;
-  } else {
-    return bounds;
-  }
-}
-
-gfx::Rect NativeWindowMac::WindowBoundsToContentBounds(
-    const gfx::Rect& bounds) const {
-  if (has_frame()) {
-    gfx::Rect content_bounds(
-        [window_ contentRectForFrameRect:bounds.ToCGRect()]);
-    int frame_height = bounds.height() - content_bounds.height();
-    content_bounds.set_y(content_bounds.y() + frame_height);
-    return content_bounds;
-  } else {
-    return bounds;
-  }
-}
-
-bool NativeWindowMac::CanResize() const {
-  return resizable_;
-}
-
-views::View* NativeWindowMac::GetContentsView() {
-  return root_view_.get();
-}
-
-void NativeWindowMac::AddContentViewLayers() {
-  // Make sure the bottom corner is rounded for non-modal windows:
-  // http://crbug.com/396264. But do not enable it on OS X 10.9 for transparent
-  // window, otherwise a semi-transparent frame would show.
-  if (!(transparent() && base::mac::IsOS10_9()) && !is_modal()) {
-    base::scoped_nsobject<CALayer> background_layer([[CALayer alloc] init]);
-    [background_layer
-        setAutoresizingMask:kCALayerWidthSizable | kCALayerHeightSizable];
-    [[window_ contentView] setLayer:background_layer];
-    [[window_ contentView] setWantsLayer:YES];
-  }
-
-  if (!has_frame()) {
-    // In OSX 10.10, adding subviews to the root view for the NSView hierarchy
-    // produces warnings. To eliminate the warnings, we resize the contentView
-    // to fill the window, and add subviews to that.
-    // http://crbug.com/380412
-    if (!original_set_frame_size) {
-      Class cl = [[window_ contentView] class];
-      original_set_frame_size = class_replaceMethod(
-          cl, @selector(setFrameSize:), (IMP)SetFrameSize, "v@:{_NSSize=ff}");
-      original_view_did_move_to_superview =
-          class_replaceMethod(cl, @selector(viewDidMoveToSuperview),
-                              (IMP)ViewDidMoveToSuperview, "v@:");
-      [[window_ contentView] viewDidMoveToWindow];
-    }
-
-    // The fullscreen button should always be hidden for frameless window.
-    [[window_ standardWindowButton:NSWindowFullScreenButton] setHidden:YES];
-
-    if (title_bar_style_ == CUSTOM_BUTTONS_ON_HOVER) {
-      buttons_view_.reset(
-          [[CustomWindowButtonView alloc] initWithFrame:NSZeroRect]);
-      [[window_ contentView] addSubview:buttons_view_];
-    } else {
-      if (title_bar_style_ != NORMAL) {
-        if (base::mac::IsOS10_9()) {
-          ShowWindowButton(NSWindowZoomButton);
-          ShowWindowButton(NSWindowMiniaturizeButton);
-          ShowWindowButton(NSWindowCloseButton);
-        }
-        return;
-      }
-
-      // Hide the window buttons.
-      [[window_ standardWindowButton:NSWindowZoomButton] setHidden:YES];
-      [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
-      [[window_ standardWindowButton:NSWindowCloseButton] setHidden:YES];
-    }
-
-    // Some third-party macOS utilities check the zoom button's enabled state to
-    // determine whether to show custom UI on hover, so we disable it here to
-    // prevent them from doing so in a frameless app window.
-    [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:NO];
-  }
-}
-
-void NativeWindowMac::InternalSetParentWindow(NativeWindow* parent,
-                                              bool attach) {
-  if (is_modal())
-    return;
-
-  NativeWindow::SetParentWindow(parent);
-
-  // Do not remove/add if we are already properly attached.
-  if (attach && parent && [window_ parentWindow] == parent->GetNativeWindow())
-    return;
-
-  // Remove current parent window.
-  if ([window_ parentWindow])
-    [[window_ parentWindow] removeChildWindow:window_];
-
-  // Set new parent window.
-  // Note that this method will force the window to become visible.
-  if (parent && attach)
-    [parent->GetNativeWindow() addChildWindow:window_ ordered:NSWindowAbove];
-}
-
-void NativeWindowMac::ShowWindowButton(NSWindowButton button) {
-  auto view = [window_ standardWindowButton:button];
-  [view.superview addSubview:view positioned:NSWindowAbove relativeTo:nil];
-}
-
-void NativeWindowMac::SetForwardMouseMessages(bool forward) {
-  [window_ setAcceptsMouseMovedEvents:forward];
-}
-
-void NativeWindowMac::OverrideNSWindowContentView() {
-  // When using `views::Widget` to hold WebContents, Chromium would use
-  // `BridgedContentView` as content view, which does not support draggable
-  // regions. In order to make draggable regions work, we have to replace the
-  // content view with a simple NSView.
-  container_view_.reset([[FullSizeContentView alloc] init]);
-  [container_view_
-      setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
-  [container_view_ setFrame:[[[window_ contentView] superview] bounds]];
-  [window_ setContentView:container_view_];
-  AddContentViewLayers();
-}
-
-void NativeWindowMac::SetStyleMask(bool on, NSUInteger flag) {
-  // Changing the styleMask of a frameless windows causes it to change size so
-  // we explicitly disable resizing while setting it.
-  ScopedDisableResize disable_resize;
-
-  bool was_maximizable = IsMaximizable();
-  if (on)
-    [window_ setStyleMask:[window_ styleMask] | flag];
-  else
-    [window_ setStyleMask:[window_ styleMask] & (~flag)];
-  // Change style mask will make the zoom button revert to default, probably
-  // a bug of Cocoa or macOS.
-  SetMaximizable(was_maximizable);
-}
-
-void NativeWindowMac::SetCollectionBehavior(bool on, NSUInteger flag) {
-  bool was_maximizable = IsMaximizable();
-  if (on)
-    [window_ setCollectionBehavior:[window_ collectionBehavior] | flag];
-  else
-    [window_ setCollectionBehavior:[window_ collectionBehavior] & (~flag)];
-  // Change collectionBehavior will make the zoom button revert to default,
-  // probably a bug of Cocoa or macOS.
-  SetMaximizable(was_maximizable);
-}
-
-// static
-NativeWindow* NativeWindow::Create(const mate::Dictionary& options,
-                                   NativeWindow* parent) {
-  return new NativeWindowMac(options, parent);
-}
-
-}  // namespace atom
removed in remote
  base   100644 cfbae95bda16a262457339e093943d371128199d atom/browser/native_window_observer.h
  our    100644 c2a86ea6b65cd6091fa7e8018bed0b11c7390f23 atom/browser/native_window_observer.h
@@ -1,99 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
-
-#include <string>
-
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "ui/base/window_open_disposition.h"
-#include "url/gurl.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#endif
-
-namespace gfx {
-class Rect;
-}
-
-namespace atom {
-
-class NativeWindowObserver {
- public:
-  virtual ~NativeWindowObserver() {}
-
-  // Called when the web page in window wants to create a popup window.
-  virtual void WillCreatePopupWindow(const base::string16& frame_name,
-                                     const GURL& target_url,
-                                     const std::string& partition_id,
-                                     WindowOpenDisposition disposition) {}
-
-  // Called when user is starting an navigation in web page.
-  virtual void WillNavigate(bool* prevent_default, const GURL& url) {}
-
-  // Called when the window is gonna closed.
-  virtual void WillCloseWindow(bool* prevent_default) {}
-
-  // Called when the window wants to know the preferred width.
-  virtual void RequestPreferredWidth(int* width) {}
-
-  // Called when closed button is clicked.
-  virtual void OnCloseButtonClicked(bool* prevent_default) {}
-
-  // Called when the window is closed.
-  virtual void OnWindowClosed() {}
-
-  // Called when Windows sends WM_ENDSESSION message
-  virtual void OnWindowEndSession() {}
-
-  // Called when window loses focus.
-  virtual void OnWindowBlur() {}
-
-  // Called when window gains focus.
-  virtual void OnWindowFocus() {}
-
-  // Called when window is shown.
-  virtual void OnWindowShow() {}
-
-  // Called when window is hidden.
-  virtual void OnWindowHide() {}
-
-  // Called when window state changed.
-  virtual void OnWindowMaximize() {}
-  virtual void OnWindowUnmaximize() {}
-  virtual void OnWindowMinimize() {}
-  virtual void OnWindowRestore() {}
-  virtual void OnWindowWillResize(const gfx::Rect& new_bounds,
-                                  bool* prevent_default) {}
-  virtual void OnWindowResize() {}
-  virtual void OnWindowMove() {}
-  virtual void OnWindowMoved() {}
-  virtual void OnWindowScrollTouchBegin() {}
-  virtual void OnWindowScrollTouchEnd() {}
-  virtual void OnWindowSwipe(const std::string& direction) {}
-  virtual void OnWindowSheetBegin() {}
-  virtual void OnWindowSheetEnd() {}
-  virtual void OnWindowEnterFullScreen() {}
-  virtual void OnWindowLeaveFullScreen() {}
-  virtual void OnWindowEnterHtmlFullScreen() {}
-  virtual void OnWindowLeaveHtmlFullScreen() {}
-  virtual void OnTouchBarItemResult(const std::string& item_id,
-                                    const base::DictionaryValue& details) {}
-  virtual void OnNewWindowForTab() {}
-
-// Called when window message received
-#if defined(OS_WIN)
-  virtual void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {}
-#endif
-
-  // Called on Windows when App Commands arrive (WM_APPCOMMAND)
-  virtual void OnExecuteWindowsCommand(const std::string& command_name) {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_OBSERVER_H_
removed in remote
  base   100644 15f2046364bbff669e4a1f90ae755191ee72939e atom/browser/native_window_views.cc
  our    100644 0dba39942f92d54ba34db7709b73012055680d94 atom/browser/native_window_views.cc
@@ -1,1260 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/native_window_views.h"
-
-#if defined(OS_WIN)
-#include <objbase.h>
-#include <wrl/client.h>
-#endif
-
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/native_browser_view_views.h"
-#include "atom/browser/ui/views/root_view.h"
-#include "atom/browser/web_contents_preferences.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/browser/window_list.h"
-#include "atom/common/draggable_region.h"
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/strings/utf_string_conversions.h"
-#include "brightray/browser/inspectable_web_contents.h"
-#include "brightray/browser/inspectable_web_contents_view.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/dictionary.h"
-#include "ui/aura/window_tree_host.h"
-#include "ui/base/hit_test.h"
-#include "ui/gfx/image/image.h"
-#include "ui/views/background.h"
-#include "ui/views/controls/webview/unhandled_keyboard_event_handler.h"
-#include "ui/views/controls/webview/webview.h"
-#include "ui/views/widget/native_widget_private.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/window/client_view.h"
-#include "ui/wm/core/shadow_types.h"
-#include "ui/wm/core/window_util.h"
-
-#if defined(USE_X11)
-#include "atom/browser/browser.h"
-#include "atom/browser/ui/views/frameless_view.h"
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
-#include "atom/browser/ui/views/native_frame_view.h"
-#include "atom/browser/ui/x/event_disabler.h"
-#include "atom/browser/ui/x/window_state_watcher.h"
-#include "atom/browser/ui/x/x_window_utils.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/ui/libgtkui/unity_service.h"
-#include "ui/base/x/x11_util.h"
-#include "ui/gfx/x/x11_types.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_x11.h"
-#include "ui/views/window/native_frame_view.h"
-#elif defined(OS_WIN)
-#include "atom/browser/ui/views/win_frame_view.h"
-#include "atom/browser/ui/win/atom_desktop_native_widget_aura.h"
-#include "atom/browser/ui/win/atom_desktop_window_tree_host_win.h"
-#include "skia/ext/skia_utils_win.h"
-#include "ui/base/win/shell.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-#if defined(OS_WIN)
-void FlipWindowStyle(HWND handle, bool on, DWORD flag) {
-  DWORD style = ::GetWindowLong(handle, GWL_STYLE);
-  if (on)
-    style |= flag;
-  else
-    style &= ~flag;
-  ::SetWindowLong(handle, GWL_STYLE, style);
-}
-#endif
-
-class NativeWindowClientView : public views::ClientView {
- public:
-  NativeWindowClientView(views::Widget* widget,
-                         views::View* root_view,
-                         NativeWindowViews* window)
-      : views::ClientView(widget, root_view), window_(window) {}
-  ~NativeWindowClientView() override = default;
-
-  bool CanClose() override {
-    window_->NotifyWindowCloseButtonClicked();
-    return false;
-  }
-
- private:
-  NativeWindowViews* window_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowClientView);
-};
-
-}  // namespace
-
-NativeWindowViews::NativeWindowViews(const mate::Dictionary& options,
-                                     NativeWindow* parent)
-    : NativeWindow(options, parent),
-      root_view_(new RootView(this)),
-      keyboard_event_handler_(new views::UnhandledKeyboardEventHandler) {
-  options.Get(options::kTitle, &title_);
-
-  bool menu_bar_autohide;
-  if (options.Get(options::kAutoHideMenuBar, &menu_bar_autohide))
-    root_view_->SetAutoHideMenuBar(menu_bar_autohide);
-
-#if defined(OS_WIN)
-  // On Windows we rely on the CanResize() to indicate whether window can be
-  // resized, and it should be set before window is created.
-  options.Get(options::kResizable, &resizable_);
-  options.Get(options::kMinimizable, &minimizable_);
-  options.Get(options::kMaximizable, &maximizable_);
-
-  // Transparent window must not have thick frame.
-  options.Get("thickFrame", &thick_frame_);
-  if (transparent())
-    thick_frame_ = false;
-#endif
-
-  if (enable_larger_than_screen())
-    // We need to set a default maximum window size here otherwise Windows
-    // will not allow us to resize the window larger than scree.
-    // Setting directly to INT_MAX somehow doesn't work, so we just devide
-    // by 10, which should still be large enough.
-    SetContentSizeConstraints(extensions::SizeConstraints(
-        gfx::Size(), gfx::Size(INT_MAX / 10, INT_MAX / 10)));
-
-  int width = 800, height = 600;
-  options.Get(options::kWidth, &width);
-  options.Get(options::kHeight, &height);
-  gfx::Rect bounds(0, 0, width, height);
-  widget_size_ = bounds.size();
-
-  widget()->AddObserver(this);
-
-  views::Widget::InitParams params;
-  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
-  params.bounds = bounds;
-  params.delegate = this;
-  params.type = views::Widget::InitParams::TYPE_WINDOW;
-  params.remove_standard_frame = !has_frame();
-
-  if (transparent())
-    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
-
-  // The given window is most likely not rectangular since it uses
-  // transparency and has no standard frame, don't show a shadow for it.
-  if (transparent() && !has_frame())
-    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
-
-  bool focusable;
-  if (options.Get(options::kFocusable, &focusable) && !focusable)
-    params.activatable = views::Widget::InitParams::ACTIVATABLE_NO;
-
-#if defined(OS_WIN)
-  if (parent)
-    params.parent = parent->GetNativeWindow();
-
-  params.native_widget = new AtomDesktopNativeWidgetAura(widget());
-  atom_desktop_window_tree_host_win_ = new AtomDesktopWindowTreeHostWin(
-      this, widget(),
-      static_cast<views::DesktopNativeWidgetAura*>(params.native_widget));
-  params.desktop_window_tree_host = atom_desktop_window_tree_host_win_;
-#elif defined(USE_X11)
-  std::string name = Browser::Get()->GetName();
-  // Set WM_WINDOW_ROLE.
-  params.wm_role_name = "browser-window";
-  // Set WM_CLASS.
-  params.wm_class_name = base::ToLowerASCII(name);
-  params.wm_class_class = name;
-#endif
-
-  widget()->Init(params);
-
-  bool fullscreen = false;
-  options.Get(options::kFullscreen, &fullscreen);
-
-  std::string window_type;
-  options.Get(options::kType, &window_type);
-
-#if defined(USE_X11)
-  // Start monitoring window states.
-  window_state_watcher_.reset(new WindowStateWatcher(this));
-
-  // Set _GTK_THEME_VARIANT to dark if we have "dark-theme" option set.
-  bool use_dark_theme = false;
-  if (options.Get(options::kDarkTheme, &use_dark_theme) && use_dark_theme) {
-    XDisplay* xdisplay = gfx::GetXDisplay();
-    XChangeProperty(xdisplay, GetAcceleratedWidget(),
-                    XInternAtom(xdisplay, "_GTK_THEME_VARIANT", x11::False),
-                    XInternAtom(xdisplay, "UTF8_STRING", x11::False), 8,
-                    PropModeReplace,
-                    reinterpret_cast<const unsigned char*>("dark"), 4);
-  }
-
-  // Before the window is mapped the SetWMSpecState can not work, so we have
-  // to manually set the _NET_WM_STATE.
-  std::vector<::Atom> state_atom_list;
-  bool skip_taskbar = false;
-  if (options.Get(options::kSkipTaskbar, &skip_taskbar) && skip_taskbar) {
-    state_atom_list.push_back(GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
-  }
-
-  // Before the window is mapped, there is no SHOW_FULLSCREEN_STATE.
-  if (fullscreen) {
-    state_atom_list.push_back(GetAtom("_NET_WM_STATE_FULLSCREEN"));
-  }
-
-  if (parent) {
-    SetParentWindow(parent);
-    // Force using dialog type for child window.
-    window_type = "dialog";
-    // Modal window needs the _NET_WM_STATE_MODAL hint.
-    if (is_modal())
-      state_atom_list.push_back(GetAtom("_NET_WM_STATE_MODAL"));
-  }
-
-  if (!state_atom_list.empty())
-    ui::SetAtomArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", "ATOM",
-                             state_atom_list);
-
-  // Set the _NET_WM_WINDOW_TYPE.
-  if (!window_type.empty())
-    SetWindowType(GetAcceleratedWidget(), window_type);
-#endif
-
-#if defined(OS_WIN)
-  if (!has_frame()) {
-    // Set Window style so that we get a minimize and maximize animation when
-    // frameless.
-    DWORD frame_style = WS_CAPTION;
-    if (resizable_)
-      frame_style |= WS_THICKFRAME;
-    if (minimizable_)
-      frame_style |= WS_MINIMIZEBOX;
-    if (maximizable_)
-      frame_style |= WS_MAXIMIZEBOX;
-    // We should not show a frame for transparent window.
-    if (!thick_frame_)
-      frame_style &= ~(WS_THICKFRAME | WS_CAPTION);
-    ::SetWindowLong(GetAcceleratedWidget(), GWL_STYLE, frame_style);
-  }
-
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (window_type == "toolbar")
-    ex_style |= WS_EX_TOOLWINDOW;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-#endif
-
-  if (has_frame()) {
-    // TODO(zcbenz): This was used to force using native frame on Windows 2003,
-    // we should check whether setting it in InitParams can work.
-    widget()->set_frame_type(views::Widget::FrameType::FRAME_TYPE_FORCE_NATIVE);
-    widget()->FrameTypeChanged();
-#if defined(OS_WIN)
-    // thickFrame also works for normal window.
-    if (!thick_frame_)
-      FlipWindowStyle(GetAcceleratedWidget(), false, WS_THICKFRAME);
-#endif
-  }
-
-  // Default content view.
-  SetContentView(new views::View());
-
-  gfx::Size size = bounds.size();
-  if (has_frame() &&
-      options.Get(options::kUseContentSize, &use_content_size_) &&
-      use_content_size_)
-    size = ContentBoundsToWindowBounds(gfx::Rect(size)).size();
-
-  widget()->CenterWindow(size);
-
-#if defined(OS_WIN)
-  // Save initial window state.
-  if (fullscreen)
-    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-  else
-    last_window_state_ = ui::SHOW_STATE_NORMAL;
-  last_normal_bounds_ = GetBounds();
-#endif
-}
-
-NativeWindowViews::~NativeWindowViews() {
-  widget()->RemoveObserver(this);
-
-#if defined(OS_WIN)
-  // Disable mouse forwarding to relinquish resources, should any be held.
-  SetForwardMouseMessages(false);
-#endif
-}
-
-void NativeWindowViews::SetContentView(views::View* view) {
-  if (content_view()) {
-    root_view_->RemoveChildView(content_view());
-    if (browser_view()) {
-      content_view()->RemoveChildView(
-          browser_view()->GetInspectableWebContentsView()->GetView());
-      set_browser_view(nullptr);
-    }
-  }
-  set_content_view(view);
-  focused_view_ = view;
-  root_view_->AddChildView(content_view());
-  root_view_->Layout();
-}
-
-void NativeWindowViews::Close() {
-  if (!IsClosable()) {
-    WindowList::WindowCloseCancelled(this);
-    return;
-  }
-
-  widget()->Close();
-}
-
-void NativeWindowViews::CloseImmediately() {
-  widget()->CloseNow();
-}
-
-void NativeWindowViews::Focus(bool focus) {
-  // For hidden window focus() should do nothing.
-  if (!IsVisible())
-    return;
-
-  if (focus) {
-    widget()->Activate();
-  } else {
-    widget()->Deactivate();
-  }
-}
-
-bool NativeWindowViews::IsFocused() {
-  return widget()->IsActive();
-}
-
-void NativeWindowViews::Show() {
-  if (is_modal() && NativeWindow::parent() &&
-      !widget()->native_widget_private()->IsVisible())
-    NativeWindow::parent()->SetEnabled(false);
-
-  widget()->native_widget_private()->ShowWithWindowState(GetRestoredState());
-
-  NotifyWindowShow();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowMapped();
-#endif
-}
-
-void NativeWindowViews::ShowInactive() {
-  widget()->ShowInactive();
-
-  NotifyWindowShow();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowMapped();
-#endif
-}
-
-void NativeWindowViews::Hide() {
-  if (is_modal() && NativeWindow::parent())
-    NativeWindow::parent()->SetEnabled(true);
-
-  widget()->Hide();
-
-  NotifyWindowHide();
-
-#if defined(USE_X11)
-  if (global_menu_bar_)
-    global_menu_bar_->OnWindowUnmapped();
-#endif
-}
-
-bool NativeWindowViews::IsVisible() {
-  return widget()->IsVisible();
-}
-
-bool NativeWindowViews::IsEnabled() {
-#if defined(OS_WIN)
-  return ::IsWindowEnabled(GetAcceleratedWidget());
-#elif defined(USE_X11)
-  return !event_disabler_.get();
-#endif
-}
-
-void NativeWindowViews::SetEnabled(bool enable) {
-  // Handle multiple calls of SetEnabled correctly.
-  if (enable) {
-    --disable_count_;
-    if (disable_count_ != 0)
-      return;
-  } else {
-    ++disable_count_;
-    if (disable_count_ != 1)
-      return;
-  }
-
-#if defined(OS_WIN)
-  ::EnableWindow(GetAcceleratedWidget(), enable);
-#elif defined(USE_X11)
-  views::DesktopWindowTreeHostX11* tree_host =
-      views::DesktopWindowTreeHostX11::GetHostForXID(GetAcceleratedWidget());
-  if (enable) {
-    tree_host->RemoveEventRewriter(event_disabler_.get());
-    event_disabler_.reset();
-  } else {
-    event_disabler_.reset(new EventDisabler);
-    tree_host->AddEventRewriter(event_disabler_.get());
-  }
-#endif
-}
-
-void NativeWindowViews::Maximize() {
-#if defined(OS_WIN)
-  // For window without WS_THICKFRAME style, we can not call Maximize().
-  if (!(::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME)) {
-    restore_bounds_ = GetBounds();
-    auto display =
-        display::Screen::GetScreen()->GetDisplayNearestPoint(GetPosition());
-    SetBounds(display.work_area(), false);
-    return;
-  }
-#endif
-
-  if (IsVisible())
-    widget()->Maximize();
-  else
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_MAXIMIZED);
-}
-
-void NativeWindowViews::Unmaximize() {
-#if defined(OS_WIN)
-  if (!(::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME)) {
-    SetBounds(restore_bounds_, false);
-    return;
-  }
-#endif
-
-  widget()->Restore();
-}
-
-bool NativeWindowViews::IsMaximized() {
-  return widget()->IsMaximized();
-}
-
-void NativeWindowViews::Minimize() {
-  if (IsVisible())
-    widget()->Minimize();
-  else
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_MINIMIZED);
-}
-
-void NativeWindowViews::Restore() {
-  widget()->Restore();
-}
-
-bool NativeWindowViews::IsMinimized() {
-  return widget()->IsMinimized();
-}
-
-void NativeWindowViews::SetFullScreen(bool fullscreen) {
-  if (!IsFullScreenable())
-    return;
-
-#if defined(OS_WIN)
-  // There is no native fullscreen state on Windows.
-  bool leaving_fullscreen = IsFullscreen() && !fullscreen;
-
-  if (fullscreen) {
-    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-    NotifyWindowEnterFullScreen();
-  } else {
-    last_window_state_ = ui::SHOW_STATE_NORMAL;
-    NotifyWindowLeaveFullScreen();
-  }
-
-  // For window without WS_THICKFRAME style, we can not call SetFullscreen().
-  // This path will be used for transparent windows as well.
-  if (!thick_frame_) {
-    if (fullscreen) {
-      restore_bounds_ = GetBounds();
-      auto display =
-          display::Screen::GetScreen()->GetDisplayNearestPoint(GetPosition());
-      SetBounds(display.bounds(), false);
-    } else {
-      SetBounds(restore_bounds_, false);
-    }
-    return;
-  }
-
-  // We set the new value after notifying, so we can handle the size event
-  // correctly.
-  widget()->SetFullscreen(fullscreen);
-
-  // If restoring from fullscreen and the window isn't visible, force visible,
-  // else a non-responsive window shell could be rendered.
-  // (this situation may arise when app starts with fullscreen: true)
-  // Note: the following must be after "widget()->SetFullscreen(fullscreen);"
-  if (leaving_fullscreen && !IsVisible())
-    FlipWindowStyle(GetAcceleratedWidget(), true, WS_VISIBLE);
-#else
-  if (IsVisible())
-    widget()->SetFullscreen(fullscreen);
-  else if (fullscreen)
-    widget()->native_widget_private()->ShowWithWindowState(
-        ui::SHOW_STATE_FULLSCREEN);
-
-  // Auto-hide menubar when in fullscreen.
-  if (fullscreen)
-    SetMenuBarVisibility(false);
-  else
-    SetMenuBarVisibility(!IsMenuBarAutoHide());
-#endif
-}
-
-bool NativeWindowViews::IsFullscreen() const {
-  return widget()->IsFullscreen();
-}
-
-void NativeWindowViews::SetBounds(const gfx::Rect& bounds, bool animate) {
-#if defined(OS_WIN) || defined(USE_X11)
-  // On Linux and Windows the minimum and maximum size should be updated with
-  // window size when window is not resizable.
-  if (!resizable_) {
-    SetMaximumSize(bounds.size());
-    SetMinimumSize(bounds.size());
-  }
-#endif
-
-  widget()->SetBounds(bounds);
-}
-
-gfx::Rect NativeWindowViews::GetBounds() {
-#if defined(OS_WIN)
-  if (IsMinimized())
-    return widget()->GetRestoredBounds();
-#endif
-
-  return widget()->GetWindowBoundsInScreen();
-}
-
-gfx::Rect NativeWindowViews::GetContentBounds() {
-  return content_view() ? content_view()->GetBoundsInScreen() : gfx::Rect();
-}
-
-gfx::Size NativeWindowViews::GetContentSize() {
-#if defined(OS_WIN)
-  if (IsMinimized())
-    return NativeWindow::GetContentSize();
-#endif
-
-  return content_view() ? content_view()->size() : gfx::Size();
-}
-
-void NativeWindowViews::SetContentSizeConstraints(
-    const extensions::SizeConstraints& size_constraints) {
-  NativeWindow::SetContentSizeConstraints(size_constraints);
-#if defined(OS_WIN)
-  // Changing size constraints would force adding the WS_THICKFRAME style, so
-  // do nothing if thickFrame is false.
-  if (!thick_frame_)
-    return;
-#endif
-  // widget_delegate() is only available after Init() is called, we make use of
-  // this to determine whether native widget has initialized.
-  if (widget() && widget()->widget_delegate())
-    widget()->OnSizeConstraintsChanged();
-  if (resizable_)
-    old_size_constraints_ = size_constraints;
-}
-
-void NativeWindowViews::SetResizable(bool resizable) {
-  if (resizable != resizable_) {
-    // On Linux there is no "resizable" property of a window, we have to set
-    // both the minimum and maximum size to the window size to achieve it.
-    if (resizable) {
-      SetContentSizeConstraints(old_size_constraints_);
-    } else {
-      old_size_constraints_ = GetContentSizeConstraints();
-      resizable_ = false;
-      gfx::Size content_size = GetContentSize();
-      SetContentSizeConstraints(
-          extensions::SizeConstraints(content_size, content_size));
-    }
-  }
-#if defined(OS_WIN)
-  if (has_frame() && thick_frame_)
-    FlipWindowStyle(GetAcceleratedWidget(), resizable, WS_THICKFRAME);
-#endif
-
-  resizable_ = resizable;
-}
-
-#if defined(OS_WIN)
-void NativeWindowViews::MoveTop() {
-  gfx::Point pos = GetPosition();
-  gfx::Size size = GetSize();
-  ::SetWindowPos(GetAcceleratedWidget(), HWND_TOP, pos.x(), pos.y(),
-                 size.width(), size.height(),
-                 SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
-}
-#endif
-
-bool NativeWindowViews::IsResizable() {
-#if defined(OS_WIN)
-  if (has_frame())
-    return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME;
-#endif
-  return CanResize();
-}
-
-void NativeWindowViews::SetMovable(bool movable) {
-  movable_ = movable;
-}
-
-bool NativeWindowViews::IsMovable() {
-#if defined(OS_WIN)
-  return movable_;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetMinimizable(bool minimizable) {
-#if defined(OS_WIN)
-  FlipWindowStyle(GetAcceleratedWidget(), minimizable, WS_MINIMIZEBOX);
-#endif
-  minimizable_ = minimizable;
-}
-
-bool NativeWindowViews::IsMinimizable() {
-#if defined(OS_WIN)
-  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MINIMIZEBOX;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetMaximizable(bool maximizable) {
-#if defined(OS_WIN)
-  FlipWindowStyle(GetAcceleratedWidget(), maximizable, WS_MAXIMIZEBOX);
-#endif
-  maximizable_ = maximizable;
-}
-
-bool NativeWindowViews::IsMaximizable() {
-#if defined(OS_WIN)
-  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MAXIMIZEBOX;
-#else
-  return true;  // Not implemented on Linux.
-#endif
-}
-
-void NativeWindowViews::SetFullScreenable(bool fullscreenable) {
-  fullscreenable_ = fullscreenable;
-}
-
-bool NativeWindowViews::IsFullScreenable() {
-  return fullscreenable_;
-}
-
-void NativeWindowViews::SetClosable(bool closable) {
-#if defined(OS_WIN)
-  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
-  if (closable) {
-    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
-  } else {
-    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
-  }
-#endif
-}
-
-bool NativeWindowViews::IsClosable() {
-#if defined(OS_WIN)
-  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
-  MENUITEMINFO info;
-  memset(&info, 0, sizeof(info));
-  info.cbSize = sizeof(info);
-  info.fMask = MIIM_STATE;
-  if (!GetMenuItemInfo(menu, SC_CLOSE, false, &info)) {
-    return false;
-  }
-  return !(info.fState & MFS_DISABLED);
-#elif defined(USE_X11)
-  return true;
-#endif
-}
-
-void NativeWindowViews::SetAlwaysOnTop(bool top,
-                                       const std::string& level,
-                                       int relativeLevel,
-                                       std::string* error) {
-  widget()->SetAlwaysOnTop(top);
-}
-
-bool NativeWindowViews::IsAlwaysOnTop() {
-  return widget()->IsAlwaysOnTop();
-}
-
-void NativeWindowViews::Center() {
-  widget()->CenterWindow(GetSize());
-}
-
-void NativeWindowViews::Invalidate() {
-  widget()->SchedulePaintInRect(gfx::Rect(GetBounds().size()));
-}
-
-void NativeWindowViews::SetTitle(const std::string& title) {
-  title_ = title;
-  widget()->UpdateWindowTitle();
-}
-
-std::string NativeWindowViews::GetTitle() {
-  return title_;
-}
-
-void NativeWindowViews::FlashFrame(bool flash) {
-#if defined(OS_WIN)
-  // The Chromium's implementation has a bug stopping flash.
-  if (!flash) {
-    FLASHWINFO fwi;
-    fwi.cbSize = sizeof(fwi);
-    fwi.hwnd = GetAcceleratedWidget();
-    fwi.dwFlags = FLASHW_STOP;
-    fwi.uCount = 0;
-    FlashWindowEx(&fwi);
-    return;
-  }
-#endif
-  widget()->FlashFrame(flash);
-}
-
-void NativeWindowViews::SetSkipTaskbar(bool skip) {
-#if defined(OS_WIN)
-  Microsoft::WRL::ComPtr<ITaskbarList> taskbar;
-  if (FAILED(::CoCreateInstance(CLSID_TaskbarList, nullptr,
-                                CLSCTX_INPROC_SERVER,
-                                IID_PPV_ARGS(&taskbar))) ||
-      FAILED(taskbar->HrInit()))
-    return;
-  if (skip) {
-    taskbar->DeleteTab(GetAcceleratedWidget());
-  } else {
-    taskbar->AddTab(GetAcceleratedWidget());
-    taskbar_host_.RestoreThumbarButtons(GetAcceleratedWidget());
-  }
-#elif defined(USE_X11)
-  SetWMSpecState(GetAcceleratedWidget(), skip,
-                 GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
-#endif
-}
-
-void NativeWindowViews::SetSimpleFullScreen(bool simple_fullscreen) {
-  SetFullScreen(simple_fullscreen);
-}
-
-bool NativeWindowViews::IsSimpleFullScreen() {
-  return IsFullscreen();
-}
-
-void NativeWindowViews::SetKiosk(bool kiosk) {
-  SetFullScreen(kiosk);
-}
-
-bool NativeWindowViews::IsKiosk() {
-  return IsFullscreen();
-}
-
-void NativeWindowViews::SetBackgroundColor(SkColor background_color) {
-  // web views' background color.
-  root_view_->SetBackground(views::CreateSolidBackground(background_color));
-
-#if defined(OS_WIN)
-  // Set the background color of native window.
-  HBRUSH brush = CreateSolidBrush(skia::SkColorToCOLORREF(background_color));
-  ULONG_PTR previous_brush =
-      SetClassLongPtr(GetAcceleratedWidget(), GCLP_HBRBACKGROUND,
-                      reinterpret_cast<LONG_PTR>(brush));
-  if (previous_brush)
-    DeleteObject((HBRUSH)previous_brush);
-#endif
-}
-
-void NativeWindowViews::SetHasShadow(bool has_shadow) {
-  wm::SetShadowElevation(GetNativeWindow(),
-                         has_shadow ? wm::kShadowElevationInactiveWindow
-                                    : wm::kShadowElevationNone);
-}
-
-bool NativeWindowViews::HasShadow() {
-  return GetNativeWindow()->GetProperty(wm::kShadowElevationKey) !=
-         wm::kShadowElevationNone;
-}
-
-void NativeWindowViews::SetOpacity(const double opacity) {
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  if (!layered_) {
-    LONG ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
-    ex_style |= WS_EX_LAYERED;
-    ::SetWindowLong(hwnd, GWL_EXSTYLE, ex_style);
-    layered_ = true;
-  }
-  ::SetLayeredWindowAttributes(hwnd, 0, opacity * 255, LWA_ALPHA);
-#endif
-  opacity_ = opacity;
-}
-
-double NativeWindowViews::GetOpacity() {
-  return opacity_;
-}
-
-void NativeWindowViews::SetIgnoreMouseEvents(bool ignore, bool forward) {
-#if defined(OS_WIN)
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (ignore)
-    ex_style |= (WS_EX_TRANSPARENT | WS_EX_LAYERED);
-  else
-    ex_style &= ~(WS_EX_TRANSPARENT | WS_EX_LAYERED);
-  if (layered_)
-    ex_style |= WS_EX_LAYERED;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-
-  // Forwarding is always disabled when not ignoring mouse messages.
-  if (!ignore) {
-    SetForwardMouseMessages(false);
-  } else {
-    SetForwardMouseMessages(forward);
-  }
-#elif defined(USE_X11)
-  if (ignore) {
-    XRectangle r = {0, 0, 1, 1};
-    XShapeCombineRectangles(gfx::GetXDisplay(), GetAcceleratedWidget(),
-                            ShapeInput, 0, 0, &r, 1, ShapeSet, YXBanded);
-  } else {
-    XShapeCombineMask(gfx::GetXDisplay(), GetAcceleratedWidget(), ShapeInput, 0,
-                      0, x11::None, ShapeSet);
-  }
-#endif
-}
-
-void NativeWindowViews::SetContentProtection(bool enable) {
-#if defined(OS_WIN)
-  DWORD affinity = enable ? WDA_MONITOR : WDA_NONE;
-  ::SetWindowDisplayAffinity(GetAcceleratedWidget(), affinity);
-#endif
-}
-
-void NativeWindowViews::SetFocusable(bool focusable) {
-#if defined(OS_WIN)
-  LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
-  if (focusable)
-    ex_style &= ~WS_EX_NOACTIVATE;
-  else
-    ex_style |= WS_EX_NOACTIVATE;
-  ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
-  SetSkipTaskbar(!focusable);
-  Focus(false);
-#endif
-}
-
-void NativeWindowViews::SetMenu(AtomMenuModel* menu_model) {
-#if defined(USE_X11)
-  if (menu_model == nullptr)
-    global_menu_bar_.reset();
-
-  if (!global_menu_bar_ && ShouldUseGlobalMenuBar())
-    global_menu_bar_.reset(new GlobalMenuBarX11(this));
-
-  // Use global application menu bar when possible.
-  if (global_menu_bar_ && global_menu_bar_->IsServerStarted()) {
-    global_menu_bar_->SetMenu(menu_model);
-    return;
-  }
-#endif
-
-  // Should reset content size when setting menu.
-  gfx::Size content_size = GetContentSize();
-  bool should_reset_size = use_content_size_ && has_frame() &&
-                           !IsMenuBarAutoHide() &&
-                           ((!!menu_model) != root_view_->HasMenu());
-
-  root_view_->SetMenu(menu_model);
-
-  if (should_reset_size) {
-    // Enlarge the size constraints for the menu.
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    extensions::SizeConstraints constraints = GetContentSizeConstraints();
-    if (constraints.HasMinimumSize()) {
-      gfx::Size min_size = constraints.GetMinimumSize();
-      min_size.set_height(min_size.height() + menu_bar_height);
-      constraints.set_minimum_size(min_size);
-    }
-    if (constraints.HasMaximumSize()) {
-      gfx::Size max_size = constraints.GetMaximumSize();
-      max_size.set_height(max_size.height() + menu_bar_height);
-      constraints.set_maximum_size(max_size);
-    }
-    SetContentSizeConstraints(constraints);
-
-    // Resize the window to make sure content size is not changed.
-    SetContentSize(content_size);
-  }
-}
-
-void NativeWindowViews::SetBrowserView(NativeBrowserView* view) {
-  if (!content_view())
-    return;
-
-  if (browser_view()) {
-    content_view()->RemoveChildView(
-        browser_view()->GetInspectableWebContentsView()->GetView());
-    set_browser_view(nullptr);
-  }
-
-  if (!view) {
-    return;
-  }
-
-  // Add as child of the main web view to avoid (0, 0) origin from overlapping
-  // with menu bar.
-  set_browser_view(view);
-  content_view()->AddChildView(
-      view->GetInspectableWebContentsView()->GetView());
-}
-
-void NativeWindowViews::SetParentWindow(NativeWindow* parent) {
-  NativeWindow::SetParentWindow(parent);
-
-#if defined(USE_X11)
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  XSetTransientForHint(
-      xdisplay, GetAcceleratedWidget(),
-      parent ? parent->GetAcceleratedWidget() : DefaultRootWindow(xdisplay));
-#elif defined(OS_WIN) && defined(DEBUG)
-  // Should work, but does not, it seems that the views toolkit doesn't support
-  // reparenting on desktop.
-  if (parent) {
-    ::SetParent(GetAcceleratedWidget(), parent->GetAcceleratedWidget());
-    views::Widget::ReparentNativeView(GetNativeWindow(),
-                                      parent->GetNativeWindow());
-    wm::AddTransientChild(parent->GetNativeWindow(), GetNativeWindow());
-  } else {
-    if (!GetNativeWindow()->parent())
-      return;
-    ::SetParent(GetAcceleratedWidget(), NULL);
-    views::Widget::ReparentNativeView(GetNativeWindow(), nullptr);
-    wm::RemoveTransientChild(GetNativeWindow()->parent(), GetNativeWindow());
-  }
-#endif
-}
-
-gfx::NativeView NativeWindowViews::GetNativeView() const {
-  return widget()->GetNativeView();
-}
-
-gfx::NativeWindow NativeWindowViews::GetNativeWindow() const {
-  return widget()->GetNativeWindow();
-}
-
-void NativeWindowViews::SetProgressBar(double progress,
-                                       NativeWindow::ProgressState state) {
-#if defined(OS_WIN)
-  taskbar_host_.SetProgressBar(GetAcceleratedWidget(), progress, state);
-#elif defined(USE_X11)
-  if (unity::IsRunning()) {
-    unity::SetProgressFraction(progress);
-  }
-#endif
-}
-
-void NativeWindowViews::SetOverlayIcon(const gfx::Image& overlay,
-                                       const std::string& description) {
-#if defined(OS_WIN)
-  taskbar_host_.SetOverlayIcon(GetAcceleratedWidget(), overlay, description);
-#endif
-}
-
-void NativeWindowViews::SetAutoHideMenuBar(bool auto_hide) {
-  root_view_->SetAutoHideMenuBar(auto_hide);
-}
-
-bool NativeWindowViews::IsMenuBarAutoHide() {
-  return root_view_->IsMenuBarAutoHide();
-}
-
-void NativeWindowViews::SetMenuBarVisibility(bool visible) {
-  root_view_->SetMenuBarVisibility(visible);
-}
-
-bool NativeWindowViews::IsMenuBarVisible() {
-  return root_view_->IsMenuBarVisible();
-}
-
-void NativeWindowViews::SetVisibleOnAllWorkspaces(bool visible) {
-  widget()->SetVisibleOnAllWorkspaces(visible);
-}
-
-bool NativeWindowViews::IsVisibleOnAllWorkspaces() {
-#if defined(USE_X11)
-  // Use the presence/absence of _NET_WM_STATE_STICKY in _NET_WM_STATE to
-  // determine whether the current window is visible on all workspaces.
-  XAtom sticky_atom = GetAtom("_NET_WM_STATE_STICKY");
-  std::vector<XAtom> wm_states;
-  ui::GetAtomArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", &wm_states);
-  return std::find(wm_states.begin(), wm_states.end(), sticky_atom) !=
-         wm_states.end();
-#endif
-  return false;
-}
-
-gfx::AcceleratedWidget NativeWindowViews::GetAcceleratedWidget() const {
-  return GetNativeWindow()->GetHost()->GetAcceleratedWidget();
-}
-
-gfx::Rect NativeWindowViews::ContentBoundsToWindowBounds(
-    const gfx::Rect& bounds) const {
-  if (!has_frame())
-    return bounds;
-
-  gfx::Rect window_bounds(bounds);
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  gfx::Rect dpi_bounds = display::win::ScreenWin::DIPToScreenRect(hwnd, bounds);
-  window_bounds = display::win::ScreenWin::ScreenToDIPRect(
-      hwnd,
-      widget()->non_client_view()->GetWindowBoundsForClientBounds(dpi_bounds));
-#endif
-
-  if (root_view_->HasMenu() && root_view_->IsMenuBarVisible()) {
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    window_bounds.set_y(window_bounds.y() - menu_bar_height);
-    window_bounds.set_height(window_bounds.height() + menu_bar_height);
-  }
-  return window_bounds;
-}
-
-gfx::Rect NativeWindowViews::WindowBoundsToContentBounds(
-    const gfx::Rect& bounds) const {
-  if (!has_frame())
-    return bounds;
-
-  gfx::Rect content_bounds(bounds);
-#if defined(OS_WIN)
-  HWND hwnd = GetAcceleratedWidget();
-  content_bounds.set_size(
-      display::win::ScreenWin::DIPToScreenSize(hwnd, content_bounds.size()));
-  RECT rect;
-  SetRectEmpty(&rect);
-  DWORD style = ::GetWindowLong(hwnd, GWL_STYLE);
-  DWORD ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
-  AdjustWindowRectEx(&rect, style, FALSE, ex_style);
-  content_bounds.set_width(content_bounds.width() - (rect.right - rect.left));
-  content_bounds.set_height(content_bounds.height() - (rect.bottom - rect.top));
-  content_bounds.set_size(
-      display::win::ScreenWin::ScreenToDIPSize(hwnd, content_bounds.size()));
-#endif
-
-  if (root_view_->HasMenu() && root_view_->IsMenuBarVisible()) {
-    int menu_bar_height = root_view_->GetMenuBarHeight();
-    content_bounds.set_y(content_bounds.y() + menu_bar_height);
-    content_bounds.set_height(content_bounds.height() - menu_bar_height);
-  }
-  return content_bounds;
-}
-
-void NativeWindowViews::UpdateDraggableRegions(
-    std::unique_ptr<SkRegion> region) {
-  draggable_region_ = std::move(region);
-}
-
-#if defined(OS_WIN)
-void NativeWindowViews::SetIcon(HICON window_icon, HICON app_icon) {
-  // We are responsible for storing the images.
-  window_icon_ = base::win::ScopedHICON(CopyIcon(window_icon));
-  app_icon_ = base::win::ScopedHICON(CopyIcon(app_icon));
-
-  HWND hwnd = GetAcceleratedWidget();
-  SendMessage(hwnd, WM_SETICON, ICON_SMALL,
-              reinterpret_cast<LPARAM>(window_icon_.get()));
-  SendMessage(hwnd, WM_SETICON, ICON_BIG,
-              reinterpret_cast<LPARAM>(app_icon_.get()));
-}
-#elif defined(USE_X11)
-void NativeWindowViews::SetIcon(const gfx::ImageSkia& icon) {
-  auto* tree_host = static_cast<views::DesktopWindowTreeHost*>(
-      views::DesktopWindowTreeHostX11::GetHostForXID(GetAcceleratedWidget()));
-  tree_host->SetWindowIcons(icon, icon);
-}
-#endif
-
-void NativeWindowViews::OnWidgetActivationChanged(views::Widget* changed_widget,
-                                                  bool active) {
-  if (changed_widget != widget())
-    return;
-
-  // Post the notification to next tick.
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI, FROM_HERE,
-      base::Bind(active ? &NativeWindow::NotifyWindowFocus
-                        : &NativeWindow::NotifyWindowBlur,
-                 GetWeakPtr()));
-
-  // Hide menu bar when window is blured.
-  if (!active && IsMenuBarAutoHide() && IsMenuBarVisible())
-    SetMenuBarVisibility(false);
-
-  root_view_->ResetAltState();
-}
-
-void NativeWindowViews::OnWidgetBoundsChanged(views::Widget* changed_widget,
-                                              const gfx::Rect& bounds) {
-  if (changed_widget != widget())
-    return;
-
-  // Note: We intentionally use `GetBounds()` instead of `bounds` to properly
-  // handle minimized windows on Windows.
-  const auto new_bounds = GetBounds();
-  if (widget_size_ != new_bounds.size()) {
-    if (browser_view()) {
-      const auto flags = static_cast<NativeBrowserViewViews*>(browser_view())
-                             ->GetAutoResizeFlags();
-      int width_delta = 0;
-      int height_delta = 0;
-      if (flags & kAutoResizeWidth) {
-        width_delta = new_bounds.width() - widget_size_.width();
-      }
-      if (flags & kAutoResizeHeight) {
-        height_delta = new_bounds.height() - widget_size_.height();
-      }
-
-      auto* view = browser_view()->GetInspectableWebContentsView()->GetView();
-      auto new_view_size = view->size();
-      new_view_size.set_width(new_view_size.width() + width_delta);
-      new_view_size.set_height(new_view_size.height() + height_delta);
-      view->SetSize(new_view_size);
-    }
-
-    NotifyWindowResize();
-    widget_size_ = new_bounds.size();
-  }
-}
-
-void NativeWindowViews::DeleteDelegate() {
-  if (is_modal() && NativeWindow::parent()) {
-    auto* parent = NativeWindow::parent();
-    // Enable parent window after current window gets closed.
-    parent->SetEnabled(true);
-    // Focus on parent window.
-    parent->Focus(true);
-  }
-
-  NotifyWindowClosed();
-}
-
-views::View* NativeWindowViews::GetInitiallyFocusedView() {
-  return focused_view_;
-}
-
-bool NativeWindowViews::CanResize() const {
-  return resizable_;
-}
-
-bool NativeWindowViews::CanMaximize() const {
-  return resizable_ && maximizable_;
-}
-
-bool NativeWindowViews::CanMinimize() const {
-#if defined(OS_WIN)
-  return minimizable_;
-#elif defined(USE_X11)
-  return true;
-#endif
-}
-
-base::string16 NativeWindowViews::GetWindowTitle() const {
-  return base::UTF8ToUTF16(title_);
-}
-
-views::View* NativeWindowViews::GetContentsView() {
-  return root_view_.get();
-}
-
-bool NativeWindowViews::ShouldDescendIntoChildForEventHandling(
-    gfx::NativeView child,
-    const gfx::Point& location) {
-  // App window should claim mouse events that fall within the draggable region.
-  if (draggable_region() &&
-      draggable_region()->contains(location.x(), location.y()))
-    return false;
-
-  // And the events on border for dragging resizable frameless window.
-  if (!has_frame() && CanResize()) {
-    FramelessView* frame =
-        static_cast<FramelessView*>(widget()->non_client_view()->frame_view());
-    return frame->ResizingBorderHitTest(location) == HTNOWHERE;
-  }
-
-  return true;
-}
-
-views::ClientView* NativeWindowViews::CreateClientView(views::Widget* widget) {
-  return new NativeWindowClientView(widget, root_view_.get(), this);
-}
-
-views::NonClientFrameView* NativeWindowViews::CreateNonClientFrameView(
-    views::Widget* widget) {
-#if defined(OS_WIN)
-  WinFrameView* frame_view = new WinFrameView;
-  frame_view->Init(this, widget);
-  return frame_view;
-#else
-  if (has_frame()) {
-    return new NativeFrameView(this, widget);
-  } else {
-    FramelessView* frame_view = new FramelessView;
-    frame_view->Init(this, widget);
-    return frame_view;
-  }
-#endif
-}
-
-void NativeWindowViews::OnWidgetMove() {
-  NotifyWindowMove();
-}
-
-void NativeWindowViews::HandleKeyboardEvent(
-    content::WebContents*,
-    const content::NativeWebKeyboardEvent& event) {
-  keyboard_event_handler_->HandleKeyboardEvent(event,
-                                               root_view_->GetFocusManager());
-  root_view_->HandleKeyEvent(event);
-}
-
-ui::WindowShowState NativeWindowViews::GetRestoredState() {
-  if (IsMaximized())
-    return ui::SHOW_STATE_MAXIMIZED;
-  if (IsFullscreen())
-    return ui::SHOW_STATE_FULLSCREEN;
-
-  return ui::SHOW_STATE_NORMAL;
-}
-
-// static
-NativeWindow* NativeWindow::Create(const mate::Dictionary& options,
-                                   NativeWindow* parent) {
-  return new NativeWindowViews(options, parent);
-}
-
-}  // namespace atom
removed in remote
  base   100644 862cd5458bb67bd8089dcf48e590691fb3e1e9e6 atom/browser/native_window_views.h
  our    100644 ef1e4413ca879980e46f301bccd6c8fe2b1a4611 atom/browser/native_window_views.h
@@ -1,289 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
-#define ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
-
-#include "atom/browser/native_window.h"
-
-#include <set>
-#include <string>
-
-#include "ui/views/widget/widget_observer.h"
-
-#if defined(OS_WIN)
-#include "atom/browser/ui/win/message_handler_delegate.h"
-#include "atom/browser/ui/win/taskbar_host.h"
-#include "base/win/scoped_gdi_object.h"
-#endif
-
-namespace views {
-class UnhandledKeyboardEventHandler;
-}
-
-namespace atom {
-
-class GlobalMenuBarX11;
-class RootView;
-class WindowStateWatcher;
-
-#if defined(OS_WIN)
-class AtomDesktopWindowTreeHostWin;
-#elif defined(USE_X11)
-class EventDisabler;
-#endif
-
-class NativeWindowViews : public NativeWindow,
-#if defined(OS_WIN)
-                          public MessageHandlerDelegate,
-#endif
-                          public views::WidgetObserver {
- public:
-  NativeWindowViews(const mate::Dictionary& options, NativeWindow* parent);
-  ~NativeWindowViews() override;
-
-  // NativeWindow:
-  void SetContentView(views::View* view) override;
-  void Close() override;
-  void CloseImmediately() override;
-  void Focus(bool focus) override;
-  bool IsFocused() override;
-  void Show() override;
-  void ShowInactive() override;
-  void Hide() override;
-  bool IsVisible() override;
-  bool IsEnabled() override;
-  void SetEnabled(bool enable) override;
-  void Maximize() override;
-  void Unmaximize() override;
-  bool IsMaximized() override;
-  void Minimize() override;
-  void Restore() override;
-  bool IsMinimized() override;
-  void SetFullScreen(bool fullscreen) override;
-  bool IsFullscreen() const override;
-  void SetBounds(const gfx::Rect& bounds, bool animate) override;
-  gfx::Rect GetBounds() override;
-  gfx::Rect GetContentBounds() override;
-  gfx::Size GetContentSize() override;
-  void SetContentSizeConstraints(
-      const extensions::SizeConstraints& size_constraints) override;
-  void SetResizable(bool resizable) override;
-#if defined(OS_WIN)
-  void MoveTop() override;
-#endif
-  bool IsResizable() override;
-  void SetMovable(bool movable) override;
-  bool IsMovable() override;
-  void SetMinimizable(bool minimizable) override;
-  bool IsMinimizable() override;
-  void SetMaximizable(bool maximizable) override;
-  bool IsMaximizable() override;
-  void SetFullScreenable(bool fullscreenable) override;
-  bool IsFullScreenable() override;
-  void SetClosable(bool closable) override;
-  bool IsClosable() override;
-  void SetAlwaysOnTop(bool top,
-                      const std::string& level,
-                      int relativeLevel,
-                      std::string* error) override;
-  bool IsAlwaysOnTop() override;
-  void Center() override;
-  void Invalidate() override;
-  void SetTitle(const std::string& title) override;
-  std::string GetTitle() override;
-  void FlashFrame(bool flash) override;
-  void SetSkipTaskbar(bool skip) override;
-  void SetSimpleFullScreen(bool simple_fullscreen) override;
-  bool IsSimpleFullScreen() override;
-  void SetKiosk(bool kiosk) override;
-  bool IsKiosk() override;
-  void SetBackgroundColor(SkColor color) override;
-  void SetHasShadow(bool has_shadow) override;
-  bool HasShadow() override;
-  void SetOpacity(const double opacity) override;
-  double GetOpacity() override;
-  void SetIgnoreMouseEvents(bool ignore, bool forward) override;
-  void SetContentProtection(bool enable) override;
-  void SetFocusable(bool focusable) override;
-  void SetMenu(AtomMenuModel* menu_model) override;
-  void SetBrowserView(NativeBrowserView* browser_view) override;
-  void SetParentWindow(NativeWindow* parent) override;
-  gfx::NativeView GetNativeView() const override;
-  gfx::NativeWindow GetNativeWindow() const override;
-  void SetOverlayIcon(const gfx::Image& overlay,
-                      const std::string& description) override;
-  void SetProgressBar(double progress, const ProgressState state) override;
-  void SetAutoHideMenuBar(bool auto_hide) override;
-  bool IsMenuBarAutoHide() override;
-  void SetMenuBarVisibility(bool visible) override;
-  bool IsMenuBarVisible() override;
-  void SetVisibleOnAllWorkspaces(bool visible) override;
-  bool IsVisibleOnAllWorkspaces() override;
-
-  gfx::AcceleratedWidget GetAcceleratedWidget() const override;
-
-  gfx::Rect ContentBoundsToWindowBounds(const gfx::Rect& bounds) const override;
-  gfx::Rect WindowBoundsToContentBounds(const gfx::Rect& bounds) const override;
-
-  void UpdateDraggableRegions(std::unique_ptr<SkRegion> region);
-
-#if defined(OS_WIN)
-  void SetIcon(HICON small_icon, HICON app_icon);
-#elif defined(USE_X11)
-  void SetIcon(const gfx::ImageSkia& icon);
-#endif
-
-  SkRegion* draggable_region() const { return draggable_region_.get(); }
-
-#if defined(OS_WIN)
-  TaskbarHost& taskbar_host() { return taskbar_host_; }
-#endif
-
- private:
-  // views::WidgetObserver:
-  void OnWidgetActivationChanged(views::Widget* widget, bool active) override;
-  void OnWidgetBoundsChanged(views::Widget* widget,
-                             const gfx::Rect& bounds) override;
-
-  // views::WidgetDelegate:
-  void DeleteDelegate() override;
-  views::View* GetInitiallyFocusedView() override;
-  bool CanResize() const override;
-  bool CanMaximize() const override;
-  bool CanMinimize() const override;
-  base::string16 GetWindowTitle() const override;
-  views::View* GetContentsView() override;
-  bool ShouldDescendIntoChildForEventHandling(
-      gfx::NativeView child,
-      const gfx::Point& location) override;
-  views::ClientView* CreateClientView(views::Widget* widget) override;
-  views::NonClientFrameView* CreateNonClientFrameView(
-      views::Widget* widget) override;
-  void OnWidgetMove() override;
-#if defined(OS_WIN)
-  bool ExecuteWindowsCommand(int command_id) override;
-#endif
-
-#if defined(OS_WIN)
-  // MessageHandlerDelegate:
-  bool PreHandleMSG(UINT message,
-                    WPARAM w_param,
-                    LPARAM l_param,
-                    LRESULT* result) override;
-  void HandleSizeEvent(WPARAM w_param, LPARAM l_param);
-  void SetForwardMouseMessages(bool forward);
-  static LRESULT CALLBACK SubclassProc(HWND hwnd,
-                                       UINT msg,
-                                       WPARAM w_param,
-                                       LPARAM l_param,
-                                       UINT_PTR subclass_id,
-                                       DWORD_PTR ref_data);
-  static LRESULT CALLBACK MouseHookProc(int n_code,
-                                        WPARAM w_param,
-                                        LPARAM l_param);
-#endif
-
-  // NativeWindow:
-  void HandleKeyboardEvent(
-      content::WebContents*,
-      const content::NativeWebKeyboardEvent& event) override;
-
-  // Returns the restore state for the window.
-  ui::WindowShowState GetRestoredState();
-
-  std::unique_ptr<RootView> root_view_;
-
-  // The view should be focused by default.
-  views::View* focused_view_ = nullptr;
-
-  // The "resizable" flag on Linux is implemented by setting size constraints,
-  // we need to make sure size constraints are restored when window becomes
-  // resizable again. This is also used on Windows, to keep taskbar resize
-  // events from resizing the window.
-  extensions::SizeConstraints old_size_constraints_;
-
-#if defined(USE_X11)
-  std::unique_ptr<GlobalMenuBarX11> global_menu_bar_;
-
-  // Handles window state events.
-  std::unique_ptr<WindowStateWatcher> window_state_watcher_;
-
-  // To disable the mouse events.
-  std::unique_ptr<EventDisabler> event_disabler_;
-#endif
-
-#if defined(OS_WIN)
-  // Weak ref.
-  AtomDesktopWindowTreeHostWin* atom_desktop_window_tree_host_win_;
-
-  ui::WindowShowState last_window_state_;
-
-  // There's an issue with restore on Windows, that sometimes causes the Window
-  // to receive the wrong size (#2498). To circumvent that, we keep tabs on the
-  // size of the window while in the normal state (not maximized, minimized or
-  // fullscreen), so we restore it correctly.
-  gfx::Rect last_normal_bounds_;
-  gfx::Rect last_normal_bounds_before_move_;
-
-  // last_normal_bounds_ may or may not require update on WM_MOVE. When a
-  // window is maximized, it is moved (WM_MOVE) to maximum size first and then
-  // sized (WM_SIZE). In this case, last_normal_bounds_ should not update. We
-  // keep last_normal_bounds_candidate_ as a candidate which will become valid
-  // last_normal_bounds_ if the moves are consecutive with no WM_SIZE event in
-  // between.
-  gfx::Rect last_normal_bounds_candidate_;
-
-  bool consecutive_moves_;
-
-  // In charge of running taskbar related APIs.
-  TaskbarHost taskbar_host_;
-
-  // Memoized version of a11y check
-  bool checked_for_a11y_support_ = false;
-
-  // Whether to show the WS_THICKFRAME style.
-  bool thick_frame_ = true;
-
-  // The bounds of window before maximize/fullscreen.
-  gfx::Rect restore_bounds_;
-
-  // The icons of window and taskbar.
-  base::win::ScopedHICON window_icon_;
-  base::win::ScopedHICON app_icon_;
-
-  // The set of windows currently forwarding mouse messages.
-  static std::set<NativeWindowViews*> forwarding_windows_;
-  static HHOOK mouse_hook_;
-  bool forwarding_mouse_messages_ = false;
-  HWND legacy_window_ = NULL;
-  bool layered_ = false;
-#endif
-
-  // Handles unhandled keyboard messages coming back from the renderer process.
-  std::unique_ptr<views::UnhandledKeyboardEventHandler> keyboard_event_handler_;
-
-  // For custom drag, the whole window is non-draggable and the draggable region
-  // has to been explicitly provided.
-  std::unique_ptr<SkRegion> draggable_region_;  // used in custom drag.
-
-  // How many times the Disable has been called.
-  int disable_count_ = 0;
-
-  bool use_content_size_ = false;
-  bool movable_ = true;
-  bool resizable_ = true;
-  bool maximizable_ = true;
-  bool minimizable_ = true;
-  bool fullscreenable_ = true;
-  std::string title_;
-  gfx::Size widget_size_;
-  double opacity_ = 1.0;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeWindowViews);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NATIVE_WINDOW_VIEWS_H_
removed in remote
  base   100644 e5ed1975f80f918eb37257f8b244f4cdf3eafc88 atom/browser/native_window_views_win.cc
  our    100644 0e61d18b915924eb3d3d14e40d1cbbd199631bed atom/browser/native_window_views_win.cc
@@ -1,386 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_views.h"
-#include "content/public/browser/browser_accessibility_state.h"
-#include "ui/base/win/accessibility_misc_utils.h"
-
-// Must be included after other Windows headers.
-#include <UIAutomationCoreApi.h>
-
-namespace atom {
-
-namespace {
-
-// Convert Win32 WM_APPCOMMANDS to strings.
-const char* AppCommandToString(int command_id) {
-  switch (command_id) {
-    case APPCOMMAND_BROWSER_BACKWARD:
-      return "browser-backward";
-    case APPCOMMAND_BROWSER_FORWARD:
-      return "browser-forward";
-    case APPCOMMAND_BROWSER_REFRESH:
-      return "browser-refresh";
-    case APPCOMMAND_BROWSER_STOP:
-      return "browser-stop";
-    case APPCOMMAND_BROWSER_SEARCH:
-      return "browser-search";
-    case APPCOMMAND_BROWSER_FAVORITES:
-      return "browser-favorites";
-    case APPCOMMAND_BROWSER_HOME:
-      return "browser-home";
-    case APPCOMMAND_VOLUME_MUTE:
-      return "volume-mute";
-    case APPCOMMAND_VOLUME_DOWN:
-      return "volume-down";
-    case APPCOMMAND_VOLUME_UP:
-      return "volume-up";
-    case APPCOMMAND_MEDIA_NEXTTRACK:
-      return "media-nexttrack";
-    case APPCOMMAND_MEDIA_PREVIOUSTRACK:
-      return "media-previoustrack";
-    case APPCOMMAND_MEDIA_STOP:
-      return "media-stop";
-    case APPCOMMAND_MEDIA_PLAY_PAUSE:
-      return "media-play-pause";
-    case APPCOMMAND_LAUNCH_MAIL:
-      return "launch-mail";
-    case APPCOMMAND_LAUNCH_MEDIA_SELECT:
-      return "launch-media-select";
-    case APPCOMMAND_LAUNCH_APP1:
-      return "launch-app1";
-    case APPCOMMAND_LAUNCH_APP2:
-      return "launch-app2";
-    case APPCOMMAND_BASS_DOWN:
-      return "bass-down";
-    case APPCOMMAND_BASS_BOOST:
-      return "bass-boost";
-    case APPCOMMAND_BASS_UP:
-      return "bass-up";
-    case APPCOMMAND_TREBLE_DOWN:
-      return "treble-down";
-    case APPCOMMAND_TREBLE_UP:
-      return "treble-up";
-    case APPCOMMAND_MICROPHONE_VOLUME_MUTE:
-      return "microphone-volume-mute";
-    case APPCOMMAND_MICROPHONE_VOLUME_DOWN:
-      return "microphone-volume-down";
-    case APPCOMMAND_MICROPHONE_VOLUME_UP:
-      return "microphone-volume-up";
-    case APPCOMMAND_HELP:
-      return "help";
-    case APPCOMMAND_FIND:
-      return "find";
-    case APPCOMMAND_NEW:
-      return "new";
-    case APPCOMMAND_OPEN:
-      return "open";
-    case APPCOMMAND_CLOSE:
-      return "close";
-    case APPCOMMAND_SAVE:
-      return "save";
-    case APPCOMMAND_PRINT:
-      return "print";
-    case APPCOMMAND_UNDO:
-      return "undo";
-    case APPCOMMAND_REDO:
-      return "redo";
-    case APPCOMMAND_COPY:
-      return "copy";
-    case APPCOMMAND_CUT:
-      return "cut";
-    case APPCOMMAND_PASTE:
-      return "paste";
-    case APPCOMMAND_REPLY_TO_MAIL:
-      return "reply-to-mail";
-    case APPCOMMAND_FORWARD_MAIL:
-      return "forward-mail";
-    case APPCOMMAND_SEND_MAIL:
-      return "send-mail";
-    case APPCOMMAND_SPELL_CHECK:
-      return "spell-check";
-    case APPCOMMAND_MIC_ON_OFF_TOGGLE:
-      return "mic-on-off-toggle";
-    case APPCOMMAND_CORRECTION_LIST:
-      return "correction-list";
-    case APPCOMMAND_MEDIA_PLAY:
-      return "media-play";
-    case APPCOMMAND_MEDIA_PAUSE:
-      return "media-pause";
-    case APPCOMMAND_MEDIA_RECORD:
-      return "media-record";
-    case APPCOMMAND_MEDIA_FAST_FORWARD:
-      return "media-fast-forward";
-    case APPCOMMAND_MEDIA_REWIND:
-      return "media-rewind";
-    case APPCOMMAND_MEDIA_CHANNEL_UP:
-      return "media-channel-up";
-    case APPCOMMAND_MEDIA_CHANNEL_DOWN:
-      return "media-channel-down";
-    case APPCOMMAND_DELETE:
-      return "delete";
-    case APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE:
-      return "dictate-or-command-control-toggle";
-    default:
-      return "unknown";
-  }
-}
-
-bool IsScreenReaderActive() {
-  UINT screenReader = 0;
-  SystemParametersInfo(SPI_GETSCREENREADER, 0, &screenReader, 0);
-  return screenReader && UiaClientsAreListening();
-}
-
-}  // namespace
-
-std::set<NativeWindowViews*> NativeWindowViews::forwarding_windows_;
-HHOOK NativeWindowViews::mouse_hook_ = NULL;
-
-bool NativeWindowViews::ExecuteWindowsCommand(int command_id) {
-  std::string command = AppCommandToString(command_id);
-  NotifyWindowExecuteWindowsCommand(command);
-
-  return false;
-}
-
-bool NativeWindowViews::PreHandleMSG(UINT message,
-                                     WPARAM w_param,
-                                     LPARAM l_param,
-                                     LRESULT* result) {
-  NotifyWindowMessage(message, w_param, l_param);
-
-  switch (message) {
-    // Screen readers send WM_GETOBJECT in order to get the accessibility
-    // object, so take this opportunity to push Chromium into accessible
-    // mode if it isn't already, always say we didn't handle the message
-    // because we still want Chromium to handle returning the actual
-    // accessibility object.
-    case WM_GETOBJECT: {
-      if (checked_for_a11y_support_)
-        return false;
-
-      const DWORD obj_id = static_cast<DWORD>(l_param);
-
-      if (obj_id != static_cast<DWORD>(OBJID_CLIENT)) {
-        return false;
-      }
-
-      if (!IsScreenReaderActive()) {
-        return false;
-      }
-
-      checked_for_a11y_support_ = true;
-
-      auto* const axState = content::BrowserAccessibilityState::GetInstance();
-      if (axState && !axState->IsAccessibleBrowser()) {
-        axState->OnScreenReaderDetected();
-        Browser::Get()->OnAccessibilitySupportChanged();
-      }
-
-      return false;
-    }
-    case WM_COMMAND:
-      // Handle thumbar button click message.
-      if (HIWORD(w_param) == THBN_CLICKED)
-        return taskbar_host_.HandleThumbarButtonEvent(LOWORD(w_param));
-      return false;
-    case WM_SIZING: {
-      bool prevent_default = false;
-      NotifyWindowWillResize(gfx::Rect(*reinterpret_cast<RECT*>(l_param)),
-                             &prevent_default);
-      if (prevent_default) {
-        ::GetWindowRect(GetAcceleratedWidget(),
-                        reinterpret_cast<RECT*>(l_param));
-      }
-      return false;
-    }
-    case WM_SIZE: {
-      // Handle window state change.
-      HandleSizeEvent(w_param, l_param);
-
-      consecutive_moves_ = false;
-      last_normal_bounds_before_move_ = last_normal_bounds_;
-
-      return false;
-    }
-    case WM_MOVING: {
-      if (!movable_)
-        ::GetWindowRect(GetAcceleratedWidget(),
-                        reinterpret_cast<RECT*>(l_param));
-      return false;
-    }
-    case WM_MOVE: {
-      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
-        if (consecutive_moves_)
-          last_normal_bounds_ = last_normal_bounds_candidate_;
-        last_normal_bounds_candidate_ = GetBounds();
-        consecutive_moves_ = true;
-      }
-      return false;
-    }
-    case WM_ENDSESSION: {
-      if (w_param) {
-        NotifyWindowEndSession();
-      }
-      return false;
-    }
-    case WM_PARENTNOTIFY: {
-      if (LOWORD(w_param) == WM_CREATE) {
-        // Because of reasons regarding legacy drivers and stuff, a window that
-        // matches the client area is created and used internally by Chromium.
-        // This is used when forwarding mouse messages. We only cache the first
-        // occurrence (the webview window) because dev tools also cause this
-        // message to be sent.
-        if (!legacy_window_) {
-          legacy_window_ = reinterpret_cast<HWND>(l_param);
-        }
-      }
-      return false;
-    }
-    default:
-      return false;
-  }
-}
-
-void NativeWindowViews::HandleSizeEvent(WPARAM w_param, LPARAM l_param) {
-  // Here we handle the WM_SIZE event in order to figure out what is the current
-  // window state and notify the user accordingly.
-  switch (w_param) {
-    case SIZE_MAXIMIZED:
-      last_window_state_ = ui::SHOW_STATE_MAXIMIZED;
-      if (consecutive_moves_) {
-        last_normal_bounds_ = last_normal_bounds_before_move_;
-      }
-      NotifyWindowMaximize();
-      break;
-    case SIZE_MINIMIZED:
-      last_window_state_ = ui::SHOW_STATE_MINIMIZED;
-      NotifyWindowMinimize();
-      break;
-    case SIZE_RESTORED:
-      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
-        // Window was resized so we save it's new size.
-        last_normal_bounds_ = GetBounds();
-        last_normal_bounds_before_move_ = last_normal_bounds_;
-      } else {
-        switch (last_window_state_) {
-          case ui::SHOW_STATE_MAXIMIZED:
-            last_window_state_ = ui::SHOW_STATE_NORMAL;
-
-            // Don't force out last known bounds onto the window as Windows
-            // actually gets these correct
-
-            NotifyWindowUnmaximize();
-            break;
-          case ui::SHOW_STATE_MINIMIZED:
-            if (IsFullscreen()) {
-              last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
-              NotifyWindowEnterFullScreen();
-            } else {
-              last_window_state_ = ui::SHOW_STATE_NORMAL;
-
-              // When the window is restored we resize it to the previous known
-              // normal size.
-              SetBounds(last_normal_bounds_, false);
-
-              NotifyWindowRestore();
-            }
-            break;
-          default:
-            break;
-        }
-      }
-      break;
-  }
-}
-
-void NativeWindowViews::SetForwardMouseMessages(bool forward) {
-  if (forward && !forwarding_mouse_messages_) {
-    forwarding_mouse_messages_ = true;
-    forwarding_windows_.insert(this);
-
-    // Subclassing is used to fix some issues when forwarding mouse messages;
-    // see comments in |SubclassProc|.
-    SetWindowSubclass(legacy_window_, SubclassProc, 1,
-                      reinterpret_cast<DWORD_PTR>(this));
-
-    if (!mouse_hook_) {
-      mouse_hook_ = SetWindowsHookEx(WH_MOUSE_LL, MouseHookProc, NULL, 0);
-    }
-  } else if (!forward && forwarding_mouse_messages_) {
-    forwarding_mouse_messages_ = false;
-    forwarding_windows_.erase(this);
-
-    RemoveWindowSubclass(legacy_window_, SubclassProc, 1);
-
-    if (forwarding_windows_.size() == 0) {
-      UnhookWindowsHookEx(mouse_hook_);
-      mouse_hook_ = NULL;
-    }
-  }
-}
-
-LRESULT CALLBACK NativeWindowViews::SubclassProc(HWND hwnd,
-                                                 UINT msg,
-                                                 WPARAM w_param,
-                                                 LPARAM l_param,
-                                                 UINT_PTR subclass_id,
-                                                 DWORD_PTR ref_data) {
-  NativeWindowViews* window = reinterpret_cast<NativeWindowViews*>(ref_data);
-  switch (msg) {
-    case WM_MOUSELEAVE: {
-      // When input is forwarded to underlying windows, this message is posted.
-      // If not handled, it interferes with Chromium logic, causing for example
-      // mouseleave events to fire. If those events are used to exit forward
-      // mode, excessive flickering on for example hover items in underlying
-      // windows can occur due to rapidly entering and leaving forwarding mode.
-      // By consuming and ignoring the message, we're essentially telling
-      // Chromium that we have not left the window despite somebody else getting
-      // the messages. As to why this is catched for the legacy window and not
-      // the actual browser window is simply that the legacy window somehow
-      // makes use of these events; posting to the main window didn't work.
-      if (window->forwarding_mouse_messages_) {
-        return 0;
-      }
-      break;
-    }
-  }
-
-  return DefSubclassProc(hwnd, msg, w_param, l_param);
-}
-
-LRESULT CALLBACK NativeWindowViews::MouseHookProc(int n_code,
-                                                  WPARAM w_param,
-                                                  LPARAM l_param) {
-  if (n_code < 0) {
-    return CallNextHookEx(NULL, n_code, w_param, l_param);
-  }
-
-  // Post a WM_MOUSEMOVE message for those windows whose client area contains
-  // the cursor since they are in a state where they would otherwise ignore all
-  // mouse input.
-  if (w_param == WM_MOUSEMOVE) {
-    for (auto* window : forwarding_windows_) {
-      // At first I considered enumerating windows to check whether the cursor
-      // was directly above the window, but since nothing bad seems to happen
-      // if we post the message even if some other window occludes it I have
-      // just left it as is.
-      RECT client_rect;
-      GetClientRect(window->legacy_window_, &client_rect);
-      POINT p = reinterpret_cast<MSLLHOOKSTRUCT*>(l_param)->pt;
-      ScreenToClient(window->legacy_window_, &p);
-      if (PtInRect(&client_rect, p)) {
-        WPARAM w = 0;  // No virtual keys pressed for our purposes
-        LPARAM l = MAKELPARAM(p.x, p.y);
-        PostMessage(window->legacy_window_, WM_MOUSEMOVE, w, l);
-      }
-    }
-  }
-
-  return CallNextHookEx(NULL, n_code, w_param, l_param);
-}
-
-}  // namespace atom
removed in remote
  base   100644 324f8339c8c9d8431480e185e1b24f468f1c7421 atom/browser/net/asar/asar_protocol_handler.cc
  our    100644 c2f53fa9d10881b0c5d68eff2b9ce628603bd8e1 atom/browser/net/asar/asar_protocol_handler.cc
@@ -1,33 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/asar/asar_protocol_handler.h"
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-#include "net/base/filename_util.h"
-#include "net/base/net_errors.h"
-
-namespace asar {
-
-AsarProtocolHandler::AsarProtocolHandler(
-    const scoped_refptr<base::TaskRunner>& file_task_runner)
-    : file_task_runner_(file_task_runner) {}
-
-AsarProtocolHandler::~AsarProtocolHandler() {}
-
-net::URLRequestJob* AsarProtocolHandler::MaybeCreateJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  base::FilePath full_path;
-  net::FileURLToFilePath(request->url(), &full_path);
-  auto* job = new URLRequestAsarJob(request, network_delegate);
-  job->Initialize(file_task_runner_, full_path);
-  return job;
-}
-
-bool AsarProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
-  return false;
-}
-
-}  // namespace asar
removed in remote
  base   100644 e0cb74d5d1bf46ace38e6c0e5e62e90f5b6d4ba0 atom/browser/net/asar/asar_protocol_handler.h
  our    100644 f431b55b71709c2f2932375fc992bf526a2d44d2 atom/browser/net/asar/asar_protocol_handler.h
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
-#define ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
-
-#include "base/memory/ref_counted.h"
-#include "net/url_request/url_request_job_factory.h"
-
-namespace base {
-class TaskRunner;
-}
-
-namespace asar {
-
-class AsarProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
- public:
-  explicit AsarProtocolHandler(
-      const scoped_refptr<base::TaskRunner>& file_task_runner);
-  ~AsarProtocolHandler() override;
-
-  // net::URLRequestJobFactory::ProtocolHandler:
-  net::URLRequestJob* MaybeCreateJob(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  bool IsSafeRedirectTarget(const GURL& location) const override;
-
- private:
-  const scoped_refptr<base::TaskRunner> file_task_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(AsarProtocolHandler);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
removed in remote
  base   100644 39e55a35cbcec0504510f0b34153382677d33e7f atom/browser/net/asar/url_request_asar_job.cc
  our    100644 85eb2e1dd142b6d64aafb5350ae47603db989e8f atom/browser/net/asar/url_request_asar_job.cc
@@ -1,334 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/archive.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/atom_constants.h"
-#include "base/bind.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_util.h"
-#include "base/synchronization/lock.h"
-#include "base/task_runner.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "net/base/file_stream.h"
-#include "net/base/filename_util.h"
-#include "net/base/io_buffer.h"
-#include "net/base/load_flags.h"
-#include "net/base/mime_util.h"
-#include "net/base/net_errors.h"
-#include "net/filter/gzip_source_stream.h"
-#include "net/http/http_util.h"
-#include "net/url_request/url_request_status.h"
-
-#if defined(OS_WIN)
-#include "base/win/shortcut.h"
-#endif
-
-namespace asar {
-
-URLRequestAsarJob::FileMetaInfo::FileMetaInfo() = default;
-
-URLRequestAsarJob::URLRequestAsarJob(net::URLRequest* request,
-                                     net::NetworkDelegate* network_delegate)
-    : net::URLRequestJob(request, network_delegate), weak_ptr_factory_(this) {}
-
-URLRequestAsarJob::~URLRequestAsarJob() {}
-
-void URLRequestAsarJob::Initialize(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    const base::FilePath& file_path) {
-  // Determine whether it is an asar file.
-  base::FilePath asar_path, relative_path;
-  if (!GetAsarArchivePath(file_path, &asar_path, &relative_path)) {
-    InitializeFileJob(file_task_runner, file_path);
-    return;
-  }
-
-  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
-  Archive::FileInfo file_info;
-  if (!archive || !archive->GetFileInfo(relative_path, &file_info)) {
-    type_ = TYPE_ERROR;
-    return;
-  }
-
-  if (file_info.unpacked) {
-    base::FilePath real_path;
-    archive->CopyFileOut(relative_path, &real_path);
-    InitializeFileJob(file_task_runner, real_path);
-    return;
-  }
-
-  InitializeAsarJob(file_task_runner, archive, relative_path, file_info);
-}
-
-void URLRequestAsarJob::InitializeAsarJob(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    std::shared_ptr<Archive> archive,
-    const base::FilePath& file_path,
-    const Archive::FileInfo& file_info) {
-  type_ = TYPE_ASAR;
-  file_task_runner_ = file_task_runner;
-  stream_.reset(new net::FileStream(file_task_runner_));
-  archive_ = archive;
-  file_path_ = file_path;
-  file_info_ = file_info;
-}
-
-void URLRequestAsarJob::InitializeFileJob(
-    const scoped_refptr<base::TaskRunner> file_task_runner,
-    const base::FilePath& file_path) {
-  type_ = TYPE_FILE;
-  file_task_runner_ = file_task_runner;
-  stream_.reset(new net::FileStream(file_task_runner_));
-  file_path_ = file_path;
-}
-
-void URLRequestAsarJob::Start() {
-  if (type_ == TYPE_ASAR || type_ == TYPE_FILE) {
-    auto* meta_info = new FileMetaInfo();
-    if (type_ == TYPE_ASAR) {
-      meta_info->file_path = archive_->path();
-      meta_info->file_exists = true;
-      meta_info->is_directory = false;
-      meta_info->file_size = file_info_.size;
-    }
-    file_task_runner_->PostTaskAndReply(
-        FROM_HERE,
-        base::BindOnce(&URLRequestAsarJob::FetchMetaInfo, file_path_, type_,
-                       base::Unretained(meta_info)),
-        base::BindOnce(&URLRequestAsarJob::DidFetchMetaInfo,
-                       weak_ptr_factory_.GetWeakPtr(), base::Owned(meta_info)));
-  } else {
-    base::ThreadTaskRunnerHandle::Get()->PostTask(
-        FROM_HERE, base::BindOnce(&URLRequestAsarJob::DidOpen,
-                                  weak_ptr_factory_.GetWeakPtr(),
-                                  net::ERR_FILE_NOT_FOUND));
-  }
-}
-
-void URLRequestAsarJob::Kill() {
-  stream_.reset();
-  weak_ptr_factory_.InvalidateWeakPtrs();
-
-  URLRequestJob::Kill();
-}
-
-int URLRequestAsarJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
-  if (remaining_bytes_ < dest_size)
-    dest_size = static_cast<int>(remaining_bytes_);
-
-  // If we should copy zero bytes because |remaining_bytes_| is zero, short
-  // circuit here.
-  if (!dest_size)
-    return 0;
-
-  int rv = stream_->Read(
-      dest, dest_size,
-      base::Bind(&URLRequestAsarJob::DidRead, weak_ptr_factory_.GetWeakPtr(),
-                 WrapRefCounted(dest)));
-  if (rv >= 0) {
-    remaining_bytes_ -= rv;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  return rv;
-}
-
-bool URLRequestAsarJob::IsRedirectResponse(GURL* location,
-                                           int* http_status_code) {
-  if (type_ != TYPE_FILE)
-    return false;
-#if defined(OS_WIN)
-  // Follow a Windows shortcut.
-  // We just resolve .lnk file, ignore others.
-  if (!base::LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
-    return false;
-
-  base::FilePath new_path = file_path_;
-  bool resolved;
-  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
-
-  // If shortcut is not resolved succesfully, do not redirect.
-  if (!resolved)
-    return false;
-
-  *location = net::FilePathToFileURL(new_path);
-  *http_status_code = 301;
-  return true;
-#else
-  return false;
-#endif
-}
-
-std::unique_ptr<net::SourceStream> URLRequestAsarJob::SetUpSourceStream() {
-  std::unique_ptr<net::SourceStream> source =
-      net::URLRequestJob::SetUpSourceStream();
-  // Bug 9936 - .svgz files needs to be decompressed.
-  return base::LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
-             ? net::GzipSourceStream::Create(std::move(source),
-                                             net::SourceStream::TYPE_GZIP)
-             : std::move(source);
-}
-
-bool URLRequestAsarJob::GetMimeType(std::string* mime_type) const {
-  if (meta_info_.mime_type_result) {
-    *mime_type = meta_info_.mime_type;
-    return true;
-  }
-  return false;
-}
-
-void URLRequestAsarJob::SetExtraRequestHeaders(
-    const net::HttpRequestHeaders& headers) {
-  std::string range_header;
-  if (headers.GetHeader(net::HttpRequestHeaders::kRange, &range_header)) {
-    // This job only cares about the Range header. This method stashes the value
-    // for later use in DidOpen(), which is responsible for some of the range
-    // validation as well. NotifyStartError is not legal to call here since
-    // the job has not started.
-    std::vector<net::HttpByteRange> ranges;
-    if (net::HttpUtil::ParseRangeHeader(range_header, &ranges)) {
-      if (ranges.size() == 1) {
-        byte_range_ = ranges[0];
-      } else {
-        range_parse_result_ = net::ERR_REQUEST_RANGE_NOT_SATISFIABLE;
-      }
-    }
-  }
-}
-
-int URLRequestAsarJob::GetResponseCode() const {
-  // Request Job gets created only if path exists.
-  return 200;
-}
-
-void URLRequestAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(atom::kCORSHeader);
-  info->headers = headers;
-}
-
-void URLRequestAsarJob::FetchMetaInfo(const base::FilePath& file_path,
-                                      JobType type,
-                                      FileMetaInfo* meta_info) {
-  if (type == TYPE_FILE) {
-    base::File::Info file_info;
-    meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
-    if (meta_info->file_exists) {
-      meta_info->file_path = file_path;
-      meta_info->file_size = file_info.size;
-      meta_info->is_directory = file_info.is_directory;
-    }
-  }
-
-  // We use GetWellKnownMimeTypeFromExtension() to ensure that configurations
-  // that may have been set by other programs on a user's machine don't affect
-  // the mime type returned (in particular, JS should always be
-  // (application/javascript). See https://crbug.com/797712. Using an accurate
-  // mime type is necessary at least for modules and sw, which enforce strict
-  // mime type requirements.
-  // TODO(deepak1556): Revert this when sw support is removed for file scheme.
-  base::FilePath::StringType file_extension = file_path.Extension();
-  if (file_extension.empty()) {
-    meta_info->mime_type_result = false;
-  } else {
-    meta_info->mime_type_result = net::GetWellKnownMimeTypeFromExtension(
-        file_extension.substr(1), &meta_info->mime_type);
-  }
-}
-
-void URLRequestAsarJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
-  meta_info_ = *meta_info;
-  if (!meta_info_.file_exists || meta_info_.is_directory) {
-    DidOpen(net::ERR_FILE_NOT_FOUND);
-    return;
-  }
-
-  int flags =
-      base::File::FLAG_OPEN | base::File::FLAG_READ | base::File::FLAG_ASYNC;
-  int rv = stream_->Open(
-      meta_info_.file_path, flags,
-      base::Bind(&URLRequestAsarJob::DidOpen, weak_ptr_factory_.GetWeakPtr()));
-  if (rv != net::ERR_IO_PENDING)
-    DidOpen(rv);
-}
-
-void URLRequestAsarJob::DidOpen(int result) {
-  if (result != net::OK) {
-    NotifyStartError(
-        net::URLRequestStatus(net::URLRequestStatus::FAILED, result));
-    return;
-  }
-
-  if (range_parse_result_ != net::OK) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           range_parse_result_));
-    return;
-  }
-
-  int64_t file_size, read_offset;
-  if (type_ == TYPE_ASAR) {
-    file_size = file_info_.size;
-    read_offset = file_info_.offset;
-  } else {
-    file_size = meta_info_.file_size;
-    read_offset = 0;
-  }
-
-  if (!byte_range_.ComputeBounds(file_size)) {
-    NotifyStartError(net::URLRequestStatus(
-        net::URLRequestStatus::FAILED, net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-
-  remaining_bytes_ =
-      byte_range_.last_byte_position() - byte_range_.first_byte_position() + 1;
-  seek_offset_ = byte_range_.first_byte_position() + read_offset;
-
-  if (remaining_bytes_ > 0 && seek_offset_ != 0) {
-    int rv =
-        stream_->Seek(seek_offset_, base::Bind(&URLRequestAsarJob::DidSeek,
-                                               weak_ptr_factory_.GetWeakPtr()));
-    if (rv != net::ERR_IO_PENDING) {
-      // stream_->Seek() failed, so pass an intentionally erroneous value
-      // into DidSeek().
-      DidSeek(-1);
-    }
-  } else {
-    // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
-    // the value that would mean seek success. This way we skip the code
-    // handling seek failure.
-    DidSeek(seek_offset_);
-  }
-}
-
-void URLRequestAsarJob::DidSeek(int64_t result) {
-  if (result != seek_offset_) {
-    NotifyStartError(net::URLRequestStatus(
-        net::URLRequestStatus::FAILED, net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
-    return;
-  }
-  set_expected_content_size(remaining_bytes_);
-  NotifyHeadersComplete();
-}
-
-void URLRequestAsarJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
-  if (result >= 0) {
-    remaining_bytes_ -= result;
-    DCHECK_GE(remaining_bytes_, 0);
-  }
-
-  buf = nullptr;
-
-  ReadRawDataComplete(result);
-}
-
-}  // namespace asar
removed in remote
  base   100644 7103abc4139adc7329101f38646fd02afac9ab97 atom/browser/net/asar/url_request_asar_job.h
  our    100644 fde6302e031d4978bc6aa9419ef1d2d458f95c4a atom/browser/net/asar/url_request_asar_job.h
@@ -1,135 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
-#define ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "atom/common/asar/archive.h"
-#include "base/files/file_path.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "net/http/http_byte_range.h"
-#include "net/url_request/url_request_job.h"
-
-namespace base {
-class TaskRunner;
-}
-
-namespace net {
-class FileStream;
-}
-
-namespace asar {
-
-// Createa a request job according to the file path.
-net::URLRequestJob* CreateJobFromPath(
-    const base::FilePath& full_path,
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate,
-    const scoped_refptr<base::TaskRunner> file_task_runner);
-
-class URLRequestAsarJob : public net::URLRequestJob {
- public:
-  URLRequestAsarJob(net::URLRequest* request,
-                    net::NetworkDelegate* network_delegate);
-
-  void Initialize(const scoped_refptr<base::TaskRunner> file_task_runner,
-                  const base::FilePath& file_path);
-
- protected:
-  ~URLRequestAsarJob() override;
-
-  void InitializeAsarJob(const scoped_refptr<base::TaskRunner> file_task_runner,
-                         std::shared_ptr<Archive> archive,
-                         const base::FilePath& file_path,
-                         const Archive::FileInfo& file_info);
-  void InitializeFileJob(const scoped_refptr<base::TaskRunner> file_task_runner,
-                         const base::FilePath& file_path);
-
-  // net::URLRequestJob:
-  void Start() override;
-  void Kill() override;
-  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
-  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
-  std::unique_ptr<net::SourceStream> SetUpSourceStream() override;
-  bool GetMimeType(std::string* mime_type) const override;
-  void SetExtraRequestHeaders(const net::HttpRequestHeaders& headers) override;
-  int GetResponseCode() const override;
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
- private:
-  // The type of this job.
-  enum JobType {
-    TYPE_ERROR,
-    TYPE_ASAR,
-    TYPE_FILE,
-  };
-
-  // Meta information about the file. It's used as a member in the
-  // URLRequestFileJob and also passed between threads because disk access is
-  // necessary to obtain it.
-  struct FileMetaInfo {
-    // Size of the file.
-    int64_t file_size = 0;
-    // Mime type associated with the file.
-    std::string mime_type;
-    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
-    // obtaining of the mime type was successful.
-    bool mime_type_result = false;
-    // Flag showing whether the file exists.
-    bool file_exists = false;
-    // Flag showing whether the file name actually refers to a directory.
-    bool is_directory = false;
-    // Path to the file.
-    base::FilePath file_path;
-
-    FileMetaInfo();
-  };
-
-  // Fetches file info on a background thread.
-  static void FetchMetaInfo(const base::FilePath& file_path,
-                            JobType type,
-                            FileMetaInfo* meta_info);
-
-  // Callback after fetching file info on a background thread.
-  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
-
-  // Callback after opening file on a background thread.
-  void DidOpen(int result);
-
-  // Callback after seeking to the beginning of |byte_range_| in the file
-  // on a background thread.
-  void DidSeek(int64_t result);
-
-  // Callback after data is asynchronously read from the file into |buf|.
-  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
-
-  JobType type_ = TYPE_ERROR;
-
-  std::shared_ptr<Archive> archive_;
-  base::FilePath file_path_;
-  Archive::FileInfo file_info_;
-
-  std::unique_ptr<net::FileStream> stream_;
-  FileMetaInfo meta_info_;
-  scoped_refptr<base::TaskRunner> file_task_runner_;
-
-  net::HttpByteRange byte_range_;
-  int64_t remaining_bytes_ = 0;
-  int64_t seek_offset_ = 0;
-
-  net::Error range_parse_result_ = net::OK;
-
-  base::WeakPtrFactory<URLRequestAsarJob> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestAsarJob);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
removed in remote
  base   100644 3633d805fb5b89707c1924d40ab3d10e2bb6e14e atom/browser/net/atom_cert_verifier.cc
  our    100644 75437f605c83ad050fc706abbce534f9383ba3a6 atom/browser/net/atom_cert_verifier.cc
@@ -1,209 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_cert_verifier.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/containers/linked_list.h"
-#include "base/memory/weak_ptr.h"
-#include "brightray/browser/net/require_ct_delegate.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/net_errors.h"
-#include "net/cert/cert_verify_result.h"
-#include "net/cert/crl_set.h"
-#include "net/cert/x509_certificate.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-VerifyRequestParams::VerifyRequestParams() = default;
-VerifyRequestParams::~VerifyRequestParams() = default;
-VerifyRequestParams::VerifyRequestParams(const VerifyRequestParams&) = default;
-
-namespace {
-
-class Response : public base::LinkNode<Response> {
- public:
-  Response(net::CertVerifyResult* verify_result,
-           const net::CompletionCallback& callback)
-      : verify_result_(verify_result), callback_(callback) {}
-  net::CertVerifyResult* verify_result() { return verify_result_; }
-  net::CompletionCallback callback() { return callback_; }
-
- private:
-  net::CertVerifyResult* verify_result_;
-  net::CompletionCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(Response);
-};
-
-}  // namespace
-
-class CertVerifierRequest : public AtomCertVerifier::Request {
- public:
-  CertVerifierRequest(const AtomCertVerifier::RequestParams& params,
-                      AtomCertVerifier* cert_verifier)
-      : params_(params),
-        cert_verifier_(cert_verifier),
-        weak_ptr_factory_(this) {}
-
-  ~CertVerifierRequest() override {
-    cert_verifier_->RemoveRequest(params_);
-    default_verifier_request_.reset();
-    while (!response_list_.empty() && !first_response_) {
-      base::LinkNode<Response>* response_node = response_list_.head();
-      response_node->RemoveFromList();
-      Response* response = response_node->value();
-      RunResponse(response);
-    }
-    cert_verifier_ = nullptr;
-    weak_ptr_factory_.InvalidateWeakPtrs();
-  }
-
-  void RunResponse(Response* response) {
-    if (custom_response_ == net::ERR_ABORTED) {
-      *(response->verify_result()) = result_;
-      response->callback().Run(error_);
-    } else {
-      response->verify_result()->Reset();
-      response->verify_result()->verified_cert = params_.certificate();
-      cert_verifier_->ct_delegate()->AddCTExcludedHost(params_.hostname());
-      response->callback().Run(custom_response_);
-    }
-    delete response;
-  }
-
-  void Start(net::CRLSet* crl_set, const net::NetLogWithSource& net_log) {
-    int error = cert_verifier_->default_verifier()->Verify(
-        params_, crl_set, &result_,
-        base::Bind(&CertVerifierRequest::OnDefaultVerificationDone,
-                   weak_ptr_factory_.GetWeakPtr()),
-        &default_verifier_request_, net_log);
-    if (error != net::ERR_IO_PENDING)
-      OnDefaultVerificationDone(error);
-  }
-
-  void OnDefaultVerificationDone(int error) {
-    error_ = error;
-    auto request = std::make_unique<VerifyRequestParams>();
-    request->hostname = params_.hostname();
-    request->default_result = net::ErrorToString(error);
-    request->error_code = error;
-    request->certificate = params_.certificate();
-    auto response_callback = base::Bind(&CertVerifierRequest::OnResponseInUI,
-                                        weak_ptr_factory_.GetWeakPtr());
-    BrowserThread::PostTask(
-        BrowserThread::UI, FROM_HERE,
-        base::BindOnce(&CertVerifierRequest::OnVerifyRequestInUI,
-                       cert_verifier_->verify_proc(), std::move(request),
-                       response_callback));
-  }
-
-  static void OnVerifyRequestInUI(
-      const AtomCertVerifier::VerifyProc& verify_proc,
-      std::unique_ptr<VerifyRequestParams> request,
-      const base::Callback<void(int)>& response_callback) {
-    verify_proc.Run(*(request.get()), response_callback);
-  }
-
-  static void OnResponseInUI(base::WeakPtr<CertVerifierRequest> self,
-                             int result) {
-    BrowserThread::PostTask(
-        BrowserThread::IO, FROM_HERE,
-        base::BindOnce(&CertVerifierRequest::NotifyResponseInIO, self, result));
-  }
-
-  void NotifyResponseInIO(int result) {
-    custom_response_ = result;
-    first_response_ = false;
-    // Responding to first request in the list will initiate destruction of
-    // the class, respond to others in the list inside destructor.
-    base::LinkNode<Response>* response_node = response_list_.head();
-    response_node->RemoveFromList();
-    Response* response = response_node->value();
-    RunResponse(response);
-  }
-
-  void AddResponseListener(net::CertVerifyResult* verify_result,
-                           const net::CompletionCallback& callback) {
-    response_list_.Append(new Response(verify_result, callback));
-  }
-
-  const AtomCertVerifier::RequestParams& params() const { return params_; }
-
- private:
-  using ResponseList = base::LinkedList<Response>;
-
-  const AtomCertVerifier::RequestParams params_;
-  AtomCertVerifier* cert_verifier_;
-  int error_ = net::ERR_IO_PENDING;
-  int custom_response_ = net::ERR_IO_PENDING;
-  bool first_response_ = true;
-  ResponseList response_list_;
-  net::CertVerifyResult result_;
-  std::unique_ptr<AtomCertVerifier::Request> default_verifier_request_;
-  base::WeakPtrFactory<CertVerifierRequest> weak_ptr_factory_;
-};
-
-AtomCertVerifier::AtomCertVerifier(brightray::RequireCTDelegate* ct_delegate)
-    : default_cert_verifier_(net::CertVerifier::CreateDefault()),
-      ct_delegate_(ct_delegate) {}
-
-AtomCertVerifier::~AtomCertVerifier() {}
-
-void AtomCertVerifier::SetVerifyProc(const VerifyProc& proc) {
-  verify_proc_ = proc;
-}
-
-int AtomCertVerifier::Verify(const RequestParams& params,
-                             net::CRLSet* crl_set,
-                             net::CertVerifyResult* verify_result,
-                             const net::CompletionCallback& callback,
-                             std::unique_ptr<Request>* out_req,
-                             const net::NetLogWithSource& net_log) {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  if (verify_proc_.is_null()) {
-    ct_delegate_->ClearCTExcludedHostsList();
-    return default_cert_verifier_->Verify(params, crl_set, verify_result,
-                                          callback, out_req, net_log);
-  } else {
-    CertVerifierRequest* request = FindRequest(params);
-    if (!request) {
-      out_req->reset();
-      auto new_request = std::make_unique<CertVerifierRequest>(params, this);
-      new_request->Start(crl_set, net_log);
-      request = new_request.get();
-      *out_req = std::move(new_request);
-      inflight_requests_[params] = request;
-    }
-    request->AddResponseListener(verify_result, callback);
-
-    return net::ERR_IO_PENDING;
-  }
-}
-
-bool AtomCertVerifier::SupportsOCSPStapling() {
-  if (verify_proc_.is_null())
-    return default_cert_verifier_->SupportsOCSPStapling();
-  return false;
-}
-
-void AtomCertVerifier::RemoveRequest(const RequestParams& params) {
-  auto it = inflight_requests_.find(params);
-  if (it != inflight_requests_.end())
-    inflight_requests_.erase(it);
-}
-
-CertVerifierRequest* AtomCertVerifier::FindRequest(
-    const RequestParams& params) {
-  auto it = inflight_requests_.find(params);
-  if (it != inflight_requests_.end())
-    return it->second;
-  return nullptr;
-}
-
-}  // namespace atom
removed in remote
  base   100644 796ae2849bda44743699e9bf03ca830608d16189 atom/browser/net/atom_cert_verifier.h
  our    100644 458615f3ed43fa8ddb6fb68138a3a1e7d845677e atom/browser/net/atom_cert_verifier.h
@@ -1,77 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
-#define ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
-
-#include <map>
-#include <memory>
-#include <string>
-
-#include "net/cert/cert_verifier.h"
-
-namespace brightray {
-
-class RequireCTDelegate;
-
-}  // namespace brightray
-
-namespace atom {
-
-class CertVerifierRequest;
-
-struct VerifyRequestParams {
-  std::string hostname;
-  std::string default_result;
-  int error_code;
-  scoped_refptr<net::X509Certificate> certificate;
-
-  VerifyRequestParams();
-  VerifyRequestParams(const VerifyRequestParams&);
-  ~VerifyRequestParams();
-};
-
-class AtomCertVerifier : public net::CertVerifier {
- public:
-  explicit AtomCertVerifier(brightray::RequireCTDelegate* ct_delegate);
-  ~AtomCertVerifier() override;
-
-  using VerifyProc = base::Callback<void(const VerifyRequestParams& request,
-                                         const net::CompletionCallback&)>;
-
-  void SetVerifyProc(const VerifyProc& proc);
-
-  const VerifyProc verify_proc() const { return verify_proc_; }
-  brightray::RequireCTDelegate* ct_delegate() const { return ct_delegate_; }
-  net::CertVerifier* default_verifier() const {
-    return default_cert_verifier_.get();
-  }
-
- protected:
-  // net::CertVerifier:
-  int Verify(const RequestParams& params,
-             net::CRLSet* crl_set,
-             net::CertVerifyResult* verify_result,
-             const net::CompletionCallback& callback,
-             std::unique_ptr<Request>* out_req,
-             const net::NetLogWithSource& net_log) override;
-  bool SupportsOCSPStapling() override;
-
- private:
-  friend class CertVerifierRequest;
-
-  void RemoveRequest(const RequestParams& params);
-  CertVerifierRequest* FindRequest(const RequestParams& params);
-
-  std::map<RequestParams, CertVerifierRequest*> inflight_requests_;
-  VerifyProc verify_proc_;
-  std::unique_ptr<net::CertVerifier> default_cert_verifier_;
-  brightray::RequireCTDelegate* ct_delegate_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomCertVerifier);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_CERT_VERIFIER_H_
removed in remote
  base   100644 91b63fada3598da41a34522561234fcc6ecd23ef atom/browser/net/atom_network_delegate.cc
  our    100644 e71ea74317b69f31a5aac8e723902748972fed8f atom/browser/net/atom_network_delegate.cc
@@ -1,553 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_network_delegate.h"
-
-#include <utility>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/login_handler.h"
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/stl_util.h"
-#include "base/strings/string_util.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/resource_request_info.h"
-#include "net/base/load_flags.h"
-#include "net/base/net_errors.h"
-#include "net/url_request/url_request.h"
-#include "services/network/throttling/throttling_network_transaction.h"
-
-using content::BrowserThread;
-using network::ThrottlingNetworkTransaction;
-
-namespace atom {
-
-const char* ResourceTypeToString(content::ResourceType type) {
-  switch (type) {
-    case content::RESOURCE_TYPE_MAIN_FRAME:
-      return "mainFrame";
-    case content::RESOURCE_TYPE_SUB_FRAME:
-      return "subFrame";
-    case content::RESOURCE_TYPE_STYLESHEET:
-      return "stylesheet";
-    case content::RESOURCE_TYPE_SCRIPT:
-      return "script";
-    case content::RESOURCE_TYPE_IMAGE:
-      return "image";
-    case content::RESOURCE_TYPE_OBJECT:
-      return "object";
-    case content::RESOURCE_TYPE_XHR:
-      return "xhr";
-    default:
-      return "other";
-  }
-}
-
-int32_t GetWebContentsID(int process_id, int frame_id) {
-  auto* webContents = content::WebContents::FromRenderFrameHost(
-      content::RenderFrameHost::FromID(process_id, frame_id));
-  return atom::api::WebContents::GetIDFromWrappedClass(webContents);
-}
-
-namespace {
-
-using ResponseHeadersContainer =
-    std::pair<scoped_refptr<net::HttpResponseHeaders>*, const std::string&>;
-
-void RunSimpleListener(const AtomNetworkDelegate::SimpleListener& listener,
-                       std::unique_ptr<base::DictionaryValue> details,
-                       int render_process_id,
-                       int render_frame_id) {
-  int32_t id = GetWebContentsID(render_process_id, render_frame_id);
-  // id must be greater than zero
-  if (id)
-    details->SetInteger("webContentsId", id);
-  return listener.Run(*(details.get()));
-}
-
-void RunResponseListener(
-    const AtomNetworkDelegate::ResponseListener& listener,
-    std::unique_ptr<base::DictionaryValue> details,
-    int render_process_id,
-    int render_frame_id,
-    const AtomNetworkDelegate::ResponseCallback& callback) {
-  int32_t id = GetWebContentsID(render_process_id, render_frame_id);
-  // id must be greater than zero
-  if (id)
-    details->SetInteger("webContentsId", id);
-  return listener.Run(*(details.get()), callback);
-}
-
-// Test whether the URL of |request| matches |patterns|.
-bool MatchesFilterCondition(net::URLRequest* request,
-                            const URLPatterns& patterns) {
-  if (patterns.empty())
-    return true;
-
-  for (const auto& pattern : patterns) {
-    if (pattern.MatchesURL(request->url()))
-      return true;
-  }
-  return false;
-}
-
-// Overloaded by multiple types to fill the |details| object.
-void ToDictionary(base::DictionaryValue* details, net::URLRequest* request) {
-  FillRequestDetails(details, request);
-  details->SetInteger("id", request->identifier());
-  details->SetDouble("timestamp", base::Time::Now().ToDoubleT() * 1000);
-  const auto* info = content::ResourceRequestInfo::ForRequest(request);
-  if (info) {
-    details->SetString("resourceType",
-                       ResourceTypeToString(info->GetResourceType()));
-  } else {
-    details->SetString("resourceType", "other");
-  }
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HttpRequestHeaders& headers) {
-  auto dict = std::make_unique<base::DictionaryValue>();
-  net::HttpRequestHeaders::Iterator it(headers);
-  while (it.GetNext())
-    dict->SetKey(it.name(), base::Value(it.value()));
-  details->Set("requestHeaders", std::move(dict));
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HttpResponseHeaders* headers) {
-  if (!headers)
-    return;
-
-  auto dict = std::make_unique<base::DictionaryValue>();
-  size_t iter = 0;
-  std::string key;
-  std::string value;
-  while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
-    if (dict->FindKey(key)) {
-      base::ListValue* values = nullptr;
-      if (dict->GetList(key, &values))
-        values->AppendString(value);
-    } else {
-      auto values = std::make_unique<base::ListValue>();
-      values->AppendString(value);
-      dict->Set(key, std::move(values));
-    }
-  }
-  details->Set("responseHeaders", std::move(dict));
-  details->SetString("statusLine", headers->GetStatusLine());
-  details->SetInteger("statusCode", headers->response_code());
-}
-
-void ToDictionary(base::DictionaryValue* details, const GURL& location) {
-  details->SetString("redirectURL", location.spec());
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::HostPortPair& host_port) {
-  if (host_port.host().empty())
-    details->SetString("ip", host_port.host());
-}
-
-void ToDictionary(base::DictionaryValue* details, bool from_cache) {
-  details->SetBoolean("fromCache", from_cache);
-}
-
-void ToDictionary(base::DictionaryValue* details,
-                  const net::URLRequestStatus& status) {
-  details->SetString("error", net::ErrorToString(status.error()));
-}
-
-// Helper function to fill |details| with arbitrary |args|.
-template <typename Arg>
-void FillDetailsObject(base::DictionaryValue* details, Arg arg) {
-  ToDictionary(details, arg);
-}
-
-template <typename Arg, typename... Args>
-void FillDetailsObject(base::DictionaryValue* details, Arg arg, Args... args) {
-  ToDictionary(details, arg);
-  FillDetailsObject(details, args...);
-}
-
-// Fill the native types with the result from the response object.
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            GURL* new_location) {
-  std::string url;
-  if (response.GetString("redirectURL", &url))
-    *new_location = GURL(url);
-}
-
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            net::HttpRequestHeaders* headers) {
-  const base::DictionaryValue* dict;
-  if (response.GetDictionary("requestHeaders", &dict)) {
-    headers->Clear();
-    for (base::DictionaryValue::Iterator it(*dict); !it.IsAtEnd();
-         it.Advance()) {
-      if (it.value().is_string()) {
-        std::string value = it.value().GetString();
-        headers->SetHeader(it.key(), value);
-      }
-    }
-  }
-}
-
-void ReadFromResponseObject(const base::DictionaryValue& response,
-                            const ResponseHeadersContainer& container) {
-  const base::DictionaryValue* dict;
-  std::string status_line;
-  if (!response.GetString("statusLine", &status_line))
-    status_line = container.second;
-  if (response.GetDictionary("responseHeaders", &dict)) {
-    auto* headers = container.first;
-    *headers = new net::HttpResponseHeaders("");
-    (*headers)->ReplaceStatusLine(status_line);
-    for (base::DictionaryValue::Iterator it(*dict); !it.IsAtEnd();
-         it.Advance()) {
-      const base::ListValue* list;
-      if (it.value().GetAsList(&list)) {
-        (*headers)->RemoveHeader(it.key());
-        for (size_t i = 0; i < list->GetSize(); ++i) {
-          std::string value;
-          if (list->GetString(i, &value))
-            (*headers)->AddHeader(it.key() + " : " + value);
-        }
-      }
-    }
-  }
-}
-
-}  // namespace
-
-AtomNetworkDelegate::SimpleListenerInfo::SimpleListenerInfo(
-    URLPatterns patterns_,
-    SimpleListener listener_)
-    : url_patterns(patterns_), listener(listener_) {}
-AtomNetworkDelegate::SimpleListenerInfo::SimpleListenerInfo() = default;
-AtomNetworkDelegate::SimpleListenerInfo::~SimpleListenerInfo() = default;
-
-AtomNetworkDelegate::ResponseListenerInfo::ResponseListenerInfo(
-    URLPatterns patterns_,
-    ResponseListener listener_)
-    : url_patterns(patterns_), listener(listener_) {}
-AtomNetworkDelegate::ResponseListenerInfo::ResponseListenerInfo() = default;
-AtomNetworkDelegate::ResponseListenerInfo::~ResponseListenerInfo() = default;
-
-AtomNetworkDelegate::AtomNetworkDelegate() {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  if (command_line->HasSwitch(switches::kIgnoreConnectionsLimit)) {
-    std::string value =
-        command_line->GetSwitchValueASCII(switches::kIgnoreConnectionsLimit);
-    ignore_connections_limit_domains_ = base::SplitString(
-        value, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-  }
-}
-
-AtomNetworkDelegate::~AtomNetworkDelegate() {}
-
-void AtomNetworkDelegate::SetSimpleListenerInIO(SimpleEvent type,
-                                                URLPatterns patterns,
-                                                SimpleListener callback) {
-  if (callback.is_null())
-    simple_listeners_.erase(type);
-  else
-    simple_listeners_[type] = {std::move(patterns), std::move(callback)};
-}
-
-void AtomNetworkDelegate::SetResponseListenerInIO(ResponseEvent type,
-                                                  URLPatterns patterns,
-                                                  ResponseListener callback) {
-  if (callback.is_null())
-    response_listeners_.erase(type);
-  else
-    response_listeners_[type] = {std::move(patterns), std::move(callback)};
-}
-
-void AtomNetworkDelegate::SetDevToolsNetworkEmulationClientId(
-    const std::string& client_id) {
-  client_id_ = client_id;
-}
-
-int AtomNetworkDelegate::OnBeforeURLRequest(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    GURL* new_url) {
-  if (!base::ContainsKey(response_listeners_, kOnBeforeRequest)) {
-    for (const auto& domain : ignore_connections_limit_domains_) {
-      if (request->url().DomainIs(domain)) {
-        // Allow unlimited concurrent connections.
-        request->SetPriority(net::MAXIMUM_PRIORITY);
-        request->SetLoadFlags(request->load_flags() | net::LOAD_IGNORE_LIMITS);
-        break;
-      }
-    }
-    return net::OK;
-  }
-
-  return HandleResponseEvent(kOnBeforeRequest, request, callback, new_url);
-}
-
-int AtomNetworkDelegate::OnBeforeStartTransaction(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    net::HttpRequestHeaders* headers) {
-  if (!client_id_.empty())
-    headers->SetHeader(network::ThrottlingNetworkTransaction::
-                           kDevToolsEmulateNetworkConditionsClientId,
-                       client_id_);
-  if (!base::ContainsKey(response_listeners_, kOnBeforeSendHeaders))
-    return net::OK;
-
-  return HandleResponseEvent(kOnBeforeSendHeaders, request, callback, headers,
-                             *headers);
-}
-
-void AtomNetworkDelegate::OnStartTransaction(
-    net::URLRequest* request,
-    const net::HttpRequestHeaders& headers) {
-  if (!base::ContainsKey(simple_listeners_, kOnSendHeaders))
-    return;
-
-  HandleSimpleEvent(kOnSendHeaders, request, headers);
-}
-
-int AtomNetworkDelegate::OnHeadersReceived(
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    const net::HttpResponseHeaders* original,
-    scoped_refptr<net::HttpResponseHeaders>* override,
-    GURL* allowed) {
-  if (!base::ContainsKey(response_listeners_, kOnHeadersReceived))
-    return net::OK;
-
-  return HandleResponseEvent(
-      kOnHeadersReceived, request, callback,
-      std::make_pair(override, original->GetStatusLine()), original);
-}
-
-void AtomNetworkDelegate::OnBeforeRedirect(net::URLRequest* request,
-                                           const GURL& new_location) {
-  if (!base::ContainsKey(simple_listeners_, kOnBeforeRedirect))
-    return;
-
-  HandleSimpleEvent(kOnBeforeRedirect, request, new_location,
-                    request->response_headers(), request->GetSocketAddress(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnResponseStarted(net::URLRequest* request,
-                                            int net_error) {
-  if (!base::ContainsKey(simple_listeners_, kOnResponseStarted))
-    return;
-
-  if (request->status().status() != net::URLRequestStatus::SUCCESS)
-    return;
-
-  HandleSimpleEvent(kOnResponseStarted, request, request->response_headers(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnCompleted(net::URLRequest* request, bool started) {
-  // OnCompleted may happen before other events.
-  callbacks_.erase(request->identifier());
-
-  if (request->status().status() == net::URLRequestStatus::FAILED ||
-      request->status().status() == net::URLRequestStatus::CANCELED) {
-    // Error event.
-    OnErrorOccurred(request, started);
-    return;
-  }
-
-  if (request->response_headers() &&
-      net::HttpResponseHeaders::IsRedirectResponseCode(
-          request->response_headers()->response_code())) {
-    // Redirect event.
-    return;
-  }
-
-  if (!base::ContainsKey(simple_listeners_, kOnCompleted))
-    return;
-
-  HandleSimpleEvent(kOnCompleted, request, request->response_headers(),
-                    request->was_cached());
-}
-
-void AtomNetworkDelegate::OnURLRequestDestroyed(net::URLRequest* request) {
-  const auto& it = login_handler_map_.find(request->identifier());
-  if (it != login_handler_map_.end()) {
-    it->second->NotifyRequestDestroyed();
-    it->second = nullptr;
-    login_handler_map_.erase(it);
-  }
-  callbacks_.erase(request->identifier());
-}
-
-net::NetworkDelegate::AuthRequiredResponse AtomNetworkDelegate::OnAuthRequired(
-    net::URLRequest* request,
-    const net::AuthChallengeInfo& auth_info,
-    const AuthCallback& callback,
-    net::AuthCredentials* credentials) {
-  auto* resource_request_info =
-      content::ResourceRequestInfo::ForRequest(request);
-  if (!resource_request_info)
-    return AUTH_REQUIRED_RESPONSE_NO_ACTION;
-  login_handler_map_.emplace(
-      request->identifier(),
-      new LoginHandler(request, auth_info, std::move(callback), credentials,
-                       resource_request_info));
-  return AUTH_REQUIRED_RESPONSE_IO_PENDING;
-}
-
-bool AtomNetworkDelegate::OnCanGetCookies(const net::URLRequest& request,
-                                          const net::CookieList& cookie_list) {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanSetCookie(
-    const net::URLRequest& request,
-    const net::CanonicalCookie& cookie_line,
-    net::CookieOptions* options) {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanAccessFile(
-    const net::URLRequest& request,
-    const base::FilePath& original_path,
-    const base::FilePath& absolute_path) const {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCanEnablePrivacyMode(
-    const GURL& url,
-    const GURL& first_party_for_cookies) const {
-  return false;
-}
-
-bool AtomNetworkDelegate::OnAreExperimentalCookieFeaturesEnabled() const {
-  return true;
-}
-
-bool AtomNetworkDelegate::OnCancelURLRequestWithPolicyViolatingReferrerHeader(
-    const net::URLRequest& request,
-    const GURL& target_url,
-    const GURL& referrer_url) const {
-  return false;
-}
-
-// TODO(deepak1556) : Enable after hooking into the reporting service
-// https://crbug.com/704259
-bool AtomNetworkDelegate::OnCanQueueReportingReport(
-    const url::Origin& origin) const {
-  return false;
-}
-
-void AtomNetworkDelegate::OnCanSendReportingReports(
-    std::set<url::Origin> origins,
-    base::OnceCallback<void(std::set<url::Origin>)> result_callback) const {}
-
-bool AtomNetworkDelegate::OnCanSetReportingClient(const url::Origin& origin,
-                                                  const GURL& endpoint) const {
-  return false;
-}
-
-bool AtomNetworkDelegate::OnCanUseReportingClient(const url::Origin& origin,
-                                                  const GURL& endpoint) const {
-  return false;
-}
-
-void AtomNetworkDelegate::OnErrorOccurred(net::URLRequest* request,
-                                          bool started) {
-  if (!base::ContainsKey(simple_listeners_, kOnErrorOccurred))
-    return;
-
-  HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
-                    request->status());
-}
-
-template <typename Out, typename... Args>
-int AtomNetworkDelegate::HandleResponseEvent(
-    ResponseEvent type,
-    net::URLRequest* request,
-    const net::CompletionCallback& callback,
-    Out out,
-    Args... args) {
-  const auto& info = response_listeners_[type];
-  if (!MatchesFilterCondition(request, info.url_patterns))
-    return net::OK;
-
-  auto details = std::make_unique<base::DictionaryValue>();
-  FillDetailsObject(details.get(), request, args...);
-
-  int render_process_id, render_frame_id;
-  content::ResourceRequestInfo::GetRenderFrameForRequest(
-      request, &render_process_id, &render_frame_id);
-
-  // The |request| could be destroyed before the |callback| is called.
-  callbacks_[request->identifier()] = callback;
-
-  ResponseCallback response =
-      base::Bind(&AtomNetworkDelegate::OnListenerResultInUI<Out>,
-                 base::Unretained(this), request->identifier(), out);
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(RunResponseListener, info.listener, std::move(details),
-                     render_process_id, render_frame_id, response));
-  return net::ERR_IO_PENDING;
-}
-
-template <typename... Args>
-void AtomNetworkDelegate::HandleSimpleEvent(SimpleEvent type,
-                                            net::URLRequest* request,
-                                            Args... args) {
-  const auto& info = simple_listeners_[type];
-  if (!MatchesFilterCondition(request, info.url_patterns))
-    return;
-
-  auto details = std::make_unique<base::DictionaryValue>();
-  FillDetailsObject(details.get(), request, args...);
-
-  int render_process_id, render_frame_id;
-  content::ResourceRequestInfo::GetRenderFrameForRequest(
-      request, &render_process_id, &render_frame_id);
-
-  BrowserThread::PostTask(
-      BrowserThread::UI, FROM_HERE,
-      base::BindOnce(RunSimpleListener, info.listener, std::move(details),
-                     render_process_id, render_frame_id));
-}
-
-template <typename T>
-void AtomNetworkDelegate::OnListenerResultInIO(
-    uint64_t id,
-    T out,
-    std::unique_ptr<base::DictionaryValue> response) {
-  // The request has been destroyed.
-  if (!base::ContainsKey(callbacks_, id))
-    return;
-
-  ReadFromResponseObject(*response, out);
-
-  bool cancel = false;
-  response->GetBoolean("cancel", &cancel);
-  callbacks_[id].Run(cancel ? net::ERR_BLOCKED_BY_CLIENT : net::OK);
-}
-
-template <typename T>
-void AtomNetworkDelegate::OnListenerResultInUI(
-    uint64_t id,
-    T out,
-    const base::DictionaryValue& response) {
-  auto copy = base::DictionaryValue::From(
-      base::Value::ToUniquePtrValue(response.Clone()));
-  BrowserThread::PostTask(
-      BrowserThread::IO, FROM_HERE,
-      base::BindOnce(&AtomNetworkDelegate::OnListenerResultInIO<T>,
-                     base::Unretained(this), id, out, std::move(copy)));
-}
-
-}  // namespace atom
removed in remote
  base   100644 4f55f7c098633215be274003612b4e7ec89d5095 atom/browser/net/atom_network_delegate.h
  our    100644 39a7a8ddfcda17fd7d022331132b54485d07a279 atom/browser/net/atom_network_delegate.h
@@ -1,182 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
-#define ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
-
-#include <map>
-#include <set>
-#include <string>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/synchronization/lock.h"
-#include "base/values.h"
-#include "content/public/browser/resource_request_info.h"
-#include "extensions/common/url_pattern.h"
-#include "net/base/network_delegate.h"
-#include "net/http/http_request_headers.h"
-#include "net/http/http_response_headers.h"
-
-class URLPattern;
-
-namespace atom {
-
-using URLPatterns = std::set<URLPattern>;
-
-const char* ResourceTypeToString(content::ResourceType type);
-
-class LoginHandler;
-
-class AtomNetworkDelegate : public net::NetworkDelegate {
- public:
-  using ResponseCallback = base::Callback<void(const base::DictionaryValue&)>;
-  using SimpleListener = base::Callback<void(const base::DictionaryValue&)>;
-  using ResponseListener = base::Callback<void(const base::DictionaryValue&,
-                                               const ResponseCallback&)>;
-
-  enum SimpleEvent {
-    kOnSendHeaders,
-    kOnBeforeRedirect,
-    kOnResponseStarted,
-    kOnCompleted,
-    kOnErrorOccurred,
-  };
-
-  enum ResponseEvent {
-    kOnBeforeRequest,
-    kOnBeforeSendHeaders,
-    kOnHeadersReceived,
-  };
-
-  struct SimpleListenerInfo {
-    URLPatterns url_patterns;
-    SimpleListener listener;
-
-    SimpleListenerInfo(URLPatterns, SimpleListener);
-    SimpleListenerInfo();
-    ~SimpleListenerInfo();
-  };
-
-  struct ResponseListenerInfo {
-    URLPatterns url_patterns;
-    ResponseListener listener;
-
-    ResponseListenerInfo(URLPatterns, ResponseListener);
-    ResponseListenerInfo();
-    ~ResponseListenerInfo();
-  };
-
-  AtomNetworkDelegate();
-  ~AtomNetworkDelegate() override;
-
-  void SetSimpleListenerInIO(SimpleEvent type,
-                             URLPatterns patterns,
-                             SimpleListener callback);
-  void SetResponseListenerInIO(ResponseEvent type,
-                               URLPatterns patterns,
-                               ResponseListener callback);
-
-  void SetDevToolsNetworkEmulationClientId(const std::string& client_id);
-
- protected:
-  // net::NetworkDelegate:
-  int OnBeforeURLRequest(net::URLRequest* request,
-                         const net::CompletionCallback& callback,
-                         GURL* new_url) override;
-  int OnBeforeStartTransaction(net::URLRequest* request,
-                               const net::CompletionCallback& callback,
-                               net::HttpRequestHeaders* headers) override;
-  void OnBeforeSendHeaders(net::URLRequest* request,
-                           const net::ProxyInfo& proxy_info,
-                           const net::ProxyRetryInfoMap& proxy_retry_info,
-                           net::HttpRequestHeaders* headers) override {}
-  void OnStartTransaction(net::URLRequest* request,
-                          const net::HttpRequestHeaders& headers) override;
-  int OnHeadersReceived(
-      net::URLRequest* request,
-      const net::CompletionCallback& callback,
-      const net::HttpResponseHeaders* original_response_headers,
-      scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
-      GURL* allowed_unsafe_redirect_url) override;
-  void OnBeforeRedirect(net::URLRequest* request,
-                        const GURL& new_location) override;
-  void OnResponseStarted(net::URLRequest* request, int net_error) override;
-  void OnNetworkBytesReceived(net::URLRequest* request,
-                              int64_t bytes_read) override {}
-  void OnNetworkBytesSent(net::URLRequest* request,
-                          int64_t bytes_sent) override {}
-  void OnCompleted(net::URLRequest* request, bool started) override;
-  void OnURLRequestDestroyed(net::URLRequest* request) override;
-  void OnPACScriptError(int line_number, const base::string16& error) override {
-  }
-  AuthRequiredResponse OnAuthRequired(
-      net::URLRequest* request,
-      const net::AuthChallengeInfo& auth_info,
-      const AuthCallback& callback,
-      net::AuthCredentials* credentials) override;
-  bool OnCanGetCookies(const net::URLRequest& request,
-                       const net::CookieList& cookie_list) override;
-  bool OnCanSetCookie(const net::URLRequest& request,
-                      const net::CanonicalCookie& cookie_line,
-                      net::CookieOptions* options) override;
-  bool OnCanAccessFile(const net::URLRequest& request,
-                       const base::FilePath& original_path,
-                       const base::FilePath& absolute_path) const override;
-  bool OnCanEnablePrivacyMode(
-      const GURL& url,
-      const GURL& first_party_for_cookies) const override;
-  bool OnAreExperimentalCookieFeaturesEnabled() const override;
-  bool OnCancelURLRequestWithPolicyViolatingReferrerHeader(
-      const net::URLRequest& request,
-      const GURL& target_url,
-      const GURL& referrer_url) const override;
-  bool OnCanQueueReportingReport(const url::Origin& origin) const override;
-  void OnCanSendReportingReports(std::set<url::Origin> origins,
-                                 base::OnceCallback<void(std::set<url::Origin>)>
-                                     result_callback) const override;
-  bool OnCanSetReportingClient(const url::Origin& origin,
-                               const GURL& endpoint) const override;
-  bool OnCanUseReportingClient(const url::Origin& origin,
-                               const GURL& endpoint) const override;
-
- private:
-  void OnErrorOccurred(net::URLRequest* request, bool started);
-
-  template <typename... Args>
-  void HandleSimpleEvent(SimpleEvent type,
-                         net::URLRequest* request,
-                         Args... args);
-  template <typename Out, typename... Args>
-  int HandleResponseEvent(ResponseEvent type,
-                          net::URLRequest* request,
-                          const net::CompletionCallback& callback,
-                          Out out,
-                          Args... args);
-
-  // Deal with the results of Listener.
-  template <typename T>
-  void OnListenerResultInIO(uint64_t id,
-                            T out,
-                            std::unique_ptr<base::DictionaryValue> response);
-  template <typename T>
-  void OnListenerResultInUI(uint64_t id,
-                            T out,
-                            const base::DictionaryValue& response);
-
-  std::map<uint64_t, scoped_refptr<LoginHandler>> login_handler_map_;
-  std::map<SimpleEvent, SimpleListenerInfo> simple_listeners_;
-  std::map<ResponseEvent, ResponseListenerInfo> response_listeners_;
-  std::map<uint64_t, net::CompletionCallback> callbacks_;
-  std::vector<std::string> ignore_connections_limit_domains_;
-
-  // Client id for devtools network emulation.
-  std::string client_id_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomNetworkDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_NETWORK_DELEGATE_H_
removed in remote
  base   100644 dbd8b4160cfdde45847cbae66a17641012a2bc21 atom/browser/net/atom_url_request_job_factory.cc
  our    100644 7047f7a6f7f83e782121f2a849a621fb836ad534 atom/browser/net/atom_url_request_job_factory.cc
@@ -1,142 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/atom_url_request_job_factory.h"
-
-#include "base/memory/ptr_util.h"
-#include "base/stl_util.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/load_flags.h"
-#include "net/url_request/url_request.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-int disable_protocol_intercept_flag_key = 0;
-
-}  // namespace
-
-typedef net::URLRequestJobFactory::ProtocolHandler ProtocolHandler;
-
-const void* DisableProtocolInterceptFlagKey() {
-  return &disable_protocol_intercept_flag_key;
-}
-
-AtomURLRequestJobFactory::AtomURLRequestJobFactory() {}
-
-AtomURLRequestJobFactory::~AtomURLRequestJobFactory() {
-  Clear();
-}
-
-bool AtomURLRequestJobFactory::SetProtocolHandler(
-    const std::string& scheme,
-    std::unique_ptr<ProtocolHandler> protocol_handler) {
-  if (!protocol_handler) {
-    auto it = protocol_handler_map_.find(scheme);
-    if (it == protocol_handler_map_.end())
-      return false;
-
-    delete it->second;
-    protocol_handler_map_.erase(it);
-    return true;
-  }
-
-  if (base::ContainsKey(protocol_handler_map_, scheme))
-    return false;
-  protocol_handler_map_[scheme] = protocol_handler.release();
-  return true;
-}
-
-bool AtomURLRequestJobFactory::InterceptProtocol(
-    const std::string& scheme,
-    std::unique_ptr<ProtocolHandler> protocol_handler) {
-  if (!base::ContainsKey(protocol_handler_map_, scheme) ||
-      base::ContainsKey(original_protocols_, scheme))
-    return false;
-  ProtocolHandler* original_protocol_handler = protocol_handler_map_[scheme];
-  protocol_handler_map_[scheme] = protocol_handler.release();
-  original_protocols_[scheme].reset(original_protocol_handler);
-  return true;
-}
-
-bool AtomURLRequestJobFactory::UninterceptProtocol(const std::string& scheme) {
-  auto it = original_protocols_.find(scheme);
-  if (it == original_protocols_.end())
-    return false;
-  protocol_handler_map_[scheme] = it->second.release();
-  original_protocols_.erase(it);
-  return true;
-}
-
-ProtocolHandler* AtomURLRequestJobFactory::GetProtocolHandler(
-    const std::string& scheme) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  auto it = protocol_handler_map_.find(scheme);
-  if (it == protocol_handler_map_.end())
-    return nullptr;
-  return it->second;
-}
-
-bool AtomURLRequestJobFactory::HasProtocolHandler(
-    const std::string& scheme) const {
-  return base::ContainsKey(protocol_handler_map_, scheme);
-}
-
-void AtomURLRequestJobFactory::Clear() {
-  for (auto& it : protocol_handler_map_)
-    delete it.second;
-  protocol_handler_map_.clear();
-  original_protocols_.clear();
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeCreateJobWithProtocolHandler(
-    const std::string& scheme,
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  auto it = protocol_handler_map_.find(scheme);
-  if (it == protocol_handler_map_.end())
-    return nullptr;
-  if (request->GetUserData(DisableProtocolInterceptFlagKey()))
-    return nullptr;
-  return it->second->MaybeCreateJob(request, network_delegate);
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeInterceptRedirect(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate,
-    const GURL& location) const {
-  return nullptr;
-}
-
-net::URLRequestJob* AtomURLRequestJobFactory::MaybeInterceptResponse(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  return nullptr;
-}
-
-bool AtomURLRequestJobFactory::IsHandledProtocol(
-    const std::string& scheme) const {
-  DCHECK_CURRENTLY_ON(BrowserThread::IO);
-
-  return HasProtocolHandler(scheme) ||
-         net::URLRequest::IsHandledProtocol(scheme);
-}
-
-bool AtomURLRequestJobFactory::IsSafeRedirectTarget(
-    const GURL& location) const {
-  if (!location.is_valid()) {
-    // We handle error cases.
-    return true;
-  }
-  return IsHandledProtocol(location.scheme());
-}
-
-}  // namespace atom
removed in remote
  base   100644 dde36225b7af1a605fd6d135de177479e2da5650 atom/browser/net/atom_url_request_job_factory.h
  our    100644 c0e26568fdea57dd473f917d597624ab10efe129 atom/browser/net/atom_url_request_job_factory.h
@@ -1,77 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
-#define ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
-
-#include <map>
-#include <memory>
-#include <string>
-#include <unordered_map>
-#include <vector>
-
-#include "net/url_request/url_request_job_factory.h"
-
-namespace atom {
-
-const void* DisableProtocolInterceptFlagKey();
-
-class AtomURLRequestJobFactory : public net::URLRequestJobFactory {
- public:
-  AtomURLRequestJobFactory();
-  ~AtomURLRequestJobFactory() override;
-
-  // Sets the ProtocolHandler for a scheme. Returns true on success, false on
-  // failure (a ProtocolHandler already exists for |scheme|). On success,
-  // URLRequestJobFactory takes ownership of |protocol_handler|.
-  bool SetProtocolHandler(const std::string& scheme,
-                          std::unique_ptr<ProtocolHandler> protocol_handler);
-
-  // Intercepts the ProtocolHandler for a scheme.
-  bool InterceptProtocol(const std::string& scheme,
-                         std::unique_ptr<ProtocolHandler> protocol_handler);
-  bool UninterceptProtocol(const std::string& scheme);
-
-  // Returns the protocol handler registered with scheme.
-  ProtocolHandler* GetProtocolHandler(const std::string& scheme) const;
-
-  // Whether the protocol handler is registered by the job factory.
-  bool HasProtocolHandler(const std::string& scheme) const;
-
-  // Clear all protocol handlers.
-  void Clear();
-
-  // URLRequestJobFactory implementation
-  net::URLRequestJob* MaybeCreateJobWithProtocolHandler(
-      const std::string& scheme,
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  net::URLRequestJob* MaybeInterceptRedirect(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate,
-      const GURL& location) const override;
-  net::URLRequestJob* MaybeInterceptResponse(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-  bool IsHandledProtocol(const std::string& scheme) const override;
-  bool IsSafeRedirectTarget(const GURL& location) const override;
-
- private:
-  using ProtocolHandlerMap = std::map<std::string, ProtocolHandler*>;
-
-  ProtocolHandlerMap protocol_handler_map_;
-
-  // Map that stores the original protocols of schemes.
-  using OriginalProtocolsMap =
-      std::unordered_map<std::string, std::unique_ptr<ProtocolHandler>>;
-  // Can only be accessed in IO thread.
-  OriginalProtocolsMap original_protocols_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomURLRequestJobFactory);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_ATOM_URL_REQUEST_JOB_FACTORY_H_
removed in remote
  base   100644 cf5fc01c0884989b0078113436bcb972ba40b3f3 atom/browser/net/http_protocol_handler.cc
  our    100644 7c5cc365b74ba31e85fd8aa81a594507a65e2d7a atom/browser/net/http_protocol_handler.cc
@@ -1,22 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/http_protocol_handler.h"
-
-#include "net/url_request/url_request_http_job.h"
-
-namespace atom {
-
-HttpProtocolHandler::HttpProtocolHandler(const std::string& scheme)
-    : scheme_(scheme) {}
-
-HttpProtocolHandler::~HttpProtocolHandler() {}
-
-net::URLRequestJob* HttpProtocolHandler::MaybeCreateJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate) const {
-  return net::URLRequestHttpJob::Factory(request, network_delegate, scheme_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 98085374175b191fc75278e0bf116a46c6110fdd atom/browser/net/http_protocol_handler.h
  our    100644 39e1ff2ad29b81ce53191c3dbe629a6cf277b525 atom/browser/net/http_protocol_handler.h
@@ -1,30 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
-#define ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
-
-#include <string>
-
-#include "net/url_request/url_request_job_factory.h"
-
-namespace atom {
-
-class HttpProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
- public:
-  explicit HttpProtocolHandler(const std::string&);
-  ~HttpProtocolHandler() override;
-
-  // net::URLRequestJobFactory::ProtocolHandler:
-  net::URLRequestJob* MaybeCreateJob(
-      net::URLRequest* request,
-      net::NetworkDelegate* network_delegate) const override;
-
- private:
-  std::string scheme_;
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
removed in remote
  base   100644 b11a69c9c13bde5facde0b26db39ff42a1fc1f5c atom/browser/net/js_asker.cc
  our    100644 59e3ab881c2355c2ed29b806de59ef372c170b62 atom/browser/net/js_asker.cc
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/js_asker.h"
-
-#include <vector>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-
-namespace atom {
-
-namespace internal {
-
-namespace {
-
-// The callback which is passed to |handler|.
-void HandlerCallback(const BeforeStartCallback& before_start,
-                     const ResponseCallback& callback,
-                     mate::Arguments* args) {
-  // If there is no argument passed then we failed.
-  v8::Local<v8::Value> value;
-  if (!args->GetNext(&value)) {
-    content::BrowserThread::PostTask(content::BrowserThread::IO, FROM_HERE,
-                                     base::BindOnce(callback, false, nullptr));
-    return;
-  }
-
-  // Give the job a chance to parse V8 value.
-  before_start.Run(args->isolate(), value);
-
-  // Pass whatever user passed to the actaul request job.
-  V8ValueConverter converter;
-  v8::Local<v8::Context> context = args->isolate()->GetCurrentContext();
-  std::unique_ptr<base::Value> options(converter.FromV8Value(value, context));
-  content::BrowserThread::PostTask(
-      content::BrowserThread::IO, FROM_HERE,
-      base::BindOnce(callback, true, std::move(options)));
-}
-
-}  // namespace
-
-void AskForOptions(v8::Isolate* isolate,
-                   const JavaScriptHandler& handler,
-                   std::unique_ptr<base::DictionaryValue> request_details,
-                   const BeforeStartCallback& before_start,
-                   const ResponseCallback& callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  v8::Locker locker(isolate);
-  v8::HandleScope handle_scope(isolate);
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Context::Scope context_scope(context);
-  handler.Run(*(request_details.get()),
-              mate::ConvertToV8(isolate, base::Bind(&HandlerCallback,
-                                                    before_start, callback)));
-}
-
-bool IsErrorOptions(base::Value* value, int* error) {
-  if (value->is_dict()) {
-    base::DictionaryValue* dict = static_cast<base::DictionaryValue*>(value);
-    if (dict->GetInteger("error", error))
-      return true;
-  } else if (value->is_int()) {
-    *error = value->GetInt();
-    return true;
-  }
-  return false;
-}
-
-}  // namespace internal
-
-}  // namespace atom
removed in remote
  base   100644 8a70794fa946ea11ab783004f7dd3a0df7329df0 atom/browser/net/js_asker.h
  our    100644 45e2da9b82207215d054ccf0adba0ca935d5f8c0 atom/browser/net/js_asker.h
@@ -1,124 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_JS_ASKER_H_
-#define ATOM_BROWSER_NET_JS_ASKER_H_
-
-#include "atom/common/native_mate_converters/net_converter.h"
-#include "base/callback.h"
-#include "base/memory/ref_counted.h"
-#include "base/memory/weak_ptr.h"
-#include "base/values.h"
-#include "content/public/browser/browser_thread.h"
-#include "net/base/net_errors.h"
-#include "net/http/http_response_headers.h"
-#include "net/http/http_status_code.h"
-#include "net/url_request/url_request_context_getter.h"
-#include "net/url_request/url_request_job.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-using JavaScriptHandler =
-    base::Callback<void(const base::DictionaryValue&, v8::Local<v8::Value>)>;
-
-namespace internal {
-
-using BeforeStartCallback =
-    base::Callback<void(v8::Isolate*, v8::Local<v8::Value>)>;
-using ResponseCallback =
-    base::Callback<void(bool, std::unique_ptr<base::Value> options)>;
-
-// Ask handler for options in UI thread.
-void AskForOptions(v8::Isolate* isolate,
-                   const JavaScriptHandler& handler,
-                   std::unique_ptr<base::DictionaryValue> request_details,
-                   const BeforeStartCallback& before_start,
-                   const ResponseCallback& callback);
-
-// Test whether the |options| means an error.
-bool IsErrorOptions(base::Value* value, int* error);
-
-}  // namespace internal
-
-template <typename RequestJob>
-class JsAsker : public RequestJob {
- public:
-  JsAsker(net::URLRequest* request, net::NetworkDelegate* network_delegate)
-      : RequestJob(request, network_delegate), weak_factory_(this) {}
-
-  // Called by |CustomProtocolHandler| to store handler related information.
-  void SetHandlerInfo(v8::Isolate* isolate,
-                      net::URLRequestContextGetter* request_context_getter,
-                      const JavaScriptHandler& handler) {
-    isolate_ = isolate;
-    request_context_getter_ = request_context_getter;
-    handler_ = handler;
-  }
-
-  // Subclass should do initailze work here.
-  virtual void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) {}
-  virtual void StartAsync(std::unique_ptr<base::Value> options) = 0;
-
-  net::URLRequestContextGetter* request_context_getter() const {
-    return request_context_getter_;
-  }
-
- private:
-  // RequestJob:
-  void Start() override {
-    auto request_details = std::make_unique<base::DictionaryValue>();
-    request_start_time_ = base::TimeTicks::Now();
-    FillRequestDetails(request_details.get(), RequestJob::request());
-    content::BrowserThread::PostTask(
-        content::BrowserThread::UI, FROM_HERE,
-        base::BindOnce(
-            &internal::AskForOptions, isolate_, handler_,
-            std::move(request_details),
-            base::Bind(&JsAsker::BeforeStartInUI, weak_factory_.GetWeakPtr()),
-            base::Bind(&JsAsker::OnResponse, weak_factory_.GetWeakPtr())));
-  }
-
-  int GetResponseCode() const override { return net::HTTP_OK; }
-
-  // NOTE: We have to implement this method or risk a crash in blink for
-  // redirects!
-  void GetLoadTimingInfo(net::LoadTimingInfo* load_timing_info) const override {
-    load_timing_info->send_start = request_start_time_;
-    load_timing_info->send_end = request_start_time_;
-    load_timing_info->request_start = request_start_time_;
-    load_timing_info->receive_headers_end = response_start_time_;
-  }
-
-  void GetResponseInfo(net::HttpResponseInfo* info) override {
-    info->headers = new net::HttpResponseHeaders("");
-  }
-
-  // Called when the JS handler has sent the response, we need to decide whether
-  // to start, or fail the job.
-  void OnResponse(bool success, std::unique_ptr<base::Value> value) {
-    response_start_time_ = base::TimeTicks::Now();
-    int error = net::ERR_NOT_IMPLEMENTED;
-    if (success && value && !internal::IsErrorOptions(value.get(), &error)) {
-      StartAsync(std::move(value));
-    } else {
-      RequestJob::NotifyStartError(
-          net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
-    }
-  }
-
-  v8::Isolate* isolate_;
-  net::URLRequestContextGetter* request_context_getter_;
-  JavaScriptHandler handler_;
-  base::TimeTicks request_start_time_;
-  base::TimeTicks response_start_time_;
-
-  base::WeakPtrFactory<JsAsker> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(JsAsker);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_JS_ASKER_H_
removed in remote
  base   100644 3578f3b7971cf157cac6841b8118e1e9cf2a2edd atom/browser/net/url_request_async_asar_job.cc
  our    100644 1c15fd39b9d479b441b0931564f9e2c3f9de37c7 atom/browser/net/url_request_async_asar_job.cc
@@ -1,56 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_async_asar_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/task_scheduler/post_task.h"
-
-namespace atom {
-
-URLRequestAsyncAsarJob::URLRequestAsyncAsarJob(
-    net::URLRequest* request,
-    net::NetworkDelegate* network_delegate)
-    : JsAsker<asar::URLRequestAsarJob>(request, network_delegate) {}
-
-void URLRequestAsyncAsarJob::StartAsync(std::unique_ptr<base::Value> options) {
-  std::string file_path;
-  if (options->is_dict()) {
-    auto* path_value =
-        options->FindKeyOfType("path", base::Value::Type::STRING);
-    if (path_value)
-      file_path = path_value->GetString();
-  } else if (options->is_string()) {
-    file_path = options->GetString();
-  }
-
-  if (file_path.empty()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-  } else {
-    asar::URLRequestAsarJob::Initialize(
-        base::CreateSequencedTaskRunnerWithTraits(
-            {base::MayBlock(), base::TaskPriority::USER_VISIBLE,
-             base::TaskShutdownBehavior::SKIP_ON_SHUTDOWN}),
-#if defined(OS_WIN)
-        base::FilePath(base::UTF8ToWide(file_path)));
-#else
-        base::FilePath(file_path));
-#endif
-    asar::URLRequestAsarJob::Start();
-  }
-}
-
-void URLRequestAsyncAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-  info->headers = headers;
-}
-
-}  // namespace atom
removed in remote
  base   100644 d65142f0bdbbd690ce52619e15e1a6cac903c2bb atom/browser/net/url_request_async_asar_job.h
  our    100644 032f3d9924132607edfaeea86fa32d44cb2a7381 atom/browser/net/url_request_async_asar_job.h
@@ -1,30 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
-
-#include "atom/browser/net/asar/url_request_asar_job.h"
-#include "atom/browser/net/js_asker.h"
-
-namespace atom {
-
-// Like URLRequestAsarJob, but asks the JavaScript handler for file path.
-class URLRequestAsyncAsarJob : public JsAsker<asar::URLRequestAsarJob> {
- public:
-  URLRequestAsyncAsarJob(net::URLRequest*, net::NetworkDelegate*);
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(URLRequestAsyncAsarJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
removed in remote
  base   100644 aa273bf81693fc597e3e20737359dbb43c27c408 atom/browser/net/url_request_buffer_job.cc
  our    100644 750099c99a766baaa371de70be9ef772467bd89a atom/browser/net/url_request_buffer_job.cc
@@ -1,101 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_buffer_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "net/base/mime_util.h"
-#include "net/base/net_errors.h"
-
-namespace atom {
-
-namespace {
-
-std::string GetExtFromURL(const GURL& url) {
-  std::string spec = url.spec();
-  size_t index = spec.find_last_of('.');
-  if (index == std::string::npos || index == spec.size())
-    return std::string();
-  return spec.substr(index + 1, spec.size() - index - 1);
-}
-
-}  // namespace
-
-URLRequestBufferJob::URLRequestBufferJob(net::URLRequest* request,
-                                         net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate),
-      status_code_(net::HTTP_NOT_IMPLEMENTED) {}
-
-URLRequestBufferJob::~URLRequestBufferJob() = default;
-
-void URLRequestBufferJob::StartAsync(std::unique_ptr<base::Value> options) {
-  const base::Value* binary = nullptr;
-  if (options->is_dict()) {
-    base::DictionaryValue* dict =
-        static_cast<base::DictionaryValue*>(options.get());
-    dict->GetString("mimeType", &mime_type_);
-    dict->GetString("charset", &charset_);
-    dict->GetBinary("data", &binary);
-  } else if (options->is_blob()) {
-    binary = options.get();
-  }
-
-  if (mime_type_.empty()) {
-    std::string ext = GetExtFromURL(request()->url());
-#if defined(OS_WIN)
-    net::GetWellKnownMimeTypeFromExtension(base::UTF8ToUTF16(ext), &mime_type_);
-#else
-    net::GetWellKnownMimeTypeFromExtension(ext, &mime_type_);
-#endif
-  }
-
-  if (!binary) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-    return;
-  }
-
-  data_ = new base::RefCountedBytes(
-      reinterpret_cast<const unsigned char*>(binary->GetBlob().data()),
-      binary->GetBlob().size());
-  status_code_ = net::HTTP_OK;
-  net::URLRequestSimpleJob::Start();
-}
-
-void URLRequestBufferJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  status.append(base::IntToString(status_code_));
-  status.append(" ");
-  status.append(net::GetHttpReasonPhrase(status_code_));
-  status.append("\0\0", 2);
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-
-  if (!mime_type_.empty()) {
-    std::string content_type_header(net::HttpRequestHeaders::kContentType);
-    content_type_header.append(": ");
-    content_type_header.append(mime_type_);
-    headers->AddHeader(content_type_header);
-  }
-
-  info->headers = headers;
-}
-
-int URLRequestBufferJob::GetRefCountedData(
-    std::string* mime_type,
-    std::string* charset,
-    scoped_refptr<base::RefCountedMemory>* data,
-    const net::CompletionCallback& callback) const {
-  *mime_type = mime_type_;
-  *charset = charset_;
-  *data = data_;
-  return net::OK;
-}
-
-}  // namespace atom
removed in remote
  base   100644 ab8de7e8f030603c4816e2f1882c068b71e1f2c7 atom/browser/net/url_request_buffer_job.h
  our    100644 a9f72e0b2b28a6a2c98ec5dda1c1e27b2ad02b70 atom/browser/net/url_request_buffer_job.h
@@ -1,45 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "base/memory/ref_counted_memory.h"
-#include "net/http/http_status_code.h"
-#include "net/url_request/url_request_simple_job.h"
-
-namespace atom {
-
-class URLRequestBufferJob : public JsAsker<net::URLRequestSimpleJob> {
- public:
-  URLRequestBufferJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestBufferJob() override;
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
-  // URLRequestSimpleJob:
-  int GetRefCountedData(std::string* mime_type,
-                        std::string* charset,
-                        scoped_refptr<base::RefCountedMemory>* data,
-                        const net::CompletionCallback& callback) const override;
-
- private:
-  std::string mime_type_;
-  std::string charset_;
-  scoped_refptr<base::RefCountedBytes> data_;
-  net::HttpStatusCode status_code_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestBufferJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
removed in remote
  base   100644 2f907314cad4248e70075f11bf714efd68790244 atom/browser/net/url_request_fetch_job.cc
  our    100644 68539433f4de80a96bc672de3a2834b299d6c04b atom/browser/net/url_request_fetch_job.cc
@@ -1,286 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_fetch_job.h"
-
-#include <algorithm>
-#include <string>
-
-#include "atom/browser/api/atom_api_session.h"
-#include "atom/browser/atom_browser_context.h"
-#include "base/guid.h"
-#include "base/memory/ptr_util.h"
-#include "base/strings/string_util.h"
-#include "native_mate/dictionary.h"
-#include "net/base/io_buffer.h"
-#include "net/base/net_errors.h"
-#include "net/http/http_response_headers.h"
-#include "net/url_request/url_fetcher.h"
-#include "net/url_request/url_fetcher_response_writer.h"
-
-using content::BrowserThread;
-
-namespace atom {
-
-namespace {
-
-// Convert string to RequestType.
-net::URLFetcher::RequestType GetRequestType(const std::string& raw) {
-  std::string method = base::ToUpperASCII(raw);
-  if (method.empty() || method == "GET")
-    return net::URLFetcher::GET;
-  else if (method == "POST")
-    return net::URLFetcher::POST;
-  else if (method == "HEAD")
-    return net::URLFetcher::HEAD;
-  else if (method == "DELETE")
-    return net::URLFetcher::DELETE_REQUEST;
-  else if (method == "PUT")
-    return net::URLFetcher::PUT;
-  else if (method == "PATCH")
-    return net::URLFetcher::PATCH;
-  else  // Use "GET" as fallback.
-    return net::URLFetcher::GET;
-}
-
-// Pipe the response writer back to URLRequestFetchJob.
-class ResponsePiper : public net::URLFetcherResponseWriter {
- public:
-  explicit ResponsePiper(URLRequestFetchJob* job) : job_(job) {}
-
-  // net::URLFetcherResponseWriter:
-  int Initialize(const net::CompletionCallback& callback) override {
-    return net::OK;
-  }
-  int Write(net::IOBuffer* buffer,
-            int num_bytes,
-            const net::CompletionCallback& callback) override {
-    if (first_write_) {
-      // The URLFetcherResponseWriter doesn't have an event when headers have
-      // been read, so we have to emulate by hooking to first write event.
-      job_->HeadersCompleted();
-      first_write_ = false;
-    }
-    return job_->DataAvailable(buffer, num_bytes, callback);
-  }
-  int Finish(int net_error, const net::CompletionCallback& callback) override {
-    return net::OK;
-  }
-
- private:
-  bool first_write_ = true;
-  URLRequestFetchJob* job_;
-
-  DISALLOW_COPY_AND_ASSIGN(ResponsePiper);
-};
-
-}  // namespace
-
-URLRequestFetchJob::URLRequestFetchJob(net::URLRequest* request,
-                                       net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestJob>(request, network_delegate) {}
-
-URLRequestFetchJob::~URLRequestFetchJob() = default;
-
-void URLRequestFetchJob::BeforeStartInUI(v8::Isolate* isolate,
-                                         v8::Local<v8::Value> value) {
-  mate::Dictionary options;
-  if (!mate::ConvertFromV8(isolate, value, &options))
-    return;
-
-  // When |session| is set to |null| we use a new request context for fetch job.
-  v8::Local<v8::Value> val;
-  if (options.Get("session", &val)) {
-    if (val->IsNull()) {
-      // We have to create the URLRequestContextGetter on UI thread.
-      custom_browser_context_ =
-          AtomBrowserContext::From(base::GenerateGUID(), true);
-      url_request_context_getter_ =
-          custom_browser_context_->GetRequestContext();
-    } else {
-      mate::Handle<api::Session> session;
-      if (mate::ConvertFromV8(isolate, val, &session) && !session.IsEmpty()) {
-        AtomBrowserContext* browser_context = session->browser_context();
-        url_request_context_getter_ = browser_context->GetRequestContext();
-      }
-    }
-  }
-}
-
-void URLRequestFetchJob::StartAsync(std::unique_ptr<base::Value> options) {
-  if (!options->is_dict()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_NOT_IMPLEMENTED));
-    return;
-  }
-
-  std::string url, method, referrer;
-  base::DictionaryValue* upload_data = nullptr;
-  base::DictionaryValue* dict =
-      static_cast<base::DictionaryValue*>(options.get());
-  dict->GetString("url", &url);
-  dict->GetString("method", &method);
-  dict->GetString("referrer", &referrer);
-  dict->GetDictionary("uploadData", &upload_data);
-
-  // Check if URL is valid.
-  GURL formated_url(url);
-  if (!formated_url.is_valid()) {
-    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
-                                           net::ERR_INVALID_URL));
-    return;
-  }
-
-  // Use |request|'s method if |method| is not specified.
-  net::URLFetcher::RequestType request_type;
-  if (method.empty())
-    request_type = GetRequestType(request()->method());
-  else
-    request_type = GetRequestType(method);
-
-  fetcher_ = net::URLFetcher::Create(formated_url, request_type, this);
-  fetcher_->SaveResponseWithWriter(base::WrapUnique(new ResponsePiper(this)));
-
-  // A request context getter is passed by the user.
-  if (url_request_context_getter_)
-    fetcher_->SetRequestContext(url_request_context_getter_.get());
-  else
-    fetcher_->SetRequestContext(request_context_getter());
-
-  // Use |request|'s referrer if |referrer| is not specified.
-  if (referrer.empty())
-    fetcher_->SetReferrer(request()->referrer());
-  else
-    fetcher_->SetReferrer(referrer);
-
-  // Set the data needed for POSTs.
-  if (upload_data && request_type == net::URLFetcher::POST) {
-    std::string content_type, data;
-    upload_data->GetString("contentType", &content_type);
-    upload_data->GetString("data", &data);
-    fetcher_->SetUploadData(content_type, data);
-  }
-
-  // Use |request|'s headers.
-  fetcher_->SetExtraRequestHeaders(
-      request()->extra_request_headers().ToString());
-
-  fetcher_->Start();
-}
-
-void URLRequestFetchJob::HeadersCompleted() {
-  response_info_.reset(new net::HttpResponseInfo);
-  response_info_->headers = fetcher_->GetResponseHeaders();
-  NotifyHeadersComplete();
-}
-
-int URLRequestFetchJob::DataAvailable(net::IOBuffer* buffer,
-                                      int num_bytes,
-                                      const net::CompletionCallback& callback) {
-  // When pending_buffer_ is empty, there's no ReadRawData() operation waiting
-  // for IO completion, we have to save the parameters until the request is
-  // ready to read data.
-  if (!pending_buffer_.get()) {
-    write_buffer_ = buffer;
-    write_num_bytes_ = num_bytes;
-    write_callback_ = callback;
-    return net::ERR_IO_PENDING;
-  }
-
-  // Write data to the pending buffer and clear them after the writing.
-  int bytes_read = BufferCopy(buffer, num_bytes, pending_buffer_.get(),
-                              pending_buffer_size_);
-  ClearPendingBuffer();
-  ReadRawDataComplete(bytes_read);
-  return bytes_read;
-}
-
-void URLRequestFetchJob::Kill() {
-  JsAsker<URLRequestJob>::Kill();
-  fetcher_.reset();
-}
-
-int URLRequestFetchJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
-  if (GetResponseCode() == 204) {
-    request()->set_received_response_content_length(prefilter_bytes_read());
-    return net::OK;
-  }
-
-  // When write_buffer_ is empty, there is no data valable yet, we have to save
-  // the dest buffer util DataAvailable.
-  if (!write_buffer_.get()) {
-    pending_buffer_ = dest;
-    pending_buffer_size_ = dest_size;
-    return net::ERR_IO_PENDING;
-  }
-
-  // Read from the write buffer and clear them after reading.
-  int bytes_read =
-      BufferCopy(write_buffer_.get(), write_num_bytes_, dest, dest_size);
-  net::CompletionCallback write_callback = write_callback_;
-  ClearWriteBuffer();
-  write_callback.Run(bytes_read);
-  return bytes_read;
-}
-
-bool URLRequestFetchJob::GetMimeType(std::string* mime_type) const {
-  if (!response_info_ || !response_info_->headers)
-    return false;
-
-  return response_info_->headers->GetMimeType(mime_type);
-}
-
-void URLRequestFetchJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  if (response_info_)
-    *info = *response_info_;
-}
-
-int URLRequestFetchJob::GetResponseCode() const {
-  if (!response_info_ || !response_info_->headers)
-    return -1;
-
-  return response_info_->headers->response_code();
-}
-
-void URLRequestFetchJob::OnURLFetchComplete(const net::URLFetcher* source) {
-  ClearPendingBuffer();
-  ClearWriteBuffer();
-
-  if (fetcher_->GetStatus().is_success()) {
-    if (!response_info_) {
-      // Since we notify header completion only after first write there will be
-      // no response object constructed for http respones with no content 204.
-      // We notify header completion here.
-      HeadersCompleted();
-      return;
-    }
-    if (request_->status().is_io_pending()) {
-      ReadRawDataComplete(0);
-    }
-  } else {
-    NotifyStartError(fetcher_->GetStatus());
-  }
-}
-
-int URLRequestFetchJob::BufferCopy(net::IOBuffer* source,
-                                   int num_bytes,
-                                   net::IOBuffer* target,
-                                   int target_size) {
-  int bytes_written = std::min(num_bytes, target_size);
-  memcpy(target->data(), source->data(), bytes_written);
-  return bytes_written;
-}
-
-void URLRequestFetchJob::ClearPendingBuffer() {
-  pending_buffer_ = nullptr;
-  pending_buffer_size_ = 0;
-}
-
-void URLRequestFetchJob::ClearWriteBuffer() {
-  write_buffer_ = nullptr;
-  write_num_bytes_ = 0;
-  write_callback_.Reset();
-}
-
-}  // namespace atom
removed in remote
  base   100644 69067fdc7fd317f0673a39252ee4743ba01d0d33 atom/browser/net/url_request_fetch_job.h
  our    100644 c38be1cbf86c72ac427b136cd5ebcb7fc0256d21 atom/browser/net/url_request_fetch_job.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "content/browser/streams/stream.h"
-#include "content/browser/streams/stream_read_observer.h"
-#include "net/url_request/url_fetcher_delegate.h"
-#include "net/url_request/url_request_context_getter.h"
-
-namespace atom {
-
-class AtomBrowserContext;
-
-class URLRequestFetchJob : public JsAsker<net::URLRequestJob>,
-                           public net::URLFetcherDelegate {
- public:
-  URLRequestFetchJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestFetchJob() override;
-
-  // Called by response writer.
-  void HeadersCompleted();
-  int DataAvailable(net::IOBuffer* buffer,
-                    int num_bytes,
-                    const net::CompletionCallback& callback);
-
- protected:
-  // JsAsker:
-  void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) override;
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // net::URLRequestJob:
-  void Kill() override;
-  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
-  bool GetMimeType(std::string* mime_type) const override;
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-  int GetResponseCode() const override;
-
-  // net::URLFetcherDelegate:
-  void OnURLFetchComplete(const net::URLFetcher* source) override;
-
- private:
-  int BufferCopy(net::IOBuffer* source,
-                 int num_bytes,
-                 net::IOBuffer* target,
-                 int target_size);
-  void ClearPendingBuffer();
-  void ClearWriteBuffer();
-
-  scoped_refptr<AtomBrowserContext> custom_browser_context_;
-  scoped_refptr<net::URLRequestContextGetter> url_request_context_getter_;
-  std::unique_ptr<net::URLFetcher> fetcher_;
-  std::unique_ptr<net::HttpResponseInfo> response_info_;
-
-  // Saved arguments passed to ReadRawData.
-  scoped_refptr<net::IOBuffer> pending_buffer_;
-  int pending_buffer_size_ = 0;
-
-  // Saved arguments passed to DataAvailable.
-  scoped_refptr<net::IOBuffer> write_buffer_;
-  int write_num_bytes_ = 0;
-  net::CompletionCallback write_callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestFetchJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
removed in remote
  base   100644 606781142da054d751767861b1c2ed0f932bcbc8 atom/browser/net/url_request_string_job.cc
  our    100644 31381ff118665f10a53e13fbe0044046738ca230 atom/browser/net/url_request_string_job.cc
@@ -1,60 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/net/url_request_string_job.h"
-
-#include <string>
-
-#include "atom/common/atom_constants.h"
-#include "net/base/net_errors.h"
-
-namespace atom {
-
-URLRequestStringJob::URLRequestStringJob(net::URLRequest* request,
-                                         net::NetworkDelegate* network_delegate)
-    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate) {}
-
-URLRequestStringJob::~URLRequestStringJob() = default;
-
-void URLRequestStringJob::StartAsync(std::unique_ptr<base::Value> options) {
-  if (options->is_dict()) {
-    base::DictionaryValue* dict =
-        static_cast<base::DictionaryValue*>(options.get());
-    dict->GetString("mimeType", &mime_type_);
-    dict->GetString("charset", &charset_);
-    dict->GetString("data", &data_);
-  } else if (options->is_string()) {
-    data_ = options->GetString();
-  }
-  net::URLRequestSimpleJob::Start();
-}
-
-void URLRequestStringJob::GetResponseInfo(net::HttpResponseInfo* info) {
-  std::string status("HTTP/1.1 200 OK");
-  auto* headers = new net::HttpResponseHeaders(status);
-
-  headers->AddHeader(kCORSHeader);
-
-  if (!mime_type_.empty()) {
-    std::string content_type_header(net::HttpRequestHeaders::kContentType);
-    content_type_header.append(": ");
-    content_type_header.append(mime_type_);
-    headers->AddHeader(content_type_header);
-  }
-
-  info->headers = headers;
-}
-
-int URLRequestStringJob::GetData(
-    std::string* mime_type,
-    std::string* charset,
-    std::string* data,
-    const net::CompletionCallback& callback) const {
-  *mime_type = mime_type_;
-  *charset = charset_;
-  *data = data_;
-  return net::OK;
-}
-
-}  // namespace atom
removed in remote
  base   100644 e40f0d93dab7900b592f62e62689ce394eda9894 atom/browser/net/url_request_string_job.h
  our    100644 841deb254d8feead5a0e61b92042d6e3d0629f1d atom/browser/net/url_request_string_job.h
@@ -1,42 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
-#define ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
-
-#include <string>
-
-#include "atom/browser/net/js_asker.h"
-#include "net/url_request/url_request_simple_job.h"
-
-namespace atom {
-
-class URLRequestStringJob : public JsAsker<net::URLRequestSimpleJob> {
- public:
-  URLRequestStringJob(net::URLRequest*, net::NetworkDelegate*);
-  ~URLRequestStringJob() override;
-
-  // JsAsker:
-  void StartAsync(std::unique_ptr<base::Value> options) override;
-
-  // URLRequestJob:
-  void GetResponseInfo(net::HttpResponseInfo* info) override;
-
-  // URLRequestSimpleJob:
-  int GetData(std::string* mime_type,
-              std::string* charset,
-              std::string* data,
-              const net::CompletionCallback& callback) const override;
-
- private:
-  std::string mime_type_;
-  std::string charset_;
-  std::string data_;
-
-  DISALLOW_COPY_AND_ASSIGN(URLRequestStringJob);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
removed in remote
  base   100644 50aa454fe75768c8357c4c4cbc89f240fb73fd01 atom/browser/node_debugger.cc
  our    100644 56e68e2b8b817aae2786775e3977977474420cc2 atom/browser/node_debugger.cc
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/node_debugger.h"
-
-#include "base/command_line.h"
-#include "base/strings/utf_string_conversions.h"
-#include "libplatform/libplatform.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-NodeDebugger::NodeDebugger(node::Environment* env) : env_(env) {}
-
-NodeDebugger::~NodeDebugger() {}
-
-void NodeDebugger::Start(node::MultiIsolatePlatform* platform) {
-  auto* inspector = env_->inspector_agent();
-  if (inspector == nullptr)
-    return;
-
-  node::DebugOptions options;
-  for (auto& arg : base::CommandLine::ForCurrentProcess()->argv()) {
-#if defined(OS_WIN)
-    options.ParseOption("Electron", base::UTF16ToUTF8(arg));
-#else
-    options.ParseOption("Electron", arg);
-#endif
-  }
-
-  // Set process._debugWaitConnect if --inspect-brk was specified to stop
-  // the debugger on the first line
-  if (options.wait_for_connect()) {
-    mate::Dictionary process(env_->isolate(), env_->process_object());
-    process.Set("_breakFirstLine", true);
-  }
-
-  inspector->Start(static_cast<node::NodePlatform*>(platform), nullptr,
-                   options);
-  DCHECK(env_->inspector_agent()->IsStarted());
-}
-
-}  // namespace atom
removed in remote
  base   100644 aedf7b2c031060baedb688cbc9e59099e67f1ca7 atom/browser/node_debugger.h
  our    100644 06b64584e9a056e7033ca21d4b87b4e9cc980bc5 atom/browser/node_debugger.h
@@ -1,33 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_NODE_DEBUGGER_H_
-#define ATOM_BROWSER_NODE_DEBUGGER_H_
-
-#include "base/macros.h"
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-// Add support for node's "--inspect" switch.
-class NodeDebugger {
- public:
-  explicit NodeDebugger(node::Environment* env);
-  ~NodeDebugger();
-
-  void Start(node::MultiIsolatePlatform* platform);
-
- private:
-  node::Environment* env_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeDebugger);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_NODE_DEBUGGER_H_
removed in remote
  base   100644 f7bd068e8f415fea18d66360dc1796fd74770956 atom/browser/resources/mac/Info.plist
  our    100644 9094f0f7335edf833d51f688851e6a105de60433 atom/browser/resources/mac/Info.plist
@@ -1,36 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-  <key>CFBundleDisplayName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundleExecutable</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundleIdentifier</key>
-  <string>${ATOM_BUNDLE_ID}</string>
-  <key>CFBundleInfoDictionaryVersion</key>
-  <string>6.0</string>
-  <key>CFBundleName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundlePackageType</key>
-  <string>APPL</string>
-  <key>CFBundleIconFile</key>
-  <string>electron.icns</string>
-  <key>CFBundleVersion</key>
-  <string>4.0.0</string>
-  <key>CFBundleShortVersionString</key>
-  <string>4.0.0</string>
-  <key>LSApplicationCategoryType</key>
-  <string>public.app-category.developer-tools</string>
-  <key>LSMinimumSystemVersion</key>
-  <string>10.9.0</string>
-  <key>NSMainNibFile</key>
-  <string>MainMenu</string>
-  <key>NSPrincipalClass</key>
-  <string>AtomApplication</string>
-  <key>NSSupportsAutomaticGraphicsSwitching</key>
-  <true/>
-  <key>NSHighResolutionCapable</key>
-  <true/>
-</dict>
-</plist>
removed in remote
  base   100644 aa09177554651fb38078881c4dd73f7d1d17ae7f atom/browser/resources/win/atom.ico
  our    100644 c080e4b377a6ce8aa090c8d60728f65e765718f6 atom/browser/resources/win/atom.ico
@@ -1,77 +0,0 @@
--</-|;.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�;.,�</-|M33
--;/,�:.,�:.,�:.,�:.,�:.,�UJC�pfY�F;6�:.,�:.,�:.,�:.,�:.,�ż�����>2/�:.,�:.,�:.,�:.,�:.,�=1/�i_T���z������ұ�������������å�����THB�XMF�laU�?30�:.,�:.,�:.,�:.,�:.,�;/,�M33
--;/,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,���~�����rg[�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�;/,�M33
--</-|;.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�:.,�;.,�</-|M33
--
--
-*�W,,(D�y
-�$���#=�J�z�z���AQE}�bC#�J��ٕ��3�S�+UJ�72��dd���H�W�����ic�U �f ��0�4�k[�ܔԾ�im�RR�2R��2�L��R+2=�g���e���M���M���u����}C+��gN~�g��l���;,9-���;\�R�G�%$�H�}_/9:�"'3]+]Ն��YWuL�p�hacy������gMR���(�c�j��yGÜ��i���"#k��DWR�A�d�r��g�\-Ԣr��N�7���D?����dR���;q�v����qi�	�&��5�����Q\�F�,��5|-��;���1iR��^E����t8A��7n4�L��L���PG,Sz���%�SC�7�ժ�ajS�{Ӵi�|�I���-�^ǌ�b����}�M���:�{��jY�J^M�f��\�z����Ju��-j6kvʺv݉[�~��r�	���fxow�	������ޙ))zjA�S+�͛]r��<��sRGŖ�b(P�U���Z3*4bO�O:�#<��@V8J�բ�M'�>�S�i�J���2-*�B�PTn;��׮:�>����^3P�Z��@���qn-[���9���㛦r�-<u�2M���-����Lسh���
-1]��6���;w:7#�N���U�U����W#'�2r�N~��m�iJOI-�@��027/j֯�@1n���Q��3����~�~(a�䄖�ف̭Գk�����2R��ʦ��Ӂ&������� ����:�Kw>ҝ����˯��2�UC�W�@+������=�$�M裼W�a�y� �~��T�G��?p�H�T��¬xP�:�~�f����C? -�6�5*�3�ܜ\��%Z�9�B��eik��n��J�&�-�H���#����S�K���N�}z�u���p-�S-7|9e"����0� 篸�fg+T#��u���k��
-룉p������M�xM{-�\�"�����oc1�!�񍛌e���l�uȵic�<4���C����+A����<��#S���{5����P�^=���(���n�l����^��R���m[�Y�|��70@ ��{�JK�{��������o�|�*ʧ�4�7��Z������߿�C*�^r�-�r .:��څ�T�-1g�����dCi]� -*�6V�s�*�ՐsmT��+�k;l`�����2���F����"TX��M�0[*OUNV��]��6�K�^��D8('3K.Ċ�� �ldhd�%��r�aiQ����]�W���������|���9O�c����O�U���UP��uQu�:~��EvU�Uf�z���iv��"��o��:6
-�FD��D�X�*��tcS�}�2������Q�ҡ)6a6i�"dfi)-�.��æ�bPl8`�އG�ȷoћW�� u1������9�|��Q��9*����(�-�4�+VBM;�Gm{�@n-�᯸|g��(�����2RSѵ��������	V�q�S�`�a���Vf�/�?���qc�Z�	�<�m�G�<��|	2��I�p���Т�W~��/�M�>��D0f`����(�k^g-���5��OoM4Y}��@c��]����L�]7BZ�@����[��3�޳�"`-��Y����[B:�1o���H�y��`����.���(��i�-�.bCލ�nދ�W_����7��ԗ&�z��o+��4�V~�_��ڤ�ǬFݿT�I@�S�ZX[���E��C._��/�� ��
-�a����ɭ[����:X����?������70�k[�{��p�ʵ��,Fϟ��j�v��(6*ec�\99�v�s��/���ldb��ML�!�(3��`<�~KMI\;y��I�xܚ{`C�$*�&j:�Hx��#=�.���x	%or�۠�%-�1�ķ�V�ͱg���hƚU�*N1�?�_�P�3��B�Jv��9҃兽SU䀏
-��82��cC|�-��u��S}1�B7��Q2�I�yʴ)9>^b���c��O�KP汏y�ծ�~;t��}���}6�H,�b���������`kDL!+#�,����f�"��Z-Z�ٳ��Dq�-�;����D�+�H�𜦣GΙE�o�4�<Φ��j(�C�C+�!VBWaaz��}ܿ�4���nNI�������h����I16D�AZR�]�^R�lY-�v���~����D��Z)�6��D�ؔ�߳ �\���x-�V�z�^'�L�f���ś/&�C^'����0�*�ڍ����s$�|���58%�/�l-���;��t�B{,)�fc�+:9c-����p��!�б-�J�U_��Xz�4�-1Q�� ������+;c�ګ�b��2R����#�/�Xy}y�Č,#�b��4��k�}J�~t�[�KG�˱�H���)8�drƶ�H!@`"���3�9X��#�\�8�X;�uޅ�qK��-G.�'K�	+7������/l���_����׾_o"����/ъ�SѺ��i�����C�(�j�s��%�1�$�-#i��r���F#�s�V�	HOL���M<�$�q����+�eZA%��{b�N��Mm�̶n��N0X����Ez�}D)Z�@x�1'�7%��X$�ovF�V(��1�f��}��Y�h/��L�:�Y��2���'R3-�j�$Es��X�Ǯ2?+5�>���ׯ�W�^��e�=�7 �	K�MO'˵��-����ɝ�ъ)?`<��$<���g`�U�;+[����6"��`ǣb	\�=�K��T�t�-���g-����<%E:�B!�1Ȋ��e�o��c�}��#�$�$�"�g~E���ѢQc���%��(&��VX3��-��R�,����D��$��ϐ�E��-Ἔ<1�D�1a����H�I'��h���Ƞ�!)�K�v��Go,�*�Y�D�9Rӆ���M��{�b�X"َAV��0�Y�]�+(���e�l��hj�s6x��(�(���G��B��0c15m�_�,�P\�n�b-o�� �i�(2$�TB����Cݱ�C���#Y��aa�,v%{#�L3-�޲e�dv<��۾��2�r������=���oG$��?Wг���ib�d�N�v����5�$�����CS�0�a	����[�߈o�4E&��X^�Ń���+�Ѽ]�x6)��u����}*�Bfz���CJ*�q��-uh00d7Y-*UR~gI����L�/��+oְ-��(]��f���'�,9�Շ�X��E�ZZ��=������&�.�U�I~��-z���&��+����F���l2�.ɗ���~
-b�������!���O#%��W���*���oXfRd���.+aQ��?��c�zr%<���11�X`�GS�h 0t�D��H�J��U�c�7{׬����k�#l�ц��Q��}L0H.������u��䈬ll�&g6JN�G!~�������d�\=�ƹ#f\�e�2	&K��s���t���=8�$����=w��N$�mފ�0K�}|���<��V�¤%����J�s|�X����&�=��L�!�����}N`�-�1�����Z�u�b#"͗��`�f�?��X��\�WN�@�!�7���1�\0�{����}�_Zv�-C �Yx645+r��|ȓ�g�)�H5�S-}HCgfi)�(]{�Z�e#jקvp�/�#������&M�k�# e����S��c ��������'�1-ua?�q�V������;x��R��#��]�:0�����T�b��S�נ�!r�������w�hI�x��_A��*�$�]�egd�<��w���P��=?�KA�>��ϓ��}̨��h���?�qEbsdvXRP�-C##T�~}	3-p���0�_%�'�e���K2he㹸Ǩ�B�zt�fu����Xm���J��eq�(���3�� ��PҒ�QXp�D�ǩVM��a��U��**��4S��vGZx���ή�T��-MŻ�?;��9�l� �Ce,��l4��&�f��P�AY�������`
-�����\5N/`��ѡ����'���r�4�Ũ��[�.ߴ�K�V�!�0�)��~r�@|Vj*�KR�A��'씓��O�/W���VN�Q2��Mc{�P�	�;�i�a�����j"��h���U���E�EE�5�wa(3���w2���:X�)L�L�RNelɧ�ıKWW�4��l	��ʖYV>���x�x���ZVV��M,-��Qy��o史8�M��q\AIqC��{.���~%���uǛ�?�X&���J��iiQ��W������Ų�ۖ.�Zb����`�E�N*�E,�!k�����Ayٹ�=�|�g������>��-ך`�p��r�&�Ƣ�X�W���C��)9�S�y4A�=<$�@�H��ͫW�����kϤXz�x/�vV��-S�YX��i�=�]\R��:�NZMMX�6wvo4
-i~�MM�4�؉;%�7�u�V����V��=�ׂ�l�ut�KO0ȩ��jL@�)�o]	l=���QQN�i���yA���dC����+*I�ɖ��{��-�K*]�}�$\k��ҍ�1tT���`;��|J��D��%�O�7�FAm�戗.+�z�u�Y���%�!Pŵn��)o��'�:(i��{����:��p�}-}����[1&�ʛ�v�D����g�.��Z˸�t�(z��
-����з��	A�H��������Mbxx���|���]�+
-�l���Vݻb/�������\���f�d��K*���m��iE������m����e3�F� �eA�:�z��cYڴuo�耖���h���y�.�����v}���#J�l,=�V�3⣍\��X�5��?�4�/i���-n	P��ӫ��};21��۾x.)șJ	���M�O��ð�n�JyH��1x�#���9�!-��k����$0�<+[;T��;jԦro��[Y�	18��=E`OF4|B��~���<jl�6M�\D�-&�T	��i�`�\}�@F-��E��D-�~��߹� 1n����-�᳖�{���3S����饎 `je]�Ҳ���0�4֑�*��-�i���~*=�J�#Rf%��R�%~�����~cS�q����z]5��Rg�Pf�-+����
-�6����PE�J��*"==��
-�\��a�|c�J���FF�IzF����L^��V47��ǂi�h��"@�P(�
\ No newline at end of file
removed in remote
  base   100644 84970c7172887f460750705de8fc06ca7eea4a5b atom/browser/resources/win/atom.manifest
  our    100644 7608ffb20f6c614383b6a5261cb76210366b9cc8 atom/browser/resources/win/atom.manifest
@@ -1,40 +0,0 @@
-<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
-<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
-
-  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
-    <application>
-      <!-- Windows 10 -->
-      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
-      <!-- Windows 8.1 -->
-      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
-      <!-- Windows 8 -->
-      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
-      <!-- Windows 7 -->
-      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
-      <!-- Windows Vista -->
-      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
-    </application>
-  </compatibility>
-
-  <dependency>
-    <dependentAssembly>
-      <assemblyIdentity type="Win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
-    </dependentAssembly>
-  </dependency>
-
-  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
-    <security>
-      <requestedPrivileges>
-        <requestedExecutionLevel level="asInvoker" />
-      </requestedPrivileges>
-    </security>
-  </trustInfo>
-
-  <asmv3:application xmlns:asmv3="urn:schemas-microsoft-com:asm.v3">
-    <asmv3:windowsSettings xmlns="http://schemas.microsoft.com/SMI/2005/WindowsSettings">
-      <dpiAware>true/pm</dpiAware>
-      <disableWindowFiltering xmlns="http://schemas.microsoft.com/SMI/2011/WindowsSettings">true</disableWindowFiltering>
-    </asmv3:windowsSettings>
-  </asmv3:application>
-
-</assembly>
removed in remote
  base   100644 15252346669461924df5952feca70adb45bc1ac7 atom/browser/resources/win/atom.rc
  our    100644 c0bd831e8bddf10180f75cd40694831e2e98622d atom/browser/resources/win/atom.rc
@@ -1,139 +0,0 @@
-// Microsoft Visual C++ generated resource script.
-//
-#include "ui\\resources\\grit\\ui_unscaled_resources.h"
-#include "resource.h"
-#include <winresrc.h>
-#ifdef IDC_STATIC
-#undef IDC_STATIC
-#endif
-#define IDC_STATIC (-1)
-
-#define APSTUDIO_READONLY_SYMBOLS
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 2 resource.
-//
-#include "windows.h"
-
-/////////////////////////////////////////////////////////////////////////////
-#undef APSTUDIO_READONLY_SYMBOLS
-
-/////////////////////////////////////////////////////////////////////////////
-// English (United States) resources
-
-#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
-LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
-
-#ifdef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// TEXTINCLUDE
-//
-
-1 TEXTINCLUDE
-BEGIN
-    "resource.h\0"
-END
-
-2 TEXTINCLUDE
-BEGIN
-    "#include ""windows.h""\r\n"
-    "\0"
-END
-
-3 TEXTINCLUDE
-BEGIN
-    "\r\n"
-    "\0"
-END
-
-#endif    // APSTUDIO_INVOKED
-
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Version
-//
-
-VS_VERSION_INFO VERSIONINFO
- FILEVERSION 4,0,0,20180821
- PRODUCTVERSION 4,0,0,20180821
- FILEFLAGSMASK 0x3fL
-#ifdef _DEBUG
- FILEFLAGS 0x1L
-#else
- FILEFLAGS 0x0L
-#endif
- FILEOS 0x40004L
- FILETYPE 0x1L
- FILESUBTYPE 0x0L
-BEGIN
-    BLOCK "StringFileInfo"
-    BEGIN
-        BLOCK "040904b0"
-        BEGIN
-            VALUE "CompanyName", "GitHub, Inc."
-            VALUE "FileDescription", "Electron"
-            VALUE "FileVersion", "4.0.0"
-            VALUE "InternalName", "electron.exe"
-            VALUE "LegalCopyright", "Copyright (C) 2015 GitHub, Inc. All rights reserved."
-            VALUE "OriginalFilename", "electron.exe"
-            VALUE "ProductName", "Electron"
-            VALUE "ProductVersion", "4.0.0"
-            VALUE "SquirrelAwareVersion", "1"
-        END
-    END
-    BLOCK "VarFileInfo"
-    BEGIN
-        VALUE "Translation", 0x409, 1200
-    END
-END
-
-#endif    // English (United States) resources
-/////////////////////////////////////////////////////////////////////////////
-
-
-
-#ifndef APSTUDIO_INVOKED
-/////////////////////////////////////////////////////////////////////////////
-//
-// Generated from the TEXTINCLUDE 3 resource.
-//
-
-
-/////////////////////////////////////////////////////////////////////////////
-#endif    // not APSTUDIO_INVOKED
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Icon
-//
-
-IDR_MAINFRAME           ICON                    "atom.ico"
-/////////////////////////////////////////////////////////////////////////////
-
-/////////////////////////////////////////////////////////////////////////////
-//
-// Cursors
-//
-IDC_ALIAS          CURSOR             "ui\\resources\\cursors\\aliasb.cur"
-IDC_CELL           CURSOR             "ui\\resources\\cursors\\cell.cur"
-IDC_COLRESIZE      CURSOR             "ui\\resources\\cursors\\col_resize.cur"
-IDC_COPYCUR        CURSOR             "ui\\resources\\cursors\\copy.cur"
-IDC_CURSOR_NONE    CURSOR             "ui\\resources\\cursors\\none.cur"
-IDC_HAND_GRAB      CURSOR             "ui\\resources\\cursors\\hand_grab.cur"
-IDC_HAND_GRABBING  CURSOR             "ui\\resources\\cursors\\hand_grabbing.cur"
-IDC_PAN_EAST       CURSOR             "ui\\resources\\cursors\\pan_east.cur"
-IDC_PAN_MIDDLE     CURSOR             "ui\\resources\\cursors\\pan_middle.cur"
-IDC_PAN_NORTH      CURSOR             "ui\\resources\\cursors\\pan_north.cur"
-IDC_PAN_NORTH_EAST CURSOR             "ui\\resources\\cursors\\pan_north_east.cur"
-IDC_PAN_NORTH_WEST CURSOR             "ui\\resources\\cursors\\pan_north_west.cur"
-IDC_PAN_SOUTH      CURSOR             "ui\\resources\\cursors\\pan_south.cur"
-IDC_PAN_SOUTH_EAST CURSOR             "ui\\resources\\cursors\\pan_south_east.cur"
-IDC_PAN_SOUTH_WEST CURSOR             "ui\\resources\\cursors\\pan_south_west.cur"
-IDC_PAN_WEST       CURSOR             "ui\\resources\\cursors\\pan_west.cur"
-IDC_ROWRESIZE      CURSOR             "ui\\resources\\cursors\\row_resize.cur"
-IDC_VERTICALTEXT   CURSOR             "ui\\resources\\cursors\\vertical_text.cur"
-IDC_ZOOMIN         CURSOR             "ui\\resources\\cursors\\zoom_in.cur"
-IDC_ZOOMOUT        CURSOR             "ui\\resources\\cursors\\zoom_out.cur"
-/////////////////////////////////////////////////////////////////////////////
removed in remote
  base   100644 d35e16d082e6dcaf15a9b58126f2770d5274bd70 atom/browser/resources/win/resource.h
  our    100644 275374d36194c609678082bdf7be3b93560ce37c atom/browser/resources/win/resource.h
@@ -1,15 +0,0 @@
-//{{NO_DEPENDENCIES}}
-// Microsoft Visual C++ generated include file.
-
-#define IDR_MAINFRAME 1
-
-// Next default values for new objects
-//
-#ifdef APSTUDIO_INVOKED
-#ifndef APSTUDIO_READONLY_SYMBOLS
-#define _APS_NEXT_RESOURCE_VALUE 101
-#define _APS_NEXT_COMMAND_VALUE 40001
-#define _APS_NEXT_CONTROL_VALUE 1001
-#define _APS_NEXT_SYMED_VALUE 101
-#endif
-#endif
removed in remote
  base   100644 f683c99c637ff2de6ea1ba86cc63365a5fec93b3 atom/browser/ui/accelerator_util.cc
  our    100644 63ea1489467c881b9f8e1686e3a73db74ea7c157 atom/browser/ui/accelerator_util.cc
@@ -1,101 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include <stdio.h>
-
-#include <string>
-#include <vector>
-
-#include "atom/common/keyboard_util.h"
-#include "base/stl_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-
-namespace accelerator_util {
-
-bool StringToAccelerator(const std::string& shortcut,
-                         ui::Accelerator* accelerator) {
-  if (!base::IsStringASCII(shortcut)) {
-    LOG(ERROR) << "The accelerator string can only contain ASCII characters";
-    return false;
-  }
-
-  std::vector<std::string> tokens = base::SplitString(
-      shortcut, "+", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-
-  // Now, parse it into an accelerator.
-  int modifiers = ui::EF_NONE;
-  ui::KeyboardCode key = ui::VKEY_UNKNOWN;
-  for (const auto& token : tokens) {
-    bool shifted = false;
-    ui::KeyboardCode code = atom::KeyboardCodeFromStr(token, &shifted);
-    if (shifted)
-      modifiers |= ui::EF_SHIFT_DOWN;
-    switch (code) {
-      // The token can be a modifier.
-      case ui::VKEY_SHIFT:
-        modifiers |= ui::EF_SHIFT_DOWN;
-        break;
-      case ui::VKEY_CONTROL:
-        modifiers |= ui::EF_CONTROL_DOWN;
-        break;
-      case ui::VKEY_MENU:
-        modifiers |= ui::EF_ALT_DOWN;
-        break;
-      case ui::VKEY_COMMAND:
-        modifiers |= ui::EF_COMMAND_DOWN;
-        break;
-      case ui::VKEY_ALTGR:
-        modifiers |= ui::EF_ALTGR_DOWN;
-        break;
-      // Or it is a normal key.
-      default:
-        key = code;
-    }
-  }
-
-  if (key == ui::VKEY_UNKNOWN) {
-    LOG(WARNING) << shortcut << " doesn't contain a valid key";
-    return false;
-  }
-
-  *accelerator = ui::Accelerator(key, modifiers);
-  SetPlatformAccelerator(accelerator);
-  return true;
-}
-
-void GenerateAcceleratorTable(AcceleratorTable* table,
-                              atom::AtomMenuModel* model) {
-  int count = model->GetItemCount();
-  for (int i = 0; i < count; ++i) {
-    atom::AtomMenuModel::ItemType type = model->GetTypeAt(i);
-    if (type == atom::AtomMenuModel::TYPE_SUBMENU) {
-      auto* submodel = model->GetSubmenuModelAt(i);
-      GenerateAcceleratorTable(table, submodel);
-    } else {
-      ui::Accelerator accelerator;
-      if (model->GetAcceleratorAtWithParams(i, true, &accelerator)) {
-        MenuItem item = {i, model};
-        (*table)[accelerator] = item;
-      }
-    }
-  }
-}
-
-bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
-                                    const ui::Accelerator& accelerator) {
-  if (base::ContainsKey(*table, accelerator)) {
-    const accelerator_util::MenuItem& item = (*table)[accelerator];
-    if (item.model->IsEnabledAt(item.position)) {
-      item.model->ActivatedAt(item.position);
-      return true;
-    }
-  }
-  return false;
-}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 584041980b4c61a504df37f651ef13938056848b atom/browser/ui/accelerator_util.h
  our    100644 c965e5da0b05a75c834e6b8df672e4220e196e18 atom/browser/ui/accelerator_util.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
-#define ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
-
-#include <map>
-#include <string>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/base/accelerators/accelerator.h"
-
-namespace accelerator_util {
-
-typedef struct {
-  int position;
-  atom::AtomMenuModel* model;
-} MenuItem;
-typedef std::map<ui::Accelerator, MenuItem> AcceleratorTable;
-
-// Parse a string as an accelerator.
-bool StringToAccelerator(const std::string& description,
-                         ui::Accelerator* accelerator);
-
-// Set platform accelerator for the Accelerator.
-void SetPlatformAccelerator(ui::Accelerator* accelerator);
-
-// Generate a table that contains memu model's accelerators and command ids.
-void GenerateAcceleratorTable(AcceleratorTable* table,
-                              atom::AtomMenuModel* model);
-
-// Trigger command from the accelerators table.
-bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
-                                    const ui::Accelerator& accelerator);
-
-}  // namespace accelerator_util
-
-#endif  // ATOM_BROWSER_UI_ACCELERATOR_UTIL_H_
removed in remote
  base   100644 be631b021249c6874d8192673dc0c269625b3989 atom/browser/ui/accelerator_util_mac.mm
  our    100644 51ac1c4db864ad85bb46624c222f15289f7bc0ac atom/browser/ui/accelerator_util_mac.mm
@@ -1,46 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include "ui/base/accelerators/accelerator.h"
-#import "ui/base/accelerators/platform_accelerator_cocoa.h"
-#import "ui/events/keycodes/keyboard_code_conversion_mac.h"
-
-namespace accelerator_util {
-
-void SetPlatformAccelerator(ui::Accelerator* accelerator) {
-  unichar character;
-  unichar characterIgnoringModifiers;
-
-  NSUInteger modifiers = (accelerator->IsCtrlDown() ? NSControlKeyMask : 0) |
-                         (accelerator->IsCmdDown() ? NSCommandKeyMask : 0) |
-                         (accelerator->IsAltDown() ? NSAlternateKeyMask : 0) |
-                         (accelerator->IsShiftDown() ? NSShiftKeyMask : 0);
-
-  ui::MacKeyCodeForWindowsKeyCode(accelerator->key_code(), modifiers,
-                                  &character, &characterIgnoringModifiers);
-
-  if (character != characterIgnoringModifiers) {
-    if (isdigit(characterIgnoringModifiers)) {
-      // The character is a number so lets not mutate it with the modifiers
-      character = characterIgnoringModifiers;
-    } else {
-      modifiers ^= NSShiftKeyMask;
-    }
-  }
-
-  if (character == NSDeleteFunctionKey) {
-    character = NSDeleteCharacter;
-  }
-
-  NSString* characters =
-      [[[NSString alloc] initWithCharacters:&character length:1] autorelease];
-
-  std::unique_ptr<ui::PlatformAccelerator> platform_accelerator(
-      new ui::PlatformAcceleratorCocoa(characters, modifiers));
-  accelerator->set_platform_accelerator(std::move(platform_accelerator));
-}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 f8d994f82ada2810b4a60ddc028694f404d02d65 atom/browser/ui/accelerator_util_views.cc
  our    100644 086e7084c48e2d29a1370f66b8599b1b9f148143 atom/browser/ui/accelerator_util_views.cc
@@ -1,13 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/accelerator_util.h"
-
-#include "ui/base/accelerators/accelerator.h"
-
-namespace accelerator_util {
-
-void SetPlatformAccelerator(ui::Accelerator* accelerator) {}
-
-}  // namespace accelerator_util
removed in remote
  base   100644 9add7a22715e9de81fa0dab952f5b89257dae9af atom/browser/ui/atom_menu_model.cc
  our    100644 83e23c42ed8984abaa6abc6f18fa76ace5a3f157 atom/browser/ui/atom_menu_model.cc
@@ -1,65 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/atom_menu_model.h"
-
-#include "base/stl_util.h"
-
-namespace atom {
-
-bool AtomMenuModel::Delegate::GetAcceleratorForCommandId(int command_id,
-    ui::Accelerator* accelerator) const {
-  return GetAcceleratorForCommandIdWithParams(
-      command_id, false, accelerator);
-}
-
-AtomMenuModel::AtomMenuModel(Delegate* delegate)
-    : ui::SimpleMenuModel(delegate), delegate_(delegate) {}
-
-AtomMenuModel::~AtomMenuModel() {}
-
-void AtomMenuModel::SetRole(int index, const base::string16& role) {
-  int command_id = GetCommandIdAt(index);
-  roles_[command_id] = role;
-}
-
-base::string16 AtomMenuModel::GetRoleAt(int index) {
-  int command_id = GetCommandIdAt(index);
-  if (base::ContainsKey(roles_, command_id))
-    return roles_[command_id];
-  else
-    return base::string16();
-}
-
-bool AtomMenuModel::GetAcceleratorAtWithParams(
-    int index,
-    bool use_default_accelerator,
-    ui::Accelerator* accelerator) const {
-  if (delegate_) {
-    return delegate_->GetAcceleratorForCommandIdWithParams(
-        GetCommandIdAt(index), use_default_accelerator, accelerator);
-  }
-  return false;
-}
-
-void AtomMenuModel::MenuWillClose() {
-  ui::SimpleMenuModel::MenuWillClose();
-  for (Observer& observer : observers_) {
-    observer.OnMenuWillClose();
-  }
-}
-
-void AtomMenuModel::MenuWillShow() {
-  ui::SimpleMenuModel::MenuWillShow();
-  for (Observer& observer : observers_) {
-    observer.OnMenuWillShow();
-  }
-}
-
-AtomMenuModel* AtomMenuModel::GetSubmenuModelAt(int index) {
-  return static_cast<AtomMenuModel*>(
-      ui::SimpleMenuModel::GetSubmenuModelAt(index));
-}
-
-}  // namespace atom
removed in remote
  base   100644 d091df9fb570fe5fbf3e95ea1232a6f4645ade08 atom/browser/ui/atom_menu_model.h
  our    100644 efdd8ec9d8834fea5d79e16899445abd80df05ca atom/browser/ui/atom_menu_model.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
-#define ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
-
-#include <map>
-
-#include "base/observer_list.h"
-#include "ui/base/models/simple_menu_model.h"
-
-namespace atom {
-
-class AtomMenuModel : public ui::SimpleMenuModel {
- public:
-  class Delegate : public ui::SimpleMenuModel::Delegate {
-   public:
-    ~Delegate() override {}
-
-    virtual bool GetAcceleratorForCommandIdWithParams(
-        int command_id,
-        bool use_default_accelerator,
-        ui::Accelerator* accelerator) const = 0;
-
-   private:
-    // ui::SimpleMenuModel::Delegate:
-    bool GetAcceleratorForCommandId(
-        int command_id,
-        ui::Accelerator* accelerator) const override;
-  };
-
-  class Observer {
-   public:
-    virtual ~Observer() {}
-
-    // Notifies the menu will open.
-    virtual void OnMenuWillShow() {}
-
-    // Notifies the menu has been closed.
-    virtual void OnMenuWillClose() {}
-  };
-
-  explicit AtomMenuModel(Delegate* delegate);
-  ~AtomMenuModel() override;
-
-  void AddObserver(Observer* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(Observer* obs) { observers_.RemoveObserver(obs); }
-
-  void SetRole(int index, const base::string16& role);
-  base::string16 GetRoleAt(int index);
-  bool GetAcceleratorAtWithParams(int index,
-                                  bool use_default_accelerator,
-                                  ui::Accelerator* accelerator) const;
-
-  // ui::SimpleMenuModel:
-  void MenuWillClose() override;
-  void MenuWillShow() override;
-
-  using SimpleMenuModel::GetSubmenuModelAt;
-  AtomMenuModel* GetSubmenuModelAt(int index);
-
- private:
-  Delegate* delegate_;  // weak ref.
-
-  std::map<int, base::string16> roles_;  // command id -> role
-  base::ObserverList<Observer> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomMenuModel);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_ATOM_MENU_MODEL_H_
removed in remote
  base   100644 f8c48aa5dcb5b9d0013f1de464ef163e48ccffe6 atom/browser/ui/cocoa/atom_menu_controller.h
  our    100644 83e9010f0daadc1d4097db3b702197f0f178967c atom/browser/ui/cocoa/atom_menu_controller.h
@@ -1,62 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
-#define ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include "base/callback.h"
-#include "base/mac/scoped_nsobject.h"
-#include "base/strings/string16.h"
-
-namespace atom {
-class AtomMenuModel;
-}
-
-// A controller for the cross-platform menu model. The menu that's created
-// has the tag and represented object set for each menu item. The object is a
-// NSValue holding a pointer to the model for that level of the menu (to
-// allow for hierarchical menus). The tag is the index into that model for
-// that particular item. It is important that the model outlives this object
-// as it only maintains weak references.
-@interface AtomMenuController : NSObject <NSMenuDelegate> {
- @protected
-  atom::AtomMenuModel* model_;  // weak
-  base::scoped_nsobject<NSMenu> menu_;
-  BOOL isMenuOpen_;
-  BOOL useDefaultAccelerator_;
-  base::Callback<void()> closeCallback;
-}
-
-@property(nonatomic, assign) atom::AtomMenuModel* model;
-
-// Builds a NSMenu from the pre-built model (must not be nil). Changes made
-// to the contents of the model after calling this will not be noticed.
-- (id)initWithModel:(atom::AtomMenuModel*)model useDefaultAccelerator:(BOOL)use;
-
-- (void)setCloseCallback:(const base::Callback<void()>&)callback;
-
-// Populate current NSMenu with |model|.
-- (void)populateWithModel:(atom::AtomMenuModel*)model;
-
-// Programmatically close the constructed menu.
-- (void)cancel;
-
-// Access to the constructed menu if the complex initializer was used. If the
-// default initializer was used, then this will create the menu on first call.
-- (NSMenu*)menu;
-
-// Whether the menu is currently open.
-- (BOOL)isMenuOpen;
-
-// NSMenuDelegate methods this class implements. Subclasses should call super
-// if extending the behavior.
-- (void)menuWillOpen:(NSMenu*)menu;
-- (void)menuDidClose:(NSMenu*)menu;
-
-@end
-
-#endif  // ATOM_BROWSER_UI_COCOA_ATOM_MENU_CONTROLLER_H_
removed in remote
  base   100644 24098914b7cbbb375f8d5c0657061bc99e4a5821 atom/browser/ui/cocoa/atom_menu_controller.mm
  our    100644 cecf30ce1c88e007957a65427648941765a6067e atom/browser/ui/cocoa/atom_menu_controller.mm
@@ -1,345 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#import "atom/browser/ui/cocoa/atom_menu_controller.h"
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/logging.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/base/accelerators/accelerator.h"
-#include "ui/base/accelerators/platform_accelerator_cocoa.h"
-#include "ui/base/l10n/l10n_util_mac.h"
-#include "ui/events/cocoa/cocoa_event_utils.h"
-#include "ui/gfx/image/image.h"
-
-using content::BrowserThread;
-
-namespace {
-
-struct Role {
-  SEL selector;
-  const char* role;
-};
-Role kRolesMap[] = {
-    {@selector(orderFrontStandardAboutPanel:), "about"},
-    {@selector(hide:), "hide"},
-    {@selector(hideOtherApplications:), "hideothers"},
-    {@selector(unhideAllApplications:), "unhide"},
-    {@selector(arrangeInFront:), "front"},
-    {@selector(undo:), "undo"},
-    {@selector(redo:), "redo"},
-    {@selector(cut:), "cut"},
-    {@selector(copy:), "copy"},
-    {@selector(paste:), "paste"},
-    {@selector(delete:), "delete"},
-    {@selector(pasteAndMatchStyle:), "pasteandmatchstyle"},
-    {@selector(selectAll:), "selectall"},
-    {@selector(startSpeaking:), "startspeaking"},
-    {@selector(stopSpeaking:), "stopspeaking"},
-    {@selector(performMiniaturize:), "minimize"},
-    {@selector(performClose:), "close"},
-    {@selector(performZoom:), "zoom"},
-    {@selector(terminate:), "quit"},
-    // ↓ is intentionally not `toggleFullScreen`. The macOS full screen menu
-    // item behaves weird. If we use `toggleFullScreen`, then the menu item will
-    // use the default label, and not take the one provided.
-    {@selector(toggleFullScreenMode:), "togglefullscreen"},
-    {@selector(toggleTabBar:), "toggletabbar"},
-    {@selector(selectNextTab:), "selectnexttab"},
-    {@selector(selectPreviousTab:), "selectprevioustab"},
-    {@selector(mergeAllWindows:), "mergeallwindows"},
-    {@selector(moveTabToNewWindow:), "movetabtonewwindow"},
-    {@selector(clearRecentDocuments:), "clearrecentdocuments"},
-};
-
-}  // namespace
-
-// Menu item is located for ease of removing it from the parent owner
-static base::scoped_nsobject<NSMenuItem> recentDocumentsMenuItem_;
-
-// Submenu retained to be swapped back to |recentDocumentsMenuItem_|
-static base::scoped_nsobject<NSMenu> recentDocumentsMenuSwap_;
-
-@implementation AtomMenuController
-
-@synthesize model = model_;
-
-- (id)initWithModel:(atom::AtomMenuModel*)model
-    useDefaultAccelerator:(BOOL)use {
-  if ((self = [super init])) {
-    model_ = model;
-    isMenuOpen_ = NO;
-    useDefaultAccelerator_ = use;
-    [self menu];
-  }
-  return self;
-}
-
-- (void)dealloc {
-  [menu_ setDelegate:nil];
-
-  // Close the menu if it is still open. This could happen if a tab gets closed
-  // while its context menu is still open.
-  [self cancel];
-
-  model_ = nil;
-
-  [super dealloc];
-}
-
-- (void)setCloseCallback:(const base::Callback<void()>&)callback {
-  closeCallback = callback;
-}
-
-- (void)populateWithModel:(atom::AtomMenuModel*)model {
-  if (!menu_)
-    return;
-
-  if (!recentDocumentsMenuItem_) {
-    // Locate & retain the recent documents menu item
-    recentDocumentsMenuItem_.reset(
-        [[[[[NSApp mainMenu] itemWithTitle:@"Electron"] submenu]
-            itemWithTitle:@"Open Recent"] retain]);
-  }
-
-  model_ = model;
-  [menu_ removeAllItems];
-
-  const int count = model->GetItemCount();
-  for (int index = 0; index < count; index++) {
-    if (model->GetTypeAt(index) == atom::AtomMenuModel::TYPE_SEPARATOR)
-      [self addSeparatorToMenu:menu_ atIndex:index];
-    else
-      [self addItemToMenu:menu_ atIndex:index fromModel:model];
-  }
-}
-
-- (void)cancel {
-  if (isMenuOpen_) {
-    [menu_ cancelTracking];
-    isMenuOpen_ = NO;
-    model_->MenuWillClose();
-    if (!closeCallback.is_null()) {
-      BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, closeCallback);
-    }
-  }
-}
-
-// Creates a NSMenu from the given model. If the model has submenus, this can
-// be invoked recursively.
-- (NSMenu*)menuFromModel:(atom::AtomMenuModel*)model {
-  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
-
-  const int count = model->GetItemCount();
-  for (int index = 0; index < count; index++) {
-    if (model->GetTypeAt(index) == atom::AtomMenuModel::TYPE_SEPARATOR)
-      [self addSeparatorToMenu:menu atIndex:index];
-    else
-      [self addItemToMenu:menu atIndex:index fromModel:model];
-  }
-
-  return menu;
-}
-
-// Adds a separator item at the given index. As the separator doesn't need
-// anything from the model, this method doesn't need the model index as the
-// other method below does.
-- (void)addSeparatorToMenu:(NSMenu*)menu atIndex:(int)index {
-  NSMenuItem* separator = [NSMenuItem separatorItem];
-  [menu insertItem:separator atIndex:index];
-}
-
-// Empties the source menu items to the destination.
-- (void)moveMenuItems:(NSMenu*)source to:(NSMenu*)destination {
-  const long count = [source numberOfItems];
-  for (long index = 0; index < count; index++) {
-    NSMenuItem* removedItem = [[[source itemAtIndex:0] retain] autorelease];
-    [source removeItemAtIndex:0];
-    [destination addItem:removedItem];
-  }
-}
-
-// Replaces the item's submenu instance with the singleton recent documents
-// menu. Previously replaced menu items will be recovered.
-- (void)replaceSubmenuShowingRecentDocuments:(NSMenuItem*)item {
-  NSMenu* recentDocumentsMenu =
-      [[[recentDocumentsMenuItem_ submenu] retain] autorelease];
-
-  // Remove menu items in recent documents back to swap menu
-  [self moveMenuItems:recentDocumentsMenu to:recentDocumentsMenuSwap_];
-  // Swap back the submenu
-  [recentDocumentsMenuItem_ setSubmenu:recentDocumentsMenuSwap_];
-
-  // Retain the item's submenu for a future recovery
-  recentDocumentsMenuSwap_.reset([[item submenu] retain]);
-
-  // Repopulate with items from the submenu to be replaced
-  [self moveMenuItems:recentDocumentsMenuSwap_ to:recentDocumentsMenu];
-  // Update the submenu's title
-  [recentDocumentsMenu setTitle:[recentDocumentsMenuSwap_ title]];
-  // Replace submenu
-  [item setSubmenu:recentDocumentsMenu];
-
-  // Remember the new menu item that carries the recent documents menu
-  recentDocumentsMenuItem_.reset([item retain]);
-}
-
-// Adds an item or a hierarchical menu to the item at the |index|,
-// associated with the entry in the model identified by |modelIndex|.
-- (void)addItemToMenu:(NSMenu*)menu
-              atIndex:(NSInteger)index
-            fromModel:(atom::AtomMenuModel*)model {
-  base::string16 label16 = model->GetLabelAt(index);
-  NSString* label = l10n_util::FixUpWindowsStyleLabel(label16);
-
-  base::scoped_nsobject<NSMenuItem> item([[NSMenuItem alloc]
-      initWithTitle:label
-             action:@selector(itemSelected:)
-      keyEquivalent:@""]);
-
-  // If the menu item has an icon, set it.
-  gfx::Image icon;
-  if (model->GetIconAt(index, &icon) && !icon.IsEmpty())
-    [item setImage:icon.ToNSImage()];
-
-  base::string16 role = model->GetRoleAt(index);
-  atom::AtomMenuModel::ItemType type = model->GetTypeAt(index);
-  if (type == atom::AtomMenuModel::TYPE_SUBMENU) {
-    // Recursively build a submenu from the sub-model at this index.
-    [item setTarget:nil];
-    [item setAction:nil];
-    atom::AtomMenuModel* submenuModel =
-        static_cast<atom::AtomMenuModel*>(model->GetSubmenuModelAt(index));
-    NSMenu* submenu = [self menuFromModel:submenuModel];
-    [submenu setTitle:[item title]];
-    [item setSubmenu:submenu];
-
-    // Set submenu's role.
-    if (role == base::ASCIIToUTF16("window") && [submenu numberOfItems])
-      [NSApp setWindowsMenu:submenu];
-    else if (role == base::ASCIIToUTF16("help"))
-      [NSApp setHelpMenu:submenu];
-    else if (role == base::ASCIIToUTF16("services"))
-      [NSApp setServicesMenu:submenu];
-    else if (role == base::ASCIIToUTF16("recentdocuments"))
-      [self replaceSubmenuShowingRecentDocuments:item];
-  } else {
-    // The MenuModel works on indexes so we can't just set the command id as the
-    // tag like we do in other menus. Also set the represented object to be
-    // the model so hierarchical menus check the correct index in the correct
-    // model. Setting the target to |self| allows this class to participate
-    // in validation of the menu items.
-    [item setTag:index];
-    NSValue* modelObject = [NSValue valueWithPointer:model];
-    [item setRepresentedObject:modelObject];  // Retains |modelObject|.
-    ui::Accelerator accelerator;
-    if (model->GetAcceleratorAtWithParams(index, useDefaultAccelerator_,
-                                          &accelerator)) {
-      const ui::PlatformAcceleratorCocoa* platformAccelerator =
-          static_cast<const ui::PlatformAcceleratorCocoa*>(
-              accelerator.platform_accelerator());
-      if (platformAccelerator) {
-        [item setKeyEquivalent:platformAccelerator->characters()];
-        [item
-            setKeyEquivalentModifierMask:platformAccelerator->modifier_mask()];
-      }
-    }
-
-    // Set menu item's role.
-    [item setTarget:self];
-    if (!role.empty()) {
-      for (const Role& pair : kRolesMap) {
-        if (role == base::ASCIIToUTF16(pair.role)) {
-          [item setTarget:nil];
-          [item setAction:pair.selector];
-          break;
-        }
-      }
-    }
-  }
-  [menu insertItem:item atIndex:index];
-}
-
-// Called before the menu is to be displayed to update the state (enabled,
-// radio, etc) of each item in the menu. Also will update the title if
-// the item is marked as "dynamic".
-- (BOOL)validateUserInterfaceItem:(id<NSValidatedUserInterfaceItem>)item {
-  SEL action = [item action];
-  if (action != @selector(itemSelected:))
-    return NO;
-
-  NSInteger modelIndex = [item tag];
-  atom::AtomMenuModel* model = static_cast<atom::AtomMenuModel*>(
-      [[(id)item representedObject] pointerValue]);
-  DCHECK(model);
-  if (model) {
-    BOOL checked = model->IsItemCheckedAt(modelIndex);
-    DCHECK([(id)item isKindOfClass:[NSMenuItem class]]);
-    [(id)item setState:(checked ? NSOnState : NSOffState)];
-    [(id)item setHidden:(!model->IsVisibleAt(modelIndex))];
-    if (model->IsItemDynamicAt(modelIndex)) {
-      // Update the label and the icon.
-      NSString* label =
-          l10n_util::FixUpWindowsStyleLabel(model->GetLabelAt(modelIndex));
-      [(id)item setTitle:label];
-
-      gfx::Image icon;
-      model->GetIconAt(modelIndex, &icon);
-      [(id)item setImage:icon.IsEmpty() ? nil : icon.ToNSImage()];
-    }
-    return model->IsEnabledAt(modelIndex);
-  }
-  return NO;
-}
-
-// Called when the user chooses a particular menu item. |sender| is the menu
-// item chosen.
-- (void)itemSelected:(id)sender {
-  NSInteger modelIndex = [sender tag];
-  atom::AtomMenuModel* model = static_cast<atom::AtomMenuModel*>(
-      [[sender representedObject] pointerValue]);
-  DCHECK(model);
-  if (model) {
-    NSEvent* event = [NSApp currentEvent];
-    model->ActivatedAt(modelIndex,
-                       ui::EventFlagsFromModifiers([event modifierFlags]));
-  }
-}
-
-- (NSMenu*)menu {
-  if (menu_)
-    return menu_.get();
-
-  menu_.reset([[NSMenu alloc] initWithTitle:@""]);
-  [menu_ setDelegate:self];
-  if (model_)
-    [self populateWithModel:model_];
-  return menu_.get();
-}
-
-- (BOOL)isMenuOpen {
-  return isMenuOpen_;
-}
-
-- (void)menuWillOpen:(NSMenu*)menu {
-  isMenuOpen_ = YES;
-  model_->MenuWillShow();
-}
-
-- (void)menuDidClose:(NSMenu*)menu {
-  if (isMenuOpen_) {
-    isMenuOpen_ = NO;
-    model_->MenuWillClose();
-    // Post async task so that itemSelected runs before the close callback
-    // deletes the controller from the map which deallocates it
-    if (!closeCallback.is_null()) {
-      BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, closeCallback);
-    }
-  }
-}
-
-@end
removed in remote
  base   100644 51d7f5ee9d32120229dd869013f240d15e82e180 atom/browser/ui/file_dialog.h
  our    100644 becc1806610ae54c005b3e8aef17a9ef19d730bf atom/browser/ui/file_dialog.h
@@ -1,86 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_FILE_DIALOG_H_
-#define ATOM_BROWSER_UI_FILE_DIALOG_H_
-
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/callback_forward.h"
-#include "base/files/file_path.h"
-
-namespace atom {
-class NativeWindow;
-}
-
-namespace file_dialog {
-
-// <description, extensions>
-typedef std::pair<std::string, std::vector<std::string>> Filter;
-typedef std::vector<Filter> Filters;
-
-enum FileDialogProperty {
-  FILE_DIALOG_OPEN_FILE = 1 << 0,
-  FILE_DIALOG_OPEN_DIRECTORY = 1 << 1,
-  FILE_DIALOG_MULTI_SELECTIONS = 1 << 2,
-  FILE_DIALOG_CREATE_DIRECTORY = 1 << 3,
-  FILE_DIALOG_SHOW_HIDDEN_FILES = 1 << 4,
-  FILE_DIALOG_PROMPT_TO_CREATE = 1 << 5,
-  FILE_DIALOG_NO_RESOLVE_ALIASES = 1 << 6,
-  FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY = 1 << 7,
-};
-
-#if defined(MAS_BUILD)
-typedef base::Callback<void(bool result,
-                            const std::vector<base::FilePath>& paths,
-                            const std::vector<std::string>& bookmarkData)>
-    OpenDialogCallback;
-
-typedef base::Callback<void(bool result,
-                            const base::FilePath& path,
-                            const std::string& bookmarkData)>
-    SaveDialogCallback;
-#else
-typedef base::Callback<void(bool result,
-                            const std::vector<base::FilePath>& paths)>
-    OpenDialogCallback;
-
-typedef base::Callback<void(bool result, const base::FilePath& path)>
-    SaveDialogCallback;
-#endif
-
-struct DialogSettings {
-  atom::NativeWindow* parent_window = nullptr;
-  std::string title;
-  std::string message;
-  std::string button_label;
-  std::string name_field_label;
-  base::FilePath default_path;
-  Filters filters;
-  int properties = 0;
-  bool shows_tag_field = true;
-  bool force_detached = false;
-  bool security_scoped_bookmarks = false;
-
-  DialogSettings();
-  DialogSettings(const DialogSettings&);
-  ~DialogSettings();
-};
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths);
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback);
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path);
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback);
-
-}  // namespace file_dialog
-
-#endif  // ATOM_BROWSER_UI_FILE_DIALOG_H_
removed in remote
  base   100644 6d19a2eda464ffd14ecf38b685ef3d30e778c737 atom/browser/ui/file_dialog_gtk.cc
  our    100644 dad4fabde9f709e65a04bc4299233bac891f38ff atom/browser/ui/file_dialog_gtk.cc
@@ -1,278 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#include <glib/gi18n.h>  // _() macro
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_util.h"
-#include "chrome/browser/ui/libgtkui/gtk_signal.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-// Makes sure that .jpg also shows .JPG.
-gboolean FileFilterCaseInsensitive(const GtkFileFilterInfo* file_info,
-                                   std::string* file_extension) {
-  // Makes .* file extension matches all file types.
-  if (*file_extension == ".*")
-    return true;
-  return base::EndsWith(file_info->filename, *file_extension,
-                        base::CompareCase::INSENSITIVE_ASCII);
-}
-
-// Deletes |data| when gtk_file_filter_add_custom() is done with it.
-void OnFileFilterDataDestroyed(std::string* file_extension) {
-  delete file_extension;
-}
-
-class FileChooserDialog {
- public:
-  FileChooserDialog(GtkFileChooserAction action, const DialogSettings& settings)
-      : parent_(static_cast<atom::NativeWindowViews*>(settings.parent_window)),
-        filters_(settings.filters) {
-    const char* confirm_text = _("_OK");
-
-    if (!settings.button_label.empty())
-      confirm_text = settings.button_label.c_str();
-    else if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
-      confirm_text = _("_Save");
-    else if (action == GTK_FILE_CHOOSER_ACTION_OPEN)
-      confirm_text = _("_Open");
-
-    dialog_ = gtk_file_chooser_dialog_new(
-        settings.title.c_str(), NULL, action, _("_Cancel"), GTK_RESPONSE_CANCEL,
-        confirm_text, GTK_RESPONSE_ACCEPT, NULL);
-    if (parent_) {
-      parent_->SetEnabled(false);
-      libgtkui::SetGtkTransientForAura(dialog_, parent_->GetNativeWindow());
-      gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
-    }
-
-    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
-      gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(dialog_),
-                                                     TRUE);
-    if (action != GTK_FILE_CHOOSER_ACTION_OPEN)
-      gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(dialog_), TRUE);
-
-    if (!settings.default_path.empty()) {
-      if (base::DirectoryExists(settings.default_path)) {
-        gtk_file_chooser_set_current_folder(
-            GTK_FILE_CHOOSER(dialog_), settings.default_path.value().c_str());
-      } else {
-        if (settings.default_path.IsAbsolute()) {
-          gtk_file_chooser_set_current_folder(
-              GTK_FILE_CHOOSER(dialog_),
-              settings.default_path.DirName().value().c_str());
-        }
-
-        gtk_file_chooser_set_current_name(
-            GTK_FILE_CHOOSER(dialog_),
-            settings.default_path.BaseName().value().c_str());
-      }
-    }
-
-    if (!settings.filters.empty())
-      AddFilters(settings.filters);
-  }
-
-  ~FileChooserDialog() {
-    gtk_widget_destroy(dialog_);
-    if (parent_)
-      parent_->SetEnabled(true);
-  }
-
-  void SetupProperties(int properties) {
-    if (properties & FILE_DIALOG_MULTI_SELECTIONS)
-      gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(dialog()), TRUE);
-    if (properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-      g_object_set(dialog(), "show-hidden", TRUE, NULL);
-  }
-
-  void RunAsynchronous() {
-    g_signal_connect(dialog_, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), NULL);
-    g_signal_connect(dialog_, "response", G_CALLBACK(OnFileDialogResponseThunk),
-                     this);
-    gtk_widget_show_all(dialog_);
-
-    // We need to call gtk_window_present after making the widgets visible to
-    // make sure window gets correctly raised and gets focus.
-    int time = ui::X11EventSource::GetInstance()->GetTimestamp();
-    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
-  }
-
-  void RunSaveAsynchronous(const SaveDialogCallback& callback) {
-    save_callback_ = callback;
-    RunAsynchronous();
-  }
-
-  void RunOpenAsynchronous(const OpenDialogCallback& callback) {
-    open_callback_ = callback;
-    RunAsynchronous();
-  }
-
-  base::FilePath GetFileName() const {
-    gchar* filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog_));
-    base::FilePath path = AddExtensionForFilename(filename);
-    g_free(filename);
-    return path;
-  }
-
-  std::vector<base::FilePath> GetFileNames() const {
-    std::vector<base::FilePath> paths;
-    GSList* filenames =
-        gtk_file_chooser_get_filenames(GTK_FILE_CHOOSER(dialog_));
-    for (GSList* iter = filenames; iter != NULL; iter = g_slist_next(iter)) {
-      base::FilePath path =
-          AddExtensionForFilename(static_cast<char*>(iter->data));
-      g_free(iter->data);
-      paths.push_back(path);
-    }
-    g_slist_free(filenames);
-    return paths;
-  }
-
-  CHROMEGTK_CALLBACK_1(FileChooserDialog, void, OnFileDialogResponse, int);
-
-  GtkWidget* dialog() const { return dialog_; }
-
- private:
-  void AddFilters(const Filters& filters);
-  base::FilePath AddExtensionForFilename(const gchar* filename) const;
-
-  atom::NativeWindowViews* parent_;
-  atom::UnresponsiveSuppressor unresponsive_suppressor_;
-
-  GtkWidget* dialog_;
-
-  Filters filters_;
-  SaveDialogCallback save_callback_;
-  OpenDialogCallback open_callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(FileChooserDialog);
-};
-
-void FileChooserDialog::OnFileDialogResponse(GtkWidget* widget, int response) {
-  gtk_widget_hide(dialog_);
-
-  if (!save_callback_.is_null()) {
-    if (response == GTK_RESPONSE_ACCEPT)
-      save_callback_.Run(true, GetFileName());
-    else
-      save_callback_.Run(false, base::FilePath());
-  } else if (!open_callback_.is_null()) {
-    if (response == GTK_RESPONSE_ACCEPT)
-      open_callback_.Run(true, GetFileNames());
-    else
-      open_callback_.Run(false, std::vector<base::FilePath>());
-  }
-  delete this;
-}
-
-void FileChooserDialog::AddFilters(const Filters& filters) {
-  for (size_t i = 0; i < filters.size(); ++i) {
-    const Filter& filter = filters[i];
-    GtkFileFilter* gtk_filter = gtk_file_filter_new();
-
-    for (size_t j = 0; j < filter.second.size(); ++j) {
-      auto file_extension =
-          std::make_unique<std::string>("." + filter.second[j]);
-      gtk_file_filter_add_custom(
-          gtk_filter, GTK_FILE_FILTER_FILENAME,
-          reinterpret_cast<GtkFileFilterFunc>(FileFilterCaseInsensitive),
-          file_extension.release(),
-          reinterpret_cast<GDestroyNotify>(OnFileFilterDataDestroyed));
-    }
-
-    gtk_file_filter_set_name(gtk_filter, filter.first.c_str());
-    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog_), gtk_filter);
-  }
-}
-
-base::FilePath FileChooserDialog::AddExtensionForFilename(
-    const gchar* filename) const {
-  base::FilePath path(filename);
-  GtkFileFilter* selected_filter =
-      gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(dialog_));
-  if (!selected_filter)
-    return path;
-
-  GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog_));
-  size_t i = g_slist_index(filters, selected_filter);
-  g_slist_free(filters);
-  if (i >= filters_.size())
-    return path;
-
-  const auto& extensions = filters_[i].second;
-  for (const auto& extension : extensions) {
-    if (extension == "*" ||
-        base::EndsWith(path.value(), "." + extension,
-                       base::CompareCase::INSENSITIVE_ASCII))
-      return path;
-  }
-
-  return path.ReplaceExtension(extensions[0]);
-}
-
-}  // namespace
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
-  FileChooserDialog open_dialog(action, settings);
-  open_dialog.SetupProperties(settings.properties);
-
-  gtk_widget_show_all(open_dialog.dialog());
-  int response = gtk_dialog_run(GTK_DIALOG(open_dialog.dialog()));
-  if (response == GTK_RESPONSE_ACCEPT) {
-    *paths = open_dialog.GetFileNames();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback) {
-  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
-  FileChooserDialog* open_dialog = new FileChooserDialog(action, settings);
-  open_dialog->SetupProperties(settings.properties);
-  open_dialog->RunOpenAsynchronous(callback);
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  FileChooserDialog save_dialog(GTK_FILE_CHOOSER_ACTION_SAVE, settings);
-  gtk_widget_show_all(save_dialog.dialog());
-  int response = gtk_dialog_run(GTK_DIALOG(save_dialog.dialog()));
-  if (response == GTK_RESPONSE_ACCEPT) {
-    *path = save_dialog.GetFileName();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback) {
-  FileChooserDialog* save_dialog =
-      new FileChooserDialog(GTK_FILE_CHOOSER_ACTION_SAVE, settings);
-  save_dialog->RunSaveAsynchronous(callback);
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 49662c69b3b81af166ca96808eb675fbb6025201 atom/browser/ui/file_dialog_mac.mm
  our    100644 18b18a8b240cda5512ae49e0afde5c749bdf75c0 atom/browser/ui/file_dialog_mac.mm
@@ -1,399 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#import <Cocoa/Cocoa.h>
-#import <CoreServices/CoreServices.h>
-
-#include "atom/browser/native_window.h"
-#include "base/files/file_util.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_util.h"
-#include "base/mac/scoped_cftyperef.h"
-#include "base/strings/sys_string_conversions.h"
-
-@interface PopUpButtonHandler : NSObject
-
-@property(nonatomic, assign) NSSavePanel* savePanel;
-@property(nonatomic, strong) NSArray* fileTypesList;
-
-- (instancetype)initWithPanel:(NSSavePanel*)panel
-                 andTypesList:(NSArray*)typesList;
-- (void)selectFormat:(id)sender;
-
-@end
-
-@implementation PopUpButtonHandler
-
-@synthesize savePanel;
-@synthesize fileTypesList;
-
-- (instancetype)initWithPanel:(NSSavePanel*)panel
-                 andTypesList:(NSArray*)typesList {
-  self = [super init];
-  if (self) {
-    [self setSavePanel:panel];
-    [self setFileTypesList:typesList];
-  }
-  return self;
-}
-
-- (void)selectFormat:(id)sender {
-  NSPopUpButton* button = (NSPopUpButton*)sender;
-  NSInteger selectedItemIndex = [button indexOfSelectedItem];
-  NSArray* list = [self fileTypesList];
-  NSArray* fileTypes = [list objectAtIndex:selectedItemIndex];
-
-  // If we meet a '*' file extension, we allow all the file types and no
-  // need to set the specified file types.
-  if ([fileTypes count] == 0 || [fileTypes containsObject:@"*"])
-    [[self savePanel] setAllowedFileTypes:nil];
-  else
-    [[self savePanel] setAllowedFileTypes:fileTypes];
-}
-
-@end
-
-// Manages the PopUpButtonHandler.
-@interface AtomAccessoryView : NSView
-@end
-
-@implementation AtomAccessoryView
-
-- (void)dealloc {
-  auto* popupButton =
-      static_cast<NSPopUpButton*>([[self subviews] objectAtIndex:1]);
-  [[popupButton target] release];
-  [super dealloc];
-}
-
-@end
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-void SetAllowedFileTypes(NSSavePanel* dialog, const Filters& filters) {
-  NSMutableArray* file_types_list = [NSMutableArray array];
-  NSMutableArray* filter_names = [NSMutableArray array];
-
-  // Create array to keep file types and their name.
-  for (const Filter& filter : filters) {
-    NSMutableSet* file_type_set = [NSMutableSet set];
-    [filter_names addObject:@(filter.first.c_str())];
-    for (const std::string& ext : filter.second) {
-      [file_type_set addObject:@(ext.c_str())];
-    }
-    [file_types_list addObject:[file_type_set allObjects]];
-  }
-
-  // Passing empty array to setAllowedFileTypes will cause exception.
-  NSArray* file_types = nil;
-  NSUInteger count = [file_types_list count];
-  if (count > 0) {
-    file_types = [[file_types_list objectAtIndex:0] allObjects];
-    // If we meet a '*' file extension, we allow all the file types and no
-    // need to set the specified file types.
-    if ([file_types count] == 0 || [file_types containsObject:@"*"])
-      file_types = nil;
-  }
-  [dialog setAllowedFileTypes:file_types];
-
-  if (count <= 1)
-    return;  // don't add file format picker
-
-  // Add file format picker.
-  AtomAccessoryView* accessoryView =
-      [[AtomAccessoryView alloc] initWithFrame:NSMakeRect(0.0, 0.0, 200, 32.0)];
-  NSTextField* label =
-      [[NSTextField alloc] initWithFrame:NSMakeRect(0, 0, 60, 22)];
-
-  [label setEditable:NO];
-  [label setStringValue:@"Format:"];
-  [label setBordered:NO];
-  [label setBezeled:NO];
-  [label setDrawsBackground:NO];
-
-  NSPopUpButton* popupButton =
-      [[NSPopUpButton alloc] initWithFrame:NSMakeRect(50.0, 2, 140, 22.0)
-                                 pullsDown:NO];
-  PopUpButtonHandler* popUpButtonHandler =
-      [[PopUpButtonHandler alloc] initWithPanel:dialog
-                                   andTypesList:file_types_list];
-  [popupButton addItemsWithTitles:filter_names];
-  [popupButton setTarget:popUpButtonHandler];
-  [popupButton setAction:@selector(selectFormat:)];
-
-  [accessoryView addSubview:[label autorelease]];
-  [accessoryView addSubview:[popupButton autorelease]];
-
-  [dialog setAccessoryView:[accessoryView autorelease]];
-}
-
-void SetupDialog(NSSavePanel* dialog, const DialogSettings& settings) {
-  if (!settings.title.empty())
-    [dialog setTitle:base::SysUTF8ToNSString(settings.title)];
-
-  if (!settings.button_label.empty())
-    [dialog setPrompt:base::SysUTF8ToNSString(settings.button_label)];
-
-  if (!settings.message.empty())
-    [dialog setMessage:base::SysUTF8ToNSString(settings.message)];
-
-  if (!settings.name_field_label.empty())
-    [dialog
-        setNameFieldLabel:base::SysUTF8ToNSString(settings.name_field_label)];
-
-  [dialog setShowsTagField:settings.shows_tag_field];
-
-  NSString* default_dir = nil;
-  NSString* default_filename = nil;
-  if (!settings.default_path.empty()) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (base::DirectoryExists(settings.default_path)) {
-      default_dir = base::SysUTF8ToNSString(settings.default_path.value());
-    } else {
-      if (settings.default_path.IsAbsolute()) {
-        default_dir =
-            base::SysUTF8ToNSString(settings.default_path.DirName().value());
-      }
-
-      default_filename =
-          base::SysUTF8ToNSString(settings.default_path.BaseName().value());
-    }
-  }
-
-  if (settings.filters.empty()) {
-    [dialog setAllowsOtherFileTypes:YES];
-  } else {
-    // Set setAllowedFileTypes before setNameFieldStringValue as it might
-    // override the extension set using setNameFieldStringValue
-    SetAllowedFileTypes(dialog, settings.filters);
-  }
-
-  // Make sure the extension is always visible. Without this, the extension in
-  // the default filename will not be used in the saved file.
-  [dialog setExtensionHidden:NO];
-
-  if (default_dir)
-    [dialog setDirectoryURL:[NSURL fileURLWithPath:default_dir]];
-  if (default_filename)
-    [dialog setNameFieldStringValue:default_filename];
-}
-
-void SetupDialogForProperties(NSOpenPanel* dialog, int properties) {
-  [dialog setCanChooseFiles:(properties & FILE_DIALOG_OPEN_FILE)];
-  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
-    [dialog setCanChooseDirectories:YES];
-  if (properties & FILE_DIALOG_CREATE_DIRECTORY)
-    [dialog setCanCreateDirectories:YES];
-  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
-    [dialog setAllowsMultipleSelection:YES];
-  if (properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-    [dialog setShowsHiddenFiles:YES];
-  if (properties & FILE_DIALOG_NO_RESOLVE_ALIASES)
-    [dialog setResolvesAliases:NO];
-  if (properties & FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY)
-    [dialog setTreatsFilePackagesAsDirectories:YES];
-}
-
-// Run modal dialog with parent window and return user's choice.
-int RunModalDialog(NSSavePanel* dialog, const DialogSettings& settings) {
-  __block int chosen = NSFileHandlingPanelCancelButton;
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    chosen = [dialog runModal];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger c) {
-                     chosen = c;
-                     [NSApp stopModal];
-                   }];
-    [NSApp runModalForWindow:window];
-  }
-
-  return chosen;
-}
-
-// Create bookmark data and serialise it into a base64 string.
-std::string GetBookmarkDataFromNSURL(NSURL* url) {
-  // Create the file if it doesn't exist (necessary for NSSavePanel options).
-  NSFileManager* defaultManager = [NSFileManager defaultManager];
-  if (![defaultManager fileExistsAtPath:[url path]]) {
-    [defaultManager createFileAtPath:[url path] contents:nil attributes:nil];
-  }
-
-  NSError* error = nil;
-  NSData* bookmarkData =
-      [url bookmarkDataWithOptions:NSURLBookmarkCreationWithSecurityScope
-          includingResourceValuesForKeys:nil
-                           relativeToURL:nil
-                                   error:&error];
-  if (error != nil) {
-    // Send back an empty string if there was an error.
-    return "";
-  } else {
-    // Encode NSData in base64 then convert to NSString.
-    NSString* base64data = [[NSString alloc]
-        initWithData:[bookmarkData base64EncodedDataWithOptions:0]
-            encoding:NSUTF8StringEncoding];
-    return base::SysNSStringToUTF8(base64data);
-  }
-}
-
-void ReadDialogPathsWithBookmarks(NSOpenPanel* dialog,
-                                  std::vector<base::FilePath>* paths,
-                                  std::vector<std::string>* bookmarks) {
-  NSArray* urls = [dialog URLs];
-  for (NSURL* url in urls)
-    if ([url isFileURL]) {
-      paths->push_back(base::FilePath(base::SysNSStringToUTF8([url path])));
-      bookmarks->push_back(GetBookmarkDataFromNSURL(url));
-    }
-}
-
-void ReadDialogPaths(NSOpenPanel* dialog, std::vector<base::FilePath>* paths) {
-  std::vector<std::string> ignored_bookmarks;
-  ReadDialogPathsWithBookmarks(dialog, paths, &ignored_bookmarks);
-}
-
-}  // namespace
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  DCHECK(paths);
-  NSOpenPanel* dialog = [NSOpenPanel openPanel];
-
-  SetupDialog(dialog, settings);
-  SetupDialogForProperties(dialog, settings.properties);
-
-  int chosen = RunModalDialog(dialog, settings);
-  if (chosen == NSFileHandlingPanelCancelButton)
-    return false;
-
-  ReadDialogPaths(dialog, paths);
-  return true;
-}
-
-void OpenDialogCompletion(int chosen,
-                          NSOpenPanel* dialog,
-                          const DialogSettings& settings,
-                          const OpenDialogCallback& callback) {
-  if (chosen == NSFileHandlingPanelCancelButton) {
-#if defined(MAS_BUILD)
-    callback.Run(false, std::vector<base::FilePath>(),
-                 std::vector<std::string>());
-#else
-    callback.Run(false, std::vector<base::FilePath>());
-#endif
-  } else {
-    std::vector<base::FilePath> paths;
-#if defined(MAS_BUILD)
-    std::vector<std::string> bookmarks;
-    if (settings.security_scoped_bookmarks) {
-      ReadDialogPathsWithBookmarks(dialog, &paths, &bookmarks);
-    } else {
-      ReadDialogPaths(dialog, &paths);
-    }
-    callback.Run(true, paths, bookmarks);
-#else
-    ReadDialogPaths(dialog, &paths);
-    callback.Run(true, paths);
-#endif
-  }
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& c) {
-  NSOpenPanel* dialog = [NSOpenPanel openPanel];
-
-  SetupDialog(dialog, settings);
-  SetupDialogForProperties(dialog, settings.properties);
-
-  // Duplicate the callback object here since c is a reference and gcd would
-  // only store the pointer, by duplication we can force gcd to store a copy.
-  __block OpenDialogCallback callback = c;
-
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    [dialog beginWithCompletionHandler:^(NSInteger chosen) {
-      OpenDialogCompletion(chosen, dialog, settings, callback);
-    }];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger chosen) {
-                     OpenDialogCompletion(chosen, dialog, settings, callback);
-                   }];
-  }
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  DCHECK(path);
-  NSSavePanel* dialog = [NSSavePanel savePanel];
-
-  SetupDialog(dialog, settings);
-
-  int chosen = RunModalDialog(dialog, settings);
-  if (chosen == NSFileHandlingPanelCancelButton || ![[dialog URL] isFileURL])
-    return false;
-
-  *path = base::FilePath(base::SysNSStringToUTF8([[dialog URL] path]));
-  return true;
-}
-
-void SaveDialogCompletion(int chosen,
-                          NSSavePanel* dialog,
-                          const DialogSettings& settings,
-                          const SaveDialogCallback& callback) {
-  if (chosen == NSFileHandlingPanelCancelButton) {
-#if defined(MAS_BUILD)
-    callback.Run(false, base::FilePath(), "");
-#else
-    callback.Run(false, base::FilePath());
-#endif
-  } else {
-    std::string path = base::SysNSStringToUTF8([[dialog URL] path]);
-#if defined(MAS_BUILD)
-    std::string bookmark;
-    if (settings.security_scoped_bookmarks) {
-      bookmark = GetBookmarkDataFromNSURL([dialog URL]);
-    }
-    callback.Run(true, base::FilePath(path), bookmark);
-#else
-    callback.Run(true, base::FilePath(path));
-#endif
-  }
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& c) {
-  NSSavePanel* dialog = [NSSavePanel savePanel];
-
-  SetupDialog(dialog, settings);
-  [dialog setCanSelectHiddenExtension:YES];
-
-  __block SaveDialogCallback callback = c;
-
-  if (!settings.parent_window || !settings.parent_window->GetNativeWindow() ||
-      settings.force_detached) {
-    [dialog beginWithCompletionHandler:^(NSInteger chosen) {
-      SaveDialogCompletion(chosen, dialog, settings, callback);
-    }];
-  } else {
-    NSWindow* window = settings.parent_window->GetNativeWindow();
-    [dialog beginSheetModalForWindow:window
-                   completionHandler:^(NSInteger chosen) {
-                     SaveDialogCompletion(chosen, dialog, settings, callback);
-                   }];
-  }
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 6577e4c08404becdc01ef319649efefc0f7dc671 atom/browser/ui/file_dialog_win.cc
  our    100644 dab125ec881bc75ff608dbbfddff972169049e54 atom/browser/ui/file_dialog_win.cc
@@ -1,310 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/file_dialog.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>  // atlbase.h for CComPtr
-
-#include <shlobj.h>
-#include <shobjidl.h>
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/files/file_util.h"
-#include "base/i18n/case_conversion.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/win/registry.h"
-
-namespace file_dialog {
-
-DialogSettings::DialogSettings() = default;
-DialogSettings::DialogSettings(const DialogSettings&) = default;
-DialogSettings::~DialogSettings() = default;
-
-namespace {
-
-// Distinguish directories from regular files.
-bool IsDirectory(const base::FilePath& path) {
-  base::File::Info file_info;
-  return base::GetFileInfo(path, &file_info) ? file_info.is_directory
-                                             : path.EndsWithSeparator();
-}
-
-void ConvertFilters(const Filters& filters,
-                    std::vector<std::wstring>* buffer,
-                    std::vector<COMDLG_FILTERSPEC>* filterspec) {
-  if (filters.empty()) {
-    COMDLG_FILTERSPEC spec = {L"All Files (*.*)", L"*.*"};
-    filterspec->push_back(spec);
-    return;
-  }
-
-  buffer->reserve(filters.size() * 2);
-  for (size_t i = 0; i < filters.size(); ++i) {
-    const Filter& filter = filters[i];
-
-    COMDLG_FILTERSPEC spec;
-    buffer->push_back(base::UTF8ToWide(filter.first));
-    spec.pszName = buffer->back().c_str();
-
-    std::vector<std::string> extensions(filter.second);
-    for (size_t j = 0; j < extensions.size(); ++j)
-      extensions[j].insert(0, "*.");
-    buffer->push_back(base::UTF8ToWide(base::JoinString(extensions, ";")));
-    spec.pszSpec = buffer->back().c_str();
-
-    filterspec->push_back(spec);
-  }
-}
-
-struct RunState {
-  base::Thread* dialog_thread;
-  scoped_refptr<base::SingleThreadTaskRunner> ui_task_runner;
-};
-
-bool CreateDialogThread(RunState* run_state) {
-  auto thread =
-      std::make_unique<base::Thread>(ATOM_PRODUCT_NAME "FileDialogThread");
-  thread->init_com_with_mta(false);
-  if (!thread->Start())
-    return false;
-
-  run_state->dialog_thread = thread.release();
-  run_state->ui_task_runner = base::ThreadTaskRunnerHandle::Get();
-  return true;
-}
-
-void RunOpenDialogInNewThread(const RunState& run_state,
-                              const DialogSettings& settings,
-                              const OpenDialogCallback& callback) {
-  std::vector<base::FilePath> paths;
-  bool result = ShowOpenDialog(settings, &paths);
-  run_state.ui_task_runner->PostTask(FROM_HERE,
-                                     base::Bind(callback, result, paths));
-  run_state.ui_task_runner->DeleteSoon(FROM_HERE, run_state.dialog_thread);
-}
-
-void RunSaveDialogInNewThread(const RunState& run_state,
-                              const DialogSettings& settings,
-                              const SaveDialogCallback& callback) {
-  base::FilePath path;
-  bool result = ShowSaveDialog(settings, &path);
-  run_state.ui_task_runner->PostTask(FROM_HERE,
-                                     base::Bind(callback, result, path));
-  run_state.ui_task_runner->DeleteSoon(FROM_HERE, run_state.dialog_thread);
-}
-
-}  // namespace
-
-static HRESULT GetFileNameFromShellItem(IShellItem* pShellItem,
-                                        SIGDN type,
-                                        LPWSTR lpstr,
-                                        size_t cchLength) {
-  assert(pShellItem != NULL);
-
-  LPWSTR lpstrName = NULL;
-  HRESULT hRet = pShellItem->GetDisplayName(type, &lpstrName);
-
-  if (SUCCEEDED(hRet)) {
-    if (wcslen(lpstrName) < cchLength) {
-      wcscpy_s(lpstr, cchLength, lpstrName);
-    } else {
-      NOTREACHED();
-      hRet = DISP_E_BUFFERTOOSMALL;
-    }
-
-    ::CoTaskMemFree(lpstrName);
-  }
-
-  return hRet;
-}
-
-static void SetDefaultFolder(IFileDialog* dialog,
-                             const base::FilePath file_path) {
-  std::wstring directory =
-      IsDirectory(file_path) ? file_path.value() : file_path.DirName().value();
-
-  ATL::CComPtr<IShellItem> folder_item;
-  HRESULT hr = SHCreateItemFromParsingName(directory.c_str(), NULL,
-                                           IID_PPV_ARGS(&folder_item));
-  if (SUCCEEDED(hr))
-    dialog->SetFolder(folder_item);
-}
-
-static HRESULT ShowFileDialog(IFileDialog* dialog,
-                              const DialogSettings& settings) {
-  atom::UnresponsiveSuppressor suppressor;
-  HWND parent_window =
-      settings.parent_window
-          ? static_cast<atom::NativeWindowViews*>(settings.parent_window)
-                ->GetAcceleratedWidget()
-          : NULL;
-
-  return dialog->Show(parent_window);
-}
-
-static void ApplySettings(IFileDialog* dialog,
-                          const DialogSettings& settings) {
-  std::wstring file_part;
-
-  if (!IsDirectory(settings.default_path))
-    file_part = settings.default_path.BaseName().value();
-
-  dialog->SetFileName(file_part.c_str());
-
-  if (!settings.title.empty())
-    dialog->SetTitle(base::UTF8ToUTF16(settings.title).c_str());
-
-  if (!settings.button_label.empty())
-    dialog->SetOkButtonLabel(base::UTF8ToUTF16(settings.button_label).c_str());
-
-  std::vector<std::wstring> buffer;
-  std::vector<COMDLG_FILTERSPEC> filterspec;
-  ConvertFilters(settings.filters, &buffer, &filterspec);
-
-  if (!filterspec.empty()) {
-    dialog->SetFileTypes(filterspec.size(), filterspec.data());
-  }
-
-  // By default, *.* will be added to the file name if file type is "*.*". In
-  // Electron, we disable it to make a better experience.
-  //
-  // From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/
-  // bb775970(v=vs.85).aspx
-  //
-  // If SetDefaultExtension is not called, the dialog will not update
-  // automatically when user choose a new file type in the file dialog.
-  //
-  // We set file extension to the first none-wildcard extension to make
-  // sure the dialog will update file extension automatically.
-  for (size_t i = 0; i < filterspec.size(); ++i) {
-    if (std::wstring(filterspec[i].pszSpec) != L"*.*") {
-      // SetFileTypeIndex is regarded as one-based index.
-      dialog->SetFileTypeIndex(i + 1);
-      dialog->SetDefaultExtension(filterspec[i].pszSpec);
-      break;
-    }
-  }
-
-  if (settings.default_path.IsAbsolute()) {
-    SetDefaultFolder(dialog, settings.default_path);
-  }
-}
-
-bool ShowOpenDialog(const DialogSettings& settings,
-                    std::vector<base::FilePath>* paths) {
-  ATL::CComPtr<IFileOpenDialog> file_open_dialog;
-  HRESULT hr = file_open_dialog.CoCreateInstance(CLSID_FileOpenDialog);
-
-  if (FAILED(hr))
-    return false;
-
-  DWORD options = FOS_FORCEFILESYSTEM | FOS_FILEMUSTEXIST;
-  if (settings.properties & FILE_DIALOG_OPEN_DIRECTORY)
-    options |= FOS_PICKFOLDERS;
-  if (settings.properties & FILE_DIALOG_MULTI_SELECTIONS)
-    options |= FOS_ALLOWMULTISELECT;
-  if (settings.properties & FILE_DIALOG_SHOW_HIDDEN_FILES)
-    options |= FOS_FORCESHOWHIDDEN;
-  if (settings.properties & FILE_DIALOG_PROMPT_TO_CREATE)
-    options |= FOS_CREATEPROMPT;
-  file_open_dialog->SetOptions(options);
-
-  ApplySettings(file_open_dialog, settings);
-  hr = ShowFileDialog(file_open_dialog, settings);
-  if (FAILED(hr))
-    return false;
-
-  ATL::CComPtr<IShellItemArray> items;
-  hr = file_open_dialog->GetResults(&items);
-  if (FAILED(hr))
-    return false;
-
-  ATL::CComPtr<IShellItem> item;
-  DWORD count = 0;
-  hr = items->GetCount(&count);
-  if (FAILED(hr))
-    return false;
-
-  paths->reserve(count);
-  for (DWORD i = 0; i < count; ++i) {
-    hr = items->GetItemAt(i, &item);
-    if (FAILED(hr))
-      return false;
-
-    wchar_t file_name[MAX_PATH];
-    hr = GetFileNameFromShellItem(item, SIGDN_FILESYSPATH, file_name, MAX_PATH);
-
-    if (FAILED(hr))
-      return false;
-
-    paths->push_back(base::FilePath(file_name));
-  }
-
-  return true;
-}
-
-void ShowOpenDialog(const DialogSettings& settings,
-                    const OpenDialogCallback& callback) {
-  RunState run_state;
-  if (!CreateDialogThread(&run_state)) {
-    callback.Run(false, std::vector<base::FilePath>());
-    return;
-  }
-
-  run_state.dialog_thread->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunOpenDialogInNewThread, run_state, settings, callback));
-}
-
-bool ShowSaveDialog(const DialogSettings& settings, base::FilePath* path) {
-  ATL::CComPtr<IFileSaveDialog> file_save_dialog;
-  HRESULT hr = file_save_dialog.CoCreateInstance(CLSID_FileSaveDialog);
-  if (FAILED(hr))
-    return false;
-
-  file_save_dialog->SetOptions(FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST |
-                        FOS_OVERWRITEPROMPT);
-  ApplySettings(file_save_dialog, settings);
-  hr = ShowFileDialog(file_save_dialog, settings);
-
-  if (FAILED(hr))
-    return false;
-
-  CComPtr<IShellItem> pItem;
-  hr = file_save_dialog->GetResult(&pItem);
-  if (FAILED(hr))
-    return false;
-
-  PWSTR result_path = nullptr;
-  hr = pItem->GetDisplayName(SIGDN_FILESYSPATH, &result_path);
-  if (!SUCCEEDED(hr))
-    return false;
-
-  *path = base::FilePath(result_path);
-  CoTaskMemFree(result_path);
-
-  return true;
-}
-
-void ShowSaveDialog(const DialogSettings& settings,
-                    const SaveDialogCallback& callback) {
-  RunState run_state;
-  if (!CreateDialogThread(&run_state)) {
-    callback.Run(false, base::FilePath());
-    return;
-  }
-
-  run_state.dialog_thread->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunSaveDialogInNewThread, run_state, settings, callback));
-}
-
-}  // namespace file_dialog
removed in remote
  base   100644 d2eb70bcd938904d6ab6cfd63755d166c8c2b1ff atom/browser/ui/message_box.h
  our    100644 a00f1e1978fd2bb5b3d47bcfbbb1c37bbf15f997 atom/browser/ui/message_box.h
@@ -1,69 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_MESSAGE_BOX_H_
-#define ATOM_BROWSER_UI_MESSAGE_BOX_H_
-
-#include <string>
-#include <vector>
-
-#include "base/callback_forward.h"
-#include "base/strings/string16.h"
-
-namespace gfx {
-class ImageSkia;
-}
-
-namespace atom {
-
-class NativeWindow;
-
-enum MessageBoxType {
-  MESSAGE_BOX_TYPE_NONE = 0,
-  MESSAGE_BOX_TYPE_INFORMATION,
-  MESSAGE_BOX_TYPE_WARNING,
-  MESSAGE_BOX_TYPE_ERROR,
-  MESSAGE_BOX_TYPE_QUESTION,
-};
-
-enum MessageBoxOptions {
-  MESSAGE_BOX_NONE = 0,
-  MESSAGE_BOX_NO_LINK = 1 << 0,
-};
-
-typedef base::Callback<void(int code, bool checkbox_checked)>
-    MessageBoxCallback;
-
-int ShowMessageBox(NativeWindow* parent_window,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon);
-
-void ShowMessageBox(NativeWindow* parent_window,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback);
-
-// Like ShowMessageBox with simplest settings, but safe to call at very early
-// stage of application.
-void ShowErrorBox(const base::string16& title, const base::string16& content);
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_MESSAGE_BOX_H_
removed in remote
  base   100644 9615e958b27574e5f8858752525848079860ba19 atom/browser/ui/message_box_gtk.cc
  our    100644 1a5e4587de92f1e681318f773fc2e6f13de5249d atom/browser/ui/message_box_gtk.cc
@@ -1,237 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#include <glib/gi18n.h>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_observer.h"
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/ui/libgtkui/gtk_signal.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-#include "chrome/browser/ui/libgtkui/skia_utils_gtk.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
-
-#define ANSI_FOREGROUND_RED "\x1b[31m"
-#define ANSI_FOREGROUND_BLACK "\x1b[30m"
-#define ANSI_TEXT_BOLD "\x1b[1m"
-#define ANSI_BACKGROUND_GRAY "\x1b[47m"
-#define ANSI_RESET "\x1b[0m"
-
-namespace atom {
-
-namespace {
-
-class GtkMessageBox : public NativeWindowObserver {
- public:
-  GtkMessageBox(NativeWindow* parent_window,
-                MessageBoxType type,
-                const std::vector<std::string>& buttons,
-                int default_id,
-                int cancel_id,
-                const std::string& title,
-                const std::string& message,
-                const std::string& detail,
-                const std::string& checkbox_label,
-                bool checkbox_checked)
-      : cancel_id_(cancel_id),
-        parent_(static_cast<NativeWindow*>(parent_window)) {
-    // Create dialog.
-    dialog_ =
-        gtk_message_dialog_new(nullptr,                         // parent
-                               static_cast<GtkDialogFlags>(0),  // no flags
-                               GetMessageType(type),            // type
-                               GTK_BUTTONS_NONE,                // no buttons
-                               "%s", message.c_str());
-    if (!detail.empty())
-      gtk_message_dialog_format_secondary_text(GTK_MESSAGE_DIALOG(dialog_),
-                                               "%s", detail.c_str());
-    if (!title.empty())
-      gtk_window_set_title(GTK_WINDOW(dialog_), title.c_str());
-
-    if (!checkbox_label.empty()) {
-      GtkWidget* message_area =
-          gtk_message_dialog_get_message_area(GTK_MESSAGE_DIALOG(dialog_));
-      GtkWidget* check_button =
-          gtk_check_button_new_with_label(checkbox_label.c_str());
-      g_signal_connect(check_button, "toggled",
-                       G_CALLBACK(OnCheckboxToggledThunk), this);
-      gtk_toggle_button_set_active(GTK_TOGGLE_BUTTON(check_button),
-                                   checkbox_checked);
-      gtk_container_add(GTK_CONTAINER(message_area), check_button);
-    }
-
-    // Add buttons.
-    for (size_t i = 0; i < buttons.size(); ++i) {
-      GtkWidget* button = gtk_dialog_add_button(
-          GTK_DIALOG(dialog_), TranslateToStock(i, buttons[i]), i);
-      if (static_cast<int>(i) == default_id)
-        gtk_widget_grab_focus(button);
-    }
-
-    // Parent window.
-    if (parent_) {
-      parent_->AddObserver(this);
-      static_cast<NativeWindowViews*>(parent_)->SetEnabled(false);
-      libgtkui::SetGtkTransientForAura(dialog_, parent_->GetNativeWindow());
-      gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
-    }
-  }
-
-  ~GtkMessageBox() override {
-    gtk_widget_destroy(dialog_);
-    if (parent_) {
-      parent_->RemoveObserver(this);
-      static_cast<NativeWindowViews*>(parent_)->SetEnabled(true);
-    }
-  }
-
-  GtkMessageType GetMessageType(MessageBoxType type) {
-    switch (type) {
-      case MESSAGE_BOX_TYPE_INFORMATION:
-        return GTK_MESSAGE_INFO;
-      case MESSAGE_BOX_TYPE_WARNING:
-        return GTK_MESSAGE_WARNING;
-      case MESSAGE_BOX_TYPE_QUESTION:
-        return GTK_MESSAGE_QUESTION;
-      case MESSAGE_BOX_TYPE_ERROR:
-        return GTK_MESSAGE_ERROR;
-      default:
-        return GTK_MESSAGE_OTHER;
-    }
-  }
-
-  const char* TranslateToStock(int id, const std::string& text) {
-    const std::string lower = base::ToLowerASCII(text);
-    if (lower == "cancel")
-      return _("_Cancel");
-    if (lower == "no")
-      return _("_No");
-    if (lower == "ok")
-      return _("_OK");
-    if (lower == "yes")
-      return _("_Yes");
-    return text.c_str();
-  }
-
-  void Show() {
-    gtk_widget_show_all(dialog_);
-    // We need to call gtk_window_present after making the widgets visible to
-    // make sure window gets correctly raised and gets focus.
-    int time = ui::X11EventSource::GetInstance()->GetTimestamp();
-    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
-  }
-
-  int RunSynchronous() {
-    Show();
-    int response = gtk_dialog_run(GTK_DIALOG(dialog_));
-    if (response < 0)
-      return cancel_id_;
-    else
-      return response;
-  }
-
-  void RunAsynchronous(const MessageBoxCallback& callback) {
-    callback_ = callback;
-    g_signal_connect(dialog_, "delete-event",
-                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
-    g_signal_connect(dialog_, "response", G_CALLBACK(OnResponseDialogThunk),
-                     this);
-    Show();
-  }
-
-  void OnWindowClosed() override {
-    parent_->RemoveObserver(this);
-    parent_ = nullptr;
-  }
-
-  CHROMEGTK_CALLBACK_1(GtkMessageBox, void, OnResponseDialog, int);
-  CHROMEGTK_CALLBACK_0(GtkMessageBox, void, OnCheckboxToggled);
-
- private:
-  atom::UnresponsiveSuppressor unresponsive_suppressor_;
-
-  // The id to return when the dialog is closed without pressing buttons.
-  int cancel_id_ = 0;
-
-  bool checkbox_checked_ = false;
-
-  NativeWindow* parent_;
-  GtkWidget* dialog_;
-  MessageBoxCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(GtkMessageBox);
-};
-
-void GtkMessageBox::OnResponseDialog(GtkWidget* widget, int response) {
-  gtk_widget_hide(dialog_);
-
-  if (response < 0)
-    callback_.Run(cancel_id_, checkbox_checked_);
-  else
-    callback_.Run(response, checkbox_checked_);
-  delete this;
-}
-
-void GtkMessageBox::OnCheckboxToggled(GtkWidget* widget) {
-  checkbox_checked_ = gtk_toggle_button_get_active(GTK_TOGGLE_BUTTON(widget));
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& /*icon*/) {
-  return GtkMessageBox(parent, type, buttons, default_id, cancel_id, title,
-                       message, detail, "", false)
-      .RunSynchronous();
-}
-
-void ShowMessageBox(NativeWindow* parent,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& /*icon*/,
-                    const MessageBoxCallback& callback) {
-  (new GtkMessageBox(parent, type, buttons, default_id, cancel_id, title,
-                     message, detail, checkbox_label, checkbox_checked))
-      ->RunAsynchronous(callback);
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  if (Browser::Get()->is_ready()) {
-    GtkMessageBox(nullptr, MESSAGE_BOX_TYPE_ERROR, {"OK"}, -1, 0, "Error",
-                  base::UTF16ToUTF8(title).c_str(),
-                  base::UTF16ToUTF8(content).c_str(), "", false)
-        .RunSynchronous();
-  } else {
-    fprintf(stderr,
-            ANSI_TEXT_BOLD ANSI_BACKGROUND_GRAY ANSI_FOREGROUND_RED
-            "%s\n" ANSI_FOREGROUND_BLACK "%s" ANSI_RESET "\n",
-            base::UTF16ToUTF8(title).c_str(),
-            base::UTF16ToUTF8(content).c_str());
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 d553a6a7dfbf79a9bdafcb1d83e2d058e6983118 atom/browser/ui/message_box_mac.mm
  our    100644 ee2f59dc8c84ba0bf5fe049a133f403d550a9473 atom/browser/ui/message_box_mac.mm
@@ -1,214 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#import <Cocoa/Cocoa.h>
-
-#include "atom/browser/native_window.h"
-#include "base/callback.h"
-#include "base/mac/mac_util.h"
-#include "base/strings/sys_string_conversions.h"
-#include "skia/ext/skia_utils_mac.h"
-#include "ui/gfx/image/image_skia.h"
-
-@interface ModalDelegate : NSObject {
- @private
-  atom::MessageBoxCallback callback_;
-  NSAlert* alert_;
-  bool callEndModal_;
-}
-- (id)initWithCallback:(const atom::MessageBoxCallback&)callback
-              andAlert:(NSAlert*)alert
-          callEndModal:(bool)flag;
-@end
-
-@implementation ModalDelegate
-
-- (id)initWithCallback:(const atom::MessageBoxCallback&)callback
-              andAlert:(NSAlert*)alert
-          callEndModal:(bool)flag {
-  if ((self = [super init])) {
-    callback_ = callback;
-    alert_ = alert;
-    callEndModal_ = flag;
-  }
-  return self;
-}
-
-- (void)alertDidEnd:(NSAlert*)alert
-         returnCode:(NSInteger)returnCode
-        contextInfo:(void*)contextInfo {
-  callback_.Run(returnCode, alert.suppressionButton.state == NSOnState);
-  [alert_ release];
-  [self release];
-
-  if (callEndModal_)
-    [NSApp stopModal];
-}
-
-@end
-
-namespace atom {
-
-namespace {
-
-NSAlert* CreateNSAlert(NativeWindow* parent_window,
-                       MessageBoxType type,
-                       const std::vector<std::string>& buttons,
-                       int default_id,
-                       int cancel_id,
-                       const std::string& title,
-                       const std::string& message,
-                       const std::string& detail,
-                       const std::string& checkbox_label,
-                       bool checkbox_checked,
-                       const gfx::ImageSkia& icon) {
-  // Ignore the title; it's the window title on other platforms and ignorable.
-  NSAlert* alert = [[NSAlert alloc] init];
-  [alert setMessageText:base::SysUTF8ToNSString(message)];
-  [alert setInformativeText:base::SysUTF8ToNSString(detail)];
-
-  switch (type) {
-    case MESSAGE_BOX_TYPE_INFORMATION:
-      alert.alertStyle = NSInformationalAlertStyle;
-      break;
-    case MESSAGE_BOX_TYPE_WARNING:
-    case MESSAGE_BOX_TYPE_ERROR:
-      // NSWarningAlertStyle shows the app icon while NSCriticalAlertStyle
-      // shows a warning icon with an app icon badge. Since there is no
-      // error variant, lets just use NSCriticalAlertStyle.
-      alert.alertStyle = NSCriticalAlertStyle;
-      break;
-    default:
-      break;
-  }
-
-  for (size_t i = 0; i < buttons.size(); ++i) {
-    NSString* title = base::SysUTF8ToNSString(buttons[i]);
-    // An empty title causes crash on macOS.
-    if (buttons[i].empty())
-      title = @"(empty)";
-    NSButton* button = [alert addButtonWithTitle:title];
-    [button setTag:i];
-  }
-
-  NSArray* ns_buttons = [alert buttons];
-  int button_count = static_cast<int>([ns_buttons count]);
-
-  if (default_id >= 0 && default_id < button_count) {
-    // Focus the button at default_id if the user opted to do so.
-    // The first button added gets set as the default selected.
-    // So remove that default, and make the requested button the default.
-    [[ns_buttons objectAtIndex:0] setKeyEquivalent:@""];
-    [[ns_buttons objectAtIndex:default_id] setKeyEquivalent:@"\r"];
-  }
-
-  // Bind cancel id button to escape key if there is more than one button
-  if (button_count > 1 && cancel_id >= 0 && cancel_id < button_count) {
-    [[ns_buttons objectAtIndex:cancel_id] setKeyEquivalent:@"\e"];
-  }
-
-  if (!checkbox_label.empty()) {
-    alert.showsSuppressionButton = YES;
-    alert.suppressionButton.title = base::SysUTF8ToNSString(checkbox_label);
-    alert.suppressionButton.state = checkbox_checked ? NSOnState : NSOffState;
-  }
-
-  if (!icon.isNull()) {
-    NSImage* image = skia::SkBitmapToNSImageWithColorSpace(
-        *icon.bitmap(), base::mac::GetGenericRGBColorSpace());
-    [alert setIcon:image];
-  }
-
-  return alert;
-}
-
-void SetReturnCode(int* ret_code, int result, bool checkbox_checked) {
-  *ret_code = result;
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent_window,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon) {
-  NSAlert* alert =
-      CreateNSAlert(parent_window, type, buttons, default_id, cancel_id, title,
-                    message, detail, "", false, icon);
-
-  // Use runModal for synchronous alert without parent, since we don't have a
-  // window to wait for.
-  if (!parent_window)
-    return [[alert autorelease] runModal];
-
-  int ret_code = -1;
-  ModalDelegate* delegate = [[ModalDelegate alloc]
-      initWithCallback:base::Bind(&SetReturnCode, &ret_code)
-              andAlert:alert
-          callEndModal:true];
-
-  NSWindow* window = parent_window->GetNativeWindow();
-  [alert beginSheetModalForWindow:window
-                    modalDelegate:delegate
-                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
-                      contextInfo:nil];
-
-  [NSApp runModalForWindow:window];
-  return ret_code;
-}
-
-void ShowMessageBox(NativeWindow* parent_window,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback) {
-  NSAlert* alert =
-      CreateNSAlert(parent_window, type, buttons, default_id, cancel_id, title,
-                    message, detail, checkbox_label, checkbox_checked, icon);
-
-  // Use runModal for synchronous alert without parent, since we don't have a
-  // window to wait for.
-  if (!parent_window) {
-    int ret = [[alert autorelease] runModal];
-    callback.Run(ret, alert.suppressionButton.state == NSOnState);
-  } else {
-    ModalDelegate* delegate = [[ModalDelegate alloc] initWithCallback:callback
-                                                             andAlert:alert
-                                                         callEndModal:false];
-
-    NSWindow* window = parent_window ? parent_window->GetNativeWindow() : nil;
-    [alert
-        beginSheetModalForWindow:window
-                   modalDelegate:delegate
-                  didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
-                     contextInfo:nil];
-  }
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  NSAlert* alert = [[NSAlert alloc] init];
-  [alert setMessageText:base::SysUTF16ToNSString(title)];
-  [alert setInformativeText:base::SysUTF16ToNSString(content)];
-  [alert setAlertStyle:NSCriticalAlertStyle];
-  [alert runModal];
-  [alert release];
-}
-
-}  // namespace atom
removed in remote
  base   100644 5f49151c30ff01c153da174506ba411fa7f383cc atom/browser/ui/message_box_win.cc
  our    100644 b0e73f550e1d3a91f15e8d2d0604518027f75298 atom/browser/ui/message_box_win.cc
@@ -1,285 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/message_box.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <commctrl.h>
-
-#include <map>
-#include <vector>
-
-#include "atom/browser/browser.h"
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/unresponsive_suppressor.h"
-#include "base/callback.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread.h"
-#include "base/win/scoped_gdi_object.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/gfx/icon_util.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace atom {
-
-namespace {
-
-// Small command ID values are already taken by Windows, we have to start from
-// a large number to avoid conflicts with Windows.
-const int kIDStart = 100;
-
-// Get the common ID from button's name.
-struct CommonButtonID {
-  int button;
-  int id;
-};
-CommonButtonID GetCommonID(const base::string16& button) {
-  base::string16 lower = base::ToLowerASCII(button);
-  if (lower == L"ok")
-    return {TDCBF_OK_BUTTON, IDOK};
-  else if (lower == L"yes")
-    return {TDCBF_YES_BUTTON, IDYES};
-  else if (lower == L"no")
-    return {TDCBF_NO_BUTTON, IDNO};
-  else if (lower == L"cancel")
-    return {TDCBF_CANCEL_BUTTON, IDCANCEL};
-  else if (lower == L"retry")
-    return {TDCBF_RETRY_BUTTON, IDRETRY};
-  else if (lower == L"close")
-    return {TDCBF_CLOSE_BUTTON, IDCLOSE};
-  return {-1, -1};
-}
-
-// Determine whether the buttons are common buttons, if so map common ID
-// to button ID.
-void MapToCommonID(const std::vector<base::string16>& buttons,
-                   std::map<int, int>* id_map,
-                   TASKDIALOG_COMMON_BUTTON_FLAGS* button_flags,
-                   std::vector<TASKDIALOG_BUTTON>* dialog_buttons) {
-  for (size_t i = 0; i < buttons.size(); ++i) {
-    auto common = GetCommonID(buttons[i]);
-    if (common.button != -1) {
-      // It is a common button.
-      (*id_map)[common.id] = i;
-      (*button_flags) |= common.button;
-    } else {
-      // It is a custom button.
-      dialog_buttons->push_back(
-          {static_cast<int>(i + kIDStart), buttons[i].c_str()});
-    }
-  }
-}
-
-int ShowTaskDialogUTF16(NativeWindow* parent,
-                        MessageBoxType type,
-                        const std::vector<base::string16>& buttons,
-                        int default_id,
-                        int cancel_id,
-                        int options,
-                        const base::string16& title,
-                        const base::string16& message,
-                        const base::string16& detail,
-                        const base::string16& checkbox_label,
-                        bool* checkbox_checked,
-                        const gfx::ImageSkia& icon) {
-  TASKDIALOG_FLAGS flags =
-      TDF_SIZE_TO_CONTENT |           // Show all content.
-      TDF_ALLOW_DIALOG_CANCELLATION;  // Allow canceling the dialog.
-
-  TASKDIALOGCONFIG config = {0};
-  config.cbSize = sizeof(config);
-  config.hInstance = GetModuleHandle(NULL);
-  config.dwFlags = flags;
-
-  if (parent) {
-    config.hwndParent =
-        static_cast<atom::NativeWindowViews*>(parent)->GetAcceleratedWidget();
-  }
-
-  if (default_id > 0)
-    config.nDefaultButton = kIDStart + default_id;
-
-  // TaskDialogIndirect doesn't allow empty name, if we set empty title it
-  // will show "electron.exe" in title.
-  base::string16 app_name = base::UTF8ToUTF16(Browser::Get()->GetName());
-  if (title.empty())
-    config.pszWindowTitle = app_name.c_str();
-  else
-    config.pszWindowTitle = title.c_str();
-
-  base::win::ScopedHICON hicon;
-  if (!icon.isNull()) {
-    hicon = IconUtil::CreateHICONFromSkBitmap(*icon.bitmap());
-    config.dwFlags |= TDF_USE_HICON_MAIN;
-    config.hMainIcon = hicon.get();
-  } else {
-    // Show icon according to dialog's type.
-    switch (type) {
-      case MESSAGE_BOX_TYPE_INFORMATION:
-      case MESSAGE_BOX_TYPE_QUESTION:
-        config.pszMainIcon = TD_INFORMATION_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_WARNING:
-        config.pszMainIcon = TD_WARNING_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_ERROR:
-        config.pszMainIcon = TD_ERROR_ICON;
-        break;
-      case MESSAGE_BOX_TYPE_NONE:
-        break;
-    }
-  }
-
-  // If "detail" is empty then don't make message hilighted.
-  if (detail.empty()) {
-    config.pszContent = message.c_str();
-  } else {
-    config.pszMainInstruction = message.c_str();
-    config.pszContent = detail.c_str();
-  }
-
-  if (!checkbox_label.empty()) {
-    config.pszVerificationText = checkbox_label.c_str();
-
-    if (checkbox_checked && *checkbox_checked) {
-      config.dwFlags |= TDF_VERIFICATION_FLAG_CHECKED;
-    }
-  }
-
-  // Iterate through the buttons, put common buttons in dwCommonButtons
-  // and custom buttons in pButtons.
-  std::map<int, int> id_map;
-  std::vector<TASKDIALOG_BUTTON> dialog_buttons;
-  if (options & MESSAGE_BOX_NO_LINK) {
-    for (size_t i = 0; i < buttons.size(); ++i)
-      dialog_buttons.push_back(
-          {static_cast<int>(i + kIDStart), buttons[i].c_str()});
-  } else {
-    MapToCommonID(buttons, &id_map, &config.dwCommonButtons, &dialog_buttons);
-  }
-  if (dialog_buttons.size() > 0) {
-    config.pButtons = &dialog_buttons.front();
-    config.cButtons = dialog_buttons.size();
-    if (!(options & MESSAGE_BOX_NO_LINK))
-      config.dwFlags |= TDF_USE_COMMAND_LINKS;  // custom buttons as links.
-  }
-
-  int id = 0;
-  BOOL verificationFlagChecked = FALSE;
-  TaskDialogIndirect(&config, &id, nullptr, &verificationFlagChecked);
-  if (checkbox_checked) {
-    *checkbox_checked = verificationFlagChecked;
-  }
-
-  if (id_map.find(id) != id_map.end())  // common button.
-    return id_map[id];
-  else if (id >= kIDStart)  // custom button.
-    return id - kIDStart;
-  else
-    return cancel_id;
-}
-
-int ShowTaskDialogUTF8(NativeWindow* parent,
-                       MessageBoxType type,
-                       const std::vector<std::string>& buttons,
-                       int default_id,
-                       int cancel_id,
-                       int options,
-                       const std::string& title,
-                       const std::string& message,
-                       const std::string& detail,
-                       const std::string& checkbox_label,
-                       bool* checkbox_checked,
-                       const gfx::ImageSkia& icon) {
-  std::vector<base::string16> utf16_buttons;
-  for (const auto& button : buttons)
-    utf16_buttons.push_back(base::UTF8ToUTF16(button));
-
-  return ShowTaskDialogUTF16(
-      parent, type, utf16_buttons, default_id, cancel_id, options,
-      base::UTF8ToUTF16(title), base::UTF8ToUTF16(message),
-      base::UTF8ToUTF16(detail), base::UTF8ToUTF16(checkbox_label),
-      checkbox_checked, icon);
-}
-
-void RunMessageBoxInNewThread(base::Thread* thread,
-                              NativeWindow* parent,
-                              MessageBoxType type,
-                              const std::vector<std::string>& buttons,
-                              int default_id,
-                              int cancel_id,
-                              int options,
-                              const std::string& title,
-                              const std::string& message,
-                              const std::string& detail,
-                              const std::string& checkbox_label,
-                              bool checkbox_checked,
-                              const gfx::ImageSkia& icon,
-                              const MessageBoxCallback& callback) {
-  int result = ShowTaskDialogUTF8(parent, type, buttons, default_id, cancel_id,
-                                  options, title, message, detail,
-                                  checkbox_label, &checkbox_checked, icon);
-  content::BrowserThread::PostTask(
-      content::BrowserThread::UI, FROM_HERE,
-      base::Bind(callback, result, checkbox_checked));
-  content::BrowserThread::DeleteSoon(content::BrowserThread::UI, FROM_HERE,
-                                     thread);
-}
-
-}  // namespace
-
-int ShowMessageBox(NativeWindow* parent,
-                   MessageBoxType type,
-                   const std::vector<std::string>& buttons,
-                   int default_id,
-                   int cancel_id,
-                   int options,
-                   const std::string& title,
-                   const std::string& message,
-                   const std::string& detail,
-                   const gfx::ImageSkia& icon) {
-  atom::UnresponsiveSuppressor suppressor;
-  return ShowTaskDialogUTF8(parent, type, buttons, default_id, cancel_id,
-                            options, title, message, detail, "", nullptr, icon);
-}
-
-void ShowMessageBox(NativeWindow* parent,
-                    MessageBoxType type,
-                    const std::vector<std::string>& buttons,
-                    int default_id,
-                    int cancel_id,
-                    int options,
-                    const std::string& title,
-                    const std::string& message,
-                    const std::string& detail,
-                    const std::string& checkbox_label,
-                    bool checkbox_checked,
-                    const gfx::ImageSkia& icon,
-                    const MessageBoxCallback& callback) {
-  auto thread =
-      std::make_unique<base::Thread>(ATOM_PRODUCT_NAME "MessageBoxThread");
-  thread->init_com_with_mta(false);
-  if (!thread->Start()) {
-    callback.Run(cancel_id, checkbox_checked);
-    return;
-  }
-
-  base::Thread* unretained = thread.release();
-  unretained->task_runner()->PostTask(
-      FROM_HERE,
-      base::Bind(&RunMessageBoxInNewThread, base::Unretained(unretained),
-                 parent, type, buttons, default_id, cancel_id, options, title,
-                 message, detail, checkbox_label, checkbox_checked, icon,
-                 callback));
-}
-
-void ShowErrorBox(const base::string16& title, const base::string16& content) {
-  atom::UnresponsiveSuppressor suppressor;
-  ShowTaskDialogUTF16(nullptr, MESSAGE_BOX_TYPE_ERROR, {}, -1, 0, 0, L"Error",
-                      title, content, L"", nullptr, gfx::ImageSkia());
-}
-
-}  // namespace atom
removed in remote
  base   100644 60923c2ad0a6489774247a6e9b0b5c376920f5e1 atom/browser/ui/tray_icon.cc
  our    100644 b5332ac97b27ac87b0b48caf7e5f21e12407a0e6 atom/browser/ui/tray_icon.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon.h"
-
-namespace atom {
-
-TrayIcon::TrayIcon() {}
-
-TrayIcon::~TrayIcon() {}
-
-void TrayIcon::SetPressedImage(ImageType image) {}
-
-void TrayIcon::SetTitle(const std::string& title) {}
-
-void TrayIcon::SetHighlightMode(TrayIcon::HighlightMode mode) {}
-
-void TrayIcon::DisplayBalloon(ImageType icon,
-                              const base::string16& title,
-                              const base::string16& contents) {}
-
-void TrayIcon::PopUpContextMenu(const gfx::Point& pos,
-                                AtomMenuModel* menu_model) {}
-
-gfx::Rect TrayIcon::GetBounds() {
-  return gfx::Rect();
-}
-
-void TrayIcon::NotifyClicked(const gfx::Rect& bounds,
-                             const gfx::Point& location,
-                             int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnClicked(bounds, location, modifiers);
-}
-
-void TrayIcon::NotifyDoubleClicked(const gfx::Rect& bounds, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDoubleClicked(bounds, modifiers);
-}
-
-void TrayIcon::NotifyBalloonShow() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonShow();
-}
-
-void TrayIcon::NotifyBalloonClicked() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonClicked();
-}
-
-void TrayIcon::NotifyBalloonClosed() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnBalloonClosed();
-}
-
-void TrayIcon::NotifyRightClicked(const gfx::Rect& bounds, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnRightClicked(bounds, modifiers);
-}
-
-void TrayIcon::NotifyDrop() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDrop();
-}
-
-void TrayIcon::NotifyDropFiles(const std::vector<std::string>& files) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDropFiles(files);
-}
-
-void TrayIcon::NotifyDropText(const std::string& text) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDropText(text);
-}
-
-void TrayIcon::NotifyMouseEntered(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseEntered(location, modifiers);
-}
-
-void TrayIcon::NotifyMouseExited(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseExited(location, modifiers);
-}
-
-void TrayIcon::NotifyMouseMoved(const gfx::Point& location, int modifiers) {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnMouseMoved(location, modifiers);
-}
-
-void TrayIcon::NotifyDragEntered() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragEntered();
-}
-
-void TrayIcon::NotifyDragExited() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragExited();
-}
-
-void TrayIcon::NotifyDragEnded() {
-  for (TrayIconObserver& observer : observers_)
-    observer.OnDragEnded();
-}
-
-}  // namespace atom
removed in remote
  base   100644 c80ff08d6a52daa84252c0a0369bc474d07245df atom/browser/ui/tray_icon.h
  our    100644 76155000e88745f1c0cda423e5af47dddec38e4a atom/browser/ui/tray_icon.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_H_
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "atom/browser/ui/tray_icon_observer.h"
-#include "base/observer_list.h"
-#include "ui/gfx/geometry/rect.h"
-
-namespace atom {
-
-class TrayIcon {
- public:
-  static TrayIcon* Create();
-
-#if defined(OS_WIN)
-  using ImageType = HICON;
-#else
-  using ImageType = const gfx::Image&;
-#endif
-
-  virtual ~TrayIcon();
-
-  // Sets the image associated with this status icon.
-  virtual void SetImage(ImageType image) = 0;
-
-  // Sets the image associated with this status icon when pressed.
-  virtual void SetPressedImage(ImageType image);
-
-  // Sets the hover text for this status icon. This is also used as the label
-  // for the menu item which is created as a replacement for the status icon
-  // click action on platforms that do not support custom click actions for the
-  // status icon (e.g. Ubuntu Unity).
-  virtual void SetToolTip(const std::string& tool_tip) = 0;
-
-  // Sets the title displayed aside of the status icon in the status bar. This
-  // only works on macOS.
-  virtual void SetTitle(const std::string& title);
-
-  // Sets the status icon highlight mode. This only works on macOS.
-  enum HighlightMode {
-    ALWAYS,    // Always highlight the tray icon
-    NEVER,     // Never highlight the tray icon
-    SELECTION  // Highlight the tray icon when clicked or the menu is opened
-  };
-  virtual void SetHighlightMode(HighlightMode mode);
-
-  // Setter and getter for the flag which determines whether to ignore double
-  // click events. These only work on macOS.
-#if defined(OS_MACOSX)
-  virtual void SetIgnoreDoubleClickEvents(bool ignore) = 0;
-  virtual bool GetIgnoreDoubleClickEvents() = 0;
-#endif
-
-  // Displays a notification balloon with the specified contents.
-  // Depending on the platform it might not appear by the icon tray.
-  virtual void DisplayBalloon(ImageType icon,
-                              const base::string16& title,
-                              const base::string16& contents);
-
-  // Popups the menu.
-  virtual void PopUpContextMenu(const gfx::Point& pos,
-                                AtomMenuModel* menu_model);
-
-  // Set the context menu for this icon.
-  virtual void SetContextMenu(AtomMenuModel* menu_model) = 0;
-
-  // Returns the bounds of tray icon.
-  virtual gfx::Rect GetBounds();
-
-  void AddObserver(TrayIconObserver* obs) { observers_.AddObserver(obs); }
-  void RemoveObserver(TrayIconObserver* obs) { observers_.RemoveObserver(obs); }
-
-  void NotifyClicked(const gfx::Rect& = gfx::Rect(),
-                     const gfx::Point& location = gfx::Point(),
-                     int modifiers = 0);
-  void NotifyDoubleClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
-  void NotifyBalloonShow();
-  void NotifyBalloonClicked();
-  void NotifyBalloonClosed();
-  void NotifyRightClicked(const gfx::Rect& bounds = gfx::Rect(),
-                          int modifiers = 0);
-  void NotifyDrop();
-  void NotifyDropFiles(const std::vector<std::string>& files);
-  void NotifyDropText(const std::string& text);
-  void NotifyDragEntered();
-  void NotifyDragExited();
-  void NotifyDragEnded();
-  void NotifyMouseEntered(const gfx::Point& location = gfx::Point(),
-                          int modifiers = 0);
-  void NotifyMouseExited(const gfx::Point& location = gfx::Point(),
-                         int modifiers = 0);
-  void NotifyMouseMoved(const gfx::Point& location = gfx::Point(),
-                        int modifiers = 0);
-
- protected:
-  TrayIcon();
-
- private:
-  base::ObserverList<TrayIconObserver> observers_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIcon);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_H_
removed in remote
  base   100644 59e2241aa480470e99d1be3f7b4cdcf4cf31c5aa atom/browser/ui/tray_icon_cocoa.h
  our    100644 34ace850a79e7ff480a96e0c066946e451a4e849 atom/browser/ui/tray_icon_cocoa.h
@@ -1,56 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
-
-#import <Cocoa/Cocoa.h>
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "base/mac/scoped_nsobject.h"
-
-@class AtomMenuController;
-@class StatusItemView;
-
-namespace atom {
-
-class TrayIconCocoa : public TrayIcon, public AtomMenuModel::Observer {
- public:
-  TrayIconCocoa();
-  ~TrayIconCocoa() override;
-
-  void SetImage(const gfx::Image& image) override;
-  void SetPressedImage(const gfx::Image& image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void SetTitle(const std::string& title) override;
-  void SetHighlightMode(TrayIcon::HighlightMode mode) override;
-  void SetIgnoreDoubleClickEvents(bool ignore) override;
-  bool GetIgnoreDoubleClickEvents() override;
-  void PopUpContextMenu(const gfx::Point& pos,
-                        AtomMenuModel* menu_model) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-  gfx::Rect GetBounds() override;
-
- protected:
-  // AtomMenuModel::Observer:
-  void OnMenuWillClose() override;
-
- private:
-  // Atom custom view for NSStatusItem.
-  base::scoped_nsobject<StatusItemView> status_item_view_;
-
-  // Status menu shown when right-clicking the system icon.
-  base::scoped_nsobject<AtomMenuController> menu_;
-
-  // Used for unregistering observer.
-  AtomMenuModel* menu_model_ = nullptr;  // weak ref.
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIconCocoa);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_COCOA_H_
removed in remote
  base   100644 d2a2fe83460e08f97982cce119f0fdb766d0e6fb atom/browser/ui/tray_icon_cocoa.mm
  our    100644 2c434d7a9e312adfb3802628a3d092a95d4ac49f atom/browser/ui/tray_icon_cocoa.mm
@@ -1,499 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon_cocoa.h"
-
-#include "atom/browser/ui/cocoa/NSString+ANSI.h"
-#include "atom/browser/ui/cocoa/atom_menu_controller.h"
-#include "base/strings/sys_string_conversions.h"
-#include "ui/display/screen.h"
-#include "ui/events/cocoa/cocoa_event_utils.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/mac/coordinate_conversion.h"
-
-namespace {
-
-// By default, macOS sets 4px to tray image as left and right padding margin.
-const CGFloat kHorizontalMargin = 4;
-// macOS tends to make the title 2px lower.
-const CGFloat kVerticalTitleMargin = 2;
-
-}  //  namespace
-
-@interface StatusItemView : NSView {
-  atom::TrayIconCocoa* trayIcon_;       // weak
-  AtomMenuController* menuController_;  // weak
-  atom::TrayIcon::HighlightMode highlight_mode_;
-  BOOL ignoreDoubleClickEvents_;
-  BOOL forceHighlight_;
-  BOOL inMouseEventSequence_;
-  BOOL ANSI_;
-  base::scoped_nsobject<NSImage> image_;
-  base::scoped_nsobject<NSImage> alternateImage_;
-  base::scoped_nsobject<NSString> title_;
-  base::scoped_nsobject<NSMutableAttributedString> attributedTitle_;
-  base::scoped_nsobject<NSStatusItem> statusItem_;
-  base::scoped_nsobject<NSTrackingArea> trackingArea_;
-}
-
-@end  // @interface StatusItemView
-
-@implementation StatusItemView
-
-- (id)initWithImage:(NSImage*)image icon:(atom::TrayIconCocoa*)icon {
-  image_.reset([image copy]);
-  trayIcon_ = icon;
-  highlight_mode_ = atom::TrayIcon::HighlightMode::SELECTION;
-  ignoreDoubleClickEvents_ = NO;
-  forceHighlight_ = NO;
-  inMouseEventSequence_ = NO;
-
-  if ((self = [super initWithFrame:CGRectZero])) {
-    [self registerForDraggedTypes:@[
-      NSFilenamesPboardType,
-      NSStringPboardType,
-    ]];
-
-    // Create the status item.
-    NSStatusItem* item = [[NSStatusBar systemStatusBar]
-        statusItemWithLength:NSVariableStatusItemLength];
-    statusItem_.reset([item retain]);
-    [statusItem_ setView:self];
-    // Finalize setup by sizing our views
-    [self updateDimensions];
-
-    // Add NSTrackingArea for listening to mouseEnter, mouseExit, and mouseMove
-    // events
-    trackingArea_.reset([[NSTrackingArea alloc]
-        initWithRect:[self bounds]
-             options:NSTrackingMouseEnteredAndExited | NSTrackingMouseMoved |
-                     NSTrackingActiveAlways
-               owner:self
-            userInfo:nil]);
-    [self addTrackingArea:trackingArea_];
-  }
-  return self;
-}
-
-- (void)updateDimensions {
-  NSStatusBar* bar = [NSStatusBar systemStatusBar];
-  [self setFrame:NSMakeRect(0, 0, [self fullWidth], [bar thickness])];
-  [self setNeedsDisplay:YES];
-}
-
-- (void)removeItem {
-  // Turn off tracking events to prevent crash
-  if (trackingArea_) {
-    [self removeTrackingArea:trackingArea_];
-    trackingArea_.reset();
-  }
-  [[NSStatusBar systemStatusBar] removeStatusItem:statusItem_];
-  statusItem_.reset();
-}
-
-- (void)drawRect:(NSRect)dirtyRect {
-  // Draw the tray icon and title that align with NSStatusItem, layout:
-  //   ----------------
-  //   | icon | title |
-  ///  ----------------
-
-  CGFloat thickness = [[statusItem_ statusBar] thickness];
-
-  // Draw the system bar background.
-  [statusItem_ drawStatusBarBackgroundInRect:self.bounds
-                               withHighlight:[self shouldHighlight]];
-
-  // Determine which image to use.
-  NSImage* image = image_.get();
-  if (inMouseEventSequence_ && alternateImage_) {
-    image = alternateImage_.get();
-  }
-  // Apply the higlight color if the image is a template image. When this moves
-  // to using the new [NSStatusItem button] API, this should work automagically.
-  if ([image isTemplate] == YES) {
-    NSImage* imageWithColor = [[image copy] autorelease];
-    [imageWithColor lockFocus];
-    [[self colorWithHighlight:[self isHighlighted]] set];
-    CGRect imageBounds = CGRectMake(0, 0, image.size.width, image.size.height);
-    NSRectFillUsingOperation(imageBounds, NSCompositeSourceAtop);
-    [imageWithColor unlockFocus];
-    image = imageWithColor;
-  }
-
-  // Draw the image
-  [image
-      drawInRect:CGRectMake(roundf(([self iconWidth] - image.size.width) / 2),
-                            roundf((thickness - image.size.height) / 2),
-                            image.size.width, image.size.height)];
-
-  if (title_) {
-    // Draw title.
-    NSRect titleDrawRect = NSMakeRect([self iconWidth], -kVerticalTitleMargin,
-                                      [self titleWidth], thickness);
-    [attributedTitle_ drawInRect:titleDrawRect];
-  }
-}
-
-- (BOOL)isDarkMode {
-  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
-  NSString* mode = [defaults stringForKey:@"AppleInterfaceStyle"];
-  return mode && [mode isEqualToString:@"Dark"];
-}
-
-- (BOOL)isHighlighted {
-  BOOL highlight = [self shouldHighlight];
-  return highlight | [self isDarkMode];
-}
-
-// The width of the full status item.
-- (CGFloat)fullWidth {
-  if (title_)
-    return [self iconWidth] + [self titleWidth] + kHorizontalMargin;
-  else
-    return [self iconWidth];
-}
-
-// The width of the icon.
-- (CGFloat)iconWidth {
-  CGFloat thickness = [[NSStatusBar systemStatusBar] thickness];
-  CGFloat imageHeight = [image_ size].height;
-  CGFloat imageWidth = [image_ size].width;
-  CGFloat iconWidth = imageWidth;
-  if (imageWidth < thickness) {
-    // Image's width must be larger than menu bar's height.
-    iconWidth = thickness;
-  } else {
-    CGFloat verticalMargin = thickness - imageHeight;
-    // Image must have same horizontal vertical margin.
-    if (verticalMargin > 0 && imageWidth != imageHeight)
-      iconWidth = imageWidth + verticalMargin;
-    CGFloat horizontalMargin = thickness - imageWidth;
-    // Image must have at least kHorizontalMargin horizontal margin on each
-    // side.
-    if (horizontalMargin < 2 * kHorizontalMargin)
-      iconWidth = imageWidth + 2 * kHorizontalMargin;
-  }
-  return iconWidth;
-}
-
-// The width of the title.
-- (CGFloat)titleWidth {
-  if (!title_)
-    return 0;
-  return [attributedTitle_ size].width;
-}
-
-- (NSColor*)colorWithHighlight:(BOOL)highlight {
-  return highlight ? [NSColor whiteColor]
-                   : [NSColor colorWithRed:0.265625
-                                     green:0.25390625
-                                      blue:0.234375
-                                     alpha:1.0];
-}
-
-- (void)setImage:(NSImage*)image {
-  image_.reset([image copy]);
-  [self updateDimensions];
-}
-
-- (void)setAlternateImage:(NSImage*)image {
-  alternateImage_.reset([image copy]);
-}
-
-- (void)setHighlight:(atom::TrayIcon::HighlightMode)mode {
-  highlight_mode_ = mode;
-  [self setNeedsDisplay:YES];
-}
-
-- (void)setIgnoreDoubleClickEvents:(BOOL)ignore {
-  ignoreDoubleClickEvents_ = ignore;
-}
-
-- (BOOL)getIgnoreDoubleClickEvents {
-  return ignoreDoubleClickEvents_;
-}
-
-- (void)setTitle:(NSString*)title {
-  if (title.length > 0) {
-    title_.reset([title copy]);
-    ANSI_ = [title containsANSICodes];
-  } else {
-    title_.reset();
-    ANSI_ = NO;
-  }
-  [self updateAttributedTitle];
-  [self updateDimensions];
-}
-
-- (void)updateAttributedTitle {
-  NSDictionary* attributes =
-      @{NSFontAttributeName : [NSFont menuBarFontOfSize:0]};
-
-  if (ANSI_) {
-    NSCharacterSet* whites = [NSCharacterSet whitespaceCharacterSet];
-    NSString* title = [title_ stringByTrimmingCharactersInSet:whites];
-    attributedTitle_.reset([title attributedStringParsingANSICodes]);
-    [attributedTitle_ addAttributes:attributes
-                              range:NSMakeRange(0, [attributedTitle_ length])];
-    return;
-  }
-
-  // check title_ being nil
-  NSString* title = @"";
-  if (title_)
-    title = title_;
-
-  attributedTitle_.reset([[NSMutableAttributedString alloc]
-      initWithString:title
-          attributes:attributes]);
-
-  // NSFontAttributeName:[NSFont menuBarFontOfSize:0],
-  // NSForegroundColorAttributeName:[self colorWithHighlight: highlight]
-  [attributedTitle_ addAttributes:attributes
-                            range:NSMakeRange(0, [attributedTitle_ length])];
-  [attributedTitle_ addAttribute:NSForegroundColorAttributeName
-                           value:[self colorWithHighlight:[self isHighlighted]]
-                           range:NSMakeRange(0, [attributedTitle_ length])];
-}
-
-- (void)setMenuController:(AtomMenuController*)menu {
-  menuController_ = menu;
-}
-
-- (void)mouseDown:(NSEvent*)event {
-  inMouseEventSequence_ = YES;
-  [self setNeedsDisplay:YES];
-}
-
-- (void)mouseUp:(NSEvent*)event {
-  if (!inMouseEventSequence_) {
-    // If the menu is showing, when user clicked the tray icon, the `mouseDown`
-    // event will be dissmissed, we need to close the menu at this time.
-    [self setNeedsDisplay:YES];
-    return;
-  }
-  inMouseEventSequence_ = NO;
-
-  // Show menu when there is a context menu.
-  // NB(hokein): Make tray's behavior more like official one's.
-  // When the tray icon gets clicked quickly multiple times, the
-  // event.clickCount doesn't always return 1. Instead, it returns a value that
-  // counts the clicked times.
-  // So we don't check the clickCount here, just pop up the menu for each click
-  // event.
-  if (menuController_)
-    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
-
-  // Don't emit click events when menu is showing.
-  if (menuController_)
-    return;
-
-  // If we are ignoring double click events, we should ignore the `clickCount`
-  // value and immediately emit a click event.
-  BOOL shouldBeHandledAsASingleClick =
-      (event.clickCount == 1) || ignoreDoubleClickEvents_;
-  if (shouldBeHandledAsASingleClick)
-    trayIcon_->NotifyClicked(
-        gfx::ScreenRectFromNSRect(event.window.frame),
-        gfx::ScreenPointFromNSPoint([event locationInWindow]),
-        ui::EventFlagsFromModifiers([event modifierFlags]));
-
-  // Double click event.
-  BOOL shouldBeHandledAsADoubleClick =
-      (event.clickCount == 2) && !ignoreDoubleClickEvents_;
-  if (shouldBeHandledAsADoubleClick)
-    trayIcon_->NotifyDoubleClicked(
-        gfx::ScreenRectFromNSRect(event.window.frame),
-        ui::EventFlagsFromModifiers([event modifierFlags]));
-
-  [self setNeedsDisplay:YES];
-}
-
-- (void)popUpContextMenu:(atom::AtomMenuModel*)menu_model {
-  // Show a custom menu.
-  if (menu_model) {
-    base::scoped_nsobject<AtomMenuController> menuController([
-        [AtomMenuController alloc] initWithModel:menu_model
-                           useDefaultAccelerator:NO]);
-    forceHighlight_ = YES;  // Should highlight when showing menu.
-    [self setNeedsDisplay:YES];
-    [statusItem_ popUpStatusItemMenu:[menuController menu]];
-    forceHighlight_ = NO;
-    [self setNeedsDisplay:YES];
-    return;
-  }
-
-  if (menuController_ && ![menuController_ isMenuOpen]) {
-    // Redraw the tray icon to show highlight if it is enabled.
-    [self setNeedsDisplay:YES];
-    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
-    // The popUpStatusItemMenu returns only after the showing menu is closed.
-    // When it returns, we need to redraw the tray icon to not show highlight.
-    [self setNeedsDisplay:YES];
-  }
-}
-
-- (void)rightMouseUp:(NSEvent*)event {
-  trayIcon_->NotifyRightClicked(
-      gfx::ScreenRectFromNSRect(event.window.frame),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (NSDragOperation)draggingEntered:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragEntered();
-  return NSDragOperationCopy;
-}
-
-- (void)mouseExited:(NSEvent*)event {
-  trayIcon_->NotifyMouseExited(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)mouseEntered:(NSEvent*)event {
-  trayIcon_->NotifyMouseEntered(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)mouseMoved:(NSEvent*)event {
-  trayIcon_->NotifyMouseMoved(
-      gfx::ScreenPointFromNSPoint([event locationInWindow]),
-      ui::EventFlagsFromModifiers([event modifierFlags]));
-}
-
-- (void)draggingExited:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragExited();
-}
-
-- (void)draggingEnded:(id<NSDraggingInfo>)sender {
-  trayIcon_->NotifyDragEnded();
-
-  if (NSPointInRect([sender draggingLocation], self.frame)) {
-    trayIcon_->NotifyDrop();
-  }
-}
-
-- (BOOL)handleDrop:(id<NSDraggingInfo>)sender {
-  NSPasteboard* pboard = [sender draggingPasteboard];
-
-  if ([[pboard types] containsObject:NSFilenamesPboardType]) {
-    std::vector<std::string> dropFiles;
-    NSArray* files = [pboard propertyListForType:NSFilenamesPboardType];
-    for (NSString* file in files)
-      dropFiles.push_back(base::SysNSStringToUTF8(file));
-    trayIcon_->NotifyDropFiles(dropFiles);
-    return YES;
-  } else if ([[pboard types] containsObject:NSStringPboardType]) {
-    NSString* dropText = [pboard stringForType:NSStringPboardType];
-    trayIcon_->NotifyDropText(base::SysNSStringToUTF8(dropText));
-    return YES;
-  }
-
-  return NO;
-}
-
-- (BOOL)prepareForDragOperation:(id<NSDraggingInfo>)sender {
-  return YES;
-}
-
-- (BOOL)performDragOperation:(id<NSDraggingInfo>)sender {
-  [self handleDrop:sender];
-  return YES;
-}
-
-- (void)setNeedsDisplay:(BOOL)display {
-  [self updateAttributedTitle];
-  [super setNeedsDisplay:display];
-}
-
-- (BOOL)shouldHighlight {
-  switch (highlight_mode_) {
-    case atom::TrayIcon::HighlightMode::ALWAYS:
-      return true;
-    case atom::TrayIcon::HighlightMode::NEVER:
-      return false;
-    case atom::TrayIcon::HighlightMode::SELECTION:
-      BOOL isMenuOpen = menuController_ && [menuController_ isMenuOpen];
-      return forceHighlight_ || inMouseEventSequence_ || isMenuOpen;
-  }
-}
-
-@end
-
-namespace atom {
-
-TrayIconCocoa::TrayIconCocoa() {}
-
-TrayIconCocoa::~TrayIconCocoa() {
-  [status_item_view_ removeItem];
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-}
-
-void TrayIconCocoa::SetImage(const gfx::Image& image) {
-  if (status_item_view_) {
-    [status_item_view_ setImage:image.AsNSImage()];
-  } else {
-    status_item_view_.reset(
-        [[StatusItemView alloc] initWithImage:image.AsNSImage() icon:this]);
-  }
-}
-
-void TrayIconCocoa::SetPressedImage(const gfx::Image& image) {
-  [status_item_view_ setAlternateImage:image.AsNSImage()];
-}
-
-void TrayIconCocoa::SetToolTip(const std::string& tool_tip) {
-  [status_item_view_ setToolTip:base::SysUTF8ToNSString(tool_tip)];
-}
-
-void TrayIconCocoa::SetTitle(const std::string& title) {
-  [status_item_view_ setTitle:base::SysUTF8ToNSString(title)];
-}
-
-void TrayIconCocoa::SetHighlightMode(TrayIcon::HighlightMode mode) {
-  [status_item_view_ setHighlight:mode];
-}
-
-void TrayIconCocoa::SetIgnoreDoubleClickEvents(bool ignore) {
-  [status_item_view_ setIgnoreDoubleClickEvents:ignore];
-}
-
-bool TrayIconCocoa::GetIgnoreDoubleClickEvents() {
-  return [status_item_view_ getIgnoreDoubleClickEvents];
-}
-
-void TrayIconCocoa::PopUpContextMenu(const gfx::Point& pos,
-                                     AtomMenuModel* menu_model) {
-  [status_item_view_ popUpContextMenu:menu_model];
-}
-
-void TrayIconCocoa::SetContextMenu(AtomMenuModel* menu_model) {
-  // Substribe to MenuClosed event.
-  if (menu_model_)
-    menu_model_->RemoveObserver(this);
-  menu_model->AddObserver(this);
-
-  // Create native menu.
-  menu_.reset([[AtomMenuController alloc] initWithModel:menu_model
-                                  useDefaultAccelerator:NO]);
-  [status_item_view_ setMenuController:menu_.get()];
-}
-
-gfx::Rect TrayIconCocoa::GetBounds() {
-  auto bounds = gfx::ScreenRectFromNSRect([status_item_view_ window].frame);
-  return bounds;
-}
-
-void TrayIconCocoa::OnMenuWillClose() {
-  [status_item_view_ setNeedsDisplay:YES];
-}
-
-// static
-TrayIcon* TrayIcon::Create() {
-  return new TrayIconCocoa;
-}
-
-}  // namespace atom
removed in remote
  base   100644 666e64101e886bcb1e14b59296ac4b9e743c1aa0 atom/browser/ui/tray_icon_gtk.cc
  our    100644 4c780285c80a157afca74b0927175ba3b045def9 atom/browser/ui/tray_icon_gtk.cc
@@ -1,69 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/tray_icon_gtk.h"
-
-#include "atom/browser/browser.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "brightray/common/application_info.h"
-#include "chrome/browser/ui/libgtkui/app_indicator_icon.h"
-#include "chrome/browser/ui/libgtkui/gtk_status_icon.h"
-#include "ui/gfx/image/image.h"
-
-namespace atom {
-
-namespace {
-
-// Number of app indicators used (used as part of app-indicator id).
-int indicators_count;
-
-}  // namespace
-
-TrayIconGtk::TrayIconGtk() {}
-
-TrayIconGtk::~TrayIconGtk() {}
-
-void TrayIconGtk::SetImage(const gfx::Image& image) {
-  if (icon_) {
-    icon_->SetImage(image.AsImageSkia());
-    return;
-  }
-
-  const auto toolTip = base::UTF8ToUTF16(brightray::GetApplicationName());
-
-  if (libgtkui::AppIndicatorIcon::CouldOpen()) {
-    ++indicators_count;
-    icon_.reset(new libgtkui::AppIndicatorIcon(
-        base::StringPrintf("%s%d", Browser::Get()->GetName().c_str(),
-                           indicators_count),
-        image.AsImageSkia(), toolTip));
-  } else {
-    icon_.reset(new libgtkui::Gtk2StatusIcon(image.AsImageSkia(), toolTip));
-  }
-  icon_->set_delegate(this);
-}
-
-void TrayIconGtk::SetToolTip(const std::string& tool_tip) {
-  icon_->SetToolTip(base::UTF8ToUTF16(tool_tip));
-}
-
-void TrayIconGtk::SetContextMenu(AtomMenuModel* menu_model) {
-  icon_->UpdatePlatformContextMenu(menu_model);
-}
-
-void TrayIconGtk::OnClick() {
-  NotifyClicked();
-}
-
-bool TrayIconGtk::HasClickAction() {
-  return false;
-}
-
-// static
-TrayIcon* TrayIcon::Create() {
-  return new TrayIconGtk;
-}
-
-}  // namespace atom
removed in remote
  base   100644 2be3259f218de502eb8b4d17ddea45fcfdc6af57 atom/browser/ui/tray_icon_gtk.h
  our    100644 cddd0c4b8927d02bf7501a87251b65403cc3a756 atom/browser/ui/tray_icon_gtk.h
@@ -1,41 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "ui/views/linux_ui/status_icon_linux.h"
-
-namespace views {
-class StatusIconLinux;
-}
-
-namespace atom {
-
-class TrayIconGtk : public TrayIcon, public views::StatusIconLinux::Delegate {
- public:
-  TrayIconGtk();
-  ~TrayIconGtk() override;
-
-  // TrayIcon:
-  void SetImage(const gfx::Image& image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-
- private:
-  // views::StatusIconLinux::Delegate:
-  void OnClick() override;
-  bool HasClickAction() override;
-
-  std::unique_ptr<views::StatusIconLinux> icon_;
-
-  DISALLOW_COPY_AND_ASSIGN(TrayIconGtk);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_GTK_H_
removed in remote
  base   100644 ed421ed854529dea76d57bef8b1b01b1962a109f atom/browser/ui/tray_icon_observer.h
  our    100644 feb5fb8cfc7477c0cc399eba65ed4e80571f8248 atom/browser/ui/tray_icon_observer.h
@@ -1,44 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
-#define ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
-
-#include <string>
-#include <vector>
-
-namespace gfx {
-class Rect;
-class Point;
-}  // namespace gfx
-
-namespace atom {
-
-class TrayIconObserver {
- public:
-  virtual void OnClicked(const gfx::Rect& bounds,
-                         const gfx::Point& location,
-                         int modifiers) {}
-  virtual void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {}
-  virtual void OnBalloonShow() {}
-  virtual void OnBalloonClicked() {}
-  virtual void OnBalloonClosed() {}
-  virtual void OnRightClicked(const gfx::Rect& bounds, int modifiers) {}
-  virtual void OnDrop() {}
-  virtual void OnDropFiles(const std::vector<std::string>& files) {}
-  virtual void OnDropText(const std::string& text) {}
-  virtual void OnDragEntered() {}
-  virtual void OnDragExited() {}
-  virtual void OnDragEnded() {}
-  virtual void OnMouseEntered(const gfx::Point& location, int modifiers) {}
-  virtual void OnMouseExited(const gfx::Point& location, int modifiers) {}
-  virtual void OnMouseMoved(const gfx::Point& location, int modifiers) {}
-
- protected:
-  virtual ~TrayIconObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_TRAY_ICON_OBSERVER_H_
removed in remote
  base   100644 82550013ef7a28b19483c189595866ad04411467 atom/browser/ui/tray_icon_win.cc
  our    100644 82550013ef7a28b19483c189595866ad04411467 atom/browser/ui/tray_icon_win.cc
@@ -1,16 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon.h"
-#include "atom/browser/ui/win/notify_icon_host.h"
-
-namespace atom {
-
-// static
-TrayIcon* TrayIcon::Create() {
-  static NotifyIconHost host;
-  return host.CreateNotifyIcon();
-}
-
-}  // namespace atom
removed in remote
  base   100644 2ec4459f6b45b71f084af67d4ac0353016f5eca9 atom/browser/ui/views/frameless_view.cc
  our    100644 8959ee13612979d2819621acc14ebf641fb7f116 atom/browser/ui/views/frameless_view.cc
@@ -1,115 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/frameless_view.h"
-
-#include "atom/browser/native_window_views.h"
-#include "ui/aura/window.h"
-#include "ui/base/hit_test.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/widget/widget_delegate.h"
-
-namespace atom {
-
-namespace {
-
-const int kResizeInsideBoundsSize = 5;
-const int kResizeAreaCornerSize = 16;
-
-}  // namespace
-
-// static
-const char FramelessView::kViewClassName[] = "FramelessView";
-
-FramelessView::FramelessView() {}
-
-FramelessView::~FramelessView() {}
-
-void FramelessView::Init(NativeWindowViews* window, views::Widget* frame) {
-  window_ = window;
-  frame_ = frame;
-}
-
-int FramelessView::ResizingBorderHitTest(const gfx::Point& point) {
-  // Check the frame first, as we allow a small area overlapping the contents
-  // to be used for resize handles.
-  bool can_ever_resize = frame_->widget_delegate()
-                             ? frame_->widget_delegate()->CanResize()
-                             : false;
-  // Don't allow overlapping resize handles when the window is maximized or
-  // fullscreen, as it can't be resized in those states.
-  int resize_border = frame_->IsMaximized() || frame_->IsFullscreen()
-                          ? 0
-                          : kResizeInsideBoundsSize;
-  return GetHTComponentForFrame(point, resize_border, resize_border,
-                                kResizeAreaCornerSize, kResizeAreaCornerSize,
-                                can_ever_resize);
-}
-
-gfx::Rect FramelessView::GetBoundsForClientView() const {
-  return bounds();
-}
-
-gfx::Rect FramelessView::GetWindowBoundsForClientBounds(
-    const gfx::Rect& client_bounds) const {
-  gfx::Rect window_bounds = client_bounds;
-  // Enforce minimum size (1, 1) in case that client_bounds is passed with
-  // empty size. This could occur when the frameless window is being
-  // initialized.
-  if (window_bounds.IsEmpty()) {
-    window_bounds.set_width(1);
-    window_bounds.set_height(1);
-  }
-  return window_bounds;
-}
-
-int FramelessView::NonClientHitTest(const gfx::Point& cursor) {
-  if (frame_->IsFullscreen())
-    return HTCLIENT;
-
-  // Check for possible draggable region in the client area for the frameless
-  // window.
-  SkRegion* draggable_region = window_->draggable_region();
-  if (draggable_region && draggable_region->contains(cursor.x(), cursor.y()))
-    return HTCAPTION;
-
-  // Support resizing frameless window by dragging the border.
-  int frame_component = ResizingBorderHitTest(cursor);
-  if (frame_component != HTNOWHERE)
-    return frame_component;
-
-  return HTCLIENT;
-}
-
-void FramelessView::GetWindowMask(const gfx::Size& size,
-                                  gfx::Path* window_mask) {}
-
-void FramelessView::ResetWindowControls() {}
-
-void FramelessView::UpdateWindowIcon() {}
-
-void FramelessView::UpdateWindowTitle() {}
-
-void FramelessView::SizeConstraintsChanged() {}
-
-gfx::Size FramelessView::CalculatePreferredSize() const {
-  return frame_->non_client_view()
-      ->GetWindowBoundsForClientBounds(
-          gfx::Rect(frame_->client_view()->GetPreferredSize()))
-      .size();
-}
-
-gfx::Size FramelessView::GetMinimumSize() const {
-  return window_->GetContentMinimumSize();
-}
-
-gfx::Size FramelessView::GetMaximumSize() const {
-  return window_->GetContentMaximumSize();
-}
-
-const char* FramelessView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 54dc3285fabc089691ce4d42f38ec6a77b2ab3e5 atom/browser/ui/views/frameless_view.h
  our    100644 a9d1e4b54906eaadc11764fccfb57877893e2a95 atom/browser/ui/views/frameless_view.h
@@ -1,57 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
-
-#include "ui/views/window/non_client_view.h"
-
-namespace views {
-class Widget;
-}
-
-namespace atom {
-
-class NativeWindowViews;
-
-class FramelessView : public views::NonClientFrameView {
- public:
-  static const char kViewClassName[];
-  FramelessView();
-  ~FramelessView() override;
-
-  virtual void Init(NativeWindowViews* window, views::Widget* frame);
-
-  // Returns whether the |point| is on frameless window's resizing border.
-  int ResizingBorderHitTest(const gfx::Point& point);
-
- protected:
-  // views::NonClientFrameView:
-  gfx::Rect GetBoundsForClientView() const override;
-  gfx::Rect GetWindowBoundsForClientBounds(
-      const gfx::Rect& client_bounds) const override;
-  int NonClientHitTest(const gfx::Point& point) override;
-  void GetWindowMask(const gfx::Size& size, gfx::Path* window_mask) override;
-  void ResetWindowControls() override;
-  void UpdateWindowIcon() override;
-  void UpdateWindowTitle() override;
-  void SizeConstraintsChanged() override;
-
-  // Overridden from View:
-  gfx::Size CalculatePreferredSize() const override;
-  gfx::Size GetMinimumSize() const override;
-  gfx::Size GetMaximumSize() const override;
-  const char* GetClassName() const override;
-
-  // Not owned.
-  NativeWindowViews* window_ = nullptr;
-  views::Widget* frame_ = nullptr;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(FramelessView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
removed in remote
  base   100644 b393e3f4657da24d4ca6b53c70c37029c1bfe327 atom/browser/ui/views/global_menu_bar_x11.cc
  our    100644 656bd8f991f87c06a240cdc09a3bfcd500d1c1c8 atom/browser/ui/views/global_menu_bar_x11.cc
@@ -1,336 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
-
-#include <dlfcn.h>
-#include <glib-object.h>
-
-#include "atom/browser/native_window_views.h"
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/logging.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
-#include "ui/aura/window.h"
-#include "ui/aura/window_tree_host.h"
-#include "ui/base/accelerators/menu_label_accelerator_util_linux.h"
-#include "ui/events/keycodes/keyboard_code_conversion_x.h"
-#include "ui/gfx/x/x11.h"
-
-// libdbusmenu-glib types
-typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_func)();
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_with_id_func)(int id);
-
-typedef int (*dbusmenu_menuitem_get_id_func)(DbusmenuMenuitem* item);
-typedef GList* (*dbusmenu_menuitem_get_children_func)(DbusmenuMenuitem* item);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_child_append_func)(
-    DbusmenuMenuitem* parent,
-    DbusmenuMenuitem* child);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    const char* value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_variant_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    GVariant* value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_bool_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    bool value);
-typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_int_func)(
-    DbusmenuMenuitem* item,
-    const char* property,
-    int value);
-
-typedef struct _DbusmenuServer DbusmenuServer;
-typedef DbusmenuServer* (*dbusmenu_server_new_func)(const char* object);
-typedef void (*dbusmenu_server_set_root_func)(DbusmenuServer* self,
-                                              DbusmenuMenuitem* root);
-
-namespace atom {
-
-namespace {
-
-// Retrieved functions from libdbusmenu-glib.
-
-// DbusmenuMenuItem methods:
-dbusmenu_menuitem_new_func menuitem_new = NULL;
-dbusmenu_menuitem_new_with_id_func menuitem_new_with_id = NULL;
-dbusmenu_menuitem_get_id_func menuitem_get_id = NULL;
-dbusmenu_menuitem_get_children_func menuitem_get_children = NULL;
-dbusmenu_menuitem_get_children_func menuitem_take_children = NULL;
-dbusmenu_menuitem_child_append_func menuitem_child_append = NULL;
-dbusmenu_menuitem_property_set_func menuitem_property_set = NULL;
-dbusmenu_menuitem_property_set_variant_func menuitem_property_set_variant =
-    NULL;
-dbusmenu_menuitem_property_set_bool_func menuitem_property_set_bool = NULL;
-dbusmenu_menuitem_property_set_int_func menuitem_property_set_int = NULL;
-
-// DbusmenuServer methods:
-dbusmenu_server_new_func server_new = NULL;
-dbusmenu_server_set_root_func server_set_root = NULL;
-
-// Properties that we set on menu items:
-const char kPropertyEnabled[] = "enabled";
-const char kPropertyLabel[] = "label";
-const char kPropertyShortcut[] = "shortcut";
-const char kPropertyType[] = "type";
-const char kPropertyToggleType[] = "toggle-type";
-const char kPropertyToggleState[] = "toggle-state";
-const char kPropertyVisible[] = "visible";
-const char kPropertyChildrenDisplay[] = "children-display";
-
-const char kToggleCheck[] = "checkmark";
-const char kToggleRadio[] = "radio";
-const char kTypeSeparator[] = "separator";
-const char kDisplaySubmenu[] = "submenu";
-
-void EnsureMethodsLoaded() {
-  static bool attempted_load = false;
-  if (attempted_load)
-    return;
-  attempted_load = true;
-
-  void* dbusmenu_lib = dlopen("libdbusmenu-glib.so", RTLD_LAZY);
-  if (!dbusmenu_lib)
-    dbusmenu_lib = dlopen("libdbusmenu-glib.so.4", RTLD_LAZY);
-  if (!dbusmenu_lib)
-    return;
-
-  // DbusmenuMenuItem methods.
-  menuitem_new = reinterpret_cast<dbusmenu_menuitem_new_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new"));
-  menuitem_new_with_id = reinterpret_cast<dbusmenu_menuitem_new_with_id_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new_with_id"));
-  menuitem_get_id = reinterpret_cast<dbusmenu_menuitem_get_id_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_id"));
-  menuitem_get_children = reinterpret_cast<dbusmenu_menuitem_get_children_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_children"));
-  menuitem_take_children =
-      reinterpret_cast<dbusmenu_menuitem_get_children_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_take_children"));
-  menuitem_child_append = reinterpret_cast<dbusmenu_menuitem_child_append_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_child_append"));
-  menuitem_property_set = reinterpret_cast<dbusmenu_menuitem_property_set_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set"));
-  menuitem_property_set_variant =
-      reinterpret_cast<dbusmenu_menuitem_property_set_variant_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_variant"));
-  menuitem_property_set_bool =
-      reinterpret_cast<dbusmenu_menuitem_property_set_bool_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_bool"));
-  menuitem_property_set_int =
-      reinterpret_cast<dbusmenu_menuitem_property_set_int_func>(
-          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_int"));
-
-  // DbusmenuServer methods.
-  server_new = reinterpret_cast<dbusmenu_server_new_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_server_new"));
-  server_set_root = reinterpret_cast<dbusmenu_server_set_root_func>(
-      dlsym(dbusmenu_lib, "dbusmenu_server_set_root"));
-}
-
-AtomMenuModel* ModelForMenuItem(DbusmenuMenuitem* item) {
-  return reinterpret_cast<AtomMenuModel*>(
-      g_object_get_data(G_OBJECT(item), "model"));
-}
-
-bool GetMenuItemID(DbusmenuMenuitem* item, int* id) {
-  gpointer id_ptr = g_object_get_data(G_OBJECT(item), "menu-id");
-  if (id_ptr != NULL) {
-    *id = GPOINTER_TO_INT(id_ptr) - 1;
-    return true;
-  }
-
-  return false;
-}
-
-void SetMenuItemID(DbusmenuMenuitem* item, int id) {
-  DCHECK_GE(id, 0);
-
-  // Add 1 to the menu_id to avoid setting zero (null) to "menu-id".
-  g_object_set_data(G_OBJECT(item), "menu-id", GINT_TO_POINTER(id + 1));
-}
-
-std::string GetMenuModelStatus(AtomMenuModel* model) {
-  std::string ret;
-  for (int i = 0; i < model->GetItemCount(); ++i) {
-    int status = model->GetTypeAt(i) | (model->IsVisibleAt(i) << 3) |
-                 (model->IsEnabledAt(i) << 4) |
-                 (model->IsItemCheckedAt(i) << 5);
-    ret += base::StringPrintf(
-        "%s-%X\n", base::UTF16ToUTF8(model->GetLabelAt(i)).c_str(), status);
-  }
-  return ret;
-}
-
-}  // namespace
-
-GlobalMenuBarX11::GlobalMenuBarX11(NativeWindowViews* window)
-    : window_(window),
-      xid_(window_->GetNativeWindow()->GetHost()->GetAcceleratedWidget()) {
-  EnsureMethodsLoaded();
-  if (server_new)
-    InitServer(xid_);
-
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
-}
-
-GlobalMenuBarX11::~GlobalMenuBarX11() {
-  if (IsServerStarted())
-    g_object_unref(server_);
-
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
-}
-
-// static
-std::string GlobalMenuBarX11::GetPathForWindow(gfx::AcceleratedWidget xid) {
-  return base::StringPrintf("/com/canonical/menu/%lX", xid);
-}
-
-void GlobalMenuBarX11::SetMenu(AtomMenuModel* menu_model) {
-  if (!IsServerStarted())
-    return;
-
-  DbusmenuMenuitem* root_item = menuitem_new();
-  menuitem_property_set(root_item, kPropertyLabel, "Root");
-  menuitem_property_set_bool(root_item, kPropertyVisible, true);
-  if (menu_model != nullptr) {
-    BuildMenuFromModel(menu_model, root_item);
-  }
-
-  server_set_root(server_, root_item);
-  g_object_unref(root_item);
-}
-
-bool GlobalMenuBarX11::IsServerStarted() const {
-  return server_;
-}
-
-void GlobalMenuBarX11::InitServer(gfx::AcceleratedWidget xid) {
-  std::string path = GetPathForWindow(xid);
-  server_ = server_new(path.c_str());
-}
-
-void GlobalMenuBarX11::OnWindowMapped() {
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
-}
-
-void GlobalMenuBarX11::OnWindowUnmapped() {
-  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
-}
-
-void GlobalMenuBarX11::BuildMenuFromModel(AtomMenuModel* model,
-                                          DbusmenuMenuitem* parent) {
-  for (int i = 0; i < model->GetItemCount(); ++i) {
-    DbusmenuMenuitem* item = menuitem_new();
-    menuitem_property_set_bool(item, kPropertyVisible, model->IsVisibleAt(i));
-
-    AtomMenuModel::ItemType type = model->GetTypeAt(i);
-    if (type == AtomMenuModel::TYPE_SEPARATOR) {
-      menuitem_property_set(item, kPropertyType, kTypeSeparator);
-    } else {
-      std::string label = ui::ConvertAcceleratorsFromWindowsStyle(
-          base::UTF16ToUTF8(model->GetLabelAt(i)));
-      menuitem_property_set(item, kPropertyLabel, label.c_str());
-      menuitem_property_set_bool(item, kPropertyEnabled, model->IsEnabledAt(i));
-
-      g_object_set_data(G_OBJECT(item), "model", model);
-      SetMenuItemID(item, i);
-
-      if (type == AtomMenuModel::TYPE_SUBMENU) {
-        menuitem_property_set(item, kPropertyChildrenDisplay, kDisplaySubmenu);
-        g_signal_connect(item, "about-to-show", G_CALLBACK(OnSubMenuShowThunk),
-                         this);
-      } else {
-        ui::Accelerator accelerator;
-        if (model->GetAcceleratorAtWithParams(i, true, &accelerator))
-          RegisterAccelerator(item, accelerator);
-
-        g_signal_connect(item, "item-activated",
-                         G_CALLBACK(OnItemActivatedThunk), this);
-
-        if (type == AtomMenuModel::TYPE_CHECK ||
-            type == AtomMenuModel::TYPE_RADIO) {
-          menuitem_property_set(
-              item, kPropertyToggleType,
-              type == AtomMenuModel::TYPE_CHECK ? kToggleCheck : kToggleRadio);
-          menuitem_property_set_int(item, kPropertyToggleState,
-                                    model->IsItemCheckedAt(i));
-        }
-      }
-    }
-
-    menuitem_child_append(parent, item);
-    g_object_unref(item);
-  }
-}
-
-void GlobalMenuBarX11::RegisterAccelerator(DbusmenuMenuitem* item,
-                                           const ui::Accelerator& accelerator) {
-  // A translation of libdbusmenu-gtk's menuitem_property_set_shortcut()
-  // translated from GDK types to ui::Accelerator types.
-  GVariantBuilder builder;
-  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
-
-  if (accelerator.IsCtrlDown())
-    g_variant_builder_add(&builder, "s", "Control");
-  if (accelerator.IsAltDown())
-    g_variant_builder_add(&builder, "s", "Alt");
-  if (accelerator.IsShiftDown())
-    g_variant_builder_add(&builder, "s", "Shift");
-
-  char* name =
-      XKeysymToString(XKeysymForWindowsKeyCode(accelerator.key_code(), false));
-  if (!name) {
-    NOTIMPLEMENTED();
-    return;
-  }
-  g_variant_builder_add(&builder, "s", name);
-
-  GVariant* inside_array = g_variant_builder_end(&builder);
-  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
-  g_variant_builder_add_value(&builder, inside_array);
-  GVariant* outside_array = g_variant_builder_end(&builder);
-
-  menuitem_property_set_variant(item, kPropertyShortcut, outside_array);
-}
-
-void GlobalMenuBarX11::OnItemActivated(DbusmenuMenuitem* item,
-                                       unsigned int timestamp) {
-  int id;
-  AtomMenuModel* model = ModelForMenuItem(item);
-  if (model && GetMenuItemID(item, &id))
-    model->ActivatedAt(id, 0);
-}
-
-void GlobalMenuBarX11::OnSubMenuShow(DbusmenuMenuitem* item) {
-  int id;
-  AtomMenuModel* model = ModelForMenuItem(item);
-  if (!model || !GetMenuItemID(item, &id))
-    return;
-
-  // Do not update menu if the submenu has not been changed.
-  std::string status = GetMenuModelStatus(model);
-  char* old = static_cast<char*>(g_object_get_data(G_OBJECT(item), "status"));
-  if (old && status == old)
-    return;
-
-  // Save the new status.
-  g_object_set_data_full(G_OBJECT(item), "status", g_strdup(status.c_str()),
-                         g_free);
-
-  // Clear children.
-  GList* children = menuitem_take_children(item);
-  g_list_foreach(children, reinterpret_cast<GFunc>(g_object_unref), NULL);
-  g_list_free(children);
-
-  // Build children.
-  BuildMenuFromModel(model->GetSubmenuModelAt(id), item);
-}
-
-}  // namespace atom
removed in remote
  base   100644 89b2680cabebf967a45a5bfaea56151d8cc0a1e9 atom/browser/ui/views/global_menu_bar_x11.h
  our    100644 dde466c94e8297e8c629152658c844fe4d3600b4 atom/browser/ui/views/global_menu_bar_x11.h
@@ -1,81 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
-#define ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
-
-#include <string>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "ui/base/glib/glib_signal.h"
-#include "ui/gfx/native_widget_types.h"
-
-typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
-typedef struct _DbusmenuServer DbusmenuServer;
-
-namespace ui {
-class Accelerator;
-}
-
-namespace atom {
-
-class NativeWindowViews;
-
-// Controls the Mac style menu bar on Unity.
-//
-// Unity has an Apple-like menu bar at the top of the screen that changes
-// depending on the active window. In the GTK port, we had a hidden GtkMenuBar
-// object in each GtkWindow which existed only to be scrapped by the
-// libdbusmenu-gtk code. Since we don't have GtkWindows anymore, we need to
-// interface directly with the lower level libdbusmenu-glib, which we
-// opportunistically dlopen() since not everyone is running Ubuntu.
-//
-// This class is like the chrome's corresponding one, but it generates the menu
-// from menu models instead, and it is also per-window specific.
-class GlobalMenuBarX11 {
- public:
-  explicit GlobalMenuBarX11(NativeWindowViews* window);
-  virtual ~GlobalMenuBarX11();
-
-  // Creates the object path for DbusmenuServer which is attached to |xid|.
-  static std::string GetPathForWindow(gfx::AcceleratedWidget xid);
-
-  void SetMenu(AtomMenuModel* menu_model);
-  bool IsServerStarted() const;
-
-  // Called by NativeWindow when it show/hides.
-  void OnWindowMapped();
-  void OnWindowUnmapped();
-
- private:
-  // Creates a DbusmenuServer.
-  void InitServer(gfx::AcceleratedWidget xid);
-
-  // Create a menu from menu model.
-  void BuildMenuFromModel(AtomMenuModel* model, DbusmenuMenuitem* parent);
-
-  // Sets the accelerator for |item|.
-  void RegisterAccelerator(DbusmenuMenuitem* item,
-                           const ui::Accelerator& accelerator);
-
-  CHROMEG_CALLBACK_1(GlobalMenuBarX11,
-                     void,
-                     OnItemActivated,
-                     DbusmenuMenuitem*,
-                     unsigned int);
-  CHROMEG_CALLBACK_0(GlobalMenuBarX11, void, OnSubMenuShow, DbusmenuMenuitem*);
-
-  NativeWindowViews* window_;
-  gfx::AcceleratedWidget xid_;
-
-  DbusmenuServer* server_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(GlobalMenuBarX11);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
removed in remote
  base   100644 ba0a542c1e8df91a5be321b6ca2967f500421000 atom/browser/ui/views/menu_bar.cc
  our    100644 e838d3cc217b5ffdb77226beff0d7217539f23f9 atom/browser/ui/views/menu_bar.cc
@@ -1,187 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/menu_bar.h"
-
-#include "atom/browser/ui/views/menu_delegate.h"
-#include "atom/browser/ui/views/submenu_button.h"
-#include "ui/base/models/menu_model.h"
-#include "ui/views/background.h"
-#include "ui/views/layout/box_layout.h"
-
-#if defined(OS_WIN)
-#include "ui/gfx/color_utils.h"
-#endif
-
-namespace atom {
-
-namespace {
-
-// Default color of the menu bar.
-const SkColor kDefaultColor = SkColorSetARGB(255, 233, 233, 233);
-
-}  // namespace
-
-const char MenuBar::kViewClassName[] = "ElectronMenuBar";
-
-MenuBar::MenuBar(views::View* window)
-    : background_color_(kDefaultColor), window_(window) {
-  RefreshColorCache();
-  UpdateViewColors();
-  SetLayoutManager(
-      std::make_unique<views::BoxLayout>(views::BoxLayout::kHorizontal));
-  window_->GetFocusManager()->AddFocusChangeListener(this);
-}
-
-MenuBar::~MenuBar() {
-  window_->GetFocusManager()->RemoveFocusChangeListener(this);
-}
-
-void MenuBar::SetMenu(AtomMenuModel* model) {
-  menu_model_ = model;
-  RebuildChildren();
-}
-
-void MenuBar::SetAcceleratorVisibility(bool visible) {
-  for (auto* child : GetChildrenInZOrder())
-    static_cast<SubmenuButton*>(child)->SetAcceleratorVisibility(visible);
-}
-
-MenuBar::View* MenuBar::FindAccelChild(base::char16 key) {
-  for (auto* child : GetChildrenInZOrder()) {
-    if (static_cast<SubmenuButton*>(child)->accelerator() == key)
-      return child;
-  }
-  return nullptr;
-}
-
-bool MenuBar::HasAccelerator(base::char16 key) {
-  return FindAccelChild(key) != nullptr;
-}
-
-void MenuBar::ActivateAccelerator(base::char16 key) {
-  auto* child = FindAccelChild(key);
-  if (child)
-    static_cast<SubmenuButton*>(child)->Activate(nullptr);
-}
-
-int MenuBar::GetItemCount() const {
-  return menu_model_ ? menu_model_->GetItemCount() : 0;
-}
-
-bool MenuBar::GetMenuButtonFromScreenPoint(const gfx::Point& screenPoint,
-                                           AtomMenuModel** menu_model,
-                                           views::MenuButton** button) {
-  if (!GetBoundsInScreen().Contains(screenPoint))
-    return false;
-
-  auto children = GetChildrenInZOrder();
-  for (int i = 0, n = children.size(); i < n; ++i) {
-    if (children[i]->GetBoundsInScreen().Contains(screenPoint) &&
-        (menu_model_->GetTypeAt(i) == AtomMenuModel::TYPE_SUBMENU)) {
-      *menu_model = menu_model_->GetSubmenuModelAt(i);
-      *button = static_cast<views::MenuButton*>(children[i]);
-      return true;
-    }
-  }
-
-  return false;
-}
-
-const char* MenuBar::GetClassName() const {
-  return kViewClassName;
-}
-
-void MenuBar::OnMenuButtonClicked(views::MenuButton* source,
-                                  const gfx::Point& point,
-                                  const ui::Event* event) {
-  // Hide the accelerator when a submenu is activated.
-  SetAcceleratorVisibility(false);
-
-  if (!menu_model_)
-    return;
-
-  if (!window_->HasFocus())
-    window_->RequestFocus();
-
-  int id = source->tag();
-  AtomMenuModel::ItemType type = menu_model_->GetTypeAt(id);
-  if (type != AtomMenuModel::TYPE_SUBMENU) {
-    menu_model_->ActivatedAt(id, 0);
-    return;
-  }
-
-  // Deleted in MenuDelegate::OnMenuClosed
-  MenuDelegate* menu_delegate = new MenuDelegate(this);
-  menu_delegate->RunMenu(menu_model_->GetSubmenuModelAt(id), source);
-}
-
-void MenuBar::RefreshColorCache(const ui::NativeTheme* theme) {
-  if (!theme)
-    theme = ui::NativeTheme::GetInstanceForNativeUi();
-  if (theme) {
-    background_color_ =
-        theme->GetSystemColor(ui::NativeTheme::kColorId_MenuBackgroundColor);
-#if defined(USE_X11)
-    enabled_color_ = theme->GetSystemColor(
-        ui::NativeTheme::kColorId_EnabledMenuItemForegroundColor);
-    disabled_color_ = theme->GetSystemColor(
-        ui::NativeTheme::kColorId_DisabledMenuItemForegroundColor);
-#endif
-  }
-#if defined(OS_WIN)
-  background_color_ = color_utils::GetSysSkColor(COLOR_MENUBAR);
-#endif
-}
-
-void MenuBar::OnNativeThemeChanged(const ui::NativeTheme* theme) {
-  RefreshColorCache(theme);
-  UpdateViewColors();
-}
-
-void MenuBar::OnDidChangeFocus(View* focused_before, View* focused_now) {
-  // if we've changed focus, update our view
-  const auto had_focus = has_focus_;
-  has_focus_ = focused_now != nullptr;
-  if (has_focus_ != had_focus)
-    UpdateViewColors();
-}
-
-void MenuBar::RebuildChildren() {
-  RemoveAllChildViews(true);
-  for (int i = 0, n = GetItemCount(); i < n; ++i) {
-    auto* button =
-        new SubmenuButton(menu_model_->GetLabelAt(i), this, background_color_);
-    button->set_tag(i);
-    AddChildView(button);
-  }
-  UpdateViewColors();
-}
-
-void MenuBar::UpdateViewColors() {
-  // set menubar background color
-  SetBackground(views::CreateSolidBackground(background_color_));
-
-  // set child colors
-  if (menu_model_ == nullptr)
-    return;
-#if defined(USE_X11)
-  const auto& textColor = has_focus_ ? enabled_color_ : disabled_color_;
-  for (auto* child : GetChildrenInZOrder()) {
-    auto* button = static_cast<SubmenuButton*>(child);
-    button->SetTextColor(views::Button::STATE_NORMAL, textColor);
-    button->SetTextColor(views::Button::STATE_DISABLED, disabled_color_);
-    button->SetTextColor(views::Button::STATE_PRESSED, enabled_color_);
-    button->SetTextColor(views::Button::STATE_HOVERED, textColor);
-    button->SetUnderlineColor(textColor);
-  }
-#elif defined(OS_WIN)
-  for (auto* child : GetChildrenInZOrder()) {
-    auto* button = static_cast<SubmenuButton*>(child);
-    button->SetUnderlineColor(color_utils::GetSysSkColor(COLOR_MENUTEXT));
-  }
-#endif
-}
-
-}  // namespace atom
removed in remote
  base   100644 9d77cfdf2a22c7927132e91eaa06fc030731a26e atom/browser/ui/views/menu_bar.h
  our    100644 2b10ba3e3bf2ccfc0453fdb59ad022ef7da8ed5b atom/browser/ui/views/menu_bar.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
-#define ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/views/controls/button/menu_button_listener.h"
-#include "ui/views/focus/focus_manager.h"
-#include "ui/views/view.h"
-
-namespace views {
-class MenuButton;
-}
-
-namespace atom {
-
-class MenuDelegate;
-
-class MenuBar : public views::View,
-                public views::MenuButtonListener,
-                public views::FocusChangeListener {
- public:
-  static const char kViewClassName[];
-
-  explicit MenuBar(views::View* window);
-  ~MenuBar() override;
-
-  // Replaces current menu with a new one.
-  void SetMenu(AtomMenuModel* menu_model);
-
-  // Shows underline under accelerators.
-  void SetAcceleratorVisibility(bool visible);
-
-  // Returns true if the submenu has accelerator |key|
-  bool HasAccelerator(base::char16 key);
-
-  // Shows the submenu whose accelerator is |key|.
-  void ActivateAccelerator(base::char16 key);
-
-  // Returns there are how many items in the root menu.
-  int GetItemCount() const;
-
-  // Get the menu under specified screen point.
-  bool GetMenuButtonFromScreenPoint(const gfx::Point& point,
-                                    AtomMenuModel** menu_model,
-                                    views::MenuButton** button);
-
- protected:
-  // views::View:
-  const char* GetClassName() const override;
-
-  // views::MenuButtonListener:
-  void OnMenuButtonClicked(views::MenuButton* source,
-                           const gfx::Point& point,
-                           const ui::Event* event) override;
-  void OnNativeThemeChanged(const ui::NativeTheme* theme) override;
-
-  // views::FocusChangeListener:
-  void OnDidChangeFocus(View* focused_before, View* focused_now) override;
-  void OnWillChangeFocus(View* focused_before, View* focused_now) override {}
-
- private:
-  void RebuildChildren();
-  void UpdateViewColors();
-
-  void RefreshColorCache(const ui::NativeTheme* theme = nullptr);
-  SkColor background_color_;
-#if defined(USE_X11)
-  SkColor enabled_color_;
-  SkColor disabled_color_;
-#endif
-
-  views::View* window_ = nullptr;
-  AtomMenuModel* menu_model_ = nullptr;
-
-  View* FindAccelChild(base::char16 key);
-
-  bool has_focus_ = true;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuBar);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_MENU_BAR_H_
removed in remote
  base   100644 f0ecf13b36b65aa96bee3e55ee459a9d3dad2aaf atom/browser/ui/views/menu_delegate.cc
  our    100644 d8cb592293a765d96f1c9c743535224835d8476a atom/browser/ui/views/menu_delegate.cc
@@ -1,125 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/menu_delegate.h"
-
-#include "atom/browser/ui/views/menu_bar.h"
-#include "atom/browser/ui/views/menu_model_adapter.h"
-#include "content/public/browser/browser_thread.h"
-#include "ui/views/controls/button/menu_button.h"
-#include "ui/views/controls/menu/menu_item_view.h"
-#include "ui/views/controls/menu/menu_runner.h"
-#include "ui/views/widget/widget.h"
-
-namespace atom {
-
-MenuDelegate::MenuDelegate(MenuBar* menu_bar) : menu_bar_(menu_bar), id_(-1) {}
-
-MenuDelegate::~MenuDelegate() {}
-
-void MenuDelegate::RunMenu(AtomMenuModel* model, views::MenuButton* button) {
-  gfx::Point screen_loc;
-  views::View::ConvertPointToScreen(button, &screen_loc);
-  // Subtract 1 from the height to make the popup flush with the button border.
-  gfx::Rect bounds(screen_loc.x(), screen_loc.y(), button->width(),
-                   button->height() - 1);
-
-  id_ = button->tag();
-  adapter_.reset(new MenuModelAdapter(model));
-
-  views::MenuItemView* item = new views::MenuItemView(this);
-  static_cast<MenuModelAdapter*>(adapter_.get())->BuildMenu(item);
-
-  menu_runner_.reset(new views::MenuRunner(
-      item,
-      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
-  menu_runner_->RunMenuAt(button->GetWidget()->GetTopLevelWidget(), button,
-                          bounds, views::MENU_ANCHOR_TOPRIGHT,
-                          ui::MENU_SOURCE_MOUSE);
-}
-
-void MenuDelegate::ExecuteCommand(int id) {
-  adapter_->ExecuteCommand(id);
-}
-
-void MenuDelegate::ExecuteCommand(int id, int mouse_event_flags) {
-  adapter_->ExecuteCommand(id, mouse_event_flags);
-}
-
-bool MenuDelegate::IsTriggerableEvent(views::MenuItemView* source,
-                                      const ui::Event& e) {
-  return adapter_->IsTriggerableEvent(source, e);
-}
-
-bool MenuDelegate::GetAccelerator(int id, ui::Accelerator* accelerator) const {
-  return adapter_->GetAccelerator(id, accelerator);
-}
-
-base::string16 MenuDelegate::GetLabel(int id) const {
-  return adapter_->GetLabel(id);
-}
-
-const gfx::FontList* MenuDelegate::GetLabelFontList(int id) const {
-  return adapter_->GetLabelFontList(id);
-}
-
-bool MenuDelegate::IsCommandEnabled(int id) const {
-  return adapter_->IsCommandEnabled(id);
-}
-
-bool MenuDelegate::IsCommandVisible(int id) const {
-  return adapter_->IsCommandVisible(id);
-}
-
-bool MenuDelegate::IsItemChecked(int id) const {
-  return adapter_->IsItemChecked(id);
-}
-
-void MenuDelegate::SelectionChanged(views::MenuItemView* menu) {
-  adapter_->SelectionChanged(menu);
-}
-
-void MenuDelegate::WillShowMenu(views::MenuItemView* menu) {
-  adapter_->WillShowMenu(menu);
-}
-
-void MenuDelegate::WillHideMenu(views::MenuItemView* menu) {
-  adapter_->WillHideMenu(menu);
-}
-
-void MenuDelegate::OnMenuClosed(views::MenuItemView* menu) {
-  // Only switch to new menu when current menu is closed.
-  if (button_to_open_)
-    button_to_open_->Activate(nullptr);
-  delete this;
-}
-
-views::MenuItemView* MenuDelegate::GetSiblingMenu(
-    views::MenuItemView* menu,
-    const gfx::Point& screen_point,
-    views::MenuAnchorPosition* anchor,
-    bool* has_mnemonics,
-    views::MenuButton**) {
-  // TODO(zcbenz): We should follow Chromium's logics on implementing the
-  // sibling menu switches, this code is almost a hack.
-  views::MenuButton* button;
-  AtomMenuModel* model;
-  if (menu_bar_->GetMenuButtonFromScreenPoint(screen_point, &model, &button) &&
-      button->tag() != id_) {
-    bool switch_in_progress = !!button_to_open_;
-    // Always update target to open.
-    button_to_open_ = button;
-    // Switching menu asyncnously to avoid crash.
-    if (!switch_in_progress) {
-      content::BrowserThread::PostTask(
-          content::BrowserThread::UI, FROM_HERE,
-          base::Bind(&views::MenuRunner::Cancel,
-                     base::Unretained(menu_runner_.get())));
-    }
-  }
-
-  return nullptr;
-}
-
-}  // namespace atom
removed in remote
  base   100644 211ddb57bc39086d183aeb96cce683cc901a99c7 atom/browser/ui/views/menu_delegate.h
  our    100644 e23262a3aa7f6a5ff5ea0ba30b3b3f17c7c51735 atom/browser/ui/views/menu_delegate.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
-#define ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
-
-#include <memory>
-
-#include "atom/browser/ui/atom_menu_model.h"
-#include "ui/views/controls/menu/menu_delegate.h"
-
-namespace views {
-class MenuRunner;
-}
-
-namespace atom {
-
-class MenuBar;
-
-class MenuDelegate : public views::MenuDelegate {
- public:
-  explicit MenuDelegate(MenuBar* menu_bar);
-  ~MenuDelegate() override;
-
-  void RunMenu(AtomMenuModel* model, views::MenuButton* button);
-
- protected:
-  // views::MenuDelegate:
-  void ExecuteCommand(int id) override;
-  void ExecuteCommand(int id, int mouse_event_flags) override;
-  bool IsTriggerableEvent(views::MenuItemView* source,
-                          const ui::Event& e) override;
-  bool GetAccelerator(int id, ui::Accelerator* accelerator) const override;
-  base::string16 GetLabel(int id) const override;
-  const gfx::FontList* GetLabelFontList(int id) const override;
-  bool IsCommandEnabled(int id) const override;
-  bool IsCommandVisible(int id) const override;
-  bool IsItemChecked(int id) const override;
-  void SelectionChanged(views::MenuItemView* menu) override;
-  void WillShowMenu(views::MenuItemView* menu) override;
-  void WillHideMenu(views::MenuItemView* menu) override;
-  void OnMenuClosed(views::MenuItemView* menu) override;
-  views::MenuItemView* GetSiblingMenu(views::MenuItemView* menu,
-                                      const gfx::Point& screen_point,
-                                      views::MenuAnchorPosition* anchor,
-                                      bool* has_mnemonics,
-                                      views::MenuButton** button) override;
-
- private:
-  MenuBar* menu_bar_;
-  int id_;
-  std::unique_ptr<views::MenuDelegate> adapter_;
-  std::unique_ptr<views::MenuRunner> menu_runner_;
-
-  // The menu button to switch to.
-  views::MenuButton* button_to_open_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(MenuDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
removed in remote
  base   100644 134255f48458c86a7993e5924c26c64eeaf3aada atom/browser/ui/views/native_frame_view.cc
  our    100644 2501373851a6ee76d568ffb113bc728cf147a452 atom/browser/ui/views/native_frame_view.cc
@@ -1,28 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/native_frame_view.h"
-
-#include "atom/browser/native_window.h"
-
-namespace atom {
-
-const char NativeFrameView::kViewClassName[] = "AtomNativeFrameView";
-
-NativeFrameView::NativeFrameView(NativeWindow* window, views::Widget* widget)
-    : views::NativeFrameView(widget), window_(window) {}
-
-gfx::Size NativeFrameView::GetMinimumSize() const {
-  return window_->GetMinimumSize();
-}
-
-gfx::Size NativeFrameView::GetMaximumSize() const {
-  return window_->GetMaximumSize();
-}
-
-const char* NativeFrameView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 670459f1cbd0a42fef1f6ec31ad8705092fc73a6 atom/browser/ui/views/native_frame_view.h
  our    100644 22aa0ff94e82d76be109ffcdc708611e12b1c7ea atom/browser/ui/views/native_frame_view.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
-
-#include "ui/views/window/native_frame_view.h"
-
-namespace atom {
-
-class NativeWindow;
-
-// Like the views::NativeFrameView, but returns the min/max size from the
-// NativeWindowViews.
-class NativeFrameView : public views::NativeFrameView {
- public:
-  static const char kViewClassName[];
-  NativeFrameView(NativeWindow* window, views::Widget* widget);
-
- protected:
-  // views::View:
-  gfx::Size GetMinimumSize() const override;
-  gfx::Size GetMaximumSize() const override;
-  const char* GetClassName() const override;
-
- private:
-  NativeWindow* window_;  // weak ref.
-
-  DISALLOW_COPY_AND_ASSIGN(NativeFrameView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
removed in remote
  base   100644 72cab258cbecc9219b0fc508cb5d7e65ab642ab2 atom/browser/ui/views/submenu_button.cc
  our    100644 1124d3d01471876fefa2757570ba3cff796a991c atom/browser/ui/views/submenu_button.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/submenu_button.h"
-
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "ui/gfx/canvas.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/gfx/text_utils.h"
-#include "ui/views/animation/flood_fill_ink_drop_ripple.h"
-#include "ui/views/animation/ink_drop_host_view.h"
-#include "ui/views/animation/ink_drop_impl.h"
-#include "ui/views/controls/button/label_button_border.h"
-
-namespace atom {
-
-SubmenuButton::SubmenuButton(const base::string16& title,
-                             views::MenuButtonListener* menu_button_listener,
-                             const SkColor& background_color)
-    : views::MenuButton(gfx::RemoveAcceleratorChar(title, '&', NULL, NULL),
-                        menu_button_listener,
-                        false),
-      background_color_(background_color) {
-#if defined(OS_LINUX)
-  // Dont' use native style border.
-  SetBorder(CreateDefaultBorder());
-#endif
-
-  if (GetUnderlinePosition(title, &accelerator_, &underline_start_,
-                           &underline_end_))
-    gfx::Canvas::SizeStringInt(GetText(), gfx::FontList(), &text_width_,
-                               &text_height_, 0, 0);
-
-  SetInkDropMode(InkDropMode::ON);
-  set_ink_drop_base_color(
-      color_utils::BlendTowardOppositeLuma(background_color_, 0x61));
-}
-
-SubmenuButton::~SubmenuButton() {}
-
-std::unique_ptr<views::InkDropRipple> SubmenuButton::CreateInkDropRipple()
-    const {
-  std::unique_ptr<views::InkDropRipple> ripple(
-      new views::FloodFillInkDropRipple(
-          size(), GetInkDropCenterBasedOnLastEvent(), GetInkDropBaseColor(),
-          ink_drop_visible_opacity()));
-  return ripple;
-}
-
-std::unique_ptr<views::InkDrop> SubmenuButton::CreateInkDrop() {
-  std::unique_ptr<views::InkDropImpl> ink_drop =
-      views::Button::CreateDefaultInkDropImpl();
-  ink_drop->SetShowHighlightOnHover(false);
-  return std::move(ink_drop);
-}
-
-void SubmenuButton::SetAcceleratorVisibility(bool visible) {
-  if (visible == show_underline_)
-    return;
-
-  show_underline_ = visible;
-  SchedulePaint();
-}
-
-void SubmenuButton::SetUnderlineColor(SkColor color) {
-  underline_color_ = color;
-}
-
-void SubmenuButton::PaintButtonContents(gfx::Canvas* canvas) {
-  views::MenuButton::PaintButtonContents(canvas);
-
-  if (show_underline_ && (underline_start_ != underline_end_)) {
-    int padding = (width() - text_width_) / 2;
-    int underline_height = (height() + text_height_) / 2 - 2;
-    canvas->DrawLine(gfx::Point(underline_start_ + padding, underline_height),
-                     gfx::Point(underline_end_ + padding, underline_height),
-                     underline_color_);
-  }
-}
-
-bool SubmenuButton::GetUnderlinePosition(const base::string16& text,
-                                         base::char16* accelerator,
-                                         int* start,
-                                         int* end) const {
-  int pos, span;
-  base::string16 trimmed = gfx::RemoveAcceleratorChar(text, '&', &pos, &span);
-  if (pos > -1 && span != 0) {
-    *accelerator = base::ToUpperASCII(trimmed[pos]);
-    GetCharacterPosition(trimmed, pos, start);
-    GetCharacterPosition(trimmed, pos + span, end);
-    return true;
-  }
-
-  return false;
-}
-
-void SubmenuButton::GetCharacterPosition(const base::string16& text,
-                                         int index,
-                                         int* pos) const {
-  int height = 0;
-  gfx::Canvas::SizeStringInt(text.substr(0, index), gfx::FontList(), pos,
-                             &height, 0, 0);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3f72a60c10b499e42c9a2b63218397911f17910e atom/browser/ui/views/submenu_button.h
  our    100644 d8b7785da131271e88533879d090badfd6e49dd5 atom/browser/ui/views/submenu_button.h
@@ -1,58 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
-#define ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
-
-#include "ui/views/animation/ink_drop_highlight.h"
-#include "ui/views/controls/button/menu_button.h"
-
-namespace atom {
-
-// Special button that used by menu bar to show submenus.
-class SubmenuButton : public views::MenuButton {
- public:
-  SubmenuButton(const base::string16& title,
-                views::MenuButtonListener* menu_button_listener,
-                const SkColor& background_color);
-  ~SubmenuButton() override;
-
-  void SetAcceleratorVisibility(bool visible);
-  void SetUnderlineColor(SkColor color);
-
-  base::char16 accelerator() const { return accelerator_; }
-
-  // views::MenuButton:
-  void PaintButtonContents(gfx::Canvas* canvas) override;
-
-  // views::InkDropHostView:
-  std::unique_ptr<views::InkDropRipple> CreateInkDropRipple() const override;
-  std::unique_ptr<views::InkDrop> CreateInkDrop() override;
-
- private:
-  bool GetUnderlinePosition(const base::string16& text,
-                            base::char16* accelerator,
-                            int* start,
-                            int* end) const;
-  void GetCharacterPosition(const base::string16& text,
-                            int index,
-                            int* pos) const;
-
-  base::char16 accelerator_ = 0;
-
-  bool show_underline_ = false;
-
-  int underline_start_ = 0;
-  int underline_end_ = 0;
-  int text_width_ = 0;
-  int text_height_ = 0;
-  SkColor underline_color_ = SK_ColorBLACK;
-  SkColor background_color_;
-
-  DISALLOW_COPY_AND_ASSIGN(SubmenuButton);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
removed in remote
  base   100644 fca7cb23347c6d2fbc056384fcec9de5bcdb2501 atom/browser/ui/views/win_frame_view.cc
  our    100644 8f2139cb90fab876a1db1b17cac016997a3904ba atom/browser/ui/views/win_frame_view.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/views/win_frame_view.h"
-
-#include "atom/browser/native_window_views.h"
-#include "ui/views/widget/widget.h"
-#include "ui/views/win/hwnd_util.h"
-
-namespace atom {
-
-const char WinFrameView::kViewClassName[] = "WinFrameView";
-
-WinFrameView::WinFrameView() {}
-
-WinFrameView::~WinFrameView() {}
-
-gfx::Rect WinFrameView::GetWindowBoundsForClientBounds(
-    const gfx::Rect& client_bounds) const {
-  return views::GetWindowBoundsForClientBounds(
-      static_cast<views::View*>(const_cast<WinFrameView*>(this)),
-      client_bounds);
-}
-
-int WinFrameView::NonClientHitTest(const gfx::Point& point) {
-  if (window_->has_frame())
-    return frame_->client_view()->NonClientHitTest(point);
-  else
-    return FramelessView::NonClientHitTest(point);
-}
-
-const char* WinFrameView::GetClassName() const {
-  return kViewClassName;
-}
-
-}  // namespace atom
removed in remote
  base   100644 b2c1ef3a15de9a222233a27193ed811a8add09f6 atom/browser/ui/views/win_frame_view.h
  our    100644 a6ffd7f363304913bb124908f138258bb804e56f atom/browser/ui/views/win_frame_view.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
-#define ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
-
-#include "atom/browser/ui/views/frameless_view.h"
-
-namespace atom {
-
-class WinFrameView : public FramelessView {
- public:
-  static const char kViewClassName[];
-  WinFrameView();
-  ~WinFrameView() override;
-
-  // views::NonClientFrameView:
-  gfx::Rect GetWindowBoundsForClientBounds(
-      const gfx::Rect& client_bounds) const override;
-  int NonClientHitTest(const gfx::Point& point) override;
-
-  // views::View:
-  const char* GetClassName() const override;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(WinFrameView);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
removed in remote
  base   100644 84a6d9aa3e50ced33616fb4b78e124f39461cd0e atom/browser/ui/win/atom_desktop_window_tree_host_win.cc
  our    100644 97857d6515aa5617cf8c1972690a1dcdfd645ac1 atom/browser/ui/win/atom_desktop_window_tree_host_win.cc
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/atom_desktop_window_tree_host_win.h"
-
-#include "atom/browser/ui/win/message_handler_delegate.h"
-
-namespace atom {
-
-AtomDesktopWindowTreeHostWin::AtomDesktopWindowTreeHostWin(
-    MessageHandlerDelegate* delegate,
-    views::internal::NativeWidgetDelegate* native_widget_delegate,
-    views::DesktopNativeWidgetAura* desktop_native_widget_aura)
-    : views::DesktopWindowTreeHostWin(native_widget_delegate,
-                                      desktop_native_widget_aura),
-      delegate_(delegate) {}
-
-AtomDesktopWindowTreeHostWin::~AtomDesktopWindowTreeHostWin() {}
-
-bool AtomDesktopWindowTreeHostWin::PreHandleMSG(UINT message,
-                                                WPARAM w_param,
-                                                LPARAM l_param,
-                                                LRESULT* result) {
-  return delegate_->PreHandleMSG(message, w_param, l_param, result);
-}
-
-bool AtomDesktopWindowTreeHostWin::HasNativeFrame() const {
-  // Since we never use chromium's titlebar implementation, we can just say
-  // that we use a native titlebar. This will disable the repaint locking when
-  // DWM composition is disabled.
-  return true;
-}
-
-}  // namespace atom
removed in remote
  base   100644 47e4cb6aed2a962bfdd2a92edaca74b452d15c4d atom/browser/ui/win/atom_desktop_window_tree_host_win.h
  our    100644 30af3cc162b4429cb3335c6864b801eac1d5f963 atom/browser/ui/win/atom_desktop_window_tree_host_win.h
@@ -1,42 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
-#define ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
-
-#include <windows.h>
-
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
-
-namespace atom {
-
-class MessageHandlerDelegate;
-
-class AtomDesktopWindowTreeHostWin : public views::DesktopWindowTreeHostWin {
- public:
-  AtomDesktopWindowTreeHostWin(
-      MessageHandlerDelegate* delegate,
-      views::internal::NativeWidgetDelegate* native_widget_delegate,
-      views::DesktopNativeWidgetAura* desktop_native_widget_aura);
-  ~AtomDesktopWindowTreeHostWin() override;
-
- protected:
-  bool PreHandleMSG(UINT message,
-                    WPARAM w_param,
-                    LPARAM l_param,
-                    LRESULT* result) override;
-  bool HasNativeFrame() const override;
-
- private:
-  MessageHandlerDelegate* delegate_;  // weak ref
-
-  DISALLOW_COPY_AND_ASSIGN(AtomDesktopWindowTreeHostWin);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_ATOM_DESKTOP_WINDOW_TREE_HOST_WIN_H_
removed in remote
  base   100644 791d1fd816d9ea2459c930e536c125c7851ccbc8 atom/browser/ui/win/message_handler_delegate.cc
  our    100644 d8b4a42ffacbfd70bf9c8049f7966de450627064 atom/browser/ui/win/message_handler_delegate.cc
@@ -1,16 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/message_handler_delegate.h"
-
-namespace atom {
-
-bool MessageHandlerDelegate::PreHandleMSG(UINT message,
-                                          WPARAM w_param,
-                                          LPARAM l_param,
-                                          LRESULT* result) {
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 d8cfcf7fc43b9089c01055aafa337ca0ee2d1038 atom/browser/ui/win/message_handler_delegate.h
  our    100644 1eb490a28d7bfa4b77c80a691c4f1ab8c56403ca atom/browser/ui/win/message_handler_delegate.h
@@ -1,28 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
-#define ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
-
-#include <windows.h>
-
-namespace atom {
-
-class MessageHandlerDelegate {
- public:
-  // Catch-all message handling and filtering. Called before
-  // HWNDMessageHandler's built-in handling, which may pre-empt some
-  // expectations in Views/Aura if messages are consumed. Returns true if the
-  // message was consumed by the delegate and should not be processed further
-  // by the HWNDMessageHandler. In this case, |result| is returned. |result| is
-  // not modified otherwise.
-  virtual bool PreHandleMSG(UINT message,
-                            WPARAM w_param,
-                            LPARAM l_param,
-                            LRESULT* result);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
removed in remote
  base   100644 112473013808250a317da6422c6143829ac69677 atom/browser/ui/win/notify_icon.cc
  our    100644 9b01de8a49f6ca3daa61b5c8e7d863e87b5e573d atom/browser/ui/win/notify_icon.cc
@@ -1,175 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon.h"
-
-#include "atom/browser/ui/win/notify_icon_host.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/windows_version.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/display/screen.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/gfx/geometry/point.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-#include "ui/views/controls/menu/menu_runner.h"
-
-namespace atom {
-
-NotifyIcon::NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message)
-    : host_(host), icon_id_(id), window_(window), message_id_(message) {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_MESSAGE;
-  icon_data.uCallbackMessage = message_id_;
-  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
-  // This can happen if the explorer process isn't running when we try to
-  // create the icon for some reason (for example, at startup).
-  if (!result)
-    LOG(WARNING) << "Unable to create status tray icon.";
-}
-
-NotifyIcon::~NotifyIcon() {
-  // Remove our icon.
-  host_->Remove(this);
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  Shell_NotifyIcon(NIM_DELETE, &icon_data);
-}
-
-void NotifyIcon::HandleClickEvent(int modifiers,
-                                  bool left_mouse_click,
-                                  bool double_button_click) {
-  gfx::Rect bounds = GetBounds();
-
-  if (left_mouse_click) {
-    if (double_button_click)  // double left click
-      NotifyDoubleClicked(bounds, modifiers);
-    else  // single left click
-      NotifyClicked(bounds,
-                    display::Screen::GetScreen()->GetCursorScreenPoint(),
-                    modifiers);
-    return;
-  } else if (!double_button_click) {  // single right click
-    if (menu_model_)
-      PopUpContextMenu(gfx::Point(), menu_model_);
-    else
-      NotifyRightClicked(bounds, modifiers);
-  }
-}
-
-void NotifyIcon::ResetIcon() {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  // Delete any previously existing icon.
-  Shell_NotifyIcon(NIM_DELETE, &icon_data);
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_MESSAGE;
-  icon_data.uCallbackMessage = message_id_;
-  icon_data.hIcon = icon_.get();
-  // If we have an image, then set the NIF_ICON flag, which tells
-  // Shell_NotifyIcon() to set the image for the status icon it creates.
-  if (icon_data.hIcon)
-    icon_data.uFlags |= NIF_ICON;
-  // Re-add our icon.
-  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to re-create status tray icon.";
-}
-
-void NotifyIcon::SetImage(HICON image) {
-  icon_ = base::win::ScopedHICON(CopyIcon(image));
-
-  // Create the icon.
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_ICON;
-  icon_data.hIcon = image;
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Error setting status tray icon image";
-}
-
-void NotifyIcon::SetPressedImage(HICON image) {
-  // Ignore pressed images, since the standard on Windows is to not highlight
-  // pressed status icons.
-}
-
-void NotifyIcon::SetToolTip(const std::string& tool_tip) {
-  // Create the icon.
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_TIP;
-  wcsncpy_s(icon_data.szTip, base::UTF8ToUTF16(tool_tip).c_str(), _TRUNCATE);
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to set tooltip for status tray icon";
-}
-
-void NotifyIcon::DisplayBalloon(HICON icon,
-                                const base::string16& title,
-                                const base::string16& contents) {
-  NOTIFYICONDATA icon_data;
-  InitIconData(&icon_data);
-  icon_data.uFlags |= NIF_INFO;
-  icon_data.dwInfoFlags = NIIF_INFO;
-  wcsncpy_s(icon_data.szInfoTitle, title.c_str(), _TRUNCATE);
-  wcsncpy_s(icon_data.szInfo, contents.c_str(), _TRUNCATE);
-  icon_data.uTimeout = 0;
-  icon_data.hBalloonIcon = icon;
-  icon_data.dwInfoFlags = NIIF_USER | NIIF_LARGE_ICON;
-
-  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
-  if (!result)
-    LOG(WARNING) << "Unable to create status tray balloon.";
-}
-
-void NotifyIcon::PopUpContextMenu(const gfx::Point& pos,
-                                  AtomMenuModel* menu_model) {
-  // Returns if context menu isn't set.
-  if (menu_model == nullptr && menu_model_ == nullptr)
-    return;
-
-  // Set our window as the foreground window, so the context menu closes when
-  // we click away from it.
-  if (!SetForegroundWindow(window_))
-    return;
-
-  // Show menu at mouse's position by default.
-  gfx::Rect rect(pos, gfx::Size());
-  if (pos.IsOrigin())
-    rect.set_origin(display::Screen::GetScreen()->GetCursorScreenPoint());
-
-  menu_runner_.reset(new views::MenuRunner(
-      menu_model != nullptr ? menu_model : menu_model_,
-      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
-  menu_runner_->RunMenuAt(NULL, NULL, rect, views::MENU_ANCHOR_TOPLEFT,
-                          ui::MENU_SOURCE_MOUSE);
-}
-
-void NotifyIcon::SetContextMenu(AtomMenuModel* menu_model) {
-  menu_model_ = menu_model;
-}
-
-gfx::Rect NotifyIcon::GetBounds() {
-  NOTIFYICONIDENTIFIER icon_id;
-  memset(&icon_id, 0, sizeof(NOTIFYICONIDENTIFIER));
-  icon_id.uID = icon_id_;
-  icon_id.hWnd = window_;
-  icon_id.cbSize = sizeof(NOTIFYICONIDENTIFIER);
-
-  RECT rect = {0};
-  Shell_NotifyIconGetRect(&icon_id, &rect);
-  return display::win::ScreenWin::ScreenToDIPRect(window_, gfx::Rect(rect));
-}
-
-void NotifyIcon::InitIconData(NOTIFYICONDATA* icon_data) {
-  memset(icon_data, 0, sizeof(NOTIFYICONDATA));
-  icon_data->cbSize = sizeof(NOTIFYICONDATA);
-  icon_data->hWnd = window_;
-  icon_data->uID = icon_id_;
-}
-
-}  // namespace atom
removed in remote
  base   100644 53ed49b937c162e9406c176e84a69689c7ecfef4 atom/browser/ui/win/notify_icon.h
  our    100644 bd4c17d2fcee53c7c106b0912252848cd6de0dc7 atom/browser/ui/win/notify_icon.h
@@ -1,92 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
-#define ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
-
-#include <windows.h>  // windows.h must be included first
-
-#include <shellapi.h>
-
-#include <string>
-
-#include "atom/browser/ui/tray_icon.h"
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "base/win/scoped_gdi_object.h"
-
-namespace gfx {
-class Point;
-}
-
-namespace views {
-class MenuRunner;
-}
-
-namespace atom {
-
-class NotifyIconHost;
-
-class NotifyIcon : public TrayIcon {
- public:
-  // Constructor which provides this icon's unique ID and messaging window.
-  NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message);
-  ~NotifyIcon() override;
-
-  // Handles a click event from the user - if |left_button_click| is true and
-  // there is a registered observer, passes the click event to the observer,
-  // otherwise displays the context menu if there is one.
-  void HandleClickEvent(int modifiers,
-                        bool left_button_click,
-                        bool double_button_click);
-
-  // Re-creates the status tray icon now after the taskbar has been created.
-  void ResetIcon();
-
-  UINT icon_id() const { return icon_id_; }
-  HWND window() const { return window_; }
-  UINT message_id() const { return message_id_; }
-
-  // Overridden from TrayIcon:
-  void SetImage(HICON image) override;
-  void SetPressedImage(HICON image) override;
-  void SetToolTip(const std::string& tool_tip) override;
-  void DisplayBalloon(HICON icon,
-                      const base::string16& title,
-                      const base::string16& contents) override;
-  void PopUpContextMenu(const gfx::Point& pos,
-                        AtomMenuModel* menu_model) override;
-  void SetContextMenu(AtomMenuModel* menu_model) override;
-  gfx::Rect GetBounds() override;
-
- private:
-  void InitIconData(NOTIFYICONDATA* icon_data);
-
-  // The tray that owns us.  Weak.
-  NotifyIconHost* host_;
-
-  // The unique ID corresponding to this icon.
-  UINT icon_id_;
-
-  // Window used for processing messages from this icon.
-  HWND window_;
-
-  // The message identifier used for status icon messages.
-  UINT message_id_;
-
-  // The currently-displayed icon for the window.
-  base::win::ScopedHICON icon_;
-
-  // The context menu.
-  AtomMenuModel* menu_model_ = nullptr;
-
-  // Context menu associated with this icon (if any).
-  std::unique_ptr<views::MenuRunner> menu_runner_;
-
-  DISALLOW_COPY_AND_ASSIGN(NotifyIcon);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_NOTIFY_ICON_H_
removed in remote
  base   100644 1f0b35b09fd24c625cf6ebc0704691ebb1dcf0df atom/browser/ui/win/notify_icon_host.cc
  our    100644 435ec050be4315d42cac4985f122fbb7e62702e5 atom/browser/ui/win/notify_icon_host.cc
@@ -1,183 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/notify_icon_host.h"
-
-#include <commctrl.h>
-#include <winuser.h>
-
-#include "atom/browser/ui/win/notify_icon.h"
-#include "base/bind.h"
-#include "base/stl_util.h"
-#include "base/win/win_util.h"
-#include "base/win/wrapped_window_proc.h"
-#include "ui/events/event_constants.h"
-#include "ui/events/win/system_event_state_lookup.h"
-#include "ui/gfx/win/hwnd_util.h"
-
-namespace atom {
-
-namespace {
-
-const UINT kNotifyIconMessage = WM_APP + 1;
-
-// |kBaseIconId| is 2 to avoid conflicts with plugins that hard-code id 1.
-const UINT kBaseIconId = 2;
-
-const wchar_t kNotifyIconHostWindowClass[] = L"Electron_NotifyIconHostWindow";
-
-bool IsWinPressed() {
-  return ((::GetKeyState(VK_LWIN) & 0x8000) == 0x8000) ||
-         ((::GetKeyState(VK_RWIN) & 0x8000) == 0x8000);
-}
-
-int GetKeyboardModifers() {
-  int modifiers = ui::EF_NONE;
-  if (ui::win::IsShiftPressed())
-    modifiers |= ui::EF_SHIFT_DOWN;
-  if (ui::win::IsCtrlPressed())
-    modifiers |= ui::EF_CONTROL_DOWN;
-  if (ui::win::IsAltPressed())
-    modifiers |= ui::EF_ALT_DOWN;
-  if (IsWinPressed())
-    modifiers |= ui::EF_COMMAND_DOWN;
-  return modifiers;
-}
-
-}  // namespace
-
-NotifyIconHost::NotifyIconHost() {
-  // Register our window class
-  WNDCLASSEX window_class;
-  base::win::InitializeWindowClass(
-      kNotifyIconHostWindowClass,
-      &base::win::WrappedWindowProc<NotifyIconHost::WndProcStatic>, 0, 0, 0,
-      NULL, NULL, NULL, NULL, NULL, &window_class);
-  instance_ = window_class.hInstance;
-  atom_ = RegisterClassEx(&window_class);
-  CHECK(atom_);
-
-  // If the taskbar is re-created after we start up, we have to rebuild all of
-  // our icons.
-  taskbar_created_message_ = RegisterWindowMessage(TEXT("TaskbarCreated"));
-
-  // Create an offscreen window for handling messages for the status icons. We
-  // create a hidden WS_POPUP window instead of an HWND_MESSAGE window, because
-  // only top-level windows such as popups can receive broadcast messages like
-  // "TaskbarCreated".
-  window_ = CreateWindow(MAKEINTATOM(atom_), 0, WS_POPUP, 0, 0, 0, 0, 0, 0,
-                         instance_, 0);
-  gfx::CheckWindowCreated(window_);
-  gfx::SetWindowUserData(window_, this);
-}
-
-NotifyIconHost::~NotifyIconHost() {
-  if (window_)
-    DestroyWindow(window_);
-
-  if (atom_)
-    UnregisterClass(MAKEINTATOM(atom_), instance_);
-
-  for (NotifyIcon* ptr : notify_icons_)
-    delete ptr;
-}
-
-NotifyIcon* NotifyIconHost::CreateNotifyIcon() {
-  NotifyIcon* notify_icon =
-      new NotifyIcon(this, NextIconId(), window_, kNotifyIconMessage);
-  notify_icons_.push_back(notify_icon);
-  return notify_icon;
-}
-
-void NotifyIconHost::Remove(NotifyIcon* icon) {
-  NotifyIcons::iterator i(
-      std::find(notify_icons_.begin(), notify_icons_.end(), icon));
-
-  if (i == notify_icons_.end()) {
-    NOTREACHED();
-    return;
-  }
-
-  notify_icons_.erase(i);
-}
-
-LRESULT CALLBACK NotifyIconHost::WndProcStatic(HWND hwnd,
-                                               UINT message,
-                                               WPARAM wparam,
-                                               LPARAM lparam) {
-  NotifyIconHost* msg_wnd =
-      reinterpret_cast<NotifyIconHost*>(GetWindowLongPtr(hwnd, GWLP_USERDATA));
-  if (msg_wnd)
-    return msg_wnd->WndProc(hwnd, message, wparam, lparam);
-  else
-    return ::DefWindowProc(hwnd, message, wparam, lparam);
-}
-
-LRESULT CALLBACK NotifyIconHost::WndProc(HWND hwnd,
-                                         UINT message,
-                                         WPARAM wparam,
-                                         LPARAM lparam) {
-  if (message == taskbar_created_message_) {
-    // We need to reset all of our icons because the taskbar went away.
-    for (NotifyIcons::const_iterator i(notify_icons_.begin());
-         i != notify_icons_.end(); ++i) {
-      NotifyIcon* win_icon = static_cast<NotifyIcon*>(*i);
-      win_icon->ResetIcon();
-    }
-    return TRUE;
-  } else if (message == kNotifyIconMessage) {
-    NotifyIcon* win_icon = NULL;
-
-    // Find the selected status icon.
-    for (NotifyIcons::const_iterator i(notify_icons_.begin());
-         i != notify_icons_.end(); ++i) {
-      NotifyIcon* current_win_icon = static_cast<NotifyIcon*>(*i);
-      if (current_win_icon->icon_id() == wparam) {
-        win_icon = current_win_icon;
-        break;
-      }
-    }
-
-    // It is possible for this procedure to be called with an obsolete icon
-    // id.  In that case we should just return early before handling any
-    // actions.
-    if (!win_icon)
-      return TRUE;
-
-    switch (lparam) {
-      case TB_CHECKBUTTON:
-        win_icon->NotifyBalloonShow();
-        return TRUE;
-
-      case TB_INDETERMINATE:
-        win_icon->NotifyBalloonClicked();
-        return TRUE;
-
-      case TB_HIDEBUTTON:
-        win_icon->NotifyBalloonClosed();
-        return TRUE;
-
-      case WM_LBUTTONDOWN:
-      case WM_RBUTTONDOWN:
-      case WM_LBUTTONDBLCLK:
-      case WM_RBUTTONDBLCLK:
-      case WM_CONTEXTMENU:
-        // Walk our icons, find which one was clicked on, and invoke its
-        // HandleClickEvent() method.
-        win_icon->HandleClickEvent(
-            GetKeyboardModifers(),
-            (lparam == WM_LBUTTONDOWN || lparam == WM_LBUTTONDBLCLK),
-            (lparam == WM_LBUTTONDBLCLK || lparam == WM_RBUTTONDBLCLK));
-        return TRUE;
-    }
-  }
-  return ::DefWindowProc(hwnd, message, wparam, lparam);
-}
-
-UINT NotifyIconHost::NextIconId() {
-  UINT icon_id = next_icon_id_++;
-  return kBaseIconId + icon_id;
-}
-
-}  // namespace atom
removed in remote
  base   100644 6797d4f6a54c9530be2f71d16b9681432ab65452 atom/browser/ui/win/notify_icon_host.h
  our    100644 6e4dd4e552233e09be8c034198c4d43fde07dbbc atom/browser/ui/win/notify_icon_host.h
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
-#define ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
-
-#include <windows.h>
-
-#include <vector>
-
-#include "base/macros.h"
-
-namespace atom {
-
-class NotifyIcon;
-
-class NotifyIconHost {
- public:
-  NotifyIconHost();
-  ~NotifyIconHost();
-
-  NotifyIcon* CreateNotifyIcon();
-  void Remove(NotifyIcon* notify_icon);
-
- private:
-  typedef std::vector<NotifyIcon*> NotifyIcons;
-
-  // Static callback invoked when a message comes in to our messaging window.
-  static LRESULT CALLBACK WndProcStatic(HWND hwnd,
-                                        UINT message,
-                                        WPARAM wparam,
-                                        LPARAM lparam);
-
-  LRESULT CALLBACK WndProc(HWND hwnd,
-                           UINT message,
-                           WPARAM wparam,
-                           LPARAM lparam);
-
-  UINT NextIconId();
-
-  // The unique icon ID we will assign to the next icon.
-  UINT next_icon_id_ = 1;
-
-  // List containing all active NotifyIcons.
-  NotifyIcons notify_icons_;
-
-  // The window class of |window_|.
-  ATOM atom_ = 0;
-
-  // The handle of the module that contains the window procedure of |window_|.
-  HMODULE instance_ = nullptr;
-
-  // The window used for processing events.
-  HWND window_ = nullptr;
-
-  // The message ID of the "TaskbarCreated" message, sent to us when we need to
-  // reset our status icons.
-  UINT taskbar_created_message_ = 0;
-
-  DISALLOW_COPY_AND_ASSIGN(NotifyIconHost);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
removed in remote
  base   100644 f7841cfa856c7c9d6a5ac362ccf39bfce972438a atom/browser/ui/win/taskbar_host.cc
  our    100644 c4b92a24aefb3afa3ff2929eea59940d439e8709 atom/browser/ui/win/taskbar_host.cc
@@ -1,226 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/win/taskbar_host.h"
-
-#include <objbase.h>
-#include <string>
-
-#include "atom/browser/native_window.h"
-#include "base/stl_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/scoped_gdi_object.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "ui/display/win/screen_win.h"
-#include "ui/gfx/icon_util.h"
-
-namespace atom {
-
-namespace {
-
-// From MSDN:
-// https://msdn.microsoft.com/en-us/library/windows/desktop/dd378460(v=vs.85).aspx#thumbbars
-// The thumbnail toolbar has a maximum of seven buttons due to the limited room.
-const size_t kMaxButtonsCount = 7;
-
-// The base id of Thumbar button.
-const int kButtonIdBase = 40001;
-
-bool GetThumbarButtonFlags(const std::vector<std::string>& flags,
-                           THUMBBUTTONFLAGS* out) {
-  THUMBBUTTONFLAGS result = THBF_ENABLED;  // THBF_ENABLED == 0
-  for (const auto& flag : flags) {
-    if (flag == "disabled")
-      result |= THBF_DISABLED;
-    else if (flag == "dismissonclick")
-      result |= THBF_DISMISSONCLICK;
-    else if (flag == "nobackground")
-      result |= THBF_NOBACKGROUND;
-    else if (flag == "hidden")
-      result |= THBF_HIDDEN;
-    else if (flag == "noninteractive")
-      result |= THBF_NONINTERACTIVE;
-    else
-      return false;
-  }
-  *out = result;
-  return true;
-}
-
-}  // namespace
-
-TaskbarHost::ThumbarButton::ThumbarButton() = default;
-TaskbarHost::ThumbarButton::ThumbarButton(const TaskbarHost::ThumbarButton&) =
-    default;
-TaskbarHost::ThumbarButton::~ThumbarButton() = default;
-
-TaskbarHost::TaskbarHost() {}
-
-TaskbarHost::~TaskbarHost() {}
-
-bool TaskbarHost::SetThumbarButtons(HWND window,
-                                    const std::vector<ThumbarButton>& buttons) {
-  if (buttons.size() > kMaxButtonsCount || !InitializeTaskbar())
-    return false;
-
-  callback_map_.clear();
-
-  // The number of buttons in thumbar can not be changed once it is created,
-  // so we have to claim kMaxButtonsCount buttons initialy in case users add
-  // more buttons later.
-  base::win::ScopedHICON icons[kMaxButtonsCount] = {};
-  THUMBBUTTON thumb_buttons[kMaxButtonsCount] = {};
-
-  for (size_t i = 0; i < kMaxButtonsCount; ++i) {
-    THUMBBUTTON& thumb_button = thumb_buttons[i];
-
-    // Set ID.
-    thumb_button.iId = kButtonIdBase + i;
-    thumb_button.dwMask = THB_FLAGS;
-
-    if (i >= buttons.size()) {
-      // This button is used to occupy the place in toolbar, and it does not
-      // show.
-      thumb_button.dwFlags = THBF_HIDDEN;
-      continue;
-    }
-
-    // This button is user's button.
-    const ThumbarButton& button = buttons[i];
-
-    // Generate flags.
-    thumb_button.dwFlags = THBF_ENABLED;
-    if (!GetThumbarButtonFlags(button.flags, &thumb_button.dwFlags))
-      return false;
-
-    // Set icon.
-    if (!button.icon.IsEmpty()) {
-      thumb_button.dwMask |= THB_ICON;
-      icons[i] = IconUtil::CreateHICONFromSkBitmap(button.icon.AsBitmap());
-      thumb_button.hIcon = icons[i].get();
-    }
-
-    // Set tooltip.
-    if (!button.tooltip.empty()) {
-      thumb_button.dwMask |= THB_TOOLTIP;
-      wcsncpy_s(thumb_button.szTip, base::UTF8ToUTF16(button.tooltip).c_str(),
-                _TRUNCATE);
-    }
-
-    // Save callback.
-    callback_map_[thumb_button.iId] = button.clicked_callback;
-  }
-
-  // Finally add them to taskbar.
-  HRESULT r;
-  if (thumbar_buttons_added_)
-    r = taskbar_->ThumbBarUpdateButtons(window, kMaxButtonsCount,
-                                        thumb_buttons);
-  else
-    r = taskbar_->ThumbBarAddButtons(window, kMaxButtonsCount, thumb_buttons);
-
-  thumbar_buttons_added_ = true;
-  last_buttons_ = buttons;
-  return SUCCEEDED(r);
-}
-
-void TaskbarHost::RestoreThumbarButtons(HWND window) {
-  if (thumbar_buttons_added_) {
-    thumbar_buttons_added_ = false;
-    SetThumbarButtons(window, last_buttons_);
-  }
-}
-
-bool TaskbarHost::SetProgressBar(HWND window,
-                                 double value,
-                                 const NativeWindow::ProgressState state) {
-  if (!InitializeTaskbar())
-    return false;
-
-  bool success;
-  if (value > 1.0 || state == NativeWindow::PROGRESS_INDETERMINATE) {
-    success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_INDETERMINATE));
-  } else if (value < 0 || state == NativeWindow::PROGRESS_NONE) {
-    success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_NOPROGRESS));
-  } else {
-    // Unless SetProgressState set a blocking state (TBPF_ERROR, TBPF_PAUSED)
-    // for the window, a call to SetProgressValue assumes the TBPF_NORMAL
-    // state even if it is not explicitly set.
-    // SetProgressValue overrides and clears the TBPF_INDETERMINATE state.
-    if (state == NativeWindow::PROGRESS_ERROR) {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_ERROR));
-    } else if (state == NativeWindow::PROGRESS_PAUSED) {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_PAUSED));
-    } else {
-      success = SUCCEEDED(taskbar_->SetProgressState(window, TBPF_NORMAL));
-    }
-
-    if (success) {
-      int val = static_cast<int>(value * 100);
-      success = SUCCEEDED(taskbar_->SetProgressValue(window, val, 100));
-    }
-  }
-
-  return success;
-}
-
-bool TaskbarHost::SetOverlayIcon(HWND window,
-                                 const gfx::Image& overlay,
-                                 const std::string& text) {
-  if (!InitializeTaskbar())
-    return false;
-
-  base::win::ScopedHICON icon(
-      IconUtil::CreateHICONFromSkBitmap(overlay.AsBitmap()));
-  return SUCCEEDED(taskbar_->SetOverlayIcon(window, icon.get(),
-                                            base::UTF8ToUTF16(text).c_str()));
-}
-
-bool TaskbarHost::SetThumbnailClip(HWND window, const gfx::Rect& region) {
-  if (!InitializeTaskbar())
-    return false;
-
-  if (region.IsEmpty()) {
-    return SUCCEEDED(taskbar_->SetThumbnailClip(window, NULL));
-  } else {
-    RECT rect =
-        display::win::ScreenWin::DIPToScreenRect(window, region).ToRECT();
-    return SUCCEEDED(taskbar_->SetThumbnailClip(window, &rect));
-  }
-}
-
-bool TaskbarHost::SetThumbnailToolTip(HWND window, const std::string& tooltip) {
-  if (!InitializeTaskbar())
-    return false;
-
-  return SUCCEEDED(taskbar_->SetThumbnailTooltip(
-      window, base::UTF8ToUTF16(tooltip).c_str()));
-}
-
-bool TaskbarHost::HandleThumbarButtonEvent(int button_id) {
-  if (ContainsKey(callback_map_, button_id)) {
-    auto callback = callback_map_[button_id];
-    if (!callback.is_null())
-      callback.Run();
-    return true;
-  }
-  return false;
-}
-
-bool TaskbarHost::InitializeTaskbar() {
-  if (taskbar_)
-    return true;
-
-  if (FAILED(::CoCreateInstance(CLSID_TaskbarList, nullptr,
-                                CLSCTX_INPROC_SERVER,
-                                IID_PPV_ARGS(&taskbar_))) ||
-      FAILED(taskbar_->HrInit())) {
-    taskbar_.Reset();
-    return false;
-  } else {
-    return true;
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 185b88a6b5b6f0570ce55c82d8db6b9c2a608073 atom/browser/ui/win/taskbar_host.h
  our    100644 2182d377a7736f5e135d2f518c2a0a838cd0d1a0 atom/browser/ui/win/taskbar_host.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
-#define ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
-
-#include <shobjidl.h>
-#include <wrl/client.h>
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "base/callback.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-
-namespace atom {
-
-class TaskbarHost {
- public:
-  struct ThumbarButton {
-    std::string tooltip;
-    gfx::Image icon;
-    std::vector<std::string> flags;
-    base::Closure clicked_callback;
-
-    ThumbarButton();
-    ThumbarButton(const ThumbarButton&);
-    ~ThumbarButton();
-  };
-
-  TaskbarHost();
-  virtual ~TaskbarHost();
-
-  // Add or update the buttons in thumbar.
-  bool SetThumbarButtons(HWND window,
-                         const std::vector<ThumbarButton>& buttons);
-
-  void RestoreThumbarButtons(HWND window);
-
-  // Set the progress state in taskbar.
-  bool SetProgressBar(HWND window,
-                      double value,
-                      const NativeWindow::ProgressState state);
-
-  // Set the overlay icon in taskbar.
-  bool SetOverlayIcon(HWND window,
-                      const gfx::Image& overlay,
-                      const std::string& text);
-
-  // Set the region of the window to show as a thumbnail in taskbar.
-  bool SetThumbnailClip(HWND window, const gfx::Rect& region);
-
-  // Set the tooltip for the thumbnail in taskbar.
-  bool SetThumbnailToolTip(HWND window, const std::string& tooltip);
-
-  // Called by the window that there is a button in thumbar clicked.
-  bool HandleThumbarButtonEvent(int button_id);
-
- private:
-  // Initialize the taskbar object.
-  bool InitializeTaskbar();
-
-  using CallbackMap = std::map<int, base::Closure>;
-  CallbackMap callback_map_;
-
-  std::vector<ThumbarButton> last_buttons_;
-
-  // The COM object of taskbar.
-  Microsoft::WRL::ComPtr<ITaskbarList3> taskbar_;
-
-  // Whether we have already added the buttons to thumbar.
-  bool thumbar_buttons_added_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(TaskbarHost);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_WIN_TASKBAR_HOST_H_
removed in remote
  base   100644 e1b2716b868f2c441ea43b7b9cf2b31ac1c1f300 atom/browser/ui/x/window_state_watcher.cc
  our    100644 9eebc361d7d0c5915345e73f0a6eba8f5336b003 atom/browser/ui/x/window_state_watcher.cc
@@ -1,64 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/x/window_state_watcher.h"
-
-#include "ui/events/platform/platform_event_source.h"
-#include "ui/gfx/x/x11.h"
-#include "ui/gfx/x/x11_atom_cache.h"
-
-namespace atom {
-
-WindowStateWatcher::WindowStateWatcher(NativeWindowViews* window)
-    : window_(window), widget_(window->GetAcceleratedWidget()) {
-  ui::PlatformEventSource::GetInstance()->AddPlatformEventObserver(this);
-}
-
-WindowStateWatcher::~WindowStateWatcher() {
-  ui::PlatformEventSource::GetInstance()->RemovePlatformEventObserver(this);
-}
-
-void WindowStateWatcher::WillProcessEvent(const ui::PlatformEvent& event) {
-  if (IsWindowStateEvent(event)) {
-    was_minimized_ = window_->IsMinimized();
-    was_maximized_ = window_->IsMaximized();
-  }
-}
-
-void WindowStateWatcher::DidProcessEvent(const ui::PlatformEvent& event) {
-  if (IsWindowStateEvent(event)) {
-    bool is_minimized = window_->IsMinimized();
-    bool is_maximized = window_->IsMaximized();
-    bool is_fullscreen = window_->IsFullscreen();
-    if (is_minimized != was_minimized_) {
-      if (is_minimized)
-        window_->NotifyWindowMinimize();
-      else
-        window_->NotifyWindowRestore();
-    } else if (is_maximized != was_maximized_) {
-      if (is_maximized)
-        window_->NotifyWindowMaximize();
-      else
-        window_->NotifyWindowUnmaximize();
-    } else {
-      // If this is neither a "maximize" or "minimize" event, then we think it
-      // is a "fullscreen" event.
-      // The "IsFullscreen()" becomes true immediately before "WillProcessEvent"
-      // is called, so we can not handle this like "maximize" and "minimize" by
-      // watching whether they have changed.
-      if (is_fullscreen)
-        window_->NotifyWindowEnterFullScreen();
-      else
-        window_->NotifyWindowLeaveFullScreen();
-    }
-  }
-}
-
-bool WindowStateWatcher::IsWindowStateEvent(const ui::PlatformEvent& event) {
-  ::Atom changed_atom = event->xproperty.atom;
-  return (changed_atom == gfx::GetAtom("_NET_WM_STATE") &&
-          event->type == PropertyNotify && event->xproperty.window == widget_);
-}
-
-}  // namespace atom
removed in remote
  base   100644 2888c9fc6fec1e68c33479c06c1c017608fa43c1 atom/browser/ui/x/window_state_watcher.h
  our    100644 7d65b08d8bb32316c509f7aaaa14d5b4e337b7f5 atom/browser/ui/x/window_state_watcher.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
-#define ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
-
-#include "ui/events/platform/platform_event_observer.h"
-
-#include "atom/browser/native_window_views.h"
-
-namespace atom {
-
-class WindowStateWatcher : public ui::PlatformEventObserver {
- public:
-  explicit WindowStateWatcher(NativeWindowViews* window);
-  ~WindowStateWatcher() override;
-
- protected:
-  // ui::PlatformEventObserver:
-  void WillProcessEvent(const ui::PlatformEvent& event) override;
-  void DidProcessEvent(const ui::PlatformEvent& event) override;
-
- private:
-  bool IsWindowStateEvent(const ui::PlatformEvent& event);
-
-  NativeWindowViews* window_;
-  gfx::AcceleratedWidget widget_;
-
-  bool was_minimized_ = false;
-  bool was_maximized_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(WindowStateWatcher);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
removed in remote
  base   100644 db83753bb3765a585cd2ff1989aecfac87457cdb atom/browser/ui/x/x_window_utils.cc
  our    100644 ecc2f906e5849595010ffe549b3bbe999b173a0a atom/browser/ui/x/x_window_utils.cc
@@ -1,90 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/ui/x/x_window_utils.h"
-
-#include <X11/Xatom.h>
-
-#include "base/environment.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_restrictions.h"
-#include "dbus/bus.h"
-#include "dbus/message.h"
-#include "dbus/object_proxy.h"
-#include "ui/base/x/x11_util.h"
-
-namespace atom {
-
-::Atom GetAtom(const char* name) {
-  return XInternAtom(gfx::GetXDisplay(), name, false);
-}
-
-void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state) {
-  XEvent xclient;
-  memset(&xclient, 0, sizeof(xclient));
-  xclient.type = ClientMessage;
-  xclient.xclient.window = xwindow;
-  xclient.xclient.message_type = GetAtom("_NET_WM_STATE");
-  xclient.xclient.format = 32;
-  xclient.xclient.data.l[0] = enabled ? 1 : 0;
-  xclient.xclient.data.l[1] = state;
-  xclient.xclient.data.l[2] = x11::None;
-  xclient.xclient.data.l[3] = 1;
-  xclient.xclient.data.l[4] = 0;
-
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  XSendEvent(xdisplay, DefaultRootWindow(xdisplay), x11::False,
-             SubstructureRedirectMask | SubstructureNotifyMask, &xclient);
-}
-
-void SetWindowType(::Window xwindow, const std::string& type) {
-  XDisplay* xdisplay = gfx::GetXDisplay();
-  std::string type_prefix = "_NET_WM_WINDOW_TYPE_";
-  ::Atom window_type = XInternAtom(
-      xdisplay, (type_prefix + base::ToUpperASCII(type)).c_str(), x11::False);
-  XChangeProperty(xdisplay, xwindow,
-                  XInternAtom(xdisplay, "_NET_WM_WINDOW_TYPE", x11::False),
-                  XA_ATOM, 32, PropModeReplace,
-                  reinterpret_cast<unsigned char*>(&window_type), 1);
-}
-
-bool ShouldUseGlobalMenuBar() {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  if (env->HasVar("ELECTRON_FORCE_WINDOW_MENU_BAR"))
-    return false;
-
-  dbus::Bus::Options options;
-  scoped_refptr<dbus::Bus> bus(new dbus::Bus(options));
-
-  dbus::ObjectProxy* object_proxy =
-      bus->GetObjectProxy(DBUS_SERVICE_DBUS, dbus::ObjectPath(DBUS_PATH_DBUS));
-  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS, "ListNames");
-  std::unique_ptr<dbus::Response> response(object_proxy->CallMethodAndBlock(
-      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT));
-  if (!response) {
-    bus->ShutdownAndBlock();
-    return false;
-  }
-
-  dbus::MessageReader reader(response.get());
-  dbus::MessageReader array_reader(NULL);
-  if (!reader.PopArray(&array_reader)) {
-    bus->ShutdownAndBlock();
-    return false;
-  }
-  while (array_reader.HasMoreData()) {
-    std::string name;
-    if (array_reader.PopString(&name) &&
-        name == "com.canonical.AppMenu.Registrar") {
-      bus->ShutdownAndBlock();
-      return true;
-    }
-  }
-
-  bus->ShutdownAndBlock();
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 16f3ddac6ccd860a3f2400d1d6272d79c79f2cd8 atom/browser/ui/x/x_window_utils.h
  our    100644 5888a2b25663aef10e1700688807e24c693f298a atom/browser/ui/x/x_window_utils.h
@@ -1,28 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
-#define ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
-
-#include <string>
-
-#include "ui/gfx/x/x11.h"
-
-namespace atom {
-
-::Atom GetAtom(const char* name);
-
-// Sends a message to the x11 window manager, enabling or disabling the |state|
-// for _NET_WM_STATE.
-void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state);
-
-// Sets the _NET_WM_WINDOW_TYPE of window.
-void SetWindowType(::Window xwindow, const std::string& type);
-
-// Returns true if the bus name "com.canonical.AppMenu.Registrar" is available.
-bool ShouldUseGlobalMenuBar();
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_UI_X_X_WINDOW_UTILS_H_
removed in remote
  base   100644 d018e1d09dbcd220f4007368e19c553c696c1f10 atom/browser/web_contents_permission_helper.cc
  our    100644 1b3d809b1e724da4f5d1105ab61c4ddb6f8f4274 atom/browser/web_contents_permission_helper.cc
@@ -1,105 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_permission_helper.h"
-
-#include <string>
-
-#include "atom/browser/atom_permission_manager.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "brightray/browser/media/media_stream_devices_controller.h"
-#include "content/public/browser/browser_context.h"
-#include "content/public/browser/render_process_host.h"
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::WebContentsPermissionHelper);
-
-namespace atom {
-
-namespace {
-
-void MediaAccessAllowed(const content::MediaStreamRequest& request,
-                        const content::MediaResponseCallback& callback,
-                        bool allowed) {
-  brightray::MediaStreamDevicesController controller(request, callback);
-  if (allowed)
-    controller.TakeAction();
-  else
-    controller.Deny(content::MEDIA_DEVICE_PERMISSION_DENIED);
-}
-
-void OnPointerLockResponse(content::WebContents* web_contents, bool allowed) {
-  if (web_contents)
-    web_contents->GotResponseToLockMouseRequest(allowed);
-}
-
-void OnPermissionResponse(const base::Callback<void(bool)>& callback,
-                          blink::mojom::PermissionStatus status) {
-  if (status == blink::mojom::PermissionStatus::GRANTED)
-    callback.Run(true);
-  else
-    callback.Run(false);
-}
-
-}  // namespace
-
-WebContentsPermissionHelper::WebContentsPermissionHelper(
-    content::WebContents* web_contents)
-    : web_contents_(web_contents) {}
-
-WebContentsPermissionHelper::~WebContentsPermissionHelper() {}
-
-void WebContentsPermissionHelper::RequestPermission(
-    content::PermissionType permission,
-    const base::Callback<void(bool)>& callback,
-    bool user_gesture,
-    const base::DictionaryValue* details) {
-  auto* rfh = web_contents_->GetMainFrame();
-  auto* permission_manager = static_cast<AtomPermissionManager*>(
-      web_contents_->GetBrowserContext()->GetPermissionManager());
-  auto origin = web_contents_->GetLastCommittedURL();
-  permission_manager->RequestPermissionWithDetails(
-      permission, rfh, origin, false, details,
-      base::Bind(&OnPermissionResponse, callback));
-}
-
-void WebContentsPermissionHelper::RequestFullscreenPermission(
-    const base::Callback<void(bool)>& callback) {
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::FULLSCREEN),
-      callback);
-}
-
-void WebContentsPermissionHelper::RequestMediaAccessPermission(
-    const content::MediaStreamRequest& request,
-    const content::MediaResponseCallback& response_callback) {
-  auto callback = base::Bind(&MediaAccessAllowed, request, response_callback);
-  // The permission type doesn't matter here, AUDIO_CAPTURE/VIDEO_CAPTURE
-  // are presented as same type in content_converter.h.
-  RequestPermission(content::PermissionType::AUDIO_CAPTURE, callback);
-}
-
-void WebContentsPermissionHelper::RequestWebNotificationPermission(
-    const base::Callback<void(bool)>& callback) {
-  RequestPermission(content::PermissionType::NOTIFICATIONS, callback);
-}
-
-void WebContentsPermissionHelper::RequestPointerLockPermission(
-    bool user_gesture) {
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::POINTER_LOCK),
-      base::Bind(&OnPointerLockResponse, web_contents_), user_gesture);
-}
-
-void WebContentsPermissionHelper::RequestOpenExternalPermission(
-    const base::Callback<void(bool)>& callback,
-    bool user_gesture,
-    const GURL& url) {
-  base::DictionaryValue details;
-  details.SetString("externalURL", url.spec());
-  RequestPermission(
-      static_cast<content::PermissionType>(PermissionType::OPEN_EXTERNAL),
-      callback, user_gesture, &details);
-}
-
-}  // namespace atom
removed in remote
  base   100644 90ae6dff56f5249aeb880e52b6839f26017d474f atom/browser/web_contents_permission_helper.h
  our    100644 322e0972fdec97ec445abc591711b0bab33f54f2 atom/browser/web_contents_permission_helper.h
@@ -1,53 +0,0 @@
-// Copyright (c) 2016 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
-#define ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
-
-#include "content/public/browser/permission_type.h"
-#include "content/public/browser/web_contents_user_data.h"
-#include "content/public/common/media_stream_request.h"
-
-namespace atom {
-
-// Applies the permission requested for WebContents.
-class WebContentsPermissionHelper
-    : public content::WebContentsUserData<WebContentsPermissionHelper> {
- public:
-  ~WebContentsPermissionHelper() override;
-
-  enum class PermissionType {
-    POINTER_LOCK = static_cast<int>(content::PermissionType::NUM) + 1,
-    FULLSCREEN,
-    OPEN_EXTERNAL,
-  };
-
-  void RequestFullscreenPermission(const base::Callback<void(bool)>& callback);
-  void RequestMediaAccessPermission(
-      const content::MediaStreamRequest& request,
-      const content::MediaResponseCallback& callback);
-  void RequestWebNotificationPermission(
-      const base::Callback<void(bool)>& callback);
-  void RequestPointerLockPermission(bool user_gesture);
-  void RequestOpenExternalPermission(const base::Callback<void(bool)>& callback,
-                                     bool user_gesture,
-                                     const GURL& url);
-
- private:
-  explicit WebContentsPermissionHelper(content::WebContents* web_contents);
-  friend class content::WebContentsUserData<WebContentsPermissionHelper>;
-
-  void RequestPermission(content::PermissionType permission,
-                         const base::Callback<void(bool)>& callback,
-                         bool user_gesture = false,
-                         const base::DictionaryValue* details = nullptr);
-
-  content::WebContents* web_contents_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsPermissionHelper);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
removed in remote
  base   100644 3939c59b8cd5ede3e64b93e4e6ea6555f1b2d947 atom/browser/web_contents_preferences.cc
  our    100644 c21c93383155091a7481cdd4e741cefad90a4a55 atom/browser/web_contents_preferences.cc
@@ -1,395 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_contents_preferences.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/web_view_manager.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/options_switches.h"
-#include "base/command_line.h"
-#include "base/memory/ptr_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/utf_string_conversions.h"
-#include "cc/base/switches.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/common/content_switches.h"
-#include "content/public/common/web_preferences.h"
-#include "native_mate/dictionary.h"
-#include "net/base/filename_util.h"
-
-#if defined(OS_WIN)
-#include "ui/gfx/switches.h"
-#endif
-
-DEFINE_WEB_CONTENTS_USER_DATA_KEY(atom::WebContentsPreferences);
-
-namespace {
-
-bool GetAsString(const base::Value* val,
-                 const base::StringPiece& path,
-                 std::string* out) {
-  if (val) {
-    auto* found = val->FindKeyOfType(path, base::Value::Type::STRING);
-    if (found) {
-      *out = found->GetString();
-      return true;
-    }
-  }
-  return false;
-}
-
-bool GetAsString(const base::Value* val,
-                 const base::StringPiece& path,
-                 base::string16* out) {
-  if (val) {
-    auto* found = val->FindKeyOfType(path, base::Value::Type::STRING);
-    if (found) {
-      *out = base::UTF8ToUTF16(found->GetString());
-      return true;
-    }
-  }
-  return false;
-}
-
-bool GetAsInteger(const base::Value* val,
-                  const base::StringPiece& path,
-                  int* out) {
-  if (val) {
-    auto* found = val->FindKey(path);
-    if (found && found->is_int()) {
-      *out = found->GetInt();
-      return true;
-    } else if (found && found->is_string()) {
-      return base::StringToInt(found->GetString(), out);
-    }
-  }
-  return false;
-}
-
-}  // namespace
-
-namespace atom {
-
-// static
-std::vector<WebContentsPreferences*> WebContentsPreferences::instances_;
-
-WebContentsPreferences::WebContentsPreferences(
-    content::WebContents* web_contents,
-    const mate::Dictionary& web_preferences)
-    : web_contents_(web_contents) {
-  v8::Isolate* isolate = web_preferences.isolate();
-  mate::Dictionary copied(isolate, web_preferences.GetHandle()->Clone());
-  // Following fields should not be stored.
-  copied.Delete("embedder");
-  copied.Delete("isGuest");
-  copied.Delete("session");
-
-  mate::ConvertFromV8(isolate, copied.GetHandle(), &preference_);
-  web_contents->SetUserData(UserDataKey(), base::WrapUnique(this));
-
-  instances_.push_back(this);
-
-  // Set WebPreferences defaults onto the JS object
-  SetDefaultBoolIfUndefined(options::kPlugins, false);
-  SetDefaultBoolIfUndefined(options::kExperimentalFeatures, false);
-  bool node = SetDefaultBoolIfUndefined(options::kNodeIntegration, true);
-  SetDefaultBoolIfUndefined(options::kNodeIntegrationInWorker, false);
-  SetDefaultBoolIfUndefined(options::kWebviewTag, node);
-  SetDefaultBoolIfUndefined(options::kSandbox, false);
-  SetDefaultBoolIfUndefined(options::kNativeWindowOpen, false);
-  SetDefaultBoolIfUndefined(options::kContextIsolation, false);
-  SetDefaultBoolIfUndefined("javascript", true);
-  SetDefaultBoolIfUndefined("images", true);
-  SetDefaultBoolIfUndefined("textAreasAreResizable", true);
-  SetDefaultBoolIfUndefined("webgl", true);
-  bool webSecurity = true;
-  SetDefaultBoolIfUndefined(options::kWebSecurity, webSecurity);
-  // If webSecurity was explicity set to false, let's inherit that into
-  // insecureContent
-  if (web_preferences.Get(options::kWebSecurity, &webSecurity) &&
-      !webSecurity) {
-    SetDefaultBoolIfUndefined(options::kAllowRunningInsecureContent, true);
-  } else {
-    SetDefaultBoolIfUndefined(options::kAllowRunningInsecureContent, false);
-  }
-#if defined(OS_MACOSX)
-  SetDefaultBoolIfUndefined(options::kScrollBounce, false);
-#endif
-  SetDefaultBoolIfUndefined(options::kOffscreen, false);
-
-  last_preference_ = preference_.Clone();
-}
-
-WebContentsPreferences::~WebContentsPreferences() {
-  instances_.erase(std::remove(instances_.begin(), instances_.end(), this),
-                   instances_.end());
-}
-
-bool WebContentsPreferences::SetDefaultBoolIfUndefined(
-    const base::StringPiece& key,
-    bool val) {
-  auto* current_value =
-      preference_.FindKeyOfType(key, base::Value::Type::BOOLEAN);
-  if (current_value) {
-    return current_value->GetBool();
-  } else {
-    preference_.SetKey(key, base::Value(val));
-    return val;
-  }
-}
-
-bool WebContentsPreferences::IsEnabled(const base::StringPiece& name,
-                                       bool default_value) const {
-  auto* current_value =
-      preference_.FindKeyOfType(name, base::Value::Type::BOOLEAN);
-  if (current_value)
-    return current_value->GetBool();
-  return default_value;
-}
-
-void WebContentsPreferences::Merge(const base::DictionaryValue& extend) {
-  if (preference_.is_dict())
-    static_cast<base::DictionaryValue*>(&preference_)->MergeDictionary(&extend);
-}
-
-void WebContentsPreferences::Clear() {
-  if (preference_.is_dict())
-    static_cast<base::DictionaryValue*>(&preference_)->Clear();
-}
-
-bool WebContentsPreferences::GetPreference(const base::StringPiece& name,
-                                           std::string* value) const {
-  return GetAsString(&preference_, name, value);
-}
-
-bool WebContentsPreferences::GetPreloadPath(
-    base::FilePath::StringType* path) const {
-  DCHECK(path);
-  base::FilePath::StringType preload;
-  if (GetAsString(&preference_, options::kPreloadScript, &preload)) {
-    if (base::FilePath(preload).IsAbsolute()) {
-      *path = std::move(preload);
-      return true;
-    } else {
-      LOG(ERROR) << "preload script must have absolute path.";
-    }
-  } else if (GetAsString(&preference_, options::kPreloadURL, &preload)) {
-    // Translate to file path if there is "preload-url" option.
-    base::FilePath preload_path;
-    if (net::FileURLToFilePath(GURL(preload), &preload_path)) {
-      *path = std::move(preload_path.value());
-      return true;
-    } else {
-      LOG(ERROR) << "preload url must be file:// protocol.";
-    }
-  }
-  return false;
-}
-
-// static
-content::WebContents* WebContentsPreferences::GetWebContentsFromProcessID(
-    int process_id) {
-  for (WebContentsPreferences* preferences : instances_) {
-    content::WebContents* web_contents = preferences->web_contents_;
-    if (web_contents->GetMainFrame()->GetProcess()->GetID() == process_id)
-      return web_contents;
-  }
-  return nullptr;
-}
-
-// static
-WebContentsPreferences* WebContentsPreferences::From(
-    content::WebContents* web_contents) {
-  if (!web_contents)
-    return nullptr;
-  return FromWebContents(web_contents);
-}
-
-void WebContentsPreferences::AppendCommandLineSwitches(
-    base::CommandLine* command_line) {
-  // Check if plugins are enabled.
-  if (IsEnabled(options::kPlugins))
-    command_line->AppendSwitch(switches::kEnablePlugins);
-
-  // Experimental flags.
-  if (IsEnabled(options::kExperimentalFeatures))
-    command_line->AppendSwitch(
-        ::switches::kEnableExperimentalWebPlatformFeatures);
-
-  // Check if we have node integration specified.
-  bool enable_node_integration = IsEnabled(options::kNodeIntegration, true);
-  command_line->AppendSwitchASCII(switches::kNodeIntegration,
-                                  enable_node_integration ? "true" : "false");
-
-  // Whether to enable node integration in Worker.
-  if (IsEnabled(options::kNodeIntegrationInWorker))
-    command_line->AppendSwitch(switches::kNodeIntegrationInWorker);
-
-  // Check if webview tag creation is enabled, default to nodeIntegration value.
-  // TODO(kevinsawicki): Default to false in 2.0
-  bool webview_tag = IsEnabled(options::kWebviewTag, enable_node_integration);
-  command_line->AppendSwitchASCII(switches::kWebviewTag,
-                                  webview_tag ? "true" : "false");
-
-  // If the `sandbox` option was passed to the BrowserWindow's webPreferences,
-  // pass `--enable-sandbox` to the renderer so it won't have any node.js
-  // integration.
-  if (IsEnabled(options::kSandbox))
-    command_line->AppendSwitch(switches::kEnableSandbox);
-  else if (!command_line->HasSwitch(switches::kEnableSandbox))
-    command_line->AppendSwitch(::switches::kNoSandbox);
-
-  // Check if nativeWindowOpen is enabled.
-  if (IsEnabled(options::kNativeWindowOpen))
-    command_line->AppendSwitch(switches::kNativeWindowOpen);
-
-  // The preload script.
-  base::FilePath::StringType preload;
-  if (GetPreloadPath(&preload))
-    command_line->AppendSwitchNative(switches::kPreloadScript, preload);
-
-  // Custom args for renderer process
-  auto* customArgs =
-      preference_.FindKeyOfType(options::kCustomArgs, base::Value::Type::LIST);
-  if (customArgs) {
-    for (const auto& customArg : customArgs->GetList()) {
-      if (customArg.is_string())
-        command_line->AppendArg(customArg.GetString());
-    }
-  }
-
-  // Run Electron APIs and preload script in isolated world
-  if (IsEnabled(options::kContextIsolation))
-    command_line->AppendSwitch(switches::kContextIsolation);
-
-  // --background-color.
-  std::string s;
-  if (GetAsString(&preference_, options::kBackgroundColor, &s))
-    command_line->AppendSwitchASCII(switches::kBackgroundColor, s);
-
-  // --guest-instance-id, which is used to identify guest WebContents.
-  int guest_instance_id = 0;
-  if (GetAsInteger(&preference_, options::kGuestInstanceID, &guest_instance_id))
-    command_line->AppendSwitchASCII(switches::kGuestInstanceID,
-                                    base::IntToString(guest_instance_id));
-
-  // Pass the opener's window id.
-  int opener_id;
-  if (GetAsInteger(&preference_, options::kOpenerID, &opener_id))
-    command_line->AppendSwitchASCII(switches::kOpenerID,
-                                    base::IntToString(opener_id));
-
-#if defined(OS_MACOSX)
-  // Enable scroll bounce.
-  if (IsEnabled(options::kScrollBounce))
-    command_line->AppendSwitch(switches::kScrollBounce);
-#endif
-
-  // Custom command line switches.
-  auto* args =
-      preference_.FindKeyOfType("commandLineSwitches", base::Value::Type::LIST);
-  if (args) {
-    for (const auto& arg : args->GetList()) {
-      if (arg.is_string()) {
-        const auto& arg_val = arg.GetString();
-        if (!arg_val.empty())
-          command_line->AppendSwitch(arg_val);
-      }
-    }
-  }
-
-  // Enable blink features.
-  if (GetAsString(&preference_, options::kEnableBlinkFeatures, &s))
-    command_line->AppendSwitchASCII(::switches::kEnableBlinkFeatures, s);
-
-  // Disable blink features.
-  if (GetAsString(&preference_, options::kDisableBlinkFeatures, &s))
-    command_line->AppendSwitchASCII(::switches::kDisableBlinkFeatures, s);
-
-  if (guest_instance_id) {
-    // Webview `document.visibilityState` tracks window visibility so we need
-    // to let it know if the window happens to be hidden right now.
-    auto* manager = WebViewManager::GetWebViewManager(web_contents_);
-    if (manager) {
-      auto* embedder = manager->GetEmbedder(guest_instance_id);
-      if (embedder) {
-        auto* relay = NativeWindowRelay::FromWebContents(embedder);
-        if (relay) {
-          auto* window = relay->window.get();
-          if (window) {
-            const bool visible = window->IsVisible() && !window->IsMinimized();
-            if (!visible) {
-              command_line->AppendSwitch(switches::kHiddenPage);
-            }
-          }
-        }
-      }
-    }
-  }
-
-  // We are appending args to a webContents so let's save the current state
-  // of our preferences object so that during the lifetime of the WebContents
-  // we can fetch the options used to initally configure the WebContents
-  last_preference_ = preference_.Clone();
-}
-
-void WebContentsPreferences::OverrideWebkitPrefs(
-    content::WebPreferences* prefs) {
-  prefs->javascript_enabled = IsEnabled("javascript", true /* default_value */);
-  prefs->images_enabled = IsEnabled("images", true /* default_value */);
-  prefs->text_areas_are_resizable =
-      IsEnabled("textAreasAreResizable", true /* default_value */);
-  prefs->navigate_on_drag_drop =
-      IsEnabled("navigateOnDragDrop", false /* default_value */);
-
-  // Check if webgl should be enabled.
-  bool is_webgl_enabled = IsEnabled("webgl", true /* default_value */);
-  prefs->webgl1_enabled = is_webgl_enabled;
-  prefs->webgl2_enabled = is_webgl_enabled;
-
-  // Check if web security should be enabled.
-  bool is_web_security_enabled =
-      IsEnabled(options::kWebSecurity, true /* default_value */);
-  prefs->web_security_enabled = is_web_security_enabled;
-  prefs->allow_running_insecure_content =
-      IsEnabled(options::kAllowRunningInsecureContent,
-                !is_web_security_enabled /* default_value */);
-
-  auto* fonts_dict = preference_.FindKeyOfType("defaultFontFamily",
-                                               base::Value::Type::DICTIONARY);
-  if (fonts_dict) {
-    base::string16 font;
-    if (GetAsString(fonts_dict, "standard", &font))
-      prefs->standard_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "serif", &font))
-      prefs->serif_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "sansSerif", &font))
-      prefs->sans_serif_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "monospace", &font))
-      prefs->fixed_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "cursive", &font))
-      prefs->cursive_font_family_map[content::kCommonScript] = font;
-    if (GetAsString(fonts_dict, "fantasy", &font))
-      prefs->fantasy_font_family_map[content::kCommonScript] = font;
-  }
-
-  int size;
-  if (GetAsInteger(&preference_, "defaultFontSize", &size))
-    prefs->default_font_size = size;
-  if (GetAsInteger(&preference_, "defaultMonospaceFontSize", &size))
-    prefs->default_fixed_font_size = size;
-  if (GetAsInteger(&preference_, "minimumFontSize", &size))
-    prefs->minimum_font_size = size;
-  std::string encoding;
-  if (GetAsString(&preference_, "defaultEncoding", &encoding))
-    prefs->default_encoding = encoding;
-}
-
-}  // namespace atom
removed in remote
  base   100644 dd98a9658acfce4154da3bd64e6faa4698a9cd33 atom/browser/web_contents_preferences.h
  our    100644 d835347afcd259f473f95271a2c19e42afcc6f2b atom/browser/web_contents_preferences.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
-#define ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
-
-#include <string>
-#include <vector>
-
-#include "base/values.h"
-#include "content/public/browser/web_contents_user_data.h"
-
-namespace base {
-class CommandLine;
-}
-
-namespace content {
-struct WebPreferences;
-}
-
-namespace mate {
-class Dictionary;
-}
-
-namespace atom {
-
-// Stores and applies the preferences of WebContents.
-class WebContentsPreferences
-    : public content::WebContentsUserData<WebContentsPreferences> {
- public:
-  // Get self from WebContents.
-  static WebContentsPreferences* From(content::WebContents* web_contents);
-
-  WebContentsPreferences(content::WebContents* web_contents,
-                         const mate::Dictionary& web_preferences);
-  ~WebContentsPreferences() override;
-
-  // A simple way to know whether a Boolean property is enabled.
-  bool IsEnabled(const base::StringPiece& name,
-                 bool default_value = false) const;
-
-  // $.extend(|web_preferences|, |new_web_preferences|).
-  void Merge(const base::DictionaryValue& new_web_preferences);
-
-  // Append command paramters according to preferences.
-  void AppendCommandLineSwitches(base::CommandLine* command_line);
-
-  // Modify the WebPreferences according to preferences.
-  void OverrideWebkitPrefs(content::WebPreferences* prefs);
-
-  // Clear the current WebPreferences.
-  void Clear();
-
-  // Return true if the particular preference value exists.
-  bool GetPreference(const base::StringPiece& name, std::string* value) const;
-
-  // Returns the preload script path.
-  bool GetPreloadPath(base::FilePath::StringType* path) const;
-
-  // Returns the web preferences.
-  base::Value* preference() { return &preference_; }
-  base::Value* last_preference() { return &last_preference_; }
-
- private:
-  friend class content::WebContentsUserData<WebContentsPreferences>;
-  friend class AtomBrowserClient;
-
-  // Get WebContents according to process ID.
-  static content::WebContents* GetWebContentsFromProcessID(int process_id);
-
-  // Set preference value to given bool if user did not provide value
-  bool SetDefaultBoolIfUndefined(const base::StringPiece& key, bool val);
-
-  static std::vector<WebContentsPreferences*> instances_;
-
-  content::WebContents* web_contents_;
-
-  base::Value preference_ = base::Value(base::Value::Type::DICTIONARY);
-  base::Value last_preference_ = base::Value(base::Value::Type::DICTIONARY);
-
-  DISALLOW_COPY_AND_ASSIGN(WebContentsPreferences);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_CONTENTS_PREFERENCES_H_
removed in remote
  base   100644 c3d2a1d0f23fb5bdb77a377f8ad1e5697e76ed42 atom/browser/web_dialog_helper.cc
  our    100644 74c8573d13f15bcaa189abdc40fa0cd8e48f89be atom/browser/web_dialog_helper.cc
@@ -1,261 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_dialog_helper.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/atom_browser_context.h"
-#include "atom/browser/native_window.h"
-#include "atom/browser/ui/file_dialog.h"
-#include "base/bind.h"
-#include "base/files/file_enumerator.h"
-#include "base/files/file_path.h"
-#include "base/strings/utf_string_conversions.h"
-#include "chrome/common/pref_names.h"
-#include "components/prefs/pref_service.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/file_chooser_file_info.h"
-#include "content/public/common/file_chooser_params.h"
-#include "net/base/mime_util.h"
-#include "ui/shell_dialogs/selected_file_info.h"
-
-namespace {
-
-class FileSelectHelper : public base::RefCounted<FileSelectHelper>,
-                         public content::WebContentsObserver {
- public:
-  FileSelectHelper(content::RenderFrameHost* render_frame_host,
-                   const content::FileChooserParams::Mode& mode)
-      : render_frame_host_(render_frame_host), mode_(mode) {
-    auto* web_contents =
-        content::WebContents::FromRenderFrameHost(render_frame_host);
-    content::WebContentsObserver::Observe(web_contents);
-  }
-
-  void ShowOpenDialog(const file_dialog::DialogSettings& settings) {
-    auto callback = base::Bind(&FileSelectHelper::OnOpenDialogDone, this);
-    file_dialog::ShowOpenDialog(settings, callback);
-  }
-
-  void ShowSaveDialog(const file_dialog::DialogSettings& settings) {
-    auto callback = base::Bind(&FileSelectHelper::OnSaveDialogDone, this);
-    file_dialog::ShowSaveDialog(settings, callback);
-  }
-
- private:
-  friend class base::RefCounted<FileSelectHelper>;
-
-  ~FileSelectHelper() override {}
-
-#if defined(MAS_BUILD)
-  void OnOpenDialogDone(bool result,
-                        const std::vector<base::FilePath>& paths,
-                        const std::vector<std::string>& bookmarks)
-#else
-  void OnOpenDialogDone(bool result, const std::vector<base::FilePath>& paths)
-#endif
-  {
-    std::vector<content::FileChooserFileInfo> file_info;
-    if (result) {
-      for (auto& path : paths) {
-        content::FileChooserFileInfo info;
-        info.file_path = path;
-        info.display_name = path.BaseName().value();
-        file_info.push_back(info);
-      }
-
-      if (render_frame_host_ && !paths.empty()) {
-        auto* browser_context = static_cast<atom::AtomBrowserContext*>(
-            render_frame_host_->GetProcess()->GetBrowserContext());
-        browser_context->prefs()->SetFilePath(prefs::kSelectFileLastDirectory,
-                                              paths[0].DirName());
-      }
-    }
-    OnFilesSelected(file_info);
-  }
-
-#if defined(MAS_BUILD)
-  void OnSaveDialogDone(bool result,
-                        const base::FilePath& path,
-                        const std::string& bookmark)
-#else
-  void OnSaveDialogDone(bool result, const base::FilePath& path)
-#endif
-  {
-    std::vector<content::FileChooserFileInfo> file_info;
-    if (result) {
-      content::FileChooserFileInfo info;
-      info.file_path = path;
-      info.display_name = path.BaseName().value();
-      file_info.push_back(info);
-    }
-    OnFilesSelected(file_info);
-  }
-
-  void OnFilesSelected(
-      const std::vector<content::FileChooserFileInfo>& file_info) {
-    if (render_frame_host_)
-      render_frame_host_->FilesSelectedInChooser(file_info, mode_);
-  }
-
-  // content::WebContentsObserver:
-  void RenderFrameHostChanged(content::RenderFrameHost* old_host,
-                              content::RenderFrameHost* new_host) override {
-    if (old_host == render_frame_host_)
-      render_frame_host_ = nullptr;
-  }
-
-  // content::WebContentsObserver:
-  void RenderFrameDeleted(content::RenderFrameHost* deleted_host) override {
-    if (deleted_host == render_frame_host_)
-      render_frame_host_ = nullptr;
-  }
-
-  // content::WebContentsObserver:
-  void WebContentsDestroyed() override { render_frame_host_ = nullptr; }
-
-  content::RenderFrameHost* render_frame_host_;
-  content::FileChooserParams::Mode mode_;
-};
-
-file_dialog::Filters GetFileTypesFromAcceptType(
-    const std::vector<base::string16>& accept_types) {
-  file_dialog::Filters filters;
-  if (accept_types.empty())
-    return filters;
-
-  std::vector<base::FilePath::StringType> extensions;
-
-  int valid_type_count = 0;
-  std::string description;
-
-  for (const auto& accept_type : accept_types) {
-    std::string ascii_type = base::UTF16ToASCII(accept_type);
-    auto old_extension_size = extensions.size();
-
-    if (ascii_type[0] == '.') {
-      // If the type starts with a period it is assumed to be a file extension,
-      // like `.txt`, // so we just have to add it to the list.
-      base::FilePath::StringType extension(ascii_type.begin(),
-                                           ascii_type.end());
-      // Skip the first character.
-      extensions.push_back(extension.substr(1));
-    } else {
-      if (ascii_type == "image/*")
-        description = "Image Files";
-      else if (ascii_type == "audio/*")
-        description = "Audio Files";
-      else if (ascii_type == "video/*")
-        description = "Video Files";
-
-      // For MIME Type, `audio/*, video/*, image/*
-      net::GetExtensionsForMimeType(ascii_type, &extensions);
-    }
-
-    if (extensions.size() > old_extension_size)
-      valid_type_count++;
-  }
-
-  // If no valid exntesion is added, return empty filters.
-  if (extensions.empty())
-    return filters;
-
-  filters.push_back(file_dialog::Filter());
-
-  if (valid_type_count > 1 || (valid_type_count == 1 && description.empty()))
-    description = "Custom Files";
-
-  DCHECK(!description.empty());
-  filters[0].first = description;
-
-  for (const auto& extension : extensions) {
-#if defined(OS_WIN)
-    filters[0].second.push_back(base::UTF16ToASCII(extension));
-#else
-    filters[0].second.push_back(extension);
-#endif
-  }
-
-  // Allow all files when extension is specified.
-  filters.push_back(file_dialog::Filter());
-  filters.back().first = "All Files";
-  filters.back().second.push_back("*");
-
-  return filters;
-}
-
-}  // namespace
-
-namespace atom {
-
-WebDialogHelper::WebDialogHelper(NativeWindow* window, bool offscreen)
-    : window_(window), offscreen_(offscreen), weak_factory_(this) {}
-
-WebDialogHelper::~WebDialogHelper() {}
-
-void WebDialogHelper::RunFileChooser(
-    content::RenderFrameHost* render_frame_host,
-    const content::FileChooserParams& params) {
-  std::vector<content::FileChooserFileInfo> result;
-
-  file_dialog::DialogSettings settings;
-  settings.force_detached = offscreen_;
-  settings.filters = GetFileTypesFromAcceptType(params.accept_types);
-  settings.parent_window = window_;
-  settings.title = base::UTF16ToUTF8(params.title);
-
-  scoped_refptr<FileSelectHelper> file_select_helper(
-      new FileSelectHelper(render_frame_host, params.mode));
-  if (params.mode == content::FileChooserParams::Save) {
-    settings.default_path = params.default_file_name;
-    file_select_helper->ShowSaveDialog(settings);
-  } else {
-    int flags = file_dialog::FILE_DIALOG_CREATE_DIRECTORY;
-    switch (params.mode) {
-      case content::FileChooserParams::OpenMultiple:
-        flags |= file_dialog::FILE_DIALOG_MULTI_SELECTIONS;
-        FALLTHROUGH;
-      case content::FileChooserParams::Open:
-        flags |= file_dialog::FILE_DIALOG_OPEN_FILE;
-        flags |= file_dialog::FILE_DIALOG_TREAT_PACKAGE_APP_AS_DIRECTORY;
-        break;
-      case content::FileChooserParams::UploadFolder:
-        flags |= file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
-        break;
-      default:
-        NOTREACHED();
-    }
-
-    auto* browser_context = static_cast<atom::AtomBrowserContext*>(
-        render_frame_host->GetProcess()->GetBrowserContext());
-    settings.default_path = browser_context->prefs()
-                                ->GetFilePath(prefs::kSelectFileLastDirectory)
-                                .Append(params.default_file_name);
-    settings.properties = flags;
-    file_select_helper->ShowOpenDialog(settings);
-  }
-}
-
-void WebDialogHelper::EnumerateDirectory(content::WebContents* web_contents,
-                                         int request_id,
-                                         const base::FilePath& dir) {
-  int types = base::FileEnumerator::FILES | base::FileEnumerator::DIRECTORIES |
-              base::FileEnumerator::INCLUDE_DOT_DOT;
-  base::FileEnumerator file_enum(dir, false, types);
-
-  base::FilePath path;
-  std::vector<base::FilePath> paths;
-  while (!(path = file_enum.Next()).empty())
-    paths.push_back(path);
-
-  web_contents->GetRenderViewHost()->DirectoryEnumerationFinished(request_id,
-                                                                  paths);
-}
-
-}  // namespace atom
removed in remote
  base   100644 a3472da4acbb936659f05670214fad62a98f5aa5 atom/browser/web_dialog_helper.h
  our    100644 e08a1a915bc29c049e9258a4f213e3dc4428208e atom/browser/web_dialog_helper.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_DIALOG_HELPER_H_
-#define ATOM_BROWSER_WEB_DIALOG_HELPER_H_
-
-#include "base/memory/weak_ptr.h"
-
-namespace base {
-class FilePath;
-}
-
-namespace content {
-struct FileChooserParams;
-class RenderFrameHost;
-class WebContents;
-}  // namespace content
-
-namespace atom {
-
-class NativeWindow;
-
-class WebDialogHelper {
- public:
-  WebDialogHelper(NativeWindow* window, bool offscreen);
-  ~WebDialogHelper();
-
-  void RunFileChooser(content::RenderFrameHost* render_frame_host,
-                      const content::FileChooserParams& params);
-  void EnumerateDirectory(content::WebContents* web_contents,
-                          int request_id,
-                          const base::FilePath& path);
-
- private:
-  NativeWindow* window_;
-  bool offscreen_;
-
-  base::WeakPtrFactory<WebDialogHelper> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebDialogHelper);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_DIALOG_HELPER_H_
removed in remote
  base   100644 6abb9713bfac2ee22a0c0cd5a8f601887a3d5503 atom/browser/web_view_guest_delegate.cc
  our    100644 27fbff7e9e3633bd17c54b4c67ba4a1d5993e449 atom/browser/web_view_guest_delegate.cc
@@ -1,116 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_view_guest_delegate.h"
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "content/browser/web_contents/web_contents_impl.h"
-#include "content/public/browser/navigation_handle.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/render_view_host.h"
-#include "content/public/browser/render_widget_host.h"
-#include "content/public/browser/render_widget_host_view.h"
-
-namespace atom {
-
-WebViewGuestDelegate::WebViewGuestDelegate(content::WebContents* embedder,
-                                           api::WebContents* api_web_contents)
-    : embedder_web_contents_(embedder), api_web_contents_(api_web_contents) {}
-
-WebViewGuestDelegate::~WebViewGuestDelegate() {
-  ResetZoomController();
-}
-
-void WebViewGuestDelegate::AttachToIframe(
-    content::WebContents* embedder_web_contents,
-    int embedder_frame_id) {
-  embedder_web_contents_ = embedder_web_contents;
-
-  int embedder_process_id =
-      embedder_web_contents_->GetMainFrame()->GetProcess()->GetID();
-  auto* embedder_frame =
-      content::RenderFrameHost::FromID(embedder_process_id, embedder_frame_id);
-  DCHECK_EQ(embedder_web_contents_,
-            content::WebContents::FromRenderFrameHost(embedder_frame));
-
-  // Attach this inner WebContents |guest_web_contents| to the outer
-  // WebContents |embedder_web_contents|. The outer WebContents's
-  // frame |embedder_frame| hosts the inner WebContents.
-  api_web_contents_->web_contents()->AttachToOuterWebContentsFrame(
-      embedder_web_contents_, embedder_frame);
-
-  ResetZoomController();
-
-  embedder_zoom_controller_ =
-      WebContentsZoomController::FromWebContents(embedder_web_contents_);
-  embedder_zoom_controller_->AddObserver(this);
-  auto* zoom_controller = api_web_contents_->GetZoomController();
-  zoom_controller->SetEmbedderZoomController(embedder_zoom_controller_);
-
-  api_web_contents_->Emit("did-attach");
-}
-
-void WebViewGuestDelegate::DidDetach() {
-  ResetZoomController();
-}
-
-content::WebContents* WebViewGuestDelegate::GetOwnerWebContents() const {
-  return embedder_web_contents_;
-}
-
-void WebViewGuestDelegate::OnZoomLevelChanged(
-    content::WebContents* web_contents,
-    double level,
-    bool is_temporary) {
-  if (web_contents == GetOwnerWebContents()) {
-    if (is_temporary) {
-      api_web_contents_->GetZoomController()->SetTemporaryZoomLevel(level);
-    } else {
-      api_web_contents_->GetZoomController()->SetZoomLevel(level);
-    }
-    // Change the default zoom factor to match the embedders' new zoom level.
-    double zoom_factor = content::ZoomLevelToZoomFactor(level);
-    api_web_contents_->GetZoomController()->SetDefaultZoomFactor(zoom_factor);
-  }
-}
-
-void WebViewGuestDelegate::OnZoomControllerWebContentsDestroyed() {
-  ResetZoomController();
-}
-
-void WebViewGuestDelegate::ResetZoomController() {
-  if (embedder_zoom_controller_) {
-    embedder_zoom_controller_->RemoveObserver(this);
-    embedder_zoom_controller_ = nullptr;
-  }
-}
-
-content::RenderWidgetHost* WebViewGuestDelegate::GetOwnerRenderWidgetHost() {
-  return embedder_web_contents_->GetRenderViewHost()->GetWidget();
-}
-
-content::SiteInstance* WebViewGuestDelegate::GetOwnerSiteInstance() {
-  return embedder_web_contents_->GetSiteInstance();
-}
-
-content::WebContents* WebViewGuestDelegate::CreateNewGuestWindow(
-    const content::WebContents::CreateParams& create_params) {
-  // Code below mirrors what content::WebContentsImpl::CreateNewWindow
-  // does for non-guest sources
-  content::WebContents::CreateParams guest_params(create_params);
-  guest_params.initial_size =
-      embedder_web_contents_->GetContainerBounds().size();
-  guest_params.context = embedder_web_contents_->GetNativeView();
-  auto* guest_contents = content::WebContents::Create(guest_params);
-  auto* guest_contents_impl =
-      static_cast<content::WebContentsImpl*>(guest_contents);
-  guest_contents_impl->GetView()->CreateViewForWidget(
-      guest_contents->GetRenderViewHost()->GetWidget(), false);
-
-  return guest_contents;
-}
-
-}  // namespace atom
removed in remote
  base   100644 95888ff749fda896a7355d7af743918a670a1bc6 atom/browser/web_view_guest_delegate.h
  our    100644 6d9f440588d1d38a869ca6b6a33fd31031091efa atom/browser/web_view_guest_delegate.h
@@ -1,60 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
-#define ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
-
-#include "atom/browser/web_contents_zoom_controller.h"
-#include "content/public/browser/browser_plugin_guest_delegate.h"
-
-namespace atom {
-
-namespace api {
-class WebContents;
-}
-
-class WebViewGuestDelegate : public content::BrowserPluginGuestDelegate,
-                             public WebContentsZoomController::Observer {
- public:
-  WebViewGuestDelegate(content::WebContents* embedder,
-                       api::WebContents* api_web_contents);
-  ~WebViewGuestDelegate() override;
-
-  // Attach to the iframe.
-  void AttachToIframe(content::WebContents* embedder_web_contents,
-                      int embedder_frame_id);
-
- protected:
-  // content::BrowserPluginGuestDelegate:
-  void DidDetach() final;
-  content::WebContents* GetOwnerWebContents() const final;
-  content::RenderWidgetHost* GetOwnerRenderWidgetHost() final;
-  content::SiteInstance* GetOwnerSiteInstance() final;
-  content::WebContents* CreateNewGuestWindow(
-      const content::WebContents::CreateParams& create_params) final;
-
-  // WebContentsZoomController::Observer:
-  void OnZoomLevelChanged(content::WebContents* web_contents,
-                          double level,
-                          bool is_temporary) override;
-  void OnZoomControllerWebContentsDestroyed() override;
-
- private:
-  void ResetZoomController();
-
-  // The WebContents that attaches this guest view.
-  content::WebContents* embedder_web_contents_ = nullptr;
-
-  // The zoom controller of the embedder that is used
-  // to subscribe for zoom changes.
-  WebContentsZoomController* embedder_zoom_controller_ = nullptr;
-
-  api::WebContents* api_web_contents_ = nullptr;
-
-  DISALLOW_COPY_AND_ASSIGN(WebViewGuestDelegate);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
removed in remote
  base   100644 d404c1a4368011301c2f133fac5e4934ada03c04 atom/browser/web_view_manager.cc
  our    100644 9448f58d51388c31f4b1ed97e36ea20f1d7dc26c atom/browser/web_view_manager.cc
@@ -1,86 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/web_view_manager.h"
-
-#include "atom/browser/atom_browser_context.h"
-#include "content/public/browser/render_frame_host.h"
-#include "content/public/browser/render_process_host.h"
-#include "content/public/browser/web_contents.h"
-
-namespace atom {
-
-WebViewManager::WebViewManager() {}
-
-WebViewManager::~WebViewManager() {}
-
-void WebViewManager::AddGuest(int guest_instance_id,
-                              int element_instance_id,
-                              content::WebContents* embedder,
-                              content::WebContents* web_contents) {
-  web_contents_embedder_map_[guest_instance_id] = {web_contents, embedder};
-
-  // Map the element in embedder to guest.
-  int owner_process_id = embedder->GetMainFrame()->GetProcess()->GetID();
-  ElementInstanceKey key(owner_process_id, element_instance_id);
-  element_instance_id_to_guest_map_[key] = guest_instance_id;
-}
-
-void WebViewManager::RemoveGuest(int guest_instance_id) {
-  if (!base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return;
-
-  web_contents_embedder_map_.erase(guest_instance_id);
-
-  // Remove the record of element in embedder too.
-  for (const auto& element : element_instance_id_to_guest_map_)
-    if (element.second == guest_instance_id) {
-      element_instance_id_to_guest_map_.erase(element.first);
-      break;
-    }
-}
-
-content::WebContents* WebViewManager::GetEmbedder(int guest_instance_id) {
-  if (base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return web_contents_embedder_map_[guest_instance_id].embedder;
-  else
-    return nullptr;
-}
-
-content::WebContents* WebViewManager::GetGuestByInstanceID(
-    int owner_process_id,
-    int element_instance_id) {
-  ElementInstanceKey key(owner_process_id, element_instance_id);
-  if (!base::ContainsKey(element_instance_id_to_guest_map_, key))
-    return nullptr;
-
-  int guest_instance_id = element_instance_id_to_guest_map_[key];
-  if (base::ContainsKey(web_contents_embedder_map_, guest_instance_id))
-    return web_contents_embedder_map_[guest_instance_id].web_contents;
-  else
-    return nullptr;
-}
-
-bool WebViewManager::ForEachGuest(content::WebContents* embedder_web_contents,
-                                  const GuestCallback& callback) {
-  for (auto& item : web_contents_embedder_map_)
-    if (item.second.embedder == embedder_web_contents &&
-        callback.Run(item.second.web_contents))
-      return true;
-  return false;
-}
-
-// static
-WebViewManager* WebViewManager::GetWebViewManager(
-    content::WebContents* web_contents) {
-  auto* context = web_contents->GetBrowserContext();
-  if (context) {
-    auto* manager = context->GetGuestManager();
-    return static_cast<WebViewManager*>(manager);
-  } else {
-    return nullptr;
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 ff9a8ecba2abca5e8b3c5513694ec01c95190e93 atom/browser/web_view_manager.h
  our    100644 1adc27678da96b72889c246674afedda30dc37f0 atom/browser/web_view_manager.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WEB_VIEW_MANAGER_H_
-#define ATOM_BROWSER_WEB_VIEW_MANAGER_H_
-
-#include <map>
-
-#include "content/public/browser/browser_plugin_guest_manager.h"
-
-namespace atom {
-
-class WebViewManager : public content::BrowserPluginGuestManager {
- public:
-  WebViewManager();
-  ~WebViewManager() override;
-
-  void AddGuest(int guest_instance_id,
-                int element_instance_id,
-                content::WebContents* embedder,
-                content::WebContents* web_contents);
-  void RemoveGuest(int guest_instance_id);
-  content::WebContents* GetEmbedder(int guest_instance_id);
-
-  static WebViewManager* GetWebViewManager(content::WebContents* web_contents);
-
- protected:
-  // content::BrowserPluginGuestManager:
-  content::WebContents* GetGuestByInstanceID(int owner_process_id,
-                                             int element_instance_id) override;
-  bool ForEachGuest(content::WebContents* embedder,
-                    const GuestCallback& callback) override;
-
- private:
-  struct WebContentsWithEmbedder {
-    content::WebContents* web_contents;
-    content::WebContents* embedder;
-  };
-  // guest_instance_id => (web_contents, embedder)
-  std::map<int, WebContentsWithEmbedder> web_contents_embedder_map_;
-
-  struct ElementInstanceKey {
-    int embedder_process_id;
-    int element_instance_id;
-
-    ElementInstanceKey(int embedder_process_id, int element_instance_id)
-        : embedder_process_id(embedder_process_id),
-          element_instance_id(element_instance_id) {}
-
-    bool operator<(const ElementInstanceKey& other) const {
-      if (embedder_process_id != other.embedder_process_id)
-        return embedder_process_id < other.embedder_process_id;
-      return element_instance_id < other.element_instance_id;
-    }
-
-    bool operator==(const ElementInstanceKey& other) const {
-      return (embedder_process_id == other.embedder_process_id) &&
-             (element_instance_id == other.element_instance_id);
-    }
-  };
-  // (embedder_process_id, element_instance_id) => guest_instance_id
-  std::map<ElementInstanceKey, int> element_instance_id_to_guest_map_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebViewManager);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WEB_VIEW_MANAGER_H_
removed in remote
  base   100644 b3bec5d08c1c017105cde2b9e034a3e7c49d15c5 atom/browser/window_list.cc
  our    100644 97561d16f38d29429550a611d58fc08ae06edd38 atom/browser/window_list.cc
@@ -1,103 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/browser/window_list.h"
-
-#include <algorithm>
-
-#include "atom/browser/native_window.h"
-#include "atom/browser/window_list_observer.h"
-#include "base/logging.h"
-
-namespace atom {
-
-// static
-base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
-    WindowList::observers_ = LAZY_INSTANCE_INITIALIZER;
-
-// static
-WindowList* WindowList::instance_ = nullptr;
-
-// static
-WindowList* WindowList::GetInstance() {
-  if (!instance_)
-    instance_ = new WindowList;
-  return instance_;
-}
-
-// static
-WindowList::WindowVector WindowList::GetWindows() {
-  return GetInstance()->windows_;
-}
-
-// static
-bool WindowList::IsEmpty() {
-  return GetInstance()->windows_.empty();
-}
-
-// static
-void WindowList::AddWindow(NativeWindow* window) {
-  DCHECK(window);
-  // Push |window| on the appropriate list instance.
-  WindowVector& windows = GetInstance()->windows_;
-  windows.push_back(window);
-
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowAdded(window);
-}
-
-// static
-void WindowList::RemoveWindow(NativeWindow* window) {
-  WindowVector& windows = GetInstance()->windows_;
-  windows.erase(std::remove(windows.begin(), windows.end(), window),
-                windows.end());
-
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowRemoved(window);
-
-  if (windows.empty()) {
-    for (WindowListObserver& observer : observers_.Get())
-      observer.OnWindowAllClosed();
-  }
-}
-
-// static
-void WindowList::WindowCloseCancelled(NativeWindow* window) {
-  for (WindowListObserver& observer : observers_.Get())
-    observer.OnWindowCloseCancelled(window);
-}
-
-// static
-void WindowList::AddObserver(WindowListObserver* observer) {
-  observers_.Get().AddObserver(observer);
-}
-
-// static
-void WindowList::RemoveObserver(WindowListObserver* observer) {
-  observers_.Get().RemoveObserver(observer);
-}
-
-// static
-void WindowList::CloseAllWindows() {
-  WindowVector windows = GetInstance()->windows_;
-#if defined(OS_MACOSX)
-  std::reverse(windows.begin(), windows.end());
-#endif
-  for (auto* const& window : windows)
-    if (!window->IsClosed())
-      window->Close();
-}
-
-// static
-void WindowList::DestroyAllWindows() {
-  WindowVector windows = GetInstance()->windows_;
-  for (auto* const& window : windows)
-    window->CloseImmediately();  // e.g. Destroy()
-}
-
-WindowList::WindowList() {}
-
-WindowList::~WindowList() {}
-
-}  // namespace atom
removed in remote
  base   100644 3dd87b2c34c296ef2e25c6ad21be318987fc3680 atom/browser/window_list.h
  our    100644 e336c8073dc86e2a3124457afe009b703b667658 atom/browser/window_list.h
@@ -1,64 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WINDOW_LIST_H_
-#define ATOM_BROWSER_WINDOW_LIST_H_
-
-#include <vector>
-
-#include "base/lazy_instance.h"
-#include "base/macros.h"
-#include "base/observer_list.h"
-
-namespace atom {
-
-class NativeWindow;
-class WindowListObserver;
-
-class WindowList {
- public:
-  typedef std::vector<NativeWindow*> WindowVector;
-
-  static WindowVector GetWindows();
-  static bool IsEmpty();
-
-  // Adds or removes |window| from the list it is associated with.
-  static void AddWindow(NativeWindow* window);
-  static void RemoveWindow(NativeWindow* window);
-
-  // Called by window when a close is cancelled by beforeunload handler.
-  static void WindowCloseCancelled(NativeWindow* window);
-
-  // Adds and removes |observer| from the observer list.
-  static void AddObserver(WindowListObserver* observer);
-  static void RemoveObserver(WindowListObserver* observer);
-
-  // Closes all windows.
-  static void CloseAllWindows();
-
-  // Destroy all windows.
-  static void DestroyAllWindows();
-
- private:
-  static WindowList* GetInstance();
-
-  WindowList();
-  ~WindowList();
-
-  // A vector of the windows in this list, in the order they were added.
-  WindowVector windows_;
-
-  // A list of observers which will be notified of every window addition and
-  // removal across all WindowLists.
-  static base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
-      observers_;
-
-  static WindowList* instance_;
-
-  DISALLOW_COPY_AND_ASSIGN(WindowList);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WINDOW_LIST_H_
removed in remote
  base   100644 424efa25a2b01aba5f640f672b7015d547c861ba atom/browser/window_list_observer.h
  our    100644 424efa25a2b01aba5f640f672b7015d547c861ba atom/browser/window_list_observer.h
@@ -1,32 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
-#define ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
-
-namespace atom {
-
-class NativeWindow;
-
-class WindowListObserver {
- public:
-  // Called immediately after a window is added to the list.
-  virtual void OnWindowAdded(NativeWindow* window) {}
-
-  // Called immediately after a window is removed from the list.
-  virtual void OnWindowRemoved(NativeWindow* window) {}
-
-  // Called when a window close is cancelled by beforeunload handler.
-  virtual void OnWindowCloseCancelled(NativeWindow* window) {}
-
-  // Called immediately after all windows are closed.
-  virtual void OnWindowAllClosed() {}
-
- protected:
-  virtual ~WindowListObserver() {}
-};
-
-}  // namespace atom
-
-#endif  // ATOM_BROWSER_WINDOW_LIST_OBSERVER_H_
removed in remote
  base   100644 eeb26614847b0bbe33b006909103f6e23ceb1bac atom/common/api/api_messages.h
  our    100644 6131a7a473c68e31790fcd8697c8f380c65ad275 atom/common/api/api_messages.h
@@ -1,71 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Multiply-included file, no traditional include guard.
-
-#include "atom/common/draggable_region.h"
-#include "base/strings/string16.h"
-#include "base/values.h"
-#include "content/public/common/common_param_traits.h"
-#include "content/public/common/referrer.h"
-#include "ipc/ipc_message_macros.h"
-#include "ui/gfx/geometry/rect_f.h"
-#include "ui/gfx/ipc/gfx_param_traits.h"
-#include "url/gurl.h"
-
-// The message starter should be declared in ipc/ipc_message_start.h. Since
-// we don't want to patch Chromium, we just pretend to be Content Shell.
-
-#define IPC_MESSAGE_START ShellMsgStart
-
-IPC_STRUCT_TRAITS_BEGIN(atom::DraggableRegion)
-  IPC_STRUCT_TRAITS_MEMBER(draggable)
-  IPC_STRUCT_TRAITS_MEMBER(bounds)
-IPC_STRUCT_TRAITS_END()
-
-IPC_MESSAGE_ROUTED2(AtomFrameHostMsg_Message,
-                    base::string16 /* channel */,
-                    base::ListValue /* arguments */)
-
-IPC_SYNC_MESSAGE_ROUTED2_1(AtomFrameHostMsg_Message_Sync,
-                           base::string16 /* channel */,
-                           base::ListValue /* arguments */,
-                           base::ListValue /* result */)
-
-IPC_MESSAGE_ROUTED3(AtomFrameMsg_Message,
-                    bool /* send_to_all */,
-                    base::string16 /* channel */,
-                    base::ListValue /* arguments */)
-
-IPC_MESSAGE_ROUTED0(AtomViewMsg_Offscreen)
-
-IPC_MESSAGE_ROUTED3(AtomAutofillFrameHostMsg_ShowPopup,
-                    gfx::RectF /* bounds */,
-                    std::vector<base::string16> /* values */,
-                    std::vector<base::string16> /* labels */)
-
-IPC_MESSAGE_ROUTED0(AtomAutofillFrameHostMsg_HidePopup)
-
-IPC_MESSAGE_ROUTED1(AtomAutofillFrameMsg_AcceptSuggestion,
-                    base::string16 /* suggestion */)
-
-// Sent by the renderer when the draggable regions are updated.
-IPC_MESSAGE_ROUTED1(AtomFrameHostMsg_UpdateDraggableRegions,
-                    std::vector<atom::DraggableRegion> /* regions */)
-
-// Update renderer process preferences.
-IPC_MESSAGE_CONTROL1(AtomMsg_UpdatePreferences, base::ListValue)
-
-// Sent by renderer to set the temporary zoom level.
-IPC_SYNC_MESSAGE_ROUTED1_1(AtomFrameHostMsg_SetTemporaryZoomLevel,
-                           double /* zoom level */,
-                           double /* result */)
-
-// Sent by renderer to get the zoom level.
-IPC_SYNC_MESSAGE_ROUTED0_1(AtomFrameHostMsg_GetZoomLevel, double /* result */)
-
-// Brings up SaveAs... dialog to save specified URL.
-IPC_MESSAGE_ROUTED2(AtomFrameHostMsg_PDFSaveURLAs,
-                    GURL /* url */,
-                    content::Referrer /* referrer */)
removed in remote
  base   100644 4bfb0ed4c1beed178c3a9cc5270a480deb511f52 atom/common/api/atom_api_asar.cc
  our    100644 240b5504c248b8199a4abb5b213a14ab5c072971 atom/common/api/atom_api_asar.cc
@@ -1,155 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <stddef.h>
-
-#include <vector>
-
-#include "atom/common/asar/archive.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "native_mate/arguments.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "native_mate/wrappable.h"
-
-#include "atom/common/node_includes.h"
-#include "atom_natives.h"  // NOLINT: This file is generated with js2c.
-
-namespace {
-
-class Archive : public mate::Wrappable<Archive> {
- public:
-  static v8::Local<v8::Value> Create(v8::Isolate* isolate,
-                                     const base::FilePath& path) {
-    auto archive = std::make_unique<asar::Archive>(path);
-    if (!archive->Init())
-      return v8::False(isolate);
-    return (new Archive(isolate, std::move(archive)))->GetWrapper();
-  }
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype) {
-    prototype->SetClassName(mate::StringToV8(isolate, "Archive"));
-    mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-        .SetProperty("path", &Archive::GetPath)
-        .SetMethod("getFileInfo", &Archive::GetFileInfo)
-        .SetMethod("stat", &Archive::Stat)
-        .SetMethod("readdir", &Archive::Readdir)
-        .SetMethod("realpath", &Archive::Realpath)
-        .SetMethod("copyFileOut", &Archive::CopyFileOut)
-        .SetMethod("getFd", &Archive::GetFD)
-        .SetMethod("destroy", &Archive::Destroy);
-  }
-
- protected:
-  Archive(v8::Isolate* isolate, std::unique_ptr<asar::Archive> archive)
-      : archive_(std::move(archive)) {
-    Init(isolate);
-  }
-
-  // Returns the path of the file.
-  base::FilePath GetPath() { return archive_->path(); }
-
-  // Reads the offset and size of file.
-  v8::Local<v8::Value> GetFileInfo(v8::Isolate* isolate,
-                                   const base::FilePath& path) {
-    asar::Archive::FileInfo info;
-    if (!archive_ || !archive_->GetFileInfo(path, &info))
-      return v8::False(isolate);
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("size", info.size);
-    dict.Set("unpacked", info.unpacked);
-    dict.Set("offset", info.offset);
-    return dict.GetHandle();
-  }
-
-  // Returns a fake result of fs.stat(path).
-  v8::Local<v8::Value> Stat(v8::Isolate* isolate, const base::FilePath& path) {
-    asar::Archive::Stats stats;
-    if (!archive_ || !archive_->Stat(path, &stats))
-      return v8::False(isolate);
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("size", stats.size);
-    dict.Set("offset", stats.offset);
-    dict.Set("isFile", stats.is_file);
-    dict.Set("isDirectory", stats.is_directory);
-    dict.Set("isLink", stats.is_link);
-    return dict.GetHandle();
-  }
-
-  // Returns all files under a directory.
-  v8::Local<v8::Value> Readdir(v8::Isolate* isolate,
-                               const base::FilePath& path) {
-    std::vector<base::FilePath> files;
-    if (!archive_ || !archive_->Readdir(path, &files))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, files);
-  }
-
-  // Returns the path of file with symbol link resolved.
-  v8::Local<v8::Value> Realpath(v8::Isolate* isolate,
-                                const base::FilePath& path) {
-    base::FilePath realpath;
-    if (!archive_ || !archive_->Realpath(path, &realpath))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, realpath);
-  }
-
-  // Copy the file out into a temporary file and returns the new path.
-  v8::Local<v8::Value> CopyFileOut(v8::Isolate* isolate,
-                                   const base::FilePath& path) {
-    base::FilePath new_path;
-    if (!archive_ || !archive_->CopyFileOut(path, &new_path))
-      return v8::False(isolate);
-    return mate::ConvertToV8(isolate, new_path);
-  }
-
-  // Return the file descriptor.
-  int GetFD() const {
-    if (!archive_)
-      return -1;
-    return archive_->GetFD();
-  }
-
-  // Free the resources used by archive.
-  void Destroy() { archive_.reset(); }
-
- private:
-  std::unique_ptr<asar::Archive> archive_;
-
-  DISALLOW_COPY_AND_ASSIGN(Archive);
-};
-
-void InitAsarSupport(v8::Isolate* isolate,
-                     v8::Local<v8::Value> process,
-                     v8::Local<v8::Value> require) {
-  // Evaluate asar_init.js.
-  v8::Local<v8::Script> asar_init =
-      v8::Script::Compile(node::asar_init_value.ToStringChecked(isolate));
-  v8::Local<v8::Value> result = asar_init->Run();
-
-  // Initialize asar support.
-  if (result->IsFunction()) {
-    v8::Local<v8::Value> args[] = {
-        process,
-        require,
-        node::asar_value.ToStringChecked(isolate),
-    };
-    result.As<v8::Function>()->Call(result, 3, args);
-  }
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("createArchive", &Archive::Create);
-  dict.SetMethod("initAsarSupport", &InitAsarSupport);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_asar, Initialize)
removed in remote
  base   100644 1f75f2cd3fe77ba3dd4c43ae0ef20d3d9ef04ad5 atom/common/api/atom_api_clipboard.cc
  our    100644 7502b1cb3627582e15de5cad27189cd68a8d7596 atom/common/api/atom_api_clipboard.cc
@@ -1,226 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_clipboard.h"
-
-#include "atom/common/native_mate_converters/image_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/strings/utf_string_conversions.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "third_party/skia/include/core/SkPixmap.h"
-#include "ui/base/clipboard/scoped_clipboard_writer.h"
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-ui::ClipboardType Clipboard::GetClipboardType(mate::Arguments* args) {
-  std::string type;
-  if (args->GetNext(&type) && type == "selection")
-    return ui::CLIPBOARD_TYPE_SELECTION;
-  else
-    return ui::CLIPBOARD_TYPE_COPY_PASTE;
-}
-
-std::vector<base::string16> Clipboard::AvailableFormats(mate::Arguments* args) {
-  std::vector<base::string16> format_types;
-  bool ignore;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadAvailableTypes(GetClipboardType(args), &format_types, &ignore);
-  return format_types;
-}
-
-bool Clipboard::Has(const std::string& format_string, mate::Arguments* args) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
-  return clipboard->IsFormatAvailable(format, GetClipboardType(args));
-}
-
-std::string Clipboard::Read(const std::string& format_string) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
-
-  std::string data;
-  clipboard->ReadData(format, &data);
-  return data;
-}
-
-v8::Local<v8::Value> Clipboard::ReadBuffer(const std::string& format_string,
-                                           mate::Arguments* args) {
-  std::string data = Read(format_string);
-  return node::Buffer::Copy(args->isolate(), data.data(), data.length())
-      .ToLocalChecked();
-}
-
-void Clipboard::WriteBuffer(const std::string& format,
-                            const v8::Local<v8::Value> buffer,
-                            mate::Arguments* args) {
-  if (!node::Buffer::HasInstance(buffer)) {
-    args->ThrowError("buffer must be a node Buffer");
-    return;
-  }
-
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteData(node::Buffer::Data(buffer), node::Buffer::Length(buffer),
-                   ui::Clipboard::GetFormatType(format));
-}
-
-void Clipboard::Write(const mate::Dictionary& data, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  base::string16 text, html, bookmark;
-  gfx::Image image;
-
-  if (data.Get("text", &text)) {
-    writer.WriteText(text);
-
-    if (data.Get("bookmark", &bookmark))
-      writer.WriteBookmark(bookmark, base::UTF16ToUTF8(text));
-  }
-
-  if (data.Get("rtf", &text)) {
-    std::string rtf = base::UTF16ToUTF8(text);
-    writer.WriteRTF(rtf);
-  }
-
-  if (data.Get("html", &html))
-    writer.WriteHTML(html, std::string());
-
-  if (data.Get("image", &image))
-    writer.WriteImage(image.AsBitmap());
-}
-
-base::string16 Clipboard::ReadText(mate::Arguments* args) {
-  base::string16 data;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  auto type = GetClipboardType(args);
-  if (clipboard->IsFormatAvailable(ui::Clipboard::GetPlainTextWFormatType(),
-                                   type)) {
-    clipboard->ReadText(type, &data);
-  } else if (clipboard->IsFormatAvailable(
-                 ui::Clipboard::GetPlainTextFormatType(), type)) {
-    std::string result;
-    clipboard->ReadAsciiText(type, &result);
-    data = base::ASCIIToUTF16(result);
-  }
-  return data;
-}
-
-void Clipboard::WriteText(const base::string16& text, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteText(text);
-}
-
-base::string16 Clipboard::ReadRTF(mate::Arguments* args) {
-  std::string data;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadRTF(GetClipboardType(args), &data);
-  return base::UTF8ToUTF16(data);
-}
-
-void Clipboard::WriteRTF(const std::string& text, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteRTF(text);
-}
-
-base::string16 Clipboard::ReadHTML(mate::Arguments* args) {
-  base::string16 data;
-  base::string16 html;
-  std::string url;
-  uint32_t start;
-  uint32_t end;
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadHTML(GetClipboardType(args), &html, &url, &start, &end);
-  data = html.substr(start, end - start);
-  return data;
-}
-
-void Clipboard::WriteHTML(const base::string16& html, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteHTML(html, std::string());
-}
-
-v8::Local<v8::Value> Clipboard::ReadBookmark(mate::Arguments* args) {
-  base::string16 title;
-  std::string url;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(args->isolate());
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  clipboard->ReadBookmark(&title, &url);
-  dict.Set("title", title);
-  dict.Set("url", url);
-  return dict.GetHandle();
-}
-
-void Clipboard::WriteBookmark(const base::string16& title,
-                              const std::string& url,
-                              mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  writer.WriteBookmark(title, url);
-}
-
-gfx::Image Clipboard::ReadImage(mate::Arguments* args) {
-  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
-  SkBitmap bitmap = clipboard->ReadImage(GetClipboardType(args));
-  return gfx::Image::CreateFrom1xBitmap(bitmap);
-}
-
-void Clipboard::WriteImage(const gfx::Image& image, mate::Arguments* args) {
-  ui::ScopedClipboardWriter writer(GetClipboardType(args));
-  SkBitmap orig = image.AsBitmap();
-  SkBitmap bmp;
-
-  if (bmp.tryAllocPixels(orig.info()) &&
-      orig.readPixels(bmp.info(), bmp.getPixels(), bmp.rowBytes(), 0, 0)) {
-    writer.WriteImage(bmp);
-  }
-}
-
-#if !defined(OS_MACOSX)
-void Clipboard::WriteFindText(const base::string16& text) {}
-base::string16 Clipboard::ReadFindText() {
-  return base::string16();
-}
-#endif
-
-void Clipboard::Clear(mate::Arguments* args) {
-  ui::Clipboard::GetForCurrentThread()->Clear(GetClipboardType(args));
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("availableFormats", &atom::api::Clipboard::AvailableFormats);
-  dict.SetMethod("has", &atom::api::Clipboard::Has);
-  dict.SetMethod("read", &atom::api::Clipboard::Read);
-  dict.SetMethod("write", &atom::api::Clipboard::Write);
-  dict.SetMethod("readText", &atom::api::Clipboard::ReadText);
-  dict.SetMethod("writeText", &atom::api::Clipboard::WriteText);
-  dict.SetMethod("readRTF", &atom::api::Clipboard::ReadRTF);
-  dict.SetMethod("writeRTF", &atom::api::Clipboard::WriteRTF);
-  dict.SetMethod("readHTML", &atom::api::Clipboard::ReadHTML);
-  dict.SetMethod("writeHTML", &atom::api::Clipboard::WriteHTML);
-  dict.SetMethod("readBookmark", &atom::api::Clipboard::ReadBookmark);
-  dict.SetMethod("writeBookmark", &atom::api::Clipboard::WriteBookmark);
-  dict.SetMethod("readImage", &atom::api::Clipboard::ReadImage);
-  dict.SetMethod("writeImage", &atom::api::Clipboard::WriteImage);
-  dict.SetMethod("readFindText", &atom::api::Clipboard::ReadFindText);
-  dict.SetMethod("writeFindText", &atom::api::Clipboard::WriteFindText);
-  dict.SetMethod("readBuffer", &atom::api::Clipboard::ReadBuffer);
-  dict.SetMethod("writeBuffer", &atom::api::Clipboard::WriteBuffer);
-  dict.SetMethod("clear", &atom::api::Clipboard::Clear);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_clipboard, Initialize)
removed in remote
  base   100644 e1932ad7f5f03aea890c5aa7949d79cf630e58d2 atom/common/api/atom_api_crash_reporter.cc
  our    100644 4aa48085d4d390c7b33994dacdf292f257c31157 atom/common/api/atom_api_crash_reporter.cc
@@ -1,67 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <map>
-#include <string>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/bind.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-using crash_reporter::CrashReporter;
-
-namespace mate {
-
-template <>
-struct Converter<CrashReporter::UploadReportResult> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const CrashReporter::UploadReportResult& reports) {
-    mate::Dictionary dict(isolate, v8::Object::New(isolate));
-    dict.Set("date", v8::Date::New(isolate, reports.first * 1000.0));
-    dict.Set("id", reports.second);
-    return dict.GetHandle();
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-void AddExtraParameter(const std::string& key, const std::string& value) {
-  CrashReporter::GetInstance()->AddExtraParameter(key, value);
-}
-
-void RemoveExtraParameter(const std::string& key) {
-  CrashReporter::GetInstance()->RemoveExtraParameter(key);
-}
-
-std::map<std::string, std::string> GetParameters() {
-  return CrashReporter::GetInstance()->GetParameters();
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  auto reporter = base::Unretained(CrashReporter::GetInstance());
-  dict.SetMethod("start", base::Bind(&CrashReporter::Start, reporter));
-  dict.SetMethod("addExtraParameter", &AddExtraParameter);
-  dict.SetMethod("removeExtraParameter", &RemoveExtraParameter);
-  dict.SetMethod("getParameters", &GetParameters);
-  dict.SetMethod("getUploadedReports",
-                 base::Bind(&CrashReporter::GetUploadedReports, reporter));
-  dict.SetMethod("setUploadToServer",
-                 base::Bind(&CrashReporter::SetUploadToServer, reporter));
-  dict.SetMethod("getUploadToServer",
-                 base::Bind(&CrashReporter::GetUploadToServer, reporter));
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_crash_reporter, Initialize)
removed in remote
  base   100644 3dda326f59fda31ca29b5bccf7e0335babcc1b3e atom/common/api/atom_api_native_image.cc
  our    100644 09edfdaac9107386241505d2d5763b1b24aa73a4 atom/common/api/atom_api_native_image.cc
@@ -1,624 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_native_image.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/files/file_util.h"
-#include "base/strings/pattern.h"
-#include "base/strings/string_util.h"
-#include "base/threading/thread_restrictions.h"
-#include "native_mate/object_template_builder.h"
-#include "net/base/data_url.h"
-#include "third_party/skia/include/core/SkBitmap.h"
-#include "third_party/skia/include/core/SkImageInfo.h"
-#include "third_party/skia/include/core/SkPixelRef.h"
-#include "ui/base/layout.h"
-#include "ui/base/webui/web_ui_util.h"
-#include "ui/gfx/codec/jpeg_codec.h"
-#include "ui/gfx/codec/png_codec.h"
-#include "ui/gfx/geometry/size.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/image/image_skia_operations.h"
-#include "ui/gfx/image/image_util.h"
-
-#if defined(OS_WIN)
-#include "atom/common/asar/archive.h"
-#include "base/win/scoped_gdi_object.h"
-#include "ui/gfx/icon_util.h"
-#endif
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-struct ScaleFactorPair {
-  const char* name;
-  float scale;
-};
-
-ScaleFactorPair kScaleFactorPairs[] = {
-    // The "@2x" is put as first one to make scale matching faster.
-    {"@2x", 2.0f},   {"@3x", 3.0f},     {"@1x", 1.0f},     {"@4x", 4.0f},
-    {"@5x", 5.0f},   {"@1.25x", 1.25f}, {"@1.33x", 1.33f}, {"@1.4x", 1.4f},
-    {"@1.5x", 1.5f}, {"@1.8x", 1.8f},   {"@2.5x", 2.5f},
-};
-
-float GetScaleFactorFromPath(const base::FilePath& path) {
-  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
-
-  // We don't try to convert string to float here because it is very very
-  // expensive.
-  for (const auto& kScaleFactorPair : kScaleFactorPairs) {
-    if (base::EndsWith(filename, kScaleFactorPair.name,
-                       base::CompareCase::INSENSITIVE_ASCII))
-      return kScaleFactorPair.scale;
-  }
-
-  return 1.0f;
-}
-
-// Get the scale factor from options object at the first argument
-float GetScaleFactorFromOptions(mate::Arguments* args) {
-  float scale_factor = 1.0f;
-  mate::Dictionary options;
-  if (args->GetNext(&options))
-    options.Get("scaleFactor", &scale_factor);
-  return scale_factor;
-}
-
-bool AddImageSkiaRep(gfx::ImageSkia* image,
-                     const unsigned char* data,
-                     size_t size,
-                     int width,
-                     int height,
-                     double scale_factor) {
-  auto decoded = std::make_unique<SkBitmap>();
-
-  // Try PNG first.
-  if (!gfx::PNGCodec::Decode(data, size, decoded.get())) {
-    // Try JPEG.
-    decoded = gfx::JPEGCodec::Decode(data, size);
-    if (decoded) {
-      // `JPEGCodec::Decode()` doesn't tell `SkBitmap` instance it creates
-      // that all of its pixels are opaque, that's why the bitmap gets
-      // an alpha type `kPremul_SkAlphaType` instead of `kOpaque_SkAlphaType`.
-      // Let's fix it here.
-      // TODO(alexeykuzmin): This workaround should be removed
-      // when the `JPEGCodec::Decode()` code is fixed.
-      // See https://github.com/electron/electron/issues/11294.
-      decoded->setAlphaType(SkAlphaType::kOpaque_SkAlphaType);
-    }
-  }
-
-  if (!decoded) {
-    // Try Bitmap
-    if (width > 0 && height > 0) {
-      decoded.reset(new SkBitmap);
-      decoded->allocN32Pixels(width, height, false);
-      decoded->setPixels(
-          const_cast<void*>(reinterpret_cast<const void*>(data)));
-    } else {
-      return false;
-    }
-  }
-
-  image->AddRepresentation(gfx::ImageSkiaRep(*decoded, scale_factor));
-  return true;
-}
-
-bool AddImageSkiaRep(gfx::ImageSkia* image,
-                     const base::FilePath& path,
-                     double scale_factor) {
-  std::string file_contents;
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (!asar::ReadFileToString(path, &file_contents))
-      return false;
-  }
-
-  const unsigned char* data =
-      reinterpret_cast<const unsigned char*>(file_contents.data());
-  size_t size = file_contents.size();
-  return AddImageSkiaRep(image, data, size, 0, 0, scale_factor);
-}
-
-bool PopulateImageSkiaRepsFromPath(gfx::ImageSkia* image,
-                                   const base::FilePath& path) {
-  bool succeed = false;
-  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
-  if (base::MatchPattern(filename, "*@*x"))
-    // Don't search for other representations if the DPI has been specified.
-    return AddImageSkiaRep(image, path, GetScaleFactorFromPath(path));
-  else
-    succeed |= AddImageSkiaRep(image, path, 1.0f);
-
-  for (const ScaleFactorPair& pair : kScaleFactorPairs)
-    succeed |= AddImageSkiaRep(
-        image, path.InsertBeforeExtensionASCII(pair.name), pair.scale);
-  return succeed;
-}
-
-base::FilePath NormalizePath(const base::FilePath& path) {
-  if (!path.ReferencesParent()) {
-    return path;
-  }
-
-  base::FilePath absolute_path = MakeAbsoluteFilePath(path);
-  // MakeAbsoluteFilePath returns an empty path on failures so use original path
-  if (absolute_path.empty()) {
-    return path;
-  } else {
-    return absolute_path;
-  }
-}
-
-#if defined(OS_MACOSX)
-bool IsTemplateFilename(const base::FilePath& path) {
-  return (base::MatchPattern(path.value(), "*Template.*") ||
-          base::MatchPattern(path.value(), "*Template@*x.*"));
-}
-#endif
-
-#if defined(OS_WIN)
-base::win::ScopedHICON ReadICOFromPath(int size, const base::FilePath& path) {
-  // If file is in asar archive, we extract it to a temp file so LoadImage can
-  // load it.
-  base::FilePath asar_path, relative_path;
-  base::FilePath image_path(path);
-  if (asar::GetAsarArchivePath(image_path, &asar_path, &relative_path)) {
-    std::shared_ptr<asar::Archive> archive =
-        asar::GetOrCreateAsarArchive(asar_path);
-    if (archive)
-      archive->CopyFileOut(relative_path, &image_path);
-  }
-
-  // Load the icon from file.
-  return base::win::ScopedHICON(
-      static_cast<HICON>(LoadImage(NULL, image_path.value().c_str(), IMAGE_ICON,
-                                   size, size, LR_LOADFROMFILE)));
-}
-
-bool ReadImageSkiaFromICO(gfx::ImageSkia* image, HICON icon) {
-  // Convert the icon from the Windows specific HICON to gfx::ImageSkia.
-  std::unique_ptr<SkBitmap> bitmap(IconUtil::CreateSkBitmapFromHICON(icon));
-  if (!bitmap)
-    return false;
-
-  image->AddRepresentation(gfx::ImageSkiaRep(*bitmap, 1.0f));
-  return true;
-}
-#endif
-
-void Noop(char*, void*) {}
-
-}  // namespace
-
-NativeImage::NativeImage(v8::Isolate* isolate, const gfx::Image& image)
-    : image_(image) {
-  Init(isolate);
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate->AdjustAmountOfExternalAllocatedMemory(
-        image_.ToImageSkia()->bitmap()->computeByteSize());
-  }
-}
-
-#if defined(OS_WIN)
-NativeImage::NativeImage(v8::Isolate* isolate, const base::FilePath& hicon_path)
-    : hicon_path_(hicon_path) {
-  // Use the 256x256 icon as fallback icon.
-  gfx::ImageSkia image_skia;
-  ReadImageSkiaFromICO(&image_skia, GetHICON(256));
-  image_ = gfx::Image(image_skia);
-  Init(isolate);
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate->AdjustAmountOfExternalAllocatedMemory(
-        image_.ToImageSkia()->bitmap()->computeByteSize());
-  }
-}
-#endif
-
-NativeImage::~NativeImage() {
-  if (image_.HasRepresentation(gfx::Image::kImageRepSkia)) {
-    isolate()->AdjustAmountOfExternalAllocatedMemory(-static_cast<int64_t>(
-        image_.ToImageSkia()->bitmap()->computeByteSize()));
-  }
-}
-
-#if defined(OS_WIN)
-HICON NativeImage::GetHICON(int size) {
-  auto iter = hicons_.find(size);
-  if (iter != hicons_.end())
-    return iter->second.get();
-
-  // First try loading the icon with specified size.
-  if (!hicon_path_.empty()) {
-    hicons_[size] = ReadICOFromPath(size, hicon_path_);
-    return hicons_[size].get();
-  }
-
-  // Then convert the image to ICO.
-  if (image_.IsEmpty())
-    return NULL;
-  hicons_[size] = IconUtil::CreateHICONFromSkBitmap(image_.AsBitmap());
-  return hicons_[size].get();
-}
-#endif
-
-v8::Local<v8::Value> NativeImage::ToPNG(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  if (scale_factor == 1.0f) {
-    // Use raw 1x PNG bytes when available
-    scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
-    if (png->size() > 0) {
-      const char* data = reinterpret_cast<const char*>(png->front());
-      size_t size = png->size();
-      return node::Buffer::Copy(args->isolate(), data, size).ToLocalChecked();
-    }
-  }
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  std::vector<unsigned char> encoded;
-  gfx::PNGCodec::EncodeBGRASkBitmap(bitmap, false, &encoded);
-  const char* data = reinterpret_cast<char*>(encoded.data());
-  size_t size = encoded.size();
-  return node::Buffer::Copy(args->isolate(), data, size).ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::ToBitmap(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  SkPixelRef* ref = bitmap.pixelRef();
-  if (!ref)
-    return node::Buffer::New(args->isolate(), 0).ToLocalChecked();
-  return node::Buffer::Copy(args->isolate(),
-                            reinterpret_cast<const char*>(ref->pixels()),
-                            bitmap.computeByteSize())
-      .ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::ToJPEG(v8::Isolate* isolate, int quality) {
-  std::vector<unsigned char> output;
-  gfx::JPEG1xEncodedDataFromImage(image_, quality, &output);
-  if (output.empty())
-    return node::Buffer::New(isolate, 0).ToLocalChecked();
-  return node::Buffer::Copy(isolate,
-                            reinterpret_cast<const char*>(&output.front()),
-                            output.size())
-      .ToLocalChecked();
-}
-
-std::string NativeImage::ToDataURL(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  if (scale_factor == 1.0f) {
-    // Use raw 1x PNG bytes when available
-    scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
-    if (png->size() > 0)
-      return webui::GetPngDataUrl(png->front(), png->size());
-  }
-
-  return webui::GetBitmapDataUrl(
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap());
-}
-
-v8::Local<v8::Value> NativeImage::GetBitmap(mate::Arguments* args) {
-  float scale_factor = GetScaleFactorFromOptions(args);
-
-  const SkBitmap bitmap =
-      image_.AsImageSkia().GetRepresentation(scale_factor).sk_bitmap();
-  SkPixelRef* ref = bitmap.pixelRef();
-  if (!ref)
-    return node::Buffer::New(args->isolate(), 0).ToLocalChecked();
-  return node::Buffer::New(args->isolate(),
-                           reinterpret_cast<char*>(ref->pixels()),
-                           bitmap.computeByteSize(), &Noop, nullptr)
-      .ToLocalChecked();
-}
-
-v8::Local<v8::Value> NativeImage::GetNativeHandle(v8::Isolate* isolate,
-                                                  mate::Arguments* args) {
-#if defined(OS_MACOSX)
-  if (IsEmpty())
-    return node::Buffer::New(isolate, 0).ToLocalChecked();
-
-  NSImage* ptr = image_.AsNSImage();
-  return node::Buffer::Copy(isolate, reinterpret_cast<char*>(ptr),
-                            sizeof(void*))
-      .ToLocalChecked();
-#else
-  args->ThrowError("Not implemented");
-  return v8::Undefined(isolate);
-#endif
-}
-
-bool NativeImage::IsEmpty() {
-  return image_.IsEmpty();
-}
-
-gfx::Size NativeImage::GetSize() {
-  return image_.Size();
-}
-
-float NativeImage::GetAspectRatio() {
-  gfx::Size size = GetSize();
-  if (size.IsEmpty())
-    return 1.f;
-  else
-    return static_cast<float>(size.width()) / static_cast<float>(size.height());
-}
-
-mate::Handle<NativeImage> NativeImage::Resize(
-    v8::Isolate* isolate,
-    const base::DictionaryValue& options) {
-  gfx::Size size = GetSize();
-  int width = size.width();
-  int height = size.height();
-  bool width_set = options.GetInteger("width", &width);
-  bool height_set = options.GetInteger("height", &height);
-  size.SetSize(width, height);
-
-  if (width_set && !height_set) {
-    // Scale height to preserve original aspect ratio
-    size.set_height(width);
-    size = gfx::ScaleToRoundedSize(size, 1.f, 1.f / GetAspectRatio());
-  } else if (height_set && !width_set) {
-    // Scale width to preserve original aspect ratio
-    size.set_width(height);
-    size = gfx::ScaleToRoundedSize(size, GetAspectRatio(), 1.f);
-  }
-
-  skia::ImageOperations::ResizeMethod method =
-      skia::ImageOperations::ResizeMethod::RESIZE_BEST;
-  std::string quality;
-  options.GetString("quality", &quality);
-  if (quality == "good")
-    method = skia::ImageOperations::ResizeMethod::RESIZE_GOOD;
-  else if (quality == "better")
-    method = skia::ImageOperations::ResizeMethod::RESIZE_BETTER;
-
-  gfx::ImageSkia resized = gfx::ImageSkiaOperations::CreateResizedImage(
-      image_.AsImageSkia(), method, size);
-  return mate::CreateHandle(isolate,
-                            new NativeImage(isolate, gfx::Image(resized)));
-}
-
-mate::Handle<NativeImage> NativeImage::Crop(v8::Isolate* isolate,
-                                            const gfx::Rect& rect) {
-  gfx::ImageSkia cropped =
-      gfx::ImageSkiaOperations::ExtractSubset(image_.AsImageSkia(), rect);
-  return mate::CreateHandle(isolate,
-                            new NativeImage(isolate, gfx::Image(cropped)));
-}
-
-void NativeImage::AddRepresentation(const mate::Dictionary& options) {
-  int width = 0;
-  int height = 0;
-  float scale_factor = 1.0f;
-  options.Get("width", &width);
-  options.Get("height", &height);
-  options.Get("scaleFactor", &scale_factor);
-
-  bool skia_rep_added = false;
-  gfx::ImageSkia image_skia = image_.AsImageSkia();
-
-  v8::Local<v8::Value> buffer;
-  GURL url;
-  if (options.Get("buffer", &buffer) && node::Buffer::HasInstance(buffer)) {
-    AddImageSkiaRep(
-        &image_skia,
-        reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
-        node::Buffer::Length(buffer), width, height, scale_factor);
-    skia_rep_added = true;
-  } else if (options.Get("dataURL", &url)) {
-    std::string mime_type, charset, data;
-    if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
-      if (mime_type == "image/png" || mime_type == "image/jpeg") {
-        AddImageSkiaRep(&image_skia,
-                        reinterpret_cast<const unsigned char*>(data.c_str()),
-                        data.size(), width, height, scale_factor);
-        skia_rep_added = true;
-      }
-    }
-  }
-
-  // Re-initialize image when first representation is added to an empty image
-  if (skia_rep_added && IsEmpty()) {
-    gfx::Image image(image_skia);
-    image_ = std::move(image);
-  }
-}
-
-#if !defined(OS_MACOSX)
-void NativeImage::SetTemplateImage(bool setAsTemplate) {}
-
-bool NativeImage::IsTemplateImage() {
-  return false;
-}
-#endif
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateEmpty(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new NativeImage(isolate, gfx::Image()));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::Create(v8::Isolate* isolate,
-                                              const gfx::Image& image) {
-  return mate::CreateHandle(isolate, new NativeImage(isolate, image));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromPNG(v8::Isolate* isolate,
-                                                     const char* buffer,
-                                                     size_t length) {
-  gfx::Image image = gfx::Image::CreateFrom1xPNGBytes(
-      reinterpret_cast<const unsigned char*>(buffer), length);
-  return Create(isolate, image);
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromJPEG(v8::Isolate* isolate,
-                                                      const char* buffer,
-                                                      size_t length) {
-  gfx::Image image = gfx::ImageFrom1xJPEGEncodedData(
-      reinterpret_cast<const unsigned char*>(buffer), length);
-  return Create(isolate, image);
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromPath(
-    v8::Isolate* isolate,
-    const base::FilePath& path) {
-  base::FilePath image_path = NormalizePath(path);
-#if defined(OS_WIN)
-  if (image_path.MatchesExtension(FILE_PATH_LITERAL(".ico"))) {
-    return mate::CreateHandle(isolate, new NativeImage(isolate, image_path));
-  }
-#endif
-  gfx::ImageSkia image_skia;
-  PopulateImageSkiaRepsFromPath(&image_skia, image_path);
-  gfx::Image image(image_skia);
-  mate::Handle<NativeImage> handle = Create(isolate, image);
-#if defined(OS_MACOSX)
-  if (IsTemplateFilename(image_path))
-    handle->SetTemplateImage(true);
-#endif
-  return handle;
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromBuffer(
-    mate::Arguments* args,
-    v8::Local<v8::Value> buffer) {
-  int width = 0;
-  int height = 0;
-  double scale_factor = 1.;
-
-  mate::Dictionary options;
-  if (args->GetNext(&options)) {
-    options.Get("width", &width);
-    options.Get("height", &height);
-    options.Get("scaleFactor", &scale_factor);
-  }
-
-  gfx::ImageSkia image_skia;
-  AddImageSkiaRep(&image_skia,
-                  reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
-                  node::Buffer::Length(buffer), width, height, scale_factor);
-  return Create(args->isolate(), gfx::Image(image_skia));
-}
-
-// static
-mate::Handle<NativeImage> NativeImage::CreateFromDataURL(v8::Isolate* isolate,
-                                                         const GURL& url) {
-  std::string mime_type, charset, data;
-  if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
-    if (mime_type == "image/png")
-      return CreateFromPNG(isolate, data.c_str(), data.size());
-    else if (mime_type == "image/jpeg")
-      return CreateFromJPEG(isolate, data.c_str(), data.size());
-  }
-
-  return CreateEmpty(isolate);
-}
-
-#if !defined(OS_MACOSX)
-mate::Handle<NativeImage> NativeImage::CreateFromNamedImage(
-    mate::Arguments* args,
-    const std::string& name) {
-  return CreateEmpty(args->isolate());
-}
-#endif
-
-// static
-void NativeImage::BuildPrototype(v8::Isolate* isolate,
-                                 v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "NativeImage"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("toPNG", &NativeImage::ToPNG)
-      .SetMethod("toJPEG", &NativeImage::ToJPEG)
-      .SetMethod("toBitmap", &NativeImage::ToBitmap)
-      .SetMethod("getBitmap", &NativeImage::GetBitmap)
-      .SetMethod("getNativeHandle", &NativeImage::GetNativeHandle)
-      .SetMethod("toDataURL", &NativeImage::ToDataURL)
-      .SetMethod("isEmpty", &NativeImage::IsEmpty)
-      .SetMethod("getSize", &NativeImage::GetSize)
-      .SetMethod("setTemplateImage", &NativeImage::SetTemplateImage)
-      .SetMethod("isTemplateImage", &NativeImage::IsTemplateImage)
-      .SetMethod("resize", &NativeImage::Resize)
-      .SetMethod("crop", &NativeImage::Crop)
-      .SetMethod("getAspectRatio", &NativeImage::GetAspectRatio)
-      .SetMethod("addRepresentation", &NativeImage::AddRepresentation);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-v8::Local<v8::Value> Converter<mate::Handle<atom::api::NativeImage>>::ToV8(
-    v8::Isolate* isolate,
-    const mate::Handle<atom::api::NativeImage>& val) {
-  return val.ToV8();
-}
-
-bool Converter<mate::Handle<atom::api::NativeImage>>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    mate::Handle<atom::api::NativeImage>* out) {
-  // Try converting from file path.
-  base::FilePath path;
-  if (ConvertFromV8(isolate, val, &path)) {
-    *out = atom::api::NativeImage::CreateFromPath(isolate, path);
-    // Should throw when failed to initialize from path.
-    return !(*out)->image().IsEmpty();
-  }
-
-  WrappableBase* wrapper =
-      static_cast<WrappableBase*>(internal::FromV8Impl(isolate, val));
-  if (!wrapper)
-    return false;
-
-  *out = CreateHandle(isolate, static_cast<atom::api::NativeImage*>(wrapper));
-  return true;
-}
-
-}  // namespace mate
-
-namespace {
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("createEmpty", &atom::api::NativeImage::CreateEmpty);
-  dict.SetMethod("createFromPath", &atom::api::NativeImage::CreateFromPath);
-  dict.SetMethod("createFromBuffer", &atom::api::NativeImage::CreateFromBuffer);
-  dict.SetMethod("createFromDataURL",
-                 &atom::api::NativeImage::CreateFromDataURL);
-  dict.SetMethod("createFromNamedImage",
-                 &atom::api::NativeImage::CreateFromNamedImage);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_native_image, Initialize)
removed in remote
  base   100644 145f5ff1dcdceed2e63e5ff0171cac00283f4a9e atom/common/api/atom_api_native_image.h
  our    100644 f945e3d4df39a83d667c5c3eb290293ed2788f4a atom/common/api/atom_api_native_image.h
@@ -1,129 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
-#define ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
-
-#include <map>
-#include <string>
-
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/image/image.h"
-
-#if defined(OS_WIN)
-#include "base/files/file_path.h"
-#include "base/win/scoped_gdi_object.h"
-#endif
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace gfx {
-class Size;
-}
-
-namespace mate {
-class Arguments;
-}
-
-namespace atom {
-
-namespace api {
-
-class NativeImage : public mate::Wrappable<NativeImage> {
- public:
-  static mate::Handle<NativeImage> CreateEmpty(v8::Isolate* isolate);
-  static mate::Handle<NativeImage> Create(v8::Isolate* isolate,
-                                          const gfx::Image& image);
-  static mate::Handle<NativeImage> CreateFromPNG(v8::Isolate* isolate,
-                                                 const char* buffer,
-                                                 size_t length);
-  static mate::Handle<NativeImage> CreateFromJPEG(v8::Isolate* isolate,
-                                                  const char* buffer,
-                                                  size_t length);
-  static mate::Handle<NativeImage> CreateFromPath(v8::Isolate* isolate,
-                                                  const base::FilePath& path);
-  static mate::Handle<NativeImage> CreateFromBuffer(
-      mate::Arguments* args,
-      v8::Local<v8::Value> buffer);
-  static mate::Handle<NativeImage> CreateFromDataURL(v8::Isolate* isolate,
-                                                     const GURL& url);
-  static mate::Handle<NativeImage> CreateFromNamedImage(
-      mate::Arguments* args,
-      const std::string& name);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
-#if defined(OS_WIN)
-  HICON GetHICON(int size);
-#endif
-
-  const gfx::Image& image() const { return image_; }
-
- protected:
-  NativeImage(v8::Isolate* isolate, const gfx::Image& image);
-#if defined(OS_WIN)
-  NativeImage(v8::Isolate* isolate, const base::FilePath& hicon_path);
-#endif
-  ~NativeImage() override;
-
- private:
-  v8::Local<v8::Value> ToPNG(mate::Arguments* args);
-  v8::Local<v8::Value> ToJPEG(v8::Isolate* isolate, int quality);
-  v8::Local<v8::Value> ToBitmap(mate::Arguments* args);
-  v8::Local<v8::Value> GetBitmap(mate::Arguments* args);
-  v8::Local<v8::Value> GetNativeHandle(v8::Isolate* isolate,
-                                       mate::Arguments* args);
-  mate::Handle<NativeImage> Resize(v8::Isolate* isolate,
-                                   const base::DictionaryValue& options);
-  mate::Handle<NativeImage> Crop(v8::Isolate* isolate, const gfx::Rect& rect);
-  std::string ToDataURL(mate::Arguments* args);
-  bool IsEmpty();
-  gfx::Size GetSize();
-  float GetAspectRatio();
-  void AddRepresentation(const mate::Dictionary& options);
-
-  // Mark the image as template image.
-  void SetTemplateImage(bool setAsTemplate);
-  // Determine if the image is a template image.
-  bool IsTemplateImage();
-
-#if defined(OS_WIN)
-  base::FilePath hicon_path_;
-  std::map<int, base::win::ScopedHICON> hicons_;
-#endif
-
-  gfx::Image image_;
-
-  DISALLOW_COPY_AND_ASSIGN(NativeImage);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace mate {
-
-// A custom converter that allows converting path to NativeImage.
-template <>
-struct Converter<mate::Handle<atom::api::NativeImage>> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const mate::Handle<atom::api::NativeImage>& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     mate::Handle<atom::api::NativeImage>* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_ATOM_API_NATIVE_IMAGE_H_
removed in remote
  base   100644 ad72d4b149246ef77a06369359b33fe26c1db3ff atom/common/api/atom_api_native_image_mac.mm
  our    100644 df1cec129f310bbd51448444a256a7be6d3b1a5c atom/common/api/atom_api_native_image_mac.mm
@@ -1,73 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_api_native_image.h"
-
-#import <Cocoa/Cocoa.h>
-
-#include "base/strings/sys_string_conversions.h"
-#include "ui/gfx/color_utils.h"
-#include "ui/gfx/image/image.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/image/image_skia_operations.h"
-
-namespace atom {
-
-namespace api {
-
-NSData* bufferFromNSImage(NSImage* image) {
-  CGImageRef ref = [image CGImageForProposedRect:nil context:nil hints:nil];
-  NSBitmapImageRep* rep = [[NSBitmapImageRep alloc] initWithCGImage:ref];
-  [rep setSize:[image size]];
-  return [rep representationUsingType:NSPNGFileType
-                           properties:[[NSDictionary alloc] init]];
-}
-
-double safeShift(double in, double def) {
-  if (in >= 0 || in <= 1 || in == def)
-    return in;
-  return def;
-}
-
-mate::Handle<NativeImage> NativeImage::CreateFromNamedImage(
-    mate::Arguments* args,
-    const std::string& name) {
-  @autoreleasepool {
-    std::vector<double> hsl_shift;
-    NSImage* image = [NSImage imageNamed:base::SysUTF8ToNSString(name)];
-    if (!image.valid) {
-      return CreateEmpty(args->isolate());
-    }
-
-    NSData* png_data = bufferFromNSImage(image);
-
-    if (args->GetNext(&hsl_shift) && hsl_shift.size() == 3) {
-      gfx::Image gfx_image = gfx::Image::CreateFrom1xPNGBytes(
-          reinterpret_cast<const unsigned char*>((char*)[png_data bytes]),
-          [png_data length]);
-      color_utils::HSL shift = {safeShift(hsl_shift[0], -1),
-                                safeShift(hsl_shift[1], 0.5),
-                                safeShift(hsl_shift[2], 0.5)};
-      png_data = bufferFromNSImage(
-          gfx::Image(gfx::ImageSkiaOperations::CreateHSLShiftedImage(
-                         gfx_image.AsImageSkia(), shift))
-              .CopyNSImage());
-    }
-
-    return CreateFromPNG(args->isolate(), (char*)[png_data bytes],
-                         [png_data length]);
-  }
-}
-
-void NativeImage::SetTemplateImage(bool setAsTemplate) {
-  [image_.AsNSImage() setTemplate:setAsTemplate];
-}
-
-bool NativeImage::IsTemplateImage() {
-  return [image_.AsNSImage() isTemplate];
-}
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 f99e2ba1854e0bdeb35d9adb327f04c8a84d7392 atom/common/api/atom_api_shell.cc
  our    100644 1323cd6402d295ccc804da6c3d42c5d7472a564e atom/common/api/atom_api_shell.cc
@@ -1,157 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "atom/common/platform_util.h"
-#include "native_mate/dictionary.h"
-
-#if defined(OS_WIN)
-#include "base/win/scoped_com_initializer.h"
-#include "base/win/shortcut.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::win::ShortcutOperation> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     base::win::ShortcutOperation* out) {
-    std::string operation;
-    if (!ConvertFromV8(isolate, val, &operation))
-      return false;
-    if (operation.empty() || operation == "create")
-      *out = base::win::SHORTCUT_CREATE_ALWAYS;
-    else if (operation == "update")
-      *out = base::win::SHORTCUT_UPDATE_EXISTING;
-    else if (operation == "replace")
-      *out = base::win::SHORTCUT_REPLACE_EXISTING;
-    else
-      return false;
-    return true;
-  }
-};
-
-}  // namespace mate
-#endif
-
-namespace {
-
-void OnOpenExternalFinished(
-    v8::Isolate* isolate,
-    const base::Callback<void(v8::Local<v8::Value>)>& callback,
-    const std::string& error) {
-  if (error.empty())
-    callback.Run(v8::Null(isolate));
-  else
-    callback.Run(v8::String::NewFromUtf8(isolate, error.c_str()));
-}
-
-bool OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    mate::Arguments* args) {
-  bool activate = true;
-  if (args->Length() >= 2) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("activate", &activate);
-    }
-  }
-
-  if (args->Length() >= 3) {
-    base::Callback<void(v8::Local<v8::Value>)> callback;
-    if (args->GetNext(&callback)) {
-      platform_util::OpenExternal(
-          url, activate,
-          base::Bind(&OnOpenExternalFinished, args->isolate(), callback));
-      return true;
-    }
-  }
-
-  return platform_util::OpenExternal(url, activate);
-}
-
-#if defined(OS_WIN)
-bool WriteShortcutLink(const base::FilePath& shortcut_path,
-                       mate::Arguments* args) {
-  base::win::ShortcutOperation operation = base::win::SHORTCUT_CREATE_ALWAYS;
-  args->GetNext(&operation);
-  mate::Dictionary options = mate::Dictionary::CreateEmpty(args->isolate());
-  if (!args->GetNext(&options)) {
-    args->ThrowError();
-    return false;
-  }
-
-  base::win::ShortcutProperties properties;
-  base::FilePath path;
-  base::string16 str;
-  int index;
-  if (options.Get("target", &path))
-    properties.set_target(path);
-  if (options.Get("cwd", &path))
-    properties.set_working_dir(path);
-  if (options.Get("args", &str))
-    properties.set_arguments(str);
-  if (options.Get("description", &str))
-    properties.set_description(str);
-  if (options.Get("icon", &path) && options.Get("iconIndex", &index))
-    properties.set_icon(path, index);
-  if (options.Get("appUserModelId", &str))
-    properties.set_app_id(str);
-
-  base::win::ScopedCOMInitializer com_initializer;
-  return base::win::CreateOrUpdateShortcutLink(shortcut_path, properties,
-                                               operation);
-}
-
-v8::Local<v8::Value> ReadShortcutLink(mate::Arguments* args,
-                                      const base::FilePath& path) {
-  using base::win::ShortcutProperties;
-  mate::Dictionary options = mate::Dictionary::CreateEmpty(args->isolate());
-  base::win::ScopedCOMInitializer com_initializer;
-  base::win::ShortcutProperties properties;
-  if (!base::win::ResolveShortcutProperties(
-          path, ShortcutProperties::PROPERTIES_ALL, &properties)) {
-    args->ThrowError("Failed to read shortcut link");
-    return v8::Null(args->isolate());
-  }
-  options.Set("target", properties.target);
-  options.Set("cwd", properties.working_dir);
-  options.Set("args", properties.arguments);
-  options.Set("description", properties.description);
-  options.Set("icon", properties.icon);
-  options.Set("iconIndex", properties.icon_index);
-  options.Set("appUserModelId", properties.app_id);
-  return options.GetHandle();
-}
-#endif
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("showItemInFolder", &platform_util::ShowItemInFolder);
-  dict.SetMethod("openItem", &platform_util::OpenItem);
-  dict.SetMethod("openExternal", &OpenExternal);
-  dict.SetMethod("moveItemToTrash", &platform_util::MoveItemToTrash);
-  dict.SetMethod("beep", &platform_util::Beep);
-#if defined(OS_WIN)
-  dict.SetMethod("writeShortcutLink", &WriteShortcutLink);
-  dict.SetMethod("readShortcutLink", &ReadShortcutLink);
-#endif
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_shell, Initialize)
removed in remote
  base   100644 0ebd939398f1f6987f179a97664d1c12878c58b9 atom/common/api/atom_api_v8_util.cc
  our    100644 3d80db0c0a4cdbb4c7a78fa7e4266fc6fc87193f atom/common/api/atom_api_v8_util.cc
@@ -1,129 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-#include <utility>
-
-#include "atom/common/api/atom_api_key_weak_map.h"
-#include "atom/common/api/remote_callback_freer.h"
-#include "atom/common/api/remote_object_freer.h"
-#include "atom/common/native_mate_converters/content_converter.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/hash.h"
-#include "native_mate/dictionary.h"
-#include "url/origin.h"
-#include "v8/include/v8-profiler.h"
-
-namespace std {
-
-// The hash function used by DoubleIDWeakMap.
-template <typename Type1, typename Type2>
-struct hash<std::pair<Type1, Type2>> {
-  std::size_t operator()(std::pair<Type1, Type2> value) const {
-    return base::HashInts(base::Hash(value.first), value.second);
-  }
-};
-
-}  // namespace std
-
-namespace mate {
-
-template <typename Type1, typename Type2>
-struct Converter<std::pair<Type1, Type2>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     std::pair<Type1, Type2>* out) {
-    if (!val->IsArray())
-      return false;
-
-    v8::Local<v8::Array> array(v8::Local<v8::Array>::Cast(val));
-    if (array->Length() != 2)
-      return false;
-    return Converter<Type1>::FromV8(isolate, array->Get(0), &out->first) &&
-           Converter<Type2>::FromV8(isolate, array->Get(1), &out->second);
-  }
-};
-
-}  // namespace mate
-
-namespace {
-
-v8::Local<v8::Value> GetHiddenValue(v8::Isolate* isolate,
-                                    v8::Local<v8::Object> object,
-                                    v8::Local<v8::String> key) {
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  v8::Local<v8::Value> value;
-  v8::Maybe<bool> result = object->HasPrivate(context, privateKey);
-  if (!(result.IsJust() && result.FromJust()))
-    return v8::Local<v8::Value>();
-  if (object->GetPrivate(context, privateKey).ToLocal(&value))
-    return value;
-  return v8::Local<v8::Value>();
-}
-
-void SetHiddenValue(v8::Isolate* isolate,
-                    v8::Local<v8::Object> object,
-                    v8::Local<v8::String> key,
-                    v8::Local<v8::Value> value) {
-  if (value.IsEmpty())
-    return;
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  object->SetPrivate(context, privateKey, value);
-}
-
-void DeleteHiddenValue(v8::Isolate* isolate,
-                       v8::Local<v8::Object> object,
-                       v8::Local<v8::String> key) {
-  v8::Local<v8::Context> context = isolate->GetCurrentContext();
-  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
-  // Actually deleting the value would make force the object into
-  // dictionary mode which is unnecessarily slow. Instead, we replace
-  // the hidden value with "undefined".
-  object->SetPrivate(context, privateKey, v8::Undefined(isolate));
-}
-
-int32_t GetObjectHash(v8::Local<v8::Object> object) {
-  return object->GetIdentityHash();
-}
-
-void TakeHeapSnapshot(v8::Isolate* isolate) {
-  isolate->GetHeapProfiler()->TakeHeapSnapshot();
-}
-
-void RequestGarbageCollectionForTesting(v8::Isolate* isolate) {
-  isolate->RequestGarbageCollectionForTesting(
-      v8::Isolate::GarbageCollectionType::kFullGarbageCollection);
-}
-
-bool IsSameOrigin(const GURL& l, const GURL& r) {
-  return url::Origin::Create(l).IsSameOriginWith(url::Origin::Create(r));
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("getHiddenValue", &GetHiddenValue);
-  dict.SetMethod("setHiddenValue", &SetHiddenValue);
-  dict.SetMethod("deleteHiddenValue", &DeleteHiddenValue);
-  dict.SetMethod("getObjectHash", &GetObjectHash);
-  dict.SetMethod("takeHeapSnapshot", &TakeHeapSnapshot);
-  dict.SetMethod("setRemoteCallbackFreer", &atom::RemoteCallbackFreer::BindTo);
-  dict.SetMethod("setRemoteObjectFreer", &atom::RemoteObjectFreer::BindTo);
-  dict.SetMethod("createIDWeakMap", &atom::api::KeyWeakMap<int32_t>::Create);
-  dict.SetMethod(
-      "createDoubleIDWeakMap",
-      &atom::api::KeyWeakMap<std::pair<std::string, int32_t>>::Create);
-  dict.SetMethod("requestGarbageCollectionForTesting",
-                 &RequestGarbageCollectionForTesting);
-  dict.SetMethod("isSameOrigin", &IsSameOrigin);
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_common_v8_util, Initialize)
removed in remote
  base   100644 fe53d8793f2a765d050ea088add855d19f2cbd8f atom/common/api/atom_bindings.cc
  our    100644 3dba3d63673ca8eb02044bd1335a3095f0194971 atom/common/api/atom_bindings.cc
@@ -1,262 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/atom_bindings.h"
-
-#include <algorithm>
-#include <iostream>
-#include <string>
-
-#include "atom/common/api/locker.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/chrome_version.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/node_includes.h"
-#include "base/logging.h"
-#include "base/process/process_info.h"
-#include "base/process/process_metrics_iocounters.h"
-#include "base/sys_info.h"
-#include "native_mate/dictionary.h"
-
-namespace atom {
-
-namespace {
-
-// Dummy class type that used for crashing the program.
-struct DummyClass {
-  bool crash;
-};
-
-// Called when there is a fatal error in V8, we just crash the process here so
-// we can get the stack trace.
-void FatalErrorCallback(const char* location, const char* message) {
-  LOG(ERROR) << "Fatal error in V8: " << location << " " << message;
-  AtomBindings::Crash();
-}
-
-}  // namespace
-
-AtomBindings::AtomBindings(uv_loop_t* loop) {
-  uv_async_init(loop, &call_next_tick_async_, OnCallNextTick);
-  call_next_tick_async_.data = this;
-  metrics_ = base::ProcessMetrics::CreateCurrentProcessMetrics();
-}
-
-AtomBindings::~AtomBindings() {
-  uv_close(reinterpret_cast<uv_handle_t*>(&call_next_tick_async_), nullptr);
-}
-
-void AtomBindings::BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process) {
-  isolate->SetFatalErrorHandler(FatalErrorCallback);
-
-  mate::Dictionary dict(isolate, process);
-  dict.SetMethod("crash", &AtomBindings::Crash);
-  dict.SetMethod("hang", &Hang);
-  dict.SetMethod("log", &Log);
-  dict.SetMethod("getHeapStatistics", &GetHeapStatistics);
-  dict.SetMethod("getProcessMemoryInfo", &GetProcessMemoryInfo);
-  dict.SetMethod("getCreationTime", &GetCreationTime);
-  dict.SetMethod("getSystemMemoryInfo", &GetSystemMemoryInfo);
-  dict.SetMethod("getCPUUsage", base::Bind(&AtomBindings::GetCPUUsage,
-                                           base::Unretained(metrics_.get())));
-  dict.SetMethod("getIOCounters", &GetIOCounters);
-#if defined(OS_POSIX)
-  dict.SetMethod("setFdLimit", &base::SetFdLimit);
-#endif
-  dict.SetMethod("activateUvLoop", base::Bind(&AtomBindings::ActivateUVLoop,
-                                              base::Unretained(this)));
-
-#if defined(MAS_BUILD)
-  dict.Set("mas", true);
-#endif
-
-  mate::Dictionary versions;
-  if (dict.Get("versions", &versions)) {
-    // TODO(kevinsawicki): Make read-only in 2.0 to match node
-    versions.Set(ATOM_PROJECT_NAME, ATOM_VERSION_STRING);
-    versions.Set("chrome", CHROME_VERSION_STRING);
-  }
-}
-
-void AtomBindings::EnvironmentDestroyed(node::Environment* env) {
-  auto it =
-      std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env);
-  if (it != pending_next_ticks_.end())
-    pending_next_ticks_.erase(it);
-}
-
-void AtomBindings::ActivateUVLoop(v8::Isolate* isolate) {
-  node::Environment* env = node::Environment::GetCurrent(isolate);
-  if (std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env) !=
-      pending_next_ticks_.end())
-    return;
-
-  pending_next_ticks_.push_back(env);
-  uv_async_send(&call_next_tick_async_);
-}
-
-// static
-void AtomBindings::OnCallNextTick(uv_async_t* handle) {
-  AtomBindings* self = static_cast<AtomBindings*>(handle->data);
-  for (std::list<node::Environment*>::const_iterator it =
-           self->pending_next_ticks_.begin();
-       it != self->pending_next_ticks_.end(); ++it) {
-    node::Environment* env = *it;
-    mate::Locker locker(env->isolate());
-    v8::Context::Scope context_scope(env->context());
-    node::InternalCallbackScope scope(
-        env, v8::Local<v8::Object>(), {0, 0},
-        node::InternalCallbackScope::kAllowEmptyResource);
-  }
-
-  self->pending_next_ticks_.clear();
-}
-
-// static
-void AtomBindings::Log(const base::string16& message) {
-  std::cout << message << std::flush;
-}
-
-// static
-void AtomBindings::Crash() {
-  static_cast<DummyClass*>(nullptr)->crash = true;
-}
-
-// static
-void AtomBindings::Hang() {
-  for (;;)
-    base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(1));
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetHeapStatistics(v8::Isolate* isolate) {
-  v8::HeapStatistics v8_heap_stats;
-  isolate->GetHeapStatistics(&v8_heap_stats);
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("totalHeapSize",
-           static_cast<double>(v8_heap_stats.total_heap_size() >> 10));
-  dict.Set(
-      "totalHeapSizeExecutable",
-      static_cast<double>(v8_heap_stats.total_heap_size_executable() >> 10));
-  dict.Set("totalPhysicalSize",
-           static_cast<double>(v8_heap_stats.total_physical_size() >> 10));
-  dict.Set("totalAvailableSize",
-           static_cast<double>(v8_heap_stats.total_available_size() >> 10));
-  dict.Set("usedHeapSize",
-           static_cast<double>(v8_heap_stats.used_heap_size() >> 10));
-  dict.Set("heapSizeLimit",
-           static_cast<double>(v8_heap_stats.heap_size_limit() >> 10));
-  dict.Set("mallocedMemory",
-           static_cast<double>(v8_heap_stats.malloced_memory() >> 10));
-  dict.Set("peakMallocedMemory",
-           static_cast<double>(v8_heap_stats.peak_malloced_memory() >> 10));
-  dict.Set("doesZapGarbage",
-           static_cast<bool>(v8_heap_stats.does_zap_garbage()));
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetProcessMemoryInfo(v8::Isolate* isolate) {
-  auto metrics = base::ProcessMetrics::CreateCurrentProcessMetrics();
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("workingSetSize",
-           static_cast<double>(metrics->GetWorkingSetSize() >> 10));
-  dict.Set("peakWorkingSetSize",
-           static_cast<double>(metrics->GetPeakWorkingSetSize() >> 10));
-
-  size_t private_bytes, shared_bytes;
-  if (metrics->GetMemoryBytes(&private_bytes, &shared_bytes)) {
-    dict.Set("privateBytes", static_cast<double>(private_bytes >> 10));
-    dict.Set("sharedBytes", static_cast<double>(shared_bytes >> 10));
-  }
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetCreationTime(v8::Isolate* isolate) {
-  auto timeValue = base::CurrentProcessInfo::CreationTime();
-  if (timeValue.is_null()) {
-    return v8::Null(isolate);
-  }
-  double jsTime = timeValue.ToJsTime();
-  return v8::Number::New(isolate, jsTime);
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetSystemMemoryInfo(v8::Isolate* isolate,
-                                                       mate::Arguments* args) {
-  base::SystemMemoryInfoKB mem_info;
-  if (!base::GetSystemMemoryInfo(&mem_info)) {
-    args->ThrowError("Unable to retrieve system memory information");
-    return v8::Undefined(isolate);
-  }
-
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("total", mem_info.total);
-
-  // See Chromium's "base/process/process_metrics.h" for an explanation.
-  int free =
-#if defined(OS_WIN)
-      mem_info.avail_phys;
-#else
-      mem_info.free;
-#endif
-  dict.Set("free", free);
-
-  // NB: These return bogus values on macOS
-#if !defined(OS_MACOSX)
-  dict.Set("swapTotal", mem_info.swap_total);
-  dict.Set("swapFree", mem_info.swap_free);
-#endif
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetCPUUsage(base::ProcessMetrics* metrics,
-                                               v8::Isolate* isolate) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  int processor_count = base::SysInfo::NumberOfProcessors();
-  dict.Set("percentCPUUsage",
-           metrics->GetPlatformIndependentCPUUsage() / processor_count);
-
-  // NB: This will throw NOTIMPLEMENTED() on Windows
-  // For backwards compatibility, we'll return 0
-#if !defined(OS_WIN)
-  dict.Set("idleWakeupsPerSecond", metrics->GetIdleWakeupsPerSecond());
-#else
-  dict.Set("idleWakeupsPerSecond", 0);
-#endif
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> AtomBindings::GetIOCounters(v8::Isolate* isolate) {
-  auto metrics = base::ProcessMetrics::CreateCurrentProcessMetrics();
-  base::IoCounters io_counters;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-
-  if (metrics->GetIOCounters(&io_counters)) {
-    dict.Set("readOperationCount", io_counters.ReadOperationCount);
-    dict.Set("writeOperationCount", io_counters.WriteOperationCount);
-    dict.Set("otherOperationCount", io_counters.OtherOperationCount);
-    dict.Set("readTransferCount", io_counters.ReadTransferCount);
-    dict.Set("writeTransferCount", io_counters.WriteTransferCount);
-    dict.Set("otherTransferCount", io_counters.OtherTransferCount);
-  }
-
-  return dict.GetHandle();
-}
-
-}  // namespace atom
removed in remote
  base   100644 9460145d2391a10fe0e18f2be29a9765862639ac atom/common/api/atom_bindings.h
  our    100644 ba8385c979b15286fd7647582e7d0aee93e1974e atom/common/api/atom_bindings.h
@@ -1,61 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_ATOM_BINDINGS_H_
-#define ATOM_COMMON_API_ATOM_BINDINGS_H_
-
-#include <list>
-
-#include "base/macros.h"
-#include "base/process/process_metrics.h"
-#include "base/strings/string16.h"
-#include "native_mate/arguments.h"
-#include "uv.h"  // NOLINT(build/include)
-#include "v8/include/v8.h"
-
-namespace node {
-class Environment;
-}
-
-namespace atom {
-
-class AtomBindings {
- public:
-  explicit AtomBindings(uv_loop_t* loop);
-  virtual ~AtomBindings();
-
-  // Add process.atomBinding function, which behaves like process.binding but
-  // load native code from Electron instead.
-  void BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process);
-
-  // Should be called when a node::Environment has been destroyed.
-  void EnvironmentDestroyed(node::Environment* env);
-
-  static void Log(const base::string16& message);
-  static void Crash();
-  static void Hang();
-  static v8::Local<v8::Value> GetHeapStatistics(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetProcessMemoryInfo(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetCreationTime(v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetSystemMemoryInfo(v8::Isolate* isolate,
-                                                  mate::Arguments* args);
-  static v8::Local<v8::Value> GetCPUUsage(base::ProcessMetrics* metrics,
-                                          v8::Isolate* isolate);
-  static v8::Local<v8::Value> GetIOCounters(v8::Isolate* isolate);
-
- private:
-  void ActivateUVLoop(v8::Isolate* isolate);
-
-  static void OnCallNextTick(uv_async_t* handle);
-
-  uv_async_t call_next_tick_async_;
-  std::list<node::Environment*> pending_next_ticks_;
-  std::unique_ptr<base::ProcessMetrics> metrics_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomBindings);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_API_ATOM_BINDINGS_H_
removed in remote
  base   100644 4b44553d37401947f2c47e55949d8a4f51cbe6b2 atom/common/api/event_emitter_caller.cc
  our    100644 a3b9187d68e32038df191a93305c39d7dd104a97 atom/common/api/event_emitter_caller.cc
@@ -1,38 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/event_emitter_caller.h"
-
-#include "atom/common/api/locker.h"
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace internal {
-
-v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> obj,
-                                        const char* method,
-                                        ValueVector* args) {
-  // Perform microtask checkpoint after running JavaScript.
-  v8::MicrotasksScope script_scope(isolate,
-                                   v8::MicrotasksScope::kRunMicrotasks);
-  // Use node::MakeCallback to call the callback, and it will also run pending
-  // tasks in Node.js.
-  v8::MaybeLocal<v8::Value> ret = node::MakeCallback(
-      isolate, obj, method, args->size(), &args->front(), {0, 0});
-  // If the JS function throws an exception (doesn't return a value) the result
-  // of MakeCallback will be empty and therefore ToLocal will be false, in this
-  // case we need to return "false" as that indicates that the event emitter did
-  // not handle the event
-  v8::Local<v8::Value> localRet;
-  if (ret.ToLocal(&localRet)) {
-    return localRet;
-  }
-  return v8::Boolean::New(isolate, false);
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 a2567da9d109131c87d4a20bdcea64d739119c6c atom/common/api/event_emitter_caller.h
  our    100644 023fb0a1d72f4b08e1ca8fae3ea6b74edb4bfcad atom/common/api/event_emitter_caller.h
@@ -1,68 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
-#define ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
-
-#include <vector>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "native_mate/converter.h"
-
-namespace mate {
-
-namespace internal {
-
-using ValueVector = std::vector<v8::Local<v8::Value>>;
-
-v8::Local<v8::Value> CallMethodWithArgs(v8::Isolate* isolate,
-                                        v8::Local<v8::Object> obj,
-                                        const char* method,
-                                        ValueVector* args);
-
-}  // namespace internal
-
-// obj.emit.apply(obj, name, args...);
-// The caller is responsible of allocating a HandleScope.
-template <typename StringType>
-v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
-                               v8::Local<v8::Object> obj,
-                               const StringType& name,
-                               const internal::ValueVector& args) {
-  internal::ValueVector concatenated_args = {StringToV8(isolate, name)};
-  concatenated_args.reserve(1 + args.size());
-  concatenated_args.insert(concatenated_args.end(), args.begin(), args.end());
-  return internal::CallMethodWithArgs(isolate, obj, "emit", &concatenated_args);
-}
-
-// obj.emit(name, args...);
-// The caller is responsible of allocating a HandleScope.
-template <typename StringType, typename... Args>
-v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
-                               v8::Local<v8::Object> obj,
-                               const StringType& name,
-                               const Args&... args) {
-  internal::ValueVector converted_args = {
-      StringToV8(isolate, name),
-      ConvertToV8(isolate, args)...,
-  };
-  return internal::CallMethodWithArgs(isolate, obj, "emit", &converted_args);
-}
-
-// obj.custom_emit(args...)
-template <typename... Args>
-v8::Local<v8::Value> CustomEmit(v8::Isolate* isolate,
-                                v8::Local<v8::Object> object,
-                                const char* custom_emit,
-                                const Args&... args) {
-  internal::ValueVector converted_args = {
-      ConvertToV8(isolate, args)...,
-  };
-  return internal::CallMethodWithArgs(isolate, object, custom_emit,
-                                      &converted_args);
-}
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_EVENT_EMITTER_CALLER_H_
removed in remote
  base   100644 fe0b23479a46a90aa32ebf3ba93aae0c9302accc atom/common/api/locker.cc
  our    100644 0ae695a1f056722c24e6281ecbddad54032534ad atom/common/api/locker.cc
@@ -1,16 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE.chromium file.
-
-#include "atom/common/api/locker.h"
-
-namespace mate {
-
-Locker::Locker(v8::Isolate* isolate) {
-  if (IsBrowserProcess())
-    locker_.reset(new v8::Locker(isolate));
-}
-
-Locker::~Locker() {}
-
-}  // namespace mate
removed in remote
  base   100644 201217ff625af48a4f0985272757cd058e9d5271 atom/common/api/locker.h
  our    100644 e64ef1853ec5df933a78873cb7c23a975c122894 atom/common/api/locker.h
@@ -1,36 +0,0 @@
-// Copyright 2014 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE.chromium file.
-
-#ifndef ATOM_COMMON_API_LOCKER_H_
-#define ATOM_COMMON_API_LOCKER_H_
-
-#include <memory>
-
-#include "base/macros.h"
-#include "v8/include/v8.h"
-
-namespace mate {
-
-// Only lock when lockers are used in current thread.
-class Locker {
- public:
-  explicit Locker(v8::Isolate* isolate);
-  ~Locker();
-
-  // Returns whether current process is browser process, currently we detect it
-  // by checking whether current has used V8 Lock, but it might be a bad idea.
-  static inline bool IsBrowserProcess() { return v8::Locker::IsActive(); }
-
- private:
-  void* operator new(size_t size);
-  void operator delete(void*, size_t);
-
-  std::unique_ptr<v8::Locker> locker_;
-
-  DISALLOW_COPY_AND_ASSIGN(Locker);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_API_LOCKER_H_
removed in remote
  base   100644 916ad8a5177ae5e359aeff96a8ec91fce99c6030 atom/common/api/object_life_monitor.cc
  our    100644 4f83a76cf682f3071e2f948fb897069dbdbb0844 atom/common/api/object_life_monitor.cc
@@ -1,41 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Copyright (c) 2012 Intel Corp. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/api/object_life_monitor.h"
-
-#include "base/bind.h"
-#include "base/message_loop/message_loop.h"
-
-namespace atom {
-
-ObjectLifeMonitor::ObjectLifeMonitor(v8::Isolate* isolate,
-                                     v8::Local<v8::Object> target)
-    : target_(isolate, target), weak_ptr_factory_(this) {
-  target_.SetWeak(this, OnObjectGC, v8::WeakCallbackType::kParameter);
-}
-
-ObjectLifeMonitor::~ObjectLifeMonitor() {
-  if (target_.IsEmpty())
-    return;
-  target_.ClearWeak();
-  target_.Reset();
-}
-
-// static
-void ObjectLifeMonitor::OnObjectGC(
-    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
-  ObjectLifeMonitor* self = data.GetParameter();
-  self->target_.Reset();
-  self->RunDestructor();
-  data.SetSecondPassCallback(Free);
-}
-
-// static
-void ObjectLifeMonitor::Free(
-    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
-  delete data.GetParameter();
-}
-
-}  // namespace atom
removed in remote
  base   100644 82d923fcedb7db9d26472e7ee8750cfbfe3c69c6 atom/common/api/object_life_monitor.h
  our    100644 e047960e8130771fb1f240d84b53b181e868670e atom/common/api/object_life_monitor.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
-#define ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
-
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "v8/include/v8.h"
-
-namespace atom {
-
-class ObjectLifeMonitor {
- protected:
-  ObjectLifeMonitor(v8::Isolate* isolate, v8::Local<v8::Object> target);
-  virtual ~ObjectLifeMonitor();
-
-  virtual void RunDestructor() = 0;
-
- private:
-  static void OnObjectGC(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
-  static void Free(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
-
-  v8::Global<v8::Object> target_;
-
-  base::WeakPtrFactory<ObjectLifeMonitor> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(ObjectLifeMonitor);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_API_OBJECT_LIFE_MONITOR_H_
removed in remote
  base   100644 01fe23a889225b1002b1f75b7787ef4f12e78cb7 atom/common/asar/archive.cc
  our    100644 9b37f94a4dc462c0cc84e0182654ff2571952df9 atom/common/asar/archive.cc
@@ -1,315 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/archive.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/asar/scoped_temporary_file.h"
-#include "base/files/file.h"
-#include "base/files/file_util.h"
-#include "base/json/json_reader.h"
-#include "base/logging.h"
-#include "base/pickle.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/task_scheduler/post_task.h"
-#include "base/threading/thread_restrictions.h"
-#include "base/values.h"
-
-#if defined(OS_WIN)
-#include <io.h>
-#endif
-
-namespace asar {
-
-namespace {
-
-#if defined(OS_WIN)
-const char kSeparators[] = "\\/";
-#else
-const char kSeparators[] = "/";
-#endif
-
-bool GetNodeFromPath(std::string path,
-                     const base::DictionaryValue* root,
-                     const base::DictionaryValue** out);
-
-// Gets the "files" from "dir".
-bool GetFilesNode(const base::DictionaryValue* root,
-                  const base::DictionaryValue* dir,
-                  const base::DictionaryValue** out) {
-  // Test for symbol linked directory.
-  std::string link;
-  if (dir->GetStringWithoutPathExpansion("link", &link)) {
-    const base::DictionaryValue* linked_node = nullptr;
-    if (!GetNodeFromPath(link, root, &linked_node))
-      return false;
-    dir = linked_node;
-  }
-
-  return dir->GetDictionaryWithoutPathExpansion("files", out);
-}
-
-// Gets sub-file "name" from "dir".
-bool GetChildNode(const base::DictionaryValue* root,
-                  const std::string& name,
-                  const base::DictionaryValue* dir,
-                  const base::DictionaryValue** out) {
-  if (name == "") {
-    *out = root;
-    return true;
-  }
-
-  const base::DictionaryValue* files = nullptr;
-  return GetFilesNode(root, dir, &files) &&
-         files->GetDictionaryWithoutPathExpansion(name, out);
-}
-
-// Gets the node of "path" from "root".
-bool GetNodeFromPath(std::string path,
-                     const base::DictionaryValue* root,
-                     const base::DictionaryValue** out) {
-  if (path == "") {
-    *out = root;
-    return true;
-  }
-
-  const base::DictionaryValue* dir = root;
-  for (size_t delimiter_position = path.find_first_of(kSeparators);
-       delimiter_position != std::string::npos;
-       delimiter_position = path.find_first_of(kSeparators)) {
-    const base::DictionaryValue* child = nullptr;
-    if (!GetChildNode(root, path.substr(0, delimiter_position), dir, &child))
-      return false;
-
-    dir = child;
-    path.erase(0, delimiter_position + 1);
-  }
-
-  return GetChildNode(root, path, dir, out);
-}
-
-bool FillFileInfoWithNode(Archive::FileInfo* info,
-                          uint32_t header_size,
-                          const base::DictionaryValue* node) {
-  int size;
-  if (!node->GetInteger("size", &size))
-    return false;
-  info->size = static_cast<uint32_t>(size);
-
-  if (node->GetBoolean("unpacked", &info->unpacked) && info->unpacked)
-    return true;
-
-  std::string offset;
-  if (!node->GetString("offset", &offset))
-    return false;
-  if (!base::StringToUint64(offset, &info->offset))
-    return false;
-  info->offset += header_size;
-
-  node->GetBoolean("executable", &info->executable);
-
-  return true;
-}
-
-}  // namespace
-
-Archive::Archive(const base::FilePath& path)
-    : path_(path), file_(base::File::FILE_OK) {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  file_.Initialize(path_, base::File::FLAG_OPEN | base::File::FLAG_READ);
-#if defined(OS_WIN)
-  fd_ = _open_osfhandle(reinterpret_cast<intptr_t>(file_.GetPlatformFile()), 0);
-#elif defined(OS_POSIX)
-  fd_ = file_.GetPlatformFile();
-#endif
-}
-
-Archive::~Archive() {
-#if defined(OS_WIN)
-  if (fd_ != -1) {
-    _close(fd_);
-    // Don't close the handle since we already closed the fd.
-    file_.TakePlatformFile();
-  }
-#endif
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  file_.Close();
-}
-
-bool Archive::Init() {
-  if (!file_.IsValid()) {
-    if (file_.error_details() != base::File::FILE_ERROR_NOT_FOUND) {
-      LOG(WARNING) << "Opening " << path_.value() << ": "
-                   << base::File::ErrorToString(file_.error_details());
-    }
-    return false;
-  }
-
-  std::vector<char> buf;
-  int len;
-
-  buf.resize(8);
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    len = file_.ReadAtCurrentPos(buf.data(), buf.size());
-  }
-  if (len != static_cast<int>(buf.size())) {
-    PLOG(ERROR) << "Failed to read header size from " << path_.value();
-    return false;
-  }
-
-  uint32_t size;
-  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size()))
-           .ReadUInt32(&size)) {
-    LOG(ERROR) << "Failed to parse header size from " << path_.value();
-    return false;
-  }
-
-  buf.resize(size);
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    len = file_.ReadAtCurrentPos(buf.data(), buf.size());
-  }
-  if (len != static_cast<int>(buf.size())) {
-    PLOG(ERROR) << "Failed to read header from " << path_.value();
-    return false;
-  }
-
-  std::string header;
-  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size()))
-           .ReadString(&header)) {
-    LOG(ERROR) << "Failed to parse header from " << path_.value();
-    return false;
-  }
-
-  std::string error;
-  base::JSONReader reader;
-  std::unique_ptr<base::Value> value(reader.ReadToValue(header));
-  if (!value || !value->is_dict()) {
-    LOG(ERROR) << "Failed to parse header: " << error;
-    return false;
-  }
-
-  header_size_ = 8 + size;
-  header_.reset(static_cast<base::DictionaryValue*>(value.release()));
-  return true;
-}
-
-bool Archive::GetFileInfo(const base::FilePath& path, FileInfo* info) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  std::string link;
-  if (node->GetString("link", &link))
-    return GetFileInfo(base::FilePath::FromUTF8Unsafe(link), info);
-
-  return FillFileInfoWithNode(info, header_size_, node);
-}
-
-bool Archive::Stat(const base::FilePath& path, Stats* stats) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  if (node->FindKey("link")) {
-    stats->is_file = false;
-    stats->is_link = true;
-    return true;
-  }
-
-  if (node->FindKey("files")) {
-    stats->is_file = false;
-    stats->is_directory = true;
-    return true;
-  }
-
-  return FillFileInfoWithNode(stats, header_size_, node);
-}
-
-bool Archive::Readdir(const base::FilePath& path,
-                      std::vector<base::FilePath>* list) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  const base::DictionaryValue* files;
-  if (!GetFilesNode(header_.get(), node, &files))
-    return false;
-
-  base::DictionaryValue::Iterator iter(*files);
-  while (!iter.IsAtEnd()) {
-    list->push_back(base::FilePath::FromUTF8Unsafe(iter.key()));
-    iter.Advance();
-  }
-  return true;
-}
-
-bool Archive::Realpath(const base::FilePath& path, base::FilePath* realpath) {
-  if (!header_)
-    return false;
-
-  const base::DictionaryValue* node;
-  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
-    return false;
-
-  std::string link;
-  if (node->GetString("link", &link)) {
-    *realpath = base::FilePath::FromUTF8Unsafe(link);
-    return true;
-  }
-
-  *realpath = path;
-  return true;
-}
-
-bool Archive::CopyFileOut(const base::FilePath& path, base::FilePath* out) {
-  auto it = external_files_.find(path.value());
-  if (it != external_files_.end()) {
-    *out = it->second->path();
-    return true;
-  }
-
-  FileInfo info;
-  if (!GetFileInfo(path, &info))
-    return false;
-
-  if (info.unpacked) {
-    *out = path_.AddExtension(FILE_PATH_LITERAL("unpacked")).Append(path);
-    return true;
-  }
-
-  auto temp_file = std::make_unique<ScopedTemporaryFile>();
-  base::FilePath::StringType ext = path.Extension();
-  if (!temp_file->InitFromFile(&file_, ext, info.offset, info.size))
-    return false;
-
-#if defined(OS_POSIX)
-  if (info.executable) {
-    // chmod a+x temp_file;
-    base::SetPosixFilePermissions(temp_file->path(), 0755);
-  }
-#endif
-
-  *out = temp_file->path();
-  external_files_[path.value()] = std::move(temp_file);
-  return true;
-}
-
-int Archive::GetFD() const {
-  return fd_;
-}
-
-}  // namespace asar
removed in remote
  base   100644 79b848623c99ec2260283ad3ca2d9ded729a397c atom/common/asar/archive.h
  our    100644 5715578ca16aae2c948f914a1352efbdcae1de3e atom/common/asar/archive.h
@@ -1,87 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_ARCHIVE_H_
-#define ATOM_COMMON_ASAR_ARCHIVE_H_
-
-#include <memory>
-#include <unordered_map>
-#include <vector>
-
-#include "base/files/file.h"
-#include "base/files/file_path.h"
-
-namespace base {
-class DictionaryValue;
-}
-
-namespace asar {
-
-class ScopedTemporaryFile;
-
-// This class represents an asar package, and provides methods to read
-// information from it.
-class Archive {
- public:
-  struct FileInfo {
-    FileInfo() : unpacked(false), executable(false), size(0), offset(0) {}
-    bool unpacked;
-    bool executable;
-    uint32_t size;
-    uint64_t offset;
-  };
-
-  struct Stats : public FileInfo {
-    Stats() : is_file(true), is_directory(false), is_link(false) {}
-    bool is_file;
-    bool is_directory;
-    bool is_link;
-  };
-
-  explicit Archive(const base::FilePath& path);
-  virtual ~Archive();
-
-  // Read and parse the header.
-  bool Init();
-
-  // Get the info of a file.
-  bool GetFileInfo(const base::FilePath& path, FileInfo* info);
-
-  // Fs.stat(path).
-  bool Stat(const base::FilePath& path, Stats* stats);
-
-  // Fs.readdir(path).
-  bool Readdir(const base::FilePath& path, std::vector<base::FilePath>* files);
-
-  // Fs.realpath(path).
-  bool Realpath(const base::FilePath& path, base::FilePath* realpath);
-
-  // Copy the file into a temporary file, and return the new path.
-  // For unpacked file, this method will return its real path.
-  bool CopyFileOut(const base::FilePath& path, base::FilePath* out);
-
-  // Returns the file's fd.
-  int GetFD() const;
-
-  base::FilePath path() const { return path_; }
-  base::DictionaryValue* header() const { return header_.get(); }
-
- private:
-  base::FilePath path_;
-  base::File file_;
-  int fd_ = -1;
-  uint32_t header_size_ = 0;
-  std::unique_ptr<base::DictionaryValue> header_;
-
-  // Cached external temporary files.
-  std::unordered_map<base::FilePath::StringType,
-                     std::unique_ptr<ScopedTemporaryFile>>
-      external_files_;
-
-  DISALLOW_COPY_AND_ASSIGN(Archive);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_ARCHIVE_H_
removed in remote
  base   100644 1eee09949aff3b4079b2687ad1be2071e7021f01 atom/common/asar/asar_util.cc
  our    100644 b564a75dc7223b118c03441d5cbfa63337a89efc atom/common/asar/asar_util.cc
@@ -1,100 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/asar_util.h"
-
-#include <map>
-#include <string>
-
-#include "atom/common/asar/archive.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/lazy_instance.h"
-#include "base/stl_util.h"
-#include "base/threading/thread_local.h"
-
-namespace asar {
-
-namespace {
-
-// The global instance of ArchiveMap, will be destroyed on exit.
-typedef std::map<base::FilePath, std::shared_ptr<Archive>> ArchiveMap;
-base::LazyInstance<base::ThreadLocalPointer<ArchiveMap>>::Leaky
-    g_archive_map_tls = LAZY_INSTANCE_INITIALIZER;
-
-const base::FilePath::CharType kAsarExtension[] = FILE_PATH_LITERAL(".asar");
-
-}  // namespace
-
-std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path) {
-  if (!g_archive_map_tls.Pointer()->Get())
-    g_archive_map_tls.Pointer()->Set(new ArchiveMap);
-  ArchiveMap& archive_map = *g_archive_map_tls.Pointer()->Get();
-  if (!ContainsKey(archive_map, path)) {
-    std::shared_ptr<Archive> archive(new Archive(path));
-    if (!archive->Init())
-      return nullptr;
-    archive_map[path] = archive;
-  }
-  return archive_map[path];
-}
-
-void ClearArchives() {
-  if (g_archive_map_tls.Pointer()->Get())
-    delete g_archive_map_tls.Pointer()->Get();
-}
-
-bool GetAsarArchivePath(const base::FilePath& full_path,
-                        base::FilePath* asar_path,
-                        base::FilePath* relative_path) {
-  base::FilePath iter = full_path;
-  while (true) {
-    base::FilePath dirname = iter.DirName();
-    if (iter.MatchesExtension(kAsarExtension))
-      break;
-    else if (iter == dirname)
-      return false;
-    iter = dirname;
-  }
-
-  base::FilePath tail;
-  if (!iter.AppendRelativePath(full_path, &tail))
-    return false;
-
-  *asar_path = iter;
-  *relative_path = tail;
-  return true;
-}
-
-bool ReadFileToString(const base::FilePath& path, std::string* contents) {
-  base::FilePath asar_path, relative_path;
-  if (!GetAsarArchivePath(path, &asar_path, &relative_path))
-    return base::ReadFileToString(path, contents);
-
-  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
-  if (!archive)
-    return false;
-
-  Archive::FileInfo info;
-  if (!archive->GetFileInfo(relative_path, &info))
-    return false;
-
-  if (info.unpacked) {
-    base::FilePath real_path;
-    // For unpacked file it will return the real path instead of doing the copy.
-    archive->CopyFileOut(relative_path, &real_path);
-    return base::ReadFileToString(real_path, contents);
-  }
-
-  base::File src(asar_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
-  if (!src.IsValid())
-    return false;
-
-  contents->resize(info.size);
-  return static_cast<int>(info.size) ==
-         src.Read(info.offset, const_cast<char*>(contents->data()),
-                  contents->size());
-}
-
-}  // namespace asar
removed in remote
  base   100644 4cb5b88e04838199024c28ace4679fdcc424c674 atom/common/asar/asar_util.h
  our    100644 90ffb9b46a3008cbcdd9e94ffe69594349dd4d25 atom/common/asar/asar_util.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_ASAR_UTIL_H_
-#define ATOM_COMMON_ASAR_ASAR_UTIL_H_
-
-#include <memory>
-#include <string>
-
-namespace base {
-class FilePath;
-}
-
-namespace asar {
-
-class Archive;
-
-// Gets or creates a new Archive from the path.
-std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path);
-
-// Destroy cached Archive objects.
-void ClearArchives();
-
-// Separates the path to Archive out.
-bool GetAsarArchivePath(const base::FilePath& full_path,
-                        base::FilePath* asar_path,
-                        base::FilePath* relative_path);
-
-// Same with base::ReadFileToString but supports asar Archive.
-bool ReadFileToString(const base::FilePath& path, std::string* contents);
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_ASAR_UTIL_H_
removed in remote
  base   100644 8578d90d9074f2124cf746260c5bad394f7d5b31 atom/common/asar/scoped_temporary_file.cc
  our    100644 f96eabc7a60dd73a556ef8e083fca51e72abdf7b atom/common/asar/scoped_temporary_file.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/asar/scoped_temporary_file.h"
-
-#include <vector>
-
-#include "base/files/file_util.h"
-#include "base/threading/thread_restrictions.h"
-
-namespace asar {
-
-ScopedTemporaryFile::ScopedTemporaryFile() {}
-
-ScopedTemporaryFile::~ScopedTemporaryFile() {
-  if (!path_.empty()) {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    // On Windows it is very likely the file is already in use (because it is
-    // mostly used for Node native modules), so deleting it now will halt the
-    // program.
-#if defined(OS_WIN)
-    base::DeleteFileAfterReboot(path_);
-#else
-    base::DeleteFile(path_, false);
-#endif
-  }
-}
-
-bool ScopedTemporaryFile::Init(const base::FilePath::StringType& ext) {
-  if (!path_.empty())
-    return true;
-
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  if (!base::CreateTemporaryFile(&path_))
-    return false;
-
-#if defined(OS_WIN)
-  // Keep the original extension.
-  if (!ext.empty()) {
-    base::FilePath new_path = path_.AddExtension(ext);
-    if (!base::Move(path_, new_path))
-      return false;
-    path_ = new_path;
-  }
-#endif
-
-  return true;
-}
-
-bool ScopedTemporaryFile::InitFromFile(base::File* src,
-                                       const base::FilePath::StringType& ext,
-                                       uint64_t offset,
-                                       uint64_t size) {
-  if (!src->IsValid())
-    return false;
-
-  if (!Init(ext))
-    return false;
-
-  std::vector<char> buf(size);
-  int len = src->Read(offset, buf.data(), buf.size());
-  if (len != static_cast<int>(size))
-    return false;
-
-  base::File dest(path_, base::File::FLAG_OPEN | base::File::FLAG_WRITE);
-  if (!dest.IsValid())
-    return false;
-
-  return dest.WriteAtCurrentPos(buf.data(), buf.size()) ==
-         static_cast<int>(size);
-}
-
-}  // namespace asar
removed in remote
  base   100644 5931d9b87af7853cfbc18f6153ac17a5ff5a09a2 atom/common/asar/scoped_temporary_file.h
  our    100644 4a55958b80842224916973e8df410784a8f5e1b6 atom/common/asar/scoped_temporary_file.h
@@ -1,44 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
-#define ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
-
-#include "base/files/file_path.h"
-
-namespace base {
-class File;
-}
-
-namespace asar {
-
-// An object representing a temporary file that should be cleaned up when this
-// object goes out of scope.  Note that since deletion occurs during the
-// destructor, no further error handling is possible if the directory fails to
-// be deleted.  As a result, deletion is not guaranteed by this class.
-class ScopedTemporaryFile {
- public:
-  ScopedTemporaryFile();
-  virtual ~ScopedTemporaryFile();
-
-  // Init an empty temporary file with a certain extension.
-  bool Init(const base::FilePath::StringType& ext);
-
-  // Init an temporary file and fill it with content of |path|.
-  bool InitFromFile(base::File* src,
-                    const base::FilePath::StringType& ext,
-                    uint64_t offset,
-                    uint64_t size);
-
-  base::FilePath path() const { return path_; }
-
- private:
-  base::FilePath path_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedTemporaryFile);
-};
-
-}  // namespace asar
-
-#endif  // ATOM_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
removed in remote
  base   100644 2ac62385aeaccc7cd7cce840b098f55cd091b2c0 atom/common/atom_command_line.cc
  our    100644 287e43f75fef778948ef9acdac8b9a7edfe07d0a atom/common/atom_command_line.cc
@@ -1,36 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/atom_command_line.h"
-
-#include "base/command_line.h"
-#include "uv.h"  // NOLINT(build/include)
-
-namespace atom {
-
-// static
-base::CommandLine::StringVector AtomCommandLine::argv_;
-
-// static
-void AtomCommandLine::Init(int argc, base::CommandLine::CharType** argv) {
-  DCHECK(argv_.empty());
-
-  // NOTE: uv_setup_args does nothing on Windows, so we don't need to call it.
-  // Otherwise we'd have to convert the arguments from UTF16.
-#if !defined(OS_WIN)
-  // Hack around with the argv pointer. Used for process.title = "blah"
-  argv = uv_setup_args(argc, argv);
-#endif
-
-  argv_.assign(argv, argv + argc);
-}
-
-#if defined(OS_LINUX)
-// static
-void AtomCommandLine::InitializeFromCommandLine() {
-  argv_ = base::CommandLine::ForCurrentProcess()->argv();
-}
-#endif
-
-}  // namespace atom
removed in remote
  base   100644 b5915533a41bd12ef17a3a748e6a503f7c04ea26 atom/common/atom_command_line.h
  our    100644 57dab57e78c4785bc847cb36dc11c893cc055b32 atom/common/atom_command_line.h
@@ -1,38 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_COMMAND_LINE_H_
-#define ATOM_COMMON_ATOM_COMMAND_LINE_H_
-
-#include <string>
-#include <vector>
-
-#include "base/command_line.h"
-#include "base/macros.h"
-#include "build/build_config.h"
-
-namespace atom {
-
-// Singleton to remember the original "argc" and "argv".
-class AtomCommandLine {
- public:
-  static const base::CommandLine::StringVector& argv() { return argv_; }
-
-  static void Init(int argc, base::CommandLine::CharType** argv);
-
-#if defined(OS_LINUX)
-  // On Linux the command line has to be read from base::CommandLine since
-  // it is using zygote.
-  static void InitializeFromCommandLine();
-#endif
-
- private:
-  static base::CommandLine::StringVector argv_;
-
-  DISALLOW_IMPLICIT_CONSTRUCTORS(AtomCommandLine);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_ATOM_COMMAND_LINE_H_
removed in remote
  base   100644 dacda3c816c80611ff88b50813e899173c025886 atom/common/atom_constants.cc
  our    100644 f5188983cc04b6873f71a0d35211a73b9b583771 atom/common/atom_constants.cc
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/atom_constants.h"
-
-namespace atom {
-
-const char kCORSHeader[] = "Access-Control-Allow-Origin: *";
-
-const char kSHA1Certificate[] = "SHA-1 Certificate";
-const char kSHA1MajorDescription[] =
-    "The certificate for this site expires in 2017 or later, "
-    "and the certificate chain contains a certificate signed using SHA-1.";
-const char kSHA1MinorDescription[] =
-    "The certificate for this site expires in 2016, "
-    "and the certificate chain contains a certificate signed using SHA-1.";
-const char kCertificateError[] = "Certificate Error";
-const char kValidCertificate[] = "Valid Certificate";
-const char kValidCertificateDescription[] =
-    "The connection to this site is using a valid, trusted server certificate.";
-const char kSecureProtocol[] = "Secure TLS connection";
-const char kSecureProtocolDescription[] =
-    "The connection to this site is using a strong protocol version "
-    "and cipher suite.";
-
-#if defined(ENABLE_PDF_VIEWER)
-const char kPdfPluginMimeType[] = "application/x-google-chrome-pdf";
-const char kPdfPluginPath[] = "chrome://pdf-viewer/";
-const char kPdfPluginSrc[] = "src";
-
-const char kPdfViewerUIOrigin[] = "chrome://pdf-viewer/";
-const char kPdfViewerUIHost[] = "pdf-viewer";
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace atom
removed in remote
  base   100644 e0d42e83eef95790260f80ff026d3baaa74dd311 atom/common/atom_constants.h
  our    100644 7ad948f43f96edf174d23e16525ecd6cdd86a48f atom/common/atom_constants.h
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_CONSTANTS_H_
-#define ATOM_COMMON_ATOM_CONSTANTS_H_
-
-namespace atom {
-
-// Header to ignore CORS.
-extern const char kCORSHeader[];
-
-// Strings describing Chrome security policy for DevTools security panel.
-extern const char kSHA1Certificate[];
-extern const char kSHA1MajorDescription[];
-extern const char kSHA1MinorDescription[];
-extern const char kCertificateError[];
-extern const char kValidCertificate[];
-extern const char kValidCertificateDescription[];
-extern const char kSecureProtocol[];
-extern const char kSecureProtocolDescription[];
-
-#if defined(ENABLE_PDF_VIEWER)
-// The MIME type used for the PDF plugin.
-extern const char kPdfPluginMimeType[];
-extern const char kPdfPluginPath[];
-extern const char kPdfPluginSrc[];
-
-// Constants for PDF viewer webui.
-extern const char kPdfViewerUIOrigin[];
-extern const char kPdfViewerUIHost[];
-#endif  // defined(ENABLE_PDF_VIEWER)
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_ATOM_CONSTANTS_H_
removed in remote
  base   100644 cb470529340495fe91e08f0f9ab5f20ba250d0a2 atom/common/atom_version.h
  our    100644 65e7d19911559a40b1b258319df5fe0fa180354f atom/common/atom_version.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_ATOM_VERSION_H_
-#define ATOM_COMMON_ATOM_VERSION_H_
-
-#define ATOM_MAJOR_VERSION 4
-#define ATOM_MINOR_VERSION 0
-#define ATOM_PATCH_VERSION 0
-#define ATOM_PRE_RELEASE_VERSION -nightly.20180821
-
-#ifndef ATOM_STRINGIFY
-#define ATOM_STRINGIFY(n) ATOM_STRINGIFY_HELPER(n)
-#define ATOM_STRINGIFY_HELPER(n) #n
-#endif
-
-#ifndef ATOM_PRE_RELEASE_VERSION
-#define ATOM_VERSION_STRING          \
-  ATOM_STRINGIFY(ATOM_MAJOR_VERSION) \
-  "." ATOM_STRINGIFY(ATOM_MINOR_VERSION) "." ATOM_STRINGIFY(ATOM_PATCH_VERSION)
-#else
-#define ATOM_VERSION_STRING                                  \
-  ATOM_STRINGIFY(ATOM_MAJOR_VERSION)                         \
-  "." ATOM_STRINGIFY(ATOM_MINOR_VERSION) "." ATOM_STRINGIFY( \
-      ATOM_PATCH_VERSION) ATOM_STRINGIFY(ATOM_PRE_RELEASE_VERSION)
-#endif
-
-#define ATOM_VERSION "v" ATOM_VERSION_STRING
-
-#endif  // ATOM_COMMON_ATOM_VERSION_H_
removed in remote
  base   100644 8b9b7ef0c826c84b9a2bbe31f6204c620d3e0c5d atom/common/chrome_version.h
  our    100644 35666ab599410942900abd2a7d9ad4b3e5c138af atom/common/chrome_version.h
@@ -1,14 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// This file is generated by script/bootstrap.py, you should never modify it
-// by hand.
-
-#ifndef ATOM_COMMON_CHROME_VERSION_H_
-#define ATOM_COMMON_CHROME_VERSION_H_
-
-#define CHROME_VERSION_STRING "66.0.3359.181"
-#define CHROME_VERSION "v" CHROME_VERSION_STRING
-
-#endif  // ATOM_COMMON_CHROME_VERSION_H_
removed in remote
  base   100644 854fc8778e9c02875db341c8cb809232f53af602 atom/common/common_message_generator.cc
  our    100644 09f5bdcfb02987607ad97fbecb3fbff0ca5404b1 atom/common/common_message_generator.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Get basic type definitions.
-#define IPC_MESSAGE_IMPL
-#include "atom/common/common_message_generator.h"
-
-// Generate constructors.
-#include "ipc/struct_constructor_macros.h"
-
-// must go after struct_contructor_macros
-#include "atom/common/common_message_generator.h"
-
-// Generate destructors.
-#include "ipc/struct_destructor_macros.h"
-
-// must go after struct_destructor_macros
-#include "atom/common/common_message_generator.h"
-
-// Generate param traits write methods.
-#include "ipc/param_traits_write_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
-
-// Generate param traits read methods.
-#include "ipc/param_traits_read_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
-
-// Generate param traits log methods.
-#include "ipc/param_traits_log_macros.h"
-namespace IPC {
-#include "atom/common/common_message_generator.h"
-}  // namespace IPC
\ No newline at end of file
removed in remote
  base   100644 832de1abf739f9e70019d35e8dd44e2f54efdc37 atom/common/common_message_generator.h
  our    100644 7e9cba51d9f7b1b915adc82df5fbadbf314261e8 atom/common/common_message_generator.h
@@ -1,10 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// Multiply-included file, no traditional include guard.
-
-#include "atom/common/api/api_messages.h"
-#include "chrome/common/chrome_utility_printing_messages.h"
-#include "chrome/common/print_messages.h"
-#include "chrome/common/tts_messages.h"
removed in remote
  base   100644 f4f0ff9b7b1631b940218944f47377369e1afb29 atom/common/crash_reporter/crash_reporter.cc
  our    100644 f804f983e59aa49e32e94d901b585c68a4204c9d atom/common/crash_reporter/crash_reporter.cc
@@ -1,127 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-
-#include "atom/browser/browser.h"
-#include "atom/common/atom_version.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_split.h"
-#include "base/threading/thread_restrictions.h"
-#include "content/public/common/content_switches.h"
-
-namespace crash_reporter {
-
-CrashReporter::CrashReporter() {
-  auto* cmd = base::CommandLine::ForCurrentProcess();
-  is_browser_ = cmd->GetSwitchValueASCII(switches::kProcessType).empty();
-}
-
-CrashReporter::~CrashReporter() {}
-
-void CrashReporter::Start(const std::string& product_name,
-                          const std::string& company_name,
-                          const std::string& submit_url,
-                          const base::FilePath& crashes_dir,
-                          bool upload_to_server,
-                          bool skip_system_crash_handler,
-                          const StringMap& extra_parameters) {
-  SetUploadParameters(extra_parameters);
-
-  InitBreakpad(product_name, ATOM_VERSION_STRING, company_name, submit_url,
-               crashes_dir, upload_to_server, skip_system_crash_handler);
-}
-
-void CrashReporter::SetUploadParameters(const StringMap& parameters) {
-  upload_parameters_ = parameters;
-  upload_parameters_["process_type"] = is_browser_ ? "browser" : "renderer";
-
-  // Setting platform dependent parameters.
-  SetUploadParameters();
-}
-
-void CrashReporter::SetUploadToServer(const bool upload_to_server) {}
-
-bool CrashReporter::GetUploadToServer() {
-  return true;
-}
-
-std::vector<CrashReporter::UploadReportResult>
-CrashReporter::GetUploadedReports(const base::FilePath& crashes_dir) {
-  base::ThreadRestrictions::ScopedAllowIO allow_io;
-  std::string file_content;
-  std::vector<CrashReporter::UploadReportResult> result;
-  base::FilePath uploads_path =
-      crashes_dir.Append(FILE_PATH_LITERAL("uploads.log"));
-  if (base::ReadFileToString(uploads_path, &file_content)) {
-    std::vector<std::string> reports = base::SplitString(
-        file_content, "\n", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-    for (const std::string& report : reports) {
-      std::vector<std::string> report_item = base::SplitString(
-          report, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-      int report_time = 0;
-      if (report_item.size() >= 2 &&
-          base::StringToInt(report_item[0], &report_time)) {
-        result.push_back(
-            CrashReporter::UploadReportResult(report_time, report_item[1]));
-      }
-    }
-  }
-  return result;
-}
-
-void CrashReporter::InitBreakpad(const std::string& product_name,
-                                 const std::string& version,
-                                 const std::string& company_name,
-                                 const std::string& submit_url,
-                                 const base::FilePath& crashes_dir,
-                                 bool auto_submit,
-                                 bool skip_system_crash_handler) {}
-
-void CrashReporter::SetUploadParameters() {}
-
-void CrashReporter::AddExtraParameter(const std::string& key,
-                                      const std::string& value) {}
-
-void CrashReporter::RemoveExtraParameter(const std::string& key) {}
-
-std::map<std::string, std::string> CrashReporter::GetParameters() const {
-  return upload_parameters_;
-}
-
-#if defined(OS_MACOSX) && defined(MAS_BUILD)
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  static CrashReporter crash_reporter;
-  return &crash_reporter;
-}
-#endif
-
-void CrashReporter::StartInstance(const mate::Dictionary& options) {
-  auto* reporter = GetInstance();
-  if (!reporter)
-    return;
-
-  std::string product_name;
-  options.Get("productName", &product_name);
-  std::string company_name;
-  options.Get("companyName", &company_name);
-  std::string submit_url;
-  options.Get("submitURL", &submit_url);
-  base::FilePath crashes_dir;
-  options.Get("crashesDirectory", &crashes_dir);
-  StringMap extra_parameters;
-  options.Get("extra", &extra_parameters);
-
-  extra_parameters["_productName"] = product_name;
-  extra_parameters["_companyName"] = company_name;
-
-  reporter->Start(product_name, company_name, submit_url, crashes_dir, true,
-                  false, extra_parameters);
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 eebbe16dca82210c861c5472802f4c56632d1773 atom/common/crash_reporter/crash_reporter.h
  our    100644 99c4c9818d8c41a9e15690bd17379b864953a723 atom/common/crash_reporter/crash_reporter.h
@@ -1,69 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
-
-#include <map>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "native_mate/dictionary.h"
-
-namespace crash_reporter {
-
-class CrashReporter {
- public:
-  typedef std::map<std::string, std::string> StringMap;
-  typedef std::pair<int, std::string> UploadReportResult;  // upload-date, id
-
-  static CrashReporter* GetInstance();
-  static void StartInstance(const mate::Dictionary& options);
-
-  void Start(const std::string& product_name,
-             const std::string& company_name,
-             const std::string& submit_url,
-             const base::FilePath& crashes_dir,
-             bool upload_to_server,
-             bool skip_system_crash_handler,
-             const StringMap& extra_parameters);
-
-  virtual std::vector<CrashReporter::UploadReportResult> GetUploadedReports(
-      const base::FilePath& crashes_dir);
-
-  virtual void SetUploadToServer(bool upload_to_server);
-  virtual bool GetUploadToServer();
-  virtual void AddExtraParameter(const std::string& key,
-                                 const std::string& value);
-  virtual void RemoveExtraParameter(const std::string& key);
-  virtual std::map<std::string, std::string> GetParameters() const;
-
- protected:
-  CrashReporter();
-  virtual ~CrashReporter();
-
-  virtual void InitBreakpad(const std::string& product_name,
-                            const std::string& version,
-                            const std::string& company_name,
-                            const std::string& submit_url,
-                            const base::FilePath& crashes_dir,
-                            bool upload_to_server,
-                            bool skip_system_crash_handler);
-  virtual void SetUploadParameters();
-
-  StringMap upload_parameters_;
-  bool is_browser_;
-
- private:
-  void SetUploadParameters(const StringMap& parameters);
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporter);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
removed in remote
  base   100644 6fe69f486956c129b3c598d9fde96393498f193d atom/common/crash_reporter/crash_reporter_linux.cc
  our    100644 7928c64fb8daccc781ae70ab1acb54f68752a0fe atom/common/crash_reporter/crash_reporter_linux.cc
@@ -1,144 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_linux.h"
-
-#include <sys/time.h>
-#include <unistd.h>
-
-#include <string>
-
-#include "base/debug/crash_logging.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/linux_util.h"
-#include "base/logging.h"
-#include "base/memory/singleton.h"
-#include "base/process/memory.h"
-#include "base/threading/thread_restrictions.h"
-#include "breakpad/src/client/linux/handler/exception_handler.h"
-#include "breakpad/src/common/linux/linux_libc_support.h"
-
-using google_breakpad::ExceptionHandler;
-using google_breakpad::MinidumpDescriptor;
-
-namespace crash_reporter {
-
-namespace {
-
-// Define a preferred limit on minidump sizes, because Crash Server currently
-// throws away any larger than 1.2MB (1.2 * 1024 * 1024).  A value of -1 means
-// no limit.
-static const off_t kMaxMinidumpFileSize = 1258291;
-
-}  // namespace
-
-CrashReporterLinux::CrashReporterLinux() : pid_(getpid()) {
-  // Set the base process start time value.
-  struct timeval tv;
-  if (!gettimeofday(&tv, NULL)) {
-    uint64_t ret = tv.tv_sec;
-    ret *= 1000;
-    ret += tv.tv_usec / 1000;
-    process_start_time_ = ret;
-  }
-
-  // Make base::g_linux_distro work.
-  base::SetLinuxDistro(base::GetLinuxDistro());
-}
-
-CrashReporterLinux::~CrashReporterLinux() {}
-
-void CrashReporterLinux::InitBreakpad(const std::string& product_name,
-                                      const std::string& version,
-                                      const std::string& company_name,
-                                      const std::string& submit_url,
-                                      const base::FilePath& crashes_dir,
-                                      bool upload_to_server,
-                                      bool skip_system_crash_handler) {
-  EnableCrashDumping(crashes_dir);
-
-  crash_keys_.reset(new CrashKeyStorage());
-
-  crash_keys_->SetKeyValue("prod", ATOM_PRODUCT_NAME);
-  crash_keys_->SetKeyValue("ver", version.c_str());
-  upload_url_ = submit_url;
-  upload_to_server_ = upload_to_server;
-
-  for (StringMap::const_iterator iter = upload_parameters_.begin();
-       iter != upload_parameters_.end(); ++iter)
-    crash_keys_->SetKeyValue(iter->first.c_str(), iter->second.c_str());
-}
-
-void CrashReporterLinux::SetUploadParameters() {
-  upload_parameters_["platform"] = "linux";
-}
-
-void CrashReporterLinux::SetUploadToServer(const bool upload_to_server) {
-  upload_to_server_ = upload_to_server;
-}
-
-bool CrashReporterLinux::GetUploadToServer() {
-  return upload_to_server_;
-}
-
-void CrashReporterLinux::EnableCrashDumping(const base::FilePath& crashes_dir) {
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    base::CreateDirectory(crashes_dir);
-  }
-  std::string log_file = crashes_dir.Append("uploads.log").value();
-  strncpy(g_crash_log_path, log_file.c_str(), sizeof(g_crash_log_path));
-
-  MinidumpDescriptor minidump_descriptor(crashes_dir.value());
-  minidump_descriptor.set_size_limit(kMaxMinidumpFileSize);
-
-  breakpad_.reset(new ExceptionHandler(minidump_descriptor, NULL, CrashDone,
-                                       this,
-                                       true,  // Install handlers.
-                                       -1));
-}
-
-bool CrashReporterLinux::CrashDone(const MinidumpDescriptor& minidump,
-                                   void* context,
-                                   const bool succeeded) {
-  CrashReporterLinux* self = static_cast<CrashReporterLinux*>(context);
-
-  // WARNING: this code runs in a compromised context. It may not call into
-  // libc nor allocate memory normally.
-  if (!succeeded) {
-    const char msg[] = "Failed to generate minidump.";
-    WriteLog(msg, sizeof(msg) - 1);
-    return false;
-  }
-
-  DCHECK(!minidump.IsFD());
-
-  BreakpadInfo info = {0};
-  info.filename = minidump.path();
-  info.fd = minidump.fd();
-  info.distro = base::g_linux_distro;
-  info.distro_length = my_strlen(base::g_linux_distro);
-  info.upload = self->upload_to_server_;
-  info.process_start_time = self->process_start_time_;
-  info.oom_size = base::g_oom_size;
-  info.pid = self->pid_;
-  info.upload_url = self->upload_url_.c_str();
-  info.crash_keys = self->crash_keys_.get();
-  HandleCrashDump(info);
-  return true;
-}
-
-// static
-CrashReporterLinux* CrashReporterLinux::GetInstance() {
-  return base::Singleton<CrashReporterLinux>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterLinux::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 165c288ab2b1caeb065e59a6164b50ba701a1d5c atom/common/crash_reporter/crash_reporter_linux.h
  our    100644 ce9d85fa4b8c744ac4be5b14ea89272b1c5ca6c8 atom/common/crash_reporter/crash_reporter_linux.h
@@ -1,66 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
-
-#include <memory>
-#include <string>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "atom/common/crash_reporter/linux/crash_dump_handler.h"
-#include "base/compiler_specific.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace google_breakpad {
-class ExceptionHandler;
-class MinidumpDescriptor;
-}  // namespace google_breakpad
-
-namespace crash_reporter {
-
-class CrashReporterLinux : public CrashReporter {
- public:
-  static CrashReporterLinux* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadToServer(bool upload_to_server) override;
-  void SetUploadParameters() override;
-  bool GetUploadToServer() override;
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterLinux>;
-
-  CrashReporterLinux();
-  ~CrashReporterLinux() override;
-
-  void EnableCrashDumping(const base::FilePath& crashes_dir);
-
-  static bool CrashDone(const google_breakpad::MinidumpDescriptor& minidump,
-                        void* context,
-                        const bool succeeded);
-
-  std::unique_ptr<google_breakpad::ExceptionHandler> breakpad_;
-  std::unique_ptr<CrashKeyStorage> crash_keys_;
-
-  uint64_t process_start_time_ = 0;
-  pid_t pid_ = 0;
-  std::string upload_url_;
-  bool upload_to_server_ = true;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterLinux);
-};
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
removed in remote
  base   100644 f031543591559307420aa08001c5bbf73f53b2cb atom/common/crash_reporter/crash_reporter_mac.h
  our    100644 359875319d6eea5436c805d300eeb4f2dc7533f4 atom/common/crash_reporter/crash_reporter_mac.h
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
-
-#include <map>
-#include <string>
-#include <vector>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "base/compiler_specific.h"
-#include "base/strings/string_piece.h"
-#include "crashpad/client/crash_report_database.h"
-#include "crashpad/client/simple_string_dictionary.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace crash_reporter {
-
-class CrashReporterMac : public CrashReporter {
- public:
-  static CrashReporterMac* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadParameters() override;
-  void SetUploadToServer(bool upload_to_server) override;
-  bool GetUploadToServer() override;
-  void AddExtraParameter(const std::string& key,
-                         const std::string& value) override;
-  void RemoveExtraParameter(const std::string& key) override;
-  std::map<std::string, std::string> GetParameters() const override;
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterMac>;
-
-  CrashReporterMac();
-  ~CrashReporterMac() override;
-
-  void SetUploadsEnabled(bool enable_uploads);
-  void SetCrashKeyValue(const base::StringPiece& key,
-                        const base::StringPiece& value);
-
-  std::vector<UploadReportResult> GetUploadedReports(
-      const base::FilePath& crashes_dir) override;
-
-  std::unique_ptr<crashpad::SimpleStringDictionary> simple_string_dictionary_;
-  std::unique_ptr<crashpad::CrashReportDatabase> database_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterMac);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
removed in remote
  base   100644 130a421665f76b625e71b30374e30ff2d62a3235 atom/common/crash_reporter/crash_reporter_mac.mm
  our    100644 636ce4b065fdbccd50470193e627c8f0ea1e2364 atom/common/crash_reporter/crash_reporter_mac.mm
@@ -1,182 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_mac.h"
-
-#include <memory>
-
-#include "base/files/file_util.h"
-#include "base/mac/bundle_locations.h"
-#include "base/mac/mac_util.h"
-#include "base/memory/singleton.h"
-#include "base/strings/string_piece.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/sys_string_conversions.h"
-#include "base/threading/thread_restrictions.h"
-#include "crashpad/client/crashpad_client.h"
-#include "crashpad/client/crashpad_info.h"
-#include "crashpad/client/settings.h"
-
-namespace crash_reporter {
-
-CrashReporterMac::CrashReporterMac() {}
-
-CrashReporterMac::~CrashReporterMac() {}
-
-void CrashReporterMac::InitBreakpad(const std::string& product_name,
-                                    const std::string& version,
-                                    const std::string& company_name,
-                                    const std::string& submit_url,
-                                    const base::FilePath& crashes_dir,
-                                    bool upload_to_server,
-                                    bool skip_system_crash_handler) {
-  // check whether crashpad has been initialized.
-  // Only need to initialize once.
-  if (simple_string_dictionary_)
-    return;
-
-  if (is_browser_) {
-    @autoreleasepool {
-      base::FilePath framework_bundle_path = base::mac::FrameworkBundlePath();
-      base::FilePath handler_path =
-          framework_bundle_path.Append("Resources").Append("crashpad_handler");
-
-      std::vector<std::string> args = {
-          "--no-rate-limit",
-          "--no-upload-gzip",  // not all servers accept gzip
-      };
-
-      crashpad::CrashpadClient crashpad_client;
-      crashpad_client.StartHandler(handler_path, crashes_dir, crashes_dir,
-                                   submit_url, StringMap(), args, true, false);
-    }  // @autoreleasepool
-  }
-
-  crashpad::CrashpadInfo* crashpad_info =
-      crashpad::CrashpadInfo::GetCrashpadInfo();
-  if (skip_system_crash_handler) {
-    crashpad_info->set_system_crash_reporter_forwarding(
-        crashpad::TriState::kDisabled);
-  }
-
-  simple_string_dictionary_.reset(new crashpad::SimpleStringDictionary());
-  crashpad_info->set_simple_annotations(simple_string_dictionary_.get());
-
-  SetCrashKeyValue("prod", ATOM_PRODUCT_NAME);
-  SetCrashKeyValue("process_type", is_browser_ ? "browser" : "renderer");
-  SetCrashKeyValue("ver", version);
-
-  for (const auto& upload_parameter : upload_parameters_) {
-    SetCrashKeyValue(upload_parameter.first, upload_parameter.second);
-  }
-  if (is_browser_) {
-    database_ = crashpad::CrashReportDatabase::Initialize(crashes_dir);
-    SetUploadToServer(upload_to_server);
-  }
-}
-
-bool CrashReporterMac::GetUploadToServer() {
-  bool enabled = true;
-  if (database_) {
-    database_->GetSettings()->GetUploadsEnabled(&enabled);
-  }
-  return enabled;
-}
-
-void CrashReporterMac::SetUploadToServer(const bool upload_to_server) {
-  if (database_) {
-    database_->GetSettings()->SetUploadsEnabled(upload_to_server);
-  }
-}
-
-void CrashReporterMac::SetUploadParameters() {
-  upload_parameters_["platform"] = "darwin";
-}
-
-void CrashReporterMac::SetCrashKeyValue(const base::StringPiece& key,
-                                        const base::StringPiece& value) {
-  simple_string_dictionary_->SetKeyValue(key.data(), value.data());
-}
-
-void CrashReporterMac::AddExtraParameter(const std::string& key,
-                                         const std::string& value) {
-  if (simple_string_dictionary_) {
-    SetCrashKeyValue(key, value);
-  } else {
-    upload_parameters_[key] = value;
-  }
-}
-
-void CrashReporterMac::RemoveExtraParameter(const std::string& key) {
-  if (simple_string_dictionary_)
-    simple_string_dictionary_->RemoveKey(key.data());
-  else
-    upload_parameters_.erase(key);
-}
-
-std::map<std::string, std::string> CrashReporterMac::GetParameters() const {
-  if (simple_string_dictionary_) {
-    std::map<std::string, std::string> ret;
-    crashpad::SimpleStringDictionary::Iterator iter(*simple_string_dictionary_);
-    for (;;) {
-      auto* const entry = iter.Next();
-      if (!entry)
-        break;
-      ret[entry->key] = entry->value;
-    }
-    return ret;
-  }
-  return upload_parameters_;
-}
-
-std::vector<CrashReporter::UploadReportResult>
-CrashReporterMac::GetUploadedReports(const base::FilePath& crashes_dir) {
-  std::vector<CrashReporter::UploadReportResult> uploaded_reports;
-
-  {
-    base::ThreadRestrictions::ScopedAllowIO allow_io;
-    if (!base::PathExists(crashes_dir)) {
-      return uploaded_reports;
-    }
-  }
-  // Load crashpad database.
-  std::unique_ptr<crashpad::CrashReportDatabase> database =
-      crashpad::CrashReportDatabase::Initialize(crashes_dir);
-  DCHECK(database);
-
-  std::vector<crashpad::CrashReportDatabase::Report> completed_reports;
-  crashpad::CrashReportDatabase::OperationStatus status =
-      database->GetCompletedReports(&completed_reports);
-  if (status != crashpad::CrashReportDatabase::kNoError) {
-    return uploaded_reports;
-  }
-
-  for (const crashpad::CrashReportDatabase::Report& completed_report :
-       completed_reports) {
-    if (completed_report.uploaded) {
-      uploaded_reports.push_back(
-          UploadReportResult(static_cast<int>(completed_report.creation_time),
-                             completed_report.id));
-    }
-  }
-
-  auto sort_by_time = [](const UploadReportResult& a,
-                         const UploadReportResult& b) {
-    return a.first >= b.first;
-  };
-  std::sort(uploaded_reports.begin(), uploaded_reports.end(), sort_by_time);
-  return uploaded_reports;
-}
-
-// static
-CrashReporterMac* CrashReporterMac::GetInstance() {
-  return base::Singleton<CrashReporterMac>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterMac::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 939a02f090c55aed3eb3db1d54e9b16d2ced2814 atom/common/crash_reporter/crash_reporter_win.cc
  our    100644 c574da71c9de9bd8c7b7cad57d3a0f84708fb97c atom/common/crash_reporter/crash_reporter_win.cc
@@ -1,281 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/crash_reporter_win.h"
-
-#include <string>
-
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/memory/singleton.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/common/result_codes.h"
-#include "gin/public/debug.h"
-#include "sandbox/win/src/nt_internals.h"
-
-#pragma intrinsic(_AddressOfReturnAddress)
-#pragma intrinsic(_ReturnAddress)
-
-#ifdef _WIN64
-// See http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx
-typedef struct _UNWIND_INFO {
-  unsigned char Version : 3;
-  unsigned char Flags : 5;
-  unsigned char SizeOfProlog;
-  unsigned char CountOfCodes;
-  unsigned char FrameRegister : 4;
-  unsigned char FrameOffset : 4;
-  ULONG ExceptionHandler;
-} UNWIND_INFO, *PUNWIND_INFO;
-#endif
-
-namespace crash_reporter {
-
-namespace {
-
-// Minidump with stacks, PEB, TEB, and unloaded module list.
-const MINIDUMP_TYPE kSmallDumpType = static_cast<MINIDUMP_TYPE>(
-    MiniDumpWithProcessThreadData |  // Get PEB and TEB.
-    MiniDumpWithUnloadedModules);    // Get unloaded modules when available.
-
-const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
-const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
-
-// Matches breakpad/src/client/windows/common/ipc_protocol.h.
-const int kNameMaxLength = 64;
-const int kValueMaxLength = 64;
-
-typedef NTSTATUS(WINAPI* NtTerminateProcessPtr)(HANDLE ProcessHandle,
-                                                NTSTATUS ExitStatus);
-char* g_real_terminate_process_stub = NULL;
-
-void TerminateProcessWithoutDump() {
-  // Patched stub exists based on conditions (See InitCrashReporter).
-  // As a side note this function also gets called from
-  // WindowProcExceptionFilter.
-  if (g_real_terminate_process_stub == NULL) {
-    ::TerminateProcess(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
-  } else {
-    NtTerminateProcessPtr real_terminate_proc =
-        reinterpret_cast<NtTerminateProcessPtr>(
-            static_cast<char*>(g_real_terminate_process_stub));
-    real_terminate_proc(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
-  }
-}
-
-#ifdef _WIN64
-int CrashForExceptionInNonABICompliantCodeRange(
-    PEXCEPTION_RECORD ExceptionRecord,
-    ULONG64 EstablisherFrame,
-    PCONTEXT ContextRecord,
-    PDISPATCHER_CONTEXT DispatcherContext) {
-  EXCEPTION_POINTERS info = {ExceptionRecord, ContextRecord};
-  if (!CrashReporter::GetInstance())
-    return EXCEPTION_CONTINUE_SEARCH;
-  return static_cast<CrashReporterWin*>(CrashReporter::GetInstance())
-      ->CrashForException(&info);
-}
-
-struct ExceptionHandlerRecord {
-  RUNTIME_FUNCTION runtime_function;
-  UNWIND_INFO unwind_info;
-  unsigned char thunk[12];
-};
-
-bool RegisterNonABICompliantCodeRange(void* start, size_t size_in_bytes) {
-  ExceptionHandlerRecord* record =
-      reinterpret_cast<ExceptionHandlerRecord*>(start);
-
-  // We assume that the first page of the code range is executable and
-  // committed and reserved for breakpad. What could possibly go wrong?
-
-  // All addresses are 32bit relative offsets to start.
-  record->runtime_function.BeginAddress = 0;
-  record->runtime_function.EndAddress =
-      base::checked_cast<DWORD>(size_in_bytes);
-  record->runtime_function.UnwindData =
-      offsetof(ExceptionHandlerRecord, unwind_info);
-
-  // Create unwind info that only specifies an exception handler.
-  record->unwind_info.Version = 1;
-  record->unwind_info.Flags = UNW_FLAG_EHANDLER;
-  record->unwind_info.SizeOfProlog = 0;
-  record->unwind_info.CountOfCodes = 0;
-  record->unwind_info.FrameRegister = 0;
-  record->unwind_info.FrameOffset = 0;
-  record->unwind_info.ExceptionHandler =
-      offsetof(ExceptionHandlerRecord, thunk);
-
-  // Hardcoded thunk.
-  // mov imm64, rax
-  record->thunk[0] = 0x48;
-  record->thunk[1] = 0xb8;
-  void* handler = &CrashForExceptionInNonABICompliantCodeRange;
-  memcpy(&record->thunk[2], &handler, 8);
-
-  // jmp rax
-  record->thunk[10] = 0xff;
-  record->thunk[11] = 0xe0;
-
-  // Protect reserved page against modifications.
-  DWORD old_protect;
-  return VirtualProtect(start, sizeof(ExceptionHandlerRecord),
-                        PAGE_EXECUTE_READ, &old_protect) &&
-         RtlAddFunctionTable(&record->runtime_function, 1,
-                             reinterpret_cast<DWORD64>(start));
-}
-
-void UnregisterNonABICompliantCodeRange(void* start) {
-  ExceptionHandlerRecord* record =
-      reinterpret_cast<ExceptionHandlerRecord*>(start);
-
-  RtlDeleteFunctionTable(&record->runtime_function);
-}
-#endif  // _WIN64
-
-}  // namespace
-
-CrashReporterWin::CrashReporterWin() {}
-
-CrashReporterWin::~CrashReporterWin() {}
-
-void CrashReporterWin::InitBreakpad(const std::string& product_name,
-                                    const std::string& version,
-                                    const std::string& company_name,
-                                    const std::string& submit_url,
-                                    const base::FilePath& crashes_dir,
-                                    bool upload_to_server,
-                                    bool skip_system_crash_handler) {
-  skip_system_crash_handler_ = skip_system_crash_handler;
-
-  base::string16 pipe_name = base::ReplaceStringPlaceholders(
-      kPipeNameFormat, base::UTF8ToUTF16(product_name), NULL);
-  base::string16 wait_name = base::ReplaceStringPlaceholders(
-      kWaitEventFormat, base::UTF8ToUTF16(product_name), NULL);
-
-  // Wait until the crash service is started.
-  HANDLE wait_event = ::CreateEventW(NULL, TRUE, FALSE, wait_name.c_str());
-  if (wait_event != NULL) {
-    WaitForSingleObject(wait_event, 1000);
-    CloseHandle(wait_event);
-  }
-
-  // ExceptionHandler() attaches our handler and ~ExceptionHandler() detaches
-  // it, so we must explicitly reset *before* we instantiate our new handler
-  // to allow any previous handler to detach in the correct order.
-  breakpad_.reset();
-
-  breakpad_.reset(new google_breakpad::ExceptionHandler(
-      crashes_dir.DirName().value(), FilterCallback, MinidumpCallback, this,
-      google_breakpad::ExceptionHandler::HANDLER_ALL, kSmallDumpType,
-      pipe_name.c_str(),
-      GetCustomInfo(product_name, version, company_name, upload_to_server)));
-
-  if (!breakpad_->IsOutOfProcess())
-    LOG(ERROR) << "Cannot initialize out-of-process crash handler";
-
-#ifdef _WIN64
-  // Hook up V8 to breakpad.
-  if (!code_range_registered_) {
-    code_range_registered_ = true;
-    // gin::Debug::SetCodeRangeCreatedCallback only runs the callback when
-    // Isolate is just created, so we have to manually run following code here.
-    void* code_range = nullptr;
-    size_t size = 0;
-    v8::Isolate::GetCurrent()->GetCodeRange(&code_range, &size);
-    if (code_range && size &&
-        RegisterNonABICompliantCodeRange(code_range, size)) {
-      gin::Debug::SetCodeRangeDeletedCallback(
-          UnregisterNonABICompliantCodeRange);
-    }
-  }
-#endif
-}
-
-void CrashReporterWin::SetUploadParameters() {
-  upload_parameters_["platform"] = "win32";
-}
-
-int CrashReporterWin::CrashForException(EXCEPTION_POINTERS* info) {
-  if (breakpad_) {
-    breakpad_->WriteMinidumpForException(info);
-    if (skip_system_crash_handler_)
-      TerminateProcessWithoutDump();
-    else
-      RaiseFailFastException(info->ExceptionRecord, info->ContextRecord, 0);
-  }
-  return EXCEPTION_CONTINUE_SEARCH;
-}
-
-// static
-bool CrashReporterWin::FilterCallback(void* context,
-                                      EXCEPTION_POINTERS* exinfo,
-                                      MDRawAssertionInfo* assertion) {
-  return true;
-}
-
-// static
-bool CrashReporterWin::MinidumpCallback(const wchar_t* dump_path,
-                                        const wchar_t* minidump_id,
-                                        void* context,
-                                        EXCEPTION_POINTERS* exinfo,
-                                        MDRawAssertionInfo* assertion,
-                                        bool succeeded) {
-  CrashReporterWin* self = static_cast<CrashReporterWin*>(context);
-  if (succeeded && self->skip_system_crash_handler_)
-    return true;
-  else
-    return false;
-}
-
-google_breakpad::CustomClientInfo* CrashReporterWin::GetCustomInfo(
-    const std::string& product_name,
-    const std::string& version,
-    const std::string& company_name,
-    bool upload_to_server) {
-  custom_info_entries_.clear();
-  custom_info_entries_.reserve(3 + upload_parameters_.size());
-
-  custom_info_entries_.push_back(
-      google_breakpad::CustomInfoEntry(L"prod", L"Electron"));
-  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
-      L"ver", base::UTF8ToWide(version).c_str()));
-  if (!upload_to_server) {
-    custom_info_entries_.push_back(
-        google_breakpad::CustomInfoEntry(L"skip_upload", L"1"));
-  }
-
-  for (StringMap::const_iterator iter = upload_parameters_.begin();
-       iter != upload_parameters_.end(); ++iter) {
-    // breakpad has hardcoded the length of name/value, and doesn't truncate
-    // the values itself, so we have to truncate them here otherwise weird
-    // things may happen.
-    std::wstring name = base::UTF8ToWide(iter->first);
-    std::wstring value = base::UTF8ToWide(iter->second);
-    if (name.length() > kNameMaxLength - 1)
-      name.resize(kNameMaxLength - 1);
-    if (value.length() > kValueMaxLength - 1)
-      value.resize(kValueMaxLength - 1);
-
-    custom_info_entries_.push_back(
-        google_breakpad::CustomInfoEntry(name.c_str(), value.c_str()));
-  }
-
-  custom_info_.entries = &custom_info_entries_.front();
-  custom_info_.count = custom_info_entries_.size();
-  return &custom_info_;
-}
-
-// static
-CrashReporterWin* CrashReporterWin::GetInstance() {
-  return base::Singleton<CrashReporterWin>::get();
-}
-
-// static
-CrashReporter* CrashReporter::GetInstance() {
-  return CrashReporterWin::GetInstance();
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 181c9eabd23cf61719beb20484977f9ac5daaa21 atom/common/crash_reporter/crash_reporter_win.h
  our    100644 89a2a5966d6caf3c13643065ef084e98b69efcaf atom/common/crash_reporter/crash_reporter_win.h
@@ -1,78 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
-#define ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "atom/common/crash_reporter/crash_reporter.h"
-#include "base/compiler_specific.h"
-#include "breakpad/src/client/windows/handler/exception_handler.h"
-
-namespace base {
-template <typename T>
-struct DefaultSingletonTraits;
-}
-
-namespace crash_reporter {
-
-class CrashReporterWin : public CrashReporter {
- public:
-  static CrashReporterWin* GetInstance();
-
-  void InitBreakpad(const std::string& product_name,
-                    const std::string& version,
-                    const std::string& company_name,
-                    const std::string& submit_url,
-                    const base::FilePath& crashes_dir,
-                    bool upload_to_server,
-                    bool skip_system_crash_handler) override;
-  void SetUploadParameters() override;
-
-  // Crashes the process after generating a dump for the provided exception.
-  int CrashForException(EXCEPTION_POINTERS* info);
-
- private:
-  friend struct base::DefaultSingletonTraits<CrashReporterWin>;
-
-  CrashReporterWin();
-  ~CrashReporterWin() override;
-
-  static bool FilterCallback(void* context,
-                             EXCEPTION_POINTERS* exinfo,
-                             MDRawAssertionInfo* assertion);
-
-  static bool MinidumpCallback(const wchar_t* dump_path,
-                               const wchar_t* minidump_id,
-                               void* context,
-                               EXCEPTION_POINTERS* exinfo,
-                               MDRawAssertionInfo* assertion,
-                               bool succeeded);
-
-  // Returns the custom info structure based on parameters.
-  google_breakpad::CustomClientInfo* GetCustomInfo(
-      const std::string& product_name,
-      const std::string& version,
-      const std::string& company_name,
-      bool upload_to_server);
-
-  // Custom information to be passed to crash handler.
-  std::vector<google_breakpad::CustomInfoEntry> custom_info_entries_;
-  google_breakpad::CustomClientInfo custom_info_;
-
-  bool skip_system_crash_handler_ = false;
-#ifdef _WIN64
-  bool code_range_registered_ = false;
-#endif
-  std::unique_ptr<google_breakpad::ExceptionHandler> breakpad_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashReporterWin);
-};
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
removed in remote
  base   100644 56a5e094d446315fbc5565b115e84b775f433c88 atom/common/crash_reporter/linux/crash_dump_handler.cc
  our    100644 8b0e3de5cecdda5c97237ebd5d6e0bbbd99a280b atom/common/crash_reporter/linux/crash_dump_handler.cc
@@ -1,753 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-// For linux_syscall_support.h. This makes it safe to call embedded system
-// calls when in seccomp mode.
-
-#include "atom/common/crash_reporter/linux/crash_dump_handler.h"
-
-#include <poll.h>
-
-#include <algorithm>
-
-#include "base/posix/eintr_wrapper.h"
-#include "breakpad/src/client/linux/minidump_writer/directory_reader.h"
-#include "breakpad/src/common/linux/linux_libc_support.h"
-#include "breakpad/src/common/memory_allocator.h"
-
-#include "third_party/lss/linux_syscall_support.h"
-
-// Some versions of gcc are prone to warn about unused return values. In cases
-// where we either a) know the call cannot fail, or b) there is nothing we
-// can do when a call fails, we mark the return code as ignored. This avoids
-// spurious compiler warnings.
-#define IGNORE_RET(x) \
-  do {                \
-    if (x)            \
-      ;               \
-  } while (0)
-
-namespace crash_reporter {
-
-namespace {
-
-// String buffer size to use to convert a uint64_t to string.
-const size_t kUint64StringSize = 21;
-
-// Writes the value |v| as 16 hex characters to the memory pointed at by
-// |output|.
-void write_uint64_hex(char* output, uint64_t v) {
-  static const char hextable[] = "0123456789abcdef";
-
-  for (int i = 15; i >= 0; --i) {
-    output[i] = hextable[v & 15];
-    v >>= 4;
-  }
-}
-
-// uint64_t version of my_int_len() from
-// breakpad/src/common/linux/linux_libc_support.h. Return the length of the
-// given, non-negative integer when expressed in base 10.
-unsigned my_uint64_len(uint64_t i) {
-  if (!i)
-    return 1;
-
-  unsigned len = 0;
-  while (i) {
-    len++;
-    i /= 10;
-  }
-
-  return len;
-}
-
-// uint64_t version of my_uitos() from
-// breakpad/src/common/linux/linux_libc_support.h. Convert a non-negative
-// integer to a string (not null-terminated).
-void my_uint64tos(char* output, uint64_t i, unsigned i_len) {
-  for (unsigned index = i_len; index; --index, i /= 10)
-    output[index - 1] = '0' + (i % 10);
-}
-
-// Converts a struct timeval to milliseconds.
-uint64_t kernel_timeval_to_ms(struct kernel_timeval* tv) {
-  uint64_t ret = tv->tv_sec;  // Avoid overflow by explicitly using a uint64_t.
-  ret *= 1000;
-  ret += tv->tv_usec / 1000;
-  return ret;
-}
-
-bool my_isxdigit(char c) {
-  return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f');
-}
-
-size_t LengthWithoutTrailingSpaces(const char* str, size_t len) {
-  while (len > 0 && str[len - 1] == ' ') {
-    len--;
-  }
-  return len;
-}
-
-// MIME substrings.
-const char g_rn[] = "\r\n";
-const char g_form_data_msg[] = "Content-Disposition: form-data; name=\"";
-const char g_quote_msg[] = "\"";
-const char g_dashdash_msg[] = "--";
-const char g_dump_msg[] = "upload_file_minidump\"; filename=\"dump\"";
-const char g_content_type_msg[] = "Content-Type: application/octet-stream";
-
-// MimeWriter manages an iovec for writing MIMEs to a file.
-class MimeWriter {
- public:
-  static const int kIovCapacity = 30;
-  static const size_t kMaxCrashChunkSize = 64;
-
-  MimeWriter(int fd, const char* const mime_boundary);
-  ~MimeWriter();
-
-  // Append boundary.
-  virtual void AddBoundary();
-
-  // Append end of file boundary.
-  virtual void AddEnd();
-
-  // Append key/value pair with specified sizes.
-  virtual void AddPairData(const char* msg_type,
-                           size_t msg_type_size,
-                           const char* msg_data,
-                           size_t msg_data_size);
-
-  // Append key/value pair.
-  void AddPairString(const char* msg_type, const char* msg_data) {
-    AddPairData(msg_type, my_strlen(msg_type), msg_data, my_strlen(msg_data));
-  }
-
-  // Append key/value pair, splitting value into chunks no larger than
-  // |chunk_size|. |chunk_size| cannot be greater than |kMaxCrashChunkSize|.
-  // The msg_type string will have a counter suffix to distinguish each chunk.
-  virtual void AddPairDataInChunks(const char* msg_type,
-                                   size_t msg_type_size,
-                                   const char* msg_data,
-                                   size_t msg_data_size,
-                                   size_t chunk_size,
-                                   bool strip_trailing_spaces);
-
-  // Add binary file contents to be uploaded with the specified filename.
-  virtual void AddFileContents(const char* filename_msg,
-                               uint8_t* file_data,
-                               size_t file_size);
-
-  // Flush any pending iovecs to the output file.
-  void Flush() {
-    IGNORE_RET(sys_writev(fd_, iov_, iov_index_));
-    iov_index_ = 0;
-  }
-
- protected:
-  void AddItem(const void* base, size_t size);
-  // Minor performance trade-off for easier-to-maintain code.
-  void AddString(const char* str) { AddItem(str, my_strlen(str)); }
-  void AddItemWithoutTrailingSpaces(const void* base, size_t size);
-
-  struct kernel_iovec iov_[kIovCapacity];
-  int iov_index_ = 0;
-
-  // Output file descriptor.
-  int fd_ = -1;
-
-  const char* const mime_boundary_;
-
- private:
-  DISALLOW_COPY_AND_ASSIGN(MimeWriter);
-};
-
-MimeWriter::MimeWriter(int fd, const char* const mime_boundary)
-    : fd_(fd), mime_boundary_(mime_boundary) {}
-
-MimeWriter::~MimeWriter() {}
-
-void MimeWriter::AddBoundary() {
-  AddString(mime_boundary_);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddEnd() {
-  AddString(mime_boundary_);
-  AddString(g_dashdash_msg);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddPairData(const char* msg_type,
-                             size_t msg_type_size,
-                             const char* msg_data,
-                             size_t msg_data_size) {
-  AddString(g_form_data_msg);
-  AddItem(msg_type, msg_type_size);
-  AddString(g_quote_msg);
-  AddString(g_rn);
-  AddString(g_rn);
-  AddItem(msg_data, msg_data_size);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddPairDataInChunks(const char* msg_type,
-                                     size_t msg_type_size,
-                                     const char* msg_data,
-                                     size_t msg_data_size,
-                                     size_t chunk_size,
-                                     bool strip_trailing_spaces) {
-  if (chunk_size > kMaxCrashChunkSize)
-    return;
-
-  unsigned i = 0;
-  size_t done = 0, msg_length = msg_data_size;
-
-  while (msg_length) {
-    char num[kUint64StringSize];
-    const unsigned num_len = my_uint_len(++i);
-    my_uitos(num, i, num_len);
-
-    size_t chunk_len = std::min(chunk_size, msg_length);
-
-    AddString(g_form_data_msg);
-    AddItem(msg_type, msg_type_size);
-    AddItem(num, num_len);
-    AddString(g_quote_msg);
-    AddString(g_rn);
-    AddString(g_rn);
-    if (strip_trailing_spaces) {
-      AddItemWithoutTrailingSpaces(msg_data + done, chunk_len);
-    } else {
-      AddItem(msg_data + done, chunk_len);
-    }
-    AddString(g_rn);
-    AddBoundary();
-    Flush();
-
-    done += chunk_len;
-    msg_length -= chunk_len;
-  }
-}
-
-void MimeWriter::AddFileContents(const char* filename_msg,
-                                 uint8_t* file_data,
-                                 size_t file_size) {
-  AddString(g_form_data_msg);
-  AddString(filename_msg);
-  AddString(g_rn);
-  AddString(g_content_type_msg);
-  AddString(g_rn);
-  AddString(g_rn);
-  AddItem(file_data, file_size);
-  AddString(g_rn);
-}
-
-void MimeWriter::AddItem(const void* base, size_t size) {
-  // Check if the iovec is full and needs to be flushed to output file.
-  if (iov_index_ == kIovCapacity) {
-    Flush();
-  }
-  iov_[iov_index_].iov_base = const_cast<void*>(base);
-  iov_[iov_index_].iov_len = size;
-  ++iov_index_;
-}
-
-void MimeWriter::AddItemWithoutTrailingSpaces(const void* base, size_t size) {
-  AddItem(base,
-          LengthWithoutTrailingSpaces(static_cast<const char*>(base), size));
-}
-
-void LoadDataFromFD(google_breakpad::PageAllocator* allocator,
-                    int fd,
-                    bool close_fd,
-                    uint8_t** file_data,
-                    size_t* size) {
-  struct kernel_stat st;
-  if (sys_fstat(fd, &st) != 0) {
-    static const char msg[] = "Cannot upload crash dump: stat failed\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-
-  *file_data = reinterpret_cast<uint8_t*>(allocator->Alloc(st.st_size));
-  if (!(*file_data)) {
-    static const char msg[] = "Cannot upload crash dump: cannot alloc\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-  my_memset(*file_data, 0xf, st.st_size);
-
-  *size = st.st_size;
-  int byte_read = sys_read(fd, *file_data, *size);
-  if (byte_read == -1) {
-    static const char msg[] = "Cannot upload crash dump: read failed\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    if (close_fd)
-      IGNORE_RET(sys_close(fd));
-    return;
-  }
-
-  if (close_fd)
-    IGNORE_RET(sys_close(fd));
-}
-
-void LoadDataFromFile(google_breakpad::PageAllocator* allocator,
-                      const char* filename,
-                      int* fd,
-                      uint8_t** file_data,
-                      size_t* size) {
-  // WARNING: this code runs in a compromised context. It may not call into
-  // libc nor allocate memory normally.
-  *fd = sys_open(filename, O_RDONLY, 0);
-  *size = 0;
-
-  if (*fd < 0) {
-    static const char msg[] = "Cannot upload crash dump: failed to open\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    return;
-  }
-
-  LoadDataFromFD(allocator, *fd, true, file_data, size);
-}
-
-// Spawn the appropriate upload process for the current OS:
-// - generic Linux invokes wget.
-// - ChromeOS invokes crash_reporter.
-// |dumpfile| is the path to the dump data file.
-// |mime_boundary| is only used on Linux.
-// |exe_buf| is only used on CrOS and is the crashing process' name.
-void ExecUploadProcessOrTerminate(const BreakpadInfo& info,
-                                  const char* dumpfile,
-                                  const char* mime_boundary,
-                                  const char* exe_buf,
-                                  google_breakpad::PageAllocator* allocator) {
-  // The --header argument to wget looks like:
-  //   --header=Content-Type: multipart/form-data; boundary=XYZ
-  // where the boundary has two fewer leading '-' chars
-  static const char header_msg[] =
-      "--header=Content-Type: multipart/form-data; boundary=";
-  char* const header = reinterpret_cast<char*>(
-      allocator->Alloc(sizeof(header_msg) - 1 + strlen(mime_boundary) - 2 + 1));
-  memcpy(header, header_msg, sizeof(header_msg) - 1);
-  memcpy(header + sizeof(header_msg) - 1, mime_boundary + 2,
-         strlen(mime_boundary) - 2);
-  // We grab the NUL byte from the end of |mime_boundary|.
-
-  // The --post-file argument to wget looks like:
-  //   --post-file=/tmp/...
-  static const char post_file_msg[] = "--post-file=";
-  char* const post_file = reinterpret_cast<char*>(
-      allocator->Alloc(sizeof(post_file_msg) - 1 + strlen(dumpfile) + 1));
-  memcpy(post_file, post_file_msg, sizeof(post_file_msg) - 1);
-  memcpy(post_file + sizeof(post_file_msg) - 1, dumpfile, strlen(dumpfile));
-
-  static const char kWgetBinary[] = "/usr/bin/wget";
-  const char* args[] = {
-      kWgetBinary,    header, post_file, info.upload_url,
-      "--timeout=60",  // Set a timeout so we don't hang forever.
-      "--tries=1",     // Don't retry if the upload fails.
-      "--quiet",       // Be silent.
-      "-O",            // output reply to /dev/null.
-      "/dev/fd/3",    NULL,
-  };
-  static const char msg[] =
-      "Cannot upload crash dump: cannot exec "
-      "/usr/bin/wget\n";
-  execve(args[0], const_cast<char**>(args), environ);
-  WriteLog(msg, sizeof(msg) - 1);
-  sys__exit(1);
-}
-
-// Runs in the helper process to wait for the upload process running
-// ExecUploadProcessOrTerminate() to finish. Returns the number of bytes written
-// to |fd| and save the written contents to |buf|.
-// |buf| needs to be big enough to hold |bytes_to_read| + 1 characters.
-size_t WaitForCrashReportUploadProcess(int fd,
-                                       size_t bytes_to_read,
-                                       char* buf) {
-  size_t bytes_read = 0;
-
-  // Upload should finish in about 10 seconds. Add a few more 500 ms
-  // internals to account for process startup time.
-  for (size_t wait_count = 0; wait_count < 24; ++wait_count) {
-    struct kernel_pollfd poll_fd;
-    poll_fd.fd = fd;
-    poll_fd.events = POLLIN | POLLPRI | POLLERR;
-    int ret = sys_poll(&poll_fd, 1, 500);
-    if (ret < 0) {
-      // Error
-      break;
-    } else if (ret > 0) {
-      // There is data to read.
-      ssize_t len = HANDLE_EINTR(
-          sys_read(fd, buf + bytes_read, bytes_to_read - bytes_read));
-      if (len < 0)
-        break;
-      bytes_read += len;
-      if (bytes_read == bytes_to_read)
-        break;
-    }
-    // |ret| == 0 -> timed out, continue waiting.
-    // or |bytes_read| < |bytes_to_read| still, keep reading.
-  }
-  buf[bytes_to_read] = 0;  // Always NUL terminate the buffer.
-  return bytes_read;
-}
-
-// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
-bool IsValidCrashReportId(const char* buf,
-                          size_t bytes_read,
-                          size_t expected_len) {
-  if (bytes_read != expected_len)
-    return false;
-  for (size_t i = 0; i < bytes_read; ++i) {
-    if (!my_isxdigit(buf[i]) && buf[i] != '-')
-      return false;
-  }
-  return true;
-}
-
-// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
-void HandleCrashReportId(const char* buf,
-                         size_t bytes_read,
-                         size_t expected_len) {
-  if (!IsValidCrashReportId(buf, bytes_read, expected_len)) {
-    static const char msg[] = "Failed to get crash dump id.";
-    WriteLog(msg, sizeof(msg) - 1);
-    WriteNewline();
-
-    static const char id_msg[] = "Report Id: ";
-    WriteLog(id_msg, sizeof(id_msg) - 1);
-    WriteLog(buf, bytes_read);
-    WriteNewline();
-    return;
-  }
-
-  // Write crash dump id to stderr.
-  static const char msg[] = "Crash dump id: ";
-  WriteLog(msg, sizeof(msg) - 1);
-  WriteLog(buf, my_strlen(buf));
-  WriteNewline();
-
-  // Write crash dump id to crash log as: seconds_since_epoch,crash_id
-  struct kernel_timeval tv;
-  if (!sys_gettimeofday(&tv, NULL)) {
-    uint64_t time = kernel_timeval_to_ms(&tv) / 1000;
-    char time_str[kUint64StringSize];
-    const unsigned time_len = my_uint64_len(time);
-    my_uint64tos(time_str, time, time_len);
-
-    const int kLogOpenFlags = O_CREAT | O_WRONLY | O_APPEND | O_CLOEXEC;
-    int log_fd = sys_open(g_crash_log_path, kLogOpenFlags, 0600);
-    if (log_fd > 0) {
-      sys_write(log_fd, time_str, time_len);
-      sys_write(log_fd, ",", 1);
-      sys_write(log_fd, buf, my_strlen(buf));
-      sys_write(log_fd, "\n", 1);
-      IGNORE_RET(sys_close(log_fd));
-    }
-  }
-}
-
-}  // namespace
-
-char g_crash_log_path[256];
-
-void HandleCrashDump(const BreakpadInfo& info) {
-  int dumpfd;
-  bool keep_fd = false;
-  size_t dump_size;
-  uint8_t* dump_data;
-  google_breakpad::PageAllocator allocator;
-  const char* exe_buf = NULL;
-
-  if (info.fd != -1) {
-    // Dump is provided with an open FD.
-    keep_fd = true;
-    dumpfd = info.fd;
-
-    // The FD is pointing to the end of the file.
-    // Rewind, we'll read the data next.
-    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
-      static const char msg[] =
-          "Cannot upload crash dump: failed to "
-          "reposition minidump FD\n";
-      WriteLog(msg, sizeof(msg) - 1);
-      IGNORE_RET(sys_close(dumpfd));
-      return;
-    }
-    LoadDataFromFD(&allocator, info.fd, false, &dump_data, &dump_size);
-  } else {
-    // Dump is provided with a path.
-    keep_fd = false;
-    LoadDataFromFile(&allocator, info.filename, &dumpfd, &dump_data,
-                     &dump_size);
-  }
-
-  // We need to build a MIME block for uploading to the server. Since we are
-  // going to fork and run wget, it needs to be written to a temp file.
-  const int ufd = sys_open("/dev/urandom", O_RDONLY, 0);
-  if (ufd < 0) {
-    static const char msg[] =
-        "Cannot upload crash dump because /dev/urandom"
-        " is missing\n";
-    WriteLog(msg, sizeof(msg) - 1);
-    return;
-  }
-
-  static const char temp_file_template[] =
-      "/tmp/chromium-upload-XXXXXXXXXXXXXXXX";
-  char temp_file[sizeof(temp_file_template)];
-  int temp_file_fd = -1;
-  if (keep_fd) {
-    temp_file_fd = dumpfd;
-    // Rewind the destination, we are going to overwrite it.
-    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
-      static const char msg[] =
-          "Cannot upload crash dump: failed to "
-          "reposition minidump FD (2)\n";
-      WriteLog(msg, sizeof(msg) - 1);
-      IGNORE_RET(sys_close(dumpfd));
-      return;
-    }
-  } else {
-    if (info.upload) {
-      memcpy(temp_file, temp_file_template, sizeof(temp_file_template));
-
-      for (unsigned i = 0; i < 10; ++i) {
-        uint64_t t;
-        sys_read(ufd, &t, sizeof(t));
-        write_uint64_hex(temp_file + sizeof(temp_file) - (16 + 1), t);
-
-        temp_file_fd = sys_open(temp_file, O_WRONLY | O_CREAT | O_EXCL, 0600);
-        if (temp_file_fd >= 0)
-          break;
-      }
-
-      if (temp_file_fd < 0) {
-        static const char msg[] =
-            "Failed to create temporary file in /tmp: "
-            "cannot upload crash dump\n";
-        WriteLog(msg, sizeof(msg) - 1);
-        IGNORE_RET(sys_close(ufd));
-        return;
-      }
-    } else {
-      temp_file_fd = sys_open(info.filename, O_WRONLY, 0600);
-      if (temp_file_fd < 0) {
-        static const char msg[] = "Failed to save crash dump: failed to open\n";
-        WriteLog(msg, sizeof(msg) - 1);
-        IGNORE_RET(sys_close(ufd));
-        return;
-      }
-    }
-  }
-
-  // The MIME boundary is 28 hyphens, followed by a 64-bit nonce and a NUL.
-  char mime_boundary[28 + 16 + 1];
-  my_memset(mime_boundary, '-', 28);
-  uint64_t boundary_rand;
-  sys_read(ufd, &boundary_rand, sizeof(boundary_rand));
-  write_uint64_hex(mime_boundary + 28, boundary_rand);
-  mime_boundary[28 + 16] = 0;
-  IGNORE_RET(sys_close(ufd));
-
-  // The MIME block looks like this:
-  //   BOUNDARY \r\n
-  //   Content-Disposition: form-data; name="prod" \r\n \r\n
-  //   Chrome_Linux \r\n
-  //   BOUNDARY \r\n
-  //   Content-Disposition: form-data; name="ver" \r\n \r\n
-  //   1.2.3.4 \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="ptime" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="ptype" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="lsb-release" \r\n \r\n
-  //   abcdef \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or one:
-  //   Content-Disposition: form-data; name="oom-size" \r\n \r\n
-  //   1234567890 \r\n
-  //   BOUNDARY \r\n
-  //
-  //   zero or more (up to CrashKeyStorage::num_entries = 64):
-  //   Content-Disposition: form-data; name=crash-key-name \r\n
-  //   crash-key-value \r\n
-  //   BOUNDARY \r\n
-  //
-  //   Content-Disposition: form-data; name="dump"; filename="dump" \r\n
-  //   Content-Type: application/octet-stream \r\n \r\n
-  //   <dump contents>
-  //   \r\n BOUNDARY -- \r\n
-
-  MimeWriter writer(temp_file_fd, mime_boundary);
-  {
-    writer.AddBoundary();
-    if (info.pid > 0) {
-      char pid_value_buf[kUint64StringSize];
-      uint64_t pid_value_len = my_uint64_len(info.pid);
-      my_uint64tos(pid_value_buf, info.pid, pid_value_len);
-      static const char pid_key_name[] = "pid";
-      writer.AddPairData(pid_key_name, sizeof(pid_key_name) - 1, pid_value_buf,
-                         pid_value_len);
-      writer.AddBoundary();
-    }
-    writer.Flush();
-  }
-
-  if (info.process_start_time > 0) {
-    struct kernel_timeval tv;
-    if (!sys_gettimeofday(&tv, NULL)) {
-      uint64_t time = kernel_timeval_to_ms(&tv);
-      if (time > info.process_start_time) {
-        time -= info.process_start_time;
-        char time_str[kUint64StringSize];
-        const unsigned time_len = my_uint64_len(time);
-        my_uint64tos(time_str, time, time_len);
-
-        static const char process_time_msg[] = "ptime";
-        writer.AddPairData(process_time_msg, sizeof(process_time_msg) - 1,
-                           time_str, time_len);
-        writer.AddBoundary();
-        writer.Flush();
-      }
-    }
-  }
-
-  if (info.distro_length) {
-    static const char distro_msg[] = "lsb-release";
-    writer.AddPairString(distro_msg, info.distro);
-    writer.AddBoundary();
-    writer.Flush();
-  }
-
-  if (info.oom_size) {
-    char oom_size_str[kUint64StringSize];
-    const unsigned oom_size_len = my_uint64_len(info.oom_size);
-    my_uint64tos(oom_size_str, info.oom_size, oom_size_len);
-    static const char oom_size_msg[] = "oom-size";
-    writer.AddPairData(oom_size_msg, sizeof(oom_size_msg) - 1, oom_size_str,
-                       oom_size_len);
-    writer.AddBoundary();
-    writer.Flush();
-  }
-
-  if (info.crash_keys) {
-    CrashKeyStorage::Iterator crash_key_iterator(*info.crash_keys);
-    const CrashKeyStorage::Entry* entry;
-    while ((entry = crash_key_iterator.Next())) {
-      writer.AddPairString(entry->key, entry->value);
-      writer.AddBoundary();
-      writer.Flush();
-    }
-  }
-
-  writer.AddFileContents(g_dump_msg, dump_data, dump_size);
-  writer.AddEnd();
-  writer.Flush();
-
-  IGNORE_RET(sys_close(temp_file_fd));
-
-  if (!info.upload)
-    return;
-
-  const pid_t child = sys_fork();
-  if (!child) {
-    // Spawned helper process.
-    //
-    // This code is called both when a browser is crashing (in which case,
-    // nothing really matters any more) and when a renderer/plugin crashes, in
-    // which case we need to continue.
-    //
-    // Since we are a multithreaded app, if we were just to fork(), we might
-    // grab file descriptors which have just been created in another thread and
-    // hold them open for too long.
-    //
-    // Thus, we have to loop and try and close everything.
-    const int fd = sys_open("/proc/self/fd", O_DIRECTORY | O_RDONLY, 0);
-    if (fd < 0) {
-      for (unsigned i = 3; i < 8192; ++i)
-        IGNORE_RET(sys_close(i));
-    } else {
-      google_breakpad::DirectoryReader reader(fd);
-      const char* name;
-      while (reader.GetNextEntry(&name)) {
-        int i;
-        if (my_strtoui(&i, name) && i > 2 && i != fd)
-          IGNORE_RET(sys_close(i));
-        reader.PopEntry();
-      }
-
-      IGNORE_RET(sys_close(fd));
-    }
-
-    IGNORE_RET(sys_setsid());
-
-    // Leave one end of a pipe in the upload process and watch for it getting
-    // closed by the upload process exiting.
-    int fds[2];
-    if (sys_pipe(fds) >= 0) {
-      const pid_t upload_child = sys_fork();
-      if (!upload_child) {
-        // Upload process.
-        IGNORE_RET(sys_close(fds[0]));
-        IGNORE_RET(sys_dup2(fds[1], 3));
-        ExecUploadProcessOrTerminate(info, temp_file, mime_boundary, exe_buf,
-                                     &allocator);
-      }
-
-      // Helper process.
-      if (upload_child > 0) {
-        IGNORE_RET(sys_close(fds[1]));
-
-        const size_t kCrashIdLength = 36;
-        char id_buf[kCrashIdLength + 1];
-        size_t bytes_read =
-            WaitForCrashReportUploadProcess(fds[0], kCrashIdLength, id_buf);
-        HandleCrashReportId(id_buf, bytes_read, kCrashIdLength);
-
-        if (sys_waitpid(upload_child, NULL, WNOHANG) == 0) {
-          // Upload process is still around, kill it.
-          sys_kill(upload_child, SIGKILL);
-        }
-      }
-    }
-
-    // Helper process.
-    IGNORE_RET(sys_unlink(info.filename));
-    IGNORE_RET(sys_unlink(temp_file));
-    sys__exit(0);
-  }
-
-  // Main browser process.
-  if (child <= 0)
-    return;
-  (void)HANDLE_EINTR(sys_waitpid(child, NULL, 0));
-}
-
-size_t WriteLog(const char* buf, size_t nbytes) {
-  return sys_write(2, buf, nbytes);
-}
-
-size_t WriteNewline() {
-  return WriteLog("\n", 1);
-}
-
-}  // namespace crash_reporter
removed in remote
  base   100644 f10c5212254ea0bcc4cd9deb9764f42fe9e4ceea atom/common/crash_reporter/linux/crash_dump_handler.h
  our    100644 99843c39fdfd011804b9b50a11232cfa8567228e atom/common/crash_reporter/linux/crash_dump_handler.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Copyright (c) 2013 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
-#define ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
-
-#include <stddef.h>
-#include <stdint.h>
-#include <sys/types.h>
-
-#include "base/macros.h"
-#include "breakpad/src/common/simple_string_dictionary.h"
-
-namespace crash_reporter {
-
-typedef google_breakpad::NonAllocatingMap<256, 256, 64> CrashKeyStorage;
-
-// BreakpadInfo describes a crash report.
-// The minidump information can either be contained in a file descriptor (fd) or
-// in a file (whose path is in filename).
-struct BreakpadInfo {
-  int fd;                       // File descriptor to the Breakpad dump data.
-  const char* filename;         // Path to the Breakpad dump data.
-  const char* distro;           // Linux distro string.
-  unsigned distro_length;       // Length of |distro|.
-  bool upload;                  // Whether to upload or save crash dump.
-  uint64_t process_start_time;  // Uptime of the crashing process.
-  size_t oom_size;              // Amount of memory requested if OOM.
-  uint64_t pid;                 // PID where applicable.
-  const char* upload_url;       // URL to upload the minidump.
-  CrashKeyStorage* crash_keys;
-};
-
-void HandleCrashDump(const BreakpadInfo& info);
-
-size_t WriteLog(const char* buf, size_t nbytes);
-size_t WriteNewline();
-
-// Global variable storing the path of upload log.
-extern char g_crash_log_path[256];
-
-}  // namespace crash_reporter
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
removed in remote
  base   100644 58c7c38632ed1bbe2a868a460c3b90af9fa5694b atom/common/crash_reporter/win/crash_service.cc
  our    100644 d13111f495be844df10deebacd572560021bbb4e atom/common/crash_reporter/win/crash_service.cc
@@ -1,507 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/win/crash_service.h"
-
-#include <windows.h>
-
-#include <sddl.h>
-#include <fstream>  // NOLINT
-#include <map>
-
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/time/time.h"
-#include "base/win/windows_version.h"
-#include "breakpad/src/client/windows/crash_generation/client_info.h"
-#include "breakpad/src/client/windows/crash_generation/crash_generation_server.h"
-#include "breakpad/src/client/windows/sender/crash_report_sender.h"
-
-namespace breakpad {
-
-namespace {
-
-const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
-const wchar_t kClassNameFormat[] = L"$1CrashServiceWindow";
-
-const wchar_t kTestPipeName[] = L"\\\\.\\pipe\\ChromeCrashServices";
-
-const wchar_t kGoogleReportURL[] = L"https://clients2.google.com/cr/report";
-const wchar_t kCheckPointFile[] = L"crash_checkpoint.txt";
-
-typedef std::map<std::wstring, std::wstring> CrashMap;
-
-bool CustomInfoToMap(const google_breakpad::ClientInfo* client_info,
-                     const std::wstring& reporter_tag,
-                     CrashMap* map) {
-  google_breakpad::CustomClientInfo info = client_info->GetCustomInfo();
-
-  for (uintptr_t i = 0; i < info.count; ++i) {
-    (*map)[info.entries[i].name] = info.entries[i].value;
-  }
-
-  (*map)[L"rept"] = reporter_tag;
-
-  return !map->empty();
-}
-
-bool WriteCustomInfoToFile(const std::wstring& dump_path, const CrashMap& map) {
-  std::wstring file_path(dump_path);
-  size_t last_dot = file_path.rfind(L'.');
-  if (last_dot == std::wstring::npos)
-    return false;
-  file_path.resize(last_dot);
-  file_path += L".txt";
-
-  std::wofstream file(file_path.c_str(), std::ios_base::out |
-                                             std::ios_base::app |
-                                             std::ios::binary);
-  if (!file.is_open())
-    return false;
-
-  CrashMap::const_iterator pos;
-  for (pos = map.begin(); pos != map.end(); ++pos) {
-    std::wstring line = pos->first;
-    line += L':';
-    line += pos->second;
-    line += L'\n';
-    file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
-  }
-  return true;
-}
-
-bool WriteReportIDToFile(const std::wstring& dump_path,
-                         const std::wstring& report_id) {
-  std::wstring file_path(dump_path);
-  size_t last_slash = file_path.rfind(L'\\');
-  if (last_slash == std::wstring::npos)
-    return false;
-  file_path.resize(last_slash);
-  file_path += L"\\uploads.log";
-
-  std::wofstream file(file_path.c_str(), std::ios_base::out |
-                                             std::ios_base::app |
-                                             std::ios::binary);
-  if (!file.is_open())
-    return false;
-
-  int64_t seconds_since_epoch =
-      (base::Time::Now() - base::Time::UnixEpoch()).InSeconds();
-  std::wstring line = base::Int64ToString16(seconds_since_epoch);
-  line += L',';
-  line += report_id;
-  line += L'\n';
-  file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
-  return true;
-}
-
-// The window procedure task is to handle when a) the user logs off.
-// b) the system shuts down or c) when the user closes the window.
-LRESULT __stdcall CrashSvcWndProc(HWND hwnd,
-                                  UINT message,
-                                  WPARAM wparam,
-                                  LPARAM lparam) {
-  switch (message) {
-    case WM_CLOSE:
-    case WM_ENDSESSION:
-    case WM_DESTROY:
-      PostQuitMessage(0);
-      break;
-    default:
-      return DefWindowProc(hwnd, message, wparam, lparam);
-  }
-  return 0;
-}
-
-// This is the main and only application window.
-HWND g_top_window = NULL;
-
-bool CreateTopWindow(HINSTANCE instance,
-                     const base::string16& application_name,
-                     bool visible) {
-  base::string16 class_name =
-      base::ReplaceStringPlaceholders(kClassNameFormat, application_name, NULL);
-
-  WNDCLASSEXW wcx = {0};
-  wcx.cbSize = sizeof(wcx);
-  wcx.style = CS_HREDRAW | CS_VREDRAW;
-  wcx.lpfnWndProc = CrashSvcWndProc;
-  wcx.hInstance = instance;
-  wcx.lpszClassName = class_name.c_str();
-  ::RegisterClassExW(&wcx);
-  DWORD style = visible ? WS_POPUPWINDOW | WS_VISIBLE : WS_OVERLAPPED;
-
-  // The window size is zero but being a popup window still shows in the
-  // task bar and can be closed using the system menu or using task manager.
-  HWND window = CreateWindowExW(0, wcx.lpszClassName, L"crash service", style,
-                                CW_USEDEFAULT, CW_USEDEFAULT, 0, 0, NULL, NULL,
-                                instance, NULL);
-  if (!window)
-    return false;
-
-  ::UpdateWindow(window);
-  VLOG(1) << "window handle is " << window;
-  g_top_window = window;
-  return true;
-}
-
-// Simple helper class to keep the process alive until the current request
-// finishes.
-class ProcessingLock {
- public:
-  ProcessingLock() { ::InterlockedIncrement(&op_count_); }
-  ~ProcessingLock() { ::InterlockedDecrement(&op_count_); }
-  static bool IsWorking() { return (op_count_ != 0); }
-
- private:
-  static volatile LONG op_count_;
-};
-
-volatile LONG ProcessingLock::op_count_ = 0;
-
-// This structure contains the information that the worker thread needs to
-// send a crash dump to the server.
-struct DumpJobInfo {
-  DWORD pid;
-  CrashService* self;
-  CrashMap map;
-  std::wstring dump_path;
-
-  DumpJobInfo(DWORD process_id,
-              CrashService* service,
-              const CrashMap& crash_map,
-              const std::wstring& path)
-      : pid(process_id), self(service), map(crash_map), dump_path(path) {}
-};
-
-}  // namespace
-
-// Command line switches:
-const char CrashService::kMaxReports[] = "max-reports";
-const char CrashService::kNoWindow[] = "no-window";
-const char CrashService::kReporterTag[] = "reporter";
-const char CrashService::kDumpsDir[] = "dumps-dir";
-const char CrashService::kPipeName[] = "pipe-name";
-const char CrashService::kReporterURL[] = "reporter-url";
-
-CrashService::CrashService() {}
-
-CrashService::~CrashService() {
-  base::AutoLock lock(sending_);
-  delete dumper_;
-  delete sender_;
-}
-
-bool CrashService::Initialize(const base::string16& application_name,
-                              const base::FilePath& operating_dir,
-                              const base::FilePath& dumps_path) {
-  using google_breakpad::CrashGenerationServer;
-  using google_breakpad::CrashReportSender;
-
-  std::wstring pipe_name = kTestPipeName;
-  int max_reports = -1;
-
-  // The checkpoint file allows CrashReportSender to enforce the maximum
-  // reports per day quota. Does not seem to serve any other purpose.
-  base::FilePath checkpoint_path = operating_dir.Append(kCheckPointFile);
-
-  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
-
-  base::FilePath dumps_path_to_use = dumps_path;
-
-  if (cmd_line.HasSwitch(kDumpsDir)) {
-    dumps_path_to_use =
-        base::FilePath(cmd_line.GetSwitchValueNative(kDumpsDir));
-  }
-
-  // We can override the send reports quota with a command line switch.
-  if (cmd_line.HasSwitch(kMaxReports))
-    max_reports = _wtoi(cmd_line.GetSwitchValueNative(kMaxReports).c_str());
-
-  // Allow the global pipe name to be overridden for better testability.
-  if (cmd_line.HasSwitch(kPipeName))
-    pipe_name = cmd_line.GetSwitchValueNative(kPipeName);
-
-  if (max_reports > 0) {
-    // Create the http sender object.
-    sender_ = new CrashReportSender(checkpoint_path.value());
-    sender_->set_max_reports_per_day(max_reports);
-  }
-
-  SECURITY_ATTRIBUTES security_attributes = {0};
-  SECURITY_DESCRIPTOR* security_descriptor =
-      reinterpret_cast<SECURITY_DESCRIPTOR*>(
-          GetSecurityDescriptorForLowIntegrity());
-  DCHECK(security_descriptor != NULL);
-
-  security_attributes.nLength = sizeof(security_attributes);
-  security_attributes.lpSecurityDescriptor = security_descriptor;
-  security_attributes.bInheritHandle = FALSE;
-
-  // Create the OOP crash generator object.
-  dumper_ = new CrashGenerationServer(
-      pipe_name, &security_attributes, &CrashService::OnClientConnected, this,
-      &CrashService::OnClientDumpRequest, this, &CrashService::OnClientExited,
-      this, NULL, NULL, true, &dumps_path_to_use.value());
-
-  if (!dumper_) {
-    LOG(ERROR) << "could not create dumper";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  if (!CreateTopWindow(::GetModuleHandleW(NULL), application_name,
-                       !cmd_line.HasSwitch(kNoWindow))) {
-    LOG(ERROR) << "could not create window";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  reporter_tag_ = L"crash svc";
-  if (cmd_line.HasSwitch(kReporterTag))
-    reporter_tag_ = cmd_line.GetSwitchValueNative(kReporterTag);
-
-  reporter_url_ = kGoogleReportURL;
-  if (cmd_line.HasSwitch(kReporterURL))
-    reporter_url_ = cmd_line.GetSwitchValueNative(kReporterURL);
-
-  // Log basic information.
-  VLOG(1) << "pipe name is " << pipe_name << "\ndumps at "
-          << dumps_path_to_use.value();
-
-  if (sender_) {
-    VLOG(1) << "checkpoint is " << checkpoint_path.value() << "\nserver is "
-            << reporter_url_ << "\nmaximum " << sender_->max_reports_per_day()
-            << " reports/day"
-            << "\nreporter is " << reporter_tag_;
-  }
-  // Start servicing clients.
-  if (!dumper_->Start()) {
-    LOG(ERROR) << "could not start dumper";
-    if (security_attributes.lpSecurityDescriptor)
-      LocalFree(security_attributes.lpSecurityDescriptor);
-    return false;
-  }
-
-  if (security_attributes.lpSecurityDescriptor)
-    LocalFree(security_attributes.lpSecurityDescriptor);
-
-  // Create or open an event to signal the browser process that the crash
-  // service is initialized.
-  base::string16 wait_name =
-      base::ReplaceStringPlaceholders(kWaitEventFormat, application_name, NULL);
-  HANDLE wait_event = ::CreateEventW(NULL, TRUE, TRUE, wait_name.c_str());
-  ::SetEvent(wait_event);
-
-  return true;
-}
-
-void CrashService::OnClientConnected(
-    void* context,
-    const google_breakpad::ClientInfo* client_info) {
-  ProcessingLock lock;
-  VLOG(1) << "client start. pid = " << client_info->pid();
-  CrashService* self = static_cast<CrashService*>(context);
-  ::InterlockedIncrement(&self->clients_connected_);
-}
-
-void CrashService::OnClientExited(
-    void* context,
-    const google_breakpad::ClientInfo* client_info) {
-  ProcessingLock processing_lock;
-  VLOG(1) << "client end. pid = " << client_info->pid();
-  CrashService* self = static_cast<CrashService*>(context);
-  ::InterlockedIncrement(&self->clients_terminated_);
-
-  if (!self->sender_)
-    return;
-
-  // When we are instructed to send reports we need to exit if there are
-  // no more clients to service. The next client that runs will start us.
-  // Only chrome.exe starts crash_service with a non-zero max_reports.
-  if (self->clients_connected_ > self->clients_terminated_)
-    return;
-  if (self->sender_->max_reports_per_day() > 0) {
-    // Wait for the other thread to send crashes, if applicable. The sender
-    // thread takes the sending_ lock, so the sleep is just to give it a
-    // chance to start.
-    ::Sleep(1000);
-    base::AutoLock lock(self->sending_);
-    // Some people can restart chrome very fast, check again if we have
-    // a new client before exiting for real.
-    if (self->clients_connected_ == self->clients_terminated_) {
-      VLOG(1) << "zero clients. exiting";
-      ::PostMessage(g_top_window, WM_CLOSE, 0, 0);
-    }
-  }
-}
-
-void CrashService::OnClientDumpRequest(
-    void* context,
-    const google_breakpad::ClientInfo* client_info,
-    const std::wstring* file_path) {
-  ProcessingLock lock;
-
-  if (!file_path) {
-    LOG(ERROR) << "dump with no file path";
-    return;
-  }
-  if (!client_info) {
-    LOG(ERROR) << "dump with no client info";
-    return;
-  }
-
-  CrashService* self = static_cast<CrashService*>(context);
-  if (!self) {
-    LOG(ERROR) << "dump with no context";
-    return;
-  }
-
-  CrashMap map;
-  CustomInfoToMap(client_info, self->reporter_tag_, &map);
-
-  // Move dump file to the directory under client breakpad dump location.
-  base::FilePath dump_location = base::FilePath(*file_path);
-  CrashMap::const_iterator it = map.find(L"breakpad-dump-location");
-  if (it != map.end()) {
-    base::FilePath alternate_dump_location = base::FilePath(it->second);
-    base::CreateDirectoryW(alternate_dump_location);
-    alternate_dump_location =
-        alternate_dump_location.Append(dump_location.BaseName());
-    base::Move(dump_location, alternate_dump_location);
-    dump_location = alternate_dump_location;
-  }
-
-  DWORD pid = client_info->pid();
-  VLOG(1) << "dump for pid = " << pid << " is " << dump_location.value();
-
-  if (!WriteCustomInfoToFile(dump_location.value(), map)) {
-    LOG(ERROR) << "could not write custom info file";
-  }
-
-  if (!self->sender_ || map.find(L"skip_upload") != map.end())
-    return;
-
-  // Send the crash dump using a worker thread. This operation has retry
-  // logic in case there is no internet connection at the time.
-  DumpJobInfo* dump_job =
-      new DumpJobInfo(pid, self, map, dump_location.value());
-  if (!::QueueUserWorkItem(&CrashService::AsyncSendDump, dump_job,
-                           WT_EXECUTELONGFUNCTION)) {
-    LOG(ERROR) << "could not queue job";
-  }
-}
-
-// We are going to try sending the report several times. If we can't send,
-// we sleep from one minute to several hours depending on the retry round.
-DWORD CrashService::AsyncSendDump(void* context) {
-  if (!context)
-    return 0;
-
-  DumpJobInfo* info = static_cast<DumpJobInfo*>(context);
-
-  std::wstring report_id = L"<unsent>";
-
-  const DWORD kOneMinute = 60 * 1000;
-  const DWORD kOneHour = 60 * kOneMinute;
-
-  const DWORD kSleepSchedule[] = {24 * kOneHour, 8 * kOneHour,    4 * kOneHour,
-                                  kOneHour,      15 * kOneMinute, 0};
-
-  int retry_round = arraysize(kSleepSchedule) - 1;
-
-  do {
-    ::Sleep(kSleepSchedule[retry_round]);
-    {
-      // Take the server lock while sending. This also prevent early
-      // termination of the service object.
-      base::AutoLock lock(info->self->sending_);
-      VLOG(1) << "trying to send report for pid = " << info->pid;
-      std::map<std::wstring, std::wstring> file_map;
-      file_map[L"upload_file_minidump"] = info->dump_path;
-      google_breakpad::ReportResult send_result =
-          info->self->sender_->SendCrashReport(info->self->reporter_url_,
-                                               info->map, file_map, &report_id);
-      switch (send_result) {
-        case google_breakpad::RESULT_FAILED:
-          report_id = L"<network issue>";
-          break;
-        case google_breakpad::RESULT_REJECTED:
-          report_id = L"<rejected>";
-          ++info->self->requests_handled_;
-          retry_round = 0;
-          break;
-        case google_breakpad::RESULT_SUCCEEDED:
-          ++info->self->requests_sent_;
-          ++info->self->requests_handled_;
-          retry_round = 0;
-          WriteReportIDToFile(info->dump_path, report_id);
-          break;
-        case google_breakpad::RESULT_THROTTLED:
-          report_id = L"<throttled>";
-          break;
-        default:
-          report_id = L"<unknown>";
-          break;
-      }
-    }
-
-    VLOG(1) << "dump for pid =" << info->pid << " crash2 id =" << report_id;
-    --retry_round;
-  } while (retry_round >= 0);
-
-  if (!::DeleteFileW(info->dump_path.c_str()))
-    LOG(WARNING) << "could not delete " << info->dump_path;
-
-  delete info;
-  return 0;
-}
-
-int CrashService::ProcessingLoop() {
-  MSG msg;
-  while (GetMessage(&msg, NULL, 0, 0)) {
-    TranslateMessage(&msg);
-    DispatchMessage(&msg);
-  }
-
-  VLOG(1) << "session ending..";
-  while (ProcessingLock::IsWorking()) {
-    ::Sleep(50);
-  }
-
-  VLOG(1) << "clients connected :" << clients_connected_
-          << "\nclients terminated :" << clients_terminated_
-          << "\ndumps serviced :" << requests_handled_
-          << "\ndumps reported :" << requests_sent_;
-
-  return static_cast<int>(msg.wParam);
-}
-
-PSECURITY_DESCRIPTOR CrashService::GetSecurityDescriptorForLowIntegrity() {
-  // Build the SDDL string for the label.
-  std::wstring sddl = L"S:(ML;;NW;;;S-1-16-4096)";
-
-  PSECURITY_DESCRIPTOR sec_desc = NULL;
-
-  PACL sacl = NULL;
-  BOOL sacl_present = FALSE;
-  BOOL sacl_defaulted = FALSE;
-
-  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(
-          sddl.c_str(), SDDL_REVISION, &sec_desc, NULL)) {
-    if (::GetSecurityDescriptorSacl(sec_desc, &sacl_present, &sacl,
-                                    &sacl_defaulted)) {
-      return sec_desc;
-    }
-  }
-
-  return NULL;
-}
-
-}  // namespace breakpad
removed in remote
  base   100644 c05e0d5bf6e453950f584bc44a911ecaea55fe84 atom/common/crash_reporter/win/crash_service.h
  our    100644 93bbb7c36de3d256acae5ff8dfaa447f8a438b14 atom/common/crash_reporter/win/crash_service.h
@@ -1,130 +0,0 @@
-// Copyright (c) 2011 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
-#define ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
-
-#include <string>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/synchronization/lock.h"
-
-#if defined(OS_WIN)
-#include <windows.h>
-#endif  // defined(OS_WIN)
-
-namespace google_breakpad {
-
-class CrashReportSender;
-class CrashGenerationServer;
-class ClientInfo;
-
-}  // namespace google_breakpad
-
-namespace breakpad {
-
-// This class implements an out-of-process crash server. It uses breakpad's
-// CrashGenerationServer and CrashReportSender to generate and then send the
-// crash dumps. Internally, it uses OS specific pipe to allow applications to
-// register for crash dumps and later on when a registered application crashes
-// it will signal an event that causes this code to wake up and perform a
-// crash dump on the signaling process. The dump is then stored on disk and
-// possibly sent to the crash2 servers.
-class CrashService {
- public:
-  CrashService();
-  ~CrashService();
-
-  // Starts servicing crash dumps. Returns false if it failed. Do not use
-  // other members in that case. |operating_dir| is where the CrashService
-  // should store breakpad's checkpoint file. |dumps_path| is the directory
-  // where the crash dumps should be stored.
-  bool Initialize(const base::string16& application_name,
-                  const base::FilePath& operating_dir,
-                  const base::FilePath& dumps_path);
-
-  // Command line switches:
-  //
-  // --max-reports=<number>
-  // Allows to override the maximum number for reports per day. Normally
-  // the crash dumps are never sent so if you want to send any you must
-  // specify a positive number here.
-  static const char kMaxReports[];
-  // --no-window
-  // Does not create a visible window on the desktop. The window does not have
-  // any other functionality other than allowing the crash service to be
-  // gracefully closed.
-  static const char kNoWindow[];
-  // --reporter=<string>
-  // Allows to specify a custom string that appears on the detail crash report
-  // page in the crash server. This should be a 25 chars or less string.
-  // The default tag if not specified is 'crash svc'.
-  static const char kReporterTag[];
-  // --dumps-dir=<directory-path>
-  // Override the directory to which crash dump files will be written.
-  static const char kDumpsDir[];
-  // --pipe-name=<string>
-  // Override the name of the Windows named pipe on which we will
-  // listen for crash dump request messages.
-  static const char kPipeName[];
-  // --reporter-url=<string>
-  // Override the URL to which crash reports will be sent to.
-  static const char kReporterURL[];
-
-  // Returns number of crash dumps handled.
-  int requests_handled() const { return requests_handled_; }
-  // Returns number of crash clients registered.
-  int clients_connected() const { return clients_connected_; }
-  // Returns number of crash clients terminated.
-  int clients_terminated() const { return clients_terminated_; }
-
-  // Starts the processing loop. This function does not return unless the
-  // user is logging off or the user closes the crash service window. The
-  // return value is a good number to pass in ExitProcess().
-  int ProcessingLoop();
-
- private:
-  static void OnClientConnected(void* context,
-                                const google_breakpad::ClientInfo* client_info);
-
-  static void OnClientDumpRequest(
-      void* context,
-      const google_breakpad::ClientInfo* client_info,
-      const std::wstring* file_path);
-
-  static void OnClientExited(void* context,
-                             const google_breakpad::ClientInfo* client_info);
-
-  // This routine sends the crash dump to the server. It takes the sending_
-  // lock when it is performing the send.
-  static DWORD __stdcall AsyncSendDump(void* context);
-
-  // Returns the security descriptor which access to low integrity processes
-  // The caller is supposed to free the security descriptor by calling
-  // LocalFree.
-  PSECURITY_DESCRIPTOR GetSecurityDescriptorForLowIntegrity();
-
-  google_breakpad::CrashGenerationServer* dumper_ = nullptr;
-  google_breakpad::CrashReportSender* sender_ = nullptr;
-
-  // the extra tag sent to the server with each dump.
-  std::wstring reporter_tag_;
-
-  // receiver URL of crash reports.
-  std::wstring reporter_url_;
-
-  // clients serviced statistics:
-  int requests_handled_ = 0;
-  int requests_sent_ = 0;
-  volatile LONG clients_connected_ = 0;
-  volatile LONG clients_terminated_ = 0;
-  base::Lock sending_;
-
-  DISALLOW_COPY_AND_ASSIGN(CrashService);
-};
-
-}  // namespace breakpad
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
removed in remote
  base   100644 56d46970b67f7843328e291f15ab07ddead8aced atom/common/crash_reporter/win/crash_service_main.cc
  our    100644 c25ee858de0b5fd87229f3cfd658f7dd3e4f90c6 atom/common/crash_reporter/win/crash_service_main.cc
@@ -1,104 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/crash_reporter/win/crash_service_main.h"
-
-#include "atom/common/crash_reporter/win/crash_service.h"
-#include "base/at_exit.h"
-#include "base/command_line.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-
-namespace crash_service {
-
-namespace {
-
-const char kApplicationName[] = "application-name";
-const char kCrashesDirectory[] = "crashes-directory";
-
-const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
-const wchar_t kStandardLogFile[] = L"operation_log.txt";
-
-void InvalidParameterHandler(const wchar_t*,
-                             const wchar_t*,
-                             const wchar_t*,
-                             unsigned int,
-                             uintptr_t) {
-  // noop.
-}
-
-bool CreateCrashServiceDirectory(const base::FilePath& temp_dir) {
-  if (!base::PathExists(temp_dir)) {
-    if (!base::CreateDirectory(temp_dir))
-      return false;
-  }
-  return true;
-}
-
-}  // namespace.
-
-int Main(const wchar_t* cmd) {
-  // Ignore invalid parameter errors.
-  _set_invalid_parameter_handler(InvalidParameterHandler);
-
-  // Initialize all Chromium things.
-  base::AtExitManager exit_manager;
-  base::CommandLine::Init(0, NULL);
-  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
-
-  // Use the application's name as pipe name and output directory.
-  if (!cmd_line.HasSwitch(kApplicationName)) {
-    LOG(ERROR) << "Application's name must be specified with --"
-               << kApplicationName;
-    return 1;
-  }
-  std::wstring application_name =
-      cmd_line.GetSwitchValueNative(kApplicationName);
-
-  if (!cmd_line.HasSwitch(kCrashesDirectory)) {
-    LOG(ERROR) << "Crashes directory path must be specified with --"
-               << kCrashesDirectory;
-    return 1;
-  }
-
-  // We use/create a directory under the user's temp folder, for logging.
-  base::FilePath operating_dir(
-      cmd_line.GetSwitchValueNative(kCrashesDirectory));
-  CreateCrashServiceDirectory(operating_dir);
-  base::FilePath log_file = operating_dir.Append(kStandardLogFile);
-
-  // Logging to stderr (to help with debugging failures on the
-  // buildbots) and to a file.
-  logging::LoggingSettings settings;
-  settings.logging_dest = logging::LOG_TO_ALL;
-  settings.log_file = log_file.value().c_str();
-  logging::InitLogging(settings);
-  // Logging with pid, tid and timestamp.
-  logging::SetLogItems(true, true, true, false);
-
-  VLOG(1) << "Session start. cmdline is [" << cmd << "]";
-
-  // Setting the crash reporter.
-  base::string16 pipe_name =
-      base::ReplaceStringPlaceholders(kPipeNameFormat, application_name, NULL);
-  cmd_line.AppendSwitch("no-window");
-  cmd_line.AppendSwitchASCII("max-reports", "128");
-  cmd_line.AppendSwitchASCII("reporter", ATOM_PROJECT_NAME "-crash-service");
-  cmd_line.AppendSwitchNative("pipe-name", pipe_name);
-
-  breakpad::CrashService crash_service;
-  if (!crash_service.Initialize(application_name, operating_dir, operating_dir))
-    return 2;
-
-  VLOG(1) << "Ready to process crash requests";
-
-  // Enter the message loop.
-  int retv = crash_service.ProcessingLoop();
-  // Time to exit.
-  VLOG(1) << "Session end. return code is " << retv;
-  return retv;
-}
-
-}  // namespace crash_service
removed in remote
  base   100644 b536313dbc3213ab3c2666db50c80c1984ebace7 atom/common/crash_reporter/win/crash_service_main.h
  our    100644 b536313dbc3213ab3c2666db50c80c1984ebace7 atom/common/crash_reporter/win/crash_service_main.h
@@ -1,15 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
-#define ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
-
-namespace crash_service {
-
-// Program entry, should be called by main();
-int Main(const wchar_t* cmd_line);
-
-}  // namespace crash_service
-
-#endif  // ATOM_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
removed in remote
  base   100644 f57719448a088e11cf173d69fb5b1dc17288e8e1 atom/common/draggable_region.cc
  our    100644 a571b2edf2b2937f8a4ddf30fc42fc927792a749 atom/common/draggable_region.cc
@@ -1,11 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/draggable_region.h"
-
-namespace atom {
-
-DraggableRegion::DraggableRegion() : draggable(false) {}
-
-}  // namespace atom
removed in remote
  base   100644 a007c8cb9fe54c9ae25438437ea95dc790d4bc33 atom/common/draggable_region.h
  our    100644 a007c8cb9fe54c9ae25438437ea95dc790d4bc33 atom/common/draggable_region.h
@@ -1,21 +0,0 @@
-// Copyright (c) 2012 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_DRAGGABLE_REGION_H_
-#define ATOM_COMMON_DRAGGABLE_REGION_H_
-
-#include "ui/gfx/geometry/rect.h"
-
-namespace atom {
-
-struct DraggableRegion {
-  bool draggable;
-  gfx::Rect bounds;
-
-  DraggableRegion();
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_DRAGGABLE_REGION_H_
removed in remote
  base   100644 dc38272ec611ff47127cb7b4cc4e006a4eb9ac15 atom/common/google_api_key.h
  our    100644 d27934595eac9e442564ab4b6e04c092ca92a605 atom/common/google_api_key.h
@@ -1,17 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_GOOGLE_API_KEY_H_
-#define ATOM_COMMON_GOOGLE_API_KEY_H_
-
-#ifndef GOOGLEAPIS_ENDPOINT
-#define GOOGLEAPIS_ENDPOINT \
-  "https://www.googleapis.com/geolocation/v1/geolocate?key="
-#endif
-
-#ifndef GOOGLEAPIS_API_KEY
-#define GOOGLEAPIS_API_KEY "AIzaSyAQfxPJiounkhOjODEO5ZieffeBv6yft2Q"
-#endif
-
-#endif  // ATOM_COMMON_GOOGLE_API_KEY_H_
removed in remote
  base   100644 d860bc0c46c767f57b3c57632ea055d105042b1f atom/common/keyboard_util.cc
  our    100644 d0a12cb6d91b9688c1bed496e64d6bbaccaf244a atom/common/keyboard_util.cc
@@ -1,325 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include <string>
-
-#include "atom/common/keyboard_util.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "ui/events/event_constants.h"
-
-namespace atom {
-
-namespace {
-
-// Return key code of the char, and also determine whether the SHIFT key is
-// pressed.
-ui::KeyboardCode KeyboardCodeFromCharCode(base::char16 c, bool* shifted) {
-  c = base::ToLowerASCII(c);
-  *shifted = false;
-  switch (c) {
-    case 0x08:
-      return ui::VKEY_BACK;
-    case 0x7F:
-      return ui::VKEY_DELETE;
-    case 0x09:
-      return ui::VKEY_TAB;
-    case 0x0D:
-      return ui::VKEY_RETURN;
-    case 0x1B:
-      return ui::VKEY_ESCAPE;
-    case ' ':
-      return ui::VKEY_SPACE;
-
-    case 'a':
-      return ui::VKEY_A;
-    case 'b':
-      return ui::VKEY_B;
-    case 'c':
-      return ui::VKEY_C;
-    case 'd':
-      return ui::VKEY_D;
-    case 'e':
-      return ui::VKEY_E;
-    case 'f':
-      return ui::VKEY_F;
-    case 'g':
-      return ui::VKEY_G;
-    case 'h':
-      return ui::VKEY_H;
-    case 'i':
-      return ui::VKEY_I;
-    case 'j':
-      return ui::VKEY_J;
-    case 'k':
-      return ui::VKEY_K;
-    case 'l':
-      return ui::VKEY_L;
-    case 'm':
-      return ui::VKEY_M;
-    case 'n':
-      return ui::VKEY_N;
-    case 'o':
-      return ui::VKEY_O;
-    case 'p':
-      return ui::VKEY_P;
-    case 'q':
-      return ui::VKEY_Q;
-    case 'r':
-      return ui::VKEY_R;
-    case 's':
-      return ui::VKEY_S;
-    case 't':
-      return ui::VKEY_T;
-    case 'u':
-      return ui::VKEY_U;
-    case 'v':
-      return ui::VKEY_V;
-    case 'w':
-      return ui::VKEY_W;
-    case 'x':
-      return ui::VKEY_X;
-    case 'y':
-      return ui::VKEY_Y;
-    case 'z':
-      return ui::VKEY_Z;
-
-    case ')':
-      *shifted = true;
-      FALLTHROUGH;
-    case '0':
-      return ui::VKEY_0;
-    case '!':
-      *shifted = true;
-      FALLTHROUGH;
-    case '1':
-      return ui::VKEY_1;
-    case '@':
-      *shifted = true;
-      FALLTHROUGH;
-    case '2':
-      return ui::VKEY_2;
-    case '#':
-      *shifted = true;
-      FALLTHROUGH;
-    case '3':
-      return ui::VKEY_3;
-    case '$':
-      *shifted = true;
-      FALLTHROUGH;
-    case '4':
-      return ui::VKEY_4;
-    case '%':
-      *shifted = true;
-      FALLTHROUGH;
-    case '5':
-      return ui::VKEY_5;
-    case '^':
-      *shifted = true;
-      FALLTHROUGH;
-    case '6':
-      return ui::VKEY_6;
-    case '&':
-      *shifted = true;
-      FALLTHROUGH;
-    case '7':
-      return ui::VKEY_7;
-    case '*':
-      *shifted = true;
-      FALLTHROUGH;
-    case '8':
-      return ui::VKEY_8;
-    case '(':
-      *shifted = true;
-      FALLTHROUGH;
-    case '9':
-      return ui::VKEY_9;
-
-    case ':':
-      *shifted = true;
-      FALLTHROUGH;
-    case ';':
-      return ui::VKEY_OEM_1;
-    case '+':
-      *shifted = true;
-      FALLTHROUGH;
-    case '=':
-      return ui::VKEY_OEM_PLUS;
-    case '<':
-      *shifted = true;
-      FALLTHROUGH;
-    case ',':
-      return ui::VKEY_OEM_COMMA;
-    case '_':
-      *shifted = true;
-      FALLTHROUGH;
-    case '-':
-      return ui::VKEY_OEM_MINUS;
-    case '>':
-      *shifted = true;
-      FALLTHROUGH;
-    case '.':
-      return ui::VKEY_OEM_PERIOD;
-    case '?':
-      *shifted = true;
-      FALLTHROUGH;
-    case '/':
-      return ui::VKEY_OEM_2;
-    case '~':
-      *shifted = true;
-      FALLTHROUGH;
-    case '`':
-      return ui::VKEY_OEM_3;
-    case '{':
-      *shifted = true;
-      FALLTHROUGH;
-    case '[':
-      return ui::VKEY_OEM_4;
-    case '|':
-      *shifted = true;
-      FALLTHROUGH;
-    case '\\':
-      return ui::VKEY_OEM_5;
-    case '}':
-      *shifted = true;
-      FALLTHROUGH;
-    case ']':
-      return ui::VKEY_OEM_6;
-    case '"':
-      *shifted = true;
-      FALLTHROUGH;
-    case '\'':
-      return ui::VKEY_OEM_7;
-
-    default:
-      return ui::VKEY_UNKNOWN;
-  }
-}
-
-// Return key code represented by |str|.
-ui::KeyboardCode KeyboardCodeFromKeyIdentifier(const std::string& s,
-                                               bool* shifted) {
-  std::string str = base::ToLowerASCII(s);
-  if (str == "ctrl" || str == "control") {
-    return ui::VKEY_CONTROL;
-  } else if (str == "super" || str == "cmd" || str == "command" ||
-             str == "meta") {
-    return ui::VKEY_COMMAND;
-  } else if (str == "commandorcontrol" || str == "cmdorctrl") {
-#if defined(OS_MACOSX)
-    return ui::VKEY_COMMAND;
-#else
-    return ui::VKEY_CONTROL;
-#endif
-  } else if (str == "alt" || str == "option") {
-    return ui::VKEY_MENU;
-  } else if (str == "shift") {
-    return ui::VKEY_SHIFT;
-  } else if (str == "altgr") {
-    return ui::VKEY_ALTGR;
-  } else if (str == "plus") {
-    *shifted = true;
-    return ui::VKEY_OEM_PLUS;
-  } else if (str == "tab") {
-    return ui::VKEY_TAB;
-  } else if (str == "space") {
-    return ui::VKEY_SPACE;
-  } else if (str == "backspace") {
-    return ui::VKEY_BACK;
-  } else if (str == "delete") {
-    return ui::VKEY_DELETE;
-  } else if (str == "insert") {
-    return ui::VKEY_INSERT;
-  } else if (str == "enter" || str == "return") {
-    return ui::VKEY_RETURN;
-  } else if (str == "up") {
-    return ui::VKEY_UP;
-  } else if (str == "down") {
-    return ui::VKEY_DOWN;
-  } else if (str == "left") {
-    return ui::VKEY_LEFT;
-  } else if (str == "right") {
-    return ui::VKEY_RIGHT;
-  } else if (str == "home") {
-    return ui::VKEY_HOME;
-  } else if (str == "end") {
-    return ui::VKEY_END;
-  } else if (str == "pageup") {
-    return ui::VKEY_PRIOR;
-  } else if (str == "pagedown") {
-    return ui::VKEY_NEXT;
-  } else if (str == "esc" || str == "escape") {
-    return ui::VKEY_ESCAPE;
-  } else if (str == "volumemute") {
-    return ui::VKEY_VOLUME_MUTE;
-  } else if (str == "volumeup") {
-    return ui::VKEY_VOLUME_UP;
-  } else if (str == "volumedown") {
-    return ui::VKEY_VOLUME_DOWN;
-  } else if (str == "medianexttrack") {
-    return ui::VKEY_MEDIA_NEXT_TRACK;
-  } else if (str == "mediaprevioustrack") {
-    return ui::VKEY_MEDIA_PREV_TRACK;
-  } else if (str == "mediastop") {
-    return ui::VKEY_MEDIA_STOP;
-  } else if (str == "mediaplaypause") {
-    return ui::VKEY_MEDIA_PLAY_PAUSE;
-  } else if (str == "printscreen") {
-    return ui::VKEY_SNAPSHOT;
-  } else if (str.size() > 1 && str[0] == 'f') {
-    // F1 - F24.
-    int n;
-    if (base::StringToInt(str.c_str() + 1, &n) && n > 0 && n < 25) {
-      return static_cast<ui::KeyboardCode>(ui::VKEY_F1 + n - 1);
-    } else {
-      LOG(WARNING) << str << "is not available on keyboard";
-      return ui::VKEY_UNKNOWN;
-    }
-  } else {
-    if (str.size() > 2)
-      LOG(WARNING) << "Invalid accelerator token: " << str;
-    return ui::VKEY_UNKNOWN;
-  }
-}
-
-}  // namespace
-
-ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted) {
-  if (str.size() == 1)
-    return KeyboardCodeFromCharCode(str[0], shifted);
-  else
-    return KeyboardCodeFromKeyIdentifier(str, shifted);
-}
-
-int WebEventModifiersToEventFlags(int modifiers) {
-  int flags = 0;
-
-  if (modifiers & blink::WebInputEvent::kShiftKey)
-    flags |= ui::EF_SHIFT_DOWN;
-  if (modifiers & blink::WebInputEvent::kControlKey)
-    flags |= ui::EF_CONTROL_DOWN;
-  if (modifiers & blink::WebInputEvent::kAltKey)
-    flags |= ui::EF_ALT_DOWN;
-  if (modifiers & blink::WebInputEvent::kMetaKey)
-    flags |= ui::EF_COMMAND_DOWN;
-  if (modifiers & blink::WebInputEvent::kCapsLockOn)
-    flags |= ui::EF_CAPS_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kNumLockOn)
-    flags |= ui::EF_NUM_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kScrollLockOn)
-    flags |= ui::EF_SCROLL_LOCK_ON;
-  if (modifiers & blink::WebInputEvent::kLeftButtonDown)
-    flags |= ui::EF_LEFT_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kMiddleButtonDown)
-    flags |= ui::EF_MIDDLE_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kRightButtonDown)
-    flags |= ui::EF_RIGHT_MOUSE_BUTTON;
-  if (modifiers & blink::WebInputEvent::kIsAutoRepeat)
-    flags |= ui::EF_IS_REPEAT;
-
-  return flags;
-}
-
-}  // namespace atom
removed in remote
  base   100644 c9d1b809e8f7cebf3b0fea0cded6d09364ee20e1 atom/common/keyboard_util.h
  our    100644 651cf6a92024cc06d7d0e044efda744e70848479 atom/common/keyboard_util.h
@@ -1,23 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_KEYBOARD_UTIL_H_
-#define ATOM_COMMON_KEYBOARD_UTIL_H_
-
-#include <string>
-
-#include "ui/events/keycodes/keyboard_codes.h"
-
-namespace atom {
-
-// Return key code of the |str|, and also determine whether the SHIFT key is
-// pressed.
-ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted);
-
-// Ported from ui/events/blink/blink_event_util.h
-int WebEventModifiersToEventFlags(int modifiers);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_KEYBOARD_UTIL_H_
removed in remote
  base   100644 053bd4bb8634ccdc9903ec18cffa8ecdce410eaa atom/common/linux/application_info.cc
  our    100644 3354c73b8b60f77cf054f975ea713d96b7e7683e atom/common/linux/application_info.cc
@@ -1,79 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "brightray/common/application_info.h"
-
-#include <gio/gdesktopappinfo.h>
-#include <gio/gio.h>
-
-#include <memory>
-#include <string>
-
-#include "atom/common/atom_version.h"
-#include "base/environment.h"
-#include "base/logging.h"
-#include "brightray/common/platform_util.h"
-#include "chrome/browser/ui/libgtkui/gtk_util.h"
-
-namespace {
-
-GDesktopAppInfo* get_desktop_app_info() {
-  GDesktopAppInfo* ret = nullptr;
-
-  std::string desktop_id;
-  if (brightray::platform_util::GetDesktopName(&desktop_id))
-    ret = g_desktop_app_info_new(desktop_id.c_str());
-
-  return ret;
-}
-
-}  // namespace
-
-namespace brightray {
-
-std::string GetApplicationName() {
-  // attempt #1: the string set in app.setName()
-  std::string ret = GetOverriddenApplicationName();
-
-  // attempt #2: the 'Name' entry from .desktop file's [Desktop] section
-  if (ret.empty()) {
-    GDesktopAppInfo* info = get_desktop_app_info();
-    if (info != nullptr) {
-      char* str = g_desktop_app_info_get_string(info, "Name");
-      g_clear_object(&info);
-      if (str != nullptr)
-        ret = str;
-      g_clear_pointer(&str, g_free);
-    }
-  }
-
-  // attempt #3: Electron's name
-  if (ret.empty()) {
-    ret = ATOM_PRODUCT_NAME;
-  }
-
-  return ret;
-}
-
-std::string GetApplicationVersion() {
-  std::string ret;
-
-  // ensure ATOM_PRODUCT_NAME and ATOM_PRODUCT_STRING match up
-  if (GetApplicationName() == ATOM_PRODUCT_NAME)
-    ret = ATOM_VERSION_STRING;
-
-  // try to use the string set in app.setVersion()
-  if (ret.empty())
-    ret = GetOverriddenApplicationVersion();
-
-  // no known version number; return some safe fallback
-  if (ret.empty()) {
-    LOG(WARNING) << "No version found. Was app.setVersion() called?";
-    ret = "0.0";
-  }
-
-  return ret;
-}
-
-}  // namespace brightray
removed in remote
  base   100644 69aadaa7a0464fc43e72d6826aad7ac513b39c24 atom/common/mouse_util.cc
  our    100644 d87be5b504e153e06dfd38965e262c6d630853a9 atom/common/mouse_util.cc
@@ -1,107 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/mouse_util.h"
-#include <string>
-
-using Cursor = blink::WebCursorInfo::Type;
-
-namespace atom {
-
-std::string CursorTypeToString(const content::CursorInfo& info) {
-  switch (info.type) {
-    case Cursor::kTypePointer:
-      return "default";
-    case Cursor::kTypeCross:
-      return "crosshair";
-    case Cursor::kTypeHand:
-      return "pointer";
-    case Cursor::kTypeIBeam:
-      return "text";
-    case Cursor::kTypeWait:
-      return "wait";
-    case Cursor::kTypeHelp:
-      return "help";
-    case Cursor::kTypeEastResize:
-      return "e-resize";
-    case Cursor::kTypeNorthResize:
-      return "n-resize";
-    case Cursor::kTypeNorthEastResize:
-      return "ne-resize";
-    case Cursor::kTypeNorthWestResize:
-      return "nw-resize";
-    case Cursor::kTypeSouthResize:
-      return "s-resize";
-    case Cursor::kTypeSouthEastResize:
-      return "se-resize";
-    case Cursor::kTypeSouthWestResize:
-      return "sw-resize";
-    case Cursor::kTypeWestResize:
-      return "w-resize";
-    case Cursor::kTypeNorthSouthResize:
-      return "ns-resize";
-    case Cursor::kTypeEastWestResize:
-      return "ew-resize";
-    case Cursor::kTypeNorthEastSouthWestResize:
-      return "nesw-resize";
-    case Cursor::kTypeNorthWestSouthEastResize:
-      return "nwse-resize";
-    case Cursor::kTypeColumnResize:
-      return "col-resize";
-    case Cursor::kTypeRowResize:
-      return "row-resize";
-    case Cursor::kTypeMiddlePanning:
-      return "m-panning";
-    case Cursor::kTypeEastPanning:
-      return "e-panning";
-    case Cursor::kTypeNorthPanning:
-      return "n-panning";
-    case Cursor::kTypeNorthEastPanning:
-      return "ne-panning";
-    case Cursor::kTypeNorthWestPanning:
-      return "nw-panning";
-    case Cursor::kTypeSouthPanning:
-      return "s-panning";
-    case Cursor::kTypeSouthEastPanning:
-      return "se-panning";
-    case Cursor::kTypeSouthWestPanning:
-      return "sw-panning";
-    case Cursor::kTypeWestPanning:
-      return "w-panning";
-    case Cursor::kTypeMove:
-      return "move";
-    case Cursor::kTypeVerticalText:
-      return "vertical-text";
-    case Cursor::kTypeCell:
-      return "cell";
-    case Cursor::kTypeContextMenu:
-      return "context-menu";
-    case Cursor::kTypeAlias:
-      return "alias";
-    case Cursor::kTypeProgress:
-      return "progress";
-    case Cursor::kTypeNoDrop:
-      return "nodrop";
-    case Cursor::kTypeCopy:
-      return "copy";
-    case Cursor::kTypeNone:
-      return "none";
-    case Cursor::kTypeNotAllowed:
-      return "not-allowed";
-    case Cursor::kTypeZoomIn:
-      return "zoom-in";
-    case Cursor::kTypeZoomOut:
-      return "zoom-out";
-    case Cursor::kTypeGrab:
-      return "grab";
-    case Cursor::kTypeGrabbing:
-      return "grabbing";
-    case Cursor::kTypeCustom:
-      return "custom";
-    default:
-      return "default";
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 2fd937422dacbe184712e341fdb0c22d4fd1d7e0 atom/common/mouse_util.h
  our    100644 efc70eeb7bdfce0d8f4668c57f642b90e08769d4 atom/common/mouse_util.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_MOUSE_UTIL_H_
-#define ATOM_COMMON_MOUSE_UTIL_H_
-
-#include <string>
-#include "content/common/cursors/webcursor.h"
-#include "ipc/ipc_message_macros.h"
-
-// IPC macros similar to the already existing ones in the chromium source.
-// We need these to listen to the cursor change IPC message while still
-// letting chromium handle the actual cursor change by setting handled = false.
-#define IPC_MESSAGE_HANDLER_CODE(msg_class, member_func, code) \
-  IPC_MESSAGE_FORWARD_CODE(msg_class, this,                    \
-                           _IpcMessageHandlerClass::member_func, code)
-
-#define IPC_MESSAGE_FORWARD_CODE(msg_class, obj, member_func, code) \
-  case msg_class::ID: {                                             \
-    if (!msg_class::Dispatch(&ipc_message__, obj, this, param__,    \
-                             &member_func))                         \
-      ipc_message__.set_dispatch_error();                           \
-    code;                                                           \
-  } break;
-
-namespace atom {
-
-// Returns the cursor's type as a string.
-std::string CursorTypeToString(const content::CursorInfo& info);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_MOUSE_UTIL_H_
removed in remote
  base   100644 15eaafda2e3d51815f1398f6e510c0787d2bdf25 atom/common/native_mate_converters/accelerator_converter.cc
  our    100644 0958308871175b0afaa9f3ed450d77b437a0d317 atom/common/native_mate_converters/accelerator_converter.cc
@@ -1,23 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/accelerator_converter.h"
-
-#include <string>
-
-#include "atom/browser/ui/accelerator_util.h"
-
-namespace mate {
-
-// static
-bool Converter<ui::Accelerator>::FromV8(v8::Isolate* isolate,
-                                        v8::Local<v8::Value> val,
-                                        ui::Accelerator* out) {
-  std::string keycode;
-  if (!ConvertFromV8(isolate, val, &keycode))
-    return false;
-  return accelerator_util::StringToAccelerator(keycode, out);
-}
-
-}  // namespace mate
removed in remote
  base   100644 499077c08e287e6084356f0f216a54264d628f57 atom/common/native_mate_converters/accelerator_converter.h
  our    100644 f2f6b56e9851883fa45f0e0566de7318cc288f67 atom/common/native_mate_converters/accelerator_converter.h
@@ -1,25 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace ui {
-class Accelerator;
-}
-
-namespace mate {
-
-template <>
-struct Converter<ui::Accelerator> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     ui::Accelerator* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
removed in remote
  base   100644 c58f830eb02e68eb2d06889cd026dbd3768673f2 atom/common/native_mate_converters/blink_converter.cc
  our    100644 f52ec9af2e405f3969453ac22cb402436610c317 atom/common/native_mate_converters/blink_converter.cc
@@ -1,544 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/blink_converter.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/common/keyboard_util.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "content/public/browser/native_web_keyboard_event.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/platform/WebMouseEvent.h"
-#include "third_party/WebKit/public/platform/WebMouseWheelEvent.h"
-#include "third_party/WebKit/public/web/WebDeviceEmulationParams.h"
-#include "third_party/WebKit/public/web/WebFindOptions.h"
-#include "ui/base/clipboard/clipboard.h"
-#include "ui/events/keycodes/dom/keycode_converter.h"
-#include "ui/events/keycodes/keyboard_code_conversion.h"
-
-namespace {
-
-template <typename T>
-int VectorToBitArray(const std::vector<T>& vec) {
-  int bits = 0;
-  for (const T& item : vec)
-    bits |= item;
-  return bits;
-}
-
-}  // namespace
-
-namespace mate {
-
-template <>
-struct Converter<base::char16> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     base::char16* out) {
-    base::string16 code = base::UTF8ToUTF16(V8ToString(val));
-    if (code.length() != 1)
-      return false;
-    *out = code[0];
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebInputEvent::Type> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebInputEvent::Type* out) {
-    std::string type = base::ToLowerASCII(V8ToString(val));
-    if (type == "mousedown")
-      *out = blink::WebInputEvent::kMouseDown;
-    else if (type == "mouseup")
-      *out = blink::WebInputEvent::kMouseUp;
-    else if (type == "mousemove")
-      *out = blink::WebInputEvent::kMouseMove;
-    else if (type == "mouseenter")
-      *out = blink::WebInputEvent::kMouseEnter;
-    else if (type == "mouseleave")
-      *out = blink::WebInputEvent::kMouseLeave;
-    else if (type == "contextmenu")
-      *out = blink::WebInputEvent::kContextMenu;
-    else if (type == "mousewheel")
-      *out = blink::WebInputEvent::kMouseWheel;
-    else if (type == "keydown")
-      *out = blink::WebInputEvent::kRawKeyDown;
-    else if (type == "keyup")
-      *out = blink::WebInputEvent::kKeyUp;
-    else if (type == "char")
-      *out = blink::WebInputEvent::kChar;
-    else if (type == "touchstart")
-      *out = blink::WebInputEvent::kTouchStart;
-    else if (type == "touchmove")
-      *out = blink::WebInputEvent::kTouchMove;
-    else if (type == "touchend")
-      *out = blink::WebInputEvent::kTouchEnd;
-    else if (type == "touchcancel")
-      *out = blink::WebInputEvent::kTouchCancel;
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebMouseEvent::Button> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebMouseEvent::Button* out) {
-    std::string button = base::ToLowerASCII(V8ToString(val));
-    if (button == "left")
-      *out = blink::WebMouseEvent::Button::kLeft;
-    else if (button == "middle")
-      *out = blink::WebMouseEvent::Button::kMiddle;
-    else if (button == "right")
-      *out = blink::WebMouseEvent::Button::kRight;
-    else
-      return false;
-    return true;
-  }
-};
-
-template <>
-struct Converter<blink::WebInputEvent::Modifiers> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Handle<v8::Value> val,
-                     blink::WebInputEvent::Modifiers* out) {
-    std::string modifier = base::ToLowerASCII(V8ToString(val));
-    if (modifier == "shift")
-      *out = blink::WebInputEvent::kShiftKey;
-    else if (modifier == "control" || modifier == "ctrl")
-      *out = blink::WebInputEvent::kControlKey;
-    else if (modifier == "alt")
-      *out = blink::WebInputEvent::kAltKey;
-    else if (modifier == "meta" || modifier == "command" || modifier == "cmd")
-      *out = blink::WebInputEvent::kMetaKey;
-    else if (modifier == "iskeypad")
-      *out = blink::WebInputEvent::kIsKeyPad;
-    else if (modifier == "isautorepeat")
-      *out = blink::WebInputEvent::kIsAutoRepeat;
-    else if (modifier == "leftbuttondown")
-      *out = blink::WebInputEvent::kLeftButtonDown;
-    else if (modifier == "middlebuttondown")
-      *out = blink::WebInputEvent::kMiddleButtonDown;
-    else if (modifier == "rightbuttondown")
-      *out = blink::WebInputEvent::kRightButtonDown;
-    else if (modifier == "capslock")
-      *out = blink::WebInputEvent::kCapsLockOn;
-    else if (modifier == "numlock")
-      *out = blink::WebInputEvent::kNumLockOn;
-    else if (modifier == "left")
-      *out = blink::WebInputEvent::kIsLeft;
-    else if (modifier == "right")
-      *out = blink::WebInputEvent::kIsRight;
-    return true;
-  }
-};
-
-blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val) {
-  blink::WebInputEvent::Type type = blink::WebInputEvent::kUndefined;
-  mate::Dictionary dict;
-  ConvertFromV8(isolate, val, &dict) && dict.Get("type", &type);
-  return type;
-}
-
-bool Converter<blink::WebInputEvent>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebInputEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  blink::WebInputEvent::Type type;
-  if (!dict.Get("type", &type))
-    return false;
-  out->SetType(type);
-  std::vector<blink::WebInputEvent::Modifiers> modifiers;
-  if (dict.Get("modifiers", &modifiers))
-    out->SetModifiers(VectorToBitArray(modifiers));
-  out->SetTimeStampSeconds(base::Time::Now().ToDoubleT());
-  return true;
-}
-
-bool Converter<blink::WebKeyboardEvent>::FromV8(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val,
-                                                blink::WebKeyboardEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
-    return false;
-
-  std::string str;
-  if (!dict.Get("keyCode", &str))
-    return false;
-
-  bool shifted = false;
-  ui::KeyboardCode keyCode = atom::KeyboardCodeFromStr(str, &shifted);
-  out->windows_key_code = keyCode;
-  if (shifted)
-    out->SetModifiers(out->GetModifiers() | blink::WebInputEvent::kShiftKey);
-
-  ui::DomCode domCode = ui::UsLayoutKeyboardCodeToDomCode(keyCode);
-  out->dom_code = static_cast<int>(domCode);
-
-  ui::DomKey domKey;
-  ui::KeyboardCode dummy_code;
-  int flags = atom::WebEventModifiersToEventFlags(out->GetModifiers());
-  if (ui::DomCodeToUsLayoutDomKey(domCode, flags, &domKey, &dummy_code))
-    out->dom_key = static_cast<int>(domKey);
-
-  if ((out->GetType() == blink::WebInputEvent::kChar ||
-       out->GetType() == blink::WebInputEvent::kRawKeyDown)) {
-    // Make sure to not read beyond the buffer in case some bad code doesn't
-    // NULL-terminate it (this is called from plugins).
-    size_t text_length_cap = blink::WebKeyboardEvent::kTextLengthCap;
-    base::string16 text16 = base::UTF8ToUTF16(str);
-
-    memset(out->text, 0, text_length_cap);
-    memset(out->unmodified_text, 0, text_length_cap);
-    for (size_t i = 0; i < std::min(text_length_cap, text16.size()); ++i) {
-      out->text[i] = text16[i];
-      out->unmodified_text[i] = text16[i];
-    }
-  }
-  return true;
-}
-
-bool Converter<content::NativeWebKeyboardEvent>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    content::NativeWebKeyboardEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebKeyboardEvent*>(out)))
-    return false;
-  dict.Get("skipInBrowser", &out->skip_in_browser);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<content::NativeWebKeyboardEvent>::ToV8(
-    v8::Isolate* isolate,
-    const content::NativeWebKeyboardEvent& in) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-
-  if (in.GetType() == blink::WebInputEvent::Type::kRawKeyDown)
-    dict.Set("type", "keyDown");
-  else if (in.GetType() == blink::WebInputEvent::Type::kKeyUp)
-    dict.Set("type", "keyUp");
-  dict.Set("key", ui::KeycodeConverter::DomKeyToKeyString(in.dom_key));
-  dict.Set("code", ui::KeycodeConverter::DomCodeToCodeString(
-                       static_cast<ui::DomCode>(in.dom_code)));
-
-  using Modifiers = blink::WebInputEvent::Modifiers;
-  dict.Set("isAutoRepeat", (in.GetModifiers() & Modifiers::kIsAutoRepeat) != 0);
-  dict.Set("shift", (in.GetModifiers() & Modifiers::kShiftKey) != 0);
-  dict.Set("control", (in.GetModifiers() & Modifiers::kControlKey) != 0);
-  dict.Set("alt", (in.GetModifiers() & Modifiers::kAltKey) != 0);
-  dict.Set("meta", (in.GetModifiers() & Modifiers::kMetaKey) != 0);
-
-  return dict.GetHandle();
-}
-
-bool Converter<blink::WebMouseEvent>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebMouseEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
-    return false;
-
-  float x = 0.f;
-  float y = 0.f;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  out->SetPositionInWidget(x, y);
-
-  if (!dict.Get("button", &out->button))
-    out->button = blink::WebMouseEvent::Button::kLeft;
-
-  float global_x = 0.f;
-  float global_y = 0.f;
-  dict.Get("globalX", &global_x);
-  dict.Get("globalY", &global_y);
-  out->SetPositionInScreen(global_x, global_y);
-
-  dict.Get("movementX", &out->movement_x);
-  dict.Get("movementY", &out->movement_y);
-  dict.Get("clickCount", &out->click_count);
-  return true;
-}
-
-bool Converter<blink::WebMouseWheelEvent>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::WebMouseWheelEvent* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  if (!ConvertFromV8(isolate, val, static_cast<blink::WebMouseEvent*>(out)))
-    return false;
-  dict.Get("deltaX", &out->delta_x);
-  dict.Get("deltaY", &out->delta_y);
-  dict.Get("wheelTicksX", &out->wheel_ticks_x);
-  dict.Get("wheelTicksY", &out->wheel_ticks_y);
-  dict.Get("accelerationRatioX", &out->acceleration_ratio_x);
-  dict.Get("accelerationRatioY", &out->acceleration_ratio_y);
-  dict.Get("hasPreciseScrollingDeltas", &out->has_precise_scrolling_deltas);
-
-#if defined(USE_AURA)
-  // Matches the behavior of ui/events/blink/web_input_event_traits.cc:
-  bool can_scroll = true;
-  if (dict.Get("canScroll", &can_scroll) && !can_scroll) {
-    out->has_precise_scrolling_deltas = false;
-    out->SetModifiers(out->GetModifiers() & ~blink::WebInputEvent::kControlKey);
-  }
-#endif
-  return true;
-}
-
-bool Converter<blink::WebFloatPoint>::FromV8(v8::Isolate* isolate,
-                                             v8::Local<v8::Value> val,
-                                             blink::WebFloatPoint* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
-}
-
-template <>
-struct Converter<base::Optional<blink::WebPoint>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::Optional<blink::WebPoint>* out) {
-    mate::Dictionary dict;
-    if (!ConvertFromV8(isolate, val, &dict))
-      return false;
-    blink::WebPoint point;
-    bool success = dict.Get("x", &point.x) && dict.Get("y", &point.y);
-    if (!success)
-      return false;
-    out->emplace(point);
-    return true;
-  }
-};
-
-bool Converter<blink::WebSize>::FromV8(v8::Isolate* isolate,
-                                       v8::Local<v8::Value> val,
-                                       blink::WebSize* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  return dict.Get("width", &out->width) && dict.Get("height", &out->height);
-}
-
-bool Converter<blink::WebDeviceEmulationParams>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::WebDeviceEmulationParams* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  std::string screen_position;
-  if (dict.Get("screenPosition", &screen_position)) {
-    screen_position = base::ToLowerASCII(screen_position);
-    if (screen_position == "mobile")
-      out->screen_position = blink::WebDeviceEmulationParams::kMobile;
-    else if (screen_position == "desktop")
-      out->screen_position = blink::WebDeviceEmulationParams::kDesktop;
-    else
-      return false;
-  }
-
-  dict.Get("screenSize", &out->screen_size);
-  dict.Get("viewPosition", &out->view_position);
-  dict.Get("deviceScaleFactor", &out->device_scale_factor);
-  dict.Get("viewSize", &out->view_size);
-  dict.Get("scale", &out->scale);
-  return true;
-}
-
-bool Converter<blink::WebFindOptions>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              blink::WebFindOptions* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  dict.Get("forward", &out->forward);
-  dict.Get("matchCase", &out->match_case);
-  dict.Get("findNext", &out->find_next);
-  dict.Get("wordStart", &out->word_start);
-  dict.Get("medialCapitalAsWordStart", &out->medial_capital_as_word_start);
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebContextMenuData::MediaType>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebContextMenuData::MediaType& in) {
-  switch (in) {
-    case blink::WebContextMenuData::kMediaTypeImage:
-      return mate::StringToV8(isolate, "image");
-    case blink::WebContextMenuData::kMediaTypeVideo:
-      return mate::StringToV8(isolate, "video");
-    case blink::WebContextMenuData::kMediaTypeAudio:
-      return mate::StringToV8(isolate, "audio");
-    case blink::WebContextMenuData::kMediaTypeCanvas:
-      return mate::StringToV8(isolate, "canvas");
-    case blink::WebContextMenuData::kMediaTypeFile:
-      return mate::StringToV8(isolate, "file");
-    case blink::WebContextMenuData::kMediaTypePlugin:
-      return mate::StringToV8(isolate, "plugin");
-    default:
-      return mate::StringToV8(isolate, "none");
-  }
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebContextMenuData::InputFieldType>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebContextMenuData::InputFieldType& in) {
-  switch (in) {
-    case blink::WebContextMenuData::kInputFieldTypePlainText:
-      return mate::StringToV8(isolate, "plainText");
-    case blink::WebContextMenuData::kInputFieldTypePassword:
-      return mate::StringToV8(isolate, "password");
-    case blink::WebContextMenuData::kInputFieldTypeOther:
-      return mate::StringToV8(isolate, "other");
-    default:
-      return mate::StringToV8(isolate, "none");
-  }
-}
-
-v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("canUndo", !!(editFlags & blink::WebContextMenuData::kCanUndo));
-  dict.Set("canRedo", !!(editFlags & blink::WebContextMenuData::kCanRedo));
-  dict.Set("canCut", !!(editFlags & blink::WebContextMenuData::kCanCut));
-  dict.Set("canCopy", !!(editFlags & blink::WebContextMenuData::kCanCopy));
-
-  bool pasteFlag = false;
-  if (editFlags & blink::WebContextMenuData::kCanPaste) {
-    std::vector<base::string16> types;
-    bool ignore;
-    ui::Clipboard::GetForCurrentThread()->ReadAvailableTypes(
-        ui::CLIPBOARD_TYPE_COPY_PASTE, &types, &ignore);
-    pasteFlag = !types.empty();
-  }
-  dict.Set("canPaste", pasteFlag);
-
-  dict.Set("canDelete", !!(editFlags & blink::WebContextMenuData::kCanDelete));
-  dict.Set("canSelectAll",
-           !!(editFlags & blink::WebContextMenuData::kCanSelectAll));
-
-  return mate::ConvertToV8(isolate, dict);
-}
-
-v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("inError",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaInError));
-  dict.Set("isPaused",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaPaused));
-  dict.Set("isMuted", !!(mediaFlags & blink::WebContextMenuData::kMediaMuted));
-  dict.Set("hasAudio",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaHasAudio));
-  dict.Set("isLooping",
-           (mediaFlags & blink::WebContextMenuData::kMediaLoop) != 0);
-  dict.Set("isControlsVisible",
-           (mediaFlags & blink::WebContextMenuData::kMediaControls) != 0);
-  dict.Set("canToggleControls",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaCanToggleControls));
-  dict.Set("canRotate",
-           !!(mediaFlags & blink::WebContextMenuData::kMediaCanRotate));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-v8::Local<v8::Value> Converter<blink::WebCache::ResourceTypeStat>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebCache::ResourceTypeStat& stat) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("count", static_cast<uint32_t>(stat.count));
-  dict.Set("size", static_cast<double>(stat.size));
-  dict.Set("liveSize", static_cast<double>(stat.decoded_size));
-  return dict.GetHandle();
-}
-
-v8::Local<v8::Value> Converter<blink::WebCache::ResourceTypeStats>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebCache::ResourceTypeStats& stats) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("images", stats.images);
-  dict.Set("scripts", stats.scripts);
-  dict.Set("cssStyleSheets", stats.css_style_sheets);
-  dict.Set("xslStyleSheets", stats.xsl_style_sheets);
-  dict.Set("fonts", stats.fonts);
-  dict.Set("other", stats.other);
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> Converter<blink::WebReferrerPolicy>::ToV8(
-    v8::Isolate* isolate,
-    const blink::WebReferrerPolicy& in) {
-  switch (in) {
-    case blink::kWebReferrerPolicyDefault:
-      return mate::StringToV8(isolate, "default");
-    case blink::kWebReferrerPolicyAlways:
-      return mate::StringToV8(isolate, "unsafe-url");
-    case blink::kWebReferrerPolicyNoReferrerWhenDowngrade:
-      return mate::StringToV8(isolate, "no-referrer-when-downgrade");
-    case blink::kWebReferrerPolicyNever:
-      return mate::StringToV8(isolate, "no-referrer");
-    case blink::kWebReferrerPolicyOrigin:
-      return mate::StringToV8(isolate, "origin");
-    case blink::kWebReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin:
-      return mate::StringToV8(isolate, "strict-origin-when-cross-origin");
-    case blink::kWebReferrerPolicySameOrigin:
-      return mate::StringToV8(isolate, "same-origin");
-    case blink::kWebReferrerPolicyStrictOrigin:
-      return mate::StringToV8(isolate, "strict-origin");
-    default:
-      return mate::StringToV8(isolate, "no-referrer");
-  }
-}
-
-// static
-bool Converter<blink::WebReferrerPolicy>::FromV8(
-    v8::Isolate* isolate,
-    v8::Handle<v8::Value> val,
-    blink::WebReferrerPolicy* out) {
-  std::string policy = base::ToLowerASCII(V8ToString(val));
-  if (policy == "default")
-    *out = blink::kWebReferrerPolicyDefault;
-  else if (policy == "unsafe-url")
-    *out = blink::kWebReferrerPolicyAlways;
-  else if (policy == "no-referrer-when-downgrade")
-    *out = blink::kWebReferrerPolicyNoReferrerWhenDowngrade;
-  else if (policy == "no-referrer")
-    *out = blink::kWebReferrerPolicyNever;
-  else if (policy == "origin")
-    *out = blink::kWebReferrerPolicyOrigin;
-  else if (policy == "strict-origin-when-cross-origin")
-    *out =
-        blink::kWebReferrerPolicyNoReferrerWhenDowngradeOriginWhenCrossOrigin;
-  else if (policy == "same-origin")
-    *out = blink::kWebReferrerPolicySameOrigin;
-  else if (policy == "strict-origin")
-    *out = blink::kWebReferrerPolicyStrictOrigin;
-  else
-    return false;
-  return true;
-}
-
-}  // namespace mate
removed in remote
  base   100644 6a3601929214f42ddef1597dfb230ab6269fc4fb atom/common/native_mate_converters/blink_converter.h
  our    100644 5e6315d9b2499fd1e0853b8bd4258b887d222b21 atom/common/native_mate_converters/blink_converter.h
@@ -1,147 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
-
-#include "native_mate/converter.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-#include "third_party/WebKit/public/platform/WebInputEvent.h"
-#include "third_party/WebKit/public/web/WebContextMenuData.h"
-
-namespace blink {
-class WebMouseEvent;
-class WebMouseWheelEvent;
-class WebKeyboardEvent;
-struct WebDeviceEmulationParams;
-struct WebFindOptions;
-struct WebFloatPoint;
-struct WebPoint;
-struct WebSize;
-}  // namespace blink
-
-namespace content {
-struct NativeWebKeyboardEvent;
-}
-
-namespace mate {
-
-blink::WebInputEvent::Type GetWebInputEventType(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val);
-
-template <>
-struct Converter<blink::WebInputEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebInputEvent* out);
-};
-
-template <>
-struct Converter<blink::WebKeyboardEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebKeyboardEvent* out);
-};
-
-template <>
-struct Converter<content::NativeWebKeyboardEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::NativeWebKeyboardEvent* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::NativeWebKeyboardEvent& in);
-};
-
-template <>
-struct Converter<blink::WebMouseEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebMouseEvent* out);
-};
-
-template <>
-struct Converter<blink::WebMouseWheelEvent> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebMouseWheelEvent* out);
-};
-
-template <>
-struct Converter<blink::WebFloatPoint> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebFloatPoint* out);
-};
-
-template <>
-struct Converter<blink::WebPoint> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebPoint* out);
-};
-
-template <>
-struct Converter<blink::WebSize> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebSize* out);
-};
-
-template <>
-struct Converter<blink::WebDeviceEmulationParams> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebDeviceEmulationParams* out);
-};
-
-template <>
-struct Converter<blink::WebFindOptions> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebFindOptions* out);
-};
-
-template <>
-struct Converter<blink::WebContextMenuData::MediaType> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebContextMenuData::MediaType& in);
-};
-
-template <>
-struct Converter<blink::WebContextMenuData::InputFieldType> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebContextMenuData::InputFieldType& in);
-};
-
-template <>
-struct Converter<blink::WebCache::ResourceTypeStat> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebCache::ResourceTypeStat& stat);
-};
-
-template <>
-struct Converter<blink::WebCache::ResourceTypeStats> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const blink::WebCache::ResourceTypeStats& stats);
-};
-
-template <>
-struct Converter<blink::WebReferrerPolicy> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const blink::WebReferrerPolicy& in);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebReferrerPolicy* out);
-};
-
-v8::Local<v8::Value> EditFlagsToV8(v8::Isolate* isolate, int editFlags);
-v8::Local<v8::Value> MediaFlagsToV8(v8::Isolate* isolate, int mediaFlags);
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
removed in remote
  base   100644 8bf5c459b0a2902638d09edd1b40355fa3ad9188 atom/common/native_mate_converters/callback.cc
  our    100644 f33cec720ea5df1c17c8d02d4aa2b70d2979e13b atom/common/native_mate_converters/callback.cc
@@ -1,127 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/callback.h"
-
-using content::BrowserThread;
-
-namespace mate {
-
-namespace internal {
-
-namespace {
-
-struct TranslaterHolder {
-  Translater translater;
-};
-
-// Cached JavaScript version of |CallTranslater|.
-v8::Persistent<v8::FunctionTemplate> g_call_translater;
-
-void CallTranslater(v8::Local<v8::External> external,
-                    v8::Local<v8::Object> state,
-                    mate::Arguments* args) {
-  v8::Isolate* isolate = args->isolate();
-
-  // Check if the callback has already been called.
-  v8::Local<v8::String> called_symbol = mate::StringToSymbol(isolate, "called");
-  if (state->Has(called_symbol)) {
-    args->ThrowError("callback can only be called for once");
-    return;
-  } else {
-    state->Set(called_symbol, v8::Boolean::New(isolate, true));
-  }
-
-  TranslaterHolder* holder = static_cast<TranslaterHolder*>(external->Value());
-  holder->translater.Run(args);
-  delete holder;
-}
-
-}  // namespace
-
-// Destroy the class on UI thread when possible.
-struct DeleteOnUIThread {
-  template <typename T>
-  static void Destruct(const T* x) {
-    if (Locker::IsBrowserProcess() &&
-        !BrowserThread::CurrentlyOn(BrowserThread::UI)) {
-      BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, x);
-    } else {
-      delete x;
-    }
-  }
-};
-
-// Like v8::Global, but ref-counted.
-template <typename T>
-class RefCountedGlobal
-    : public base::RefCountedThreadSafe<RefCountedGlobal<T>, DeleteOnUIThread> {
- public:
-  RefCountedGlobal(v8::Isolate* isolate, v8::Local<v8::Value> value)
-      : handle_(isolate, v8::Local<T>::Cast(value)) {}
-
-  bool IsAlive() const { return !handle_.IsEmpty(); }
-
-  v8::Local<T> NewHandle(v8::Isolate* isolate) const {
-    return v8::Local<T>::New(isolate, handle_);
-  }
-
- private:
-  v8::Global<T> handle_;
-
-  DISALLOW_COPY_AND_ASSIGN(RefCountedGlobal);
-};
-
-SafeV8Function::SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value)
-    : v8_function_(new RefCountedGlobal<v8::Function>(isolate, value)) {}
-
-SafeV8Function::SafeV8Function(const SafeV8Function& other)
-    : v8_function_(other.v8_function_) {}
-
-SafeV8Function::~SafeV8Function() {}
-
-bool SafeV8Function::IsAlive() const {
-  return v8_function_.get() && v8_function_->IsAlive();
-}
-
-v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
-  return v8_function_->NewHandle(isolate);
-}
-
-v8::Local<v8::Value> CreateFunctionFromTranslater(
-    v8::Isolate* isolate,
-    const Translater& translater) {
-  // The FunctionTemplate is cached.
-  if (g_call_translater.IsEmpty())
-    g_call_translater.Reset(isolate, mate::CreateFunctionTemplate(
-                                         isolate, base::Bind(&CallTranslater)));
-
-  v8::Local<v8::FunctionTemplate> call_translater =
-      v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
-  auto* holder = new TranslaterHolder;
-  holder->translater = translater;
-  return BindFunctionWith(
-      isolate, isolate->GetCurrentContext(), call_translater->GetFunction(),
-      v8::External::New(isolate, holder), v8::Object::New(isolate));
-}
-
-// func.bind(func, arg1).
-// NB(zcbenz): Using C++11 version crashes VS.
-v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
-                                      v8::Local<v8::Context> context,
-                                      v8::Local<v8::Function> func,
-                                      v8::Local<v8::Value> arg1,
-                                      v8::Local<v8::Value> arg2) {
-  v8::MaybeLocal<v8::Value> bind = func->Get(mate::StringToV8(isolate, "bind"));
-  CHECK(!bind.IsEmpty());
-  v8::Local<v8::Function> bind_func =
-      v8::Local<v8::Function>::Cast(bind.ToLocalChecked());
-  v8::Local<v8::Value> converted[] = {func, arg1, arg2};
-  return bind_func->Call(context, func, arraysize(converted), converted)
-      .ToLocalChecked();
-}
-
-}  // namespace internal
-
-}  // namespace mate
removed in remote
  base   100644 6ef8e74c735a9ae3cef88dff0b1075faa4407c64 atom/common/native_mate_converters/callback.h
  our    100644 06140a3a7a7a928143e44e22113288b514409929 atom/common/native_mate_converters/callback.h
@@ -1,173 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc. All rights reserved.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
-
-#include <vector>
-
-#include "atom/common/api/locker.h"
-#include "base/bind.h"
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "base/message_loop/message_loop.h"
-#include "content/public/browser/browser_thread.h"
-#include "native_mate/function_template.h"
-#include "native_mate/scoped_persistent.h"
-
-namespace mate {
-
-namespace internal {
-
-template <typename T>
-class RefCountedGlobal;
-
-// Manages the V8 function with RAII.
-class SafeV8Function {
- public:
-  SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value);
-  SafeV8Function(const SafeV8Function& other);
-  ~SafeV8Function();
-
-  bool IsAlive() const;
-  v8::Local<v8::Function> NewHandle(v8::Isolate* isolate) const;
-
- private:
-  scoped_refptr<RefCountedGlobal<v8::Function>> v8_function_;
-};
-
-// Helper to invoke a V8 function with C++ parameters.
-template <typename Sig>
-struct V8FunctionInvoker {};
-
-template <typename... ArgTypes>
-struct V8FunctionInvoker<v8::Local<v8::Value>(ArgTypes...)> {
-  static v8::Local<v8::Value> Go(v8::Isolate* isolate,
-                                 const SafeV8Function& function,
-                                 ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::EscapableHandleScope handle_scope(isolate);
-    if (!function.IsAlive())
-      return v8::Null(isolate);
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    v8::Local<v8::Value> ret(holder->Call(
-        holder, args.size(), args.empty() ? nullptr : &args.front()));
-    return handle_scope.Escape(ret);
-  }
-};
-
-template <typename... ArgTypes>
-struct V8FunctionInvoker<void(ArgTypes...)> {
-  static void Go(v8::Isolate* isolate,
-                 const SafeV8Function& function,
-                 ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    if (!function.IsAlive())
-      return;
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    holder->Call(holder, args.size(), args.empty() ? nullptr : &args.front());
-  }
-};
-
-template <typename ReturnType, typename... ArgTypes>
-struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
-  static ReturnType Go(v8::Isolate* isolate,
-                       const SafeV8Function& function,
-                       ArgTypes... raw) {
-    Locker locker(isolate);
-    v8::HandleScope handle_scope(isolate);
-    ReturnType ret = ReturnType();
-    if (!function.IsAlive())
-      return ret;
-    v8::MicrotasksScope script_scope(isolate,
-                                     v8::MicrotasksScope::kRunMicrotasks);
-    v8::Local<v8::Function> holder = function.NewHandle(isolate);
-    v8::Local<v8::Context> context = holder->CreationContext();
-    v8::Context::Scope context_scope(context);
-    std::vector<v8::Local<v8::Value>> args{ConvertToV8(isolate, raw)...};
-    v8::Local<v8::Value> result;
-    auto maybe_result = holder->Call(context, holder, args.size(),
-                                     args.empty() ? nullptr : &args.front());
-    if (maybe_result.ToLocal(&result))
-      Converter<ReturnType>::FromV8(isolate, result, &ret);
-    return ret;
-  }
-};
-
-// Helper to pass a C++ funtion to JavaScript.
-using Translater = base::Callback<void(Arguments* args)>;
-v8::Local<v8::Value> CreateFunctionFromTranslater(v8::Isolate* isolate,
-                                                  const Translater& translater);
-v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
-                                      v8::Local<v8::Context> context,
-                                      v8::Local<v8::Function> func,
-                                      v8::Local<v8::Value> arg1,
-                                      v8::Local<v8::Value> arg2);
-
-// Calls callback with Arguments.
-template <typename Sig>
-struct NativeFunctionInvoker {};
-
-template <typename ReturnType, typename... ArgTypes>
-struct NativeFunctionInvoker<ReturnType(ArgTypes...)> {
-  static void Go(base::Callback<ReturnType(ArgTypes...)> val, Arguments* args) {
-    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
-    Invoker<Indices, ArgTypes...> invoker(args, 0);
-    if (invoker.IsOK())
-      invoker.DispatchToCallback(val);
-  }
-};
-
-}  // namespace internal
-
-template <typename Sig>
-struct Converter<base::OnceCallback<Sig>> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::OnceCallback<Sig>* out) {
-    if (!val->IsFunction())
-      return false;
-
-    *out = base::BindOnce(&internal::V8FunctionInvoker<Sig>::Go, isolate,
-                          internal::SafeV8Function(isolate, val));
-    return true;
-  }
-};
-
-template <typename Sig>
-struct Converter<base::RepeatingCallback<Sig>> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::RepeatingCallback<Sig>& val) {
-    // We don't use CreateFunctionTemplate here because it creates a new
-    // FunctionTemplate everytime, which is cached by V8 and causes leaks.
-    internal::Translater translater =
-        base::BindRepeating(&internal::NativeFunctionInvoker<Sig>::Go, val);
-    return internal::CreateFunctionFromTranslater(isolate, translater);
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::RepeatingCallback<Sig>* out) {
-    if (!val->IsFunction())
-      return false;
-
-    *out = base::BindRepeating(&internal::V8FunctionInvoker<Sig>::Go, isolate,
-                               internal::SafeV8Function(isolate, val));
-    return true;
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
removed in remote
  base   100644 f5d81d085bc1a1ca7f9efa3c48d0ef3d05d88af9 atom/common/native_mate_converters/content_converter.cc
  our    100644 2684aa7dda07ac79e47823c3cf9bf00d3f5cf3f5 atom/common/native_mate_converters/content_converter.cc
@@ -1,251 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/content_converter.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/browser/api/atom_api_web_contents.h"
-#include "atom/browser/web_contents_permission_helper.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/ui_base_types_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "content/public/browser/web_contents.h"
-#include "content/public/common/context_menu_params.h"
-#include "native_mate/dictionary.h"
-
-namespace {
-
-void ExecuteCommand(content::WebContents* web_contents,
-                    int action,
-                    const content::CustomContextMenuContext& context) {
-  web_contents->ExecuteCustomContextMenuCommand(action, context);
-}
-
-// Forward declaration for nested recursive call.
-v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
-                              content::WebContents* web_contents,
-                              const content::CustomContextMenuContext& context,
-                              const std::vector<content::MenuItem>& menu);
-
-v8::Local<v8::Value> MenuItemToV8(
-    v8::Isolate* isolate,
-    content::WebContents* web_contents,
-    const content::CustomContextMenuContext& context,
-    const content::MenuItem& item) {
-  mate::Dictionary v8_item = mate::Dictionary::CreateEmpty(isolate);
-  switch (item.type) {
-    case content::MenuItem::CHECKABLE_OPTION:
-    case content::MenuItem::GROUP:
-      v8_item.Set("checked", item.checked);
-      FALLTHROUGH;
-    case content::MenuItem::OPTION:
-    case content::MenuItem::SUBMENU:
-      v8_item.Set("label", item.label);
-      v8_item.Set("enabled", item.enabled);
-      FALLTHROUGH;
-    default:
-      v8_item.Set("type", item.type);
-  }
-  if (item.type == content::MenuItem::SUBMENU)
-    v8_item.Set("submenu",
-                MenuToV8(isolate, web_contents, context, item.submenu));
-  else if (item.action > 0)
-    v8_item.Set("click",
-                base::Bind(ExecuteCommand, web_contents, item.action, context));
-  return v8_item.GetHandle();
-}
-
-v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
-                              content::WebContents* web_contents,
-                              const content::CustomContextMenuContext& context,
-                              const std::vector<content::MenuItem>& menu) {
-  std::vector<v8::Local<v8::Value>> v8_menu;
-  for (const auto& menu_item : menu)
-    v8_menu.push_back(MenuItemToV8(isolate, web_contents, context, menu_item));
-  return mate::ConvertToV8(isolate, v8_menu);
-}
-
-}  // namespace
-
-namespace mate {
-
-// static
-v8::Local<v8::Value> Converter<content::MenuItem::Type>::ToV8(
-    v8::Isolate* isolate,
-    const content::MenuItem::Type& val) {
-  switch (val) {
-    case content::MenuItem::CHECKABLE_OPTION:
-      return StringToV8(isolate, "checkbox");
-    case content::MenuItem::GROUP:
-      return StringToV8(isolate, "radio");
-    case content::MenuItem::SEPARATOR:
-      return StringToV8(isolate, "separator");
-    case content::MenuItem::SUBMENU:
-      return StringToV8(isolate, "submenu");
-    case content::MenuItem::OPTION:
-    default:
-      return StringToV8(isolate, "normal");
-  }
-}
-
-// static
-v8::Local<v8::Value> Converter<ContextMenuParamsWithWebContents>::ToV8(
-    v8::Isolate* isolate,
-    const ContextMenuParamsWithWebContents& val) {
-  const auto& params = val.first;
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("x", params.x);
-  dict.Set("y", params.y);
-  dict.Set("linkURL", params.link_url);
-  dict.Set("linkText", params.link_text);
-  dict.Set("pageURL", params.page_url);
-  dict.Set("frameURL", params.frame_url);
-  dict.Set("srcURL", params.src_url);
-  dict.Set("mediaType", params.media_type);
-  dict.Set("mediaFlags", MediaFlagsToV8(isolate, params.media_flags));
-  bool has_image_contents =
-      (params.media_type == blink::WebContextMenuData::kMediaTypeImage) &&
-      params.has_image_contents;
-  dict.Set("hasImageContents", has_image_contents);
-  dict.Set("isEditable", params.is_editable);
-  dict.Set("editFlags", EditFlagsToV8(isolate, params.edit_flags));
-  dict.Set("selectionText", params.selection_text);
-  dict.Set("titleText", params.title_text);
-  dict.Set("misspelledWord", params.misspelled_word);
-  dict.Set("frameCharset", params.frame_charset);
-  dict.Set("inputFieldType", params.input_field_type);
-  dict.Set("menuSourceType", params.source_type);
-
-  if (params.custom_context.is_pepper_menu)
-    dict.Set("menu", MenuToV8(isolate, val.second, params.custom_context,
-                              params.custom_items));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-bool Converter<blink::mojom::PermissionStatus>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    blink::mojom::PermissionStatus* out) {
-  bool result;
-  if (!ConvertFromV8(isolate, val, &result))
-    return false;
-
-  if (result)
-    *out = blink::mojom::PermissionStatus::GRANTED;
-  else
-    *out = blink::mojom::PermissionStatus::DENIED;
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::PermissionType>::ToV8(
-    v8::Isolate* isolate,
-    const content::PermissionType& val) {
-  using PermissionType = atom::WebContentsPermissionHelper::PermissionType;
-  switch (val) {
-    case content::PermissionType::MIDI_SYSEX:
-      return StringToV8(isolate, "midiSysex");
-    case content::PermissionType::NOTIFICATIONS:
-      return StringToV8(isolate, "notifications");
-    case content::PermissionType::GEOLOCATION:
-      return StringToV8(isolate, "geolocation");
-    case content::PermissionType::AUDIO_CAPTURE:
-    case content::PermissionType::VIDEO_CAPTURE:
-      return StringToV8(isolate, "media");
-    case content::PermissionType::PROTECTED_MEDIA_IDENTIFIER:
-      return StringToV8(isolate, "mediaKeySystem");
-    case content::PermissionType::MIDI:
-      return StringToV8(isolate, "midi");
-    default:
-      break;
-  }
-
-  if (val == static_cast<content::PermissionType>(PermissionType::POINTER_LOCK))
-    return StringToV8(isolate, "pointerLock");
-  else if (val ==
-           static_cast<content::PermissionType>(PermissionType::FULLSCREEN))
-    return StringToV8(isolate, "fullscreen");
-  else if (val ==
-           static_cast<content::PermissionType>(PermissionType::OPEN_EXTERNAL))
-    return StringToV8(isolate, "openExternal");
-
-  return StringToV8(isolate, "unknown");
-}
-
-// static
-bool Converter<content::StopFindAction>::FromV8(v8::Isolate* isolate,
-                                                v8::Local<v8::Value> val,
-                                                content::StopFindAction* out) {
-  std::string action;
-  if (!ConvertFromV8(isolate, val, &action))
-    return false;
-
-  if (action == "clearSelection")
-    *out = content::STOP_FIND_ACTION_CLEAR_SELECTION;
-  else if (action == "keepSelection")
-    *out = content::STOP_FIND_ACTION_KEEP_SELECTION;
-  else if (action == "activateSelection")
-    *out = content::STOP_FIND_ACTION_ACTIVATE_SELECTION;
-  else
-    return false;
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::WebContents*>::ToV8(
-    v8::Isolate* isolate,
-    content::WebContents* val) {
-  if (!val)
-    return v8::Null(isolate);
-  return atom::api::WebContents::CreateFrom(isolate, val).ToV8();
-}
-
-// static
-bool Converter<content::WebContents*>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              content::WebContents** out) {
-  atom::api::WebContents* web_contents = nullptr;
-  if (!ConvertFromV8(isolate, val, &web_contents) || !web_contents)
-    return false;
-
-  *out = web_contents->web_contents();
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<content::Referrer>::ToV8(
-    v8::Isolate* isolate,
-    const content::Referrer& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("url", ConvertToV8(isolate, val.url));
-  dict.Set("policy", ConvertToV8(isolate, val.policy));
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-bool Converter<content::Referrer>::FromV8(v8::Isolate* isolate,
-                                          v8::Local<v8::Value> val,
-                                          content::Referrer* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  if (!dict.Get("url", &out->url))
-    return false;
-
-  if (!dict.Get("policy", &out->policy))
-    return false;
-
-  return true;
-}
-
-}  // namespace mate
removed in remote
  base   100644 b1a42b6897ca23ce6ab2442dd2ac1d569e7adc2d atom/common/native_mate_converters/content_converter.h
  our    100644 18a2d5f1a7c8d0f33cb35e575bae7a4b2740d7cd atom/common/native_mate_converters/content_converter.h
@@ -1,79 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
-
-#include <utility>
-
-#include "content/public/browser/permission_type.h"
-#include "content/public/common/menu_item.h"
-#include "content/public/common/referrer.h"
-#include "content/public/common/stop_find_action.h"
-#include "native_mate/converter.h"
-#include "third_party/WebKit/public/platform/modules/permissions/permission_status.mojom.h"
-
-namespace content {
-struct ContextMenuParams;
-class WebContents;
-}  // namespace content
-
-using ContextMenuParamsWithWebContents =
-    std::pair<content::ContextMenuParams, content::WebContents*>;
-
-namespace mate {
-
-template <>
-struct Converter<content::MenuItem::Type> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::MenuItem::Type& val);
-};
-
-template <>
-struct Converter<ContextMenuParamsWithWebContents> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const ContextMenuParamsWithWebContents& val);
-};
-
-template <>
-struct Converter<blink::mojom::PermissionStatus> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::mojom::PermissionStatus* out);
-};
-
-template <>
-struct Converter<content::PermissionType> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::PermissionType& val);
-};
-
-template <>
-struct Converter<content::StopFindAction> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::StopFindAction* out);
-};
-
-template <>
-struct Converter<content::WebContents*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   content::WebContents* val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::WebContents** out);
-};
-
-template <>
-struct Converter<content::Referrer> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const content::Referrer& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     content::Referrer* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
removed in remote
  base   100644 7df1289e243be0f5f8dc9a114b3c98a1ba55ab37 atom/common/native_mate_converters/file_path_converter.h
  our    100644 c283d3370a61dc29724f7e5f5761ee6125eab516 atom/common/native_mate_converters/file_path_converter.h
@@ -1,39 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
-
-#include <string>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/files/file_path.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::FilePath> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::FilePath& val) {
-    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::FilePath* out) {
-    if (val->IsNull())
-      return true;
-
-    base::FilePath::StringType path;
-    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {
-      *out = base::FilePath(path);
-      return true;
-    } else {
-      return false;
-    }
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
removed in remote
  base   100644 37e7aeb3a48becbecd7f5fd61934ac4d178539ca atom/common/native_mate_converters/gfx_converter.cc
  our    100644 7a7cfd39e061837f7772be91b43f5851d8278c00 atom/common/native_mate_converters/gfx_converter.cc
@@ -1,138 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/gfx_converter.h"
-
-#include "native_mate/dictionary.h"
-#include "ui/display/display.h"
-#include "ui/display/screen.h"
-#include "ui/gfx/geometry/point.h"
-#include "ui/gfx/geometry/rect.h"
-#include "ui/gfx/geometry/size.h"
-
-namespace mate {
-
-v8::Local<v8::Value> Converter<gfx::Point>::ToV8(v8::Isolate* isolate,
-                                                 const gfx::Point& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Point>::FromV8(v8::Isolate* isolate,
-                                   v8::Local<v8::Value> val,
-                                   gfx::Point* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int x, y;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  *out = gfx::Point(x, y);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::PointF>::ToV8(v8::Isolate* isolate,
-                                                  const gfx::PointF& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::PointF>::FromV8(v8::Isolate* isolate,
-                                    v8::Local<v8::Value> val,
-                                    gfx::PointF* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  float x, y;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y))
-    return false;
-  *out = gfx::PointF(x, y);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Size>::ToV8(v8::Isolate* isolate,
-                                                const gfx::Size& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("width", val.width());
-  dict.Set("height", val.height());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Size>::FromV8(v8::Isolate* isolate,
-                                  v8::Local<v8::Value> val,
-                                  gfx::Size* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int width, height;
-  if (!dict.Get("width", &width) || !dict.Get("height", &height))
-    return false;
-  *out = gfx::Size(width, height);
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Rect>::ToV8(v8::Isolate* isolate,
-                                                const gfx::Rect& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("x", val.x());
-  dict.Set("y", val.y());
-  dict.Set("width", val.width());
-  dict.Set("height", val.height());
-  return dict.GetHandle();
-}
-
-bool Converter<gfx::Rect>::FromV8(v8::Isolate* isolate,
-                                  v8::Local<v8::Value> val,
-                                  gfx::Rect* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-  int x, y, width, height;
-  if (!dict.Get("x", &x) || !dict.Get("y", &y) || !dict.Get("width", &width) ||
-      !dict.Get("height", &height))
-    return false;
-  *out = gfx::Rect(x, y, width, height);
-  return true;
-}
-
-template <>
-struct Converter<display::Display::TouchSupport> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const display::Display::TouchSupport& val) {
-    switch (val) {
-      case display::Display::TouchSupport::AVAILABLE:
-        return StringToV8(isolate, "available");
-      case display::Display::TouchSupport::UNAVAILABLE:
-        return StringToV8(isolate, "unavailable");
-      default:
-        return StringToV8(isolate, "unknown");
-    }
-  }
-};
-
-v8::Local<v8::Value> Converter<display::Display>::ToV8(
-    v8::Isolate* isolate,
-    const display::Display& val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.SetHidden("simple", true);
-  dict.Set("id", val.id());
-  dict.Set("bounds", val.bounds());
-  dict.Set("workArea", val.work_area());
-  dict.Set("size", val.size());
-  dict.Set("workAreaSize", val.work_area_size());
-  dict.Set("scaleFactor", val.device_scale_factor());
-  dict.Set("rotation", val.RotationAsDegree());
-  dict.Set("touchSupport", val.touch_support());
-  return dict.GetHandle();
-}
-
-}  // namespace mate
removed in remote
  base   100644 c6da76a2d0e72404c01e24cd3ac01c3bd0b42a38 atom/common/native_mate_converters/gfx_converter.h
  our    100644 745e6528093f084d36959c624e05d8aabb994c4a atom/common/native_mate_converters/gfx_converter.h
@@ -1,67 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
-
-#include "native_mate/converter.h"
-#include "ui/gfx/geometry/point_f.h"
-
-namespace display {
-class Display;
-}
-
-namespace gfx {
-class Point;
-class Size;
-class Rect;
-}  // namespace gfx
-
-namespace mate {
-
-template <>
-struct Converter<gfx::Point> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Point& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Point* out);
-};
-
-template <>
-struct Converter<gfx::PointF> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const gfx::PointF& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::PointF* out);
-};
-
-template <>
-struct Converter<gfx::Size> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Size& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Size* out);
-};
-
-template <>
-struct Converter<gfx::Rect> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Rect& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Rect* out);
-};
-
-template <>
-struct Converter<display::Display> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const display::Display& val);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     display::Display* out);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
removed in remote
  base   100644 34408913b789a9303cacc57a56fdb1d0254c112e atom/common/native_mate_converters/gurl_converter.h
  our    100644 110b97d5ef290de2b39dd5435a20d1685178a781 atom/common/native_mate_converters/gurl_converter.h
@@ -1,35 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
-
-#include <string>
-
-#include "native_mate/converter.h"
-#include "url/gurl.h"
-
-namespace mate {
-
-template <>
-struct Converter<GURL> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const GURL& val) {
-    return ConvertToV8(isolate, val.spec());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     GURL* out) {
-    std::string url;
-    if (Converter<std::string>::FromV8(isolate, val, &url)) {
-      *out = GURL(url);
-      return true;
-    } else {
-      return false;
-    }
-  }
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
removed in remote
  base   100644 550bb7b904a74b54883b11f879ee772bb4bcb3a1 atom/common/native_mate_converters/image_converter.cc
  our    100644 1198479926068c1aed59fc7f8d6f384e246b678d atom/common/native_mate_converters/image_converter.cc
@@ -1,43 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/image_converter.h"
-
-#include "atom/common/api/atom_api_native_image.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "ui/gfx/image/image_skia.h"
-
-namespace mate {
-
-bool Converter<gfx::ImageSkia>::FromV8(v8::Isolate* isolate,
-                                       v8::Local<v8::Value> val,
-                                       gfx::ImageSkia* out) {
-  gfx::Image image;
-  if (!ConvertFromV8(isolate, val, &image))
-    return false;
-
-  *out = image.AsImageSkia();
-  return true;
-}
-
-bool Converter<gfx::Image>::FromV8(v8::Isolate* isolate,
-                                   v8::Local<v8::Value> val,
-                                   gfx::Image* out) {
-  if (val->IsNull())
-    return true;
-
-  Handle<atom::api::NativeImage> native_image;
-  if (!ConvertFromV8(isolate, val, &native_image))
-    return false;
-
-  *out = native_image->image();
-  return true;
-}
-
-v8::Local<v8::Value> Converter<gfx::Image>::ToV8(v8::Isolate* isolate,
-                                                 const gfx::Image& val) {
-  return ConvertToV8(isolate, atom::api::NativeImage::Create(isolate, val));
-}
-
-}  // namespace mate
removed in remote
  base   100644 be52288eb0491d9d5284ba20927e3496b714e481 atom/common/native_mate_converters/image_converter.h
  our    100644 d8673145a7637e8e0d479492a85b1126ab822127 atom/common/native_mate_converters/image_converter.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace gfx {
-class Image;
-class ImageSkia;
-}  // namespace gfx
-
-namespace mate {
-
-template <>
-struct Converter<gfx::ImageSkia> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::ImageSkia* out);
-};
-
-template <>
-struct Converter<gfx::Image> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     gfx::Image* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate, const gfx::Image& val);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
removed in remote
  base   100644 5223709ae585f128ab9933e1d2c80c7b5aaa3eb5 atom/common/native_mate_converters/net_converter.cc
  our    100644 db54210e7c095da593c6f5b9f4ed1eafb91b945d atom/common/native_mate_converters/net_converter.cc
@@ -1,259 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/net_converter.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/native_mate_converters/gurl_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "base/strings/string_number_conversions.h"
-#include "base/strings/string_util.h"
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-#include "net/base/upload_bytes_element_reader.h"
-#include "net/base/upload_data_stream.h"
-#include "net/base/upload_element_reader.h"
-#include "net/base/upload_file_element_reader.h"
-#include "net/cert/x509_certificate.h"
-#include "net/cert/x509_util.h"
-#include "net/http/http_response_headers.h"
-#include "net/url_request/url_request.h"
-#include "storage/browser/blob/upload_blob_element_reader.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-namespace {
-
-bool CertFromData(const std::string& data,
-                  scoped_refptr<net::X509Certificate>* out) {
-  auto cert_list = net::X509Certificate::CreateCertificateListFromBytes(
-      data.c_str(), data.length(),
-      net::X509Certificate::FORMAT_SINGLE_CERTIFICATE);
-  if (cert_list.empty())
-    return false;
-
-  auto leaf_cert = cert_list.front();
-  if (!leaf_cert)
-    return false;
-
-  *out = leaf_cert;
-
-  return true;
-}
-
-}  // namespace
-
-// static
-v8::Local<v8::Value> Converter<const net::AuthChallengeInfo*>::ToV8(
-    v8::Isolate* isolate,
-    const net::AuthChallengeInfo* val) {
-  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
-  dict.Set("isProxy", val->is_proxy);
-  dict.Set("scheme", val->scheme);
-  dict.Set("host", val->challenger.host());
-  dict.Set("port", static_cast<uint32_t>(val->challenger.port()));
-  dict.Set("realm", val->realm);
-  return mate::ConvertToV8(isolate, dict);
-}
-
-// static
-v8::Local<v8::Value> Converter<scoped_refptr<net::X509Certificate>>::ToV8(
-    v8::Isolate* isolate,
-    const scoped_refptr<net::X509Certificate>& val) {
-  mate::Dictionary dict(isolate, v8::Object::New(isolate));
-  std::string encoded_data;
-  net::X509Certificate::GetPEMEncoded(val->cert_buffer(), &encoded_data);
-
-  dict.Set("data", encoded_data);
-  dict.Set("issuer", val->issuer());
-  dict.Set("issuerName", val->issuer().GetDisplayName());
-  dict.Set("subject", val->subject());
-  dict.Set("subjectName", val->subject().GetDisplayName());
-  dict.Set("serialNumber", base::HexEncode(val->serial_number().data(),
-                                           val->serial_number().size()));
-  dict.Set("validStart", val->valid_start().ToDoubleT());
-  dict.Set("validExpiry", val->valid_expiry().ToDoubleT());
-  dict.Set("fingerprint",
-           net::HashValue(val->CalculateFingerprint256(val->cert_buffer()))
-               .ToString());
-
-  const auto& intermediate_buffers = val->intermediate_buffers();
-  if (!intermediate_buffers.empty()) {
-    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> issuer_intermediates;
-    issuer_intermediates.reserve(intermediate_buffers.size() - 1);
-    for (size_t i = 1; i < intermediate_buffers.size(); ++i) {
-      issuer_intermediates.push_back(
-          net::x509_util::DupCryptoBuffer(intermediate_buffers[i].get()));
-    }
-    const scoped_refptr<net::X509Certificate>& issuer_cert =
-        net::X509Certificate::CreateFromBuffer(
-            net::x509_util::DupCryptoBuffer(intermediate_buffers[0].get()),
-            std::move(issuer_intermediates));
-    dict.Set("issuerCert", issuer_cert);
-  }
-
-  return dict.GetHandle();
-}
-
-bool Converter<scoped_refptr<net::X509Certificate>>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    scoped_refptr<net::X509Certificate>* out) {
-  mate::Dictionary dict;
-  if (!ConvertFromV8(isolate, val, &dict))
-    return false;
-
-  std::string data;
-  dict.Get("data", &data);
-  scoped_refptr<net::X509Certificate> leaf_cert;
-  if (!CertFromData(data, &leaf_cert))
-    return false;
-
-  scoped_refptr<net::X509Certificate> issuer_cert;
-  if (dict.Get("issuerCert", &issuer_cert)) {
-    std::vector<bssl::UniquePtr<CRYPTO_BUFFER>> intermediates;
-    intermediates.push_back(
-        net::x509_util::DupCryptoBuffer(issuer_cert->cert_buffer()));
-    auto cert = net::X509Certificate::CreateFromBuffer(
-        net::x509_util::DupCryptoBuffer(leaf_cert->cert_buffer()),
-        std::move(intermediates));
-    if (!cert)
-      return false;
-
-    *out = cert;
-  } else {
-    *out = leaf_cert;
-  }
-
-  return true;
-}
-
-// static
-v8::Local<v8::Value> Converter<net::CertPrincipal>::ToV8(
-    v8::Isolate* isolate,
-    const net::CertPrincipal& val) {
-  mate::Dictionary dict(isolate, v8::Object::New(isolate));
-
-  dict.Set("commonName", val.common_name);
-  dict.Set("organizations", val.organization_names);
-  dict.Set("organizationUnits", val.organization_unit_names);
-  dict.Set("locality", val.locality_name);
-  dict.Set("state", val.state_or_province_name);
-  dict.Set("country", val.country_name);
-
-  return dict.GetHandle();
-}
-
-// static
-v8::Local<v8::Value> Converter<net::HttpResponseHeaders*>::ToV8(
-    v8::Isolate* isolate,
-    net::HttpResponseHeaders* headers) {
-  base::DictionaryValue response_headers;
-  if (headers) {
-    size_t iter = 0;
-    std::string key;
-    std::string value;
-    while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
-      key = base::ToLowerASCII(key);
-      if (response_headers.FindKey(key)) {
-        base::ListValue* values = nullptr;
-        if (response_headers.GetList(key, &values))
-          values->AppendString(value);
-      } else {
-        auto values = std::make_unique<base::ListValue>();
-        values->AppendString(value);
-        response_headers.Set(key, std::move(values));
-      }
-    }
-  }
-  return ConvertToV8(isolate, response_headers);
-}
-
-bool Converter<net::HttpResponseHeaders*>::FromV8(
-    v8::Isolate* isolate,
-    v8::Local<v8::Value> val,
-    net::HttpResponseHeaders* out) {
-  if (!val->IsObject()) {
-    return false;
-  }
-  auto context = isolate->GetCurrentContext();
-  auto headers = v8::Local<v8::Object>::Cast(val);
-  auto keys = headers->GetOwnPropertyNames();
-  for (uint32_t i = 0; i < keys->Length(); i++) {
-    v8::Local<v8::String> key, value;
-    if (!keys->Get(i)->ToString(context).ToLocal(&key)) {
-      return false;
-    }
-    if (!headers->Get(key)->ToString(context).ToLocal(&value)) {
-      return false;
-    }
-    v8::String::Utf8Value key_utf8(key);
-    v8::String::Utf8Value value_utf8(value);
-    std::string k(*key_utf8, key_utf8.length());
-    std::string v(*value_utf8, value_utf8.length());
-    std::ostringstream tmp;
-    tmp << k << ": " << v;
-    out->AddHeader(tmp.str());
-  }
-  return true;
-}
-
-}  // namespace mate
-
-namespace atom {
-
-void FillRequestDetails(base::DictionaryValue* details,
-                        const net::URLRequest* request) {
-  details->SetString("method", request->method());
-  std::string url;
-  if (!request->url_chain().empty())
-    url = request->url().spec();
-  details->SetKey("url", base::Value(url));
-  details->SetString("referrer", request->referrer());
-  auto list = std::make_unique<base::ListValue>();
-  GetUploadData(list.get(), request);
-  if (!list->empty())
-    details->Set("uploadData", std::move(list));
-  auto headers_value = std::make_unique<base::DictionaryValue>();
-  for (net::HttpRequestHeaders::Iterator it(request->extra_request_headers());
-       it.GetNext();) {
-    headers_value->SetString(it.name(), it.value());
-  }
-  details->Set("headers", std::move(headers_value));
-}
-
-void GetUploadData(base::ListValue* upload_data_list,
-                   const net::URLRequest* request) {
-  const net::UploadDataStream* upload_data = request->get_upload();
-  if (!upload_data)
-    return;
-  const std::vector<std::unique_ptr<net::UploadElementReader>>* readers =
-      upload_data->GetElementReaders();
-  for (const auto& reader : *readers) {
-    auto upload_data_dict = std::make_unique<base::DictionaryValue>();
-    if (reader->AsBytesReader()) {
-      const net::UploadBytesElementReader* bytes_reader =
-          reader->AsBytesReader();
-      auto bytes = std::make_unique<base::Value>(
-          std::vector<char>(bytes_reader->bytes(),
-                            bytes_reader->bytes() + bytes_reader->length()));
-      upload_data_dict->Set("bytes", std::move(bytes));
-    } else if (reader->AsFileReader()) {
-      const net::UploadFileElementReader* file_reader = reader->AsFileReader();
-      auto file_path = file_reader->path().AsUTF8Unsafe();
-      upload_data_dict->SetKey("file", base::Value(file_path));
-    } else {
-      const storage::UploadBlobElementReader* blob_reader =
-          static_cast<storage::UploadBlobElementReader*>(reader.get());
-      upload_data_dict->SetString("blobUUID", blob_reader->uuid());
-    }
-    upload_data_list->Append(std::move(upload_data_dict));
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 b7fd9481a2070480d8cf26b40b7f8a70f4c1692e atom/common/native_mate_converters/net_converter.h
  our    100644 7182102cebaaf4debae09d26f6bd5654b3dcc627 atom/common/native_mate_converters/net_converter.h
@@ -1,70 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
-
-#include "base/memory/ref_counted.h"
-#include "native_mate/converter.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-}  // namespace base
-
-namespace net {
-class AuthChallengeInfo;
-class URLRequest;
-class X509Certificate;
-class HttpResponseHeaders;
-struct CertPrincipal;
-}  // namespace net
-
-namespace mate {
-
-template <>
-struct Converter<const net::AuthChallengeInfo*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::AuthChallengeInfo* val);
-};
-
-template <>
-struct Converter<scoped_refptr<net::X509Certificate>> {
-  static v8::Local<v8::Value> ToV8(
-      v8::Isolate* isolate,
-      const scoped_refptr<net::X509Certificate>& val);
-
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     scoped_refptr<net::X509Certificate>* out);
-};
-
-template <>
-struct Converter<net::CertPrincipal> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const net::CertPrincipal& val);
-};
-
-template <>
-struct Converter<net::HttpResponseHeaders*> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   net::HttpResponseHeaders* headers);
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     net::HttpResponseHeaders* out);
-};
-
-}  // namespace mate
-
-namespace atom {
-
-void FillRequestDetails(base::DictionaryValue* details,
-                        const net::URLRequest* request);
-
-void GetUploadData(base::ListValue* upload_data_list,
-                   const net::URLRequest* request);
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
removed in remote
  base   100644 e2a5b8ca489eb40daf1830a98a034370f929316e atom/common/native_mate_converters/string16_converter.h
  our    100644 38dd7001fa23338a4be066f66c18960cb4962057 atom/common/native_mate_converters/string16_converter.h
@@ -1,40 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
-
-#include "base/strings/string16.h"
-#include "native_mate/converter.h"
-
-namespace mate {
-
-template <>
-struct Converter<base::string16> {
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::string16& val) {
-    return v8::String::NewFromTwoByte(
-        isolate, reinterpret_cast<const uint16_t*>(val.data()),
-        v8::String::kNormalString, val.size());
-  }
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::string16* out) {
-    if (!val->IsString())
-      return false;
-
-    v8::String::Value s(val);
-    out->assign(reinterpret_cast<const base::char16*>(*s), s.length());
-    return true;
-  }
-};
-
-inline v8::Local<v8::String> StringToV8(v8::Isolate* isolate,
-                                        const base::string16& input) {
-  return ConvertToV8(isolate, input).As<v8::String>();
-}
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
removed in remote
  base   100644 99873cd1c4f08e497d30d9ebef5a9534152f00d4 atom/common/native_mate_converters/v8_value_converter.cc
  our    100644 3fa070771d6843e9428e560c746965b095961e2a atom/common/native_mate_converters/v8_value_converter.cc
@@ -1,500 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-
-#include <map>
-#include <memory>
-#include <string>
-#include <utility>
-#include <vector>
-
-#include "base/logging.h"
-#include "base/values.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_bindings.h"
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-namespace {
-
-const int kMaxRecursionDepth = 100;
-
-}  // namespace
-
-// The state of a call to FromV8Value.
-class V8ValueConverter::FromV8ValueState {
- public:
-  // Level scope which updates the current depth of some FromV8ValueState.
-  class Level {
-   public:
-    explicit Level(FromV8ValueState* state) : state_(state) {
-      state_->max_recursion_depth_--;
-    }
-    ~Level() { state_->max_recursion_depth_++; }
-
-   private:
-    FromV8ValueState* state_;
-  };
-
-  FromV8ValueState() : max_recursion_depth_(kMaxRecursionDepth) {}
-
-  // If |handle| is not in |unique_map_|, then add it to |unique_map_| and
-  // return true.
-  //
-  // Otherwise do nothing and return false. Here "A is unique" means that no
-  // other handle B in the map points to the same object as A. Note that A can
-  // be unique even if there already is another handle with the same identity
-  // hash (key) in the map, because two objects can have the same hash.
-  bool AddToUniquenessCheck(v8::Local<v8::Object> handle) {
-    int hash;
-    auto iter = GetIteratorInMap(handle, &hash);
-    if (iter != unique_map_.end())
-      return false;
-
-    unique_map_.insert(std::make_pair(hash, handle));
-    return true;
-  }
-
-  bool RemoveFromUniquenessCheck(v8::Local<v8::Object> handle) {
-    int unused_hash;
-    auto iter = GetIteratorInMap(handle, &unused_hash);
-    if (iter == unique_map_.end())
-      return false;
-    unique_map_.erase(iter);
-    return true;
-  }
-
-  bool HasReachedMaxRecursionDepth() { return max_recursion_depth_ < 0; }
-
- private:
-  using HashToHandleMap = std::multimap<int, v8::Local<v8::Object>>;
-  using Iterator = HashToHandleMap::const_iterator;
-
-  Iterator GetIteratorInMap(v8::Local<v8::Object> handle, int* hash) {
-    *hash = handle->GetIdentityHash();
-    // We only compare using == with handles to objects with the same identity
-    // hash. Different hash obviously means different objects, but two objects
-    // in a couple of thousands could have the same identity hash.
-    std::pair<Iterator, Iterator> range = unique_map_.equal_range(*hash);
-    for (auto it = range.first; it != range.second; ++it) {
-      // Operator == for handles actually compares the underlying objects.
-      if (it->second == handle)
-        return it;
-    }
-    // Not found.
-    return unique_map_.end();
-  }
-
-  HashToHandleMap unique_map_;
-
-  int max_recursion_depth_;
-};
-
-// A class to ensure that objects/arrays that are being converted by
-// this V8ValueConverterImpl do not have cycles.
-//
-// An example of cycle: var v = {}; v = {key: v};
-// Not an example of cycle: var v = {}; a = [v, v]; or w = {a: v, b: v};
-class V8ValueConverter::ScopedUniquenessGuard {
- public:
-  ScopedUniquenessGuard(V8ValueConverter::FromV8ValueState* state,
-                        v8::Local<v8::Object> value)
-      : state_(state),
-        value_(value),
-        is_valid_(state_->AddToUniquenessCheck(value_)) {}
-  ~ScopedUniquenessGuard() {
-    if (is_valid_) {
-      bool removed = state_->RemoveFromUniquenessCheck(value_);
-      DCHECK(removed);
-    }
-  }
-
-  bool is_valid() const { return is_valid_; }
-
- private:
-  typedef std::multimap<int, v8::Local<v8::Object>> HashToHandleMap;
-  V8ValueConverter::FromV8ValueState* state_;
-  v8::Local<v8::Object> value_;
-  bool is_valid_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScopedUniquenessGuard);
-};
-
-V8ValueConverter::V8ValueConverter() {}
-
-void V8ValueConverter::SetRegExpAllowed(bool val) {
-  reg_exp_allowed_ = val;
-}
-
-void V8ValueConverter::SetFunctionAllowed(bool val) {
-  function_allowed_ = val;
-}
-
-void V8ValueConverter::SetStripNullFromObjects(bool val) {
-  strip_null_from_objects_ = val;
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Value(
-    const base::Value* value,
-    v8::Local<v8::Context> context) const {
-  v8::Context::Scope context_scope(context);
-  v8::EscapableHandleScope handle_scope(context->GetIsolate());
-  return handle_scope.Escape(ToV8ValueImpl(context->GetIsolate(), value));
-}
-
-base::Value* V8ValueConverter::FromV8Value(
-    v8::Local<v8::Value> val,
-    v8::Local<v8::Context> context) const {
-  v8::Context::Scope context_scope(context);
-  v8::HandleScope handle_scope(context->GetIsolate());
-  FromV8ValueState state;
-  return FromV8ValueImpl(&state, val, context->GetIsolate());
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8ValueImpl(
-    v8::Isolate* isolate,
-    const base::Value* value) const {
-  switch (value->type()) {
-    case base::Value::Type::NONE:
-      return v8::Null(isolate);
-
-    case base::Value::Type::BOOLEAN: {
-      bool val = value->GetBool();
-      return v8::Boolean::New(isolate, val);
-    }
-
-    case base::Value::Type::INTEGER: {
-      int val = value->GetInt();
-      return v8::Integer::New(isolate, val);
-    }
-
-    case base::Value::Type::DOUBLE: {
-      double val = value->GetDouble();
-      return v8::Number::New(isolate, val);
-    }
-
-    case base::Value::Type::STRING: {
-      std::string val = value->GetString();
-      return v8::String::NewFromUtf8(isolate, val.c_str(),
-                                     v8::String::kNormalString, val.length());
-    }
-
-    case base::Value::Type::LIST:
-      return ToV8Array(isolate, static_cast<const base::ListValue*>(value));
-
-    case base::Value::Type::DICTIONARY:
-      return ToV8Object(isolate,
-                        static_cast<const base::DictionaryValue*>(value));
-
-    case base::Value::Type::BINARY:
-      return ToArrayBuffer(isolate, static_cast<const base::Value*>(value));
-
-    default:
-      LOG(ERROR) << "Unexpected value type: " << value->type();
-      return v8::Null(isolate);
-  }
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Array(
-    v8::Isolate* isolate,
-    const base::ListValue* val) const {
-  v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
-
-  for (size_t i = 0; i < val->GetSize(); ++i) {
-    const base::Value* child = nullptr;
-    val->Get(i, &child);
-
-    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, child);
-
-    v8::TryCatch try_catch(isolate);
-    result->Set(static_cast<uint32_t>(i), child_v8);
-    if (try_catch.HasCaught())
-      LOG(ERROR) << "Setter for index " << i << " threw an exception.";
-  }
-
-  return result;
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToV8Object(
-    v8::Isolate* isolate,
-    const base::DictionaryValue* val) const {
-  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate);
-  result.SetHidden("simple", true);
-
-  for (base::DictionaryValue::Iterator iter(*val); !iter.IsAtEnd();
-       iter.Advance()) {
-    const std::string& key = iter.key();
-    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, &iter.value());
-
-    v8::TryCatch try_catch(isolate);
-    result.Set(key, child_v8);
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Setter for property " << key.c_str() << " threw an "
-                 << "exception.";
-    }
-  }
-
-  return result.GetHandle();
-}
-
-v8::Local<v8::Value> V8ValueConverter::ToArrayBuffer(
-    v8::Isolate* isolate,
-    const base::Value* value) const {
-  const char* data = value->GetBlob().data();
-  size_t length = value->GetBlob().size();
-
-  if (NodeBindings::IsInitialized()) {
-    return node::Buffer::Copy(isolate, data, length).ToLocalChecked();
-  }
-
-  if (length > node::Buffer::kMaxLength) {
-    return v8::Local<v8::Object>();
-  }
-  auto context = isolate->GetCurrentContext();
-  auto array_buffer = v8::ArrayBuffer::New(isolate, length);
-  memcpy(array_buffer->GetContents().Data(), data, length);
-  // From this point, if something goes wrong(can't find Buffer class for
-  // example) we'll simply return a Uint8Array based on the created ArrayBuffer.
-  // This can happen if no preload script was specified to the renderer.
-  mate::Dictionary global(isolate, context->Global());
-  v8::Local<v8::Value> buffer_value;
-
-  // Get the Buffer class stored as a hidden value in the global object. We'll
-  // use it return a browserified Buffer.
-  if (!global.GetHidden("Buffer", &buffer_value) ||
-      !buffer_value->IsFunction()) {
-    return v8::Uint8Array::New(array_buffer, 0, length);
-  }
-
-  mate::Dictionary buffer_class(
-      isolate,
-      buffer_value->ToObject(isolate->GetCurrentContext()).ToLocalChecked());
-  v8::Local<v8::Value> from_value;
-  if (!buffer_class.Get("from", &from_value) || !from_value->IsFunction()) {
-    return v8::Uint8Array::New(array_buffer, 0, length);
-  }
-
-  v8::Local<v8::Value> args[] = {array_buffer};
-  auto func = v8::Local<v8::Function>::Cast(from_value);
-  auto result = func->Call(context, v8::Null(isolate), 1, args);
-  if (!result.IsEmpty()) {
-    return result.ToLocalChecked();
-  }
-
-  return v8::Uint8Array::New(array_buffer, 0, length);
-}
-
-base::Value* V8ValueConverter::FromV8ValueImpl(FromV8ValueState* state,
-                                               v8::Local<v8::Value> val,
-                                               v8::Isolate* isolate) const {
-  FromV8ValueState::Level state_level(state);
-  if (state->HasReachedMaxRecursionDepth())
-    return nullptr;
-
-  if (val->IsExternal())
-    return std::make_unique<base::Value>().release();
-
-  if (val->IsNull())
-    return std::make_unique<base::Value>().release();
-
-  auto context = isolate->GetCurrentContext();
-
-  if (val->IsBoolean())
-    return new base::Value(val->ToBoolean(context).ToLocalChecked()->Value());
-
-  if (val->IsInt32())
-    return new base::Value(val->ToInt32(context).ToLocalChecked()->Value());
-
-  if (val->IsNumber()) {
-    double val_as_double = val->ToNumber(context).ToLocalChecked()->Value();
-    if (!std::isfinite(val_as_double))
-      return nullptr;
-    return new base::Value(val_as_double);
-  }
-
-  if (val->IsString()) {
-    v8::String::Utf8Value utf8(val->ToString(context).ToLocalChecked());
-    return new base::Value(std::string(*utf8, utf8.length()));
-  }
-
-  if (val->IsUndefined())
-    // JSON.stringify ignores undefined.
-    return nullptr;
-
-  if (val->IsDate()) {
-    v8::Date* date = v8::Date::Cast(*val);
-    v8::Local<v8::Value> toISOString =
-        date->Get(v8::String::NewFromUtf8(isolate, "toISOString"));
-    if (toISOString->IsFunction()) {
-      v8::Local<v8::Value> result =
-          toISOString.As<v8::Function>()->Call(val, 0, nullptr);
-      if (!result.IsEmpty()) {
-        v8::String::Utf8Value utf8(result->ToString(context).ToLocalChecked());
-        return new base::Value(std::string(*utf8, utf8.length()));
-      }
-    }
-  }
-
-  if (val->IsRegExp()) {
-    if (!reg_exp_allowed_)
-      // JSON.stringify converts to an object.
-      return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                          isolate);
-    return new base::Value(
-        *v8::String::Utf8Value(val->ToString(context).ToLocalChecked()));
-  }
-
-  // v8::Value doesn't have a ToArray() method for some reason.
-  if (val->IsArray())
-    return FromV8Array(val.As<v8::Array>(), state, isolate);
-
-  if (val->IsFunction()) {
-    if (!function_allowed_)
-      // JSON.stringify refuses to convert function(){}.
-      return nullptr;
-    return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                        isolate);
-  }
-
-  if (node::Buffer::HasInstance(val)) {
-    return FromNodeBuffer(val, state, isolate);
-  }
-
-  if (val->IsObject()) {
-    return FromV8Object(val->ToObject(context).ToLocalChecked(), state,
-                        isolate);
-  }
-
-  LOG(ERROR) << "Unexpected v8 value type encountered.";
-  return nullptr;
-}
-
-base::Value* V8ValueConverter::FromV8Array(v8::Local<v8::Array> val,
-                                           FromV8ValueState* state,
-                                           v8::Isolate* isolate) const {
-  ScopedUniquenessGuard uniqueness_guard(state, val);
-  if (!uniqueness_guard.is_valid())
-    return std::make_unique<base::Value>().release();
-
-  std::unique_ptr<v8::Context::Scope> scope;
-  // If val was created in a different context than our current one, change to
-  // that context, but change back after val is converted.
-  if (!val->CreationContext().IsEmpty() &&
-      val->CreationContext() != isolate->GetCurrentContext())
-    scope.reset(new v8::Context::Scope(val->CreationContext()));
-
-  auto* result = new base::ListValue();
-
-  // Only fields with integer keys are carried over to the ListValue.
-  for (uint32_t i = 0; i < val->Length(); ++i) {
-    v8::TryCatch try_catch(isolate);
-    v8::Local<v8::Value> child_v8 = val->Get(i);
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Getter for index " << i << " threw an exception.";
-      child_v8 = v8::Null(isolate);
-    }
-
-    if (!val->HasRealIndexedProperty(i))
-      continue;
-
-    base::Value* child = FromV8ValueImpl(state, child_v8, isolate);
-    if (child)
-      result->Append(std::unique_ptr<base::Value>(child));
-    else
-      // JSON.stringify puts null in places where values don't serialize, for
-      // example undefined and functions. Emulate that behavior.
-      result->Append(std::make_unique<base::Value>());
-  }
-  return result;
-}
-
-base::Value* V8ValueConverter::FromNodeBuffer(v8::Local<v8::Value> value,
-                                              FromV8ValueState* state,
-                                              v8::Isolate* isolate) const {
-  return new base::Value(std::vector<char>(
-      node::Buffer::Data(value),
-      node::Buffer::Data(value) + node::Buffer::Length(value)));
-}
-
-base::Value* V8ValueConverter::FromV8Object(v8::Local<v8::Object> val,
-                                            FromV8ValueState* state,
-                                            v8::Isolate* isolate) const {
-  ScopedUniquenessGuard uniqueness_guard(state, val);
-  if (!uniqueness_guard.is_valid())
-    return std::make_unique<base::Value>().release();
-
-  std::unique_ptr<v8::Context::Scope> scope;
-  // If val was created in a different context than our current one, change to
-  // that context, but change back after val is converted.
-  if (!val->CreationContext().IsEmpty() &&
-      val->CreationContext() != isolate->GetCurrentContext())
-    scope.reset(new v8::Context::Scope(val->CreationContext()));
-
-  auto result = std::make_unique<base::DictionaryValue>();
-  v8::Local<v8::Array> property_names(val->GetOwnPropertyNames());
-
-  for (uint32_t i = 0; i < property_names->Length(); ++i) {
-    v8::Local<v8::Value> key(property_names->Get(i));
-
-    // Extend this test to cover more types as necessary and if sensible.
-    if (!key->IsString() && !key->IsNumber()) {
-      NOTREACHED() << "Key \"" << *v8::String::Utf8Value(key)
-                   << "\" "
-                      "is neither a string nor a number";
-      continue;
-    }
-
-    v8::String::Utf8Value name_utf8(
-        key->ToString(isolate->GetCurrentContext()).ToLocalChecked());
-
-    v8::TryCatch try_catch(isolate);
-    v8::Local<v8::Value> child_v8 = val->Get(key);
-
-    if (try_catch.HasCaught()) {
-      LOG(ERROR) << "Getter for property " << *name_utf8
-                 << " threw an exception.";
-      child_v8 = v8::Null(isolate);
-    }
-
-    std::unique_ptr<base::Value> child(
-        FromV8ValueImpl(state, child_v8, isolate));
-    if (!child.get())
-      // JSON.stringify skips properties whose values don't serialize, for
-      // example undefined and functions. Emulate that behavior.
-      continue;
-
-    // Strip null if asked (and since undefined is turned into null, undefined
-    // too). The use case for supporting this is JSON-schema support,
-    // specifically for extensions, where "optional" JSON properties may be
-    // represented as null, yet due to buggy legacy code elsewhere isn't
-    // treated as such (potentially causing crashes). For example, the
-    // "tabs.create" function takes an object as its first argument with an
-    // optional "windowId" property.
-    //
-    // Given just
-    //
-    //   tabs.create({})
-    //
-    // this will work as expected on code that only checks for the existence of
-    // a "windowId" property (such as that legacy code). However given
-    //
-    //   tabs.create({windowId: null})
-    //
-    // there *is* a "windowId" property, but since it should be an int, code
-    // on the browser which doesn't additionally check for null will fail.
-    // We can avoid all bugs related to this by stripping null.
-    if (strip_null_from_objects_ && child->is_none())
-      continue;
-
-    result->SetWithoutPathExpansion(std::string(*name_utf8, name_utf8.length()),
-                                    std::move(child));
-  }
-
-  return result.release();
-}
-
-}  // namespace atom
removed in remote
  base   100644 632587022d14424fac08b0afde870f0ece298284 atom/common/native_mate_converters/v8_value_converter.h
  our    100644 353f5d13597fa0cefee8d99a0b8bcfa007498aa1 atom/common/native_mate_converters/v8_value_converter.h
@@ -1,74 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
-
-#include "base/compiler_specific.h"
-#include "base/macros.h"
-#include "v8/include/v8.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-class Value;
-}  // namespace base
-
-namespace atom {
-
-class V8ValueConverter {
- public:
-  V8ValueConverter();
-
-  void SetRegExpAllowed(bool val);
-  void SetFunctionAllowed(bool val);
-  void SetStripNullFromObjects(bool val);
-  v8::Local<v8::Value> ToV8Value(const base::Value* value,
-                                 v8::Local<v8::Context> context) const;
-  base::Value* FromV8Value(v8::Local<v8::Value> value,
-                           v8::Local<v8::Context> context) const;
-
- private:
-  class FromV8ValueState;
-  class ScopedUniquenessGuard;
-
-  v8::Local<v8::Value> ToV8ValueImpl(v8::Isolate* isolate,
-                                     const base::Value* value) const;
-  v8::Local<v8::Value> ToV8Array(v8::Isolate* isolate,
-                                 const base::ListValue* list) const;
-  v8::Local<v8::Value> ToV8Object(
-      v8::Isolate* isolate,
-      const base::DictionaryValue* dictionary) const;
-  v8::Local<v8::Value> ToArrayBuffer(v8::Isolate* isolate,
-                                     const base::Value* value) const;
-
-  base::Value* FromV8ValueImpl(FromV8ValueState* state,
-                               v8::Local<v8::Value> value,
-                               v8::Isolate* isolate) const;
-  base::Value* FromV8Array(v8::Local<v8::Array> array,
-                           FromV8ValueState* state,
-                           v8::Isolate* isolate) const;
-  base::Value* FromNodeBuffer(v8::Local<v8::Value> value,
-                              FromV8ValueState* state,
-                              v8::Isolate* isolate) const;
-  base::Value* FromV8Object(v8::Local<v8::Object> object,
-                            FromV8ValueState* state,
-                            v8::Isolate* isolate) const;
-
-  // If true, we will convert RegExp JavaScript objects to string.
-  bool reg_exp_allowed_ = false;
-
-  // If true, we will convert Function JavaScript objects to dictionaries.
-  bool function_allowed_ = false;
-
-  // If true, undefined and null values are ignored when converting v8 objects
-  // into Values.
-  bool strip_null_from_objects_ = false;
-
-  DISALLOW_COPY_AND_ASSIGN(V8ValueConverter);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
removed in remote
  base   100644 c9c1a861ba26d9cfdc68292427ca2f86fba7685e atom/common/native_mate_converters/value_converter.cc
  our    100644 a71cc70f83d2526596a75d8daf036f905ca099be atom/common/native_mate_converters/value_converter.cc
@@ -1,74 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/native_mate_converters/value_converter.h"
-
-#include "atom/common/native_mate_converters/v8_value_converter.h"
-#include "base/values.h"
-
-namespace mate {
-
-bool Converter<base::DictionaryValue>::FromV8(v8::Isolate* isolate,
-                                              v8::Local<v8::Value> val,
-                                              base::DictionaryValue* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value && value->is_dict()) {
-    out->Swap(static_cast<base::DictionaryValue*>(value.get()));
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::DictionaryValue>::ToV8(
-    v8::Isolate* isolate,
-    const base::DictionaryValue& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-bool Converter<base::Value>::FromV8(v8::Isolate* isolate,
-                                    v8::Local<v8::Value> val,
-                                    base::Value* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value) {
-    *out = value->Clone();
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::Value>::ToV8(v8::Isolate* isolate,
-                                                  const base::Value& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-bool Converter<base::ListValue>::FromV8(v8::Isolate* isolate,
-                                        v8::Local<v8::Value> val,
-                                        base::ListValue* out) {
-  atom::V8ValueConverter converter;
-  std::unique_ptr<base::Value> value(
-      converter.FromV8Value(val, isolate->GetCurrentContext()));
-  if (value->is_list()) {
-    out->Swap(static_cast<base::ListValue*>(value.get()));
-    return true;
-  } else {
-    return false;
-  }
-}
-
-v8::Local<v8::Value> Converter<base::ListValue>::ToV8(
-    v8::Isolate* isolate,
-    const base::ListValue& val) {
-  atom::V8ValueConverter converter;
-  return converter.ToV8Value(&val, isolate->GetCurrentContext());
-}
-
-}  // namespace mate
removed in remote
  base   100644 013dd99cc7980a2636b04c6b700dc55fa53385cb atom/common/native_mate_converters/value_converter.h
  our    100644 b2ea5def0aa9646791c635c15e0ed504dc0af465 atom/common/native_mate_converters/value_converter.h
@@ -1,47 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
-#define ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
-
-#include "native_mate/converter.h"
-
-namespace base {
-class DictionaryValue;
-class ListValue;
-class Value;
-}  // namespace base
-
-namespace mate {
-
-template <>
-struct Converter<base::DictionaryValue> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::DictionaryValue* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::DictionaryValue& val);
-};
-
-template <>
-struct Converter<base::Value> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::Value* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::Value& val);
-};
-
-template <>
-struct Converter<base::ListValue> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     base::ListValue* out);
-  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
-                                   const base::ListValue& val);
-};
-
-}  // namespace mate
-
-#endif  // ATOM_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
removed in remote
  base   100644 b0b4148c7baf2f4970d7211bb368591a695ca727 atom/common/node_bindings.cc
  our    100644 e6aded2e661af919c2d89c2f9bd46b4921d4aec4 atom/common/node_bindings.cc
@@ -1,384 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings.h"
-
-#include <algorithm>
-#include <string>
-#include <vector>
-
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/api/locker.h"
-#include "atom/common/atom_command_line.h"
-#include "atom/common/native_mate_converters/file_path_converter.h"
-#include "base/base_paths.h"
-#include "base/command_line.h"
-#include "base/environment.h"
-#include "base/path_service.h"
-#include "base/run_loop.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "base/trace_event/trace_event.h"
-#include "content/public/browser/browser_thread.h"
-#include "content/public/common/content_paths.h"
-#include "native_mate/dictionary.h"
-
-#include "atom/common/node_includes.h"
-
-#define ELECTRON_BUILTIN_MODULES(V)          \
-  V(atom_browser_app)                        \
-  V(atom_browser_auto_updater)               \
-  V(atom_browser_browser_view)               \
-  V(atom_browser_content_tracing)            \
-  V(atom_browser_debugger)                   \
-  V(atom_browser_dialog)                     \
-  V(atom_browser_download_item)              \
-  V(atom_browser_global_shortcut)            \
-  V(atom_browser_in_app_purchase)            \
-  V(atom_browser_menu)                       \
-  V(atom_browser_net)                        \
-  V(atom_browser_net_log)                    \
-  V(atom_browser_power_monitor)              \
-  V(atom_browser_power_save_blocker)         \
-  V(atom_browser_protocol)                   \
-  V(atom_browser_render_process_preferences) \
-  V(atom_browser_session)                    \
-  V(atom_browser_system_preferences)         \
-  V(atom_browser_top_level_window)           \
-  V(atom_browser_tray)                       \
-  V(atom_browser_web_contents)               \
-  V(atom_browser_web_contents_view)          \
-  V(atom_browser_view)                       \
-  V(atom_browser_web_view_manager)           \
-  V(atom_browser_window)                     \
-  V(atom_common_asar)                        \
-  V(atom_common_clipboard)                   \
-  V(atom_common_crash_reporter)              \
-  V(atom_common_features)                    \
-  V(atom_common_native_image)                \
-  V(atom_common_notification)                \
-  V(atom_common_screen)                      \
-  V(atom_common_shell)                       \
-  V(atom_common_v8_util)                     \
-  V(atom_renderer_ipc)                       \
-  V(atom_renderer_web_frame)
-
-#define ELECTRON_VIEW_MODULES(V) \
-  V(atom_browser_box_layout)     \
-  V(atom_browser_button)         \
-  V(atom_browser_label_button)   \
-  V(atom_browser_layout_manager) \
-  V(atom_browser_text_field)
-
-#define ELECTRON_DESKTOP_CAPTURER_MODULE(V) V(atom_browser_desktop_capturer)
-
-// This is used to load built-in modules. Instead of using
-// __attribute__((constructor)), we call the _register_<modname>
-// function for each built-in modules explicitly. This is only
-// forward declaration. The definitions are in each module's
-// implementation when calling the NODE_BUILTIN_MODULE_CONTEXT_AWARE.
-#define V(modname) void _register_##modname();
-ELECTRON_BUILTIN_MODULES(V)
-#if defined(ENABLE_VIEW_API)
-ELECTRON_VIEW_MODULES(V)
-#endif
-#if defined(ENABLE_DESKTOP_CAPTURER)
-ELECTRON_DESKTOP_CAPTURER_MODULE(V)
-#endif
-#undef V
-
-namespace {
-
-void stop_and_close_uv_loop(uv_loop_t* loop) {
-  // Close any active handles
-  uv_stop(loop);
-  uv_walk(loop,
-          [](uv_handle_t* handle, void*) {
-            if (!uv_is_closing(handle)) {
-              uv_close(handle, nullptr);
-            }
-          },
-          nullptr);
-
-  // Run the loop to let it finish all the closing handles
-  // NB: after uv_stop(), uv_run(UV_RUN_DEFAULT) returns 0 when that's done
-  for (;;)
-    if (!uv_run(loop, UV_RUN_DEFAULT))
-      break;
-
-  DCHECK(!uv_loop_alive(loop));
-  uv_loop_close(loop);
-}
-
-bool g_is_initialized = false;
-
-}  // namespace
-
-namespace atom {
-
-namespace {
-
-// Convert the given vector to an array of C-strings. The strings in the
-// returned vector are only guaranteed valid so long as the vector of strings
-// is not modified.
-std::unique_ptr<const char* []> StringVectorToArgArray(
-    const std::vector<std::string>& vector) {
-  std::unique_ptr<const char* []> array(new const char*[vector.size()]);
-  for (size_t i = 0; i < vector.size(); ++i) {
-    array[i] = vector[i].c_str();
-  }
-  return array;
-}
-
-base::FilePath GetResourcesPath(bool is_browser) {
-  auto* command_line = base::CommandLine::ForCurrentProcess();
-  base::FilePath exec_path(command_line->GetProgram());
-  PathService::Get(base::FILE_EXE, &exec_path);
-
-  base::FilePath resources_path =
-#if defined(OS_MACOSX)
-      is_browser
-          ? exec_path.DirName().DirName().Append("Resources")
-          : exec_path.DirName().DirName().DirName().DirName().DirName().Append(
-                "Resources");
-#else
-      exec_path.DirName().Append(FILE_PATH_LITERAL("resources"));
-#endif
-  return resources_path;
-}
-
-}  // namespace
-
-NodeBindings::NodeBindings(BrowserEnvironment browser_env)
-    : browser_env_(browser_env), weak_factory_(this) {
-  if (browser_env == WORKER) {
-    uv_loop_init(&worker_loop_);
-    uv_loop_ = &worker_loop_;
-  } else {
-    uv_loop_ = uv_default_loop();
-  }
-}
-
-NodeBindings::~NodeBindings() {
-  // Quit the embed thread.
-  embed_closed_ = true;
-  uv_sem_post(&embed_sem_);
-  WakeupEmbedThread();
-
-  // Wait for everything to be done.
-  uv_thread_join(&embed_thread_);
-
-  // Clear uv.
-  uv_sem_destroy(&embed_sem_);
-  uv_close(reinterpret_cast<uv_handle_t*>(&dummy_uv_handle_), nullptr);
-
-  // Clean up worker loop
-  if (uv_loop_ == &worker_loop_)
-    stop_and_close_uv_loop(uv_loop_);
-}
-
-void NodeBindings::RegisterBuiltinModules() {
-#define V(modname) _register_##modname();
-  ELECTRON_BUILTIN_MODULES(V)
-#if defined(ENABLE_VIEW_API)
-  ELECTRON_VIEW_MODULES(V)
-#endif
-#if defined(ENABLE_DESKTOP_CAPTURER)
-  ELECTRON_DESKTOP_CAPTURER_MODULE(V)
-#endif
-#undef V
-}
-
-bool NodeBindings::IsInitialized() {
-  return g_is_initialized;
-}
-
-base::FilePath::StringType NodeBindings::GetHelperResourcesPath() {
-  return GetResourcesPath(false).value();
-}
-
-void NodeBindings::Initialize() {
-  // Open node's error reporting system for browser process.
-  node::g_standalone_mode = browser_env_ == BROWSER;
-  node::g_upstream_node_mode = false;
-
-#if defined(OS_LINUX)
-  // Get real command line in renderer process forked by zygote.
-  if (browser_env_ != BROWSER)
-    AtomCommandLine::InitializeFromCommandLine();
-#endif
-
-  // Explicitly register electron's builtin modules.
-  RegisterBuiltinModules();
-
-  // Init node.
-  // (we assume node::Init would not modify the parameters under embedded mode).
-  node::Init(nullptr, nullptr, nullptr, nullptr);
-
-#if defined(OS_WIN)
-  // uv_init overrides error mode to suppress the default crash dialog, bring
-  // it back if user wants to show it.
-  std::unique_ptr<base::Environment> env(base::Environment::Create());
-  if (browser_env_ == BROWSER || env->HasVar("ELECTRON_DEFAULT_ERROR_MODE"))
-    SetErrorMode(GetErrorMode() & ~SEM_NOGPFAULTERRORBOX);
-#endif
-
-  g_is_initialized = true;
-}
-
-node::Environment* NodeBindings::CreateEnvironment(
-    v8::Handle<v8::Context> context,
-    node::MultiIsolatePlatform* platform) {
-#if defined(OS_WIN)
-  auto& atom_args = AtomCommandLine::argv();
-  std::vector<std::string> args(atom_args.size());
-  std::transform(atom_args.cbegin(), atom_args.cend(), args.begin(),
-                 [](auto& a) { return base::WideToUTF8(a); });
-#else
-  auto args = AtomCommandLine::argv();
-#endif
-
-  // Feed node the path to initialization script.
-  base::FilePath::StringType process_type;
-  switch (browser_env_) {
-    case BROWSER:
-      process_type = FILE_PATH_LITERAL("browser");
-      break;
-    case RENDERER:
-      process_type = FILE_PATH_LITERAL("renderer");
-      break;
-    case WORKER:
-      process_type = FILE_PATH_LITERAL("worker");
-      break;
-  }
-  base::FilePath resources_path = GetResourcesPath(browser_env_ == BROWSER);
-  base::FilePath script_path =
-      resources_path.Append(FILE_PATH_LITERAL("electron.asar"))
-          .Append(process_type)
-          .Append(FILE_PATH_LITERAL("init.js"));
-  args.insert(args.begin() + 1, script_path.AsUTF8Unsafe());
-
-  std::unique_ptr<const char* []> c_argv = StringVectorToArgArray(args);
-  node::Environment* env = node::CreateEnvironment(
-      node::CreateIsolateData(context->GetIsolate(), uv_loop_, platform),
-      context, args.size(), c_argv.get(), 0, nullptr);
-
-  if (browser_env_ == BROWSER) {
-    // SetAutorunMicrotasks is no longer called in node::CreateEnvironment
-    // so instead call it here to match expected node behavior
-    context->GetIsolate()->SetMicrotasksPolicy(v8::MicrotasksPolicy::kExplicit);
-  } else {
-    // Node uses the deprecated SetAutorunMicrotasks(false) mode, we should
-    // switch to use the scoped policy to match blink's behavior.
-    context->GetIsolate()->SetMicrotasksPolicy(v8::MicrotasksPolicy::kScoped);
-  }
-
-  mate::Dictionary process(context->GetIsolate(), env->process_object());
-  process.Set("type", process_type);
-  process.Set("resourcesPath", resources_path);
-  // Do not set DOM globals for renderer process.
-  if (browser_env_ != BROWSER)
-    process.Set("_noBrowserGlobals", resources_path);
-  // The path to helper app.
-  base::FilePath helper_exec_path;
-  PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);
-  process.Set("helperExecPath", helper_exec_path);
-
-  return env;
-}
-
-void NodeBindings::LoadEnvironment(node::Environment* env) {
-  node::LoadEnvironment(env);
-  mate::EmitEvent(env->isolate(), env->process_object(), "loaded");
-}
-
-void NodeBindings::PrepareMessageLoop() {
-  // Add dummy handle for libuv, otherwise libuv would quit when there is
-  // nothing to do.
-  uv_async_init(uv_loop_, &dummy_uv_handle_, nullptr);
-
-  // Start worker that will interrupt main loop when having uv events.
-  uv_sem_init(&embed_sem_, 0);
-  uv_thread_create(&embed_thread_, EmbedThreadRunner, this);
-}
-
-void NodeBindings::RunMessageLoop() {
-  // The MessageLoop should have been created, remember the one in main thread.
-  task_runner_ = base::ThreadTaskRunnerHandle::Get();
-
-  // Run uv loop for once to give the uv__io_poll a chance to add all events.
-  UvRunOnce();
-}
-
-void NodeBindings::UvRunOnce() {
-  node::Environment* env = uv_env();
-
-  // When doing navigation without restarting renderer process, it may happen
-  // that the node environment is destroyed but the message loop is still there.
-  // In this case we should not run uv loop.
-  if (!env)
-    return;
-
-  // Use Locker in browser process.
-  mate::Locker locker(env->isolate());
-  v8::HandleScope handle_scope(env->isolate());
-
-  // Enter node context while dealing with uv events.
-  v8::Context::Scope context_scope(env->context());
-
-  // Perform microtask checkpoint after running JavaScript.
-  v8::MicrotasksScope script_scope(env->isolate(),
-                                   v8::MicrotasksScope::kRunMicrotasks);
-
-  if (browser_env_ != BROWSER)
-    TRACE_EVENT_BEGIN0("devtools.timeline", "FunctionCall");
-
-  // Deal with uv events.
-  int r = uv_run(uv_loop_, UV_RUN_NOWAIT);
-
-  if (browser_env_ != BROWSER)
-    TRACE_EVENT_END0("devtools.timeline", "FunctionCall");
-
-  if (r == 0)
-    base::RunLoop().QuitWhenIdle();  // Quit from uv.
-
-  // Tell the worker thread to continue polling.
-  uv_sem_post(&embed_sem_);
-}
-
-void NodeBindings::WakeupMainThread() {
-  DCHECK(task_runner_);
-  task_runner_->PostTask(FROM_HERE, base::BindOnce(&NodeBindings::UvRunOnce,
-                                                   weak_factory_.GetWeakPtr()));
-}
-
-void NodeBindings::WakeupEmbedThread() {
-  uv_async_send(&dummy_uv_handle_);
-}
-
-// static
-void NodeBindings::EmbedThreadRunner(void* arg) {
-  NodeBindings* self = static_cast<NodeBindings*>(arg);
-
-  while (true) {
-    // Wait for the main loop to deal with events.
-    uv_sem_wait(&self->embed_sem_);
-    if (self->embed_closed_)
-      break;
-
-    // Wait for something to happen in uv loop.
-    // Note that the PollEvents() is implemented by derived classes, so when
-    // this class is being destructed the PollEvents() would not be available
-    // anymore. Because of it we must make sure we only invoke PollEvents()
-    // when this class is alive.
-    self->PollEvents();
-    if (self->embed_closed_)
-      break;
-
-    // Deal with event in main thread.
-    self->WakeupMainThread();
-  }
-}
-
-}  // namespace atom
removed in remote
  base   100644 16d512d3bed038c08d9d3c25da727ea9640f4f49 atom/common/node_bindings.h
  our    100644 5e5ec8e5300ba2c1917e3e9d7e2e8ea1ee341e3b atom/common/node_bindings.h
@@ -1,117 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_H_
-#define ATOM_COMMON_NODE_BINDINGS_H_
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/memory/weak_ptr.h"
-#include "base/single_thread_task_runner.h"
-#include "uv.h"  // NOLINT(build/include)
-#include "v8/include/v8.h"
-
-namespace base {
-class MessageLoop;
-}
-
-namespace node {
-class Environment;
-class MultiIsolatePlatform;
-}  // namespace node
-
-namespace atom {
-
-class NodeBindings {
- public:
-  enum BrowserEnvironment {
-    BROWSER,
-    RENDERER,
-    WORKER,
-  };
-
-  static NodeBindings* Create(BrowserEnvironment browser_env);
-  static void RegisterBuiltinModules();
-  static bool IsInitialized();
-  static base::FilePath::StringType GetHelperResourcesPath();
-
-  virtual ~NodeBindings();
-
-  // Setup V8, libuv.
-  void Initialize();
-
-  // Create the environment and load node.js.
-  node::Environment* CreateEnvironment(
-      v8::Handle<v8::Context> context,
-      node::MultiIsolatePlatform* platform = nullptr);
-
-  // Load node.js in the environment.
-  void LoadEnvironment(node::Environment* env);
-
-  // Prepare for message loop integration.
-  void PrepareMessageLoop();
-
-  // Do message loop integration.
-  virtual void RunMessageLoop();
-
-  // Gets/sets the environment to wrap uv loop.
-  void set_uv_env(node::Environment* env) { uv_env_ = env; }
-  node::Environment* uv_env() const { return uv_env_; }
-
-  uv_loop_t* uv_loop() const { return uv_loop_; }
-
- protected:
-  explicit NodeBindings(BrowserEnvironment browser_env);
-
-  // Called to poll events in new thread.
-  virtual void PollEvents() = 0;
-
-  // Run the libuv loop for once.
-  void UvRunOnce();
-
-  // Make the main thread run libuv loop.
-  void WakeupMainThread();
-
-  // Interrupt the PollEvents.
-  void WakeupEmbedThread();
-
-  // Which environment we are running.
-  BrowserEnvironment browser_env_;
-
-  // Current thread's MessageLoop.
-  scoped_refptr<base::SingleThreadTaskRunner> task_runner_;
-
-  // Current thread's libuv loop.
-  uv_loop_t* uv_loop_;
-
- private:
-  // Thread to poll uv events.
-  static void EmbedThreadRunner(void* arg);
-
-  // Whether the libuv loop has ended.
-  bool embed_closed_ = false;
-
-  // Loop used when constructed in WORKER mode
-  uv_loop_t worker_loop_;
-
-  // Dummy handle to make uv's loop not quit.
-  uv_async_t dummy_uv_handle_;
-
-  // Thread for polling events.
-  uv_thread_t embed_thread_;
-
-  // Semaphore to wait for main loop in the embed thread.
-  uv_sem_t embed_sem_;
-
-  // Environment that to wrap the uv loop.
-  node::Environment* uv_env_ = nullptr;
-
-  base::WeakPtrFactory<NodeBindings> weak_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindings);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_H_
removed in remote
  base   100644 34b9ea952365eb5875ac9e9faea1641f3f5a225e atom/common/node_bindings_linux.cc
  our    100644 3c58cb67a072387c4b203697ece022c19d45f7ed atom/common/node_bindings_linux.cc
@@ -1,55 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_linux.h"
-
-#include <sys/epoll.h>
-
-namespace atom {
-
-NodeBindingsLinux::NodeBindingsLinux(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env), epoll_(epoll_create(1)) {
-  int backend_fd = uv_backend_fd(uv_loop_);
-  struct epoll_event ev = {0};
-  ev.events = EPOLLIN;
-  ev.data.fd = backend_fd;
-  epoll_ctl(epoll_, EPOLL_CTL_ADD, backend_fd, &ev);
-}
-
-NodeBindingsLinux::~NodeBindingsLinux() {}
-
-void NodeBindingsLinux::RunMessageLoop() {
-  // Get notified when libuv's watcher queue changes.
-  uv_loop_->data = this;
-  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
-
-  NodeBindings::RunMessageLoop();
-}
-
-// static
-void NodeBindingsLinux::OnWatcherQueueChanged(uv_loop_t* loop) {
-  NodeBindingsLinux* self = static_cast<NodeBindingsLinux*>(loop->data);
-
-  // We need to break the io polling in the epoll thread when loop's watcher
-  // queue changes, otherwise new events cannot be notified.
-  self->WakeupEmbedThread();
-}
-
-void NodeBindingsLinux::PollEvents() {
-  int timeout = uv_backend_timeout(uv_loop_);
-
-  // Wait for new libuv events.
-  int r;
-  do {
-    struct epoll_event ev;
-    r = epoll_wait(epoll_, &ev, 1, timeout);
-  } while (r == -1 && errno == EINTR);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsLinux(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3bbea9f9dd0a315a32880f87da5e3d5c7c5a1cbc atom/common/node_bindings_linux.h
  our    100644 15d9b33eb047bfd9fc92bb1458989c4238e0d9d2 atom/common/node_bindings_linux.h
@@ -1,34 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_LINUX_H_
-#define ATOM_COMMON_NODE_BINDINGS_LINUX_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsLinux : public NodeBindings {
- public:
-  explicit NodeBindingsLinux(BrowserEnvironment browser_env);
-  ~NodeBindingsLinux() override;
-
-  void RunMessageLoop() override;
-
- private:
-  // Called when uv's watcher queue changes.
-  static void OnWatcherQueueChanged(uv_loop_t* loop);
-
-  void PollEvents() override;
-
-  // Epoll to poll for uv's backend fd.
-  int epoll_;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsLinux);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_LINUX_H_
removed in remote
  base   100644 877497d5a1e2b0748072fc539596a5d7b3b1f417 atom/common/node_bindings_mac.cc
  our    100644 856b9cc868a51e1ca754da2a24682780ed9100b4 atom/common/node_bindings_mac.cc
@@ -1,65 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_mac.h"
-
-#include <errno.h>
-#include <sys/select.h>
-#include <sys/sysctl.h>
-#include <sys/time.h>
-#include <sys/types.h>
-
-#include "atom/common/node_includes.h"
-
-namespace atom {
-
-NodeBindingsMac::NodeBindingsMac(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env) {}
-
-NodeBindingsMac::~NodeBindingsMac() {}
-
-void NodeBindingsMac::RunMessageLoop() {
-  // Get notified when libuv's watcher queue changes.
-  uv_loop_->data = this;
-  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
-
-  NodeBindings::RunMessageLoop();
-}
-
-// static
-void NodeBindingsMac::OnWatcherQueueChanged(uv_loop_t* loop) {
-  NodeBindingsMac* self = static_cast<NodeBindingsMac*>(loop->data);
-
-  // We need to break the io polling in the kqueue thread when loop's watcher
-  // queue changes, otherwise new events cannot be notified.
-  self->WakeupEmbedThread();
-}
-
-void NodeBindingsMac::PollEvents() {
-  struct timeval tv;
-  int timeout = uv_backend_timeout(uv_loop_);
-  if (timeout != -1) {
-    tv.tv_sec = timeout / 1000;
-    tv.tv_usec = (timeout % 1000) * 1000;
-  }
-
-  fd_set readset;
-  int fd = uv_backend_fd(uv_loop_);
-  FD_ZERO(&readset);
-  FD_SET(fd, &readset);
-
-  // Wait for new libuv events.
-  int r;
-  do {
-    r = select(fd + 1, &readset, nullptr, nullptr,
-               timeout == -1 ? nullptr : &tv);
-  } while (r == -1 && errno == EINTR);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsMac(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 03152ada3ea698af3c9d6297f219cdd9127ecbe9 atom/common/node_bindings_mac.h
  our    100644 a0f93d8755eda701d12833e425bf1bb580790c5b atom/common/node_bindings_mac.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_MAC_H_
-#define ATOM_COMMON_NODE_BINDINGS_MAC_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsMac : public NodeBindings {
- public:
-  explicit NodeBindingsMac(BrowserEnvironment browser_env);
-  ~NodeBindingsMac() override;
-
-  void RunMessageLoop() override;
-
- private:
-  // Called when uv's watcher queue changes.
-  static void OnWatcherQueueChanged(uv_loop_t* loop);
-
-  void PollEvents() override;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsMac);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_MAC_H_
removed in remote
  base   100644 b8de4f59da3b79d62e880dee7ee35707533c3536 atom/common/node_bindings_win.cc
  our    100644 e41fb585f57114de00376f52e0d97277e6eca94b atom/common/node_bindings_win.cc
@@ -1,39 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/node_bindings_win.h"
-
-#include <windows.h>
-
-#include "base/logging.h"
-
-namespace atom {
-
-NodeBindingsWin::NodeBindingsWin(BrowserEnvironment browser_env)
-    : NodeBindings(browser_env) {}
-
-NodeBindingsWin::~NodeBindingsWin() {}
-
-void NodeBindingsWin::PollEvents() {
-  // If there are other kinds of events pending, uv_backend_timeout will
-  // instruct us not to wait.
-  DWORD bytes, timeout;
-  ULONG_PTR key;
-  OVERLAPPED* overlapped;
-
-  timeout = uv_backend_timeout(uv_loop_);
-
-  GetQueuedCompletionStatus(uv_loop_->iocp, &bytes, &key, &overlapped, timeout);
-
-  // Give the event back so libuv can deal with it.
-  if (overlapped != NULL)
-    PostQueuedCompletionStatus(uv_loop_->iocp, bytes, key, overlapped);
-}
-
-// static
-NodeBindings* NodeBindings::Create(BrowserEnvironment browser_env) {
-  return new NodeBindingsWin(browser_env);
-}
-
-}  // namespace atom
removed in remote
  base   100644 3950098e5ebfba8c2a19618f366a24ef37455a86 atom/common/node_bindings_win.h
  our    100644 77fe5f43b54c8d53bfc5a4a29c9c0a6f62bea423 atom/common/node_bindings_win.h
@@ -1,26 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_BINDINGS_WIN_H_
-#define ATOM_COMMON_NODE_BINDINGS_WIN_H_
-
-#include "atom/common/node_bindings.h"
-#include "base/compiler_specific.h"
-
-namespace atom {
-
-class NodeBindingsWin : public NodeBindings {
- public:
-  explicit NodeBindingsWin(BrowserEnvironment browser_env);
-  ~NodeBindingsWin() override;
-
- private:
-  void PollEvents() override;
-
-  DISALLOW_COPY_AND_ASSIGN(NodeBindingsWin);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_NODE_BINDINGS_WIN_H_
removed in remote
  base   100644 bb76afb54db9e806a68cfe797f7af79c6b3ef199 atom/common/node_includes.h
  our    100644 fa1a7499a8b082fe9007f04041b46e58502b3ad9 atom/common/node_includes.h
@@ -1,54 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_NODE_INCLUDES_H_
-#define ATOM_COMMON_NODE_INCLUDES_H_
-
-#include "base/logging.h"
-
-// Include common headers for using node APIs.
-
-#ifdef NODE_SHARED_MODE
-#define BUILDING_NODE_EXTENSION
-#endif
-
-// The following define makes sure that we do not include the macros
-// again. But we still need the tracing functions, so declaring them.
-#define SRC_TRACING_TRACE_EVENT_H_
-
-#undef ASSERT
-#undef CHECK
-#undef CHECK_EQ
-#undef CHECK_NE
-#undef CHECK_GE
-#undef CHECK_GT
-#undef CHECK_LE
-#undef CHECK_LT
-#undef UNLIKELY
-#undef DISALLOW_COPY_AND_ASSIGN
-#undef NO_RETURN
-#undef LIKELY
-#undef arraysize
-#undef debug_string  // This is defined in macOS 10.9 SDK in AssertMacros.h.
-#include "env-inl.h"
-#include "env.h"
-#include "node.h"
-#include "node_buffer.h"
-#include "node_debug_options.h"
-#include "node_internals.h"
-#include "node_platform.h"
-
-namespace node {
-namespace tracing {
-
-class TraceEventHelper {
- public:
-  static v8::TracingController* GetTracingController();
-  static void SetTracingController(v8::TracingController* controller);
-};
-
-}  // namespace tracing
-}  // namespace node
-
-#endif  // ATOM_COMMON_NODE_INCLUDES_H_
removed in remote
  base   100644 ac63ea1b7276fc93f5d47ffaa624e080d95d6939 atom/common/options_switches.cc
  our    100644 8b1836f80c583e4db68971ff1b00ca4f86356b45 atom/common/options_switches.cc
@@ -1,221 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/options_switches.h"
-
-namespace atom {
-
-namespace options {
-
-const char kTitle[] = "title";
-const char kIcon[] = "icon";
-const char kFrame[] = "frame";
-const char kShow[] = "show";
-const char kCenter[] = "center";
-const char kX[] = "x";
-const char kY[] = "y";
-const char kWidth[] = "width";
-const char kHeight[] = "height";
-const char kMinWidth[] = "minWidth";
-const char kMinHeight[] = "minHeight";
-const char kMaxWidth[] = "maxWidth";
-const char kMaxHeight[] = "maxHeight";
-const char kResizable[] = "resizable";
-const char kMovable[] = "movable";
-const char kMinimizable[] = "minimizable";
-const char kMaximizable[] = "maximizable";
-const char kFullScreenable[] = "fullscreenable";
-const char kClosable[] = "closable";
-const char kFullscreen[] = "fullscreen";
-
-// Whether the window should show in taskbar.
-const char kSkipTaskbar[] = "skipTaskbar";
-
-// Start with the kiosk mode, see Opera's page for description:
-// http://www.opera.com/support/mastering/kiosk/
-const char kKiosk[] = "kiosk";
-
-const char kSimpleFullScreen[] = "simpleFullscreen";
-
-// Make windows stays on the top of all other windows.
-const char kAlwaysOnTop[] = "alwaysOnTop";
-
-// Enable the NSView to accept first mouse event.
-const char kAcceptFirstMouse[] = "acceptFirstMouse";
-
-// Whether window size should include window frame.
-const char kUseContentSize[] = "useContentSize";
-
-// Whether window zoom should be to page width.
-const char kZoomToPageWidth[] = "zoomToPageWidth";
-
-// Whether always show title text in full screen is enabled.
-const char kFullscreenWindowTitle[] = "fullscreenWindowTitle";
-
-// The requested title bar style for the window
-const char kTitleBarStyle[] = "titleBarStyle";
-
-// Tabbing identifier for the window if native tabs are enabled on macOS.
-const char kTabbingIdentifier[] = "tabbingIdentifier";
-
-// The menu bar is hidden unless "Alt" is pressed.
-const char kAutoHideMenuBar[] = "autoHideMenuBar";
-
-// Enable window to be resized larger than screen.
-const char kEnableLargerThanScreen[] = "enableLargerThanScreen";
-
-// Forces to use dark theme on Linux.
-const char kDarkTheme[] = "darkTheme";
-
-// Whether the window should be transparent.
-const char kTransparent[] = "transparent";
-
-// Window type hint.
-const char kType[] = "type";
-
-// Disable auto-hiding cursor.
-const char kDisableAutoHideCursor[] = "disableAutoHideCursor";
-
-// Use the macOS' standard window instead of the textured window.
-const char kStandardWindow[] = "standardWindow";
-
-// Default browser window background color.
-const char kBackgroundColor[] = "backgroundColor";
-
-// Whether the window should have a shadow.
-const char kHasShadow[] = "hasShadow";
-
-// Browser window opacity
-const char kOpacity[] = "opacity";
-
-// Whether the window can be activated.
-const char kFocusable[] = "focusable";
-
-// The WebPreferences.
-const char kWebPreferences[] = "webPreferences";
-
-// Add a vibrancy effect to the browser window
-const char kVibrancyType[] = "vibrancy";
-
-// The factor of which page should be zoomed.
-const char kZoomFactor[] = "zoomFactor";
-
-// Script that will be loaded by guest WebContents before other scripts.
-const char kPreloadScript[] = "preload";
-
-// Like --preload, but the passed argument is an URL.
-const char kPreloadURL[] = "preloadURL";
-
-// Enable the node integration.
-const char kNodeIntegration[] = "nodeIntegration";
-
-// Enable context isolation of Electron APIs and preload script
-const char kContextIsolation[] = "contextIsolation";
-
-// Instance ID of guest WebContents.
-const char kGuestInstanceID[] = "guestInstanceId";
-
-// Web runtime features.
-const char kExperimentalFeatures[] = "experimentalFeatures";
-
-// Opener window's ID.
-const char kOpenerID[] = "openerId";
-
-// Enable the rubber banding effect.
-const char kScrollBounce[] = "scrollBounce";
-
-// Enable blink features.
-const char kEnableBlinkFeatures[] = "enableBlinkFeatures";
-
-// Disable blink features.
-const char kDisableBlinkFeatures[] = "disableBlinkFeatures";
-
-// Enable the node integration in WebWorker.
-const char kNodeIntegrationInWorker[] = "nodeIntegrationInWorker";
-
-// Enable the web view tag.
-const char kWebviewTag[] = "webviewTag";
-
-const char kNativeWindowOpen[] = "nativeWindowOpen";
-
-const char kCustomArgs[] = "additionalArguments";
-
-const char kPlugins[] = "plugins";
-
-const char kSandbox[] = "sandbox";
-
-const char kWebSecurity[] = "webSecurity";
-
-const char kAllowRunningInsecureContent[] = "allowRunningInsecureContent";
-
-const char kOffscreen[] = "offscreen";
-
-}  // namespace options
-
-namespace switches {
-
-// Enable chromium sandbox.
-const char kEnableSandbox[] = "enable-sandbox";
-
-// Enable sandbox in only remote content windows.
-const char kEnableMixedSandbox[] = "enable-mixed-sandbox";
-
-// Enable plugins.
-const char kEnablePlugins[] = "enable-plugins";
-
-// Ppapi Flash path.
-const char kPpapiFlashPath[] = "ppapi-flash-path";
-
-// Ppapi Flash version.
-const char kPpapiFlashVersion[] = "ppapi-flash-version";
-
-// Disable HTTP cache.
-const char kDisableHttpCache[] = "disable-http-cache";
-
-// The list of standard schemes.
-const char kStandardSchemes[] = "standard-schemes";
-
-// Register schemes to handle service worker.
-const char kRegisterServiceWorkerSchemes[] = "register-service-worker-schemes";
-
-// Register schemes as secure.
-const char kSecureSchemes[] = "secure-schemes";
-
-// The browser process app model ID
-const char kAppUserModelId[] = "app-user-model-id";
-
-// The application path
-const char kAppPath[] = "app-path";
-
-// The command line switch versions of the options.
-const char kBackgroundColor[] = "background-color";
-const char kPreloadScript[] = "preload";
-const char kPreloadScripts[] = "preload-scripts";
-const char kNodeIntegration[] = "node-integration";
-const char kContextIsolation[] = "context-isolation";
-const char kGuestInstanceID[] = "guest-instance-id";
-const char kOpenerID[] = "opener-id";
-const char kScrollBounce[] = "scroll-bounce";
-const char kHiddenPage[] = "hidden-page";
-const char kNativeWindowOpen[] = "native-window-open";
-const char kWebviewTag[] = "webview-tag";
-
-// Command switch passed to renderer process to control nodeIntegration.
-const char kNodeIntegrationInWorker[] = "node-integration-in-worker";
-
-// Widevine options
-// Path to Widevine CDM binaries.
-const char kWidevineCdmPath[] = "widevine-cdm-path";
-// Widevine CDM version.
-const char kWidevineCdmVersion[] = "widevine-cdm-version";
-
-// Forces the maximum disk space to be used by the disk cache, in bytes.
-const char kDiskCacheSize[] = "disk-cache-size";
-
-// Ignore the limit of 6 connections per host.
-const char kIgnoreConnectionsLimit[] = "ignore-connections-limit";
-
-}  // namespace switches
-
-}  // namespace atom
removed in remote
  base   100644 3c198555a5c380e81dbdfcd4f26b5c03a2a5c6a5 atom/common/options_switches.h
  our    100644 5f6d7e9d38120668ed06922ced2f8d6a6e27a52b atom/common/options_switches.h
@@ -1,119 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_OPTIONS_SWITCHES_H_
-#define ATOM_COMMON_OPTIONS_SWITCHES_H_
-
-namespace atom {
-
-namespace options {
-
-extern const char kTitle[];
-extern const char kIcon[];
-extern const char kFrame[];
-extern const char kShow[];
-extern const char kCenter[];
-extern const char kX[];
-extern const char kY[];
-extern const char kWidth[];
-extern const char kHeight[];
-extern const char kMinWidth[];
-extern const char kMinHeight[];
-extern const char kMaxWidth[];
-extern const char kMaxHeight[];
-extern const char kResizable[];
-extern const char kMovable[];
-extern const char kMinimizable[];
-extern const char kMaximizable[];
-extern const char kFullScreenable[];
-extern const char kClosable[];
-extern const char kFullscreen[];
-extern const char kSkipTaskbar[];
-extern const char kKiosk[];
-extern const char kSimpleFullScreen[];
-extern const char kAlwaysOnTop[];
-extern const char kAcceptFirstMouse[];
-extern const char kUseContentSize[];
-extern const char kZoomToPageWidth[];
-extern const char kFullscreenWindowTitle[];
-extern const char kTitleBarStyle[];
-extern const char kTabbingIdentifier[];
-extern const char kAutoHideMenuBar[];
-extern const char kEnableLargerThanScreen[];
-extern const char kDarkTheme[];
-extern const char kTransparent[];
-extern const char kType[];
-extern const char kDisableAutoHideCursor[];
-extern const char kStandardWindow[];
-extern const char kBackgroundColor[];
-extern const char kHasShadow[];
-extern const char kOpacity[];
-extern const char kFocusable[];
-extern const char kWebPreferences[];
-extern const char kVibrancyType[];
-
-// WebPreferences.
-extern const char kZoomFactor[];
-extern const char kPreloadScript[];
-extern const char kPreloadURL[];
-extern const char kNodeIntegration[];
-extern const char kContextIsolation[];
-extern const char kGuestInstanceID[];
-extern const char kExperimentalFeatures[];
-extern const char kOpenerID[];
-extern const char kScrollBounce[];
-extern const char kEnableBlinkFeatures[];
-extern const char kDisableBlinkFeatures[];
-extern const char kNodeIntegrationInWorker[];
-extern const char kWebviewTag[];
-extern const char kNativeWindowOpen[];
-extern const char kCustomArgs[];
-extern const char kPlugins[];
-extern const char kSandbox[];
-extern const char kWebSecurity[];
-extern const char kAllowRunningInsecureContent[];
-extern const char kOffscreen[];
-
-}  // namespace options
-
-// Following are actually command line switches, should be moved to other files.
-
-namespace switches {
-
-extern const char kEnableSandbox[];
-extern const char kEnableMixedSandbox[];
-extern const char kEnablePlugins[];
-extern const char kPpapiFlashPath[];
-extern const char kPpapiFlashVersion[];
-extern const char kDisableHttpCache[];
-extern const char kStandardSchemes[];
-extern const char kRegisterServiceWorkerSchemes[];
-extern const char kSecureSchemes[];
-extern const char kAppUserModelId[];
-extern const char kAppPath[];
-
-extern const char kBackgroundColor[];
-extern const char kPreloadScript[];
-extern const char kPreloadScripts[];
-extern const char kNodeIntegration[];
-extern const char kContextIsolation[];
-extern const char kGuestInstanceID[];
-extern const char kOpenerID[];
-extern const char kScrollBounce[];
-extern const char kHiddenPage[];
-extern const char kNativeWindowOpen[];
-extern const char kNodeIntegrationInWorker[];
-extern const char kWebviewTag[];
-
-extern const char kWidevineCdmPath[];
-extern const char kWidevineCdmVersion[];
-
-extern const char kDiskCacheSize[];
-extern const char kIgnoreConnectionsLimit[];
-
-}  // namespace switches
-
-}  // namespace atom
-
-#endif  // ATOM_COMMON_OPTIONS_SWITCHES_H_
removed in remote
  base   100644 4565221e9d8455b42edceb04e3c4ae17d1680755 atom/common/platform_util.h
  our    100644 6fd84056a06a3163547b254777d78161538b7069 atom/common/platform_util.h
@@ -1,67 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_COMMON_PLATFORM_UTIL_H_
-#define ATOM_COMMON_PLATFORM_UTIL_H_
-
-#include <string>
-
-#include "base/callback_forward.h"
-#include "build/build_config.h"
-
-#if defined(OS_WIN)
-#include "base/strings/string16.h"
-#endif
-
-class GURL;
-
-namespace base {
-class FilePath;
-}
-
-namespace platform_util {
-
-typedef base::Callback<void(const std::string&)> OpenExternalCallback;
-
-// Show the given file in a file manager. If possible, select the file.
-// Must be called from the UI thread.
-bool ShowItemInFolder(const base::FilePath& full_path);
-
-// Open the given file in the desktop's default manner.
-// Must be called from the UI thread.
-bool OpenItem(const base::FilePath& full_path);
-
-// Open the given external protocol URL in the desktop's default manner.
-// (For example, mailto: URLs in the default mail user agent.)
-bool OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    bool activate);
-
-// The asynchronous version of OpenExternal.
-void OpenExternal(
-#if defined(OS_WIN)
-    const base::string16& url,
-#else
-    const GURL& url,
-#endif
-    bool activate,
-    const OpenExternalCallback& callback);
-
-// Move a file to trash.
-bool MoveItemToTrash(const base::FilePath& full_path);
-
-void Beep();
-
-#if defined(OS_MACOSX)
-bool GetLoginItemEnabled();
-void SetLoginItemEnabled(bool enabled);
-#endif
-
-}  // namespace platform_util
-
-#endif  // ATOM_COMMON_PLATFORM_UTIL_H_
removed in remote
  base   100644 1e437b866cc019078915ef0f9edbb62a20a483cc atom/common/platform_util_linux.cc
  our    100644 8fad8609342a81f46ea2608b3923f85af2d4308b atom/common/platform_util_linux.cc
@@ -1,149 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#include <stdio.h>
-
-#include "base/cancelable_callback.h"
-#include "base/environment.h"
-#include "base/files/file_util.h"
-#include "base/nix/xdg_util.h"
-#include "base/process/kill.h"
-#include "base/process/launch.h"
-#include "url/gurl.h"
-
-#define ELECTRON_TRASH "ELECTRON_TRASH"
-#define ELECTRON_DEFAULT_TRASH "gvfs-trash"
-
-namespace {
-
-bool XDGUtilV(const std::vector<std::string>& argv, const bool wait_for_exit) {
-  base::LaunchOptions options;
-  options.allow_new_privs = true;
-  // xdg-open can fall back on mailcap which eventually might plumb through
-  // to a command that needs a terminal.  Set the environment variable telling
-  // it that we definitely don't have a terminal available and that it should
-  // bring up a new terminal if necessary.  See "man mailcap".
-  options.environ["MM_NOTTTY"] = "1";
-
-  base::Process process = base::LaunchProcess(argv, options);
-  if (!process.IsValid())
-    return false;
-
-  if (!wait_for_exit) {
-    base::EnsureProcessGetsReaped(process.Pid());
-    return true;
-  }
-
-  int exit_code = -1;
-  if (!process.WaitForExit(&exit_code))
-    return false;
-
-  return (exit_code == 0);
-}
-
-bool XDGUtil(const std::string& util,
-             const std::string& arg,
-             const bool wait_for_exit) {
-  std::vector<std::string> argv;
-  argv.push_back(util);
-  argv.push_back(arg);
-
-  return XDGUtilV(argv, wait_for_exit);
-}
-
-bool XDGOpen(const std::string& path, const bool wait_for_exit) {
-  return XDGUtil("xdg-open", path, wait_for_exit);
-}
-
-bool XDGEmail(const std::string& email, const bool wait_for_exit) {
-  return XDGUtil("xdg-email", email, wait_for_exit);
-}
-
-}  // namespace
-
-namespace platform_util {
-
-// TODO(estade): It would be nice to be able to select the file in the file
-// manager, but that probably requires extending xdg-open. For now just
-// show the folder.
-bool ShowItemInFolder(const base::FilePath& full_path) {
-  base::FilePath dir = full_path.DirName();
-  if (!base::DirectoryExists(dir))
-    return false;
-
-  return XDGOpen(dir.value(), false);
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  return XDGOpen(full_path.value(), false);
-}
-
-bool OpenExternal(const GURL& url, bool activate) {
-  // Don't wait for exit, since we don't want to wait for the browser/email
-  // client window to close before returning
-  if (url.SchemeIs("mailto"))
-    return XDGEmail(url.spec(), false);
-  else
-    return XDGOpen(url.spec(), false);
-}
-
-void OpenExternal(const GURL& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  // TODO(gabriel): Implement async open if callback is specified
-  callback.Run(OpenExternal(url, activate) ? "" : "Failed to open");
-}
-
-bool MoveItemToTrash(const base::FilePath& full_path) {
-  std::string trash;
-  if (getenv(ELECTRON_TRASH) != NULL) {
-    trash = getenv(ELECTRON_TRASH);
-  } else {
-    // Determine desktop environment and set accordingly.
-    std::unique_ptr<base::Environment> env(base::Environment::Create());
-    base::nix::DesktopEnvironment desktop_env(
-        base::nix::GetDesktopEnvironment(env.get()));
-    if (desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE4 ||
-        desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE5) {
-      trash = "kioclient5";
-    } else if (desktop_env == base::nix::DESKTOP_ENVIRONMENT_KDE3) {
-      trash = "kioclient";
-    } else {
-      trash = ELECTRON_DEFAULT_TRASH;
-    }
-  }
-
-  std::vector<std::string> argv;
-
-  if (trash.compare("kioclient5") == 0 || trash.compare("kioclient") == 0) {
-    argv.push_back(trash);
-    argv.push_back("move");
-    argv.push_back(full_path.value());
-    argv.push_back("trash:/");
-  } else if (trash.compare("trash-cli") == 0) {
-    argv.push_back("trash-put");
-    argv.push_back(full_path.value());
-  } else if (trash.compare("gio") == 0) {
-    argv.push_back("gio");
-    argv.push_back("trash");
-    argv.push_back(full_path.value());
-  } else {
-    argv.push_back(ELECTRON_DEFAULT_TRASH);
-    argv.push_back(full_path.value());
-  }
-  return XDGUtilV(argv, true);
-}
-
-void Beep() {
-  // echo '\a' > /dev/console
-  FILE* console = fopen("/dev/console", "r");
-  if (console == NULL)
-    return;
-  fprintf(console, "\a");
-  fclose(console);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 98bc4e537d89162236689586e930e818098d758d atom/common/platform_util_mac.mm
  our    100644 b83b1e11d891ed8a70e488460fcdc7402dc6281e atom/common/platform_util_mac.mm
@@ -1,207 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#import <Carbon/Carbon.h>
-#import <Cocoa/Cocoa.h>
-#import <ServiceManagement/ServiceManagement.h>
-
-#include "base/callback.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/mac/foundation_util.h"
-#include "base/mac/mac_logging.h"
-#include "base/mac/scoped_aedesc.h"
-#include "base/strings/stringprintf.h"
-#include "base/strings/sys_string_conversions.h"
-#include "net/base/mac/url_conversions.h"
-#include "url/gurl.h"
-
-namespace {
-
-std::string MessageForOSStatus(OSStatus status, const char* default_message) {
-  switch (status) {
-    case kLSAppInTrashErr:
-      return "The application cannot be run because it is inside a Trash "
-             "folder.";
-    case kLSUnknownErr:
-      return "An unknown error has occurred.";
-    case kLSNotAnApplicationErr:
-      return "The item to be registered is not an application.";
-    case kLSNotInitializedErr:
-      return "Formerly returned by LSInit on initialization failure; "
-             "no longer used.";
-    case kLSDataUnavailableErr:
-      return "Data of the desired type is not available (for example, there is "
-             "no kind string).";
-    case kLSApplicationNotFoundErr:
-      return "No application in the Launch Services database matches the input "
-             "criteria.";
-    case kLSDataErr:
-      return "Data is structured improperly (for example, an item’s "
-             "information property list is malformed). Not used in macOS 10.4.";
-    case kLSLaunchInProgressErr:
-      return "A launch of the application is already in progress.";
-    case kLSServerCommunicationErr:
-      return "There is a problem communicating with the server process that "
-             "maintains the Launch Services database.";
-    case kLSCannotSetInfoErr:
-      return "The filename extension to be hidden cannot be hidden.";
-    case kLSIncompatibleSystemVersionErr:
-      return "The application to be launched cannot run on the current Mac OS "
-             "version.";
-    case kLSNoLaunchPermissionErr:
-      return "The user does not have permission to launch the application (on a"
-             "managed network).";
-    case kLSNoExecutableErr:
-      return "The executable file is missing or has an unusable format.";
-    case kLSNoClassicEnvironmentErr:
-      return "The Classic emulation environment was required but is not "
-             "available.";
-    case kLSMultipleSessionsNotSupportedErr:
-      return "The application to be launched cannot run simultaneously in two "
-             "different user sessions.";
-    default:
-      return base::StringPrintf("%s (%d)", default_message, status);
-  }
-}
-
-// This may be called from a global dispatch queue, the methods used here are
-// thread safe, including LSGetApplicationForURL (> 10.2) and
-// NSWorkspace#openURLs.
-std::string OpenURL(NSURL* ns_url, bool activate) {
-  CFURLRef openingApp = nullptr;
-  OSStatus status = LSGetApplicationForURL(base::mac::NSToCFCast(ns_url),
-                                           kLSRolesAll, nullptr, &openingApp);
-  if (status != noErr)
-    return MessageForOSStatus(status, "Failed to open");
-
-  CFRelease(openingApp);  // NOT A BUG; LSGetApplicationForURL retains for us
-
-  NSUInteger launchOptions = NSWorkspaceLaunchDefault;
-  if (!activate)
-    launchOptions |= NSWorkspaceLaunchWithoutActivation;
-
-  bool opened = [[NSWorkspace sharedWorkspace] openURLs:@[ ns_url ]
-                                withAppBundleIdentifier:nil
-                                                options:launchOptions
-                         additionalEventParamDescriptor:nil
-                                      launchIdentifiers:nil];
-  if (!opened)
-    return "Failed to open URL";
-
-  return "";
-}
-
-NSString* GetLoginHelperBundleIdentifier() {
-  return [[[NSBundle mainBundle] bundleIdentifier]
-      stringByAppendingString:@".loginhelper"];
-}
-
-}  // namespace
-
-namespace platform_util {
-
-bool ShowItemInFolder(const base::FilePath& path) {
-  // The API only takes absolute path.
-  base::FilePath full_path =
-      path.IsAbsolute() ? path : base::MakeAbsoluteFilePath(path);
-
-  DCHECK([NSThread isMainThread]);
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  if (!path_string || ![[NSWorkspace sharedWorkspace] selectFile:path_string
-                                        inFileViewerRootedAtPath:@""]) {
-    LOG(WARNING) << "NSWorkspace failed to select file " << full_path.value();
-    return false;
-  }
-  return true;
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  DCHECK([NSThread isMainThread]);
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  if (!path_string)
-    return false;
-
-  NSURL* url = [NSURL fileURLWithPath:path_string];
-  if (!url)
-    return false;
-
-  const NSWorkspaceLaunchOptions launch_options =
-      NSWorkspaceLaunchAsync | NSWorkspaceLaunchWithErrorPresentation;
-  return [[NSWorkspace sharedWorkspace] openURLs:@[ url ]
-                         withAppBundleIdentifier:nil
-                                         options:launch_options
-                  additionalEventParamDescriptor:nil
-                               launchIdentifiers:NULL];
-}
-
-bool OpenExternal(const GURL& url, bool activate) {
-  DCHECK([NSThread isMainThread]);
-  NSURL* ns_url = net::NSURLWithGURL(url);
-  if (ns_url)
-    return OpenURL(ns_url, activate).empty();
-  return false;
-}
-
-void OpenExternal(const GURL& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  NSURL* ns_url = net::NSURLWithGURL(url);
-  if (!ns_url) {
-    callback.Run("Invalid URL");
-    return;
-  }
-
-  __block OpenExternalCallback c = callback;
-  dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0),
-                 ^{
-                   __block std::string error = OpenURL(ns_url, activate);
-                   dispatch_async(dispatch_get_main_queue(), ^{
-                     c.Run(error);
-                   });
-                 });
-}
-
-bool MoveItemToTrash(const base::FilePath& full_path) {
-  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
-  BOOL status = [[NSFileManager defaultManager]
-        trashItemAtURL:[NSURL fileURLWithPath:path_string]
-      resultingItemURL:nil
-                 error:nil];
-  if (!path_string || !status)
-    LOG(WARNING) << "NSWorkspace failed to move file " << full_path.value()
-                 << " to trash";
-  return status;
-}
-
-void Beep() {
-  NSBeep();
-}
-
-bool GetLoginItemEnabled() {
-  BOOL enabled = NO;
-  // SMJobCopyDictionary does not work in sandbox (see rdar://13626319)
-  CFArrayRef jobs = SMCopyAllJobDictionaries(kSMDomainUserLaunchd);
-  NSArray* jobs_ = CFBridgingRelease(jobs);
-  NSString* identifier = GetLoginHelperBundleIdentifier();
-  if (jobs_ && [jobs_ count] > 0) {
-    for (NSDictionary* job in jobs_) {
-      if ([identifier isEqualToString:[job objectForKey:@"Label"]]) {
-        enabled = [[job objectForKey:@"OnDemand"] boolValue];
-        break;
-      }
-    }
-  }
-  return enabled;
-}
-
-void SetLoginItemEnabled(bool enabled) {
-  NSString* identifier = GetLoginHelperBundleIdentifier();
-  SMLoginItemSetEnabled((__bridge CFStringRef)identifier, enabled);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 12591a94d5691c8944ff96596af755779941261c atom/common/platform_util_win.cc
  our    100644 34576be95f2552aaa985dacb3f36406dfc29d54c atom/common/platform_util_win.cc
@@ -1,371 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/common/platform_util.h"
-
-#include <windows.h>  // windows.h must be included first
-
-#include <atlbase.h>
-#include <comdef.h>
-#include <commdlg.h>
-#include <dwmapi.h>
-#include <objbase.h>
-#include <shellapi.h>
-#include <shlobj.h>
-#include <wrl/client.h>
-
-#include "base/bind.h"
-#include "base/bind_helpers.h"
-#include "base/files/file_path.h"
-#include "base/files/file_util.h"
-#include "base/logging.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "base/win/registry.h"
-#include "base/win/scoped_co_mem.h"
-#include "base/win/scoped_com_initializer.h"
-#include "base/win/windows_version.h"
-#include "ui/base/win/shell.h"
-#include "url/gurl.h"
-
-namespace {
-
-// Required COM implementation of IFileOperationProgressSink so we can
-// precheck files before deletion to make sure they can be move to the
-// Recycle Bin.
-class DeleteFileProgressSink : public IFileOperationProgressSink {
- public:
-  DeleteFileProgressSink();
-  virtual ~DeleteFileProgressSink() = default;
-
- private:
-  ULONG STDMETHODCALLTYPE AddRef(void) override;
-  ULONG STDMETHODCALLTYPE Release(void) override;
-  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,
-                                           LPVOID* ppvObj) override;
-  HRESULT STDMETHODCALLTYPE StartOperations(void) override;
-  HRESULT STDMETHODCALLTYPE FinishOperations(HRESULT) override;
-  HRESULT STDMETHODCALLTYPE PreRenameItem(DWORD, IShellItem*, LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE
-  PostRenameItem(DWORD, IShellItem*, LPCWSTR, HRESULT, IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreMoveItem(DWORD,
-                                        IShellItem*,
-                                        IShellItem*,
-                                        LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostMoveItem(DWORD,
-                                         IShellItem*,
-                                         IShellItem*,
-                                         LPCWSTR,
-                                         HRESULT,
-                                         IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreCopyItem(DWORD,
-                                        IShellItem*,
-                                        IShellItem*,
-                                        LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostCopyItem(DWORD,
-                                         IShellItem*,
-                                         IShellItem*,
-                                         LPCWSTR,
-                                         HRESULT,
-                                         IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreDeleteItem(DWORD, IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PostDeleteItem(DWORD,
-                                           IShellItem*,
-                                           HRESULT,
-                                           IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE PreNewItem(DWORD, IShellItem*, LPCWSTR) override;
-  HRESULT STDMETHODCALLTYPE PostNewItem(DWORD,
-                                        IShellItem*,
-                                        LPCWSTR,
-                                        LPCWSTR,
-                                        DWORD,
-                                        HRESULT,
-                                        IShellItem*) override;
-  HRESULT STDMETHODCALLTYPE UpdateProgress(UINT, UINT) override;
-  HRESULT STDMETHODCALLTYPE ResetTimer(void) override;
-  HRESULT STDMETHODCALLTYPE PauseTimer(void) override;
-  HRESULT STDMETHODCALLTYPE ResumeTimer(void) override;
-
-  ULONG m_cRef;
-};
-
-DeleteFileProgressSink::DeleteFileProgressSink() {
-  m_cRef = 0;
-}
-
-HRESULT DeleteFileProgressSink::PreDeleteItem(DWORD dwFlags, IShellItem*) {
-  if (!(dwFlags & TSF_DELETE_RECYCLE_IF_POSSIBLE)) {
-    // TSF_DELETE_RECYCLE_IF_POSSIBLE will not be set for items that cannot be
-    // recycled.  In this case, we abort the delete operation.  This bubbles
-    // up and stops the Delete in IFileOperation.
-    return E_ABORT;
-  }
-  // Returns S_OK if successful, or an error value otherwise. In the case of an
-  // error value, the delete operation and all subsequent operations pending
-  // from the call to IFileOperation are canceled.
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::QueryInterface(REFIID riid, LPVOID* ppvObj) {
-  // Always set out parameter to NULL, validating it first.
-  if (!ppvObj)
-    return E_INVALIDARG;
-  *ppvObj = nullptr;
-  if (riid == IID_IUnknown || riid == IID_IFileOperationProgressSink) {
-    // Increment the reference count and return the pointer.
-    *ppvObj = reinterpret_cast<IUnknown*>(this);
-    AddRef();
-    return NOERROR;
-  }
-  return E_NOINTERFACE;
-}
-
-ULONG DeleteFileProgressSink::AddRef() {
-  InterlockedIncrement(&m_cRef);
-  return m_cRef;
-}
-
-ULONG DeleteFileProgressSink::Release() {
-  // Decrement the object's internal counter.
-  ULONG ulRefCount = InterlockedDecrement(&m_cRef);
-  if (0 == m_cRef) {
-    delete this;
-  }
-  return ulRefCount;
-}
-
-HRESULT DeleteFileProgressSink::StartOperations() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::FinishOperations(HRESULT) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PreRenameItem(DWORD, IShellItem*, LPCWSTR) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PostRenameItem(DWORD,
-                                               IShellItem*,
-                                               __RPC__in_string LPCWSTR,
-                                               HRESULT,
-                                               IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PreMoveItem(DWORD,
-                                            IShellItem*,
-                                            IShellItem*,
-                                            LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostMoveItem(DWORD,
-                                             IShellItem*,
-                                             IShellItem*,
-                                             LPCWSTR,
-                                             HRESULT,
-                                             IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PreCopyItem(DWORD,
-                                            IShellItem*,
-                                            IShellItem*,
-                                            LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostCopyItem(DWORD,
-                                             IShellItem*,
-                                             IShellItem*,
-                                             LPCWSTR,
-                                             HRESULT,
-                                             IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostDeleteItem(DWORD,
-                                               IShellItem*,
-                                               HRESULT,
-                                               IShellItem*) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PreNewItem(DWORD dwFlags,
-                                           IShellItem*,
-                                           LPCWSTR) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::PostNewItem(DWORD,
-                                            IShellItem*,
-                                            LPCWSTR,
-                                            LPCWSTR,
-                                            DWORD,
-                                            HRESULT,
-                                            IShellItem*) {
-  return E_NOTIMPL;
-}
-
-HRESULT DeleteFileProgressSink::UpdateProgress(UINT, UINT) {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::ResetTimer() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::PauseTimer() {
-  return S_OK;
-}
-
-HRESULT DeleteFileProgressSink::ResumeTimer() {
-  return S_OK;
-}
-
-}  // namespace
-
-namespace platform_util {
-
-bool ShowItemInFolder(const base::FilePath& full_path) {
-  base::win::ScopedCOMInitializer com_initializer;
-  if (!com_initializer.Succeeded())
-    return false;
-
-  base::FilePath dir = full_path.DirName().AsEndingWithSeparator();
-  // ParseDisplayName will fail if the directory is "C:", it must be "C:\\".
-  if (dir.empty())
-    return false;
-
-  Microsoft::WRL::ComPtr<IShellFolder> desktop;
-  HRESULT hr = SHGetDesktopFolder(desktop.GetAddressOf());
-  if (FAILED(hr))
-    return false;
-
-  base::win::ScopedCoMem<ITEMIDLIST> dir_item;
-  hr = desktop->ParseDisplayName(NULL, NULL,
-                                 const_cast<wchar_t*>(dir.value().c_str()),
-                                 NULL, &dir_item, NULL);
-  if (FAILED(hr)) {
-    return ui::win::OpenFolderViaShell(dir);
-  }
-
-  base::win::ScopedCoMem<ITEMIDLIST> file_item;
-  hr = desktop->ParseDisplayName(
-      NULL, NULL, const_cast<wchar_t*>(full_path.value().c_str()), NULL,
-      &file_item, NULL);
-  if (FAILED(hr)) {
-    return ui::win::OpenFolderViaShell(dir);
-  }
-
-  const ITEMIDLIST* highlight[] = {file_item};
-
-  hr = SHOpenFolderAndSelectItems(dir_item, arraysize(highlight), highlight,
-                                  NULL);
-  if (!FAILED(hr))
-    return true;
-
-  // On some systems, the above call mysteriously fails with "file not
-  // found" even though the file is there.  In these cases, ShellExecute()
-  // seems to work as a fallback (although it won't select the file).
-  if (hr == ERROR_FILE_NOT_FOUND) {
-    return ui::win::OpenFolderViaShell(dir);
-  } else {
-    LPTSTR message = NULL;
-    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
-                  0, hr, 0, reinterpret_cast<LPTSTR>(&message), 0, NULL);
-    LOG(WARNING) << " " << __FUNCTION__ << "(): Can't open full_path = \""
-                 << full_path.value() << "\""
-                 << " hr = " << hr << " " << reinterpret_cast<LPTSTR>(&message);
-    if (message)
-      LocalFree(message);
-
-    return ui::win::OpenFolderViaShell(dir);
-  }
-}
-
-bool OpenItem(const base::FilePath& full_path) {
-  if (base::DirectoryExists(full_path))
-    return ui::win::OpenFolderViaShell(full_path);
-  else
-    return ui::win::OpenFileViaShell(full_path);
-}
-
-bool OpenExternal(const base::string16& url, bool activate) {
-  // Quote the input scheme to be sure that the command does not have
-  // parameters unexpected by the external program. This url should already
-  // have been escaped.
-  base::string16 escaped_url = L"\"" + url + L"\"";
-
-  if (reinterpret_cast<ULONG_PTR>(ShellExecuteW(
-          NULL, L"open", escaped_url.c_str(), NULL, NULL, SW_SHOWNORMAL)) <=
-      32) {
-    // We fail to execute the call. We could display a message to the user.
-    // TODO(nsylvain): we should also add a dialog to warn on errors. See
-    // bug 1136923.
-    return false;
-  }
-  return true;
-}
-
-void OpenExternal(const base::string16& url,
-                  bool activate,
-                  const OpenExternalCallback& callback) {
-  // TODO(gabriel): Implement async open if callback is specified
-  callback.Run(OpenExternal(url, activate) ? "" : "Failed to open");
-}
-
-bool MoveItemToTrash(const base::FilePath& path) {
-  base::win::ScopedCOMInitializer com_initializer;
-  if (!com_initializer.Succeeded())
-    return false;
-
-  Microsoft::WRL::ComPtr<IFileOperation> pfo;
-  if (FAILED(::CoCreateInstance(CLSID_FileOperation, nullptr, CLSCTX_ALL,
-                                IID_PPV_ARGS(&pfo))))
-    return false;
-
-  // Elevation prompt enabled for UAC protected files.  This overrides the
-  // SILENT, NO_UI and NOERRORUI flags.
-
-  if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
-    // Windows 8 introduces the flag RECYCLEONDELETE and deprecates the
-    // ALLOWUNDO in favor of ADDUNDORECORD.
-    if (FAILED(pfo->SetOperationFlags(
-            FOF_NO_UI | FOFX_ADDUNDORECORD | FOF_NOERRORUI | FOF_SILENT |
-            FOFX_SHOWELEVATIONPROMPT | FOFX_RECYCLEONDELETE)))
-      return false;
-  } else {
-    // For Windows 7 and Vista, RecycleOnDelete is the default behavior.
-    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI | FOF_ALLOWUNDO |
-                                      FOF_NOERRORUI | FOF_SILENT |
-                                      FOFX_SHOWELEVATIONPROMPT)))
-      return false;
-  }
-
-  // Create an IShellItem from the supplied source path.
-  Microsoft::WRL::ComPtr<IShellItem> delete_item;
-  if (FAILED(SHCreateItemFromParsingName(
-          path.value().c_str(), NULL,
-          IID_PPV_ARGS(delete_item.GetAddressOf()))))
-    return false;
-
-  Microsoft::WRL::ComPtr<IFileOperationProgressSink> delete_sink(
-      new DeleteFileProgressSink);
-  if (!delete_sink)
-    return false;
-
-  // Processes the queued command DeleteItem. This will trigger
-  // the DeleteFileProgressSink to check for Recycle Bin.
-  return SUCCEEDED(pfo->DeleteItem(delete_item.Get(), delete_sink.Get())) &&
-         SUCCEEDED(pfo->PerformOperations());
-}
-
-void Beep() {
-  MessageBeep(MB_OK);
-}
-
-}  // namespace platform_util
removed in remote
  base   100644 7b56a46470ea071c861f28c879cb20b8ced1d34d atom/common/resources/mac/Info.plist
  our    100644 7b56a46470ea071c861f28c879cb20b8ced1d34d atom/common/resources/mac/Info.plist
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-	<key>CFBundleIdentifier</key>
-	<string>${ATOM_BUNDLE_ID}</string>
-	<key>CFBundleName</key>
-	<string>${PRODUCT_NAME}</string>
-	<key>CFBundleExecutable</key>
-	<string>${PRODUCT_NAME}</string>
-	<key>CFBundlePackageType</key>
-	<string>FMWK</string>
-	<key>NSSupportsAutomaticGraphicsSwitching</key>
-	<true/>
-</dict>
-</plist>
removed in remote
  base   100644 fb4656cac6184e1c0eaafccc45eee95eb539df92 atom/common/resources/mac/MainMenu.xib
  our    100644 5427dde7f9290006bfed808788c2cc8374a05598 atom/common/resources/mac/MainMenu.xib
@@ -1,219 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="8.00">
-	<data>
-		<int key="IBDocument.SystemTarget">101000</int>
-		<string key="IBDocument.SystemVersion">14D136</string>
-		<string key="IBDocument.InterfaceBuilderVersion">7531</string>
-		<string key="IBDocument.AppKitVersion">1347.57</string>
-		<string key="IBDocument.HIToolboxVersion">758.70</string>
-		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
-			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin</string>
-			<string key="NS.object.0">7531</string>
-		</object>
-		<array key="IBDocument.IntegratedClassDependencies">
-			<string>NSCustomObject</string>
-			<string>NSMenu</string>
-			<string>NSMenuItem</string>
-		</array>
-		<array key="IBDocument.PluginDependencies">
-			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
-		</array>
-		<object class="NSMutableDictionary" key="IBDocument.Metadata">
-			<string key="NS.key.0">PluginDependencyRecalculationVersion</string>
-			<integer value="1" key="NS.object.0"/>
-		</object>
-		<array class="NSMutableArray" key="IBDocument.RootObjects" id="1048">
-			<object class="NSCustomObject" id="1021">
-				<string key="NSClassName">AtomApplication</string>
-			</object>
-			<object class="NSCustomObject" id="1014">
-				<string key="NSClassName">FirstResponder</string>
-			</object>
-			<object class="NSCustomObject" id="1050">
-				<string key="NSClassName">NSApplication</string>
-			</object>
-			<object class="NSCustomObject" id="903638069">
-				<string key="NSClassName">NSFontManager</string>
-			</object>
-			<object class="NSMenu" id="649796088">
-				<string key="NSTitle">Main Menu</string>
-				<array class="NSMutableArray" key="NSMenuItems">
-					<object class="NSMenuItem" id="694149608">
-						<reference key="NSMenu" ref="649796088"/>
-						<string key="NSTitle">Electron</string>
-						<string key="NSKeyEquiv"/>
-						<int key="NSMnemonicLoc">2147483647</int>
-						<object class="NSCustomResource" key="NSOnImage" id="229763992">
-							<string key="NSClassName">NSImage</string>
-							<string key="NSResourceName">NSMenuCheckmark</string>
-						</object>
-						<object class="NSCustomResource" key="NSMixedImage" id="909111550">
-							<string key="NSClassName">NSImage</string>
-							<string key="NSResourceName">NSMenuMixedState</string>
-						</object>
-						<string key="NSAction">submenuAction:</string>
-						<reference key="NSTarget" ref="110575045"/>
-						<object class="NSMenu" key="NSSubmenu" id="110575045">
-							<string key="NSTitle">Electron</string>
-							<array class="NSMutableArray" key="NSMenuItems">
-								<object class="NSMenuItem" id="632727374">
-									<reference key="NSMenu" ref="110575045"/>
-									<string key="NSTitle">Quit</string>
-									<string key="NSKeyEquiv">q</string>
-									<int key="NSKeyEquivModMask">1048576</int>
-									<int key="NSMnemonicLoc">2147483647</int>
-									<reference key="NSOnImage" ref="229763992"/>
-									<reference key="NSMixedImage" ref="909111550"/>
-								</object>
-								<object class="NSMenuItem" id="1025936716">
-									<reference key="NSMenu" ref="110575045"/>
-									<string key="NSTitle">Open Recent</string>
-									<string key="NSKeyEquiv"/>
-									<int key="NSKeyEquivModMask">1048576</int>
-									<int key="NSMnemonicLoc">2147483647</int>
-									<bool key="NSIsHidden">YES</bool>
-									<reference key="NSOnImage" ref="229763992"/>
-									<reference key="NSMixedImage" ref="909111550"/>
-									<string key="NSAction">submenuAction:</string>
-									<object class="NSMenu" key="NSSubmenu" id="1065607017">
-										<string key="NSTitle">Open Recent</string>
-										<array class="NSMutableArray" key="NSMenuItems"></array>
-										<string key="NSName">_NSRecentDocumentsMenu</string>
-									</object>
-								</object>
-							</array>
-							<string key="NSName">_NSAppleMenu</string>
-						</object>
-					</object>
-				</array>
-				<string key="NSName">_NSMainMenu</string>
-			</object>
-		</array>
-		<object class="IBObjectContainer" key="IBDocument.Objects">
-			<array key="connectionRecords">
-				<object class="IBConnectionRecord">
-					<object class="IBActionConnection" key="connection">
-						<string key="label">terminate:</string>
-						<reference key="source" ref="1014"/>
-						<reference key="destination" ref="632727374"/>
-					</object>
-					<int key="connectionID">807</int>
-				</object>
-			</array>
-			<object class="IBMutableOrderedSet" key="objectRecords">
-				<array key="orderedObjects">
-					<object class="IBObjectRecord">
-						<int key="objectID">0</int>
-						<array key="object" id="0"/>
-						<reference key="children" ref="1048"/>
-						<nil key="parent"/>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-2</int>
-						<reference key="object" ref="1021"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">File's Owner</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-1</int>
-						<reference key="object" ref="1014"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">First Responder</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">-3</int>
-						<reference key="object" ref="1050"/>
-						<reference key="parent" ref="0"/>
-						<string key="objectName">Application</string>
-					</object>
-					<object class="IBObjectRecord">
-						<int key="objectID">371</int>
-						<reference key="object" ref="903638069"/>
-						<reference key="parent" ref="0"/>
-					</object>
-					<!-- NSMenu Main Menu -->
-					<object class="IBObjectRecord">
-						<int key="objectID">29</int>
-						<reference key="object" ref="649796088"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="694149608"/>
-						</array>
-						<reference key="parent" ref="0"/>
-					</object>
-					<!-- NSMenuItem Electron -->
-					<object class="IBObjectRecord">
-						<int key="objectID">56</int>
-						<reference key="object" ref="694149608"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="110575045"/>
-						</array>
-						<reference key="parent" ref="649796088"/>
-					</object>
-					<!-- NSMenu Electron -->
-					<object class="IBObjectRecord">
-						<int key="objectID">57</int>
-						<reference key="object" ref="110575045"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="632727374"/>
-							<reference ref="1025936716"/>
-						</array>
-						<reference key="parent" ref="694149608"/>
-					</object>
-					<!-- NSMenuItem Quit -->
-					<object class="IBObjectRecord">
-						<int key="objectID">136</int>
-						<reference key="object" ref="632727374"/>
-						<reference key="parent" ref="110575045"/>
-					</object>
-					<!-- NSMenuItem Open Recent -->
-					<object class="IBObjectRecord">
-						<int key="objectID">124</int>
-						<reference key="object" ref="1025936716"/>
-						<array class="NSMutableArray" key="children">
-							<reference ref="1065607017"/>
-						</array>
-						<reference key="parent" ref="110575045"/>
-					</object>
-					<!-- NSMenu Open Recent -->
-					<object class="IBObjectRecord">
-						<int key="objectID">125</int>
-						<reference key="object" ref="1065607017"/>
-						<array class="NSMutableArray" key="children"></array>
-						<reference key="parent" ref="1025936716"/>
-					</object>
-				</array>
-			</object>
-			<dictionary class="NSMutableDictionary" key="flattenedProperties">
-				<string key="-1.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="-2.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="-3.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="29.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="371.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="56.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="57.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="136.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="124.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-				<string key="125.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
-			</dictionary>
-			<dictionary class="NSMutableDictionary" key="unlocalizedProperties"/>
-			<nil key="activeLocalization"/>
-			<dictionary class="NSMutableDictionary" key="localizations"/>
-			<nil key="sourceID"/>
-			<int key="maxID">807</int>
-		</object>
-		<int key="IBDocument.localizationMode">0</int>
-		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaFramework</string>
-		<bool key="IBDocument.previouslyAttemptedUpgradeToXcode5">NO</bool>
-		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
-			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.InterfaceBuilder3</string>
-			<integer value="4600" key="NS.object.0"/>
-		</object>
-		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
-		<int key="IBDocument.defaultPropertyAccessControl">3</int>
-		<dictionary class="NSMutableDictionary" key="IBDocument.LastKnownImageSizes">
-			<string key="NSMenuCheckmark">{12, 12}</string>
-			<string key="NSMenuMixedState">{10, 2}</string>
-		</dictionary>
-		<bool key="IBDocument.UseAutolayout">YES</bool>
-	</data>
-</archive>
removed in remote
  base   100644 a82562f93614194343442d52921cc757fb400824 atom/renderer/api/atom_api_renderer_ipc.cc
  our    100644 3e48a4f7d0c11f40e6360b0acc2c83c38e671319 atom/renderer/api/atom_api_renderer_ipc.cc
@@ -1,76 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_renderer_ipc.h"
-#include "atom/common/api/api_messages.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/common/native_mate_converters/value_converter.h"
-#include "atom/common/node_bindings.h"
-#include "atom/common/node_includes.h"
-#include "content/public/renderer/render_frame.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-
-using blink::WebLocalFrame;
-using content::RenderFrame;
-
-namespace atom {
-
-namespace api {
-
-RenderFrame* GetCurrentRenderFrame() {
-  WebLocalFrame* frame = WebLocalFrame::FrameForCurrentContext();
-  if (!frame)
-    return nullptr;
-
-  return RenderFrame::FromWebFrame(frame);
-}
-
-void Send(mate::Arguments* args,
-          const base::string16& channel,
-          const base::ListValue& arguments) {
-  RenderFrame* render_frame = GetCurrentRenderFrame();
-  if (render_frame == nullptr)
-    return;
-
-  bool success = render_frame->Send(new AtomFrameHostMsg_Message(
-      render_frame->GetRoutingID(), channel, arguments));
-
-  if (!success)
-    args->ThrowError("Unable to send AtomFrameHostMsg_Message");
-}
-
-base::ListValue SendSync(mate::Arguments* args,
-                         const base::string16& channel,
-                         const base::ListValue& arguments) {
-  base::ListValue result;
-
-  RenderFrame* render_frame = GetCurrentRenderFrame();
-  if (render_frame == nullptr)
-    return result;
-
-  IPC::SyncMessage* message = new AtomFrameHostMsg_Message_Sync(
-      render_frame->GetRoutingID(), channel, arguments, &result);
-  bool success = render_frame->Send(message);
-
-  if (!success)
-    args->ThrowError("Unable to send AtomFrameHostMsg_Message_Sync");
-
-  return result;
-}
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  mate::Dictionary dict(context->GetIsolate(), exports);
-  dict.SetMethod("send", &Send);
-  dict.SetMethod("sendSync", &SendSync);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_renderer_ipc, atom::api::Initialize)
removed in remote
  base   100644 08f36efce5819903e97a9895afc5a08976ad8c7c atom/renderer/api/atom_api_spell_check_client.cc
  our    100644 5f7985be2f820fdb0a9b7a26032e7fc83ed34952 atom/renderer/api/atom_api_spell_check_client.cc
@@ -1,248 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_spell_check_client.h"
-
-#include <algorithm>
-#include <vector>
-
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "base/logging.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
-#include "native_mate/converter.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebTextCheckingCompletion.h"
-#include "third_party/WebKit/public/web/WebTextCheckingResult.h"
-#include "third_party/icu/source/common/unicode/uscript.h"
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-bool HasWordCharacters(const base::string16& text, int index) {
-  const base::char16* data = text.data();
-  int length = text.length();
-  while (index < length) {
-    uint32_t code = 0;
-    U16_NEXT(data, index, length, code);
-    UErrorCode error = U_ZERO_ERROR;
-    if (uscript_getScript(code, &error) != USCRIPT_COMMON)
-      return true;
-  }
-  return false;
-}
-
-}  // namespace
-
-class SpellCheckClient::SpellcheckRequest {
- public:
-  SpellcheckRequest(const base::string16& text,
-                    blink::WebTextCheckingCompletion* completion)
-      : text_(text), completion_(completion) {
-    DCHECK(completion);
-  }
-  ~SpellcheckRequest() {}
-
-  base::string16 text() { return text_; }
-  blink::WebTextCheckingCompletion* completion() { return completion_; }
-
- private:
-  base::string16 text_;  // Text to be checked in this task.
-
-  // The interface to send the misspelled ranges to WebKit.
-  blink::WebTextCheckingCompletion* completion_;
-
-  DISALLOW_COPY_AND_ASSIGN(SpellcheckRequest);
-};
-
-SpellCheckClient::SpellCheckClient(const std::string& language,
-                                   bool auto_spell_correct_turned_on,
-                                   v8::Isolate* isolate,
-                                   v8::Local<v8::Object> provider)
-    : isolate_(isolate),
-      context_(isolate, isolate->GetCurrentContext()),
-      provider_(isolate, provider) {
-  DCHECK(!context_.IsEmpty());
-
-  character_attributes_.SetDefaultLanguage(language);
-
-  // Persistent the method.
-  mate::Dictionary dict(isolate, provider);
-  dict.Get("spellCheck", &spell_check_);
-}
-
-SpellCheckClient::~SpellCheckClient() {
-  context_.Reset();
-}
-
-void SpellCheckClient::CheckSpelling(
-    const blink::WebString& text,
-    int& misspelling_start,
-    int& misspelling_len,
-    blink::WebVector<blink::WebString>* optional_suggestions) {
-  std::vector<blink::WebTextCheckingResult> results;
-  SpellCheckText(text.Utf16(), true, &results);
-  if (results.size() == 1) {
-    misspelling_start = results[0].location;
-    misspelling_len = results[0].length;
-  }
-}
-
-void SpellCheckClient::RequestCheckingOfText(
-    const blink::WebString& textToCheck,
-    blink::WebTextCheckingCompletion* completionCallback) {
-  base::string16 text(textToCheck.Utf16());
-  // Ignore invalid requests.
-  if (text.empty() || !HasWordCharacters(text, 0)) {
-    completionCallback->DidCancelCheckingText();
-    return;
-  }
-
-  // Clean up the previous request before starting a new request.
-  if (pending_request_param_.get()) {
-    pending_request_param_->completion()->DidCancelCheckingText();
-  }
-
-  pending_request_param_.reset(new SpellcheckRequest(text, completionCallback));
-
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE,
-      base::BindOnce(&SpellCheckClient::PerformSpellCheck, AsWeakPtr(),
-                     base::Owned(pending_request_param_.release())));
-}
-
-bool SpellCheckClient::IsSpellCheckingEnabled() const {
-  return true;
-}
-
-void SpellCheckClient::ShowSpellingUI(bool show) {}
-
-bool SpellCheckClient::IsShowingSpellingUI() {
-  return false;
-}
-
-void SpellCheckClient::UpdateSpellingUIWithMisspelledWord(
-    const blink::WebString& word) {}
-
-void SpellCheckClient::SpellCheckText(
-    const base::string16& text,
-    bool stop_at_first_result,
-    std::vector<blink::WebTextCheckingResult>* results) {
-  if (text.empty() || spell_check_.IsEmpty())
-    return;
-
-  if (!text_iterator_.IsInitialized() &&
-      !text_iterator_.Initialize(&character_attributes_, true)) {
-    // We failed to initialize text_iterator_, return as spelled correctly.
-    VLOG(1) << "Failed to initialize SpellcheckWordIterator";
-    return;
-  }
-
-  if (!contraction_iterator_.IsInitialized() &&
-      !contraction_iterator_.Initialize(&character_attributes_, false)) {
-    // We failed to initialize the word iterator, return as spelled correctly.
-    VLOG(1) << "Failed to initialize contraction_iterator_";
-    return;
-  }
-
-  text_iterator_.SetText(text.c_str(), text.size());
-
-  SpellCheckScope scope(*this);
-  base::string16 word;
-  int word_start;
-  int word_length;
-  for (auto status =
-           text_iterator_.GetNextWord(&word, &word_start, &word_length);
-       status != SpellcheckWordIterator::IS_END_OF_TEXT;
-       status = text_iterator_.GetNextWord(&word, &word_start, &word_length)) {
-    if (status == SpellcheckWordIterator::IS_SKIPPABLE)
-      continue;
-
-    // Found a word (or a contraction) that the spellchecker can check the
-    // spelling of.
-    if (SpellCheckWord(scope, word))
-      continue;
-
-    // If the given word is a concatenated word of two or more valid words
-    // (e.g. "hello:hello"), we should treat it as a valid word.
-    if (IsValidContraction(scope, word))
-      continue;
-
-    blink::WebTextCheckingResult result;
-    result.location = word_start;
-    result.length = word_length;
-    results->push_back(result);
-
-    if (stop_at_first_result)
-      return;
-  }
-}
-
-bool SpellCheckClient::SpellCheckWord(
-    const SpellCheckScope& scope,
-    const base::string16& word_to_check) const {
-  DCHECK(!scope.spell_check_.IsEmpty());
-
-  v8::Local<v8::Value> word = mate::ConvertToV8(isolate_, word_to_check);
-  v8::Local<v8::Value> result =
-      scope.spell_check_->Call(scope.provider_, 1, &word);
-
-  if (!result.IsEmpty() && result->IsBoolean())
-    return result->BooleanValue();
-  else
-    return true;
-}
-
-// Returns whether or not the given string is a valid contraction.
-// This function is a fall-back when the SpellcheckWordIterator class
-// returns a concatenated word which is not in the selected dictionary
-// (e.g. "in'n'out") but each word is valid.
-bool SpellCheckClient::IsValidContraction(const SpellCheckScope& scope,
-                                          const base::string16& contraction) {
-  DCHECK(contraction_iterator_.IsInitialized());
-
-  contraction_iterator_.SetText(contraction.c_str(), contraction.length());
-
-  base::string16 word;
-  int word_start;
-  int word_length;
-
-  for (auto status =
-           contraction_iterator_.GetNextWord(&word, &word_start, &word_length);
-       status != SpellcheckWordIterator::IS_END_OF_TEXT;
-       status = contraction_iterator_.GetNextWord(&word, &word_start,
-                                                  &word_length)) {
-    if (status == SpellcheckWordIterator::IS_SKIPPABLE)
-      continue;
-
-    if (!SpellCheckWord(scope, word))
-      return false;
-  }
-  return true;
-}
-
-void SpellCheckClient::PerformSpellCheck(SpellcheckRequest* param) {
-  DCHECK(param);
-
-  std::vector<blink::WebTextCheckingResult> results;
-  SpellCheckText(param->text(), false, &results);
-  param->completion()->DidFinishCheckingText(results);
-}
-
-SpellCheckClient::SpellCheckScope::SpellCheckScope(
-    const SpellCheckClient& client)
-    : handle_scope_(client.isolate_),
-      context_scope_(
-          v8::Local<v8::Context>::New(client.isolate_, client.context_)),
-      provider_(client.provider_.NewHandle()),
-      spell_check_(client.spell_check_.NewHandle()) {}
-
-SpellCheckClient::SpellCheckScope::~SpellCheckScope() = default;
-
-}  // namespace api
-
-}  // namespace atom
removed in remote
  base   100644 af72756e2ec13911ae5159944cbcca51d8365e77 atom/renderer/api/atom_api_spell_check_client.h
  our    100644 c8b5f7f4ab164307f735cc0bc0651435a42c3034 atom/renderer/api/atom_api_spell_check_client.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
-#define ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
-
-#include <string>
-#include <vector>
-
-#include "base/callback.h"
-#include "base/memory/weak_ptr.h"
-#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
-#include "native_mate/scoped_persistent.h"
-#include "third_party/WebKit/public/platform/WebSpellCheckPanelHostClient.h"
-#include "third_party/WebKit/public/platform/WebVector.h"
-#include "third_party/WebKit/public/web/WebTextCheckClient.h"
-
-namespace blink {
-struct WebTextCheckingResult;
-class WebTextCheckingCompletion;
-}  // namespace blink
-
-namespace atom {
-
-namespace api {
-
-class SpellCheckClient : public blink::WebSpellCheckPanelHostClient,
-                         public blink::WebTextCheckClient,
-                         public base::SupportsWeakPtr<SpellCheckClient> {
- public:
-  SpellCheckClient(const std::string& language,
-                   bool auto_spell_correct_turned_on,
-                   v8::Isolate* isolate,
-                   v8::Local<v8::Object> provider);
-  ~SpellCheckClient() override;
-
- private:
-  class SpellcheckRequest;
-  // blink::WebTextCheckClient:
-  void CheckSpelling(
-      const blink::WebString& text,
-      int& misspelledOffset,
-      int& misspelledLength,
-      blink::WebVector<blink::WebString>* optionalSuggestions) override;
-  void RequestCheckingOfText(
-      const blink::WebString& textToCheck,
-      blink::WebTextCheckingCompletion* completionCallback) override;
-  bool IsSpellCheckingEnabled() const override;
-
-  // blink::WebSpellCheckPanelHostClient:
-  void ShowSpellingUI(bool show) override;
-  bool IsShowingSpellingUI() override;
-  void UpdateSpellingUIWithMisspelledWord(
-      const blink::WebString& word) override;
-
-  struct SpellCheckScope {
-    v8::HandleScope handle_scope_;
-    v8::Context::Scope context_scope_;
-    v8::Local<v8::Object> provider_;
-    v8::Local<v8::Function> spell_check_;
-
-    explicit SpellCheckScope(const SpellCheckClient& client);
-    ~SpellCheckScope();
-  };
-
-  // Check the spelling of text.
-  void SpellCheckText(const base::string16& text,
-                      bool stop_at_first_result,
-                      std::vector<blink::WebTextCheckingResult>* results);
-
-  // Call JavaScript to check spelling a word.
-  bool SpellCheckWord(const SpellCheckScope& scope,
-                      const base::string16& word_to_check) const;
-
-  // Returns whether or not the given word is a contraction of valid words
-  // (e.g. "word:word").
-  bool IsValidContraction(const SpellCheckScope& scope,
-                          const base::string16& word);
-
-  // Performs spell checking from the request queue.
-  void PerformSpellCheck(SpellcheckRequest* param);
-
-  // Represents character attributes used for filtering out characters which
-  // are not supported by this SpellCheck object.
-  SpellcheckCharAttribute character_attributes_;
-
-  // Represents word iterators used in this spellchecker. The |text_iterator_|
-  // splits text provided by WebKit into words, contractions, or concatenated
-  // words. The |contraction_iterator_| splits a concatenated word extracted by
-  // |text_iterator_| into word components so we can treat a concatenated word
-  // consisting only of correct words as a correct word.
-  SpellcheckWordIterator text_iterator_;
-  SpellcheckWordIterator contraction_iterator_;
-
-  // The parameters of a pending background-spellchecking request.
-  // (When WebKit sends two or more requests, we cancel the previous
-  // requests so we do not have to use vectors.)
-  std::unique_ptr<SpellcheckRequest> pending_request_param_;
-
-  v8::Isolate* isolate_;
-  v8::Persistent<v8::Context> context_;
-  mate::ScopedPersistent<v8::Object> provider_;
-  mate::ScopedPersistent<v8::Function> spell_check_;
-
-  DISALLOW_COPY_AND_ASSIGN(SpellCheckClient);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_API_ATOM_API_SPELL_CHECK_CLIENT_H_
removed in remote
  base   100644 e00b901bfff60e8223fd11194bfd209efee72fea atom/renderer/api/atom_api_web_frame.cc
  our    100644 f0f7ef249d73876f7107d3d3865e8fc71ee33945 atom/renderer/api/atom_api_web_frame.cc
@@ -1,544 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/api/atom_api_web_frame.h"
-
-#include "atom/common/api/api_messages.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/native_mate_converters/blink_converter.h"
-#include "atom/common/native_mate_converters/callback.h"
-#include "atom/common/native_mate_converters/gfx_converter.h"
-#include "atom/common/native_mate_converters/string16_converter.h"
-#include "atom/renderer/api/atom_api_spell_check_client.h"
-#include "base/memory/memory_pressure_listener.h"
-#include "content/public/renderer/render_frame.h"
-#include "content/public/renderer/render_frame_observer.h"
-#include "content/public/renderer/render_frame_visitor.h"
-#include "content/public/renderer/render_view.h"
-#include "native_mate/dictionary.h"
-#include "native_mate/object_template_builder.h"
-#include "third_party/WebKit/Source/platform/weborigin/SchemeRegistry.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-#include "third_party/WebKit/public/web/WebDocument.h"
-#include "third_party/WebKit/public/web/WebElement.h"
-#include "third_party/WebKit/public/web/WebFrameWidget.h"
-#include "third_party/WebKit/public/web/WebImeTextSpan.h"
-#include "third_party/WebKit/public/web/WebInputMethodController.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-#include "third_party/WebKit/public/web/WebScriptExecutionCallback.h"
-#include "third_party/WebKit/public/web/WebScriptSource.h"
-#include "third_party/WebKit/public/web/WebView.h"
-
-#include "atom/common/node_includes.h"
-
-namespace mate {
-
-template <>
-struct Converter<blink::WebLocalFrame::ScriptExecutionType> {
-  static bool FromV8(v8::Isolate* isolate,
-                     v8::Local<v8::Value> val,
-                     blink::WebLocalFrame::ScriptExecutionType* out) {
-    std::string execution_type;
-    if (!ConvertFromV8(isolate, val, &execution_type))
-      return false;
-    if (execution_type == "asynchronous") {
-      *out = blink::WebLocalFrame::kAsynchronous;
-    } else if (execution_type == "asynchronousBlockingOnload") {
-      *out = blink::WebLocalFrame::kAsynchronousBlockingOnload;
-    } else if (execution_type == "synchronous") {
-      *out = blink::WebLocalFrame::kSynchronous;
-    } else {
-      return false;
-    }
-    return true;
-  }
-};
-
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-namespace {
-
-content::RenderFrame* GetRenderFrame(v8::Local<v8::Value> value) {
-  v8::Local<v8::Context> context =
-      v8::Local<v8::Object>::Cast(value)->CreationContext();
-  if (context.IsEmpty())
-    return nullptr;
-  blink::WebLocalFrame* frame = blink::WebLocalFrame::FrameForContext(context);
-  if (!frame)
-    return nullptr;
-  return content::RenderFrame::FromWebFrame(frame);
-}
-
-class RenderFrameStatus : public content::RenderFrameObserver {
- public:
-  explicit RenderFrameStatus(content::RenderFrame* render_frame)
-      : content::RenderFrameObserver(render_frame) {}
-  ~RenderFrameStatus() final {}
-
-  bool is_ok() { return render_frame() != nullptr; }
-
-  // RenderFrameObserver implementation.
-  void OnDestruct() final {}
-};
-
-class ScriptExecutionCallback : public blink::WebScriptExecutionCallback {
- public:
-  using CompletionCallback =
-      base::Callback<void(const v8::Local<v8::Value>& result)>;
-
-  explicit ScriptExecutionCallback(const CompletionCallback& callback)
-      : callback_(callback) {}
-  ~ScriptExecutionCallback() override {}
-
-  void Completed(
-      const blink::WebVector<v8::Local<v8::Value>>& result) override {
-    if (!callback_.is_null() && !result.IsEmpty() && !result[0].IsEmpty())
-      // Right now only single results per frame is supported.
-      callback_.Run(result[0]);
-    delete this;
-  }
-
- private:
-  CompletionCallback callback_;
-
-  DISALLOW_COPY_AND_ASSIGN(ScriptExecutionCallback);
-};
-
-class FrameSpellChecker : public content::RenderFrameVisitor {
- public:
-  explicit FrameSpellChecker(SpellCheckClient* spell_check_client,
-                             content::RenderFrame* main_frame)
-      : spell_check_client_(spell_check_client), main_frame_(main_frame) {}
-  ~FrameSpellChecker() override {
-    spell_check_client_ = nullptr;
-    main_frame_ = nullptr;
-  }
-  bool Visit(content::RenderFrame* render_frame) override {
-    auto* view = render_frame->GetRenderView();
-    if (view->GetMainRenderFrame() == main_frame_ ||
-        (render_frame->IsMainFrame() && render_frame == main_frame_)) {
-      render_frame->GetWebFrame()->SetTextCheckClient(spell_check_client_);
-    }
-    return true;
-  }
-
- private:
-  SpellCheckClient* spell_check_client_;
-  content::RenderFrame* main_frame_;
-  DISALLOW_COPY_AND_ASSIGN(FrameSpellChecker);
-};
-
-}  // namespace
-
-WebFrame::WebFrame(v8::Isolate* isolate)
-    : web_frame_(blink::WebLocalFrame::FrameForCurrentContext()) {
-  Init(isolate);
-}
-
-WebFrame::WebFrame(v8::Isolate* isolate, blink::WebLocalFrame* blink_frame)
-    : web_frame_(blink_frame) {
-  Init(isolate);
-}
-
-WebFrame::~WebFrame() {}
-
-void WebFrame::SetName(const std::string& name) {
-  web_frame_->SetName(blink::WebString::FromUTF8(name));
-}
-
-double WebFrame::SetZoomLevel(double level) {
-  double result = 0.0;
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromWebFrame(web_frame_);
-  render_frame->Send(new AtomFrameHostMsg_SetTemporaryZoomLevel(
-      render_frame->GetRoutingID(), level, &result));
-  return result;
-}
-
-double WebFrame::GetZoomLevel() const {
-  double result = 0.0;
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromWebFrame(web_frame_);
-  render_frame->Send(
-      new AtomFrameHostMsg_GetZoomLevel(render_frame->GetRoutingID(), &result));
-  return result;
-}
-
-double WebFrame::SetZoomFactor(double factor) {
-  return blink::WebView::ZoomLevelToZoomFactor(
-      SetZoomLevel(blink::WebView::ZoomFactorToZoomLevel(factor)));
-}
-
-double WebFrame::GetZoomFactor() const {
-  return blink::WebView::ZoomLevelToZoomFactor(GetZoomLevel());
-}
-
-void WebFrame::SetVisualZoomLevelLimits(double min_level, double max_level) {
-  web_frame_->View()->SetDefaultPageScaleLimits(min_level, max_level);
-  web_frame_->View()->SetIgnoreViewportTagScaleLimits(true);
-}
-
-void WebFrame::SetLayoutZoomLevelLimits(double min_level, double max_level) {
-  web_frame_->View()->ZoomLimitsChanged(min_level, max_level);
-}
-
-v8::Local<v8::Value> WebFrame::RegisterEmbedderCustomElement(
-    const base::string16& name,
-    v8::Local<v8::Object> options) {
-  return web_frame_->GetDocument().RegisterEmbedderCustomElement(
-      blink::WebString::FromUTF16(name), options);
-}
-
-int WebFrame::GetWebFrameId(v8::Local<v8::Value> content_window) {
-  // Get the WebLocalFrame before (possibly) executing any user-space JS while
-  // getting the |params|. We track the status of the RenderFrame via an
-  // observer in case it is deleted during user code execution.
-  content::RenderFrame* render_frame = GetRenderFrame(content_window);
-  RenderFrameStatus render_frame_status(render_frame);
-
-  if (!render_frame_status.is_ok())
-    return -1;
-
-  blink::WebLocalFrame* frame = render_frame->GetWebFrame();
-  // Parent must exist.
-  blink::WebFrame* parent_frame = frame->Parent();
-  DCHECK(parent_frame);
-  DCHECK(parent_frame->IsWebLocalFrame());
-
-  return render_frame->GetRoutingID();
-}
-
-void WebFrame::SetSpellCheckProvider(mate::Arguments* args,
-                                     const std::string& language,
-                                     bool auto_spell_correct_turned_on,
-                                     v8::Local<v8::Object> provider) {
-  if (!provider->Has(mate::StringToV8(args->isolate(), "spellCheck"))) {
-    args->ThrowError("\"spellCheck\" has to be defined");
-    return;
-  }
-
-  auto client = std::make_unique<SpellCheckClient>(
-      language, auto_spell_correct_turned_on, args->isolate(), provider);
-  // Set spellchecker for all live frames in the same process or
-  // in the sandbox mode for all live sub frames to this WebFrame.
-  FrameSpellChecker spell_checker(
-      client.get(), content::RenderFrame::FromWebFrame(web_frame_));
-  content::RenderFrame::ForEach(&spell_checker);
-  spell_check_client_.swap(client);
-  web_frame_->SetSpellCheckPanelHostClient(spell_check_client_.get());
-}
-
-void WebFrame::RegisterURLSchemeAsBypassingCSP(const std::string& scheme) {
-  // Register scheme to bypass pages's Content Security Policy.
-  blink::SchemeRegistry::RegisterURLSchemeAsBypassingContentSecurityPolicy(
-      WTF::String::FromUTF8(scheme.data(), scheme.length()));
-}
-
-void WebFrame::RegisterURLSchemeAsPrivileged(const std::string& scheme,
-                                             mate::Arguments* args) {
-  // TODO(deepak1556): blink::SchemeRegistry methods should be called
-  // before any renderer threads are created. Fixing this would break
-  // current api. Change it with 2.0.
-
-  // Read optional flags
-  bool secure = true;
-  bool bypassCSP = true;
-  bool allowServiceWorkers = true;
-  bool supportFetchAPI = true;
-  bool corsEnabled = true;
-  if (args->Length() == 2) {
-    mate::Dictionary options;
-    if (args->GetNext(&options)) {
-      options.Get("secure", &secure);
-      options.Get("bypassCSP", &bypassCSP);
-      options.Get("allowServiceWorkers", &allowServiceWorkers);
-      options.Get("supportFetchAPI", &supportFetchAPI);
-      options.Get("corsEnabled", &corsEnabled);
-    }
-  }
-  // Register scheme to privileged list (https, wss, data, chrome-extension)
-  WTF::String privileged_scheme(
-      WTF::String::FromUTF8(scheme.data(), scheme.length()));
-  if (bypassCSP) {
-    blink::SchemeRegistry::RegisterURLSchemeAsBypassingContentSecurityPolicy(
-        privileged_scheme);
-  }
-  if (allowServiceWorkers) {
-    blink::SchemeRegistry::RegisterURLSchemeAsAllowingServiceWorkers(
-        privileged_scheme);
-  }
-  if (supportFetchAPI) {
-    blink::SchemeRegistry::RegisterURLSchemeAsSupportingFetchAPI(
-        privileged_scheme);
-  }
-  if (corsEnabled) {
-    blink::SchemeRegistry::RegisterURLSchemeAsCORSEnabled(privileged_scheme);
-  }
-}
-
-void WebFrame::InsertText(const std::string& text) {
-  web_frame_->FrameWidget()->GetActiveWebInputMethodController()->CommitText(
-      blink::WebString::FromUTF8(text),
-      blink::WebVector<blink::WebImeTextSpan>(), blink::WebRange(), 0);
-}
-
-void WebFrame::InsertCSS(const std::string& css) {
-  web_frame_->GetDocument().InsertStyleSheet(blink::WebString::FromUTF8(css));
-}
-
-void WebFrame::ExecuteJavaScript(const base::string16& code,
-                                 mate::Arguments* args) {
-  bool has_user_gesture = false;
-  args->GetNext(&has_user_gesture);
-  ScriptExecutionCallback::CompletionCallback completion_callback;
-  args->GetNext(&completion_callback);
-  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
-      new ScriptExecutionCallback(completion_callback));
-  web_frame_->RequestExecuteScriptAndReturnValue(
-      blink::WebScriptSource(blink::WebString::FromUTF16(code)),
-      has_user_gesture, callback.release());
-}
-
-void WebFrame::ExecuteJavaScriptInIsolatedWorld(
-    int world_id,
-    const std::vector<mate::Dictionary>& scripts,
-    mate::Arguments* args) {
-  std::vector<blink::WebScriptSource> sources;
-
-  for (const auto& script : scripts) {
-    base::string16 code;
-    base::string16 url;
-    int start_line = 1;
-    script.Get("url", &url);
-    script.Get("startLine", &start_line);
-
-    if (!script.Get("code", &code)) {
-      args->ThrowError("Invalid 'code'");
-      return;
-    }
-
-    sources.emplace_back(
-        blink::WebScriptSource(blink::WebString::FromUTF16(code),
-                               blink::WebURL(GURL(url)), start_line));
-  }
-
-  bool has_user_gesture = false;
-  args->GetNext(&has_user_gesture);
-
-  blink::WebLocalFrame::ScriptExecutionType scriptExecutionType =
-      blink::WebLocalFrame::kSynchronous;
-  args->GetNext(&scriptExecutionType);
-
-  ScriptExecutionCallback::CompletionCallback completion_callback;
-  args->GetNext(&completion_callback);
-  std::unique_ptr<blink::WebScriptExecutionCallback> callback(
-      new ScriptExecutionCallback(completion_callback));
-
-  web_frame_->RequestExecuteScriptInIsolatedWorld(
-      world_id, &sources.front(), sources.size(), has_user_gesture,
-      scriptExecutionType, callback.release());
-}
-
-void WebFrame::SetIsolatedWorldSecurityOrigin(int world_id,
-                                              const std::string& origin_url) {
-  web_frame_->SetIsolatedWorldSecurityOrigin(
-      world_id, blink::WebSecurityOrigin::CreateFromString(
-                    blink::WebString::FromUTF8(origin_url)));
-}
-
-void WebFrame::SetIsolatedWorldContentSecurityPolicy(
-    int world_id,
-    const std::string& security_policy) {
-  web_frame_->SetIsolatedWorldContentSecurityPolicy(
-      world_id, blink::WebString::FromUTF8(security_policy));
-}
-
-void WebFrame::SetIsolatedWorldHumanReadableName(int world_id,
-                                                 const std::string& name) {
-  web_frame_->SetIsolatedWorldHumanReadableName(
-      world_id, blink::WebString::FromUTF8(name));
-}
-
-// static
-mate::Handle<WebFrame> WebFrame::Create(v8::Isolate* isolate) {
-  return mate::CreateHandle(isolate, new WebFrame(isolate));
-}
-
-blink::WebCache::ResourceTypeStats WebFrame::GetResourceUsage(
-    v8::Isolate* isolate) {
-  blink::WebCache::ResourceTypeStats stats;
-  blink::WebCache::GetResourceTypeStats(&stats);
-  return stats;
-}
-
-void WebFrame::ClearCache(v8::Isolate* isolate) {
-  isolate->IdleNotificationDeadline(0.5);
-  blink::WebCache::Clear();
-  base::MemoryPressureListener::NotifyMemoryPressure(
-      base::MemoryPressureListener::MEMORY_PRESSURE_LEVEL_CRITICAL);
-}
-
-v8::Local<v8::Value> WebFrame::Opener() const {
-  blink::WebFrame* frame = web_frame_->Opener();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::Parent() const {
-  blink::WebFrame* frame = web_frame_->Parent();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::Top() const {
-  blink::WebFrame* frame = web_frame_->Top();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FirstChild() const {
-  blink::WebFrame* frame = web_frame_->FirstChild();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::NextSibling() const {
-  blink::WebFrame* frame = web_frame_->NextSibling();
-  if (frame && frame->IsWebLocalFrame())
-    return mate::CreateHandle(isolate(),
-                              new WebFrame(isolate(), frame->ToWebLocalFrame()))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::GetFrameForSelector(
-    const std::string& selector) const {
-  blink::WebElement element = web_frame_->GetDocument().QuerySelector(
-      blink::WebString::FromUTF8(selector));
-  blink::WebLocalFrame* element_frame =
-      blink::WebLocalFrame::FromFrameOwnerElement(element);
-  if (element_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), element_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FindFrameByName(const std::string& name) const {
-  blink::WebLocalFrame* local_frame =
-      web_frame_->FindFrameByName(blink::WebString::FromUTF8(name))
-          ->ToWebLocalFrame();
-  if (local_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), local_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::FindFrameByRoutingId(int routing_id) const {
-  content::RenderFrame* render_frame =
-      content::RenderFrame::FromRoutingID(routing_id);
-  blink::WebLocalFrame* local_frame = nullptr;
-  if (render_frame)
-    local_frame = render_frame->GetWebFrame();
-  if (local_frame)
-    return mate::CreateHandle(isolate(), new WebFrame(isolate(), local_frame))
-        .ToV8();
-  else
-    return v8::Null(isolate());
-}
-
-v8::Local<v8::Value> WebFrame::RoutingId() const {
-  int routing_id = content::RenderFrame::GetRoutingIdForWebFrame(web_frame_);
-  return v8::Number::New(isolate(), routing_id);
-}
-
-// static
-void WebFrame::BuildPrototype(v8::Isolate* isolate,
-                              v8::Local<v8::FunctionTemplate> prototype) {
-  prototype->SetClassName(mate::StringToV8(isolate, "WebFrame"));
-  mate::ObjectTemplateBuilder(isolate, prototype->PrototypeTemplate())
-      .SetMethod("setName", &WebFrame::SetName)
-      .SetMethod("setZoomLevel", &WebFrame::SetZoomLevel)
-      .SetMethod("getZoomLevel", &WebFrame::GetZoomLevel)
-      .SetMethod("setZoomFactor", &WebFrame::SetZoomFactor)
-      .SetMethod("getZoomFactor", &WebFrame::GetZoomFactor)
-      .SetMethod("setVisualZoomLevelLimits",
-                 &WebFrame::SetVisualZoomLevelLimits)
-      .SetMethod("setLayoutZoomLevelLimits",
-                 &WebFrame::SetLayoutZoomLevelLimits)
-      .SetMethod("registerEmbedderCustomElement",
-                 &WebFrame::RegisterEmbedderCustomElement)
-      .SetMethod("getWebFrameId", &WebFrame::GetWebFrameId)
-      .SetMethod("setSpellCheckProvider", &WebFrame::SetSpellCheckProvider)
-      .SetMethod("registerURLSchemeAsBypassingCSP",
-                 &WebFrame::RegisterURLSchemeAsBypassingCSP)
-      .SetMethod("registerURLSchemeAsPrivileged",
-                 &WebFrame::RegisterURLSchemeAsPrivileged)
-      .SetMethod("insertText", &WebFrame::InsertText)
-      .SetMethod("insertCSS", &WebFrame::InsertCSS)
-      .SetMethod("executeJavaScript", &WebFrame::ExecuteJavaScript)
-      .SetMethod("executeJavaScriptInIsolatedWorld",
-                 &WebFrame::ExecuteJavaScriptInIsolatedWorld)
-      .SetMethod("setIsolatedWorldSecurityOrigin",
-                 &WebFrame::SetIsolatedWorldSecurityOrigin)
-      .SetMethod("setIsolatedWorldContentSecurityPolicy",
-                 &WebFrame::SetIsolatedWorldContentSecurityPolicy)
-      .SetMethod("setIsolatedWorldHumanReadableName",
-                 &WebFrame::SetIsolatedWorldHumanReadableName)
-      .SetMethod("getResourceUsage", &WebFrame::GetResourceUsage)
-      .SetMethod("clearCache", &WebFrame::ClearCache)
-      .SetMethod("getFrameForSelector", &WebFrame::GetFrameForSelector)
-      .SetMethod("findFrameByName", &WebFrame::FindFrameByName)
-      .SetProperty("opener", &WebFrame::Opener)
-      .SetProperty("parent", &WebFrame::Parent)
-      .SetProperty("top", &WebFrame::Top)
-      .SetProperty("firstChild", &WebFrame::FirstChild)
-      .SetProperty("nextSibling", &WebFrame::NextSibling)
-      .SetProperty("routingId", &WebFrame::RoutingId)
-      .SetMethod("findFrameByRoutingId", &WebFrame::FindFrameByRoutingId);
-}
-
-}  // namespace api
-
-}  // namespace atom
-
-namespace {
-
-using atom::api::WebFrame;
-
-void Initialize(v8::Local<v8::Object> exports,
-                v8::Local<v8::Value> unused,
-                v8::Local<v8::Context> context,
-                void* priv) {
-  v8::Isolate* isolate = context->GetIsolate();
-  mate::Dictionary dict(isolate, exports);
-  dict.Set("webFrame", WebFrame::Create(isolate));
-  dict.Set("WebFrame", WebFrame::GetConstructor(isolate)->GetFunction());
-}
-
-}  // namespace
-
-NODE_BUILTIN_MODULE_CONTEXT_AWARE(atom_renderer_web_frame, Initialize)
removed in remote
  base   100644 d55b24fd25ea474104ccf32f48103c39a79c8f56 atom/renderer/api/atom_api_web_frame.h
  our    100644 4cc6386abcb41cfa29fdc002f6fb267329bb112d atom/renderer/api/atom_api_web_frame.h
@@ -1,113 +0,0 @@
-// Copyright (c) 2014 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
-#define ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
-
-#include <memory>
-#include <string>
-#include <vector>
-
-#include "native_mate/handle.h"
-#include "native_mate/wrappable.h"
-#include "third_party/WebKit/public/platform/WebCache.h"
-
-namespace blink {
-class WebLocalFrame;
-}
-
-namespace mate {
-class Dictionary;
-class Arguments;
-}  // namespace mate
-
-namespace atom {
-
-namespace api {
-
-class SpellCheckClient;
-
-class WebFrame : public mate::Wrappable<WebFrame> {
- public:
-  static mate::Handle<WebFrame> Create(v8::Isolate* isolate);
-
-  static void BuildPrototype(v8::Isolate* isolate,
-                             v8::Local<v8::FunctionTemplate> prototype);
-
- private:
-  explicit WebFrame(v8::Isolate* isolate);
-  explicit WebFrame(v8::Isolate* isolate, blink::WebLocalFrame* blink_frame);
-  ~WebFrame() override;
-
-  void SetName(const std::string& name);
-
-  double SetZoomLevel(double level);
-  double GetZoomLevel() const;
-  double SetZoomFactor(double factor);
-  double GetZoomFactor() const;
-
-  void SetVisualZoomLevelLimits(double min_level, double max_level);
-  void SetLayoutZoomLevelLimits(double min_level, double max_level);
-
-  v8::Local<v8::Value> RegisterEmbedderCustomElement(
-      const base::string16& name,
-      v8::Local<v8::Object> options);
-  int GetWebFrameId(v8::Local<v8::Value> content_window);
-
-  // Set the provider that will be used by SpellCheckClient for spell check.
-  void SetSpellCheckProvider(mate::Arguments* args,
-                             const std::string& language,
-                             bool auto_spell_correct_turned_on,
-                             v8::Local<v8::Object> provider);
-
-  void RegisterURLSchemeAsBypassingCSP(const std::string& scheme);
-  void RegisterURLSchemeAsPrivileged(const std::string& scheme,
-                                     mate::Arguments* args);
-
-  // Editing.
-  void InsertText(const std::string& text);
-  void InsertCSS(const std::string& css);
-
-  // Executing scripts.
-  void ExecuteJavaScript(const base::string16& code, mate::Arguments* args);
-  void ExecuteJavaScriptInIsolatedWorld(
-      int world_id,
-      const std::vector<mate::Dictionary>& scripts,
-      mate::Arguments* args);
-
-  // Isolated world related methods
-  void SetIsolatedWorldSecurityOrigin(int world_id,
-                                      const std::string& origin_url);
-  void SetIsolatedWorldContentSecurityPolicy(
-      int world_id,
-      const std::string& security_policy);
-  void SetIsolatedWorldHumanReadableName(int world_id, const std::string& name);
-
-  // Resource related methods
-  blink::WebCache::ResourceTypeStats GetResourceUsage(v8::Isolate* isolate);
-  void ClearCache(v8::Isolate* isolate);
-
-  // Frame navigation
-  v8::Local<v8::Value> Opener() const;
-  v8::Local<v8::Value> Parent() const;
-  v8::Local<v8::Value> Top() const;
-  v8::Local<v8::Value> FirstChild() const;
-  v8::Local<v8::Value> NextSibling() const;
-  v8::Local<v8::Value> GetFrameForSelector(const std::string& selector) const;
-  v8::Local<v8::Value> FindFrameByName(const std::string& name) const;
-  v8::Local<v8::Value> FindFrameByRoutingId(int routing_id) const;
-  v8::Local<v8::Value> RoutingId() const;
-
-  std::unique_ptr<SpellCheckClient> spell_check_client_;
-
-  blink::WebLocalFrame* web_frame_;
-
-  DISALLOW_COPY_AND_ASSIGN(WebFrame);
-};
-
-}  // namespace api
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_API_ATOM_API_WEB_FRAME_H_
removed in remote
  base   100644 bbaea351378bf2c9115b87b762a8b2af7e15b844 atom/renderer/atom_render_view_observer.cc
  our    100644 1a425dfa1d40953efb192c3405baff61e96cb734 atom/renderer/atom_render_view_observer.cc
@@ -1,37 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/atom_render_view_observer.h"
-
-#include "atom/common/api/api_messages.h"
-#include "content/public/renderer/render_view.h"
-#include "ipc/ipc_message_macros.h"
-#include "third_party/WebKit/public/web/WebView.h"
-
-namespace atom {
-
-AtomRenderViewObserver::AtomRenderViewObserver(content::RenderView* render_view)
-    : content::RenderViewObserver(render_view) {}
-
-AtomRenderViewObserver::~AtomRenderViewObserver() {}
-
-bool AtomRenderViewObserver::OnMessageReceived(const IPC::Message& message) {
-  bool handled = true;
-  IPC_BEGIN_MESSAGE_MAP(AtomRenderViewObserver, message)
-    IPC_MESSAGE_HANDLER(AtomViewMsg_Offscreen, OnOffscreen)
-    IPC_MESSAGE_UNHANDLED(handled = false)
-  IPC_END_MESSAGE_MAP()
-
-  return handled;
-}
-
-void AtomRenderViewObserver::OnDestruct() {
-  delete this;
-}
-
-void AtomRenderViewObserver::OnOffscreen() {
-  blink::WebView::SetUseExternalPopupMenus(false);
-}
-
-}  // namespace atom
removed in remote
  base   100644 4b9d59f3fa08720ab25170a4c0cc785ba1c170de atom/renderer/atom_render_view_observer.h
  our    100644 097616e12369662473c12645a93e27cffcb55e3b atom/renderer/atom_render_view_observer.h
@@ -1,31 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
-#define ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
-
-#include "content/public/renderer/render_view_observer.h"
-
-namespace atom {
-
-class AtomRenderViewObserver : public content::RenderViewObserver {
- public:
-  explicit AtomRenderViewObserver(content::RenderView* render_view);
-
- protected:
-  ~AtomRenderViewObserver() override;
-
- private:
-  // content::RenderViewObserver implementation.
-  bool OnMessageReceived(const IPC::Message& message) override;
-  void OnDestruct() override;
-
-  void OnOffscreen();
-
-  DISALLOW_COPY_AND_ASSIGN(AtomRenderViewObserver);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_ATOM_RENDER_VIEW_OBSERVER_H_
removed in remote
  base   100644 7746ce123e4ffdec46196aae5b69295672ccdcc8 atom/renderer/atom_renderer_client.cc
  our    100644 204f17c2cf0d2d4ec4a71bdbecfcd1cbdc5fc8be atom/renderer/atom_renderer_client.cc
@@ -1,230 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/atom_renderer_client.h"
-
-#include <string>
-#include <vector>
-
-#include "atom/common/api/atom_bindings.h"
-#include "atom/common/api/event_emitter_caller.h"
-#include "atom/common/asar/asar_util.h"
-#include "atom/common/node_bindings.h"
-#include "atom/common/options_switches.h"
-#include "atom/renderer/api/atom_api_renderer_ipc.h"
-#include "atom/renderer/atom_render_frame_observer.h"
-#include "atom/renderer/web_worker_observer.h"
-#include "base/command_line.h"
-#include "content/public/renderer/render_frame.h"
-#include "native_mate/dictionary.h"
-#include "third_party/WebKit/public/web/WebDocument.h"
-#include "third_party/WebKit/public/web/WebLocalFrame.h"
-
-#include "atom/common/node_includes.h"
-#include "atom_natives.h"  // NOLINT: This file is generated with js2c
-#include "tracing/trace_event.h"
-
-namespace atom {
-
-namespace {
-
-bool IsDevToolsExtension(content::RenderFrame* render_frame) {
-  return static_cast<GURL>(render_frame->GetWebFrame()->GetDocument().Url())
-      .SchemeIs("chrome-extension");
-}
-
-}  // namespace
-
-AtomRendererClient::AtomRendererClient()
-    : node_bindings_(NodeBindings::Create(NodeBindings::RENDERER)),
-      atom_bindings_(new AtomBindings(uv_default_loop())) {}
-
-AtomRendererClient::~AtomRendererClient() {
-  asar::ClearArchives();
-}
-
-void AtomRendererClient::RenderThreadStarted() {
-  RendererClientBase::RenderThreadStarted();
-}
-
-void AtomRendererClient::RenderFrameCreated(
-    content::RenderFrame* render_frame) {
-  new AtomRenderFrameObserver(render_frame, this);
-  RendererClientBase::RenderFrameCreated(render_frame);
-}
-
-void AtomRendererClient::RenderViewCreated(content::RenderView* render_view) {
-  RendererClientBase::RenderViewCreated(render_view);
-}
-
-void AtomRendererClient::RunScriptsAtDocumentStart(
-    content::RenderFrame* render_frame) {
-  // Inform the document start pharse.
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  node::Environment* env = GetEnvironment(render_frame);
-  if (env)
-    mate::EmitEvent(env->isolate(), env->process_object(), "document-start");
-}
-
-void AtomRendererClient::RunScriptsAtDocumentEnd(
-    content::RenderFrame* render_frame) {
-  // Inform the document end pharse.
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  node::Environment* env = GetEnvironment(render_frame);
-  if (env)
-    mate::EmitEvent(env->isolate(), env->process_object(), "document-end");
-}
-
-void AtomRendererClient::DidCreateScriptContext(
-    v8::Handle<v8::Context> context,
-    content::RenderFrame* render_frame) {
-  RendererClientBase::DidCreateScriptContext(context, render_frame);
-
-  // Only allow node integration for the main frame, unless it is a devtools
-  // extension page.
-  if (!render_frame->IsMainFrame() && !IsDevToolsExtension(render_frame))
-    return;
-
-  injected_frames_.insert(render_frame);
-
-  // Prepare the node bindings.
-  if (!node_integration_initialized_) {
-    node_integration_initialized_ = true;
-    node_bindings_->Initialize();
-    node_bindings_->PrepareMessageLoop();
-  }
-
-  // Setup node tracing controller.
-  if (!node::tracing::TraceEventHelper::GetTracingController())
-    node::tracing::TraceEventHelper::SetTracingController(
-        new v8::TracingController());
-
-  // Setup node environment for each window.
-  node::Environment* env = node_bindings_->CreateEnvironment(context);
-  environments_.insert(env);
-
-  // Add Electron extended APIs.
-  atom_bindings_->BindTo(env->isolate(), env->process_object());
-  AddRenderBindings(env->isolate(), env->process_object());
-
-  // Load everything.
-  node_bindings_->LoadEnvironment(env);
-
-  if (node_bindings_->uv_env() == nullptr) {
-    // Make uv loop being wrapped by window context.
-    node_bindings_->set_uv_env(env);
-
-    // Give the node loop a run to make sure everything is ready.
-    node_bindings_->RunMessageLoop();
-  }
-}
-
-void AtomRendererClient::WillReleaseScriptContext(
-    v8::Handle<v8::Context> context,
-    content::RenderFrame* render_frame) {
-  if (injected_frames_.find(render_frame) == injected_frames_.end())
-    return;
-  injected_frames_.erase(render_frame);
-
-  node::Environment* env = node::Environment::GetCurrent(context);
-  if (environments_.find(env) == environments_.end())
-    return;
-  environments_.erase(env);
-
-  mate::EmitEvent(env->isolate(), env->process_object(), "exit");
-
-  // The main frame may be replaced.
-  if (env == node_bindings_->uv_env())
-    node_bindings_->set_uv_env(nullptr);
-
-  // Destroy the node environment.
-  // This is disabled because pending async tasks may still use the environment
-  // and would cause crashes later. Node does not seem to clear all async tasks
-  // when the environment is destroyed.
-  // node::FreeEnvironment(env);
-
-  // AtomBindings is tracking node environments.
-  atom_bindings_->EnvironmentDestroyed(env);
-}
-
-bool AtomRendererClient::ShouldFork(blink::WebLocalFrame* frame,
-                                    const GURL& url,
-                                    const std::string& http_method,
-                                    bool is_initial_navigation,
-                                    bool is_server_redirect,
-                                    bool* send_referrer) {
-  // Handle all the navigations and reloads in browser.
-  // FIXME We only support GET here because http method will be ignored when
-  // the OpenURLFromTab is triggered, which means form posting would not work,
-  // we should solve this by patching Chromium in future.
-  *send_referrer = true;
-  return http_method == "GET";
-}
-
-void AtomRendererClient::DidInitializeWorkerContextOnWorkerThread(
-    v8::Local<v8::Context> context) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kNodeIntegrationInWorker)) {
-    WebWorkerObserver::GetCurrent()->ContextCreated(context);
-  }
-}
-
-void AtomRendererClient::WillDestroyWorkerContextOnWorkerThread(
-    v8::Local<v8::Context> context) {
-  if (base::CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kNodeIntegrationInWorker)) {
-    WebWorkerObserver::GetCurrent()->ContextWillDestroy(context);
-  }
-}
-
-void AtomRendererClient::SetupMainWorldOverrides(
-    v8::Handle<v8::Context> context) {
-  // Setup window overrides in the main world context
-  v8::Isolate* isolate = context->GetIsolate();
-
-  // Wrap the bundle into a function that receives the binding object as
-  // an argument.
-  std::string left = "(function (binding, require) {\n";
-  std::string right = "\n})";
-  auto script = v8::Script::Compile(v8::String::Concat(
-      mate::ConvertToV8(isolate, left)->ToString(),
-      v8::String::Concat(node::isolated_bundle_value.ToStringChecked(isolate),
-                         mate::ConvertToV8(isolate, right)->ToString())));
-  auto func =
-      v8::Handle<v8::Function>::Cast(script->Run(context).ToLocalChecked());
-
-  auto binding = v8::Object::New(isolate);
-  api::Initialize(binding, v8::Null(isolate), context, nullptr);
-
-  // Pass in CLI flags needed to setup window
-  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
-  mate::Dictionary dict(isolate, binding);
-  if (command_line->HasSwitch(switches::kGuestInstanceID))
-    dict.Set(options::kGuestInstanceID,
-             command_line->GetSwitchValueASCII(switches::kGuestInstanceID));
-  if (command_line->HasSwitch(switches::kOpenerID))
-    dict.Set(options::kOpenerID,
-             command_line->GetSwitchValueASCII(switches::kOpenerID));
-  dict.Set("hiddenPage", command_line->HasSwitch(switches::kHiddenPage));
-  dict.Set(options::kNativeWindowOpen,
-           command_line->HasSwitch(switches::kNativeWindowOpen));
-
-  v8::Local<v8::Value> args[] = {binding};
-  ignore_result(func->Call(context, v8::Null(isolate), 1, args));
-}
-
-node::Environment* AtomRendererClient::GetEnvironment(
-    content::RenderFrame* render_frame) const {
-  if (injected_frames_.find(render_frame) == injected_frames_.end())
-    return nullptr;
-  v8::HandleScope handle_scope(v8::Isolate::GetCurrent());
-  auto context =
-      GetContext(render_frame->GetWebFrame(), v8::Isolate::GetCurrent());
-  node::Environment* env = node::Environment::GetCurrent(context);
-  if (environments_.find(env) == environments_.end())
-    return nullptr;
-  return env;
-}
-
-}  // namespace atom
removed in remote
  base   100644 59b407ba1efb230a001043f7fb25b1c4cb1d0b53 atom/renderer/atom_renderer_client.h
  our    100644 3e81cd4c647b8fddc01da868d0e8a53bcb59b5b4 atom/renderer/atom_renderer_client.h
@@ -1,83 +0,0 @@
-// Copyright (c) 2013 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
-#define ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
-
-#include <set>
-#include <string>
-#include <vector>
-
-#include "atom/renderer/renderer_client_base.h"
-
-namespace node {
-class Environment;
-}
-
-namespace atom {
-
-class AtomBindings;
-class NodeBindings;
-
-class AtomRendererClient : public RendererClientBase {
- public:
-  AtomRendererClient();
-  ~AtomRendererClient() override;
-
-  // atom::RendererClientBase:
-  void DidCreateScriptContext(v8::Handle<v8::Context> context,
-                              content::RenderFrame* render_frame) override;
-  void WillReleaseScriptContext(v8::Handle<v8::Context> context,
-                                content::RenderFrame* render_frame) override;
-  void SetupMainWorldOverrides(v8::Handle<v8::Context> context) override;
-
- private:
-  enum NodeIntegration {
-    ALL,
-    EXCEPT_IFRAME,
-    MANUAL_ENABLE_IFRAME,
-    DISABLE,
-  };
-
-  // content::ContentRendererClient:
-  void RenderThreadStarted() override;
-  void RenderFrameCreated(content::RenderFrame*) override;
-  void RenderViewCreated(content::RenderView*) override;
-  void RunScriptsAtDocumentStart(content::RenderFrame* render_frame) override;
-  void RunScriptsAtDocumentEnd(content::RenderFrame* render_frame) override;
-  bool ShouldFork(blink::WebLocalFrame* frame,
-                  const GURL& url,
-                  const std::string& http_method,
-                  bool is_initial_navigation,
-                  bool is_server_redirect,
-                  bool* send_referrer) override;
-  void DidInitializeWorkerContextOnWorkerThread(
-      v8::Local<v8::Context> context) override;
-  void WillDestroyWorkerContextOnWorkerThread(
-      v8::Local<v8::Context> context) override;
-
-  node::Environment* GetEnvironment(content::RenderFrame* frame) const;
-
-  // Whether the node integration has been initialized.
-  bool node_integration_initialized_ = false;
-
-  std::unique_ptr<NodeBindings> node_bindings_;
-  std::unique_ptr<AtomBindings> atom_bindings_;
-
-  // The node::Environment::GetCurrent API does not return nullptr when it
-  // is called for a context without node::Environment, so we have to keep
-  // a book of the environments created.
-  std::set<node::Environment*> environments_;
-
-  // Getting main script context from web frame would lazily initializes
-  // its script context. Doing so in a web page without scripts would trigger
-  // assertion, so we have to keep a book of injected web frames.
-  std::set<content::RenderFrame*> injected_frames_;
-
-  DISALLOW_COPY_AND_ASSIGN(AtomRendererClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_ATOM_RENDERER_CLIENT_H_
removed in remote
  base   100644 f50c3f78685c0886b44f82cad7e48e2ed90ae385 atom/renderer/guest_view_container.cc
  our    100644 6ad5cd0703f50481749b467d7fe99575dc0731c7 atom/renderer/guest_view_container.cc
@@ -1,63 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/renderer/guest_view_container.h"
-
-#include <map>
-
-#include "base/bind.h"
-#include "base/lazy_instance.h"
-#include "base/threading/thread_task_runner_handle.h"
-#include "ui/gfx/geometry/size.h"
-
-namespace atom {
-
-namespace {
-
-using GuestViewContainerMap = std::map<int, GuestViewContainer*>;
-static base::LazyInstance<GuestViewContainerMap>::DestructorAtExit
-    g_guest_view_container_map = LAZY_INSTANCE_INITIALIZER;
-
-}  // namespace
-
-GuestViewContainer::GuestViewContainer(content::RenderFrame* render_frame)
-    : weak_ptr_factory_(this) {}
-
-GuestViewContainer::~GuestViewContainer() {
-  if (element_instance_id_ > 0)
-    g_guest_view_container_map.Get().erase(element_instance_id_);
-}
-
-// static
-GuestViewContainer* GuestViewContainer::FromID(int element_instance_id) {
-  GuestViewContainerMap* guest_view_containers =
-      g_guest_view_container_map.Pointer();
-  auto it = guest_view_containers->find(element_instance_id);
-  return it == guest_view_containers->end() ? nullptr : it->second;
-}
-
-void GuestViewContainer::RegisterElementResizeCallback(
-    const ResizeCallback& callback) {
-  element_resize_callback_ = callback;
-}
-
-void GuestViewContainer::SetElementInstanceID(int element_instance_id) {
-  element_instance_id_ = element_instance_id;
-  g_guest_view_container_map.Get().insert(
-      std::make_pair(element_instance_id, this));
-}
-
-void GuestViewContainer::DidResizeElement(const gfx::Size& new_size) {
-  if (element_resize_callback_.is_null())
-    return;
-
-  base::ThreadTaskRunnerHandle::Get()->PostTask(
-      FROM_HERE, base::BindOnce(element_resize_callback_, new_size));
-}
-
-base::WeakPtr<content::BrowserPluginDelegate> GuestViewContainer::GetWeakPtr() {
-  return weak_ptr_factory_.GetWeakPtr();
-}
-
-}  // namespace atom
removed in remote
  base   100644 3771c7adc4e6c1dc31cdb0be4a5cf5025053733c atom/renderer/guest_view_container.h
  our    100644 81e6313358a9a64728a94f52a31a4f40e5547d7a atom/renderer/guest_view_container.h
@@ -1,46 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
-#define ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
-
-#include "base/callback.h"
-#include "content/public/renderer/browser_plugin_delegate.h"
-#include "content/public/renderer/render_frame.h"
-
-namespace gfx {
-class Size;
-}
-
-namespace atom {
-
-class GuestViewContainer : public content::BrowserPluginDelegate {
- public:
-  typedef base::Callback<void(const gfx::Size&)> ResizeCallback;
-
-  explicit GuestViewContainer(content::RenderFrame* render_frame);
-  ~GuestViewContainer() override;
-
-  static GuestViewContainer* FromID(int element_instance_id);
-
-  void RegisterElementResizeCallback(const ResizeCallback& callback);
-
-  // content::BrowserPluginDelegate:
-  void SetElementInstanceID(int element_instance_id) final;
-  void DidResizeElement(const gfx::Size& new_size) final;
-  base::WeakPtr<BrowserPluginDelegate> GetWeakPtr() final;
-
- private:
-  int element_instance_id_;
-
-  ResizeCallback element_resize_callback_;
-
-  base::WeakPtrFactory<GuestViewContainer> weak_ptr_factory_;
-
-  DISALLOW_COPY_AND_ASSIGN(GuestViewContainer);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_RENDERER_GUEST_VIEW_CONTAINER_H_
removed in remote
  base   100644 1da2c29fd9ca2138134e5cf2db2da57aba31f35c atom/renderer/resources/mac/Info.plist
  our    100644 1da2c29fd9ca2138134e5cf2db2da57aba31f35c atom/renderer/resources/mac/Info.plist
@@ -1,16 +0,0 @@
-<?xml version="1.0" encoding="UTF-8"?>
-<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
-<plist version="1.0">
-<dict>
-  <key>CFBundleIdentifier</key>
-  <string>${ATOM_BUNDLE_ID}</string>
-  <key>CFBundleName</key>
-  <string>${PRODUCT_NAME}</string>
-  <key>CFBundlePackageType</key>
-  <string>APPL</string>
-  <key>LSUIElement</key>
-  <true/>
-  <key>NSSupportsAutomaticGraphicsSwitching</key>
-  <true/>
-</dict>
-</plist>
removed in remote
  base   100644 2e591f2c6a8dadb3bb624aa395276377e0d43a6b atom/utility/atom_content_utility_client.cc
  our    100644 e2a856d53ae243de988c43b0a3335b9391e54b4e atom/utility/atom_content_utility_client.cc
@@ -1,32 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#include "atom/utility/atom_content_utility_client.h"
-
-#if defined(OS_WIN)
-#include "chrome/utility/printing_handler_win.h"
-#endif
-
-namespace atom {
-
-AtomContentUtilityClient::AtomContentUtilityClient() {
-#if defined(OS_WIN)
-  handlers_.push_back(std::make_unique<printing::PrintingHandlerWin>());
-#endif
-}
-
-AtomContentUtilityClient::~AtomContentUtilityClient() {}
-
-bool AtomContentUtilityClient::OnMessageReceived(const IPC::Message& message) {
-#if defined(OS_WIN)
-  for (const auto& handler : handlers_) {
-    if (handler->OnMessageReceived(message))
-      return true;
-  }
-#endif
-
-  return false;
-}
-
-}  // namespace atom
removed in remote
  base   100644 229ae3f91765d36041f1360a635840524eb9febd atom/utility/atom_content_utility_client.h
  our    100644 7694970457b745a84ecab24a2f0ec8eaefa8a1ad atom/utility/atom_content_utility_client.h
@@ -1,36 +0,0 @@
-// Copyright (c) 2015 GitHub, Inc.
-// Use of this source code is governed by the MIT license that can be
-// found in the LICENSE file.
-
-#ifndef ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
-#define ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
-
-#include <memory>
-#include <vector>
-
-#include "base/compiler_specific.h"
-#include "content/public/utility/content_utility_client.h"
-
-class UtilityMessageHandler;
-
-namespace atom {
-
-class AtomContentUtilityClient : public content::ContentUtilityClient {
- public:
-  AtomContentUtilityClient();
-  ~AtomContentUtilityClient() override;
-
-  bool OnMessageReceived(const IPC::Message& message) override;
-
- private:
-#if defined(OS_WIN)
-  typedef std::vector<std::unique_ptr<UtilityMessageHandler>> Handlers;
-  Handlers handlers_;
-#endif
-
-  DISALLOW_COPY_AND_ASSIGN(AtomContentUtilityClient);
-};
-
-}  // namespace atom
-
-#endif  // ATOM_UTILITY_ATOM_CONTENT_UTILITY_CLIENT_H_
changed in both
  base   100644 a195ad4c6adfc9726faaf297e037fa7c863a67a9 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
  our    100644 a346478c49fb355db5bfb163deafbb6f7a98ab20 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
  their  100644 d47c855f6b90654a08b7b32275fd46ec6e17eaf1 chromium_src/chrome/browser/printing/print_preview_message_handler.cc
@@ -18,7 +18,7 @@
 #include "printing/pdf_metafile_skia.h"
 #include "printing/print_job_constants.h"
 
-#include "atom/common/node_includes.h"
+#include "electron/common/node_includes.h"
 
 using content::BrowserThread;
 using content::WebContents;
@@ -107,7 +107,7 @@
 
 void PrintPreviewMessageHandler::PrintToPDF(
     const base::DictionaryValue& options,
-    const atom::api::WebContents::PrintToPDFCallback& callback) {
+    const electron::api::WebContents::PrintToPDFCallback& callback) {
   int request_id;
   options.GetInteger(printing::kPreviewRequestID, &request_id);
   print_to_pdf_callback_map_[request_id] = callback;
changed in both
  base   100644 1aac74baa229923460ac3d8d230159f90f23fe5f chromium_src/chrome/browser/printing/print_preview_message_handler.h
  our    100644 465bbf598319551525ef629b46943c4d905577ce chromium_src/chrome/browser/printing/print_preview_message_handler.h
  their  100644 9ade37bb732798e65ff18e1c540624c6a6a297fe chromium_src/chrome/browser/printing/print_preview_message_handler.h
@@ -7,7 +7,7 @@
 
 #include <map>
 
-#include "atom/browser/api/atom_api_web_contents.h"
+#include "electron/browser/api/electron_api_web_contents.h"
 #include "base/compiler_specific.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "content/public/browser/web_contents_user_data.h"
@@ -34,10 +34,10 @@
                          content::RenderFrameHost* render_frame_host) override;
 
   void PrintToPDF(const base::DictionaryValue& options,
-                  const atom::api::WebContents::PrintToPDFCallback& callback);
+                  const electron::api::WebContents::PrintToPDFCallback& callback);
 
  private:
-  typedef std::map<int, atom::api::WebContents::PrintToPDFCallback>
+  typedef std::map<int, electron::api::WebContents::PrintToPDFCallback>
       PrintToPDFCallbackMap;
 
   explicit PrintPreviewMessageHandler(content::WebContents* web_contents);
changed in both
  base   100644 7e54d9b5d37039ebc9adf3656c984e029328433d chromium_src/chrome/browser/process_singleton_posix.cc
  our    100644 4891743710d16673c6a72d76a303f6ac56a5ad32 chromium_src/chrome/browser/process_singleton_posix.cc
  their  100644 1d157cf625218de7b32ac2e29ffe581843ad1215 chromium_src/chrome/browser/process_singleton_posix.cc
@@ -53,11 +53,15 @@
 #include <set>
 #include <string>
 
+<<<<<<< .our
 #include <stddef.h>
 
 #include "atom/browser/browser.h"
 #include "atom/common/atom_command_line.h"
 
+=======
+#include "electron/common/electron_command_line.h"
+>>>>>>> .their
 #include "base/base_paths.h"
 #include "base/bind.h"
 #include "base/command_line.h"
@@ -824,7 +828,7 @@
     return PROCESS_NONE;
   to_send.append(current_dir.value());
 
-  const std::vector<std::string>& argv = atom::AtomCommandLine::argv();
+  const std::vector<std::string>& argv = electron::ElectronCommandLine::argv();
   for (std::vector<std::string>::const_iterator it = argv.begin();
        it != argv.end(); ++it) {
     to_send.push_back(kTokenDelimiter);
changed in both
  base   100644 fd4c22e7405c4c6185c37e86d9a9ed0f4cfbe176 chromium_src/chrome/browser/process_singleton_win.cc
  our    100644 6d0d102430ff700e703cef7e3189403c4a35218f chromium_src/chrome/browser/process_singleton_win.cc
  their  100644 88c6185f3bb51ac553b471c901e1bb0de0153205 chromium_src/chrome/browser/process_singleton_win.cc
@@ -263,7 +263,7 @@
 // isn't one, create a message window with its title set to the profile
 // directory path.
 bool ProcessSingleton::Create() {
-  static const wchar_t kMutexName[] = L"Local\\AtomProcessSingletonStartup!";
+  static const wchar_t kMutexName[] = L"Local\\ElectronProcessSingletonStartup!";
 
   remote_window_ = chrome::FindRunningChromeWindow(user_data_dir_);
   if (!remote_window_) {
changed in both
  base   100644 cead675a74d33ac990b1a77fe5f9c2c6416ac249 chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
  our    100644 54bf67e50330255c9b1e29d812fced8d2a73e52e chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
  their  100644 26c5b703aa76e1a991e6d7b7ac181c96726d4e96 chromium_src/chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.cc
@@ -4,7 +4,7 @@
 
 #include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
 
-#include "atom/browser/ui/views/global_menu_bar_x11.h"
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
 #include "base/bind.h"
 #include "base/debug/leak_annotations.h"
 #include "base/logging.h"
@@ -65,7 +65,7 @@
 
 void GlobalMenuBarRegistrarX11::RegisterXID(unsigned long xid) {
   DCHECK(registrar_proxy_);
-  std::string path = atom::GlobalMenuBarX11::GetPathForWindow(xid);
+  std::string path = electron::GlobalMenuBarX11::GetPathForWindow(xid);
 
   ANNOTATE_SCOPED_MEMORY_LEAK;  // http://crbug.com/314087
   // TODO(erg): The mozilla implementation goes to a lot of callback trouble
@@ -82,7 +82,7 @@
 
 void GlobalMenuBarRegistrarX11::UnregisterXID(unsigned long xid) {
   DCHECK(registrar_proxy_);
-  std::string path = atom::GlobalMenuBarX11::GetPathForWindow(xid);
+  std::string path = electron::GlobalMenuBarX11::GetPathForWindow(xid);
 
   ANNOTATE_SCOPED_MEMORY_LEAK;  // http://crbug.com/314087
   // TODO(erg): The mozilla implementation goes to a lot of callback trouble
merged
  result 100644 1fd4364a5fc24a34f23c578783ff9e4baab4b155 chromium_src/chrome/common/chrome_constants.cc
  our    100644 43a6ccdc7cb4a29fc1f53846e35a4b490d5899ff chromium_src/chrome/common/chrome_constants.cc
@@ -10,7 +10,7 @@
 
 #if defined(OS_MACOSX)
 const base::FilePath::CharType kFrameworkName[] =
-    FPL(ATOM_PRODUCT_NAME " Framework.framework");
+    FPL(ELECTRON_PRODUCT_NAME " Framework.framework");
 #endif  // OS_MACOSX
 
 // filenames
added in both
  our    100644 944ddab2a3fd879044e31677e4bac2843fffbdee electron.gyp
  their  100644 ff95786a4ec0a57f25cc494ee5965e88c1139b50 electron.gyp
@@ -4,6 +4,7 @@
     'product_name%': 'Electron',
     'company_name%': 'GitHub, Inc',
     'company_abbr%': 'github',
+<<<<<<< .our
     'version%': '4.0.0-nightly.20180821',
     'js2c_input_dir': '<(SHARED_INTERMEDIATE_DIR)/js2c',
   },
@@ -16,6 +17,18 @@
     'defines': [
       'ATOM_PRODUCT_NAME="<(product_name)"',
       'ATOM_PROJECT_NAME="<(project_name)"',
+=======
+    'version%': '0.37.3',
+  },
+  'includes': [
+    'filenames.gypi',
+    'vendor/native_mate/native_mate_files.gypi',
+  ],
+  'target_defaults': {
+    'defines': [
+      'ELECTRON_PRODUCT_NAME="<(product_name)"',
+      'ELECTRON_PROJECT_NAME="<(project_name)"',
+>>>>>>> .their
     ],
     'conditions': [
       ['OS=="mac"', {
@@ -23,6 +36,7 @@
           '<(source_root)/external_binaries',
         ],
       }],
+<<<<<<< .our
       ['enable_desktop_capturer==1', {
         'defines': [
           'ENABLE_DESKTOP_CAPTURER',
@@ -53,6 +67,8 @@
           'ENABLE_PEPPER_FLASH',
         ],
       }],  # enable_pepper_flash
+=======
+>>>>>>> .their
     ],
   },
   'targets': [
@@ -61,7 +77,10 @@
       'type': 'executable',
       'dependencies': [
         'js2asar',
+<<<<<<< .our
         'app2asar',
+=======
+>>>>>>> .their
         '<(project_name)_lib',
       ],
       'sources': [
@@ -82,8 +101,13 @@
             '<(project_name)_helper',
           ],
           'xcode_settings': {
+<<<<<<< .our
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name)',
             'INFOPLIST_FILE': 'atom/browser/resources/mac/Info.plist',
+=======
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name)',
+            'INFOPLIST_FILE': 'electron/browser/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_RUNPATH_SEARCH_PATHS': [
               '@executable_path/../Frameworks',
             ],
@@ -99,6 +123,15 @@
                 '<(PRODUCT_DIR)/<(product_name) Framework.framework',
               ],
             },
+<<<<<<< .our
+=======
+            {
+              'destination': '<(PRODUCT_DIR)/<(product_name).app/Contents/Resources',
+              'files': [
+                'default_app',
+              ],
+            },
+>>>>>>> .their
           ],
           'postbuilds': [
             {
@@ -112,7 +145,11 @@
               # is marked for no PIE (ASLR).
               'postbuild_name': 'Make More Helpers',
               'action': [
+<<<<<<< .our
                 'tools/mac/make_more_helpers.sh',
+=======
+                'vendor/brightray/tools/mac/make_more_helpers.sh',
+>>>>>>> .their
                 'Frameworks',
                 '<(product_name)',
               ],
@@ -147,6 +184,7 @@
                 },
               ],
             }],
+<<<<<<< .our
             ['mas_build==1', {
               'dependencies': [
                 '<(project_name)_login_helper',
@@ -181,6 +219,19 @@
                 'wtsapi32.lib',
               ],
             },
+=======
+          ],
+        }],  # OS!="mac"
+        ['OS=="win"', {
+          'include_dirs': [
+            '<(libchromiumcontent_dir)/gen/ui/resources',
+          ],
+          'msvs_settings': {
+            'VCManifestTool': {
+              'EmbedManifest': 'true',
+              'AdditionalManifestFiles': 'electron/browser/resources/win/electron.manifest',
+            }
+>>>>>>> .their
           },
           'copies': [
             {
@@ -205,6 +256,7 @@
                 '<(libchromiumcontent_dir)/libEGL.dll',
                 '<(libchromiumcontent_dir)/libGLESv2.dll',
                 '<(libchromiumcontent_dir)/icudtl.dat',
+<<<<<<< .our
                 '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_shell.pak',
@@ -215,6 +267,26 @@
                 'external_binaries/d3dcompiler_47.dll',
               ],
             },
+=======
+                '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
+                '<(libchromiumcontent_dir)/content_shell.pak',
+                '<(libchromiumcontent_dir)/ui_resources_200_percent.pak',
+                '<(libchromiumcontent_dir)/natives_blob.bin',
+                '<(libchromiumcontent_dir)/snapshot_blob.bin',
+                'external_binaries/d3dcompiler_47.dll',
+                'external_binaries/xinput1_3.dll',
+                'external_binaries/msvcp120.dll',
+                'external_binaries/msvcr120.dll',
+                'external_binaries/vccorlib120.dll',
+              ],
+            },
+            {
+              'destination': '<(PRODUCT_DIR)/resources',
+              'files': [
+                'default_app',
+              ]
+            },
+>>>>>>> .their
           ],
         }, {
           'dependencies': [
@@ -245,6 +317,7 @@
                 '<@(copied_libraries)',
                 '<(libchromiumcontent_dir)/locales',
                 '<(libchromiumcontent_dir)/icudtl.dat',
+<<<<<<< .our
                 '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_resources_200_percent.pak',
                 '<(libchromiumcontent_dir)/content_shell.pak',
@@ -254,6 +327,19 @@
                 '<(libchromiumcontent_dir)/v8_context_snapshot.bin',
               ],
             },
+=======
+                '<(libchromiumcontent_dir)/content_shell.pak',
+                '<(libchromiumcontent_dir)/natives_blob.bin',
+                '<(libchromiumcontent_dir)/snapshot_blob.bin',
+              ],
+            },
+            {
+              'destination': '<(PRODUCT_DIR)/resources',
+              'files': [
+                'default_app',
+              ]
+            },
+>>>>>>> .their
           ],
         }],  # OS=="linux"
       ],
@@ -262,6 +348,7 @@
       'target_name': '<(project_name)_lib',
       'type': 'static_library',
       'dependencies': [
+<<<<<<< .our
         'atom_js2c',
         'brightray/brightray.gyp:brightray',
         'vendor/node/node.gyp:node_lib',
@@ -272,10 +359,20 @@
         'NODE_SHARED_MODE',
         'HAVE_OPENSSL=1',
         'HAVE_INSPECTOR=1',
+=======
+        'electron_js2c',
+        'vendor/brightray/brightray.gyp:brightray',
+        'vendor/node/node.gyp:node',
+      ],
+      'defines': [
+        # This is defined in skia/skia_common.gypi.
+        'SK_SUPPORT_LEGACY_GETTOPDEVICE',
+>>>>>>> .their
         # Disable warnings for g_settings_list_schemas.
         'GLIB_DISABLE_DEPRECATION_WARNINGS',
         # Defined in Chromium but not exposed in its gyp file.
         'V8_USE_EXTERNAL_STARTUP_DATA',
+<<<<<<< .our
 
         # Import V8 symbols from shared library (node.dll / libnode.so)
         'USING_V8_SHARED',
@@ -285,6 +382,11 @@
         # See Chromium src/third_party/protobuf/BUILD.gn
         'GOOGLE_PROTOBUF_NO_RTTI',
         'GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER',
+=======
+        'ENABLE_PLUGINS',
+        'ENABLE_PEPPER_CDMS',
+        'USE_PROPRIETARY_CODECS',
+>>>>>>> .their
       ],
       'sources': [
         '<@(lib_sources)',
@@ -292,8 +394,14 @@
       'include_dirs': [
         '.',
         'chromium_src',
+<<<<<<< .our
         'native_mate',
         # Include atom_natives.h.
+=======
+        'vendor/brightray',
+        'vendor/native_mate',
+        # Include electron_natives.h.
+>>>>>>> .their
         '<(SHARED_INTERMEDIATE_DIR)',
         # Include directories for uv and node.
         'vendor/node/src',
@@ -311,6 +419,7 @@
         '<(libchromiumcontent_src_dir)/third_party/',
         '<(libchromiumcontent_src_dir)/components/cdm',
         '<(libchromiumcontent_src_dir)/third_party/widevine',
+<<<<<<< .our
         '<(libchromiumcontent_src_dir)/third_party/widevine/cdm/stub',
         '<(libchromiumcontent_src_dir)/third_party/protobuf/src',
         # The 'third_party/webrtc/modules/desktop_capture/desktop_capture_options.h' is using 'rtc_base/constructormagic.h'.
@@ -318,6 +427,8 @@
         # leveldb includes are required
         '<(libchromiumcontent_src_dir)/third_party/leveldatabase/src',
         '<(libchromiumcontent_src_dir)/third_party/leveldatabase/src/include',
+=======
+>>>>>>> .their
       ],
       'direct_dependent_settings': {
         'include_dirs': [
@@ -325,6 +436,7 @@
         ],
       },
       'export_dependent_settings': [
+<<<<<<< .our
         'brightray/brightray.gyp:brightray',
       ],
       'conditions': [
@@ -352,6 +464,11 @@
             ],
           },
         }],  # enable_pepper_flash
+=======
+        'vendor/brightray/brightray.gyp:brightray',
+      ],
+      'conditions': [
+>>>>>>> .their
         ['libchromiumcontent_component', {
           'link_settings': {
             'libraries': [ '<@(libchromiumcontent_v8_libraries)' ],
@@ -363,17 +480,24 @@
           ],
           'link_settings': {
             'libraries': [
+<<<<<<< .our
               '-ldwmapi.lib',
               '-limm32.lib',
               '-lgdi32.lib',
+=======
+              '-limm32.lib',
+>>>>>>> .their
               '-loleacc.lib',
               '-lcomctl32.lib',
               '-lcomdlg32.lib',
               '-lwininet.lib',
               '-lwinmm.lib',
+<<<<<<< .our
               '-lcrypt32.lib',
               '-luiautomationcore.lib',
               '-lPropsys.lib'
+=======
+>>>>>>> .their
             ],
           },
           'dependencies': [
@@ -399,6 +523,7 @@
               '$(SDKROOT)/System/Library/Frameworks/QTKit.framework',
             ],
           },
+<<<<<<< .our
           'xcode_settings': {
             # ReactiveCocoa which is used by Squirrel requires using __weak.
             'CLANG_ENABLE_OBJC_WEAK': 'YES',
@@ -407,12 +532,15 @@
               '-Wobjc-missing-property-synthesis',
             ],
           },
+=======
+>>>>>>> .their
         }],  # OS=="mac" and mas_build==0
         ['OS=="mac" and mas_build==1', {
           'defines': [
             'MAS_BUILD',
           ],
           'sources!': [
+<<<<<<< .our
             'atom/browser/auto_updater_mac.mm',
             'atom/common/crash_reporter/crash_reporter_mac.h',
             'atom/common/crash_reporter/crash_reporter_mac.mm',
@@ -430,12 +558,24 @@
             '<@(lib_sources_linux)',
             '<@(lib_sources_nss)',
           ],
+=======
+            'electron/browser/auto_updater_mac.mm',
+            'electron/common/crash_reporter/crash_reporter_mac.h',
+            'electron/common/crash_reporter/crash_reporter_mac.mm',
+          ],
+        }],  # OS=="mac" and mas_build==1
+        ['OS=="linux"', {
+>>>>>>> .their
           'link_settings': {
             'ldflags': [
               # Make binary search for libraries under current directory, so we
               # don't have to manually set $LD_LIBRARY_PATH:
               # http://serverfault.com/questions/279068/cant-find-so-in-the-same-directory-as-the-executable
+<<<<<<< .our
               '-Wl,-rpath=\$$ORIGIN',
+=======
+              '-rpath \$$ORIGIN',
+>>>>>>> .their
               # Make native module dynamic loading work.
               '-rdynamic',
             ],
@@ -443,6 +583,10 @@
           # Required settings of using breakpad.
           'cflags_cc': [
             '-Wno-empty-body',
+<<<<<<< .our
+=======
+            '-Wno-reserved-user-defined-literal',
+>>>>>>> .their
           ],
           'include_dirs': [
             'vendor/breakpad/src',
@@ -451,12 +595,15 @@
             'vendor/breakpad/breakpad.gyp:breakpad_client',
           ],
         }],  # OS=="linux"
+<<<<<<< .our
         ['OS=="linux" and clang==1', {
           # Required settings of using breakpad.
           'cflags_cc': [
             '-Wno-reserved-user-defined-literal',
           ],
         }],  # OS=="linux" and clang==1
+=======
+>>>>>>> .their
       ],
     },  # target <(product_name)_lib
     {
@@ -484,13 +631,17 @@
             'python',
             'tools/js2asar.py',
             '<@(_outputs)',
+<<<<<<< .our
             'lib',
+=======
+>>>>>>> .their
             '<@(_inputs)',
           ],
         }
       ],
     },  # target js2asar
     {
+<<<<<<< .our
       'target_name': 'app2asar',
       'type': 'none',
       'actions': [
@@ -617,10 +768,23 @@
           ],
           'outputs': [
             '<(SHARED_INTERMEDIATE_DIR)/atom_natives.h',
+=======
+      'target_name': 'electron_js2c',
+      'type': 'none',
+      'actions': [
+        {
+          'action_name': 'electron_js2c',
+          'inputs': [
+            '<@(js2c_sources)',
+          ],
+          'outputs': [
+            '<(SHARED_INTERMEDIATE_DIR)/electron_natives.h',
+>>>>>>> .their
           ],
           'action': [
             'python',
             'tools/js2c.py',
+<<<<<<< .our
             'vendor/node',
             '<@(_outputs)',
             '<(js2c_input_dir)',
@@ -628,6 +792,14 @@
         }
       ],
     },  # target atom_js2c
+=======
+            '<@(_outputs)',
+            '<@(_inputs)',
+          ],
+        }
+      ],
+    },  # target electron_js2c
+>>>>>>> .their
   ],
   'conditions': [
     ['OS=="mac"', {
@@ -654,15 +826,19 @@
             'libraries': [
               '$(SDKROOT)/System/Library/Frameworks/Carbon.framework',
               '$(SDKROOT)/System/Library/Frameworks/QuartzCore.framework',
+<<<<<<< .our
               '$(SDKROOT)/System/Library/Frameworks/Quartz.framework',
               '$(SDKROOT)/System/Library/Frameworks/Security.framework',
               '$(SDKROOT)/System/Library/Frameworks/SecurityInterface.framework',
               '$(SDKROOT)/System/Library/Frameworks/ServiceManagement.framework',
               '$(SDKROOT)/System/Library/Frameworks/StoreKit.framework',
+=======
+>>>>>>> .their
             ],
           },
           'mac_bundle': 1,
           'mac_bundle_resources': [
+<<<<<<< .our
             'atom/common/resources/mac/MainMenu.xib',
             '<(libchromiumcontent_dir)/icudtl.dat',
             '<(libchromiumcontent_dir)/blink_image_resources_200_percent.pak',
@@ -676,6 +852,17 @@
           'xcode_settings': {
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name).framework',
             'INFOPLIST_FILE': 'atom/common/resources/mac/Info.plist',
+=======
+            'electron/common/resources/mac/MainMenu.xib',
+            '<(libchromiumcontent_dir)/content_shell.pak',
+            '<(libchromiumcontent_dir)/icudtl.dat',
+            '<(libchromiumcontent_dir)/natives_blob.bin',
+            '<(libchromiumcontent_dir)/snapshot_blob.bin',
+          ],
+          'xcode_settings': {
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name).framework',
+            'INFOPLIST_FILE': 'electron/common/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_DYLIB_INSTALL_NAME': '@rpath/<(product_name) Framework.framework/<(product_name) Framework',
             'LD_RUNPATH_SEARCH_PATHS': [
               '@loader_path/Libraries',
@@ -720,6 +907,19 @@
               ],
             },
             {
+<<<<<<< .our
+=======
+              'postbuild_name': 'Fix path of ffmpeg',
+              'action': [
+                'install_name_tool',
+                '-change',
+                '/usr/local/lib/libffmpeg.dylib',
+                '@rpath/libffmpeg.dylib',
+                '${BUILT_PRODUCTS_DIR}/<(product_name) Framework.framework/Versions/A/<(product_name) Framework',
+              ],
+            },
+            {
+>>>>>>> .their
               'postbuild_name': 'Add symlinks for framework subdirectories',
               'action': [
                 'tools/mac/create-framework-subdir-symlinks.sh',
@@ -739,11 +939,14 @@
             },
           ],
           'conditions': [
+<<<<<<< .our
             ['enable_pdf_viewer==1', {
               'mac_bundle_resources': [
                 '<(PRODUCT_DIR)/pdf_viewer_resources.pak',
               ],
             }],  # enable_pdf_viewer
+=======
+>>>>>>> .their
             ['mas_build==0', {
               'link_settings': {
                 'libraries': [
@@ -778,13 +981,19 @@
           ],
           'mac_bundle': 1,
           'xcode_settings': {
+<<<<<<< .our
             'ATOM_BUNDLE_ID': 'com.<(company_abbr).<(project_name).helper',
             'INFOPLIST_FILE': 'atom/renderer/resources/mac/Info.plist',
+=======
+            'ELECTRON_BUNDLE_ID': 'com.<(company_abbr).<(project_name).helper',
+            'INFOPLIST_FILE': 'electron/renderer/resources/mac/Info.plist',
+>>>>>>> .their
             'LD_RUNPATH_SEARCH_PATHS': [
               '@executable_path/../../..',
             ],
           },
         },  # target helper
+<<<<<<< .our
         {
           'target_name': '<(project_name)_login_helper',
           'product_name': '<(product_name) Login Helper',
@@ -811,6 +1020,8 @@
             ],
           },
         },  # target login_helper
+=======
+>>>>>>> .their
       ],
     }],  # OS!="mac"
   ],
added in remote
  their  100644 5e5eae74e7f694982bfffe709b5f6fd44251840f electron/app/electron_content_client.cc
@@ -0,0 +1,216 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_content_client.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/common/content_constants.h"
+#include "content/public/common/pepper_plugin_info.h"
+#include "content/public/common/user_agent.h"
+#include "ppapi/shared_impl/ppapi_permissions.h"
+#include "third_party/widevine/cdm/stub/widevine_cdm_version.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "url/url_constants.h"
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+#include "chrome/common/widevine_cdm_constants.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+content::PepperPluginInfo CreatePepperFlashInfo(const base::FilePath& path,
+                                                const std::string& version) {
+  content::PepperPluginInfo plugin;
+
+  plugin.is_out_of_process = true;
+  plugin.name = content::kFlashPluginName;
+  plugin.path = path;
+  plugin.permissions = ppapi::PERMISSION_ALL_BITS;
+
+  std::vector<std::string> flash_version_numbers = base::SplitString(
+      version, ".", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+  if (flash_version_numbers.size() < 1)
+    flash_version_numbers.push_back("11");
+  // |SplitString()| puts in an empty string given an empty string. :(
+  else if (flash_version_numbers[0].empty())
+    flash_version_numbers[0] = "11";
+  if (flash_version_numbers.size() < 2)
+    flash_version_numbers.push_back("2");
+  if (flash_version_numbers.size() < 3)
+    flash_version_numbers.push_back("999");
+  if (flash_version_numbers.size() < 4)
+    flash_version_numbers.push_back("999");
+  // E.g., "Shockwave Flash 10.2 r154":
+  plugin.description = plugin.name + " " + flash_version_numbers[0] + "." +
+      flash_version_numbers[1] + " r" + flash_version_numbers[2];
+  plugin.version = base::JoinString(flash_version_numbers, ".");
+  content::WebPluginMimeType swf_mime_type(
+      content::kFlashPluginSwfMimeType,
+      content::kFlashPluginSwfExtension,
+      content::kFlashPluginSwfDescription);
+  plugin.mime_types.push_back(swf_mime_type);
+  content::WebPluginMimeType spl_mime_type(
+      content::kFlashPluginSplMimeType,
+      content::kFlashPluginSplExtension,
+      content::kFlashPluginSplDescription);
+  plugin.mime_types.push_back(spl_mime_type);
+
+  return plugin;
+}
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+content::PepperPluginInfo CreateWidevineCdmInfo(const base::FilePath& path,
+                                                const std::string& version) {
+  content::PepperPluginInfo widevine_cdm;
+  widevine_cdm.is_out_of_process = true;
+  widevine_cdm.path = path;
+  widevine_cdm.name = kWidevineCdmDisplayName;
+  widevine_cdm.description = kWidevineCdmDescription +
+                             std::string(" (version: ") +
+                             version + ")";
+  widevine_cdm.version = version;
+  content::WebPluginMimeType widevine_cdm_mime_type(
+      kWidevineCdmPluginMimeType,
+      kWidevineCdmPluginExtension,
+      kWidevineCdmPluginMimeTypeDescription);
+
+  // Add the supported codecs as if they came from the component manifest.
+  std::vector<std::string> codecs;
+  codecs.push_back(kCdmSupportedCodecVorbis);
+  codecs.push_back(kCdmSupportedCodecVp8);
+  codecs.push_back(kCdmSupportedCodecVp9);
+#if defined(USE_PROPRIETARY_CODECS)
+  codecs.push_back(kCdmSupportedCodecAac);
+  codecs.push_back(kCdmSupportedCodecAvc1);
+#endif  // defined(USE_PROPRIETARY_CODECS)
+  std::string codec_string = base::JoinString(
+      codecs, std::string(1, kCdmSupportedCodecsValueDelimiter));
+  widevine_cdm_mime_type.additional_param_names.push_back(
+      base::ASCIIToUTF16(kCdmSupportedCodecsParamName));
+  widevine_cdm_mime_type.additional_param_values.push_back(
+      base::ASCIIToUTF16(codec_string));
+
+  widevine_cdm.mime_types.push_back(widevine_cdm_mime_type);
+  widevine_cdm.permissions = kWidevineCdmPluginPermissions;
+
+  return widevine_cdm;
+}
+#endif
+
+void ConvertStringWithSeparatorToVector(std::vector<std::string>* vec,
+                                        const char* separator,
+                                        const char* cmd_switch) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto string_with_separator = command_line->GetSwitchValueASCII(cmd_switch);
+  if (!string_with_separator.empty())
+    *vec = base::SplitString(string_with_separator, separator,
+                             base::TRIM_WHITESPACE,
+                             base::SPLIT_WANT_NONEMPTY);
+}
+
+}  // namespace
+
+void AddPepperFlashFromCommandLine(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto flash_path = command_line->GetSwitchValueNative(
+      switches::kPpapiFlashPath);
+  if (flash_path.empty())
+    return;
+
+  auto flash_version = command_line->GetSwitchValueASCII(
+      switches::kPpapiFlashVersion);
+
+  plugins->push_back(
+      CreatePepperFlashInfo(base::FilePath(flash_path), flash_version));
+}
+
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+void AddWidevineCdmFromCommandLine(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  auto widevine_cdm_path = command_line->GetSwitchValueNative(
+      switches::kWidevineCdmPath);
+  if (widevine_cdm_path.empty())
+    return;
+
+  if (!base::PathExists(base::FilePath(widevine_cdm_path)))
+    return;
+
+  auto widevine_cdm_version = command_line->GetSwitchValueASCII(
+      switches::kWidevineCdmVersion);
+  if (widevine_cdm_version.empty())
+    return;
+
+  plugins->push_back(CreateWidevineCdmInfo(base::FilePath(widevine_cdm_path),
+                                           widevine_cdm_version));
+}
+#endif
+
+ElectronContentClient::ElectronContentClient() {
+}
+
+ElectronContentClient::~ElectronContentClient() {
+}
+
+std::string ElectronContentClient::GetProduct() const {
+  return "Chrome/" CHROME_VERSION_STRING;
+}
+
+std::string ElectronContentClient::GetUserAgent() const {
+  return content::BuildUserAgentFromProduct(
+      "Chrome/" CHROME_VERSION_STRING " "
+      ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING);
+}
+
+base::string16 ElectronContentClient::GetLocalizedString(int message_id) const {
+  return l10n_util::GetStringUTF16(message_id);
+}
+
+void ElectronContentClient::AddAdditionalSchemes(
+    std::vector<url::SchemeWithType>* standard_schemes,
+    std::vector<std::string>* savable_schemes) {
+  std::vector<std::string> schemes;
+  ConvertStringWithSeparatorToVector(&schemes, ",",
+                                     switches::kRegisterStandardSchemes);
+  if (!schemes.empty()) {
+    for (const std::string& scheme : schemes)
+      standard_schemes->push_back({scheme.c_str(), url::SCHEME_WITHOUT_PORT});
+  }
+  standard_schemes->push_back({"chrome-extension", url::SCHEME_WITHOUT_PORT});
+}
+
+void ElectronContentClient::AddPepperPlugins(
+    std::vector<content::PepperPluginInfo>* plugins) {
+  AddPepperFlashFromCommandLine(plugins);
+#if defined(WIDEVINE_CDM_AVAILABLE) && defined(ENABLE_PEPPER_CDMS)
+  AddWidevineCdmFromCommandLine(plugins);
+#endif
+}
+
+void ElectronContentClient::AddServiceWorkerSchemes(
+    std::set<std::string>* service_worker_schemes) {
+  std::vector<std::string> schemes;
+  ConvertStringWithSeparatorToVector(&schemes, ",",
+                                     switches::kRegisterServiceWorkerSchemes);
+  if (!schemes.empty()) {
+    for (const std::string& scheme : schemes)
+      service_worker_schemes->insert(scheme);
+  }
+  service_worker_schemes->insert(url::kFileScheme);
+}
+
+}  // namespace electron
added in remote
  their  100644 99d14289797ec4383023d85dfbd76b45560a3292 electron/app/electron_content_client.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
+#define ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "brightray/common/content_client.h"
+
+namespace electron {
+
+class ElectronContentClient : public brightray::ContentClient {
+ public:
+  ElectronContentClient();
+  virtual ~ElectronContentClient();
+
+ protected:
+  // content::ContentClient:
+  std::string GetProduct() const override;
+  std::string GetUserAgent() const override;
+  base::string16 GetLocalizedString(int message_id) const override;
+  void AddAdditionalSchemes(
+      std::vector<url::SchemeWithType>* standard_schemes,
+      std::vector<std::string>* savable_schemes) override;
+  void AddPepperPlugins(
+      std::vector<content::PepperPluginInfo>* plugins) override;
+  void AddServiceWorkerSchemes(
+      std::set<std::string>* service_worker_schemes) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronContentClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_ELECTRON_CONTENT_CLIENT_H_
added in remote
  their  100644 11f76e61e5f79ecc809c5e4dbaaa2905bcdda41f electron/app/electron_library_main.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
+#define ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
+
+#include "build/build_config.h"
+
+#if defined(OS_MACOSX)
+extern "C" {
+__attribute__((visibility("default")))
+int ElectronMain(int argc, const char* argv[]);
+
+__attribute__((visibility("default")))
+int ElectronInitializeICUandStartNode(int argc, char *argv[]);
+}
+#endif  // OS_MACOSX
+
+#endif  // ELECTRON_APP_ELECTRON_LIBRARY_MAIN_H_
added in remote
  their  100644 98a72397e5fd3500c91085aefeb34f5d46b560e1 electron/app/electron_library_main.mm
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_library_main.h"
+
+#include "electron/app/electron_main_delegate.h"
+#include "electron/app/node_main.h"
+#include "electron/common/electron_command_line.h"
+#include "base/at_exit.h"
+#include "base/i18n/icu_util.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/scoped_nsautorelease_pool.h"
+#include "brightray/common/mac/main_application_bundle.h"
+#include "content/public/app/content_main.h"
+
+#if defined(OS_MACOSX)
+int ElectronMain(int argc, const char* argv[]) {
+  electron::ElectronMainDelegate delegate;
+  content::ContentMainParams params(&delegate);
+  params.argc = argc;
+  params.argv = argv;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+int ElectronInitializeICUandStartNode(int argc, char *argv[]) {
+  base::AtExitManager atexit_manager;
+  base::mac::ScopedNSAutoreleasePool pool;
+  base::mac::SetOverrideFrameworkBundlePath(
+      brightray::MainApplicationBundlePath()
+          .Append("Contents")
+          .Append("Frameworks")
+          .Append(ELECTRON_PRODUCT_NAME " Framework.framework"));
+  base::i18n::InitializeICU();
+  return electron::NodeMain(argc, argv);
+}
+#endif  // OS_MACOSX
added in remote
  their  100644 4d80e607c406e565986f2db25cf3d4952e613008 electron/app/electron_main.cc
@@ -0,0 +1,197 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main.h"
+
+#include <stdlib.h>
+
+#if defined(OS_WIN)
+#include <windows.h>
+#include <shellscalingapi.h>
+#include <tchar.h>
+#include <shellapi.h>
+
+#include "electron/app/electron_main_delegate.h"
+#include "electron/common/crash_reporter/win/crash_service_main.h"
+#include "base/environment.h"
+#include "base/win/windows_version.h"
+#include "content/public/app/sandbox_helper_win.h"
+#include "sandbox/win/src/sandbox_types.h"
+#include "ui/gfx/win/dpi.h"
+#elif defined(OS_LINUX)  // defined(OS_WIN)
+#include "electron/app/electron_main_delegate.h"  // NOLINT
+#include "content/public/app/content_main.h"
+#else  // defined(OS_LINUX)
+#include "electron/app/electron_library_main.h"
+#endif  // defined(OS_MACOSX)
+
+#include "electron/app/node_main.h"
+#include "electron/common/electron_command_line.h"
+#include "base/at_exit.h"
+#include "base/i18n/icu_util.h"
+
+namespace {
+
+const char* kRunAsNode = "ELECTRON_RUN_AS_NODE";
+const char* kOldRunAsNode = "ATOM_SHELL_INTERNAL_RUN_AS_NODE";
+
+bool IsEnvSet(const char* name) {
+#if defined(OS_WIN)
+  size_t required_size;
+  getenv_s(&required_size, nullptr, 0, name);
+  return required_size != 0;
+#else
+  char* indicator = getenv(name);
+  return indicator && indicator[0] != '\0';
+#endif
+}
+
+bool IsRunAsNode() {
+  return IsEnvSet(kRunAsNode) || IsEnvSet(kOldRunAsNode);
+}
+
+#if defined(OS_WIN)
+// Win8.1 supports monitor-specific DPI scaling.
+bool SetProcessDpiAwarenessWrapper(PROCESS_DPI_AWARENESS value) {
+  typedef HRESULT(WINAPI *SetProcessDpiAwarenessPtr)(PROCESS_DPI_AWARENESS);
+  SetProcessDpiAwarenessPtr set_process_dpi_awareness_func =
+      reinterpret_cast<SetProcessDpiAwarenessPtr>(
+          GetProcAddress(GetModuleHandleA("user32.dll"),
+                         "SetProcessDpiAwarenessInternal"));
+  if (set_process_dpi_awareness_func) {
+    HRESULT hr = set_process_dpi_awareness_func(value);
+    if (SUCCEEDED(hr)) {
+      VLOG(1) << "SetProcessDpiAwareness succeeded.";
+      return true;
+    } else if (hr == E_ACCESSDENIED) {
+      LOG(ERROR) << "Access denied error from SetProcessDpiAwareness. "
+          "Function called twice, or manifest was used.";
+    }
+  }
+  return false;
+}
+
+// This function works for Windows Vista through Win8. Win8.1 must use
+// SetProcessDpiAwareness[Wrapper].
+BOOL SetProcessDPIAwareWrapper() {
+  typedef BOOL(WINAPI *SetProcessDPIAwarePtr)(VOID);
+  SetProcessDPIAwarePtr set_process_dpi_aware_func =
+      reinterpret_cast<SetProcessDPIAwarePtr>(
+      GetProcAddress(GetModuleHandleA("user32.dll"),
+                      "SetProcessDPIAware"));
+  return set_process_dpi_aware_func &&
+    set_process_dpi_aware_func();
+}
+
+void EnableHighDPISupport() {
+  if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
+    SetProcessDPIAwareWrapper();
+  }
+}
+#endif
+
+}  // namespace
+
+#if defined(OS_WIN)
+int APIENTRY wWinMain(HINSTANCE instance, HINSTANCE, wchar_t* cmd, int) {
+  int argc = 0;
+  wchar_t** wargv = ::CommandLineToArgvW(::GetCommandLineW(), &argc);
+
+  // Make output work in console if we are not in cygiwn.
+  if (!IsEnvSet("TERM") && !IsEnvSet("ELECTRON_NO_ATTACH_CONSOLE")) {
+    AttachConsole(ATTACH_PARENT_PROCESS);
+
+    FILE* dontcare;
+    freopen_s(&dontcare, "CON", "w", stdout);
+    freopen_s(&dontcare, "CON", "w", stderr);
+  }
+
+  // Convert argv to to UTF8
+  char** argv = new char*[argc];
+  for (int i = 0; i < argc; i++) {
+    // Compute the size of the required buffer
+    DWORD size = WideCharToMultiByte(CP_UTF8,
+                                     0,
+                                     wargv[i],
+                                     -1,
+                                     NULL,
+                                     0,
+                                     NULL,
+                                     NULL);
+    if (size == 0) {
+      // This should never happen.
+      fprintf(stderr, "Could not convert arguments to utf8.");
+      exit(1);
+    }
+    // Do the actual conversion
+    argv[i] = new char[size];
+    DWORD result = WideCharToMultiByte(CP_UTF8,
+                                       0,
+                                       wargv[i],
+                                       -1,
+                                       argv[i],
+                                       size,
+                                       NULL,
+                                       NULL);
+    if (result == 0) {
+      // This should never happen.
+      fprintf(stderr, "Could not convert arguments to utf8.");
+      exit(1);
+    }
+  }
+
+  if (IsRunAsNode()) {
+    // Now that argv conversion is done, we can finally start.
+    base::AtExitManager atexit_manager;
+    base::i18n::InitializeICU();
+    return electron::NodeMain(argc, argv);
+  } else if (IsEnvSet("ELECTRON_INTERNAL_CRASH_SERVICE")) {
+    return crash_service::Main(cmd);
+  }
+
+  sandbox::SandboxInterfaceInfo sandbox_info = {0};
+  content::InitializeSandboxInfo(&sandbox_info);
+  electron::ElectronMainDelegate delegate;
+
+  // We don't want to set DPI awareness on pre-Win7 because we don't support
+  // DirectWrite there. GDI fonts are kerned very badly, so better to leave
+  // DPI-unaware and at effective 1.0. See also ShouldUseDirectWrite().
+  if (base::win::GetVersion() >= base::win::VERSION_WIN7)
+    EnableHighDPISupport();
+
+  content::ContentMainParams params(&delegate);
+  params.instance = instance;
+  params.sandbox_info = &sandbox_info;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+#elif defined(OS_LINUX)  // defined(OS_WIN)
+
+int main(int argc, const char* argv[]) {
+  if (IsRunAsNode()) {
+    base::i18n::InitializeICU();
+    base::AtExitManager atexit_manager;
+    return electron::NodeMain(argc, const_cast<char**>(argv));
+  }
+
+  electron::ElectronMainDelegate delegate;
+  content::ContentMainParams params(&delegate);
+  params.argc = argc;
+  params.argv = argv;
+  electron::ElectronCommandLine::Init(argc, argv);
+  return content::ContentMain(params);
+}
+
+#else  // defined(OS_LINUX)
+
+int main(int argc, const char* argv[]) {
+  if (IsRunAsNode()) {
+    return ElectronInitializeICUandStartNode(argc, const_cast<char**>(argv));
+  }
+
+  return ElectronMain(argc, argv);
+}
+
+#endif  // defined(OS_MACOSX)
added in remote
  their  100644 bd507a25b1658c5fce00b9371f205164c53a0aa5 electron/app/electron_main.h
@@ -0,0 +1,10 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_MAIN_H_
+#define ELECTRON_APP_ELECTRON_MAIN_H_
+
+#include "content/public/app/content_main.h"
+
+#endif  // ELECTRON_APP_ELECTRON_MAIN_H_
added in remote
  their  100644 32c3348a7e7a1adc1875185ec514cb42f5313aa9 electron/app/electron_main_delegate.cc
@@ -0,0 +1,141 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main_delegate.h"
+
+#include <string>
+#include <iostream>
+
+#include "electron/app/electron_content_client.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/common/google_api_key.h"
+#include "electron/renderer/electron_renderer_client.h"
+#include "electron/utility/electron_content_utility_client.h"
+#include "base/command_line.h"
+#include "base/debug/stack_trace.h"
+#include "base/environment.h"
+#include "base/logging.h"
+#include "chrome/common/chrome_paths.h"
+#include "content/public/common/content_switches.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/base/resource/resource_bundle.h"
+
+namespace electron {
+
+namespace {
+
+bool IsBrowserProcess(base::CommandLine* cmd) {
+  std::string process_type = cmd->GetSwitchValueASCII(switches::kProcessType);
+  return process_type.empty();
+}
+
+}  // namespace
+
+ElectronMainDelegate::ElectronMainDelegate() {
+}
+
+ElectronMainDelegate::~ElectronMainDelegate() {
+}
+
+bool ElectronMainDelegate::BasicStartupComplete(int* exit_code) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  logging::LoggingSettings settings;
+#if defined(OS_WIN)
+  // On Windows the terminal returns immediately, so we add a new line to
+  // prevent output in the same line as the prompt.
+  if (IsBrowserProcess(command_line))
+    std::wcout << std::endl;
+#if defined(DEBUG)
+  // Print logging to debug.log on Windows
+  settings.logging_dest = logging::LOG_TO_ALL;
+  settings.log_file = L"debug.log";
+  settings.lock_log = logging::LOCK_LOG_FILE;
+  settings.delete_old = logging::DELETE_OLD_LOG_FILE;
+#else
+  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
+#endif  // defined(DEBUG)
+#else  // defined(OS_WIN)
+  settings.logging_dest = logging::LOG_TO_SYSTEM_DEBUG_LOG;
+#endif  // !defined(OS_WIN)
+
+  // Only enable logging when --enable-logging is specified.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (!command_line->HasSwitch(switches::kEnableLogging) &&
+      !env->HasVar("ELECTRON_ENABLE_LOGGING")) {
+    settings.logging_dest = logging::LOG_NONE;
+    logging::SetMinLogLevel(logging::LOG_NUM_SEVERITIES);
+  }
+
+  logging::InitLogging(settings);
+
+  // Logging with pid and timestamp.
+  logging::SetLogItems(true, false, true, false);
+
+  // Enable convient stack printing.
+  bool enable_stack_dumping = env->HasVar("ELECTRON_ENABLE_STACK_DUMPING");
+#if defined(DEBUG) && defined(OS_LINUX)
+  enable_stack_dumping = true;
+#endif
+  if (enable_stack_dumping)
+    base::debug::EnableInProcessStackDumping();
+
+  chrome::RegisterPathProvider();
+
+  return brightray::MainDelegate::BasicStartupComplete(exit_code);
+}
+
+void ElectronMainDelegate::PreSandboxStartup() {
+  brightray::MainDelegate::PreSandboxStartup();
+
+  // Set google API key.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (!env->HasVar("GOOGLE_API_KEY"))
+    env->SetVar("GOOGLE_API_KEY", GOOGLEAPIS_API_KEY);
+
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  std::string process_type = command_line->GetSwitchValueASCII(
+      switches::kProcessType);
+
+  if (process_type == switches::kUtilityProcess) {
+    ElectronContentUtilityClient::PreSandboxStartup();
+  }
+
+  // Only append arguments for browser process.
+  if (!IsBrowserProcess(command_line))
+    return;
+
+  // Disable renderer sandbox for most of node's functions.
+  command_line->AppendSwitch(switches::kNoSandbox);
+
+  // Allow file:// URIs to read other file:// URIs by default.
+  command_line->AppendSwitch(switches::kAllowFileAccessFromFiles);
+
+#if defined(OS_MACOSX)
+  // Enable AVFoundation.
+  command_line->AppendSwitch("enable-avfoundation");
+#endif
+}
+
+content::ContentBrowserClient* ElectronMainDelegate::CreateContentBrowserClient() {
+  browser_client_.reset(new ElectronBrowserClient);
+  return browser_client_.get();
+}
+
+content::ContentRendererClient*
+    ElectronMainDelegate::CreateContentRendererClient() {
+  renderer_client_.reset(new ElectronRendererClient);
+  return renderer_client_.get();
+}
+
+content::ContentUtilityClient* ElectronMainDelegate::CreateContentUtilityClient() {
+  utility_client_.reset(new ElectronContentUtilityClient);
+  return utility_client_.get();
+}
+
+scoped_ptr<brightray::ContentClient> ElectronMainDelegate::CreateContentClient() {
+  return scoped_ptr<brightray::ContentClient>(new ElectronContentClient);
+}
+
+}  // namespace electron
added in remote
  their  100644 1068c65e3cc41e6a63f9b95133ef138e5c479709 electron/app/electron_main_delegate.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
+#define ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
+
+#include "brightray/common/main_delegate.h"
+#include "brightray/common/content_client.h"
+
+namespace electron {
+
+class ElectronMainDelegate : public brightray::MainDelegate {
+ public:
+  ElectronMainDelegate();
+  ~ElectronMainDelegate();
+
+ protected:
+  // content::ContentMainDelegate:
+  bool BasicStartupComplete(int* exit_code) override;
+  void PreSandboxStartup() override;
+  content::ContentBrowserClient* CreateContentBrowserClient() override;
+  content::ContentRendererClient* CreateContentRendererClient() override;
+  content::ContentUtilityClient* CreateContentUtilityClient() override;
+
+  // brightray::MainDelegate:
+  scoped_ptr<brightray::ContentClient> CreateContentClient() override;
+#if defined(OS_MACOSX)
+  void OverrideChildProcessPath() override;
+  void OverrideFrameworkBundlePath() override;
+#endif
+
+ private:
+  brightray::ContentClient content_client_;
+  scoped_ptr<content::ContentBrowserClient> browser_client_;
+  scoped_ptr<content::ContentRendererClient> renderer_client_;
+  scoped_ptr<content::ContentUtilityClient> utility_client_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronMainDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_ELECTRON_MAIN_DELEGATE_H_
added in remote
  their  100644 aa6f2abae3e60da0e132fa07c9b529be49255d60 electron/app/electron_main_delegate_mac.mm
@@ -0,0 +1,51 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/electron_main_delegate.h"
+
+#include "base/mac/bundle_locations.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/path_service.h"
+#include "brightray/common/application_info.h"
+#include "brightray/common/mac/main_application_bundle.h"
+#include "content/public/common/content_paths.h"
+
+namespace electron {
+
+namespace {
+
+base::FilePath GetFrameworksPath() {
+  return brightray::MainApplicationBundlePath().Append("Contents")
+                                               .Append("Frameworks");
+}
+
+base::FilePath GetHelperAppPath(const base::FilePath& frameworks_path,
+                                const std::string& name) {
+  return frameworks_path.Append(name + " Helper.app")
+                        .Append("Contents")
+                        .Append("MacOS")
+                        .Append(name + " Helper");
+}
+
+}  // namespace
+
+void ElectronMainDelegate::OverrideFrameworkBundlePath() {
+  base::mac::SetOverrideFrameworkBundlePath(
+      GetFrameworksPath().Append(ELECTRON_PRODUCT_NAME " Framework.framework"));
+}
+
+void ElectronMainDelegate::OverrideChildProcessPath() {
+  base::FilePath frameworks_path = GetFrameworksPath();
+  base::FilePath helper_path = GetHelperAppPath(frameworks_path,
+                                                ELECTRON_PRODUCT_NAME);
+  if (!base::PathExists(helper_path))
+    helper_path = GetHelperAppPath(frameworks_path,
+                                   brightray::GetApplicationName());
+  if (!base::PathExists(helper_path))
+    LOG(FATAL) << "Unable to find helper app";
+  PathService::Override(content::CHILD_PROCESS_EXE, helper_path);
+}
+
+}  // namespace electron
added in remote
  their  100644 10bab4e16a7f69d175b62550044261dc255230b9 electron/app/node_main.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/node_main.h"
+
+#include "electron/app/uv_task_runner.h"
+#include "electron/browser/javascript_environment.h"
+#include "electron/browser/node_debugger.h"
+#include "base/command_line.h"
+#include "electron/common/node_includes.h"
+#include "base/thread_task_runner_handle.h"
+#include "gin/array_buffer.h"
+#include "gin/public/isolate_holder.h"
+#include "gin/v8_initializer.h"
+
+namespace electron {
+
+int NodeMain(int argc, char *argv[]) {
+  base::CommandLine::Init(argc, argv);
+
+  int exit_code = 1;
+  {
+    // Feed gin::PerIsolateData with a task runner.
+    argv = uv_setup_args(argc, argv);
+    uv_loop_t* loop = uv_default_loop();
+    scoped_refptr<UvTaskRunner> uv_task_runner(new UvTaskRunner(loop));
+    base::ThreadTaskRunnerHandle handle(uv_task_runner);
+
+    gin::V8Initializer::LoadV8Snapshot();
+    gin::V8Initializer::LoadV8Natives();
+    JavascriptEnvironment gin_env;
+
+    int exec_argc;
+    const char** exec_argv;
+    node::Init(&argc, const_cast<const char**>(argv), &exec_argc, &exec_argv);
+
+    node::Environment* env = node::CreateEnvironment(
+        gin_env.isolate(), loop, gin_env.context(), argc, argv,
+        exec_argc, exec_argv);
+
+    // Start our custom debugger implementation.
+    NodeDebugger node_debugger(gin_env.isolate());
+    if (node_debugger.IsRunning())
+      env->AssignToContext(v8::Debug::GetDebugContext());
+
+    node::LoadEnvironment(env);
+
+    bool more;
+    do {
+      more = uv_run(env->event_loop(), UV_RUN_ONCE);
+      if (more == false) {
+        node::EmitBeforeExit(env);
+
+        // Emit `beforeExit` if the loop became alive either after emitting
+        // event, or after running some callbacks.
+        more = uv_loop_alive(env->event_loop());
+        if (uv_run(env->event_loop(), UV_RUN_NOWAIT) != 0)
+          more = true;
+      }
+    } while (more == true);
+
+    exit_code = node::EmitExit(env);
+    node::RunAtExit(env);
+
+    env->Dispose();
+  }
+
+  v8::V8::Dispose();
+
+  return exit_code;
+}
+
+}  // namespace electron
added in remote
  their  100644 98a39687267f0b30cc54f96049c9954a42b69d0b electron/app/node_main.h
@@ -0,0 +1,14 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_NODE_MAIN_H_
+#define ELECTRON_APP_NODE_MAIN_H_
+
+namespace electron {
+
+int NodeMain(int argc, char *argv[]);
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_NODE_MAIN_H_
added in remote
  their  100644 4d7bb75e3f31a716bf61cbd7ed4ff42ea0ba7edc electron/app/uv_task_runner.cc
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/app/uv_task_runner.h"
+
+#include "base/stl_util.h"
+
+namespace electron {
+
+UvTaskRunner::UvTaskRunner(uv_loop_t* loop) : loop_(loop) {
+}
+
+UvTaskRunner::~UvTaskRunner() {
+  for (auto& iter : tasks_) {
+    uv_unref(reinterpret_cast<uv_handle_t*>(iter.first));
+    delete iter.first;
+  }
+}
+
+bool UvTaskRunner::PostDelayedTask(const tracked_objects::Location& from_here,
+                                   const base::Closure& task,
+                                   base::TimeDelta delay) {
+  uv_timer_t* timer = new uv_timer_t;
+  timer->data = this;
+  uv_timer_init(loop_, timer);
+  uv_timer_start(timer, UvTaskRunner::OnTimeout, delay.InMilliseconds(), 0);
+  tasks_[timer] = task;
+  return true;
+}
+
+bool UvTaskRunner::RunsTasksOnCurrentThread() const {
+  return true;
+}
+
+bool UvTaskRunner::PostNonNestableDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  return PostDelayedTask(from_here, task, delay);
+}
+
+// static
+void UvTaskRunner::OnTimeout(uv_timer_t* timer) {
+  UvTaskRunner* self = static_cast<UvTaskRunner*>(timer->data);
+  if (!ContainsKey(self->tasks_, timer))
+    return;
+
+  self->tasks_[timer].Run();
+  self->tasks_.erase(timer);
+  uv_timer_stop(timer);
+  uv_close(reinterpret_cast<uv_handle_t*>(timer), UvTaskRunner::OnClose);
+}
+
+// static
+void UvTaskRunner::OnClose(uv_handle_t* handle) {
+  delete reinterpret_cast<uv_timer_t*>(handle);
+}
+
+}  // namespace electron
added in remote
  their  100644 668836682f0378a05dffe16bf49da255a1c2ea19 electron/app/uv_task_runner.h
@@ -0,0 +1,45 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_APP_UV_TASK_RUNNER_H_
+#define ELECTRON_APP_UV_TASK_RUNNER_H_
+
+#include <map>
+
+#include "base/callback.h"
+#include "base/single_thread_task_runner.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// TaskRunner implementation that posts tasks into libuv's default loop.
+class UvTaskRunner : public base::SingleThreadTaskRunner {
+ public:
+  explicit UvTaskRunner(uv_loop_t* loop);
+  ~UvTaskRunner() override;
+
+  // base::SingleThreadTaskRunner:
+  bool PostDelayedTask(const tracked_objects::Location& from_here,
+                       const base::Closure& task,
+                       base::TimeDelta delay) override;
+  bool RunsTasksOnCurrentThread() const override;
+  bool PostNonNestableDelayedTask(
+      const tracked_objects::Location& from_here,
+      const base::Closure& task,
+      base::TimeDelta delay) override;
+
+ private:
+  static void OnTimeout(uv_timer_t* timer);
+  static void OnClose(uv_handle_t* handle);
+
+  uv_loop_t* loop_;
+
+  std::map<uv_timer_t*, base::Closure> tasks_;
+
+  DISALLOW_COPY_AND_ASSIGN(UvTaskRunner);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_APP_UV_TASK_RUNNER_H_
added in remote
  their  100644 4ac19bcf4ce6d96a815d2825bccead9d3b2cabb7 electron/browser/api/electron_api_app.cc
@@ -0,0 +1,472 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_app.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/api/electron_api_session.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/login_handler.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "brightray/browser/brightray_paths.h"
+#include "chrome/common/chrome_paths.h"
+#include "content/public/browser/client_certificate_delegate.h"
+#include "content/public/browser/gpu_data_manager.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/common/content_switches.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/ssl/ssl_cert_request_info.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "ui/gfx/image/image.h"
+
+#if defined(OS_WIN)
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/win/shell.h"
+#endif
+
+using electron::Browser;
+
+namespace mate {
+
+#if defined(OS_WIN)
+template<>
+struct Converter<Browser::UserTask> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     Browser::UserTask* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    if (!dict.Get("program", &(out->program)) ||
+        !dict.Get("title", &(out->title)))
+      return false;
+    if (dict.Get("iconPath", &(out->icon_path)) &&
+        !dict.Get("iconIndex", &(out->icon_index)))
+      return false;
+    dict.Get("arguments", &(out->arguments));
+    dict.Get("description", &(out->description));
+    return true;
+  }
+};
+#endif
+
+}  // namespace mate
+
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Return the path constant from string.
+int GetPathConstant(const std::string& name) {
+  if (name == "appData")
+    return brightray::DIR_APP_DATA;
+  else if (name == "userData")
+    return brightray::DIR_USER_DATA;
+  else if (name == "cache")
+    return brightray::DIR_CACHE;
+  else if (name == "userCache")
+    return brightray::DIR_USER_CACHE;
+  else if (name == "home")
+    return base::DIR_HOME;
+  else if (name == "temp")
+    return base::DIR_TEMP;
+  else if (name == "userDesktop" || name == "desktop")
+    return base::DIR_USER_DESKTOP;
+  else if (name == "exe")
+    return base::FILE_EXE;
+  else if (name == "module")
+    return base::FILE_MODULE;
+  else if (name == "documents")
+    return chrome::DIR_USER_DOCUMENTS;
+  else if (name == "downloads")
+    return chrome::DIR_DEFAULT_DOWNLOADS;
+  else if (name == "music")
+    return chrome::DIR_USER_MUSIC;
+  else if (name == "pictures")
+    return chrome::DIR_USER_PICTURES;
+  else if (name == "videos")
+    return chrome::DIR_USER_VIDEOS;
+  else
+    return -1;
+}
+
+bool NotificationCallbackWrapper(
+    const ProcessSingleton::NotificationCallback& callback,
+    const base::CommandLine::StringVector& cmd,
+    const base::FilePath& cwd) {
+  // Make sure the callback is called after app gets ready.
+  if (Browser::Get()->is_ready()) {
+    callback.Run(cmd, cwd);
+  } else {
+    scoped_refptr<base::SingleThreadTaskRunner> task_runner(
+        base::ThreadTaskRunnerHandle::Get());
+    task_runner->PostTask(
+        FROM_HERE, base::Bind(base::IgnoreResult(callback), cmd, cwd));
+  }
+  // ProcessSingleton needs to know whether current process is quiting.
+  return !Browser::Get()->is_shutting_down();
+}
+
+void OnClientCertificateSelected(
+    v8::Isolate* isolate,
+    std::shared_ptr<content::ClientCertificateDelegate> delegate,
+    mate::Arguments* args) {
+  mate::Dictionary cert_data;
+  if (!args->GetNext(&cert_data)) {
+    args->ThrowError();
+    return;
+  }
+
+  v8::Local<v8::Object> data;
+  if (!cert_data.Get("data", &data))
+    return;
+
+  auto certs = net::X509Certificate::CreateCertificateListFromBytes(
+      node::Buffer::Data(data), node::Buffer::Length(data),
+      net::X509Certificate::FORMAT_AUTO);
+  if (certs.size() > 0)
+    delegate->ContinueWithCertificate(certs[0].get());
+}
+
+void PassLoginInformation(scoped_refptr<LoginHandler> login_handler,
+                          mate::Arguments* args) {
+  base::string16 username, password;
+  if (args->GetNext(&username) && args->GetNext(&password))
+    login_handler->Login(username, password);
+  else
+    login_handler->CancelAuth();
+}
+
+}  // namespace
+
+App::App() {
+  static_cast<ElectronBrowserClient*>(ElectronBrowserClient::Get())->set_delegate(this);
+  Browser::Get()->AddObserver(this);
+  content::GpuDataManager::GetInstance()->AddObserver(this);
+}
+
+App::~App() {
+  static_cast<ElectronBrowserClient*>(ElectronBrowserClient::Get())->set_delegate(
+      nullptr);
+  Browser::Get()->RemoveObserver(this);
+  content::GpuDataManager::GetInstance()->RemoveObserver(this);
+}
+
+void App::OnBeforeQuit(bool* prevent_default) {
+  *prevent_default = Emit("before-quit");
+}
+
+void App::OnWillQuit(bool* prevent_default) {
+  *prevent_default = Emit("will-quit");
+}
+
+void App::OnWindowAllClosed() {
+  Emit("window-all-closed");
+}
+
+void App::OnQuit() {
+  int exitCode = ElectronBrowserMainParts::Get()->GetExitCode();
+  Emit("quit", exitCode);
+
+  if (process_singleton_.get()) {
+    process_singleton_->Cleanup();
+    process_singleton_.reset();
+  }
+}
+
+void App::OnOpenFile(bool* prevent_default, const std::string& file_path) {
+  *prevent_default = Emit("open-file", file_path);
+}
+
+void App::OnOpenURL(const std::string& url) {
+  Emit("open-url", url);
+}
+
+void App::OnActivate(bool has_visible_windows) {
+  Emit("activate", has_visible_windows);
+}
+
+void App::OnWillFinishLaunching() {
+  Emit("will-finish-launching");
+}
+
+void App::OnFinishLaunching() {
+  Emit("ready");
+}
+
+void App::OnLogin(LoginHandler* login_handler) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  bool prevent_default = Emit(
+      "login",
+      WebContents::CreateFrom(isolate(), login_handler->GetWebContents()),
+      login_handler->request(),
+      login_handler->auth_info(),
+      base::Bind(&PassLoginInformation, make_scoped_refptr(login_handler)));
+
+  // Default behavior is to always cancel the auth.
+  if (!prevent_default)
+    login_handler->CancelAuth();
+}
+
+void App::AllowCertificateError(
+    content::WebContents* web_contents,
+    int cert_error,
+    const net::SSLInfo& ssl_info,
+    const GURL& request_url,
+    content::ResourceType resource_type,
+    bool overridable,
+    bool strict_enforcement,
+    bool expired_previous_decision,
+    const base::Callback<void(bool)>& callback,
+    content::CertificateRequestResultType* request) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  bool prevent_default = Emit("certificate-error",
+                              WebContents::CreateFrom(isolate(), web_contents),
+                              request_url,
+                              net::ErrorToString(cert_error),
+                              ssl_info.cert,
+                              callback);
+
+  // Deny the certificate by default.
+  if (!prevent_default)
+    *request = content::CERTIFICATE_REQUEST_RESULT_TYPE_DENY;
+}
+
+void App::SelectClientCertificate(
+    content::WebContents* web_contents,
+    net::SSLCertRequestInfo* cert_request_info,
+    scoped_ptr<content::ClientCertificateDelegate> delegate) {
+  std::shared_ptr<content::ClientCertificateDelegate>
+      shared_delegate(delegate.release());
+  bool prevent_default =
+      Emit("select-client-certificate",
+           WebContents::CreateFrom(isolate(), web_contents),
+           cert_request_info->host_and_port.ToString(),
+           cert_request_info->client_certs,
+           base::Bind(&OnClientCertificateSelected,
+                      isolate(),
+                      shared_delegate));
+
+  // Default to first certificate from the platform store.
+  if (!prevent_default)
+    shared_delegate->ContinueWithCertificate(
+        cert_request_info->client_certs[0].get());
+}
+
+void App::OnGpuProcessCrashed(base::TerminationStatus exit_code) {
+  Emit("gpu-process-crashed");
+}
+
+#if defined(OS_MACOSX)
+void App::OnPlatformThemeChanged() {
+  Emit("platform-theme-changed");
+}
+#endif
+
+base::FilePath App::GetPath(mate::Arguments* args, const std::string& name) {
+  bool succeed = false;
+  base::FilePath path;
+  int key = GetPathConstant(name);
+  if (key >= 0)
+    succeed = PathService::Get(key, &path);
+  if (!succeed)
+    args->ThrowError("Failed to get path");
+  return path;
+}
+
+void App::SetPath(mate::Arguments* args,
+                  const std::string& name,
+                  const base::FilePath& path) {
+  bool succeed = false;
+  int key = GetPathConstant(name);
+  if (key >= 0)
+    succeed = PathService::Override(key, path);
+  if (!succeed)
+    args->ThrowError("Failed to set path");
+}
+
+void App::SetDesktopName(const std::string& desktop_name) {
+#if defined(OS_LINUX)
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  env->SetVar("CHROME_DESKTOP", desktop_name);
+#endif
+}
+
+void App::AllowNTLMCredentialsForAllDomains(bool should_allow) {
+  auto browser_context = static_cast<ElectronBrowserContext*>(
+        ElectronBrowserMainParts::Get()->browser_context());
+  browser_context->AllowNTLMCredentialsForAllDomains(should_allow);
+}
+
+std::string App::GetLocale() {
+  return l10n_util::GetApplicationLocale("");
+}
+
+#if defined(OS_WIN)
+bool App::IsAeroGlassEnabled() {
+  return ui::win::IsAeroGlassEnabled();
+}
+#endif
+
+bool App::MakeSingleInstance(
+    const ProcessSingleton::NotificationCallback& callback) {
+  if (process_singleton_.get())
+    return false;
+
+  base::FilePath user_dir;
+  PathService::Get(brightray::DIR_USER_DATA, &user_dir);
+  process_singleton_.reset(new ProcessSingleton(
+      user_dir, base::Bind(NotificationCallbackWrapper, callback)));
+
+  switch (process_singleton_->NotifyOtherProcessOrCreate()) {
+    case ProcessSingleton::NotifyResult::LOCK_ERROR:
+    case ProcessSingleton::NotifyResult::PROFILE_IN_USE:
+    case ProcessSingleton::NotifyResult::PROCESS_NOTIFIED:
+      process_singleton_.reset();
+      return true;
+    case ProcessSingleton::NotifyResult::PROCESS_NONE:
+    default:  // Shouldn't be needed, but VS warns if it is not there.
+      return false;
+  }
+}
+
+mate::ObjectTemplateBuilder App::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  auto browser = base::Unretained(Browser::Get());
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("quit", base::Bind(&Browser::Quit, browser))
+      .SetMethod("exit", base::Bind(&Browser::Exit, browser))
+      .SetMethod("focus", base::Bind(&Browser::Focus, browser))
+      .SetMethod("getVersion", base::Bind(&Browser::GetVersion, browser))
+      .SetMethod("setVersion", base::Bind(&Browser::SetVersion, browser))
+      .SetMethod("getName", base::Bind(&Browser::GetName, browser))
+      .SetMethod("setName", base::Bind(&Browser::SetName, browser))
+      .SetMethod("isReady", base::Bind(&Browser::is_ready, browser))
+      .SetMethod("addRecentDocument",
+                 base::Bind(&Browser::AddRecentDocument, browser))
+      .SetMethod("clearRecentDocuments",
+                 base::Bind(&Browser::ClearRecentDocuments, browser))
+      .SetMethod("setAppUserModelId",
+                 base::Bind(&Browser::SetAppUserModelID, browser))
+      .SetMethod("setAsDefaultProtocolClient",
+                 base::Bind(&Browser::SetAsDefaultProtocolClient, browser))
+      .SetMethod("removeAsDefaultProtocolClient",
+                 base::Bind(&Browser::RemoveAsDefaultProtocolClient, browser))
+#if defined(OS_MACOSX)
+      .SetMethod("hide", base::Bind(&Browser::Hide, browser))
+      .SetMethod("show", base::Bind(&Browser::Show, browser))
+      .SetMethod("isDarkMode",
+                 base::Bind(&Browser::IsDarkMode, browser))
+#endif
+#if defined(OS_WIN)
+      .SetMethod("setUserTasks",
+                 base::Bind(&Browser::SetUserTasks, browser))
+      .SetMethod("isAeroGlassEnabled", &App::IsAeroGlassEnabled)
+#endif
+      .SetMethod("setPath", &App::SetPath)
+      .SetMethod("getPath", &App::GetPath)
+      .SetMethod("setDesktopName", &App::SetDesktopName)
+      .SetMethod("allowNTLMCredentialsForAllDomains",
+                 &App::AllowNTLMCredentialsForAllDomains)
+      .SetMethod("getLocale", &App::GetLocale)
+      .SetMethod("makeSingleInstance", &App::MakeSingleInstance);
+}
+
+// static
+mate::Handle<App> App::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new App);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void AppendSwitch(const std::string& switch_string, mate::Arguments* args) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  if (switch_string == electron::switches::kPpapiFlashPath ||
+      switch_string == electron::switches::kClientCertificate ||
+      switch_string == switches::kLogNetLog) {
+    base::FilePath path;
+    args->GetNext(&path);
+    command_line->AppendSwitchPath(switch_string, path);
+    return;
+  }
+
+  std::string value;
+  if (args->GetNext(&value))
+    command_line->AppendSwitchASCII(switch_string, value);
+  else
+    command_line->AppendSwitch(switch_string);
+}
+
+#if defined(OS_MACOSX)
+int DockBounce(const std::string& type) {
+  int request_id = -1;
+  if (type == "critical")
+    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_CRITICAL);
+  else if (type == "informational")
+    request_id = Browser::Get()->DockBounce(Browser::BOUNCE_INFORMATIONAL);
+  return request_id;
+}
+
+void DockSetMenu(electron::api::Menu* menu) {
+  Browser::Get()->DockSetMenu(menu->model());
+}
+#endif
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  auto command_line = base::CommandLine::ForCurrentProcess();
+
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("app", electron::api::App::Create(isolate));
+  dict.SetMethod("appendSwitch", &AppendSwitch);
+  dict.SetMethod("appendArgument",
+                 base::Bind(&base::CommandLine::AppendArg,
+                            base::Unretained(command_line)));
+#if defined(OS_MACOSX)
+  auto browser = base::Unretained(Browser::Get());
+  dict.SetMethod("dockBounce", &DockBounce);
+  dict.SetMethod("dockCancelBounce",
+                 base::Bind(&Browser::DockCancelBounce, browser));
+  dict.SetMethod("dockSetBadgeText",
+                 base::Bind(&Browser::DockSetBadgeText, browser));
+  dict.SetMethod("dockGetBadgeText",
+                 base::Bind(&Browser::DockGetBadgeText, browser));
+  dict.SetMethod("dockHide", base::Bind(&Browser::DockHide, browser));
+  dict.SetMethod("dockShow", base::Bind(&Browser::DockShow, browser));
+  dict.SetMethod("dockSetMenu", &DockSetMenu);
+  dict.SetMethod("dockSetIcon", base::Bind(&Browser::DockSetIcon, browser));
+#endif
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_app, Initialize)
added in remote
  their  100644 a824d4b4ecea505eb572bdb97a3577b37e82d119 electron/browser/api/electron_api_app.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
+
+#include <string>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/browser_observer.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "chrome/browser/process_singleton.h"
+#include "content/public/browser/gpu_data_manager_observer.h"
+#include "native_mate/handle.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class App : public ElectronBrowserClient::Delegate,
+            public mate::EventEmitter,
+            public BrowserObserver,
+            public content::GpuDataManagerObserver {
+ public:
+  static mate::Handle<App> Create(v8::Isolate* isolate);
+
+ protected:
+  App();
+  virtual ~App();
+
+  // BrowserObserver:
+  void OnBeforeQuit(bool* prevent_default) override;
+  void OnWillQuit(bool* prevent_default) override;
+  void OnWindowAllClosed() override;
+  void OnQuit() override;
+  void OnOpenFile(bool* prevent_default, const std::string& file_path) override;
+  void OnOpenURL(const std::string& url) override;
+  void OnActivate(bool has_visible_windows) override;
+  void OnWillFinishLaunching() override;
+  void OnFinishLaunching() override;
+  void OnLogin(LoginHandler* login_handler) override;
+
+  // content::ContentBrowserClient:
+  void AllowCertificateError(
+      content::WebContents* web_contents,
+      int cert_error,
+      const net::SSLInfo& ssl_info,
+      const GURL& request_url,
+      content::ResourceType resource_type,
+      bool overridable,
+      bool strict_enforcement,
+      bool expired_previous_decision,
+      const base::Callback<void(bool)>& callback,
+      content::CertificateRequestResultType* request) override;
+  void SelectClientCertificate(
+      content::WebContents* web_contents,
+      net::SSLCertRequestInfo* cert_request_info,
+      scoped_ptr<content::ClientCertificateDelegate> delegate) override;
+
+  // content::GpuDataManagerObserver:
+  void OnGpuProcessCrashed(base::TerminationStatus exit_code) override;
+
+#if defined(OS_MACOSX)
+  void OnPlatformThemeChanged() override;
+#endif
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  // Get/Set the pre-defined path in PathService.
+  base::FilePath GetPath(mate::Arguments* args, const std::string& name);
+  void SetPath(mate::Arguments* args,
+               const std::string& name,
+               const base::FilePath& path);
+
+  void SetDesktopName(const std::string& desktop_name);
+  void AllowNTLMCredentialsForAllDomains(bool should_allow);
+  bool MakeSingleInstance(
+      const ProcessSingleton::NotificationCallback& callback);
+  std::string GetLocale();
+
+#if defined(OS_WIN)
+  bool IsAeroGlassEnabled();
+#endif
+
+  scoped_ptr<ProcessSingleton> process_singleton_;
+
+  DISALLOW_COPY_AND_ASSIGN(App);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_APP_H_
added in remote
  their  100644 2de74a2077d1ba9104dab6200d1b9d06e00cd2df electron/browser/api/electron_api_auto_updater.cc
@@ -0,0 +1,124 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_auto_updater.h"
+
+#include "base/time/time.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::Time> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::Time& val) {
+    v8::MaybeLocal<v8::Value> date = v8::Date::New(
+        isolate->GetCurrentContext(), val.ToJsTime());
+    if (date.IsEmpty())
+      return v8::Null(isolate);
+    else
+      return date.ToLocalChecked();
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+AutoUpdater::AutoUpdater() {
+  auto_updater::AutoUpdater::SetDelegate(this);
+}
+
+AutoUpdater::~AutoUpdater() {
+  auto_updater::AutoUpdater::SetDelegate(nullptr);
+}
+
+void AutoUpdater::OnError(const std::string& message) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  auto error = v8::Exception::Error(mate::StringToV8(isolate(), message));
+  EmitCustomEvent(
+      "error",
+      error->ToObject(isolate()->GetCurrentContext()).ToLocalChecked(),
+      // Message is also emitted to keep compatibility with old code.
+      message);
+}
+
+void AutoUpdater::OnCheckingForUpdate() {
+  Emit("checking-for-update");
+}
+
+void AutoUpdater::OnUpdateAvailable() {
+  Emit("update-available");
+}
+
+void AutoUpdater::OnUpdateNotAvailable() {
+  Emit("update-not-available");
+}
+
+void AutoUpdater::OnUpdateDownloaded(const std::string& release_notes,
+                                     const std::string& release_name,
+                                     const base::Time& release_date,
+                                     const std::string& url) {
+  Emit("update-downloaded", release_notes, release_name, release_date, url,
+       // Keep compatibility with old APIs.
+       base::Bind(&AutoUpdater::QuitAndInstall, base::Unretained(this)));
+}
+
+void AutoUpdater::OnWindowAllClosed() {
+  QuitAndInstall();
+}
+
+mate::ObjectTemplateBuilder AutoUpdater::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("setFeedURL", &auto_updater::AutoUpdater::SetFeedURL)
+      .SetMethod("checkForUpdates", &auto_updater::AutoUpdater::CheckForUpdates)
+      .SetMethod("quitAndInstall", &AutoUpdater::QuitAndInstall);
+}
+
+void AutoUpdater::QuitAndInstall() {
+  // If we don't have any window then quitAndInstall immediately.
+  WindowList* window_list = WindowList::GetInstance();
+  if (window_list->size() == 0) {
+    auto_updater::AutoUpdater::QuitAndInstall();
+    return;
+  }
+
+  // Otherwise do the restart after all windows have been closed.
+  window_list->AddObserver(this);
+  for (NativeWindow* window : *window_list)
+    window->Close();
+}
+
+// static
+mate::Handle<AutoUpdater> AutoUpdater::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new AutoUpdater);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("autoUpdater", electron::api::AutoUpdater::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_auto_updater, Initialize)
added in remote
  their  100644 cd9960f6a563774735fd25ecbb21eec3033d7383 electron/browser/api/electron_api_auto_updater.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
+
+#include <string>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/browser/auto_updater.h"
+#include "electron/browser/window_list_observer.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class AutoUpdater : public mate::EventEmitter,
+                    public auto_updater::Delegate,
+                    public WindowListObserver {
+ public:
+  static mate::Handle<AutoUpdater> Create(v8::Isolate* isolate);
+
+ protected:
+  AutoUpdater();
+  virtual ~AutoUpdater();
+
+  // Delegate implementations.
+  void OnError(const std::string& error) override;
+  void OnCheckingForUpdate() override;
+  void OnUpdateAvailable() override;
+  void OnUpdateNotAvailable() override;
+  void OnUpdateDownloaded(const std::string& release_notes,
+                          const std::string& release_name,
+                          const base::Time& release_date,
+                          const std::string& update_url) override;
+
+  // WindowListObserver:
+  void OnWindowAllClosed() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  void QuitAndInstall();
+
+  DISALLOW_COPY_AND_ASSIGN(AutoUpdater);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_AUTO_UPDATER_H_
added in remote
  their  100644 3a2fb346beaa5eba580aa644b8aa35228388074c electron/browser/api/electron_api_content_tracing.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <set>
+#include <string>
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "content/public/browser/tracing_controller.h"
+#include "native_mate/dictionary.h"
+
+using content::TracingController;
+
+namespace mate {
+
+template<>
+struct Converter<base::trace_event::TraceConfig> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::trace_event::TraceConfig* out) {
+    Dictionary options;
+    if (!ConvertFromV8(isolate, val, &options))
+      return false;
+    std::string category_filter, trace_options;
+    if (!options.Get("categoryFilter", &category_filter) ||
+        !options.Get("traceOptions", &trace_options))
+      return false;
+    *out = base::trace_event::TraceConfig(category_filter, trace_options);
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+using CompletionCallback = base::Callback<void(const base::FilePath&)>;
+
+scoped_refptr<TracingController::TraceDataSink> GetTraceDataSink(
+    const base::FilePath& path, const CompletionCallback& callback) {
+  base::FilePath result_file_path = path;
+  if (result_file_path.empty() && !base::CreateTemporaryFile(&result_file_path))
+    LOG(ERROR) << "Creating temporary file failed";
+
+  return TracingController::CreateFileSink(result_file_path,
+                                           base::Bind(callback,
+                                                      result_file_path));
+}
+
+void StopRecording(const base::FilePath& path,
+                   const CompletionCallback& callback) {
+  TracingController::GetInstance()->StopTracing(
+      GetTraceDataSink(path, callback));
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  auto controller = base::Unretained(TracingController::GetInstance());
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("getCategories", base::Bind(
+      &TracingController::GetCategories, controller));
+  dict.SetMethod("startRecording", base::Bind(
+      &TracingController::StartTracing, controller));
+  dict.SetMethod("stopRecording", &StopRecording);
+  dict.SetMethod("getTraceBufferUsage", base::Bind(
+      &TracingController::GetTraceBufferUsage, controller));
+  dict.SetMethod("setWatchEvent", base::Bind(
+      &TracingController::SetWatchEvent, controller));
+  dict.SetMethod("cancelWatchEvent", base::Bind(
+      &TracingController::CancelWatchEvent, controller));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_content_tracing, Initialize)
added in remote
  their  100644 8974d7492b6fb85ea50539c0cc79297c8050de41 electron/browser/api/electron_api_cookies.cc
@@ -0,0 +1,240 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_cookies.h"
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "base/time/time.h"
+#include "base/values.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/cookies/cookie_monster.h"
+#include "net/cookies/cookie_store.h"
+#include "net/cookies/cookie_util.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_context_getter.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+template<>
+struct Converter<electron::api::Cookies::Error> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   electron::api::Cookies::Error val) {
+    if (val == electron::api::Cookies::SUCCESS)
+      return v8::Null(isolate);
+    else
+      return v8::Exception::Error(StringToV8(isolate, "failed"));
+  }
+};
+
+template<>
+struct Converter<net::CanonicalCookie> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::CanonicalCookie& val) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("name", val.Name());
+    dict.Set("value", val.Value());
+    dict.Set("domain", val.Domain());
+    dict.Set("hostOnly", net::cookie_util::DomainIsHostOnly(val.Domain()));
+    dict.Set("path", val.Path());
+    dict.Set("secure", val.IsSecure());
+    dict.Set("httpOnly", val.IsHttpOnly());
+    dict.Set("session", !val.IsPersistent());
+    if (!val.IsPersistent())
+      dict.Set("expirationDate", val.ExpiryDate().ToDoubleT());
+    return dict.GetHandle();
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Returns whether |domain| matches |filter|.
+bool MatchesDomain(std::string filter, const std::string& domain) {
+  // Add a leading '.' character to the filter domain if it doesn't exist.
+  if (net::cookie_util::DomainIsHostOnly(filter))
+    filter.insert(0, ".");
+
+  std::string sub_domain(domain);
+  // Strip any leading '.' character from the input cookie domain.
+  if (!net::cookie_util::DomainIsHostOnly(sub_domain))
+    sub_domain = sub_domain.substr(1);
+
+  // Now check whether the domain argument is a subdomain of the filter domain.
+  for (sub_domain.insert(0, "."); sub_domain.length() >= filter.length();) {
+    if (sub_domain == filter)
+      return true;
+    const size_t next_dot = sub_domain.find('.', 1);  // Skip over leading dot.
+    sub_domain.erase(0, next_dot);
+  }
+  return false;
+}
+
+// Returns whether |cookie| matches |filter|.
+bool MatchesCookie(const base::DictionaryValue* filter,
+                   const net::CanonicalCookie& cookie) {
+  std::string str;
+  bool b;
+  if (filter->GetString("name", &str) && str != cookie.Name())
+    return false;
+  if (filter->GetString("path", &str) && str != cookie.Path())
+    return false;
+  if (filter->GetString("domain", &str) && !MatchesDomain(str, cookie.Domain()))
+    return false;
+  if (filter->GetBoolean("secure", &b) && b != cookie.IsSecure())
+    return false;
+  if (filter->GetBoolean("session", &b) && b != !cookie.IsPersistent())
+    return false;
+  return true;
+}
+
+// Helper to returns the CookieStore.
+inline net::CookieStore* GetCookieStore(
+    scoped_refptr<net::URLRequestContextGetter> getter) {
+  return getter->GetURLRequestContext()->cookie_store();
+}
+
+// Run |callback| on UI thread.
+void RunCallbackInUI(const base::Closure& callback) {
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, callback);
+}
+
+// Remove cookies from |list| not matching |filter|, and pass it to |callback|.
+void FilterCookies(scoped_ptr<base::DictionaryValue> filter,
+                   const Cookies::GetCallback& callback,
+                   const net::CookieList& list) {
+  net::CookieList result;
+  for (const auto& cookie : list) {
+    if (MatchesCookie(filter.get(), cookie))
+      result.push_back(cookie);
+  }
+  RunCallbackInUI(base::Bind(callback, Cookies::SUCCESS, result));
+}
+
+// Receives cookies matching |filter| in IO thread.
+void GetCookiesOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                    scoped_ptr<base::DictionaryValue> filter,
+                    const Cookies::GetCallback& callback) {
+  std::string url;
+  filter->GetString("url", &url);
+
+  auto filtered_callback =
+      base::Bind(FilterCookies, base::Passed(&filter), callback);
+
+  net::CookieMonster* monster = GetCookieStore(getter)->GetCookieMonster();
+  // Empty url will match all url cookies.
+  if (url.empty())
+    monster->GetAllCookiesAsync(filtered_callback);
+  else
+    monster->GetAllCookiesForURLAsync(GURL(url), filtered_callback);
+}
+
+// Removes cookie with |url| and |name| in IO thread.
+void RemoveCookieOnIOThread(scoped_refptr<net::URLRequestContextGetter> getter,
+                            const GURL& url, const std::string& name,
+                            const base::Closure& callback) {
+  GetCookieStore(getter)->DeleteCookieAsync(
+      url, name, base::Bind(RunCallbackInUI, callback));
+}
+
+// Callback of SetCookie.
+void OnSetCookie(const Cookies::SetCallback& callback, bool success) {
+  RunCallbackInUI(
+      base::Bind(callback, success ? Cookies::SUCCESS : Cookies::FAILED));
+}
+
+// Sets cookie with |details| in IO thread.
+void SetCookieOnIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                   scoped_ptr<base::DictionaryValue> details,
+                   const Cookies::SetCallback& callback) {
+  std::string url, name, value, domain, path;
+  bool secure = false;
+  bool http_only = false;
+  double expiration_date;
+  details->GetString("url", &url);
+  details->GetString("name", &name);
+  details->GetString("value", &value);
+  details->GetString("domain", &domain);
+  details->GetString("path", &path);
+  details->GetBoolean("secure", &secure);
+  details->GetBoolean("httpOnly", &http_only);
+
+  base::Time expiration_time;
+  if (details->GetDouble("expirationDate", &expiration_date)) {
+    expiration_time = (expiration_date == 0) ?
+        base::Time::UnixEpoch() :
+        base::Time::FromDoubleT(expiration_date);
+  }
+
+  GetCookieStore(getter)->GetCookieMonster()->SetCookieWithDetailsAsync(
+      GURL(url), name, value, domain, path, expiration_time, secure, http_only,
+      false, false, false, net::COOKIE_PRIORITY_DEFAULT,
+      base::Bind(OnSetCookie, callback));
+}
+
+}  // namespace
+
+Cookies::Cookies(content::BrowserContext* browser_context)
+    : request_context_getter_(browser_context->GetRequestContext()) {
+}
+
+Cookies::~Cookies() {
+}
+
+void Cookies::Get(const base::DictionaryValue& filter,
+                  const GetCallback& callback) {
+  scoped_ptr<base::DictionaryValue> copied(filter.CreateDeepCopy());
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(GetCookiesOnIO, getter, Passed(&copied), callback));
+}
+
+void Cookies::Remove(const GURL& url, const std::string& name,
+                     const base::Closure& callback) {
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(RemoveCookieOnIOThread, getter, url, name, callback));
+}
+
+void Cookies::Set(const base::DictionaryValue& details,
+                  const SetCallback& callback) {
+  scoped_ptr<base::DictionaryValue> copied(details.CreateDeepCopy());
+  auto getter = make_scoped_refptr(request_context_getter_);
+  content::BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(SetCookieOnIO, getter, Passed(&copied), callback));
+}
+
+// static
+mate::Handle<Cookies> Cookies::Create(
+    v8::Isolate* isolate,
+    content::BrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new Cookies(browser_context));
+}
+
+// static
+void Cookies::BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("get", &Cookies::Get)
+      .SetMethod("remove", &Cookies::Remove)
+      .SetMethod("set", &Cookies::Set);
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 196f4576fe6c837eab191f92eee39f9879779dd0 electron/browser/api/electron_api_cookies.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "native_mate/handle.h"
+#include "net/cookies/canonical_cookie.h"
+
+namespace base {
+class DictionaryValue;
+}
+
+namespace content {
+class BrowserContext;
+}
+
+namespace net {
+class URLRequestContextGetter;
+}
+
+namespace electron {
+
+namespace api {
+
+class Cookies : public mate::TrackableObject<Cookies> {
+ public:
+  enum Error {
+    SUCCESS,
+    FAILED,
+  };
+
+  using GetCallback = base::Callback<void(Error, const net::CookieList&)>;
+  using SetCallback = base::Callback<void(Error)>;
+
+  static mate::Handle<Cookies> Create(v8::Isolate* isolate,
+                                      content::BrowserContext* browser_context);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Cookies(content::BrowserContext* browser_context);
+  ~Cookies();
+
+  void Get(const base::DictionaryValue& filter, const GetCallback& callback);
+  void Remove(const GURL& url, const std::string& name,
+              const base::Closure& callback);
+  void Set(const base::DictionaryValue& details, const SetCallback& callback);
+
+ private:
+  net::URLRequestContextGetter* request_context_getter_;
+
+  DISALLOW_COPY_AND_ASSIGN(Cookies);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_COOKIES_H_
added in remote
  their  100644 8721a8cb7299ddf611b5f543a9a834b8c8a22439 electron/browser/api/electron_api_debugger.cc
@@ -0,0 +1,195 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_debugger.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/json/json_reader.h"
+#include "base/json/json_writer.h"
+#include "content/public/browser/devtools_agent_host.h"
+#include "content/public/browser/web_contents.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+using content::DevToolsAgentHost;
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapDebugger funtion which is implemented in JavaScript.
+using WrapDebuggerCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapDebuggerCallback g_wrap_debugger;
+
+}  // namespace
+
+Debugger::Debugger(content::WebContents* web_contents)
+    : web_contents_(web_contents),
+      previous_request_id_(0) {
+}
+
+Debugger::~Debugger() {
+}
+
+void Debugger::AgentHostClosed(DevToolsAgentHost* agent_host,
+                               bool replaced_with_another_client) {
+  std::string detach_reason = "target closed";
+  if (replaced_with_another_client)
+    detach_reason = "replaced with devtools";
+  Emit("detach", detach_reason);
+}
+
+void Debugger::DispatchProtocolMessage(DevToolsAgentHost* agent_host,
+                                       const std::string& message) {
+  DCHECK(agent_host == agent_host_.get());
+
+  scoped_ptr<base::Value> parsed_message(base::JSONReader::Read(message));
+  if (!parsed_message->IsType(base::Value::TYPE_DICTIONARY))
+    return;
+
+  base::DictionaryValue* dict =
+      static_cast<base::DictionaryValue*>(parsed_message.get());
+  int id;
+  if (!dict->GetInteger("id", &id)) {
+    std::string method;
+    if (!dict->GetString("method", &method))
+      return;
+    base::DictionaryValue* params_value = nullptr;
+    base::DictionaryValue params;
+    if (dict->GetDictionary("params", &params_value))
+      params.Swap(params_value);
+    Emit("message", method, params);
+  } else {
+    auto send_command_callback = pending_requests_[id];
+    pending_requests_.erase(id);
+    if (send_command_callback.is_null())
+      return;
+    base::DictionaryValue* error_body = nullptr;
+    base::DictionaryValue error;
+    if (dict->GetDictionary("error", &error_body))
+      error.Swap(error_body);
+
+    base::DictionaryValue* result_body = nullptr;
+    base::DictionaryValue result;
+    if (dict->GetDictionary("result", &result_body))
+      result.Swap(result_body);
+    send_command_callback.Run(error, result);
+  }
+}
+
+void Debugger::Attach(mate::Arguments* args) {
+  std::string protocol_version;
+  args->GetNext(&protocol_version);
+
+  if (!protocol_version.empty() &&
+      !DevToolsAgentHost::IsSupportedProtocolVersion(protocol_version)) {
+    args->ThrowError("Requested protocol version is not supported");
+    return;
+  }
+  agent_host_ = DevToolsAgentHost::GetOrCreateFor(web_contents_);
+  if (!agent_host_.get()) {
+    args->ThrowError("No target available");
+    return;
+  }
+  if (agent_host_->IsAttached()) {
+    args->ThrowError("Another debugger is already attached to this target");
+    return;
+  }
+
+  agent_host_->AttachClient(this);
+}
+
+bool Debugger::IsAttached() {
+  return agent_host_.get() ? agent_host_->IsAttached() : false;
+}
+
+void Debugger::Detach() {
+  if (!agent_host_.get())
+    return;
+  agent_host_->DetachClient();
+  AgentHostClosed(agent_host_.get(), false);
+  agent_host_ = nullptr;
+}
+
+void Debugger::SendCommand(mate::Arguments* args) {
+  if (!agent_host_.get())
+    return;
+
+  std::string method;
+  if (!args->GetNext(&method)) {
+    args->ThrowError();
+    return;
+  }
+  base::DictionaryValue command_params;
+  args->GetNext(&command_params);
+  SendCommandCallback callback;
+  args->GetNext(&callback);
+
+  base::DictionaryValue request;
+  int request_id = ++previous_request_id_;
+  pending_requests_[request_id] = callback;
+  request.SetInteger("id", request_id);
+  request.SetString("method", method);
+  if (!command_params.empty())
+    request.Set("params", command_params.DeepCopy());
+
+  std::string json_args;
+  base::JSONWriter::Write(request, &json_args);
+  agent_host_->DispatchProtocolMessage(json_args);
+}
+
+// static
+mate::Handle<Debugger> Debugger::Create(
+    v8::Isolate* isolate,
+    content::WebContents* web_contents) {
+  auto handle = mate::CreateHandle(isolate, new Debugger(web_contents));
+  g_wrap_debugger.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+void Debugger::BuildPrototype(v8::Isolate* isolate,
+                              v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("attach", &Debugger::Attach)
+      .SetMethod("isAttached", &Debugger::IsAttached)
+      .SetMethod("detach", &Debugger::Detach)
+      .SetMethod("sendCommand", &Debugger::SendCommand);
+}
+
+void ClearWrapDebugger() {
+  g_wrap_debugger.Reset();
+}
+
+void SetWrapDebugger(const WrapDebuggerCallback& callback) {
+  g_wrap_debugger = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapDebugger));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("_setWrapDebugger", &electron::api::SetWrapDebugger);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_debugger, Initialize);
added in remote
  their  100644 5822573d3b1fd06dcba088a990f1fb0537050c9a electron/browser/api/electron_api_debugger.h
@@ -0,0 +1,75 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
+
+#include <map>
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "base/values.h"
+#include "content/public/browser/devtools_agent_host_client.h"
+#include "native_mate/handle.h"
+
+namespace content {
+class DevToolsAgentHost;
+class WebContents;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class Debugger: public mate::TrackableObject<Debugger>,
+                public content::DevToolsAgentHostClient {
+ public:
+  using SendCommandCallback =
+      base::Callback<void(const base::DictionaryValue&,
+                          const base::DictionaryValue&)>;
+
+  static mate::Handle<Debugger> Create(
+      v8::Isolate* isolate, content::WebContents* web_contents);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Debugger(content::WebContents* web_contents);
+  ~Debugger();
+
+  // content::DevToolsAgentHostClient:
+  void AgentHostClosed(content::DevToolsAgentHost* agent_host,
+                       bool replaced_with_another_client) override;
+  void DispatchProtocolMessage(content::DevToolsAgentHost* agent_host,
+                               const std::string& message) override;
+
+ private:
+  using PendingRequestMap = std::map<int, SendCommandCallback>;
+
+  void Attach(mate::Arguments* args);
+  bool IsAttached();
+  void Detach();
+  void SendCommand(mate::Arguments* args);
+
+  content::WebContents* web_contents_;  // Weak Reference.
+  scoped_refptr<content::DevToolsAgentHost> agent_host_;
+
+  PendingRequestMap pending_requests_;
+  int previous_request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(Debugger);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DEBUGGER_H_
added in remote
  their  100644 18c562e8951d0da6eb37f20b0a513e8c2be2a8b9 electron/browser/api/electron_api_desktop_capturer.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_desktop_capturer.h"
+
+#include "electron/common/api/electron_api_native_image.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/media/desktop_media_list.h"
+#include "native_mate/dictionary.h"
+#include "third_party/webrtc/modules/desktop_capture/desktop_capture_options.h"
+#include "third_party/webrtc/modules/desktop_capture/screen_capturer.h"
+#include "third_party/webrtc/modules/desktop_capture/window_capturer.h"
+
+#include "electron/common/node_includes.h"
+
+namespace mate {
+
+template<>
+struct Converter<DesktopMediaList::Source> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const DesktopMediaList::Source& source) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    content::DesktopMediaID id = source.id;
+    dict.Set("name", base::UTF16ToUTF8(source.name));
+    dict.Set("id", id.ToString());
+    dict.Set(
+        "thumbnail",
+        electron::api::NativeImage::Create(isolate, gfx::Image(source.thumbnail)));
+    return ConvertToV8(isolate, dict);
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+DesktopCapturer::DesktopCapturer() {
+}
+
+DesktopCapturer::~DesktopCapturer() {
+}
+
+void DesktopCapturer::StartHandling(bool capture_window,
+                                    bool capture_screen,
+                                    const gfx::Size& thumbnail_size) {
+  webrtc::DesktopCaptureOptions options =
+      webrtc::DesktopCaptureOptions::CreateDefault();
+
+#if defined(OS_WIN)
+  // On windows, desktop effects (e.g. Aero) will be disabled when the Desktop
+  // capture API is active by default.
+  // We keep the desktop effects in most times. Howerver, the screen still
+  // fickers when the API is capturing the window due to limitation of current
+  // implemetation. This is a known and wontFix issue in webrtc (see:
+  // http://code.google.com/p/webrtc/issues/detail?id=3373)
+  options.set_disable_effects(false);
+#endif
+
+  scoped_ptr<webrtc::ScreenCapturer> screen_capturer(
+      capture_screen ? webrtc::ScreenCapturer::Create(options) : nullptr);
+  scoped_ptr<webrtc::WindowCapturer> window_capturer(
+      capture_window ? webrtc::WindowCapturer::Create(options) : nullptr);
+  media_list_.reset(new NativeDesktopMediaList(
+      std::move(screen_capturer), std::move(window_capturer)));
+
+  media_list_->SetThumbnailSize(thumbnail_size);
+  media_list_->StartUpdating(this);
+}
+
+void DesktopCapturer::OnSourceAdded(int index) {
+}
+
+void DesktopCapturer::OnSourceRemoved(int index) {
+}
+
+void DesktopCapturer::OnSourceMoved(int old_index, int new_index) {
+}
+
+void DesktopCapturer::OnSourceNameChanged(int index) {
+}
+
+void DesktopCapturer::OnSourceThumbnailChanged(int index) {
+}
+
+bool DesktopCapturer::OnRefreshFinished() {
+  Emit("finished", media_list_->GetSources());
+  media_list_.reset();
+  return false;
+}
+
+mate::ObjectTemplateBuilder DesktopCapturer::GetObjectTemplateBuilder(
+      v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("startHandling", &DesktopCapturer::StartHandling);
+}
+
+// static
+mate::Handle<DesktopCapturer> DesktopCapturer::Create(v8::Isolate* isolate) {
+  return mate::CreateHandle(isolate, new DesktopCapturer);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("desktopCapturer", electron::api::DesktopCapturer::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_desktop_capturer, Initialize);
added in remote
  their  100644 c70348207224d0e370348d10cbe662cf3777dda9 electron/browser/api/electron_api_desktop_capturer.h
@@ -0,0 +1,52 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
+
+#include "electron/browser/api/event_emitter.h"
+#include "chrome/browser/media/desktop_media_list_observer.h"
+#include "chrome/browser/media/native_desktop_media_list.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class DesktopCapturer: public mate::EventEmitter,
+                       public DesktopMediaListObserver {
+ public:
+  static mate::Handle<DesktopCapturer> Create(v8::Isolate* isolate);
+
+  void StartHandling(bool capture_window,
+                     bool capture_screen,
+                     const gfx::Size& thumbnail_size);
+
+ protected:
+  DesktopCapturer();
+  ~DesktopCapturer();
+
+  // DesktopMediaListObserver overrides.
+  void OnSourceAdded(int index) override;
+  void OnSourceRemoved(int index) override;
+  void OnSourceMoved(int old_index, int new_index) override;
+  void OnSourceNameChanged(int index) override;
+  void OnSourceThumbnailChanged(int index) override;
+  bool OnRefreshFinished() override;
+
+ private:
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+  scoped_ptr<DesktopMediaList> media_list_;
+
+  DISALLOW_COPY_AND_ASSIGN(DesktopCapturer);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DESKTOP_CAPTURER_H_
added in remote
  their  100644 61e362f0eb861141de4ca58dc2e45b8cd7e6b6b4 electron/browser/api/electron_api_dialog.cc
@@ -0,0 +1,120 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "electron/browser/ui/message_box.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+namespace mate {
+
+template<>
+struct Converter<file_dialog::Filter> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     file_dialog::Filter* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    if (!dict.Get("name", &(out->first)))
+      return false;
+    if (!dict.Get("extensions", &(out->second)))
+      return false;
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+void ShowMessageBox(int type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  electron::MessageBoxCallback callback;
+  if (mate::Converter<electron::MessageBoxCallback>::FromV8(args->isolate(),
+                                                        peek,
+                                                        &callback)) {
+    electron::ShowMessageBox(window, (electron::MessageBoxType)type, buttons,
+                         default_id, cancel_id, options, title,
+                         message, detail, icon, callback);
+  } else {
+    int chosen = electron::ShowMessageBox(window, (electron::MessageBoxType)type,
+                                      buttons, default_id, cancel_id,
+                                      options, title, message, detail, icon);
+    args->Return(chosen);
+  }
+}
+
+void ShowOpenDialog(const std::string& title,
+                    const base::FilePath& default_path,
+                    const file_dialog::Filters& filters,
+                    int properties,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  file_dialog::OpenDialogCallback callback;
+  if (mate::Converter<file_dialog::OpenDialogCallback>::FromV8(args->isolate(),
+                                                               peek,
+                                                               &callback)) {
+    file_dialog::ShowOpenDialog(window, title, default_path, filters,
+                                properties, callback);
+  } else {
+    std::vector<base::FilePath> paths;
+    if (file_dialog::ShowOpenDialog(window, title, default_path, filters,
+                                    properties, &paths))
+      args->Return(paths);
+  }
+}
+
+void ShowSaveDialog(const std::string& title,
+                    const base::FilePath& default_path,
+                    const file_dialog::Filters& filters,
+                    electron::NativeWindow* window,
+                    mate::Arguments* args) {
+  v8::Local<v8::Value> peek = args->PeekNext();
+  file_dialog::SaveDialogCallback callback;
+  if (mate::Converter<file_dialog::SaveDialogCallback>::FromV8(args->isolate(),
+                                                               peek,
+                                                               &callback)) {
+    file_dialog::ShowSaveDialog(window, title, default_path, filters, callback);
+  } else {
+    base::FilePath path;
+    if (file_dialog::ShowSaveDialog(window, title, default_path, filters,
+                                    &path))
+      args->Return(path);
+  }
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("showMessageBox", &ShowMessageBox);
+  dict.SetMethod("showErrorBox", &electron::ShowErrorBox);
+  dict.SetMethod("showOpenDialog", &ShowOpenDialog);
+  dict.SetMethod("showSaveDialog", &ShowSaveDialog);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_dialog, Initialize)
added in remote
  their  100644 7e6db9f7152cbe1c1e7f83d8c649eafdc2796ba6 electron/browser/api/electron_api_download_item.cc
@@ -0,0 +1,212 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_download_item.h"
+
+#include <map>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/memory/linked_ptr.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "native_mate/dictionary.h"
+#include "net/base/filename_util.h"
+
+namespace mate {
+
+template<>
+struct Converter<content::DownloadItem::DownloadState> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::DownloadItem::DownloadState state) {
+    std::string download_state;
+    switch (state) {
+      case content::DownloadItem::COMPLETE:
+        download_state = "completed";
+        break;
+      case content::DownloadItem::CANCELLED:
+        download_state = "cancelled";
+        break;
+      case content::DownloadItem::INTERRUPTED:
+        download_state = "interrupted";
+        break;
+      default:
+        break;
+    }
+    return ConvertToV8(isolate, download_state);
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapDownloadItem funtion which is implemented in JavaScript
+using WrapDownloadItemCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapDownloadItemCallback g_wrap_download_item;
+
+std::map<uint32_t, linked_ptr<v8::Global<v8::Value>>> g_download_item_objects;
+
+}  // namespace
+
+DownloadItem::DownloadItem(content::DownloadItem* download_item)
+    : download_item_(download_item) {
+  download_item_->AddObserver(this);
+  AttachAsUserData(download_item);
+}
+
+DownloadItem::~DownloadItem() {
+  if (download_item_) {
+    // Destroyed by either garbage collection or destroy().
+    download_item_->RemoveObserver(this);
+    download_item_->Remove();
+  }
+
+  // Remove from the global map.
+  auto iter = g_download_item_objects.find(weak_map_id());
+  if (iter != g_download_item_objects.end())
+    g_download_item_objects.erase(iter);
+}
+
+void DownloadItem::OnDownloadUpdated(content::DownloadItem* item) {
+  if (download_item_->IsDone()) {
+    Emit("done", item->GetState());
+
+    // Destroy the item once item is downloaded.
+    base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+  } else {
+    Emit("updated");
+  }
+}
+
+void DownloadItem::OnDownloadDestroyed(content::DownloadItem* download_item) {
+  download_item_ = nullptr;
+  // Destroy the native class immediately when downloadItem is destroyed.
+  delete this;
+}
+
+void DownloadItem::Pause() {
+  download_item_->Pause();
+}
+
+void DownloadItem::Resume() {
+  download_item_->Resume();
+}
+
+void DownloadItem::Cancel() {
+  download_item_->Cancel(true);
+  download_item_->Remove();
+}
+
+int64_t DownloadItem::GetReceivedBytes() const {
+  return download_item_->GetReceivedBytes();
+}
+
+int64_t DownloadItem::GetTotalBytes() const {
+  return download_item_->GetTotalBytes();
+}
+
+std::string DownloadItem::GetMimeType() const {
+  return download_item_->GetMimeType();
+}
+
+bool DownloadItem::HasUserGesture() const {
+  return download_item_->HasUserGesture();
+}
+
+std::string DownloadItem::GetFilename() const {
+  return base::UTF16ToUTF8(net::GenerateFileName(GetURL(),
+                           GetContentDisposition(),
+                           std::string(),
+                           download_item_->GetSuggestedFilename(),
+                           GetMimeType(),
+                           std::string()).LossyDisplayName());
+}
+
+std::string DownloadItem::GetContentDisposition() const {
+  return download_item_->GetContentDisposition();
+}
+
+const GURL& DownloadItem::GetURL() const {
+  return download_item_->GetURL();
+}
+
+void DownloadItem::SetSavePath(const base::FilePath& path) {
+  save_path_ = path;
+}
+
+base::FilePath DownloadItem::GetSavePath() const {
+  return save_path_;
+}
+
+// static
+void DownloadItem::BuildPrototype(v8::Isolate* isolate,
+                                  v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("pause", &DownloadItem::Pause)
+      .SetMethod("resume", &DownloadItem::Resume)
+      .SetMethod("cancel", &DownloadItem::Cancel)
+      .SetMethod("getReceivedBytes", &DownloadItem::GetReceivedBytes)
+      .SetMethod("getTotalBytes", &DownloadItem::GetTotalBytes)
+      .SetMethod("getMimeType", &DownloadItem::GetMimeType)
+      .SetMethod("hasUserGesture", &DownloadItem::HasUserGesture)
+      .SetMethod("getFilename", &DownloadItem::GetFilename)
+      .SetMethod("getContentDisposition", &DownloadItem::GetContentDisposition)
+      .SetMethod("getURL", &DownloadItem::GetURL)
+      .SetMethod("setSavePath", &DownloadItem::SetSavePath)
+      .SetMethod("getSavePath", &DownloadItem::GetSavePath);
+}
+
+// static
+mate::Handle<DownloadItem> DownloadItem::Create(
+    v8::Isolate* isolate, content::DownloadItem* item) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, item);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<DownloadItem*>(existing));
+
+  auto handle = mate::CreateHandle(isolate, new DownloadItem(item));
+  g_wrap_download_item.Run(handle.ToV8());
+
+  // Reference this object in case it got garbage collected.
+  g_download_item_objects[handle->weak_map_id()] = make_linked_ptr(
+      new v8::Global<v8::Value>(isolate, handle.ToV8()));
+  return handle;
+}
+
+void ClearWrapDownloadItem() {
+  g_wrap_download_item.Reset();
+}
+
+void SetWrapDownloadItem(const WrapDownloadItemCallback& callback) {
+  g_wrap_download_item = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapDownloadItem));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("_setWrapDownloadItem", &electron::api::SetWrapDownloadItem);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_download_item, Initialize);
added in remote
  their  100644 d9afc825c22553224e5865f7171bbfc490cb3f78 electron/browser/api/electron_api_download_item.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/files/file_path.h"
+#include "content/public/browser/download_item.h"
+#include "native_mate/handle.h"
+#include "url/gurl.h"
+
+namespace electron {
+
+namespace api {
+
+class DownloadItem : public mate::TrackableObject<DownloadItem>,
+                     public content::DownloadItem::Observer {
+ public:
+  static mate::Handle<DownloadItem> Create(v8::Isolate* isolate,
+                                           content::DownloadItem* item);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+  void Pause();
+  void Resume();
+  void Cancel();
+  int64_t GetReceivedBytes() const;
+  int64_t GetTotalBytes() const;
+  std::string GetMimeType() const;
+  bool HasUserGesture() const;
+  std::string GetFilename() const;
+  std::string GetContentDisposition() const;
+  const GURL& GetURL() const;
+  void SetSavePath(const base::FilePath& path);
+  base::FilePath GetSavePath() const;
+
+ protected:
+  explicit DownloadItem(content::DownloadItem* download_item);
+  ~DownloadItem();
+
+  // Override content::DownloadItem::Observer methods
+  void OnDownloadUpdated(content::DownloadItem* download) override;
+  void OnDownloadDestroyed(content::DownloadItem* download) override;
+
+ private:
+  base::FilePath save_path_;
+  content::DownloadItem* download_item_;
+
+  DISALLOW_COPY_AND_ASSIGN(DownloadItem);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_DOWNLOAD_ITEM_H_
added in remote
  their  100644 d2be70b1a5f282279671d8864f864e9712bcb955 electron/browser/api/electron_api_global_shortcut.cc
@@ -0,0 +1,98 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_global_shortcut.h"
+
+#include <string>
+
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "base/stl_util.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+using extensions::GlobalShortcutListener;
+
+namespace electron {
+
+namespace api {
+
+GlobalShortcut::GlobalShortcut() {
+}
+
+GlobalShortcut::~GlobalShortcut() {
+  UnregisterAll();
+}
+
+void GlobalShortcut::OnKeyPressed(const ui::Accelerator& accelerator) {
+  if (accelerator_callback_map_.find(accelerator) ==
+      accelerator_callback_map_.end()) {
+    // This should never occur, because if it does, GlobalGlobalShortcutListener
+    // notifes us with wrong accelerator.
+    NOTREACHED();
+    return;
+  }
+  accelerator_callback_map_[accelerator].Run();
+}
+
+bool GlobalShortcut::Register(const ui::Accelerator& accelerator,
+                              const base::Closure& callback) {
+  if (!GlobalShortcutListener::GetInstance()->RegisterAccelerator(
+      accelerator, this)) {
+    return false;
+  }
+
+  accelerator_callback_map_[accelerator] = callback;
+  return true;
+}
+
+void GlobalShortcut::Unregister(const ui::Accelerator& accelerator) {
+  if (!ContainsKey(accelerator_callback_map_, accelerator))
+    return;
+
+  accelerator_callback_map_.erase(accelerator);
+  GlobalShortcutListener::GetInstance()->UnregisterAccelerator(
+      accelerator, this);
+}
+
+bool GlobalShortcut::IsRegistered(const ui::Accelerator& accelerator) {
+  return ContainsKey(accelerator_callback_map_, accelerator);
+}
+
+void GlobalShortcut::UnregisterAll() {
+  accelerator_callback_map_.clear();
+  GlobalShortcutListener::GetInstance()->UnregisterAccelerators(this);
+}
+
+mate::ObjectTemplateBuilder GlobalShortcut::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("register", &GlobalShortcut::Register)
+      .SetMethod("isRegistered", &GlobalShortcut::IsRegistered)
+      .SetMethod("unregister", &GlobalShortcut::Unregister)
+      .SetMethod("unregisterAll", &GlobalShortcut::UnregisterAll);
+}
+
+// static
+mate::Handle<GlobalShortcut> GlobalShortcut::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new GlobalShortcut);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("globalShortcut", electron::api::GlobalShortcut::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_global_shortcut, Initialize)
added in remote
  their  100644 48021f8fd15833886e717d0fc435e5428a78b9a4 electron/browser/api/electron_api_global_shortcut.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
+
+#include <map>
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/callback.h"
+#include "chrome/browser/extensions/global_shortcut_listener.h"
+#include "native_mate/handle.h"
+#include "ui/base/accelerators/accelerator.h"
+
+namespace electron {
+
+namespace api {
+
+class GlobalShortcut : public extensions::GlobalShortcutListener::Observer,
+                       public mate::TrackableObject<GlobalShortcut> {
+ public:
+  static mate::Handle<GlobalShortcut> Create(v8::Isolate* isolate);
+
+ protected:
+  GlobalShortcut();
+  ~GlobalShortcut() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  typedef std::map<ui::Accelerator, base::Closure> AcceleratorCallbackMap;
+
+  bool Register(const ui::Accelerator& accelerator,
+                const base::Closure& callback);
+  bool IsRegistered(const ui::Accelerator& accelerator);
+  void Unregister(const ui::Accelerator& accelerator);
+  void UnregisterAll();
+
+  // GlobalShortcutListener::Observer implementation.
+  void OnKeyPressed(const ui::Accelerator& accelerator) override;
+
+  AcceleratorCallbackMap accelerator_callback_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalShortcut);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_GLOBAL_SHORTCUT_H_
added in remote
  their  100644 6e2a3c3f80f176e7673b12b7d44640419db149de electron/browser/api/electron_api_menu.cc
@@ -0,0 +1,199 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_menu.h"
+
+#include "electron/browser/native_window.h"
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+Menu::Menu()
+    : model_(new ElectronMenuModel(this)),
+      parent_(NULL) {
+}
+
+Menu::~Menu() {
+}
+
+void Menu::AfterInit(v8::Isolate* isolate) {
+  mate::Dictionary wrappable(isolate, GetWrapper(isolate));
+  mate::Dictionary delegate;
+  if (!wrappable.Get("delegate", &delegate))
+    return;
+
+  delegate.Get("isCommandIdChecked", &is_checked_);
+  delegate.Get("isCommandIdEnabled", &is_enabled_);
+  delegate.Get("isCommandIdVisible", &is_visible_);
+  delegate.Get("getAcceleratorForCommandId", &get_accelerator_);
+  delegate.Get("executeCommand", &execute_command_);
+  delegate.Get("menuWillShow", &menu_will_show_);
+}
+
+bool Menu::IsCommandIdChecked(int command_id) const {
+  return is_checked_.Run(command_id);
+}
+
+bool Menu::IsCommandIdEnabled(int command_id) const {
+  return is_enabled_.Run(command_id);
+}
+
+bool Menu::IsCommandIdVisible(int command_id) const {
+  return is_visible_.Run(command_id);
+}
+
+bool Menu::GetAcceleratorForCommandId(int command_id,
+                                      ui::Accelerator* accelerator) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  v8::Local<v8::Value> val = get_accelerator_.Run(command_id);
+  return mate::ConvertFromV8(isolate(), val, accelerator);
+}
+
+void Menu::ExecuteCommand(int command_id, int event_flags) {
+  execute_command_.Run(command_id);
+}
+
+void Menu::MenuWillShow(ui::SimpleMenuModel* source) {
+  menu_will_show_.Run();
+}
+
+void Menu::InsertItemAt(
+    int index, int command_id, const base::string16& label) {
+  model_->InsertItemAt(index, command_id, label);
+}
+
+void Menu::InsertSeparatorAt(int index) {
+  model_->InsertSeparatorAt(index, ui::NORMAL_SEPARATOR);
+}
+
+void Menu::InsertCheckItemAt(int index,
+                             int command_id,
+                             const base::string16& label) {
+  model_->InsertCheckItemAt(index, command_id, label);
+}
+
+void Menu::InsertRadioItemAt(int index,
+                             int command_id,
+                             const base::string16& label,
+                             int group_id) {
+  model_->InsertRadioItemAt(index, command_id, label, group_id);
+}
+
+void Menu::InsertSubMenuAt(int index,
+                           int command_id,
+                           const base::string16& label,
+                           Menu* menu) {
+  menu->parent_ = this;
+  model_->InsertSubMenuAt(index, command_id, label, menu->model_.get());
+}
+
+void Menu::SetIcon(int index, const gfx::Image& image) {
+  model_->SetIcon(index, image);
+}
+
+void Menu::SetSublabel(int index, const base::string16& sublabel) {
+  model_->SetSublabel(index, sublabel);
+}
+
+void Menu::SetRole(int index, const base::string16& role) {
+  model_->SetRole(index, role);
+}
+
+void Menu::Clear() {
+  model_->Clear();
+}
+
+int Menu::GetIndexOfCommandId(int command_id) {
+  return model_->GetIndexOfCommandId(command_id);
+}
+
+int Menu::GetItemCount() const {
+  return model_->GetItemCount();
+}
+
+int Menu::GetCommandIdAt(int index) const {
+  return model_->GetCommandIdAt(index);
+}
+
+base::string16 Menu::GetLabelAt(int index) const {
+  return model_->GetLabelAt(index);
+}
+
+base::string16 Menu::GetSublabelAt(int index) const {
+  return model_->GetSublabelAt(index);
+}
+
+bool Menu::IsItemCheckedAt(int index) const {
+  return model_->IsItemCheckedAt(index);
+}
+
+bool Menu::IsEnabledAt(int index) const {
+  return model_->IsEnabledAt(index);
+}
+
+bool Menu::IsVisibleAt(int index) const {
+  return model_->IsVisibleAt(index);
+}
+
+// static
+void Menu::BuildPrototype(v8::Isolate* isolate,
+                          v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("insertItem", &Menu::InsertItemAt)
+      .SetMethod("insertCheckItem", &Menu::InsertCheckItemAt)
+      .SetMethod("insertRadioItem", &Menu::InsertRadioItemAt)
+      .SetMethod("insertSeparator", &Menu::InsertSeparatorAt)
+      .SetMethod("insertSubMenu", &Menu::InsertSubMenuAt)
+      .SetMethod("setIcon", &Menu::SetIcon)
+      .SetMethod("setSublabel", &Menu::SetSublabel)
+      .SetMethod("setRole", &Menu::SetRole)
+      .SetMethod("clear", &Menu::Clear)
+      .SetMethod("getIndexOfCommandId", &Menu::GetIndexOfCommandId)
+      .SetMethod("getItemCount", &Menu::GetItemCount)
+      .SetMethod("getCommandIdAt", &Menu::GetCommandIdAt)
+      .SetMethod("getLabelAt", &Menu::GetLabelAt)
+      .SetMethod("getSublabelAt", &Menu::GetSublabelAt)
+      .SetMethod("isItemCheckedAt", &Menu::IsItemCheckedAt)
+      .SetMethod("isEnabledAt", &Menu::IsEnabledAt)
+      .SetMethod("isVisibleAt", &Menu::IsVisibleAt)
+      .SetMethod("popupAt", &Menu::PopupAt);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  using electron::api::Menu;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Menu>(
+      isolate, "Menu", base::Bind(&Menu::Create));
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("Menu", static_cast<v8::Local<v8::Value>>(constructor));
+#if defined(OS_MACOSX)
+  dict.SetMethod("setApplicationMenu", &Menu::SetApplicationMenu);
+  dict.SetMethod("sendActionToFirstResponder",
+                 &Menu::SendActionToFirstResponder);
+#endif
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_menu, Initialize)
added in remote
  their  100644 91ecb49688edb4df91d2741681156b10aa2452ad electron/browser/api/electron_api_menu.h
@@ -0,0 +1,126 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
+
+#include <string>
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/ui/electron_menu_model.h"
+#include "base/callback.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace electron {
+
+namespace api {
+
+class Menu : public mate::TrackableObject<Menu>,
+             public ElectronMenuModel::Delegate {
+ public:
+  static mate::Wrappable* Create();
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+#if defined(OS_MACOSX)
+  // Set the global menubar.
+  static void SetApplicationMenu(Menu* menu);
+
+  // Fake sending an action from the application menu.
+  static void SendActionToFirstResponder(const std::string& action);
+#endif
+
+  ElectronMenuModel* model() const { return model_.get(); }
+
+ protected:
+  Menu();
+  ~Menu() override;
+
+  // mate::Wrappable:
+  void AfterInit(v8::Isolate* isolate) override;
+
+  // ui::SimpleMenuModel::Delegate:
+  bool IsCommandIdChecked(int command_id) const override;
+  bool IsCommandIdEnabled(int command_id) const override;
+  bool IsCommandIdVisible(int command_id) const override;
+  bool GetAcceleratorForCommandId(int command_id,
+                                  ui::Accelerator* accelerator) override;
+  void ExecuteCommand(int command_id, int event_flags) override;
+  void MenuWillShow(ui::SimpleMenuModel* source) override;
+
+  virtual void PopupAt(Window* window,
+                       int x = -1, int y = -1,
+                       int positioning_item = 0) = 0;
+
+  scoped_ptr<ElectronMenuModel> model_;
+  Menu* parent_;
+
+ private:
+  void InsertItemAt(int index, int command_id, const base::string16& label);
+  void InsertSeparatorAt(int index);
+  void InsertCheckItemAt(int index,
+                         int command_id,
+                         const base::string16& label);
+  void InsertRadioItemAt(int index,
+                         int command_id,
+                         const base::string16& label,
+                         int group_id);
+  void InsertSubMenuAt(int index,
+                       int command_id,
+                       const base::string16& label,
+                       Menu* menu);
+  void SetIcon(int index, const gfx::Image& image);
+  void SetSublabel(int index, const base::string16& sublabel);
+  void SetRole(int index, const base::string16& role);
+  void Clear();
+  int GetIndexOfCommandId(int command_id);
+  int GetItemCount() const;
+  int GetCommandIdAt(int index) const;
+  base::string16 GetLabelAt(int index) const;
+  base::string16 GetSublabelAt(int index) const;
+  bool IsItemCheckedAt(int index) const;
+  bool IsEnabledAt(int index) const;
+  bool IsVisibleAt(int index) const;
+
+  // Stored delegate methods.
+  base::Callback<bool(int)> is_checked_;
+  base::Callback<bool(int)> is_enabled_;
+  base::Callback<bool(int)> is_visible_;
+  base::Callback<v8::Local<v8::Value>(int)> get_accelerator_;
+  base::Callback<void(int)> execute_command_;
+  base::Callback<void()> menu_will_show_;
+
+  DISALLOW_COPY_AND_ASSIGN(Menu);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace mate {
+
+template<>
+struct Converter<electron::ElectronMenuModel*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     electron::ElectronMenuModel** out) {
+    // null would be tranfered to NULL.
+    if (val->IsNull()) {
+      *out = nullptr;
+      return true;
+    }
+
+    electron::api::Menu* menu;
+    if (!Converter<electron::api::Menu*>::FromV8(isolate, val, &menu))
+      return false;
+    *out = menu->model();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_H_
added in remote
  their  100644 73bcdfb949a28820a28c0a4112474125e2e996a9 electron/browser/api/electron_api_menu_mac.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
+
+#include "electron/browser/api/electron_api_menu.h"
+
+#include <string>
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+namespace electron {
+
+namespace api {
+
+class MenuMac : public Menu {
+ protected:
+  MenuMac();
+
+  void PopupAt(Window* window, int x, int y, int positioning_item = 0) override;
+
+  base::scoped_nsobject<ElectronMenuController> menu_controller_;
+
+ private:
+  friend class Menu;
+
+  static void SendActionToFirstResponder(const std::string& action);
+
+  DISALLOW_COPY_AND_ASSIGN(MenuMac);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_MAC_H_
added in remote
  their  100644 9999b30b934569227fc9a4d9eb11ca33bdd13126 electron/browser/api/electron_api_menu_mac.mm
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/api/electron_api_menu_mac.h"
+
+#include "electron/browser/native_window.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/sys_string_conversions.h"
+#include "content/public/browser/web_contents.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+MenuMac::MenuMac() {
+}
+
+void MenuMac::PopupAt(Window* window, int x, int y, int positioning_item) {
+  NativeWindow* native_window = window->window();
+  if (!native_window)
+    return;
+  content::WebContents* web_contents = native_window->web_contents();
+  if (!web_contents)
+    return;
+
+  base::scoped_nsobject<ElectronMenuController> menu_controller(
+      [[ElectronMenuController alloc] initWithModel:model_.get()]);
+  NSMenu* menu = [menu_controller menu];
+  NSView* view = web_contents->GetContentNativeView();
+
+  // Which menu item to show.
+  NSMenuItem* item = nil;
+  if (positioning_item < [menu numberOfItems] && positioning_item >= 0)
+    item = [menu itemAtIndex:positioning_item];
+
+  // (-1, -1) means showing on mouse location.
+  NSPoint position;
+  if (x == -1 || y == -1) {
+    NSWindow* nswindow = native_window->GetNativeWindow();
+    position = [view convertPoint:[nswindow mouseLocationOutsideOfEventStream]
+                         fromView:nil];
+  } else {
+    position = NSMakePoint(x, [view frame].size.height - y);
+  }
+
+  // Show the menu.
+  [menu popUpMenuPositioningItem:item atLocation:position inView:view];
+}
+
+// static
+void Menu::SetApplicationMenu(Menu* base_menu) {
+  MenuMac* menu = static_cast<MenuMac*>(base_menu);
+  base::scoped_nsobject<ElectronMenuController> menu_controller(
+      [[ElectronMenuController alloc] initWithModel:menu->model_.get()]);
+  [NSApp setMainMenu:[menu_controller menu]];
+
+  // Ensure the menu_controller_ is destroyed after main menu is set.
+  menu_controller.swap(menu->menu_controller_);
+}
+
+// static
+void Menu::SendActionToFirstResponder(const std::string& action) {
+  SEL selector = NSSelectorFromString(base::SysUTF8ToNSString(action));
+  [NSApp sendAction:selector to:nil from:[NSApp mainMenu]];
+}
+
+// static
+mate::Wrappable* Menu::Create() {
+  return new MenuMac();
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 1efa598d415ca0a311cae33e1ac80e1fdf28a1ea electron/browser/api/electron_api_menu_views.cc
@@ -0,0 +1,58 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_menu_views.h"
+
+#include "electron/browser/native_window_views.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "ui/gfx/screen.h"
+#include "ui/views/controls/menu/menu_runner.h"
+
+namespace electron {
+
+namespace api {
+
+MenuViews::MenuViews() {
+}
+
+void MenuViews::PopupAt(Window* window, int x, int y, int positioning_item) {
+  NativeWindow* native_window = static_cast<NativeWindow*>(window->window());
+  if (!native_window)
+    return;
+  content::WebContents* web_contents = native_window->web_contents();
+  if (!web_contents)
+    return;
+  content::RenderWidgetHostView* view = web_contents->GetRenderWidgetHostView();
+  if (!view)
+    return;
+
+  // (-1, -1) means showing on mouse location.
+  gfx::Point location;
+  if (x == -1 || y == -1) {
+    location = gfx::Screen::GetNativeScreen()->GetCursorScreenPoint();
+  } else {
+    gfx::Point origin = view->GetViewBounds().origin();
+    location = gfx::Point(origin.x() + x, origin.y() + y);
+  }
+
+  // Show the menu.
+  views::MenuRunner menu_runner(
+      model(),
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS);
+  ignore_result(menu_runner.RunMenuAt(
+      static_cast<NativeWindowViews*>(window->window())->widget(),
+      NULL,
+      gfx::Rect(location, gfx::Size()),
+      views::MENU_ANCHOR_TOPLEFT,
+      ui::MENU_SOURCE_MOUSE));
+}
+
+// static
+mate::Wrappable* Menu::Create() {
+  return new MenuViews();
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 be42d0abb557e067d4c17dfa74e30330084238d8 electron/browser/api/electron_api_menu_views.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "ui/gfx/screen.h"
+
+namespace electron {
+
+namespace api {
+
+class MenuViews : public Menu {
+ public:
+  MenuViews();
+
+ protected:
+  void PopupAt(Window* window, int x, int y, int positioning_item = 0) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MenuViews);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_MENU_VIEWS_H_
added in remote
  their  100644 84fd7a55e005b81d4fa89a6edf2cd09580e1be43 electron/browser/api/electron_api_power_monitor.cc
@@ -0,0 +1,73 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_power_monitor.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/node_includes.h"
+#include "base/power_monitor/power_monitor.h"
+#include "base/power_monitor/power_monitor_device_source.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace api {
+
+PowerMonitor::PowerMonitor() {
+  base::PowerMonitor::Get()->AddObserver(this);
+}
+
+PowerMonitor::~PowerMonitor() {
+  base::PowerMonitor::Get()->RemoveObserver(this);
+}
+
+void PowerMonitor::OnPowerStateChange(bool on_battery_power) {
+  if (on_battery_power)
+    Emit("on-battery");
+  else
+    Emit("on-ac");
+}
+
+void PowerMonitor::OnSuspend() {
+  Emit("suspend");
+}
+
+void PowerMonitor::OnResume() {
+  Emit("resume");
+}
+
+// static
+v8::Local<v8::Value> PowerMonitor::Create(v8::Isolate* isolate) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate,
+        "Cannot initialize \"power-monitor\" module before app is ready")));
+    return v8::Null(isolate);
+  }
+
+  return CreateHandle(isolate, new PowerMonitor).ToV8();
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+#if defined(OS_MACOSX)
+  base::PowerMonitorDeviceSource::AllocateSystemIOPorts();
+#endif
+
+  using electron::api::PowerMonitor;
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("powerMonitor", PowerMonitor::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_power_monitor, Initialize)
added in remote
  their  100644 1ed381df5b42bdea0c280a425895f8a294ac5271 electron/browser/api/electron_api_power_monitor.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/compiler_specific.h"
+#include "base/power_monitor/power_observer.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class PowerMonitor : public mate::TrackableObject<PowerMonitor>,
+                     public base::PowerObserver {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
+
+ protected:
+  PowerMonitor();
+  ~PowerMonitor() override;
+
+  // base::PowerObserver implementations:
+  void OnPowerStateChange(bool on_battery_power) override;
+  void OnSuspend() override;
+  void OnResume() override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(PowerMonitor);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_POWER_MONITOR_H_
added in remote
  their  100644 eb422da50a2f613bd41f18cde438a6028d15c992 electron/browser/api/electron_api_power_save_blocker.cc
@@ -0,0 +1,128 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_power_save_blocker.h"
+
+#include <string>
+
+#include "electron/common/node_includes.h"
+#include "content/public/browser/power_save_blocker.h"
+#include "native_mate/dictionary.h"
+
+namespace mate {
+
+template<>
+struct Converter<content::PowerSaveBlocker::PowerSaveBlockerType> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     content::PowerSaveBlocker::PowerSaveBlockerType* out) {
+    using content::PowerSaveBlocker;
+    std::string type;
+    if (!ConvertFromV8(isolate, val, &type))
+      return false;
+    if (type == "prevent-app-suspension")
+      *out = PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension;
+    else if (type == "prevent-display-sleep")
+      *out = PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep;
+    else
+      return false;
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+PowerSaveBlocker::PowerSaveBlocker()
+    : current_blocker_type_(
+        content::PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension) {
+}
+
+PowerSaveBlocker::~PowerSaveBlocker() {
+}
+
+void PowerSaveBlocker::UpdatePowerSaveBlocker() {
+  if (power_save_blocker_types_.empty()) {
+    power_save_blocker_.reset();
+    return;
+  }
+
+  // |kPowerSaveBlockPreventAppSuspension| keeps system active, but allows
+  // screen to be turned off.
+  // |kPowerSaveBlockPreventDisplaySleep| keeps system and screen active, has a
+  // higher precedence level than |kPowerSaveBlockPreventAppSuspension|.
+  //
+  // Only the highest-precedence blocker type takes effect.
+  content::PowerSaveBlocker::PowerSaveBlockerType new_blocker_type =
+      content::PowerSaveBlocker::kPowerSaveBlockPreventAppSuspension;
+  for (const auto& element : power_save_blocker_types_) {
+    if (element.second ==
+        content::PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep) {
+      new_blocker_type =
+          content::PowerSaveBlocker::kPowerSaveBlockPreventDisplaySleep;
+      break;
+    }
+  }
+
+  if (!power_save_blocker_ || new_blocker_type != current_blocker_type_) {
+    scoped_ptr<content::PowerSaveBlocker> new_blocker =
+        content::PowerSaveBlocker::Create(
+            new_blocker_type,
+            content::PowerSaveBlocker::kReasonOther,
+            ELECTRON_PRODUCT_NAME);
+    power_save_blocker_.swap(new_blocker);
+    current_blocker_type_ = new_blocker_type;
+  }
+}
+
+int PowerSaveBlocker::Start(
+    content::PowerSaveBlocker::PowerSaveBlockerType type) {
+  static int count = 0;
+  power_save_blocker_types_[count] = type;
+  UpdatePowerSaveBlocker();
+  return count++;
+}
+
+bool PowerSaveBlocker::Stop(int id) {
+  bool success = power_save_blocker_types_.erase(id) > 0;
+  UpdatePowerSaveBlocker();
+  return success;
+}
+
+bool PowerSaveBlocker::IsStarted(int id) {
+  return power_save_blocker_types_.find(id) != power_save_blocker_types_.end();
+}
+
+mate::ObjectTemplateBuilder PowerSaveBlocker::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("start", &PowerSaveBlocker::Start)
+      .SetMethod("stop", &PowerSaveBlocker::Stop)
+      .SetMethod("isStarted", &PowerSaveBlocker::IsStarted);
+}
+
+// static
+mate::Handle<PowerSaveBlocker> PowerSaveBlocker::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new PowerSaveBlocker);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("powerSaveBlocker", electron::api::PowerSaveBlocker::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_power_save_blocker, Initialize);
added in remote
  their  100644 484913d4cacec1f5239300e895ea16668af7fae0 electron/browser/api/electron_api_power_save_blocker.h
@@ -0,0 +1,58 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
+
+#include <map>
+
+#include "electron/browser/api/trackable_object.h"
+#include "base/memory/scoped_ptr.h"
+#include "content/public/browser/power_save_blocker.h"
+#include "native_mate/handle.h"
+
+namespace mate {
+class Dictionary;
+}
+
+namespace electron {
+
+namespace api {
+
+class PowerSaveBlocker : public mate::TrackableObject<PowerSaveBlocker> {
+ public:
+  static mate::Handle<PowerSaveBlocker> Create(v8::Isolate* isolate);
+
+ protected:
+  PowerSaveBlocker();
+  ~PowerSaveBlocker() override;
+
+  // mate::Wrappable implementations:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  void UpdatePowerSaveBlocker();
+  int Start(content::PowerSaveBlocker::PowerSaveBlockerType type);
+  bool Stop(int id);
+  bool IsStarted(int id);
+
+  scoped_ptr<content::PowerSaveBlocker> power_save_blocker_;
+
+  // Currnet blocker type used by |power_save_blocker_|
+  content::PowerSaveBlocker::PowerSaveBlockerType current_blocker_type_;
+
+  // Map from id to the corresponding blocker type for each request.
+  using PowerSaveBlockerTypeMap =
+      std::map<int, content::PowerSaveBlocker::PowerSaveBlockerType>;
+  PowerSaveBlockerTypeMap power_save_blocker_types_;
+
+  DISALLOW_COPY_AND_ASSIGN(PowerSaveBlocker);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_POWER_SAVE_BLOCKER_H_
added in remote
  their  100644 41fc5eadff2ca01963bea12f6f8381d98c85fd62 electron/browser/api/electron_api_protocol.cc
@@ -0,0 +1,173 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_protocol.h"
+
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/net/url_request_async_asar_job.h"
+#include "electron/browser/net/url_request_buffer_job.h"
+#include "electron/browser/net/url_request_fetch_job.h"
+#include "electron/browser/net/url_request_string_job.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace api {
+
+Protocol::Protocol(ElectronBrowserContext* browser_context)
+    : request_context_getter_(browser_context->GetRequestContext()),
+      job_factory_(browser_context->job_factory()) {
+  CHECK(job_factory_);
+}
+
+mate::ObjectTemplateBuilder Protocol::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("registerStandardSchemes", &Protocol::RegisterStandardSchemes)
+      .SetMethod("registerServiceWorkerSchemes",
+                 &Protocol::RegisterServiceWorkerSchemes)
+      .SetMethod("registerStringProtocol",
+                 &Protocol::RegisterProtocol<URLRequestStringJob>)
+      .SetMethod("registerBufferProtocol",
+                 &Protocol::RegisterProtocol<URLRequestBufferJob>)
+      .SetMethod("registerFileProtocol",
+                 &Protocol::RegisterProtocol<URLRequestAsyncAsarJob>)
+      .SetMethod("registerHttpProtocol",
+                 &Protocol::RegisterProtocol<URLRequestFetchJob>)
+      .SetMethod("unregisterProtocol", &Protocol::UnregisterProtocol)
+      .SetMethod("isProtocolHandled", &Protocol::IsProtocolHandled)
+      .SetMethod("interceptStringProtocol",
+                 &Protocol::InterceptProtocol<URLRequestStringJob>)
+      .SetMethod("interceptBufferProtocol",
+                 &Protocol::InterceptProtocol<URLRequestBufferJob>)
+      .SetMethod("interceptFileProtocol",
+                 &Protocol::InterceptProtocol<URLRequestAsyncAsarJob>)
+      .SetMethod("interceptHttpProtocol",
+                 &Protocol::InterceptProtocol<URLRequestFetchJob>)
+      .SetMethod("uninterceptProtocol", &Protocol::UninterceptProtocol);
+}
+
+void Protocol::RegisterStandardSchemes(
+    const std::vector<std::string>& schemes) {
+  electron::ElectronBrowserClient::SetCustomSchemes(schemes);
+}
+
+void Protocol::RegisterServiceWorkerSchemes(
+    const std::vector<std::string>& schemes) {
+  electron::ElectronBrowserClient::SetCustomServiceWorkerSchemes(schemes);
+}
+
+void Protocol::UnregisterProtocol(
+    const std::string& scheme, mate::Arguments* args) {
+  CompletionCallback callback;
+  args->GetNext(&callback);
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::UnregisterProtocolInIO,
+                 base::Unretained(this), scheme),
+      base::Bind(&Protocol::OnIOCompleted,
+                 base::Unretained(this), callback));
+}
+
+Protocol::ProtocolError Protocol::UnregisterProtocolInIO(
+    const std::string& scheme) {
+  if (!job_factory_->HasProtocolHandler(scheme))
+    return PROTOCOL_NOT_REGISTERED;
+  job_factory_->SetProtocolHandler(scheme, nullptr);
+  return PROTOCOL_OK;
+}
+
+void Protocol::IsProtocolHandled(const std::string& scheme,
+                                    const BooleanCallback& callback) {
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::IsProtocolHandledInIO,
+                 base::Unretained(this), scheme),
+      callback);
+}
+
+bool Protocol::IsProtocolHandledInIO(const std::string& scheme) {
+  return job_factory_->IsHandledProtocol(scheme);
+}
+
+void Protocol::UninterceptProtocol(
+    const std::string& scheme, mate::Arguments* args) {
+  CompletionCallback callback;
+  args->GetNext(&callback);
+  content::BrowserThread::PostTaskAndReplyWithResult(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(&Protocol::UninterceptProtocolInIO,
+                 base::Unretained(this), scheme),
+      base::Bind(&Protocol::OnIOCompleted,
+                 base::Unretained(this), callback));
+}
+
+Protocol::ProtocolError Protocol::UninterceptProtocolInIO(
+    const std::string& scheme) {
+  if (!original_protocols_.contains(scheme))
+    return PROTOCOL_NOT_INTERCEPTED;
+  job_factory_->ReplaceProtocol(scheme,
+                                original_protocols_.take_and_erase(scheme));
+  return PROTOCOL_OK;
+}
+
+void Protocol::OnIOCompleted(
+    const CompletionCallback& callback, ProtocolError error) {
+  // The completion callback is optional.
+  if (callback.is_null())
+    return;
+
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+
+  if (error == PROTOCOL_OK) {
+    callback.Run(v8::Null(isolate()));
+  } else {
+    std::string str = ErrorCodeToString(error);
+    callback.Run(v8::Exception::Error(mate::StringToV8(isolate(), str)));
+  }
+}
+
+std::string Protocol::ErrorCodeToString(ProtocolError error) {
+  switch (error) {
+    case PROTOCOL_FAIL: return "Failed to manipulate protocol factory";
+    case PROTOCOL_REGISTERED: return "The scheme has been registred";
+    case PROTOCOL_NOT_REGISTERED: return "The scheme has not been registred";
+    case PROTOCOL_INTERCEPTED: return "The scheme has been intercepted";
+    case PROTOCOL_NOT_INTERCEPTED: return "The scheme has not been intercepted";
+    default: return "Unexpected error";
+  }
+}
+
+// static
+mate::Handle<Protocol> Protocol::Create(
+    v8::Isolate* isolate, ElectronBrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new Protocol(browser_context));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  auto browser_context = static_cast<electron::ElectronBrowserContext*>(
+      electron::ElectronBrowserMainParts::Get()->browser_context());
+  dict.Set("protocol", electron::api::Protocol::Create(isolate, browser_context));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_protocol, Initialize)
added in remote
  their  100644 5962211ea4eb443d84fb3f720d0f9c0ae1c0d715 electron/browser/api/electron_api_protocol.h
@@ -0,0 +1,195 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
+
+#include <string>
+#include <map>
+#include <vector>
+
+#include "electron/browser/net/electron_url_request_job_factory.h"
+#include "base/callback.h"
+#include "base/containers/scoped_ptr_hash_map.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+
+namespace net {
+class URLRequest;
+class URLRequestContextGetter;
+}
+
+namespace electron {
+
+class ElectronBrowserContext;
+class ElectronURLRequestJobFactory;
+
+namespace api {
+
+class Protocol : public mate::Wrappable {
+ public:
+  using Handler =
+      base::Callback<void(const net::URLRequest*, v8::Local<v8::Value>)>;
+  using CompletionCallback = base::Callback<void(v8::Local<v8::Value>)>;
+  using BooleanCallback = base::Callback<void(bool)>;
+
+  static mate::Handle<Protocol> Create(
+      v8::Isolate* isolate, ElectronBrowserContext* browser_context);
+
+ protected:
+  explicit Protocol(ElectronBrowserContext* browser_context);
+
+  // mate::Wrappable implementations:
+  virtual mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate);
+
+ private:
+  // Possible errors.
+  enum ProtocolError {
+    PROTOCOL_OK,  // no error
+    PROTOCOL_FAIL,  // operation failed, should never occur
+    PROTOCOL_REGISTERED,
+    PROTOCOL_NOT_REGISTERED,
+    PROTOCOL_INTERCEPTED,
+    PROTOCOL_NOT_INTERCEPTED,
+  };
+
+  // The protocol handler that will create a protocol handler for certain
+  // request job.
+  template<typename RequestJob>
+  class CustomProtocolHandler
+      : public net::URLRequestJobFactory::ProtocolHandler {
+   public:
+    CustomProtocolHandler(
+        v8::Isolate* isolate,
+        net::URLRequestContextGetter* request_context,
+        const Handler& handler)
+        : isolate_(isolate),
+          request_context_(request_context),
+          handler_(handler) {}
+    ~CustomProtocolHandler() override {}
+
+    net::URLRequestJob* MaybeCreateJob(
+        net::URLRequest* request,
+        net::NetworkDelegate* network_delegate) const override {
+      RequestJob* request_job = new RequestJob(request, network_delegate);
+      request_job->SetHandlerInfo(isolate_, request_context_, handler_);
+      return request_job;
+    }
+
+   private:
+    v8::Isolate* isolate_;
+    net::URLRequestContextGetter* request_context_;
+    Protocol::Handler handler_;
+
+    DISALLOW_COPY_AND_ASSIGN(CustomProtocolHandler);
+  };
+
+  // Register schemes to standard scheme list.
+  void RegisterStandardSchemes(const std::vector<std::string>& schemes);
+
+  // Register schemes that can handle service worker.
+  void RegisterServiceWorkerSchemes(const std::vector<std::string>& schemes);
+
+  // Register the protocol with certain request job.
+  template<typename RequestJob>
+  void RegisterProtocol(const std::string& scheme,
+                        const Handler& handler,
+                        mate::Arguments* args) {
+    CompletionCallback callback;
+    args->GetNext(&callback);
+    content::BrowserThread::PostTaskAndReplyWithResult(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&Protocol::RegisterProtocolInIO<RequestJob>,
+                   base::Unretained(this), scheme, handler),
+        base::Bind(&Protocol::OnIOCompleted,
+                   base::Unretained(this), callback));
+  }
+  template<typename RequestJob>
+  ProtocolError RegisterProtocolInIO(const std::string& scheme,
+                                     const Handler& handler) {
+    if (job_factory_->IsHandledProtocol(scheme))
+      return PROTOCOL_REGISTERED;
+    scoped_ptr<CustomProtocolHandler<RequestJob>> protocol_handler(
+        new CustomProtocolHandler<RequestJob>(
+            isolate(), request_context_getter_, handler));
+    if (job_factory_->SetProtocolHandler(scheme, std::move(protocol_handler)))
+      return PROTOCOL_OK;
+    else
+      return PROTOCOL_FAIL;
+  }
+
+  // Unregister the protocol handler that handles |scheme|.
+  void UnregisterProtocol(const std::string& scheme, mate::Arguments* args);
+  ProtocolError UnregisterProtocolInIO(const std::string& scheme);
+
+  // Whether the protocol has handler registered.
+  void IsProtocolHandled(const std::string& scheme,
+                         const BooleanCallback& callback);
+  bool IsProtocolHandledInIO(const std::string& scheme);
+
+  // Replace the protocol handler with a new one.
+  template<typename RequestJob>
+  void InterceptProtocol(const std::string& scheme,
+                         const Handler& handler,
+                         mate::Arguments* args) {
+    CompletionCallback callback;
+    args->GetNext(&callback);
+    content::BrowserThread::PostTaskAndReplyWithResult(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(&Protocol::InterceptProtocolInIO<RequestJob>,
+                   base::Unretained(this), scheme, handler),
+        base::Bind(&Protocol::OnIOCompleted,
+                   base::Unretained(this), callback));
+  }
+  template<typename RequestJob>
+  ProtocolError InterceptProtocolInIO(const std::string& scheme,
+                                      const Handler& handler) {
+    if (!job_factory_->IsHandledProtocol(scheme))
+      return PROTOCOL_NOT_REGISTERED;
+    // It is possible a protocol is handled but can not be intercepted.
+    if (!job_factory_->HasProtocolHandler(scheme))
+      return PROTOCOL_FAIL;
+    if (ContainsKey(original_protocols_, scheme))
+      return PROTOCOL_INTERCEPTED;
+    scoped_ptr<CustomProtocolHandler<RequestJob>> protocol_handler(
+        new CustomProtocolHandler<RequestJob>(
+            isolate(), request_context_getter_, handler));
+    original_protocols_.set(
+        scheme,
+        job_factory_->ReplaceProtocol(scheme, std::move(protocol_handler)));
+    return PROTOCOL_OK;
+  }
+
+  // Restore the |scheme| to its original protocol handler.
+  void UninterceptProtocol(const std::string& scheme, mate::Arguments* args);
+  ProtocolError UninterceptProtocolInIO(const std::string& scheme);
+
+  // Convert error code to JS exception and call the callback.
+  void OnIOCompleted(const CompletionCallback& callback, ProtocolError error);
+
+  // Convert error code to string.
+  std::string ErrorCodeToString(ProtocolError error);
+
+  net::URLRequestContextGetter* request_context_getter_;
+
+  // Map that stores the original protocols of schemes.
+  using OriginalProtocolsMap = base::ScopedPtrHashMap<
+      std::string,
+      scoped_ptr<net::URLRequestJobFactory::ProtocolHandler>>;
+  OriginalProtocolsMap original_protocols_;
+
+  ElectronURLRequestJobFactory* job_factory_;  // weak ref
+
+  DISALLOW_COPY_AND_ASSIGN(Protocol);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_PROTOCOL_H_
added in remote
  their  100644 40e49d2833337c985eb7be6b32684c7d983c3f73 electron/browser/api/electron_api_screen.cc
@@ -0,0 +1,146 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_screen.h"
+
+#include <algorithm>
+#include <string>
+
+#include "electron/browser/browser.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "base/bind.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "ui/gfx/screen.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// Find an item in container according to its ID.
+template<class T>
+typename T::iterator FindById(T* container, int id) {
+  auto predicate = [id] (const typename T::value_type& item) -> bool {
+    return item.id() == id;
+  };
+  return std::find_if(container->begin(), container->end(), predicate);
+}
+
+// Convert the changed_metrics bitmask to string array.
+std::vector<std::string> MetricsToArray(uint32_t metrics) {
+  std::vector<std::string> array;
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_BOUNDS)
+    array.push_back("bounds");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_WORK_AREA)
+    array.push_back("workArea");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_DEVICE_SCALE_FACTOR)
+    array.push_back("scaleFactor");
+  if (metrics & gfx::DisplayObserver::DISPLAY_METRIC_ROTATION)
+    array.push_back("rotation");
+  return array;
+}
+
+}  // namespace
+
+Screen::Screen(gfx::Screen* screen) : screen_(screen) {
+  displays_ = screen_->GetAllDisplays();
+  screen_->AddObserver(this);
+}
+
+Screen::~Screen() {
+  screen_->RemoveObserver(this);
+}
+
+gfx::Point Screen::GetCursorScreenPoint() {
+  return screen_->GetCursorScreenPoint();
+}
+
+gfx::Display Screen::GetPrimaryDisplay() {
+  return screen_->GetPrimaryDisplay();
+}
+
+std::vector<gfx::Display> Screen::GetAllDisplays() {
+  return displays_;
+}
+
+gfx::Display Screen::GetDisplayNearestPoint(const gfx::Point& point) {
+  return screen_->GetDisplayNearestPoint(point);
+}
+
+gfx::Display Screen::GetDisplayMatching(const gfx::Rect& match_rect) {
+  return screen_->GetDisplayMatching(match_rect);
+}
+
+void Screen::OnDisplayAdded(const gfx::Display& new_display) {
+  displays_.push_back(new_display);
+  Emit("display-added", new_display);
+}
+
+void Screen::OnDisplayRemoved(const gfx::Display& old_display) {
+  auto iter = FindById(&displays_, old_display.id());
+  if (iter == displays_.end())
+    return;
+
+  displays_.erase(iter);
+  Emit("display-removed", old_display);
+}
+
+void Screen::OnDisplayMetricsChanged(const gfx::Display& display,
+                                     uint32_t changed_metrics) {
+  auto iter = FindById(&displays_, display.id());
+  if (iter == displays_.end())
+    return;
+
+  *iter = display;
+  Emit("display-metrics-changed", display, MetricsToArray(changed_metrics));
+}
+
+mate::ObjectTemplateBuilder Screen::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("getCursorScreenPoint", &Screen::GetCursorScreenPoint)
+      .SetMethod("getPrimaryDisplay", &Screen::GetPrimaryDisplay)
+      .SetMethod("getAllDisplays", &Screen::GetAllDisplays)
+      .SetMethod("getDisplayNearestPoint", &Screen::GetDisplayNearestPoint)
+      .SetMethod("getDisplayMatching", &Screen::GetDisplayMatching);
+}
+
+// static
+v8::Local<v8::Value> Screen::Create(v8::Isolate* isolate) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate,
+        "Cannot initialize \"screen\" module before app is ready")));
+    return v8::Null(isolate);
+  }
+
+  gfx::Screen* screen = gfx::Screen::GetNativeScreen();
+  if (!screen) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Failed to get screen information")));
+    return v8::Null(isolate);
+  }
+
+  return mate::CreateHandle(isolate, new Screen(screen)).ToV8();
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.Set("screen", electron::api::Screen::Create(context->GetIsolate()));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_screen, Initialize)
added in remote
  their  100644 6c44a66d4143a9bb935f27282a4e3cdc2b6d694b electron/browser/api/electron_api_screen.h
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
+
+#include <vector>
+
+#include "electron/browser/api/event_emitter.h"
+#include "native_mate/handle.h"
+#include "ui/gfx/display_observer.h"
+
+namespace gfx {
+class Point;
+class Rect;
+class Screen;
+}
+
+namespace electron {
+
+namespace api {
+
+class Screen : public mate::EventEmitter,
+               public gfx::DisplayObserver {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate);
+
+ protected:
+  explicit Screen(gfx::Screen* screen);
+  virtual ~Screen();
+
+  gfx::Point GetCursorScreenPoint();
+  gfx::Display GetPrimaryDisplay();
+  std::vector<gfx::Display> GetAllDisplays();
+  gfx::Display GetDisplayNearestPoint(const gfx::Point& point);
+  gfx::Display GetDisplayMatching(const gfx::Rect& match_rect);
+
+  // gfx::DisplayObserver:
+  void OnDisplayAdded(const gfx::Display& new_display) override;
+  void OnDisplayRemoved(const gfx::Display& old_display) override;
+  void OnDisplayMetricsChanged(const gfx::Display& display,
+                               uint32_t changed_metrics) override;
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  gfx::Screen* screen_;
+  std::vector<gfx::Display> displays_;
+
+  DISALLOW_COPY_AND_ASSIGN(Screen);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_SCREEN_H_
added in remote
  their  100644 c4d14c26369a83eaa03514bebde0e217b8d94f49 electron/browser/api/electron_api_session.cc
@@ -0,0 +1,524 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_session.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_cookies.h"
+#include "electron/browser/api/electron_api_download_item.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/api/electron_api_web_request.h"
+#include "electron/browser/api/save_page_handler.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_permission_manager.h"
+#include "electron/browser/net/electron_cert_verifier.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/content_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/files/file_path.h"
+#include "base/prefs/pref_service.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/thread_task_runner_handle.h"
+#include "brightray/browser/net/devtools_network_conditions.h"
+#include "brightray/browser/net/devtools_network_controller.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/storage_partition.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/base/load_flags.h"
+#include "net/disk_cache/disk_cache.h"
+#include "net/dns/host_cache.h"
+#include "net/proxy/proxy_service.h"
+#include "net/proxy/proxy_config_service_fixed.h"
+#include "net/url_request/url_request_context.h"
+#include "net/url_request/url_request_context_getter.h"
+
+using content::BrowserThread;
+using content::StoragePartition;
+
+namespace {
+
+struct ClearStorageDataOptions {
+  GURL origin;
+  uint32_t storage_types = StoragePartition::REMOVE_DATA_MASK_ALL;
+  uint32_t quota_types = StoragePartition::QUOTA_MANAGED_STORAGE_MASK_ALL;
+};
+
+uint32_t GetStorageMask(const std::vector<std::string>& storage_types) {
+  uint32_t storage_mask = 0;
+  for (const auto& it : storage_types) {
+    auto type = base::ToLowerASCII(it);
+    if (type == "appcache")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_APPCACHE;
+    else if (type == "cookies")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_COOKIES;
+    else if (type == "filesystem")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_FILE_SYSTEMS;
+    else if (type == "indexdb")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_INDEXEDDB;
+    else if (type == "localstorage")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_LOCAL_STORAGE;
+    else if (type == "shadercache")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SHADER_CACHE;
+    else if (type == "websql")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_WEBSQL;
+    else if (type == "serviceworkers")
+      storage_mask |= StoragePartition::REMOVE_DATA_MASK_SERVICE_WORKERS;
+  }
+  return storage_mask;
+}
+
+uint32_t GetQuotaMask(const std::vector<std::string>& quota_types) {
+  uint32_t quota_mask = 0;
+  for (const auto& it : quota_types) {
+    auto type = base::ToLowerASCII(it);
+    if (type == "temporary")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_TEMPORARY;
+    else if (type == "persistent")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_PERSISTENT;
+    else if (type == "syncable")
+      quota_mask |= StoragePartition::QUOTA_MANAGED_STORAGE_MASK_SYNCABLE;
+  }
+  return quota_mask;
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<ClearStorageDataOptions> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     ClearStorageDataOptions* out) {
+    mate::Dictionary options;
+    if (!ConvertFromV8(isolate, val, &options))
+      return false;
+    options.Get("origin", &out->origin);
+    std::vector<std::string> types;
+    if (options.Get("storages", &types))
+      out->storage_types = GetStorageMask(types);
+    if (options.Get("quotas", &types))
+      out->quota_types = GetQuotaMask(types);
+    return true;
+  }
+};
+
+template<>
+struct Converter<net::ProxyConfig> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     net::ProxyConfig* out) {
+    std::string proxy_rules;
+    GURL pac_url;
+    mate::Dictionary options;
+    // Fallback to previous API when passed String.
+    // https://git.io/vuhjj
+    if (ConvertFromV8(isolate, val, &proxy_rules)) {
+      pac_url = GURL(proxy_rules);  // Assume it is PAC script if it is URL.
+    } else if (ConvertFromV8(isolate, val, &options)) {
+      options.Get("pacScript", &pac_url);
+      options.Get("proxyRules", &proxy_rules);
+    } else {
+      return false;
+    }
+
+    // pacScript takes precedence over proxyRules.
+    if (!pac_url.is_empty() && pac_url.is_valid()) {
+      out->set_pac_url(pac_url);
+    } else {
+      out->proxy_rules().ParseFromString(proxy_rules);
+    }
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapSession funtion which is implemented in JavaScript
+using WrapSessionCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapSessionCallback g_wrap_session;
+
+class ResolveProxyHelper {
+ public:
+  ResolveProxyHelper(ElectronBrowserContext* browser_context,
+                     const GURL& url,
+                     Session::ResolveProxyCallback callback)
+      : callback_(callback),
+        original_thread_(base::ThreadTaskRunnerHandle::Get()) {
+    scoped_refptr<net::URLRequestContextGetter> context_getter =
+        browser_context->GetRequestContext();
+    context_getter->GetNetworkTaskRunner()->PostTask(
+        FROM_HERE,
+        base::Bind(&ResolveProxyHelper::ResolveProxy,
+                   base::Unretained(this), context_getter, url));
+  }
+
+  void OnResolveProxyCompleted(int result) {
+    std::string proxy;
+    if (result == net::OK)
+      proxy = proxy_info_.ToPacString();
+    original_thread_->PostTask(FROM_HERE,
+                               base::Bind(callback_, proxy));
+    delete this;
+  }
+
+ private:
+  void ResolveProxy(scoped_refptr<net::URLRequestContextGetter> context_getter,
+                    const GURL& url) {
+    DCHECK_CURRENTLY_ON(content::BrowserThread::IO);
+
+    net::ProxyService* proxy_service =
+        context_getter->GetURLRequestContext()->proxy_service();
+    net::CompletionCallback completion_callback =
+        base::Bind(&ResolveProxyHelper::OnResolveProxyCompleted,
+                   base::Unretained(this));
+
+    // Start the request.
+    int result = proxy_service->ResolveProxy(
+        url, net::LOAD_NORMAL, &proxy_info_, completion_callback,
+        &pac_req_, nullptr, net::BoundNetLog());
+
+    // Completed synchronously.
+    if (result != net::ERR_IO_PENDING)
+      completion_callback.Run(result);
+  }
+
+  Session::ResolveProxyCallback callback_;
+  net::ProxyInfo proxy_info_;
+  net::ProxyService::PacRequest* pac_req_;
+  scoped_refptr<base::SingleThreadTaskRunner> original_thread_;
+
+  DISALLOW_COPY_AND_ASSIGN(ResolveProxyHelper);
+};
+
+// Runs the callback in UI thread.
+template<typename ...T>
+void RunCallbackInUI(const base::Callback<void(T...)>& callback, T... result) {
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE, base::Bind(callback, result...));
+}
+
+// Callback of HttpCache::GetBackend.
+void OnGetBackend(disk_cache::Backend** backend_ptr,
+                  Session::CacheAction action,
+                  const net::CompletionCallback& callback,
+                  int result) {
+  if (result != net::OK) {
+    RunCallbackInUI(callback, result);
+  } else if (backend_ptr && *backend_ptr) {
+    if (action == Session::CacheAction::CLEAR) {
+      (*backend_ptr)->DoomAllEntries(base::Bind(&RunCallbackInUI<int>,
+                                                callback));
+    } else if (action == Session::CacheAction::STATS) {
+      base::StringPairs stats;
+      (*backend_ptr)->GetStats(&stats);
+      for (size_t i = 0; i < stats.size(); ++i) {
+        if (stats[i].first == "Current size") {
+          int current_size;
+          base::StringToInt(stats[i].second, &current_size);
+          RunCallbackInUI(callback, current_size);
+          break;
+        }
+      }
+    }
+  } else {
+    RunCallbackInUI<int>(callback, net::ERR_FAILED);
+  }
+}
+
+void DoCacheActionInIO(
+    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
+    Session::CacheAction action,
+    const net::CompletionCallback& callback) {
+  auto request_context = context_getter->GetURLRequestContext();
+  auto http_cache = request_context->http_transaction_factory()->GetCache();
+  if (!http_cache)
+    RunCallbackInUI<int>(callback, net::ERR_FAILED);
+
+  // Call GetBackend and make the backend's ptr accessable in OnGetBackend.
+  using BackendPtr = disk_cache::Backend*;
+  BackendPtr* backend_ptr = new BackendPtr(nullptr);
+  net::CompletionCallback on_get_backend =
+      base::Bind(&OnGetBackend, base::Owned(backend_ptr), action, callback);
+  int rv = http_cache->GetBackend(backend_ptr, on_get_backend);
+  if (rv != net::ERR_IO_PENDING)
+    on_get_backend.Run(net::OK);
+}
+
+void SetProxyInIO(net::URLRequestContextGetter* getter,
+                  const net::ProxyConfig& config,
+                  const base::Closure& callback) {
+  auto proxy_service = getter->GetURLRequestContext()->proxy_service();
+  proxy_service->ResetConfigService(make_scoped_ptr(
+      new net::ProxyConfigServiceFixed(config)));
+  // Refetches and applies the new pac script if provided.
+  proxy_service->ForceReloadProxyConfig();
+  RunCallbackInUI(callback);
+}
+
+void ClearHostResolverCacheInIO(
+    const scoped_refptr<net::URLRequestContextGetter>& context_getter,
+    const base::Closure& callback) {
+  auto request_context = context_getter->GetURLRequestContext();
+  auto cache = request_context->host_resolver()->GetHostCache();
+  if (cache) {
+    cache->clear();
+    DCHECK_EQ(0u, cache->size());
+    if (!callback.is_null())
+      RunCallbackInUI(callback);
+  }
+}
+
+}  // namespace
+
+Session::Session(ElectronBrowserContext* browser_context)
+    : browser_context_(browser_context) {
+  AttachAsUserData(browser_context);
+
+  // Observe DownloadManger to get download notifications.
+  content::BrowserContext::GetDownloadManager(browser_context)->
+      AddObserver(this);
+}
+
+Session::~Session() {
+  content::BrowserContext::GetDownloadManager(browser_context())->
+      RemoveObserver(this);
+}
+
+void Session::OnDownloadCreated(content::DownloadManager* manager,
+                                content::DownloadItem* item) {
+  auto web_contents = item->GetWebContents();
+  if (SavePageHandler::IsSavePageTypes(item->GetMimeType()))
+    return;
+  bool prevent_default = Emit(
+      "will-download",
+      DownloadItem::Create(isolate(), item),
+      api::WebContents::CreateFrom(isolate(), web_contents));
+  if (prevent_default) {
+    item->Cancel(true);
+    item->Remove();
+  }
+}
+
+void Session::ResolveProxy(const GURL& url, ResolveProxyCallback callback) {
+  new ResolveProxyHelper(browser_context(), url, callback);
+}
+
+template<Session::CacheAction action>
+void Session::DoCacheAction(const net::CompletionCallback& callback) {
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&DoCacheActionInIO,
+                 make_scoped_refptr(browser_context_->GetRequestContext()),
+                 action,
+                 callback));
+}
+
+void Session::ClearStorageData(mate::Arguments* args) {
+  // clearStorageData([options, ]callback)
+  ClearStorageDataOptions options;
+  args->GetNext(&options);
+  base::Closure callback;
+  if (!args->GetNext(&callback)) {
+    args->ThrowError();
+    return;
+  }
+
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
+  storage_partition->ClearData(
+      options.storage_types, options.quota_types, options.origin,
+      content::StoragePartition::OriginMatcherFunction(),
+      base::Time(), base::Time::Max(), callback);
+}
+
+void Session::FlushStorageData() {
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(browser_context(), nullptr);
+  storage_partition->Flush();
+}
+
+void Session::SetProxy(const net::ProxyConfig& config,
+                       const base::Closure& callback) {
+  auto getter = browser_context_->GetRequestContext();
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&SetProxyInIO, base::Unretained(getter), config, callback));
+}
+
+void Session::SetDownloadPath(const base::FilePath& path) {
+  browser_context_->prefs()->SetFilePath(
+      prefs::kDownloadDefaultDirectory, path);
+}
+
+void Session::EnableNetworkEmulation(const mate::Dictionary& options) {
+  scoped_ptr<brightray::DevToolsNetworkConditions> conditions;
+  bool offline = false;
+  double latency, download_throughput, upload_throughput;
+  if (options.Get("offline", &offline) && offline) {
+    conditions.reset(new brightray::DevToolsNetworkConditions(offline));
+  } else {
+    options.Get("latency", &latency);
+    options.Get("downloadThroughput", &download_throughput);
+    options.Get("uploadThroughput", &upload_throughput);
+    conditions.reset(
+        new brightray::DevToolsNetworkConditions(false,
+                                                 latency,
+                                                 download_throughput,
+                                                 upload_throughput));
+  }
+  auto controller = browser_context_->GetDevToolsNetworkController();
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&brightray::DevToolsNetworkController::SetNetworkState,
+                 base::Unretained(controller),
+                 std::string(),
+                 base::Passed(&conditions)));
+}
+
+void Session::DisableNetworkEmulation() {
+  scoped_ptr<brightray::DevToolsNetworkConditions> conditions(
+      new brightray::DevToolsNetworkConditions(false));
+  auto controller = browser_context_->GetDevToolsNetworkController();
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&brightray::DevToolsNetworkController::SetNetworkState,
+                 base::Unretained(controller),
+                 std::string(),
+                 base::Passed(&conditions)));
+}
+
+void Session::SetCertVerifyProc(v8::Local<v8::Value> val,
+                                mate::Arguments* args) {
+  ElectronCertVerifier::VerifyProc proc;
+  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &proc))) {
+    args->ThrowError("Must pass null or function");
+    return;
+  }
+
+  browser_context_->cert_verifier()->SetVerifyProc(proc);
+}
+
+void Session::SetPermissionRequestHandler(v8::Local<v8::Value> val,
+                                          mate::Arguments* args) {
+  ElectronPermissionManager::RequestHandler handler;
+  if (!(val->IsNull() || mate::ConvertFromV8(args->isolate(), val, &handler))) {
+    args->ThrowError("Must pass null or function");
+    return;
+  }
+  auto permission_manager = static_cast<ElectronPermissionManager*>(
+      browser_context()->GetPermissionManager());
+  permission_manager->SetPermissionRequestHandler(handler);
+}
+
+void Session::ClearHostResolverCache(mate::Arguments* args) {
+  base::Closure callback;
+  args->GetNext(&callback);
+
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+      base::Bind(&ClearHostResolverCacheInIO,
+                 make_scoped_refptr(browser_context_->GetRequestContext()),
+                 callback));
+}
+
+v8::Local<v8::Value> Session::Cookies(v8::Isolate* isolate) {
+  if (cookies_.IsEmpty()) {
+    auto handle = electron::api::Cookies::Create(isolate, browser_context());
+    cookies_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, cookies_);
+}
+
+v8::Local<v8::Value> Session::WebRequest(v8::Isolate* isolate) {
+  if (web_request_.IsEmpty()) {
+    auto handle = electron::api::WebRequest::Create(isolate, browser_context());
+    web_request_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, web_request_);
+}
+
+// static
+mate::Handle<Session> Session::CreateFrom(
+    v8::Isolate* isolate, ElectronBrowserContext* browser_context) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, browser_context);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<Session*>(existing));
+
+  auto handle = mate::CreateHandle(isolate, new Session(browser_context));
+  g_wrap_session.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+mate::Handle<Session> Session::FromPartition(
+    v8::Isolate* isolate, const std::string& partition, bool in_memory) {
+  auto browser_context = brightray::BrowserContext::From(partition, in_memory);
+  return CreateFrom(isolate,
+                    static_cast<ElectronBrowserContext*>(browser_context.get()));
+}
+
+// static
+void Session::BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("resolveProxy", &Session::ResolveProxy)
+      .SetMethod("getCacheSize", &Session::DoCacheAction<CacheAction::STATS>)
+      .SetMethod("clearCache", &Session::DoCacheAction<CacheAction::CLEAR>)
+      .SetMethod("clearStorageData", &Session::ClearStorageData)
+      .SetMethod("flushStorageData", &Session::FlushStorageData)
+      .SetMethod("setProxy", &Session::SetProxy)
+      .SetMethod("setDownloadPath", &Session::SetDownloadPath)
+      .SetMethod("enableNetworkEmulation", &Session::EnableNetworkEmulation)
+      .SetMethod("disableNetworkEmulation", &Session::DisableNetworkEmulation)
+      .SetMethod("setCertificateVerifyProc", &Session::SetCertVerifyProc)
+      .SetMethod("setPermissionRequestHandler",
+                 &Session::SetPermissionRequestHandler)
+      .SetMethod("clearHostResolverCache", &Session::ClearHostResolverCache)
+      .SetProperty("cookies", &Session::Cookies)
+      .SetProperty("webRequest", &Session::WebRequest);
+}
+
+void ClearWrapSession() {
+  g_wrap_session.Reset();
+}
+
+void SetWrapSession(const WrapSessionCallback& callback) {
+  g_wrap_session = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapSession));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("fromPartition", &electron::api::Session::FromPartition);
+  dict.SetMethod("_setWrapSession", &electron::api::SetWrapSession);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_session, Initialize)
added in remote
  their  100644 42941fee865627a0af7b758e3b99c5e0c05c469a electron/browser/api/electron_api_session.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
+
+#include <string>
+
+#include "electron/browser/api/trackable_object.h"
+#include "content/public/browser/download_manager.h"
+#include "native_mate/handle.h"
+#include "net/base/completion_callback.h"
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace net {
+class ProxyConfig;
+}
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+namespace api {
+
+class Session: public mate::TrackableObject<Session>,
+               public content::DownloadManager::Observer {
+ public:
+  using ResolveProxyCallback = base::Callback<void(std::string)>;
+
+  enum class CacheAction {
+    CLEAR,
+    STATS,
+  };
+
+  // Gets or creates Session from the |browser_context|.
+  static mate::Handle<Session> CreateFrom(
+      v8::Isolate* isolate, ElectronBrowserContext* browser_context);
+
+  // Gets the Session of |partition| and |in_memory|.
+  static mate::Handle<Session> FromPartition(
+      v8::Isolate* isolate, const std::string& partition, bool in_memory);
+
+  ElectronBrowserContext* browser_context() const { return browser_context_.get(); }
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Session(ElectronBrowserContext* browser_context);
+  ~Session();
+
+  // content::DownloadManager::Observer:
+  void OnDownloadCreated(content::DownloadManager* manager,
+                         content::DownloadItem* item) override;
+
+ private:
+  void ResolveProxy(const GURL& url, ResolveProxyCallback callback);
+  template<CacheAction action>
+  void DoCacheAction(const net::CompletionCallback& callback);
+  void ClearStorageData(mate::Arguments* args);
+  void FlushStorageData();
+  void SetProxy(const net::ProxyConfig& config, const base::Closure& callback);
+  void SetDownloadPath(const base::FilePath& path);
+  void EnableNetworkEmulation(const mate::Dictionary& options);
+  void DisableNetworkEmulation();
+  void SetCertVerifyProc(v8::Local<v8::Value> proc, mate::Arguments* args);
+  void SetPermissionRequestHandler(v8::Local<v8::Value> val,
+                                   mate::Arguments* args);
+  void ClearHostResolverCache(mate::Arguments* args);
+  v8::Local<v8::Value> Cookies(v8::Isolate* isolate);
+  v8::Local<v8::Value> WebRequest(v8::Isolate* isolate);
+
+  // Cached object.
+  v8::Global<v8::Value> cookies_;
+  v8::Global<v8::Value> web_request_;
+
+  scoped_refptr<ElectronBrowserContext> browser_context_;
+
+  DISALLOW_COPY_AND_ASSIGN(Session);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_SESSION_H_
added in remote
  their  100644 c4dc2ddb2c7d674db6837be3859e4d98001816ee electron/browser/api/electron_api_tray.cc
@@ -0,0 +1,187 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_tray.h"
+
+#include <string>
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/ui/tray_icon.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "ui/events/event_constants.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+namespace api {
+
+Tray::Tray(const gfx::Image& image)
+    : tray_icon_(TrayIcon::Create()) {
+  tray_icon_->SetImage(image);
+  tray_icon_->AddObserver(this);
+}
+
+Tray::~Tray() {
+}
+
+// static
+mate::Wrappable* Tray::New(v8::Isolate* isolate, const gfx::Image& image) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Cannot create Tray before app is ready")));
+    return nullptr;
+  }
+  return new Tray(image);
+}
+
+void Tray::OnClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("double-click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnRightClicked(const gfx::Rect& bounds, int modifiers) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  EmitCustomEvent("right-click",
+                  ModifiersToObject(isolate(), modifiers), bounds);
+}
+
+void Tray::OnBalloonShow() {
+  Emit("balloon-show");
+}
+
+void Tray::OnBalloonClicked() {
+  Emit("balloon-click");
+}
+
+void Tray::OnBalloonClosed() {
+  Emit("balloon-closed");
+}
+
+void Tray::OnDrop() {
+  Emit("drop");
+}
+
+void Tray::OnDropFiles(const std::vector<std::string>& files) {
+  Emit("drop-files", files);
+}
+
+void Tray::OnDragEntered() {
+  Emit("drag-enter");
+}
+
+void Tray::OnDragExited() {
+  Emit("drag-leave");
+}
+
+void Tray::OnDragEnded() {
+  Emit("drag-end");
+}
+
+void Tray::SetImage(mate::Arguments* args, const gfx::Image& image) {
+  tray_icon_->SetImage(image);
+}
+
+void Tray::SetPressedImage(mate::Arguments* args, const gfx::Image& image) {
+  tray_icon_->SetPressedImage(image);
+}
+
+void Tray::SetToolTip(mate::Arguments* args, const std::string& tool_tip) {
+  tray_icon_->SetToolTip(tool_tip);
+}
+
+void Tray::SetTitle(mate::Arguments* args, const std::string& title) {
+  tray_icon_->SetTitle(title);
+}
+
+void Tray::SetHighlightMode(mate::Arguments* args, bool highlight) {
+  tray_icon_->SetHighlightMode(highlight);
+}
+
+void Tray::DisplayBalloon(mate::Arguments* args,
+                          const mate::Dictionary& options) {
+  gfx::Image icon;
+  options.Get("icon", &icon);
+  base::string16 title, content;
+  if (!options.Get("title", &title) ||
+      !options.Get("content", &content)) {
+    args->ThrowError("'title' and 'content' must be defined");
+    return;
+  }
+
+  tray_icon_->DisplayBalloon(icon, title, content);
+}
+
+void Tray::PopUpContextMenu(mate::Arguments* args) {
+  mate::Handle<Menu> menu;
+  args->GetNext(&menu);
+  gfx::Point pos;
+  args->GetNext(&pos);
+  tray_icon_->PopUpContextMenu(pos, menu.IsEmpty() ? nullptr : menu->model());
+}
+
+void Tray::SetContextMenu(mate::Arguments* args, Menu* menu) {
+  tray_icon_->SetContextMenu(menu->model());
+}
+
+v8::Local<v8::Object> Tray::ModifiersToObject(v8::Isolate* isolate,
+                                              int modifiers) {
+  mate::Dictionary obj(isolate, v8::Object::New(isolate));
+  obj.Set("shiftKey", static_cast<bool>(modifiers & ui::EF_SHIFT_DOWN));
+  obj.Set("ctrlKey", static_cast<bool>(modifiers & ui::EF_CONTROL_DOWN));
+  obj.Set("altKey", static_cast<bool>(modifiers & ui::EF_ALT_DOWN));
+  obj.Set("metaKey", static_cast<bool>(modifiers & ui::EF_COMMAND_DOWN));
+  return obj.GetHandle();
+}
+
+// static
+void Tray::BuildPrototype(v8::Isolate* isolate,
+                          v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("setImage", &Tray::SetImage)
+      .SetMethod("setPressedImage", &Tray::SetPressedImage)
+      .SetMethod("setToolTip", &Tray::SetToolTip)
+      .SetMethod("setTitle", &Tray::SetTitle)
+      .SetMethod("setHighlightMode", &Tray::SetHighlightMode)
+      .SetMethod("displayBalloon", &Tray::DisplayBalloon)
+      .SetMethod("popUpContextMenu", &Tray::PopUpContextMenu)
+      .SetMethod("_setContextMenu", &Tray::SetContextMenu);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  using electron::api::Tray;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Tray>(
+      isolate, "Tray", base::Bind(&Tray::New));
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("Tray", static_cast<v8::Local<v8::Value>>(constructor));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_tray, Initialize)
added in remote
  their  100644 9fbea743753d9ba05213db03e0136a84388b0a26 electron/browser/api/electron_api_tray.h
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/ui/tray_icon_observer.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace gfx {
+class Image;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+class TrayIcon;
+
+namespace api {
+
+class Menu;
+
+class Tray : public mate::TrackableObject<Tray>,
+             public TrayIconObserver {
+ public:
+  static mate::Wrappable* New(v8::Isolate* isolate, const gfx::Image& image);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit Tray(const gfx::Image& image);
+  ~Tray() override;
+
+  // TrayIconObserver:
+  void OnClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnRightClicked(const gfx::Rect& bounds, int modifiers) override;
+  void OnBalloonShow() override;
+  void OnBalloonClicked() override;
+  void OnBalloonClosed() override;
+  void OnDrop() override;
+  void OnDropFiles(const std::vector<std::string>& files) override;
+  void OnDragEntered() override;
+  void OnDragExited() override;
+  void OnDragEnded() override;
+
+  void SetImage(mate::Arguments* args, const gfx::Image& image);
+  void SetPressedImage(mate::Arguments* args, const gfx::Image& image);
+  void SetToolTip(mate::Arguments* args, const std::string& tool_tip);
+  void SetTitle(mate::Arguments* args, const std::string& title);
+  void SetHighlightMode(mate::Arguments* args, bool highlight);
+  void DisplayBalloon(mate::Arguments* args, const mate::Dictionary& options);
+  void PopUpContextMenu(mate::Arguments* args);
+  void SetContextMenu(mate::Arguments* args, Menu* menu);
+
+ private:
+  v8::Local<v8::Object> ModifiersToObject(v8::Isolate* isolate, int modifiers);
+
+  scoped_ptr<TrayIcon> tray_icon_;
+
+  DISALLOW_COPY_AND_ASSIGN(Tray);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_TRAY_H_
added in remote
  their  100644 488f516a3e91fa3856ea503a46d38dfd06d25f1d electron/browser/api/electron_api_web_contents.cc
@@ -0,0 +1,1286 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_contents.h"
+
+#include <set>
+#include <string>
+
+#include "electron/browser/api/electron_api_debugger.h"
+#include "electron/browser/api/electron_api_session.h"
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/web_view_guest_delegate.h"
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/blink_converter.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/content_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/mouse_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "chrome/browser/printing/print_view_manager_basic.h"
+#include "chrome/browser/printing/print_preview_message_handler.h"
+#include "content/common/view_messages.h"
+#include "content/public/browser/favicon_status.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "content/public/browser/navigation_details.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/plugin_service.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/browser/resource_request_details.h"
+#include "content/public/browser/service_worker_context.h"
+#include "content/public/browser/storage_partition.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/context_menu_params.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/static_http_user_agent_settings.h"
+#include "net/url_request/url_request_context.h"
+#include "third_party/WebKit/public/web/WebInputEvent.h"
+#include "ui/base/l10n/l10n_util.h"
+
+#include "electron/common/node_includes.h"
+
+namespace {
+
+struct PrintSettings {
+  bool silent;
+  bool print_background;
+};
+
+void SetUserAgentInIO(scoped_refptr<net::URLRequestContextGetter> getter,
+                      std::string accept_lang,
+                      std::string user_agent) {
+  getter->GetURLRequestContext()->set_http_user_agent_settings(
+      new net::StaticHttpUserAgentSettings(
+          net::HttpUtil::GenerateAcceptLanguageHeader(accept_lang),
+          user_agent));
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<electron::SetSizeParams> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     electron::SetSizeParams* out) {
+    mate::Dictionary params;
+    if (!ConvertFromV8(isolate, val, &params))
+      return false;
+    bool autosize;
+    if (params.Get("enableAutoSize", &autosize))
+      out->enable_auto_size.reset(new bool(true));
+    gfx::Size size;
+    if (params.Get("min", &size))
+      out->min_size.reset(new gfx::Size(size));
+    if (params.Get("max", &size))
+      out->max_size.reset(new gfx::Size(size));
+    if (params.Get("normal", &size))
+      out->normal_size.reset(new gfx::Size(size));
+    return true;
+  }
+};
+
+template<>
+struct Converter<PrintSettings> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     PrintSettings* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    dict.Get("silent", &(out->silent));
+    dict.Get("printBackground", &(out->print_background));
+    return true;
+  }
+};
+
+template<>
+struct Converter<WindowOpenDisposition> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   WindowOpenDisposition val) {
+    std::string disposition = "other";
+    switch (val) {
+      case CURRENT_TAB: disposition = "default"; break;
+      case NEW_FOREGROUND_TAB: disposition = "foreground-tab"; break;
+      case NEW_BACKGROUND_TAB: disposition = "background-tab"; break;
+      case NEW_POPUP: case NEW_WINDOW: disposition = "new-window"; break;
+      default: break;
+    }
+    return mate::ConvertToV8(isolate, disposition);
+  }
+};
+
+template<>
+struct Converter<net::HttpResponseHeaders*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   net::HttpResponseHeaders* headers) {
+    base::DictionaryValue response_headers;
+    if (headers) {
+      void* iter = nullptr;
+      std::string key;
+      std::string value;
+      while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
+        key = base::ToLowerASCII(key);
+        if (response_headers.HasKey(key)) {
+          base::ListValue* values = nullptr;
+          if (response_headers.GetList(key, &values))
+            values->AppendString(value);
+        } else {
+          scoped_ptr<base::ListValue> values(new base::ListValue());
+          values->AppendString(value);
+          response_headers.Set(key, std::move(values));
+        }
+      }
+    }
+    return ConvertToV8(isolate, response_headers);
+  }
+};
+
+template<>
+struct Converter<content::SavePageType> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::SavePageType* out) {
+    std::string save_type;
+    if (!ConvertFromV8(isolate, val, &save_type))
+      return false;
+    save_type = base::ToLowerASCII(save_type);
+    if (save_type == "htmlonly") {
+      *out = content::SAVE_PAGE_TYPE_AS_ONLY_HTML;
+    } else if (save_type == "htmlcomplete") {
+      *out = content::SAVE_PAGE_TYPE_AS_COMPLETE_HTML;
+    } else if (save_type == "mhtml") {
+      *out = content::SAVE_PAGE_TYPE_AS_MHTML;
+    } else {
+      return false;
+    }
+    return true;
+  }
+};
+
+}  // namespace mate
+
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// The wrapWebContents function which is implemented in JavaScript
+using WrapWebContentsCallback = base::Callback<void(v8::Local<v8::Value>)>;
+WrapWebContentsCallback g_wrap_web_contents;
+
+content::ServiceWorkerContext* GetServiceWorkerContext(
+    const content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  auto site_instance = web_contents->GetSiteInstance();
+  if (!context || !site_instance)
+    return nullptr;
+
+  auto storage_partition =
+      content::BrowserContext::GetStoragePartition(context, site_instance);
+  if (!storage_partition)
+    return nullptr;
+
+  return storage_partition->GetServiceWorkerContext();
+}
+
+}  // namespace
+
+WebContents::WebContents(content::WebContents* web_contents)
+    : content::WebContentsObserver(web_contents),
+      type_(REMOTE) {
+  AttachAsUserData(web_contents);
+  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
+}
+
+WebContents::WebContents(v8::Isolate* isolate,
+                         const mate::Dictionary& options)
+    : embedder_(nullptr),
+      request_id_(0) {
+  // Whether it is a guest WebContents.
+  bool is_guest = false;
+  options.Get("isGuest", &is_guest);
+  type_ = is_guest ? WEB_VIEW : BROWSER_WINDOW;
+
+  // Obtain the session.
+  std::string partition;
+  mate::Handle<api::Session> session;
+  if (options.Get("session", &session)) {
+  } else if (options.Get("partition", &partition) && !partition.empty()) {
+    bool in_memory = true;
+    if (base::StartsWith(partition, "persist:", base::CompareCase::SENSITIVE)) {
+      in_memory = false;
+      partition = partition.substr(8);
+    }
+    session = Session::FromPartition(isolate, partition, in_memory);
+  } else {
+    // Use the default session if not specified.
+    session = Session::FromPartition(isolate, "", false);
+  }
+  session_.Reset(isolate, session.ToV8());
+
+  content::WebContents* web_contents;
+  if (is_guest) {
+    content::SiteInstance* site_instance = content::SiteInstance::CreateForURL(
+        session->browser_context(), GURL("chrome-guest://fake-host"));
+    content::WebContents::CreateParams params(
+        session->browser_context(), site_instance);
+    guest_delegate_.reset(new WebViewGuestDelegate);
+    params.guest_delegate = guest_delegate_.get();
+    web_contents = content::WebContents::Create(params);
+  } else {
+    content::WebContents::CreateParams params(session->browser_context());
+    web_contents = content::WebContents::Create(params);
+  }
+
+  Observe(web_contents);
+  AttachAsUserData(web_contents);
+  InitWithWebContents(web_contents);
+
+  managed_web_contents()->GetView()->SetDelegate(this);
+
+  // Save the preferences in C++.
+  new WebContentsPreferences(web_contents, options);
+
+  // Intialize permission helper.
+  WebContentsPermissionHelper::CreateForWebContents(web_contents);
+
+  web_contents->SetUserAgentOverride(GetBrowserContext()->GetUserAgent());
+
+  if (is_guest) {
+    guest_delegate_->Initialize(this);
+
+    NativeWindow* owner_window = nullptr;
+    if (options.Get("embedder", &embedder_) && embedder_) {
+      // New WebContents's owner_window is the embedder's owner_window.
+      auto relay =
+          NativeWindowRelay::FromWebContents(embedder_->web_contents());
+      if (relay)
+        owner_window = relay->window.get();
+    }
+    if (owner_window)
+      SetOwnerWindow(owner_window);
+  }
+}
+
+WebContents::~WebContents() {
+  // The destroy() is called.
+  if (managed_web_contents()) {
+    // For webview we need to tell content module to do some cleanup work before
+    // destroying it.
+    if (type_ == WEB_VIEW)
+      guest_delegate_->Destroy();
+
+    // The WebContentsDestroyed will not be called automatically because we
+    // unsubscribe from webContents before destroying it. So we have to manually
+    // call it here to make sure "destroyed" event is emitted.
+    RenderViewDeleted(web_contents()->GetRenderViewHost());
+    WebContentsDestroyed();
+  }
+}
+
+bool WebContents::AddMessageToConsole(content::WebContents* source,
+                                      int32_t level,
+                                      const base::string16& message,
+                                      int32_t line_no,
+                                      const base::string16& source_id) {
+  if (type_ == BROWSER_WINDOW) {
+    return false;
+  } else {
+    Emit("console-message", level, message, line_no, source_id);
+    return true;
+  }
+}
+
+bool WebContents::ShouldCreateWebContents(
+    content::WebContents* web_contents,
+    int32_t route_id,
+    int32_t main_frame_route_id,
+    int32_t main_frame_widget_route_id,
+    WindowContainerType window_container_type,
+    const std::string& frame_name,
+    const GURL& target_url,
+    const std::string& partition_id,
+    content::SessionStorageNamespace* session_storage_namespace) {
+  if (type_ == BROWSER_WINDOW)
+    Emit("-new-window", target_url, frame_name, NEW_FOREGROUND_TAB);
+  else
+    Emit("new-window", target_url, frame_name, NEW_FOREGROUND_TAB);
+  return false;
+}
+
+content::WebContents* WebContents::OpenURLFromTab(
+    content::WebContents* source,
+    const content::OpenURLParams& params) {
+  if (params.disposition != CURRENT_TAB) {
+    if (type_ == BROWSER_WINDOW)
+      Emit("-new-window", params.url, "", params.disposition);
+    else
+      Emit("new-window", params.url, "", params.disposition);
+    return nullptr;
+  }
+
+  // Give user a chance to cancel navigation.
+  if (Emit("will-navigate", params.url))
+    return nullptr;
+
+  return CommonWebContentsDelegate::OpenURLFromTab(source, params);
+}
+
+void WebContents::BeforeUnloadFired(content::WebContents* tab,
+                                    bool proceed,
+                                    bool* proceed_to_fire_unload) {
+  if (type_ == BROWSER_WINDOW)
+    *proceed_to_fire_unload = proceed;
+  else
+    *proceed_to_fire_unload = true;
+}
+
+void WebContents::MoveContents(content::WebContents* source,
+                               const gfx::Rect& pos) {
+  Emit("move", pos);
+}
+
+void WebContents::CloseContents(content::WebContents* source) {
+  Emit("close");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->CloseContents(source);
+}
+
+void WebContents::ActivateContents(content::WebContents* source) {
+  Emit("activate");
+}
+
+bool WebContents::IsPopupOrPanel(const content::WebContents* source) const {
+  return type_ == BROWSER_WINDOW;
+}
+
+void WebContents::HandleKeyboardEvent(
+    content::WebContents* source,
+    const content::NativeWebKeyboardEvent& event) {
+  if (event.windowsKeyCode == ui::VKEY_ESCAPE && is_html_fullscreen()) {
+    // Escape exits tabbed fullscreen mode.
+    ExitFullscreenModeForTab(source);
+  } else if (type_ == BROWSER_WINDOW) {
+    owner_window()->HandleKeyboardEvent(source, event);
+  } else if (type_ == WEB_VIEW && guest_delegate_) {
+    // Send the unhandled keyboard events back to the embedder.
+    guest_delegate_->HandleKeyboardEvent(source, event);
+  }
+}
+
+void WebContents::EnterFullscreenModeForTab(content::WebContents* source,
+                                            const GURL& origin) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(source);
+  auto callback = base::Bind(&WebContents::OnEnterFullscreenModeForTab,
+                             base::Unretained(this), source, origin);
+  permission_helper->RequestFullscreenPermission(callback);
+}
+
+void WebContents::OnEnterFullscreenModeForTab(content::WebContents* source,
+                                              const GURL& origin,
+                                              bool allowed) {
+  if (!allowed)
+    return;
+  CommonWebContentsDelegate::EnterFullscreenModeForTab(source, origin);
+  Emit("enter-html-full-screen");
+}
+
+void WebContents::ExitFullscreenModeForTab(content::WebContents* source) {
+  CommonWebContentsDelegate::ExitFullscreenModeForTab(source);
+  Emit("leave-html-full-screen");
+}
+
+void WebContents::RendererUnresponsive(content::WebContents* source) {
+  Emit("unresponsive");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->RendererUnresponsive(source);
+}
+
+void WebContents::RendererResponsive(content::WebContents* source) {
+  Emit("responsive");
+  if (type_ == BROWSER_WINDOW)
+    owner_window()->RendererResponsive(source);
+}
+
+bool WebContents::HandleContextMenu(const content::ContextMenuParams& params) {
+  if (!params.custom_context.is_pepper_menu)
+    return false;
+
+  Emit("pepper-context-menu", std::make_pair(params, web_contents()));
+  web_contents()->NotifyContextMenuClosed(params.custom_context);
+  return true;
+}
+
+bool WebContents::OnGoToEntryOffset(int offset) {
+  GoToOffset(offset);
+  return false;
+}
+
+void WebContents::FindReply(content::WebContents* web_contents,
+                            int request_id,
+                            int number_of_matches,
+                            const gfx::Rect& selection_rect,
+                            int active_match_ordinal,
+                            bool final_update) {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+
+  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate());
+  if (number_of_matches == -1) {
+    result.Set("requestId", request_id);
+    result.Set("selectionArea", selection_rect);
+    result.Set("finalUpdate", final_update);
+    result.Set("activeMatchOrdinal", active_match_ordinal);
+    Emit("found-in-page", result);
+  } else if (final_update) {
+    result.Set("requestId", request_id);
+    result.Set("matches", number_of_matches);
+    result.Set("finalUpdate", final_update);
+    Emit("found-in-page", result);
+  }
+}
+
+bool WebContents::CheckMediaAccessPermission(
+    content::WebContents* web_contents,
+    const GURL& security_origin,
+    content::MediaStreamType type) {
+  return true;
+}
+
+void WebContents::RequestMediaAccessPermission(
+    content::WebContents* web_contents,
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& callback) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  permission_helper->RequestMediaAccessPermission(request, callback);
+}
+
+void WebContents::RequestToLockMouse(
+    content::WebContents* web_contents,
+    bool user_gesture,
+    bool last_unlocked_by_target) {
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  permission_helper->RequestPointerLockPermission(user_gesture);
+}
+
+void WebContents::BeforeUnloadFired(const base::TimeTicks& proceed_time) {
+  // Do nothing, we override this method just to avoid compilation error since
+  // there are two virtual functions named BeforeUnloadFired.
+}
+
+void WebContents::RenderViewDeleted(content::RenderViewHost* render_view_host) {
+  Emit("render-view-deleted", render_view_host->GetProcess()->GetID());
+}
+
+void WebContents::RenderProcessGone(base::TerminationStatus status) {
+  Emit("crashed");
+}
+
+void WebContents::PluginCrashed(const base::FilePath& plugin_path,
+                                base::ProcessId plugin_pid) {
+  content::WebPluginInfo info;
+  auto plugin_service = content::PluginService::GetInstance();
+  plugin_service->GetPluginInfoByPath(plugin_path, &info);
+  Emit("plugin-crashed", info.name, info.version);
+}
+
+void WebContents::MediaStartedPlaying(const MediaPlayerId& id) {
+  Emit("media-started-playing");
+}
+
+void WebContents::MediaStoppedPlaying(const MediaPlayerId& id) {
+  Emit("media-paused");
+}
+
+void WebContents::DidChangeThemeColor(SkColor theme_color) {
+  std::string hex_theme_color = base::StringPrintf("#%02X%02X%02X",
+    SkColorGetR(theme_color),
+    SkColorGetG(theme_color),
+    SkColorGetB(theme_color));
+  Emit("did-change-theme-color", hex_theme_color);
+}
+
+void WebContents::DocumentLoadedInFrame(
+    content::RenderFrameHost* render_frame_host) {
+  if (!render_frame_host->GetParent())
+    Emit("dom-ready");
+}
+
+void WebContents::DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                                const GURL& validated_url) {
+  bool is_main_frame = !render_frame_host->GetParent();
+  Emit("did-frame-finish-load", is_main_frame);
+
+  if (is_main_frame)
+    Emit("did-finish-load");
+}
+
+void WebContents::DidFailProvisionalLoad(
+    content::RenderFrameHost* render_frame_host,
+    const GURL& url,
+    int error_code,
+    const base::string16& error_description,
+    bool was_ignored_by_handler) {
+  Emit("did-fail-provisional-load", error_code, error_description, url);
+}
+
+void WebContents::DidFailLoad(content::RenderFrameHost* render_frame_host,
+                              const GURL& validated_url,
+                              int error_code,
+                              const base::string16& error_description,
+                              bool was_ignored_by_handler) {
+  Emit("did-fail-load", error_code, error_description, validated_url);
+}
+
+void WebContents::DidStartLoading() {
+  Emit("did-start-loading");
+}
+
+void WebContents::DidStopLoading() {
+  Emit("did-stop-loading");
+}
+
+void WebContents::DidGetResourceResponseStart(
+    const content::ResourceRequestDetails& details) {
+  Emit("did-get-response-details",
+       details.socket_address.IsEmpty(),
+       details.url,
+       details.original_url,
+       details.http_response_code,
+       details.method,
+       details.referrer,
+       details.headers.get());
+}
+
+void WebContents::DidGetRedirectForResourceRequest(
+    content::RenderFrameHost* render_frame_host,
+    const content::ResourceRedirectDetails& details) {
+  Emit("did-get-redirect-request",
+       details.url,
+       details.new_url,
+       (details.resource_type == content::RESOURCE_TYPE_MAIN_FRAME),
+       details.http_response_code,
+       details.method,
+       details.referrer,
+       details.headers.get());
+}
+
+void WebContents::DidNavigateMainFrame(
+    const content::LoadCommittedDetails& details,
+    const content::FrameNavigateParams& params) {
+  if (details.is_navigation_to_different_page())
+    Emit("did-navigate", params.url);
+  else if (details.is_in_page)
+    Emit("did-navigate-in-page", params.url);
+}
+
+void WebContents::TitleWasSet(content::NavigationEntry* entry,
+                              bool explicit_set) {
+  if (entry)
+    Emit("-page-title-updated", entry->GetTitle(), explicit_set);
+  else
+    Emit("-page-title-updated", "", explicit_set);
+}
+
+void WebContents::DidUpdateFaviconURL(
+    const std::vector<content::FaviconURL>& urls) {
+  std::set<GURL> unique_urls;
+  for (auto iter = urls.begin(); iter != urls.end(); ++iter) {
+    if (iter->icon_type != content::FaviconURL::FAVICON)
+      continue;
+    const GURL& url = iter->icon_url;
+    if (url.is_valid())
+      unique_urls.insert(url);
+  }
+  Emit("page-favicon-updated", unique_urls);
+}
+
+void WebContents::DevToolsFocused() {
+  Emit("devtools-focused");
+}
+
+void WebContents::DevToolsOpened() {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  auto handle = WebContents::CreateFrom(
+      isolate(), managed_web_contents()->GetDevToolsWebContents());
+  devtools_web_contents_.Reset(isolate(), handle.ToV8());
+
+  // Inherit owner window in devtools.
+  if (owner_window())
+    handle->SetOwnerWindow(managed_web_contents()->GetDevToolsWebContents(),
+                           owner_window());
+
+  Emit("devtools-opened");
+}
+
+void WebContents::DevToolsClosed() {
+  v8::Locker locker(isolate());
+  v8::HandleScope handle_scope(isolate());
+  devtools_web_contents_.Reset();
+
+  Emit("devtools-closed");
+}
+
+bool WebContents::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(WebContents, message)
+    IPC_MESSAGE_HANDLER(ElectronViewHostMsg_Message, OnRendererMessage)
+    IPC_MESSAGE_HANDLER_DELAY_REPLY(ElectronViewHostMsg_Message_Sync,
+                                    OnRendererMessageSync)
+    IPC_MESSAGE_HANDLER_CODE(ViewHostMsg_SetCursor, OnCursorChange,
+      handled = false)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+// There are three ways of destroying a webContents:
+// 1. call webContents.destory();
+// 2. garbage collection;
+// 3. user closes the window of webContents;
+// For webview only #1 will happen, for BrowserWindow both #1 and #3 may
+// happen. The #2 should never happen for webContents, because webview is
+// managed by GuestViewManager, and BrowserWindow's webContents is managed
+// by api::Window.
+// For #1, the destructor will do the cleanup work and we only need to make
+// sure "destroyed" event is emitted. For #3, the content::WebContents will
+// be destroyed on close, and WebContentsDestroyed would be called for it, so
+// we need to make sure the api::WebContents is also deleted.
+void WebContents::WebContentsDestroyed() {
+  // This event is only for internal use, which is emitted when WebContents is
+  // being destroyed.
+  Emit("will-destroy");
+
+  // Cleanup relationships with other parts.
+  RemoveFromWeakMap();
+
+  // We can not call Destroy here because we need to call Emit first, but we
+  // also do not want any method to be used, so just mark as destroyed here.
+  MarkDestroyed();
+
+  Emit("destroyed");
+
+  // Destroy the native class in next tick.
+  base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+}
+
+void WebContents::NavigationEntryCommitted(
+    const content::LoadCommittedDetails& details) {
+  Emit("navigation-entry-commited", details.entry->GetURL(),
+       details.is_in_page, details.did_replace_entry);
+}
+
+int WebContents::GetID() const {
+  return web_contents()->GetRenderProcessHost()->GetID();
+}
+
+bool WebContents::Equal(const WebContents* web_contents) const {
+  return GetID() == web_contents->GetID();
+}
+
+void WebContents::LoadURL(const GURL& url, const mate::Dictionary& options) {
+  if (!url.is_valid()) {
+    Emit("did-fail-load",
+         static_cast<int>(net::ERR_INVALID_URL),
+         net::ErrorToShortString(net::ERR_INVALID_URL),
+         url.possibly_invalid_spec());
+    return;
+  }
+
+  content::NavigationController::LoadURLParams params(url);
+
+  GURL http_referrer;
+  if (options.Get("httpReferrer", &http_referrer))
+    params.referrer = content::Referrer(http_referrer.GetAsReferrer(),
+                                        blink::WebReferrerPolicyDefault);
+
+  std::string user_agent;
+  if (options.Get("userAgent", &user_agent))
+    SetUserAgent(user_agent);
+
+  std::string extra_headers;
+  if (options.Get("extraHeaders", &extra_headers))
+    params.extra_headers = extra_headers;
+
+  params.transition_type = ui::PAGE_TRANSITION_TYPED;
+  params.should_clear_history_list = true;
+  params.override_user_agent = content::NavigationController::UA_OVERRIDE_TRUE;
+  web_contents()->GetController().LoadURLWithParams(params);
+}
+
+void WebContents::DownloadURL(const GURL& url) {
+  auto browser_context = web_contents()->GetBrowserContext();
+  auto download_manager =
+    content::BrowserContext::GetDownloadManager(browser_context);
+
+  download_manager->DownloadUrl(
+    content::DownloadUrlParameters::FromWebContents(web_contents(), url));
+}
+
+GURL WebContents::GetURL() const {
+  return web_contents()->GetURL();
+}
+
+base::string16 WebContents::GetTitle() const {
+  return web_contents()->GetTitle();
+}
+
+bool WebContents::IsLoading() const {
+  return web_contents()->IsLoading();
+}
+
+bool WebContents::IsWaitingForResponse() const {
+  return web_contents()->IsWaitingForResponse();
+}
+
+void WebContents::Stop() {
+  web_contents()->Stop();
+}
+
+void WebContents::GoBack() {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoBack();
+}
+
+void WebContents::GoForward() {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoForward();
+}
+
+void WebContents::GoToOffset(int offset) {
+  electron::ElectronBrowserClient::SuppressRendererProcessRestartForOnce();
+  web_contents()->GetController().GoToOffset(offset);
+}
+
+bool WebContents::IsCrashed() const {
+  return web_contents()->IsCrashed();
+}
+
+void WebContents::SetUserAgent(const std::string& user_agent) {
+  web_contents()->SetUserAgentOverride(user_agent);
+  scoped_refptr<net::URLRequestContextGetter> getter =
+      web_contents()->GetBrowserContext()->GetRequestContext();
+
+  auto accept_lang = l10n_util::GetApplicationLocale("");
+  getter->GetNetworkTaskRunner()->PostTask(FROM_HERE,
+      base::Bind(&SetUserAgentInIO, getter, accept_lang, user_agent));
+}
+
+std::string WebContents::GetUserAgent() {
+  return web_contents()->GetUserAgentOverride();
+}
+
+void WebContents::InsertCSS(const std::string& css) {
+  web_contents()->InsertCSS(css);
+}
+
+bool WebContents::SavePage(const base::FilePath& full_file_path,
+                           const content::SavePageType& save_type,
+                           const SavePageHandler::SavePageCallback& callback) {
+  auto handler = new SavePageHandler(web_contents(), callback);
+  return handler->Handle(full_file_path, save_type);
+}
+
+void WebContents::OpenDevTools(mate::Arguments* args) {
+  if (type_ == REMOTE)
+    return;
+
+  bool detach = false;
+  if (type_ == WEB_VIEW) {
+    detach = true;
+  } else if (args && args->Length() == 1) {
+    mate::Dictionary options;
+    args->GetNext(&options) && options.Get("detach", &detach);
+  }
+  managed_web_contents()->SetCanDock(!detach);
+  managed_web_contents()->ShowDevTools();
+}
+
+void WebContents::CloseDevTools() {
+  if (type_ == REMOTE)
+    return;
+
+  managed_web_contents()->CloseDevTools();
+}
+
+bool WebContents::IsDevToolsOpened() {
+  if (type_ == REMOTE)
+    return false;
+
+  return managed_web_contents()->IsDevToolsViewShowing();
+}
+
+bool WebContents::IsDevToolsFocused() {
+  if (type_ == REMOTE)
+    return false;
+
+  return managed_web_contents()->GetView()->IsDevToolsViewFocused();
+}
+
+void WebContents::EnableDeviceEmulation(
+    const blink::WebDeviceEmulationParams& params) {
+  if (type_ == REMOTE)
+    return;
+
+  Send(new ViewMsg_EnableDeviceEmulation(routing_id(), params));
+}
+
+void WebContents::DisableDeviceEmulation() {
+  if (type_ == REMOTE)
+    return;
+
+  Send(new ViewMsg_DisableDeviceEmulation(routing_id()));
+}
+
+void WebContents::ToggleDevTools() {
+  if (IsDevToolsOpened())
+    CloseDevTools();
+  else
+    OpenDevTools(nullptr);
+}
+
+void WebContents::InspectElement(int x, int y) {
+  if (type_ == REMOTE)
+    return;
+
+  OpenDevTools(nullptr);
+  scoped_refptr<content::DevToolsAgentHost> agent(
+    content::DevToolsAgentHost::GetOrCreateFor(web_contents()));
+  agent->InspectElement(x, y);
+}
+
+void WebContents::InspectServiceWorker() {
+  if (type_ == REMOTE)
+    return;
+
+  for (const auto& agent_host : content::DevToolsAgentHost::GetOrCreateAll()) {
+    if (agent_host->GetType() ==
+        content::DevToolsAgentHost::TYPE_SERVICE_WORKER) {
+      OpenDevTools(nullptr);
+      managed_web_contents()->AttachTo(agent_host);
+      break;
+    }
+  }
+}
+
+void WebContents::HasServiceWorker(
+    const base::Callback<void(bool)>& callback) {
+  auto context = GetServiceWorkerContext(web_contents());
+  if (!context)
+    return;
+
+  context->CheckHasServiceWorker(web_contents()->GetLastCommittedURL(),
+                                 GURL::EmptyGURL(),
+                                 callback);
+}
+
+void WebContents::UnregisterServiceWorker(
+    const base::Callback<void(bool)>& callback) {
+  auto context = GetServiceWorkerContext(web_contents());
+  if (!context)
+    return;
+
+  context->UnregisterServiceWorker(web_contents()->GetLastCommittedURL(),
+                                   callback);
+}
+
+void WebContents::SetAudioMuted(bool muted) {
+  web_contents()->SetAudioMuted(muted);
+}
+
+bool WebContents::IsAudioMuted() {
+  return web_contents()->IsAudioMuted();
+}
+
+void WebContents::Print(mate::Arguments* args) {
+  PrintSettings settings = { false, false };
+  if (args->Length() == 1 && !args->GetNext(&settings)) {
+    args->ThrowError();
+    return;
+  }
+
+  printing::PrintViewManagerBasic::FromWebContents(web_contents())->
+      PrintNow(settings.silent, settings.print_background);
+}
+
+void WebContents::PrintToPDF(const base::DictionaryValue& setting,
+                             const PrintToPDFCallback& callback) {
+  printing::PrintPreviewMessageHandler::FromWebContents(web_contents())->
+      PrintToPDF(setting, callback);
+}
+
+void WebContents::AddWorkSpace(mate::Arguments* args,
+                               const base::FilePath& path) {
+  if (path.empty()) {
+    args->ThrowError("path cannot be empty");
+    return;
+  }
+  DevToolsAddFileSystem(path);
+}
+
+void WebContents::RemoveWorkSpace(mate::Arguments* args,
+                                  const base::FilePath& path) {
+  if (path.empty()) {
+    args->ThrowError("path cannot be empty");
+    return;
+  }
+  DevToolsRemoveFileSystem(path);
+}
+
+void WebContents::Undo() {
+  web_contents()->Undo();
+}
+
+void WebContents::Redo() {
+  web_contents()->Redo();
+}
+
+void WebContents::Cut() {
+  web_contents()->Cut();
+}
+
+void WebContents::Copy() {
+  web_contents()->Copy();
+}
+
+void WebContents::Paste() {
+  web_contents()->Paste();
+}
+
+void WebContents::PasteAndMatchStyle() {
+  web_contents()->PasteAndMatchStyle();
+}
+
+void WebContents::Delete() {
+  web_contents()->Delete();
+}
+
+void WebContents::SelectAll() {
+  web_contents()->SelectAll();
+}
+
+void WebContents::Unselect() {
+  web_contents()->Unselect();
+}
+
+void WebContents::Replace(const base::string16& word) {
+  web_contents()->Replace(word);
+}
+
+void WebContents::ReplaceMisspelling(const base::string16& word) {
+  web_contents()->ReplaceMisspelling(word);
+}
+
+uint32_t WebContents::FindInPage(mate::Arguments* args) {
+  uint32_t request_id = GetNextRequestId();
+  base::string16 search_text;
+  blink::WebFindOptions options;
+  if (!args->GetNext(&search_text) || search_text.empty()) {
+    args->ThrowError("Must provide a non-empty search content");
+    return 0;
+  }
+
+  args->GetNext(&options);
+
+  web_contents()->Find(request_id, search_text, options);
+  return request_id;
+}
+
+void WebContents::StopFindInPage(content::StopFindAction action) {
+  web_contents()->StopFinding(action);
+}
+
+void WebContents::Focus() {
+  web_contents()->Focus();
+}
+
+void WebContents::TabTraverse(bool reverse) {
+  web_contents()->FocusThroughTabTraversal(reverse);
+}
+
+bool WebContents::SendIPCMessage(const base::string16& channel,
+                                 const base::ListValue& args) {
+  return Send(new ElectronViewMsg_Message(routing_id(), channel, args));
+}
+
+void WebContents::SendInputEvent(v8::Isolate* isolate,
+                                 v8::Local<v8::Value> input_event) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (!view)
+    return;
+  const auto host = view->GetRenderWidgetHost();
+  if (!host)
+    return;
+
+  int type = mate::GetWebInputEventType(isolate, input_event);
+  if (blink::WebInputEvent::isMouseEventType(type)) {
+    blink::WebMouseEvent mouse_event;
+    if (mate::ConvertFromV8(isolate, input_event, &mouse_event)) {
+      host->ForwardMouseEvent(mouse_event);
+      return;
+    }
+  } else if (blink::WebInputEvent::isKeyboardEventType(type)) {
+    content::NativeWebKeyboardEvent keyboard_event;
+    if (mate::ConvertFromV8(isolate, input_event, &keyboard_event)) {
+      host->ForwardKeyboardEvent(keyboard_event);
+      return;
+    }
+  } else if (type == blink::WebInputEvent::MouseWheel) {
+    blink::WebMouseWheelEvent mouse_wheel_event;
+    if (mate::ConvertFromV8(isolate, input_event, &mouse_wheel_event)) {
+      host->ForwardWheelEvent(mouse_wheel_event);
+      return;
+    }
+  }
+
+  isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+      isolate, "Invalid event object")));
+}
+
+void WebContents::BeginFrameSubscription(
+    const FrameSubscriber::FrameCaptureCallback& callback) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (view) {
+    scoped_ptr<FrameSubscriber> frame_subscriber(new FrameSubscriber(
+        isolate(), view, callback));
+    view->BeginFrameSubscription(std::move(frame_subscriber));
+  }
+}
+
+void WebContents::EndFrameSubscription() {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  if (view)
+    view->EndFrameSubscription();
+}
+
+void WebContents::OnCursorChange(const content::WebCursor& cursor) {
+  content::WebCursor::CursorInfo info;
+  cursor.GetCursorInfo(&info);
+
+  if (cursor.IsCustom()) {
+    Emit("cursor-changed", CursorTypeToString(info),
+      gfx::Image::CreateFrom1xBitmap(info.custom_image),
+      info.image_scale_factor);
+  } else {
+    Emit("cursor-changed", CursorTypeToString(info));
+  }
+}
+
+void WebContents::SetSize(const SetSizeParams& params) {
+  if (guest_delegate_)
+    guest_delegate_->SetSize(params);
+}
+
+bool WebContents::IsGuest() const {
+  return type_ == WEB_VIEW;
+}
+
+v8::Local<v8::Value> WebContents::GetWebPreferences(v8::Isolate* isolate) {
+  WebContentsPreferences* web_preferences =
+      WebContentsPreferences::FromWebContents(web_contents());
+  return mate::ConvertToV8(isolate, *web_preferences->web_preferences());
+}
+
+v8::Local<v8::Value> WebContents::GetOwnerBrowserWindow() {
+  if (owner_window())
+    return Window::From(isolate(), owner_window());
+  else
+    return v8::Null(isolate());
+}
+
+v8::Local<v8::Value> WebContents::Session(v8::Isolate* isolate) {
+  return v8::Local<v8::Value>::New(isolate, session_);
+}
+
+content::WebContents* WebContents::HostWebContents() {
+  if (!embedder_)
+    return nullptr;
+  return embedder_->web_contents();
+}
+
+v8::Local<v8::Value> WebContents::DevToolsWebContents(v8::Isolate* isolate) {
+  if (devtools_web_contents_.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return v8::Local<v8::Value>::New(isolate, devtools_web_contents_);
+}
+
+v8::Local<v8::Value> WebContents::Debugger(v8::Isolate* isolate) {
+  if (debugger_.IsEmpty()) {
+    auto handle = electron::api::Debugger::Create(isolate, web_contents());
+    debugger_.Reset(isolate, handle.ToV8());
+  }
+  return v8::Local<v8::Value>::New(isolate, debugger_);
+}
+
+// static
+void WebContents::BuildPrototype(v8::Isolate* isolate,
+                                 v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("getId", &WebContents::GetID)
+      .SetMethod("equal", &WebContents::Equal)
+      .SetMethod("_loadURL", &WebContents::LoadURL)
+      .SetMethod("downloadURL", &WebContents::DownloadURL)
+      .SetMethod("_getURL", &WebContents::GetURL)
+      .SetMethod("getTitle", &WebContents::GetTitle)
+      .SetMethod("isLoading", &WebContents::IsLoading)
+      .SetMethod("isWaitingForResponse", &WebContents::IsWaitingForResponse)
+      .SetMethod("_stop", &WebContents::Stop)
+      .SetMethod("_goBack", &WebContents::GoBack)
+      .SetMethod("_goForward", &WebContents::GoForward)
+      .SetMethod("_goToOffset", &WebContents::GoToOffset)
+      .SetMethod("isCrashed", &WebContents::IsCrashed)
+      .SetMethod("setUserAgent", &WebContents::SetUserAgent)
+      .SetMethod("getUserAgent", &WebContents::GetUserAgent)
+      .SetMethod("insertCSS", &WebContents::InsertCSS)
+      .SetMethod("savePage", &WebContents::SavePage)
+      .SetMethod("openDevTools", &WebContents::OpenDevTools)
+      .SetMethod("closeDevTools", &WebContents::CloseDevTools)
+      .SetMethod("isDevToolsOpened", &WebContents::IsDevToolsOpened)
+      .SetMethod("isDevToolsFocused", &WebContents::IsDevToolsFocused)
+      .SetMethod("enableDeviceEmulation",
+                 &WebContents::EnableDeviceEmulation)
+      .SetMethod("disableDeviceEmulation",
+                 &WebContents::DisableDeviceEmulation)
+      .SetMethod("toggleDevTools", &WebContents::ToggleDevTools)
+      .SetMethod("inspectElement", &WebContents::InspectElement)
+      .SetMethod("setAudioMuted", &WebContents::SetAudioMuted)
+      .SetMethod("isAudioMuted", &WebContents::IsAudioMuted)
+      .SetMethod("undo", &WebContents::Undo)
+      .SetMethod("redo", &WebContents::Redo)
+      .SetMethod("cut", &WebContents::Cut)
+      .SetMethod("copy", &WebContents::Copy)
+      .SetMethod("paste", &WebContents::Paste)
+      .SetMethod("pasteAndMatchStyle", &WebContents::PasteAndMatchStyle)
+      .SetMethod("delete", &WebContents::Delete)
+      .SetMethod("selectAll", &WebContents::SelectAll)
+      .SetMethod("unselect", &WebContents::Unselect)
+      .SetMethod("replace", &WebContents::Replace)
+      .SetMethod("replaceMisspelling", &WebContents::ReplaceMisspelling)
+      .SetMethod("findInPage", &WebContents::FindInPage)
+      .SetMethod("stopFindInPage", &WebContents::StopFindInPage)
+      .SetMethod("focus", &WebContents::Focus)
+      .SetMethod("tabTraverse", &WebContents::TabTraverse)
+      .SetMethod("_send", &WebContents::SendIPCMessage)
+      .SetMethod("sendInputEvent", &WebContents::SendInputEvent)
+      .SetMethod("beginFrameSubscription",
+                 &WebContents::BeginFrameSubscription)
+      .SetMethod("endFrameSubscription", &WebContents::EndFrameSubscription)
+      .SetMethod("setSize", &WebContents::SetSize)
+      .SetMethod("isGuest", &WebContents::IsGuest)
+      .SetMethod("getWebPreferences", &WebContents::GetWebPreferences)
+      .SetMethod("getOwnerBrowserWindow", &WebContents::GetOwnerBrowserWindow)
+      .SetMethod("hasServiceWorker", &WebContents::HasServiceWorker)
+      .SetMethod("unregisterServiceWorker",
+                 &WebContents::UnregisterServiceWorker)
+      .SetMethod("inspectServiceWorker", &WebContents::InspectServiceWorker)
+      .SetMethod("print", &WebContents::Print)
+      .SetMethod("_printToPDF", &WebContents::PrintToPDF)
+      .SetMethod("addWorkSpace", &WebContents::AddWorkSpace)
+      .SetMethod("removeWorkSpace", &WebContents::RemoveWorkSpace)
+      .SetProperty("session", &WebContents::Session)
+      .SetProperty("hostWebContents", &WebContents::HostWebContents)
+      .SetProperty("devToolsWebContents", &WebContents::DevToolsWebContents)
+      .SetProperty("debugger", &WebContents::Debugger);
+}
+
+ElectronBrowserContext* WebContents::GetBrowserContext() const {
+  return static_cast<ElectronBrowserContext*>(web_contents()->GetBrowserContext());
+}
+
+void WebContents::OnRendererMessage(const base::string16& channel,
+                                    const base::ListValue& args) {
+  // webContents.emit(channel, new Event(), args...);
+  Emit(base::UTF16ToUTF8(channel), args);
+}
+
+void WebContents::OnRendererMessageSync(const base::string16& channel,
+                                        const base::ListValue& args,
+                                        IPC::Message* message) {
+  // webContents.emit(channel, new Event(sender, message), args...);
+  EmitWithSender(base::UTF16ToUTF8(channel), web_contents(), message, args);
+}
+
+// static
+mate::Handle<WebContents> WebContents::CreateFrom(
+    v8::Isolate* isolate, content::WebContents* web_contents) {
+  // We have an existing WebContents object in JS.
+  auto existing = TrackableObject::FromWrappedClass(isolate, web_contents);
+  if (existing)
+    return mate::CreateHandle(isolate, static_cast<WebContents*>(existing));
+
+  // Otherwise create a new WebContents wrapper object.
+  auto handle = mate::CreateHandle(isolate, new WebContents(web_contents));
+  g_wrap_web_contents.Run(handle.ToV8());
+  return handle;
+}
+
+// static
+mate::Handle<WebContents> WebContents::Create(
+    v8::Isolate* isolate, const mate::Dictionary& options) {
+  auto handle = mate::CreateHandle(isolate, new WebContents(isolate, options));
+  g_wrap_web_contents.Run(handle.ToV8());
+  return handle;
+}
+
+void ClearWrapWebContents() {
+  g_wrap_web_contents.Reset();
+}
+
+void SetWrapWebContents(const WrapWebContentsCallback& callback) {
+  g_wrap_web_contents = callback;
+
+  // Cleanup the wrapper on exit.
+  electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(
+      base::Bind(ClearWrapWebContents));
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.SetMethod("create", &electron::api::WebContents::Create);
+  dict.SetMethod("_setWrapWebContents", &electron::api::SetWrapWebContents);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_web_contents, Initialize)
added in remote
  their  100644 f09e9597d1527a9e114c3de147708582ef6790dd electron/browser/api/electron_api_web_contents.h
@@ -0,0 +1,311 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/frame_subscriber.h"
+#include "electron/browser/api/save_page_handler.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/common_web_contents_delegate.h"
+#include "content/public/browser/web_contents_observer.h"
+#include "content/public/common/favicon_url.h"
+#include "content/common/cursors/webcursor.h"
+#include "native_mate/handle.h"
+#include "ui/gfx/image/image.h"
+
+namespace blink {
+struct WebDeviceEmulationParams;
+}
+
+namespace brightray {
+class InspectableWebContents;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+struct SetSizeParams;
+class ElectronBrowserContext;
+class WebViewGuestDelegate;
+
+namespace api {
+
+class WebContents : public mate::TrackableObject<WebContents>,
+                    public CommonWebContentsDelegate,
+                    public content::WebContentsObserver {
+ public:
+  // For node.js callback function type: function(error, buffer)
+  using PrintToPDFCallback =
+      base::Callback<void(v8::Local<v8::Value>, v8::Local<v8::Value>)>;
+
+  // Create from an existing WebContents.
+  static mate::Handle<WebContents> CreateFrom(
+      v8::Isolate* isolate, content::WebContents* web_contents);
+
+  // Create a new WebContents.
+  static mate::Handle<WebContents> Create(
+      v8::Isolate* isolate, const mate::Dictionary& options);
+
+  int GetID() const;
+  bool Equal(const WebContents* web_contents) const;
+  void LoadURL(const GURL& url, const mate::Dictionary& options);
+  void DownloadURL(const GURL& url);
+  GURL GetURL() const;
+  base::string16 GetTitle() const;
+  bool IsLoading() const;
+  bool IsWaitingForResponse() const;
+  void Stop();
+  void ReloadIgnoringCache();
+  void GoBack();
+  void GoForward();
+  void GoToOffset(int offset);
+  bool IsCrashed() const;
+  void SetUserAgent(const std::string& user_agent);
+  std::string GetUserAgent();
+  void InsertCSS(const std::string& css);
+  bool SavePage(const base::FilePath& full_file_path,
+                const content::SavePageType& save_type,
+                const SavePageHandler::SavePageCallback& callback);
+  void OpenDevTools(mate::Arguments* args);
+  void CloseDevTools();
+  bool IsDevToolsOpened();
+  bool IsDevToolsFocused();
+  void ToggleDevTools();
+  void EnableDeviceEmulation(const blink::WebDeviceEmulationParams& params);
+  void DisableDeviceEmulation();
+  void InspectElement(int x, int y);
+  void InspectServiceWorker();
+  void HasServiceWorker(const base::Callback<void(bool)>&);
+  void UnregisterServiceWorker(const base::Callback<void(bool)>&);
+  void SetAudioMuted(bool muted);
+  bool IsAudioMuted();
+  void Print(mate::Arguments* args);
+
+  // Print current page as PDF.
+  void PrintToPDF(const base::DictionaryValue& setting,
+                  const PrintToPDFCallback& callback);
+
+  // DevTools workspace api.
+  void AddWorkSpace(mate::Arguments* args, const base::FilePath& path);
+  void RemoveWorkSpace(mate::Arguments* args, const base::FilePath& path);
+
+  // Editing commands.
+  void Undo();
+  void Redo();
+  void Cut();
+  void Copy();
+  void Paste();
+  void PasteAndMatchStyle();
+  void Delete();
+  void SelectAll();
+  void Unselect();
+  void Replace(const base::string16& word);
+  void ReplaceMisspelling(const base::string16& word);
+  uint32_t FindInPage(mate::Arguments* args);
+  void StopFindInPage(content::StopFindAction action);
+
+  // Focus.
+  void Focus();
+  void TabTraverse(bool reverse);
+
+  // Send messages to browser.
+  bool SendIPCMessage(const base::string16& channel,
+                      const base::ListValue& args);
+
+  // Send WebInputEvent to the page.
+  void SendInputEvent(v8::Isolate* isolate, v8::Local<v8::Value> input_event);
+
+  // Subscribe to the frame updates.
+  void BeginFrameSubscription(
+      const FrameSubscriber::FrameCaptureCallback& callback);
+  void EndFrameSubscription();
+
+  // Methods for creating <webview>.
+  void SetSize(const SetSizeParams& params);
+  bool IsGuest() const;
+
+  // Callback triggered on permission response.
+  void OnEnterFullscreenModeForTab(content::WebContents* source,
+                                   const GURL& origin,
+                                   bool allowed);
+
+  // Returns the web preferences of current WebContents.
+  v8::Local<v8::Value> GetWebPreferences(v8::Isolate* isolate);
+
+  // Returns the owner window.
+  v8::Local<v8::Value> GetOwnerBrowserWindow();
+
+  // Properties.
+  v8::Local<v8::Value> Session(v8::Isolate* isolate);
+  content::WebContents* HostWebContents();
+  v8::Local<v8::Value> DevToolsWebContents(v8::Isolate* isolate);
+  v8::Local<v8::Value> Debugger(v8::Isolate* isolate);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit WebContents(content::WebContents* web_contents);
+  WebContents(v8::Isolate* isolate, const mate::Dictionary& options);
+  ~WebContents();
+
+  // content::WebContentsDelegate:
+  bool AddMessageToConsole(content::WebContents* source,
+                           int32_t level,
+                           const base::string16& message,
+                           int32_t line_no,
+                           const base::string16& source_id) override;
+  bool ShouldCreateWebContents(
+      content::WebContents* web_contents,
+      int32_t route_id,
+      int32_t main_frame_route_id,
+      int32_t main_frame_widget_route_id,
+      WindowContainerType window_container_type,
+      const std::string& frame_name,
+      const GURL& target_url,
+      const std::string& partition_id,
+      content::SessionStorageNamespace* session_storage_namespace) override;
+  content::WebContents* OpenURLFromTab(
+      content::WebContents* source,
+      const content::OpenURLParams& params) override;
+  void BeforeUnloadFired(content::WebContents* tab,
+                         bool proceed,
+                         bool* proceed_to_fire_unload) override;
+  void MoveContents(content::WebContents* source,
+                    const gfx::Rect& pos) override;
+  void CloseContents(content::WebContents* source) override;
+  void ActivateContents(content::WebContents* contents) override;
+  bool IsPopupOrPanel(const content::WebContents* source) const override;
+  void HandleKeyboardEvent(
+      content::WebContents* source,
+      const content::NativeWebKeyboardEvent& event) override;
+  void EnterFullscreenModeForTab(content::WebContents* source,
+                                 const GURL& origin) override;
+  void ExitFullscreenModeForTab(content::WebContents* source) override;
+  void RendererUnresponsive(content::WebContents* source) override;
+  void RendererResponsive(content::WebContents* source) override;
+  bool HandleContextMenu(const content::ContextMenuParams& params) override;
+  bool OnGoToEntryOffset(int offset) override;
+  void FindReply(content::WebContents* web_contents,
+                 int request_id,
+                 int number_of_matches,
+                 const gfx::Rect& selection_rect,
+                 int active_match_ordinal,
+                 bool final_update) override;
+  bool CheckMediaAccessPermission(
+      content::WebContents* web_contents,
+      const GURL& security_origin,
+      content::MediaStreamType type) override;
+  void RequestMediaAccessPermission(
+      content::WebContents* web_contents,
+      const content::MediaStreamRequest& request,
+      const content::MediaResponseCallback& callback) override;
+  void RequestToLockMouse(
+      content::WebContents* web_contents,
+      bool user_gesture,
+      bool last_unlocked_by_target) override;
+
+  // content::WebContentsObserver:
+  void BeforeUnloadFired(const base::TimeTicks& proceed_time) override;
+  void RenderViewDeleted(content::RenderViewHost*) override;
+  void RenderProcessGone(base::TerminationStatus status) override;
+  void DocumentLoadedInFrame(
+      content::RenderFrameHost* render_frame_host) override;
+  void DidFinishLoad(content::RenderFrameHost* render_frame_host,
+                     const GURL& validated_url) override;
+  void DidFailLoad(content::RenderFrameHost* render_frame_host,
+                   const GURL& validated_url,
+                   int error_code,
+                   const base::string16& error_description,
+                   bool was_ignored_by_handler) override;
+  void DidFailProvisionalLoad(content::RenderFrameHost* render_frame_host,
+                              const GURL& validated_url,
+                              int error_code,
+                              const base::string16& error_description,
+                              bool was_ignored_by_handler) override;
+  void DidStartLoading() override;
+  void DidStopLoading() override;
+  void DidGetResourceResponseStart(
+      const content::ResourceRequestDetails& details) override;
+  void DidGetRedirectForResourceRequest(
+      content::RenderFrameHost* render_frame_host,
+      const content::ResourceRedirectDetails& details) override;
+  void DidNavigateMainFrame(
+      const content::LoadCommittedDetails& details,
+      const content::FrameNavigateParams& params) override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+  void WebContentsDestroyed() override;
+  void NavigationEntryCommitted(
+      const content::LoadCommittedDetails& load_details) override;
+  void TitleWasSet(content::NavigationEntry* entry, bool explicit_set) override;
+  void DidUpdateFaviconURL(
+      const std::vector<content::FaviconURL>& urls) override;
+  void PluginCrashed(const base::FilePath& plugin_path,
+                     base::ProcessId plugin_pid) override;
+  void MediaStartedPlaying(const MediaPlayerId& id) override;
+  void MediaStoppedPlaying(const MediaPlayerId& id) override;
+  void DidChangeThemeColor(SkColor theme_color) override;
+
+  // brightray::InspectableWebContentsViewDelegate:
+  void DevToolsFocused() override;
+  void DevToolsOpened() override;
+  void DevToolsClosed() override;
+
+ private:
+  enum Type {
+    BROWSER_WINDOW,  // Used by BrowserWindow.
+    WEB_VIEW,  // Used by <webview>.
+    REMOTE,  // Thin wrap around an existing WebContents.
+  };
+
+  ElectronBrowserContext* GetBrowserContext() const;
+
+  uint32_t GetNextRequestId() {
+    return ++request_id_;
+  }
+
+  // Called when we receive a CursorChange message from chromium.
+  void OnCursorChange(const content::WebCursor& cursor);
+
+  // Called when received a message from renderer.
+  void OnRendererMessage(const base::string16& channel,
+                         const base::ListValue& args);
+
+  // Called when received a synchronous message from renderer.
+  void OnRendererMessageSync(const base::string16& channel,
+                             const base::ListValue& args,
+                             IPC::Message* message);
+
+  v8::Global<v8::Value> session_;
+  v8::Global<v8::Value> devtools_web_contents_;
+  v8::Global<v8::Value> debugger_;
+
+  scoped_ptr<WebViewGuestDelegate> guest_delegate_;
+
+  // The host webcontents that may contain this webcontents.
+  WebContents* embedder_;
+
+  // The type of current WebContents.
+  Type type_;
+
+  // Request id used for findInPage request.
+  uint32_t request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContents);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WEB_CONTENTS_H_
added in remote
  their  100644 36ec558ef11671cb3177ed3ce0db619816f6d6c8 electron/browser/api/electron_api_web_request.cc
@@ -0,0 +1,119 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_request.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "content/public/browser/browser_thread.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+template<>
+struct Converter<extensions::URLPattern> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     extensions::URLPattern* out) {
+    std::string pattern;
+    if (!ConvertFromV8(isolate, val, &pattern))
+      return false;
+    return out->Parse(pattern) == extensions::URLPattern::PARSE_SUCCESS;
+  }
+};
+
+}  // namespace mate
+
+namespace electron {
+
+namespace api {
+
+WebRequest::WebRequest(ElectronBrowserContext* browser_context)
+    : browser_context_(browser_context) {
+}
+
+WebRequest::~WebRequest() {
+}
+
+template<ElectronNetworkDelegate::SimpleEvent type>
+void WebRequest::SetSimpleListener(mate::Arguments* args) {
+  SetListener<ElectronNetworkDelegate::SimpleListener>(
+      &ElectronNetworkDelegate::SetSimpleListenerInIO, type, args);
+}
+
+template<ElectronNetworkDelegate::ResponseEvent type>
+void WebRequest::SetResponseListener(mate::Arguments* args) {
+  SetListener<ElectronNetworkDelegate::ResponseListener>(
+      &ElectronNetworkDelegate::SetResponseListenerInIO, type, args);
+}
+
+template<typename Listener, typename Method, typename Event>
+void WebRequest::SetListener(Method method, Event type, mate::Arguments* args) {
+  // { urls }.
+  URLPatterns patterns;
+  mate::Dictionary dict;
+  args->GetNext(&dict) && dict.Get("urls", &patterns);
+
+  // Function or null.
+  v8::Local<v8::Value> value;
+  Listener listener;
+  if (!args->GetNext(&listener) &&
+      !(args->GetNext(&value) && value->IsNull())) {
+    args->ThrowError("Must pass null or a Function");
+    return;
+  }
+
+  auto delegate = browser_context_->network_delegate();
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::Bind(method, base::Unretained(delegate), type,
+                                     patterns, listener));
+}
+
+// static
+mate::Handle<WebRequest> WebRequest::Create(
+    v8::Isolate* isolate,
+    ElectronBrowserContext* browser_context) {
+  return mate::CreateHandle(isolate, new WebRequest(browser_context));
+}
+
+// static
+void WebRequest::BuildPrototype(v8::Isolate* isolate,
+                                v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("onBeforeRequest",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnBeforeRequest>)
+      .SetMethod("onBeforeSendHeaders",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnBeforeSendHeaders>)
+      .SetMethod("onHeadersReceived",
+                 &WebRequest::SetResponseListener<
+                    ElectronNetworkDelegate::kOnHeadersReceived>)
+      .SetMethod("onSendHeaders",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnSendHeaders>)
+      .SetMethod("onBeforeRedirect",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnBeforeRedirect>)
+      .SetMethod("onResponseStarted",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnResponseStarted>)
+      .SetMethod("onCompleted",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnCompleted>)
+      .SetMethod("onErrorOccurred",
+                 &WebRequest::SetSimpleListener<
+                    ElectronNetworkDelegate::kOnErrorOccurred>);
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 3005158188cbd7ed36cc99afc41967271f94a6a6 electron/browser/api/electron_api_web_request.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "native_mate/arguments.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+namespace api {
+
+class WebRequest : public mate::TrackableObject<WebRequest> {
+ public:
+  static mate::Handle<WebRequest> Create(v8::Isolate* isolate,
+                                         ElectronBrowserContext* browser_context);
+
+  // mate::TrackableObject:
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  explicit WebRequest(ElectronBrowserContext* browser_context);
+  ~WebRequest();
+
+  // C++ can not distinguish overloaded member function.
+  template<ElectronNetworkDelegate::SimpleEvent type>
+  void SetSimpleListener(mate::Arguments* args);
+  template<ElectronNetworkDelegate::ResponseEvent type>
+  void SetResponseListener(mate::Arguments* args);
+  template<typename Listener, typename Method, typename Event>
+  void SetListener(Method method, Event type, mate::Arguments* args);
+
+ private:
+  scoped_refptr<ElectronBrowserContext> browser_context_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebRequest);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WEB_REQUEST_H_
added in remote
  their  100644 8596ac2369a3f6515cd799a0ec8dd250dc3b639f electron/browser/api/electron_api_web_view_manager.cc
@@ -0,0 +1,71 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/web_view_manager.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "content/public/browser/browser_context.h"
+#include "native_mate/dictionary.h"
+
+using electron::WebContentsPreferences;
+
+namespace mate {
+
+template<>
+struct Converter<content::WebContents*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::WebContents** out) {
+    electron::api::WebContents* contents;
+    if (!Converter<electron::api::WebContents*>::FromV8(isolate, val, &contents))
+      return false;
+    *out = contents->web_contents();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+electron::WebViewManager* GetWebViewManager(content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  if (context) {
+    auto manager = context->GetGuestManager();
+    return static_cast<electron::WebViewManager*>(manager);
+  } else {
+    return nullptr;
+  }
+}
+
+void AddGuest(int guest_instance_id,
+              int element_instance_id,
+              content::WebContents* embedder,
+              content::WebContents* guest_web_contents,
+              const base::DictionaryValue& options) {
+  auto manager = GetWebViewManager(embedder);
+  if (manager)
+    manager->AddGuest(guest_instance_id, element_instance_id, embedder,
+                      guest_web_contents);
+
+  WebContentsPreferences::FromWebContents(guest_web_contents)->Merge(options);
+}
+
+void RemoveGuest(content::WebContents* embedder, int guest_instance_id) {
+  auto manager = GetWebViewManager(embedder);
+  if (manager)
+    manager->RemoveGuest(guest_instance_id);
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("addGuest", &AddGuest);
+  dict.SetMethod("removeGuest", &RemoveGuest);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_web_view_manager, Initialize)
added in remote
  their  100644 f9994cdc079e2e9159e3328d7bc465e20ef3a5b1 electron/browser/api/electron_api_window.cc
@@ -0,0 +1,848 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/electron_api_window.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+
+#include "electron/browser/api/electron_api_menu.h"
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "content/public/browser/render_process_host.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/geometry/rect.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/native_window_views.h"
+#include "electron/browser/ui/win/taskbar_host.h"
+#endif
+
+#if defined(OS_WIN)
+namespace mate {
+
+template<>
+struct Converter<electron::TaskbarHost::ThumbarButton> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     electron::TaskbarHost::ThumbarButton* out) {
+    mate::Dictionary dict;
+    if (!ConvertFromV8(isolate, val, &dict))
+      return false;
+    dict.Get("click", &(out->clicked_callback));
+    dict.Get("tooltip", &(out->tooltip));
+    dict.Get("flags", &out->flags);
+    return dict.Get("icon", &(out->icon));
+  }
+};
+
+}  // namespace mate
+#endif
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+// This function is implemented in JavaScript
+using DeprecatedOptionsCheckCallback =
+    base::Callback<std::string(v8::Local<v8::Value>)>;
+DeprecatedOptionsCheckCallback g_deprecated_options_check;
+
+void OnCapturePageDone(
+    v8::Isolate* isolate,
+    const base::Callback<void(const gfx::Image&)>& callback,
+    const SkBitmap& bitmap) {
+  v8::Locker locker(isolate);
+  v8::HandleScope handle_scope(isolate);
+  callback.Run(gfx::Image::CreateFrom1xBitmap(bitmap));
+}
+
+// Converts min-width to minWidth, returns false if no conversion is needed.
+bool TranslateOldKey(const std::string& key, std::string* new_key) {
+  if (key.find('-') == std::string::npos)
+    return false;
+  new_key->reserve(key.size());
+  bool next_upper_case = false;
+  for (char c : key) {
+    if (c == '-') {
+      next_upper_case = true;
+    } else if (next_upper_case) {
+      new_key->push_back(base::ToUpperASCII(c));
+      next_upper_case = false;
+    } else {
+      new_key->push_back(c);
+    }
+  }
+  return true;
+}
+
+// Converts min-width to minWidth recursively in the dictionary.
+void TranslateOldOptions(v8::Isolate* isolate, v8::Local<v8::Object> options) {
+  auto context = isolate->GetCurrentContext();
+  auto maybe_keys = options->GetOwnPropertyNames(context);
+  if (maybe_keys.IsEmpty())
+    return;
+  std::vector<std::string> keys;
+  if (!mate::ConvertFromV8(isolate, maybe_keys.ToLocalChecked(), &keys))
+    return;
+  mate::Dictionary dict(isolate, options);
+  for (const auto& key : keys) {
+    v8::Local<v8::Value> value;
+    if (!dict.Get(key, &value))  // Shouldn't happen, but guard it anyway.
+      continue;
+    // Go recursively.
+    v8::Local<v8::Object> sub_options;
+    if (mate::ConvertFromV8(isolate, value, &sub_options))
+      TranslateOldOptions(isolate, sub_options);
+    // Translate key.
+    std::string new_key;
+    if (TranslateOldKey(key, &new_key)) {
+      dict.Set(new_key, value);
+      dict.Delete(key);
+    }
+  }
+}
+
+// Converts binary data to Buffer.
+v8::Local<v8::Value> ToBuffer(v8::Isolate* isolate, void* val, int size) {
+  auto buffer = node::Buffer::Copy(isolate, static_cast<char*>(val), size);
+  if (buffer.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return buffer.ToLocalChecked();
+}
+
+}  // namespace
+
+
+Window::Window(v8::Isolate* isolate, const mate::Dictionary& options) {
+  // Be compatible with old style field names like min-width.
+  TranslateOldOptions(isolate, options.GetHandle());
+
+  // Use options.webPreferences to create WebContents.
+  mate::Dictionary web_preferences = mate::Dictionary::CreateEmpty(isolate);
+  options.Get(options::kWebPreferences, &web_preferences);
+
+  // Be compatible with old options which are now in web_preferences.
+  v8::Local<v8::Value> value;
+  if (options.Get(options::kNodeIntegration, &value))
+    web_preferences.Set(options::kNodeIntegration, value);
+  if (options.Get(options::kPreloadScript, &value))
+    web_preferences.Set(options::kPreloadScript, value);
+  if (options.Get(options::kZoomFactor, &value))
+    web_preferences.Set(options::kZoomFactor, value);
+
+  // Creates the WebContents used by BrowserWindow.
+  auto web_contents = WebContents::Create(isolate, web_preferences);
+  web_contents_.Reset(isolate, web_contents.ToV8());
+  api_web_contents_ = web_contents.get();
+
+  // Keep a copy of the options for later use.
+  mate::Dictionary(isolate, web_contents->GetWrapper(isolate)).Set(
+      "browserWindowOptions", options);
+
+  // Creates BrowserWindow.
+  window_.reset(NativeWindow::Create(web_contents->managed_web_contents(),
+                                     options));
+  web_contents->SetOwnerWindow(window_.get());
+  window_->InitFromOptions(options);
+  window_->AddObserver(this);
+  AttachAsUserData(window_.get());
+}
+
+Window::~Window() {
+  if (!window_->IsClosed())
+    window_->CloseContents(nullptr);
+
+  // Destroy the native window in next tick because the native code might be
+  // iterating all windows.
+  base::MessageLoop::current()->DeleteSoon(FROM_HERE, window_.release());
+}
+
+void Window::WillCloseWindow(bool* prevent_default) {
+  *prevent_default = Emit("close");
+}
+
+void Window::OnWindowClosed() {
+  api_web_contents_->DestroyWebContents();
+
+  RemoveFromWeakMap();
+  window_->RemoveObserver(this);
+
+  // We can not call Destroy here because we need to call Emit first, but we
+  // also do not want any method to be used, so just mark as destroyed here.
+  MarkDestroyed();
+
+  Emit("closed");
+
+  // Destroy the native class when window is closed.
+  base::MessageLoop::current()->PostTask(FROM_HERE, GetDestroyClosure());
+}
+
+void Window::OnWindowBlur() {
+  Emit("blur");
+}
+
+void Window::OnWindowFocus() {
+  Emit("focus");
+}
+
+void Window::OnWindowShow() {
+  Emit("show");
+}
+
+void Window::OnWindowHide() {
+  Emit("hide");
+}
+
+void Window::OnWindowMaximize() {
+  Emit("maximize");
+}
+
+void Window::OnWindowUnmaximize() {
+  Emit("unmaximize");
+}
+
+void Window::OnWindowMinimize() {
+  Emit("minimize");
+}
+
+void Window::OnWindowRestore() {
+  Emit("restore");
+}
+
+void Window::OnWindowResize() {
+  Emit("resize");
+}
+
+void Window::OnWindowMove() {
+  Emit("move");
+}
+
+void Window::OnWindowMoved() {
+  Emit("moved");
+}
+
+void Window::OnWindowEnterFullScreen() {
+  Emit("enter-full-screen");
+}
+
+void Window::OnWindowLeaveFullScreen() {
+  Emit("leave-full-screen");
+}
+
+void Window::OnWindowScrollTouchBegin() {
+  Emit("scroll-touch-begin");
+}
+
+void Window::OnWindowScrollTouchEnd() {
+  Emit("scroll-touch-end");
+}
+
+void Window::OnWindowSwipe(const std::string& direction) {
+  Emit("swipe", direction);
+}
+
+void Window::OnWindowEnterHtmlFullScreen() {
+  Emit("enter-html-full-screen");
+}
+
+void Window::OnWindowLeaveHtmlFullScreen() {
+  Emit("leave-html-full-screen");
+}
+
+void Window::OnRendererUnresponsive() {
+  Emit("unresponsive");
+}
+
+void Window::OnRendererResponsive() {
+  Emit("responsive");
+}
+
+void Window::OnExecuteWindowsCommand(const std::string& command_name) {
+  Emit("app-command", command_name);
+}
+
+#if defined(OS_WIN)
+void Window::OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {
+  if (IsWindowMessageHooked(message)) {
+    messages_callback_map_[message].Run(
+        ToBuffer(isolate(), static_cast<void*>(&w_param), sizeof(WPARAM)),
+        ToBuffer(isolate(), static_cast<void*>(&l_param), sizeof(LPARAM)));
+  }
+}
+#endif
+
+// static
+mate::Wrappable* Window::New(v8::Isolate* isolate, mate::Arguments* args) {
+  if (!Browser::Get()->is_ready()) {
+    isolate->ThrowException(v8::Exception::Error(mate::StringToV8(
+        isolate, "Cannot create BrowserWindow before app is ready")));
+    return nullptr;
+  }
+
+  if (args->Length() > 1) {
+    args->ThrowError();
+    return nullptr;
+  }
+
+  mate::Dictionary options;
+  if (!(args->Length() == 1 && args->GetNext(&options))) {
+    options = mate::Dictionary::CreateEmpty(isolate);
+  }
+
+  std::string deprecation_message = g_deprecated_options_check.Run(
+      options.GetHandle());
+  if (deprecation_message.length() > 0) {
+    args->ThrowError(deprecation_message);
+    return nullptr;
+  }
+
+  return new Window(isolate, options);
+}
+
+void Window::Close() {
+  window_->Close();
+}
+
+void Window::Focus() {
+  window_->Focus(true);
+}
+
+void Window::Blur() {
+  window_->Focus(false);
+}
+
+bool Window::IsFocused() {
+  return window_->IsFocused();
+}
+
+void Window::Show() {
+  window_->Show();
+}
+
+void Window::ShowInactive() {
+  window_->ShowInactive();
+}
+
+void Window::Hide() {
+  window_->Hide();
+}
+
+bool Window::IsVisible() {
+  return window_->IsVisible();
+}
+
+void Window::Maximize() {
+  window_->Maximize();
+}
+
+void Window::Unmaximize() {
+  window_->Unmaximize();
+}
+
+bool Window::IsMaximized() {
+  return window_->IsMaximized();
+}
+
+void Window::Minimize() {
+  window_->Minimize();
+}
+
+void Window::Restore() {
+  window_->Restore();
+}
+
+bool Window::IsMinimized() {
+  return window_->IsMinimized();
+}
+
+void Window::SetFullScreen(bool fullscreen) {
+  window_->SetFullScreen(fullscreen);
+}
+
+bool Window::IsFullscreen() {
+  return window_->IsFullscreen();
+}
+
+void Window::SetBounds(const gfx::Rect& bounds, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetBounds(bounds, animate);
+}
+
+gfx::Rect Window::GetBounds() {
+  return window_->GetBounds();
+}
+
+void Window::SetSize(int width, int height, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetSize(gfx::Size(width, height), animate);
+}
+
+std::vector<int> Window::GetSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetContentSize(int width, int height, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetContentSize(gfx::Size(width, height), animate);
+}
+
+std::vector<int> Window::GetContentSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetContentSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetMinimumSize(int width, int height) {
+  window_->SetMinimumSize(gfx::Size(width, height));
+}
+
+std::vector<int> Window::GetMinimumSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetMinimumSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetMaximumSize(int width, int height) {
+  window_->SetMaximumSize(gfx::Size(width, height));
+}
+
+std::vector<int> Window::GetMaximumSize() {
+  std::vector<int> result(2);
+  gfx::Size size = window_->GetMaximumSize();
+  result[0] = size.width();
+  result[1] = size.height();
+  return result;
+}
+
+void Window::SetResizable(bool resizable) {
+  window_->SetResizable(resizable);
+}
+
+bool Window::IsResizable() {
+  return window_->IsResizable();
+}
+
+void Window::SetMovable(bool movable) {
+  window_->SetMovable(movable);
+}
+
+bool Window::IsMovable() {
+  return window_->IsMovable();
+}
+
+void Window::SetMinimizable(bool minimizable) {
+  window_->SetMinimizable(minimizable);
+}
+
+bool Window::IsMinimizable() {
+  return window_->IsMinimizable();
+}
+
+void Window::SetMaximizable(bool maximizable) {
+  window_->SetMaximizable(maximizable);
+}
+
+bool Window::IsMaximizable() {
+  return window_->IsMaximizable();
+}
+
+void Window::SetFullScreenable(bool fullscreenable) {
+  window_->SetFullScreenable(fullscreenable);
+}
+
+bool Window::IsFullScreenable() {
+  return window_->IsFullScreenable();
+}
+
+void Window::SetClosable(bool closable) {
+  window_->SetClosable(closable);
+}
+
+bool Window::IsClosable() {
+  return window_->IsClosable();
+}
+
+void Window::SetAlwaysOnTop(bool top) {
+  window_->SetAlwaysOnTop(top);
+}
+
+bool Window::IsAlwaysOnTop() {
+  return window_->IsAlwaysOnTop();
+}
+
+void Window::Center() {
+  window_->Center();
+}
+
+void Window::SetPosition(int x, int y, mate::Arguments* args) {
+  bool animate = false;
+  args->GetNext(&animate);
+  window_->SetPosition(gfx::Point(x, y), animate);
+}
+
+std::vector<int> Window::GetPosition() {
+  std::vector<int> result(2);
+  gfx::Point pos = window_->GetPosition();
+  result[0] = pos.x();
+  result[1] = pos.y();
+  return result;
+}
+
+void Window::SetTitle(const std::string& title) {
+  window_->SetTitle(title);
+}
+
+std::string Window::GetTitle() {
+  return window_->GetTitle();
+}
+
+void Window::FlashFrame(bool flash) {
+  window_->FlashFrame(flash);
+}
+
+void Window::SetSkipTaskbar(bool skip) {
+  window_->SetSkipTaskbar(skip);
+}
+
+void Window::SetKiosk(bool kiosk) {
+  window_->SetKiosk(kiosk);
+}
+
+bool Window::IsKiosk() {
+  return window_->IsKiosk();
+}
+
+void Window::SetBackgroundColor(const std::string& color_name) {
+  window_->SetBackgroundColor(color_name);
+}
+
+void Window::SetHasShadow(bool has_shadow) {
+  window_->SetHasShadow(has_shadow);
+}
+
+bool Window::HasShadow() {
+  return window_->HasShadow();
+}
+
+void Window::FocusOnWebView() {
+  window_->FocusOnWebView();
+}
+
+void Window::BlurWebView() {
+  window_->BlurWebView();
+}
+
+bool Window::IsWebViewFocused() {
+  return window_->IsWebViewFocused();
+}
+
+void Window::SetRepresentedFilename(const std::string& filename) {
+  window_->SetRepresentedFilename(filename);
+}
+
+std::string Window::GetRepresentedFilename() {
+  return window_->GetRepresentedFilename();
+}
+
+void Window::SetDocumentEdited(bool edited) {
+  window_->SetDocumentEdited(edited);
+}
+
+bool Window::IsDocumentEdited() {
+  return window_->IsDocumentEdited();
+}
+
+void Window::SetIgnoreMouseEvents(bool ignore) {
+  return window_->SetIgnoreMouseEvents(ignore);
+}
+
+void Window::CapturePage(mate::Arguments* args) {
+  gfx::Rect rect;
+  base::Callback<void(const gfx::Image&)> callback;
+
+  if (!(args->Length() == 1 && args->GetNext(&callback)) &&
+      !(args->Length() == 2 && args->GetNext(&rect)
+                            && args->GetNext(&callback))) {
+    args->ThrowError();
+    return;
+  }
+
+  window_->CapturePage(
+      rect, base::Bind(&OnCapturePageDone, args->isolate(), callback));
+}
+
+void Window::SetProgressBar(double progress) {
+  window_->SetProgressBar(progress);
+}
+
+void Window::SetOverlayIcon(const gfx::Image& overlay,
+                            const std::string& description) {
+  window_->SetOverlayIcon(overlay, description);
+}
+
+bool Window::SetThumbarButtons(mate::Arguments* args) {
+#if defined(OS_WIN)
+  std::vector<TaskbarHost::ThumbarButton> buttons;
+  if (!args->GetNext(&buttons)) {
+    args->ThrowError();
+    return false;
+  }
+  auto window = static_cast<NativeWindowViews*>(window_.get());
+  return window->taskbar_host().SetThumbarButtons(
+      window->GetAcceleratedWidget(), buttons);
+#else
+  return false;
+#endif
+}
+
+void Window::SetMenu(v8::Isolate* isolate, v8::Local<v8::Value> value) {
+  mate::Handle<Menu> menu;
+  if (value->IsObject() &&
+      mate::V8ToString(value->ToObject()->GetConstructorName()) == "Menu" &&
+      mate::ConvertFromV8(isolate, value, &menu)) {
+    menu_.Reset(isolate, menu.ToV8());
+    window_->SetMenu(menu->model());
+  } else if (value->IsNull()) {
+    menu_.Reset();
+    window_->SetMenu(nullptr);
+  } else {
+    isolate->ThrowException(v8::Exception::TypeError(
+        mate::StringToV8(isolate, "Invalid Menu")));
+  }
+}
+
+void Window::SetAutoHideMenuBar(bool auto_hide) {
+  window_->SetAutoHideMenuBar(auto_hide);
+}
+
+bool Window::IsMenuBarAutoHide() {
+  return window_->IsMenuBarAutoHide();
+}
+
+void Window::SetMenuBarVisibility(bool visible) {
+  window_->SetMenuBarVisibility(visible);
+}
+
+bool Window::IsMenuBarVisible() {
+  return window_->IsMenuBarVisible();
+}
+
+#if defined(OS_WIN)
+bool Window::HookWindowMessage(UINT message,
+                               const MessageCallback& callback) {
+  messages_callback_map_[message] = callback;
+  return true;
+}
+
+void Window::UnhookWindowMessage(UINT message) {
+  if (!ContainsKey(messages_callback_map_, message))
+    return;
+
+  messages_callback_map_.erase(message);
+}
+
+bool Window::IsWindowMessageHooked(UINT message) {
+  return ContainsKey(messages_callback_map_, message);
+}
+
+void Window::UnhookAllWindowMessages() {
+  messages_callback_map_.clear();
+}
+#endif
+
+#if defined(OS_MACOSX)
+void Window::ShowDefinitionForSelection() {
+  window_->ShowDefinitionForSelection();
+}
+#endif
+
+void Window::SetAspectRatio(double aspect_ratio, mate::Arguments* args) {
+  gfx::Size extra_size;
+  args->GetNext(&extra_size);
+  window_->SetAspectRatio(aspect_ratio, extra_size);
+}
+
+v8::Local<v8::Value> Window::GetNativeWindowHandle() {
+  gfx::AcceleratedWidget handle = window_->GetAcceleratedWidget();
+  return ToBuffer(
+      isolate(), static_cast<void*>(&handle), sizeof(gfx::AcceleratedWidget));
+}
+
+void Window::SetVisibleOnAllWorkspaces(bool visible) {
+  return window_->SetVisibleOnAllWorkspaces(visible);
+}
+
+bool Window::IsVisibleOnAllWorkspaces() {
+  return window_->IsVisibleOnAllWorkspaces();
+}
+
+int32_t Window::ID() const {
+  return weak_map_id();
+}
+
+v8::Local<v8::Value> Window::WebContents(v8::Isolate* isolate) {
+  if (web_contents_.IsEmpty())
+    return v8::Null(isolate);
+  else
+    return v8::Local<v8::Value>::New(isolate, web_contents_);
+}
+
+// static
+void Window::BuildPrototype(v8::Isolate* isolate,
+                            v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .MakeDestroyable()
+      .SetMethod("close", &Window::Close)
+      .SetMethod("focus", &Window::Focus)
+      .SetMethod("blur", &Window::Blur)
+      .SetMethod("isFocused", &Window::IsFocused)
+      .SetMethod("show", &Window::Show)
+      .SetMethod("showInactive", &Window::ShowInactive)
+      .SetMethod("hide", &Window::Hide)
+      .SetMethod("isVisible", &Window::IsVisible)
+      .SetMethod("maximize", &Window::Maximize)
+      .SetMethod("unmaximize", &Window::Unmaximize)
+      .SetMethod("isMaximized", &Window::IsMaximized)
+      .SetMethod("minimize", &Window::Minimize)
+      .SetMethod("restore", &Window::Restore)
+      .SetMethod("isMinimized", &Window::IsMinimized)
+      .SetMethod("setFullScreen", &Window::SetFullScreen)
+      .SetMethod("isFullScreen", &Window::IsFullscreen)
+      .SetMethod("setAspectRatio", &Window::SetAspectRatio)
+      .SetMethod("getNativeWindowHandle", &Window::GetNativeWindowHandle)
+      .SetMethod("getBounds", &Window::GetBounds)
+      .SetMethod("setBounds", &Window::SetBounds)
+      .SetMethod("getSize", &Window::GetSize)
+      .SetMethod("setSize", &Window::SetSize)
+      .SetMethod("getContentSize", &Window::GetContentSize)
+      .SetMethod("setContentSize", &Window::SetContentSize)
+      .SetMethod("setMinimumSize", &Window::SetMinimumSize)
+      .SetMethod("getMinimumSize", &Window::GetMinimumSize)
+      .SetMethod("setMaximumSize", &Window::SetMaximumSize)
+      .SetMethod("getMaximumSize", &Window::GetMaximumSize)
+      .SetMethod("setResizable", &Window::SetResizable)
+      .SetMethod("isResizable", &Window::IsResizable)
+      .SetMethod("setMovable", &Window::SetMovable)
+      .SetMethod("isMovable", &Window::IsMovable)
+      .SetMethod("setMinimizable", &Window::SetMinimizable)
+      .SetMethod("isMinimizable", &Window::IsMinimizable)
+      .SetMethod("setMaximizable", &Window::SetMaximizable)
+      .SetMethod("isMaximizable", &Window::IsMaximizable)
+      .SetMethod("setFullScreenable", &Window::SetFullScreenable)
+      .SetMethod("isFullScreenable", &Window::IsFullScreenable)
+      .SetMethod("setClosable", &Window::SetClosable)
+      .SetMethod("isClosable", &Window::IsClosable)
+      .SetMethod("setAlwaysOnTop", &Window::SetAlwaysOnTop)
+      .SetMethod("isAlwaysOnTop", &Window::IsAlwaysOnTop)
+      .SetMethod("center", &Window::Center)
+      .SetMethod("setPosition", &Window::SetPosition)
+      .SetMethod("getPosition", &Window::GetPosition)
+      .SetMethod("setTitle", &Window::SetTitle)
+      .SetMethod("getTitle", &Window::GetTitle)
+      .SetMethod("flashFrame", &Window::FlashFrame)
+      .SetMethod("setSkipTaskbar", &Window::SetSkipTaskbar)
+      .SetMethod("setKiosk", &Window::SetKiosk)
+      .SetMethod("isKiosk", &Window::IsKiosk)
+      .SetMethod("setBackgroundColor", &Window::SetBackgroundColor)
+      .SetMethod("setHasShadow", &Window::SetHasShadow)
+      .SetMethod("hasShadow", &Window::HasShadow)
+      .SetMethod("setRepresentedFilename", &Window::SetRepresentedFilename)
+      .SetMethod("getRepresentedFilename", &Window::GetRepresentedFilename)
+      .SetMethod("setDocumentEdited", &Window::SetDocumentEdited)
+      .SetMethod("isDocumentEdited", &Window::IsDocumentEdited)
+      .SetMethod("setIgnoreMouseEvents", &Window::SetIgnoreMouseEvents)
+      .SetMethod("focusOnWebView", &Window::FocusOnWebView)
+      .SetMethod("blurWebView", &Window::BlurWebView)
+      .SetMethod("isWebViewFocused", &Window::IsWebViewFocused)
+      .SetMethod("capturePage", &Window::CapturePage)
+      .SetMethod("setProgressBar", &Window::SetProgressBar)
+      .SetMethod("setOverlayIcon", &Window::SetOverlayIcon)
+      .SetMethod("setThumbarButtons", &Window::SetThumbarButtons)
+      .SetMethod("setMenu", &Window::SetMenu)
+      .SetMethod("setAutoHideMenuBar", &Window::SetAutoHideMenuBar)
+      .SetMethod("isMenuBarAutoHide", &Window::IsMenuBarAutoHide)
+      .SetMethod("setMenuBarVisibility", &Window::SetMenuBarVisibility)
+      .SetMethod("isMenuBarVisible", &Window::IsMenuBarVisible)
+      .SetMethod("setVisibleOnAllWorkspaces",
+                 &Window::SetVisibleOnAllWorkspaces)
+      .SetMethod("isVisibleOnAllWorkspaces",
+                 &Window::IsVisibleOnAllWorkspaces)
+#if defined(OS_WIN)
+      .SetMethod("hookWindowMessage", &Window::HookWindowMessage)
+      .SetMethod("isWindowMessageHooked", &Window::IsWindowMessageHooked)
+      .SetMethod("unhookWindowMessage", &Window::UnhookWindowMessage)
+      .SetMethod("unhookAllWindowMessages", &Window::UnhookAllWindowMessages)
+#endif
+#if defined(OS_MACOSX)
+      .SetMethod("showDefinitionForSelection",
+                 &Window::ShowDefinitionForSelection)
+#endif
+      .SetProperty("id", &Window::ID)
+      .SetProperty("webContents", &Window::WebContents);
+}
+
+// static
+v8::Local<v8::Value> Window::From(v8::Isolate* isolate,
+                                  NativeWindow* native_window) {
+  auto existing = TrackableObject::FromWrappedClass(isolate, native_window);
+  if (existing)
+    return existing->GetWrapper(isolate);
+  else
+    return v8::Null(isolate);
+}
+
+void SetDeprecatedOptionsCheck(const DeprecatedOptionsCheckCallback& callback) {
+  g_deprecated_options_check = callback;
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+using electron::api::Window;
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<Window>(
+      isolate, "BrowserWindow", base::Bind(&Window::New));
+  mate::Dictionary browser_window(isolate, constructor);
+  browser_window.SetMethod("fromId",
+                           &mate::TrackableObject<Window>::FromWeakMapID);
+  browser_window.SetMethod("getAllWindows",
+                           &mate::TrackableObject<Window>::GetAll);
+
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("BrowserWindow", browser_window);
+  dict.SetMethod("_setDeprecatedOptionsCheck",
+                 &electron::api::SetDeprecatedOptionsCheck);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_browser_window, Initialize)
added in remote
  their  100644 bf2bb09510456036dfc5f501f39f871e40b59437 electron/browser/api/electron_api_window.h
@@ -0,0 +1,222 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
+#define ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "ui/gfx/image/image.h"
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/native_window_observer.h"
+#include "native_mate/handle.h"
+
+class GURL;
+
+namespace gfx {
+class Rect;
+}
+
+namespace mate {
+class Arguments;
+class Dictionary;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+namespace api {
+
+class WebContents;
+
+class Window : public mate::TrackableObject<Window>,
+               public NativeWindowObserver {
+ public:
+  static mate::Wrappable* New(v8::Isolate* isolate, mate::Arguments* args);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+  // Returns the BrowserWindow object from |native_window|.
+  static v8::Local<v8::Value> From(v8::Isolate* isolate,
+                                   NativeWindow* native_window);
+
+  NativeWindow* window() const { return window_.get(); }
+
+ protected:
+  Window(v8::Isolate* isolate, const mate::Dictionary& options);
+  virtual ~Window();
+
+  // NativeWindowObserver:
+  void WillCloseWindow(bool* prevent_default) override;
+  void OnWindowClosed() override;
+  void OnWindowBlur() override;
+  void OnWindowFocus() override;
+  void OnWindowShow() override;
+  void OnWindowHide() override;
+  void OnWindowMaximize() override;
+  void OnWindowUnmaximize() override;
+  void OnWindowMinimize() override;
+  void OnWindowRestore() override;
+  void OnWindowResize() override;
+  void OnWindowMove() override;
+  void OnWindowMoved() override;
+  void OnWindowScrollTouchBegin() override;
+  void OnWindowScrollTouchEnd() override;
+  void OnWindowSwipe(const std::string& direction) override;
+  void OnWindowEnterFullScreen() override;
+  void OnWindowLeaveFullScreen() override;
+  void OnWindowEnterHtmlFullScreen() override;
+  void OnWindowLeaveHtmlFullScreen() override;
+  void OnRendererUnresponsive() override;
+  void OnRendererResponsive() override;
+  void OnExecuteWindowsCommand(const std::string& command_name) override;
+
+  #if defined(OS_WIN)
+  void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) override;
+  #endif
+
+ private:
+  // APIs for NativeWindow.
+  void Close();
+  void Focus();
+  void Blur();
+  bool IsFocused();
+  void Show();
+  void ShowInactive();
+  void Hide();
+  bool IsVisible();
+  void Maximize();
+  void Unmaximize();
+  bool IsMaximized();
+  void Minimize();
+  void Restore();
+  bool IsMinimized();
+  void SetFullScreen(bool fullscreen);
+  bool IsFullscreen();
+  void SetBounds(const gfx::Rect& bounds, mate::Arguments* args);
+  gfx::Rect GetBounds();
+  void SetSize(int width, int height, mate::Arguments* args);
+  std::vector<int> GetSize();
+  void SetContentSize(int width, int height, mate::Arguments* args);
+  std::vector<int> GetContentSize();
+  void SetMinimumSize(int width, int height);
+  std::vector<int> GetMinimumSize();
+  void SetMaximumSize(int width, int height);
+  std::vector<int> GetMaximumSize();
+  void SetResizable(bool resizable);
+  bool IsResizable();
+  void SetMovable(bool movable);
+  bool IsMovable();
+  void SetMinimizable(bool minimizable);
+  bool IsMinimizable();
+  void SetMaximizable(bool maximizable);
+  bool IsMaximizable();
+  void SetFullScreenable(bool fullscreenable);
+  bool IsFullScreenable();
+  void SetClosable(bool closable);
+  bool IsClosable();
+  void SetAlwaysOnTop(bool top);
+  bool IsAlwaysOnTop();
+  void Center();
+  void SetPosition(int x, int y, mate::Arguments* args);
+  std::vector<int> GetPosition();
+  void SetTitle(const std::string& title);
+  std::string GetTitle();
+  void FlashFrame(bool flash);
+  void SetSkipTaskbar(bool skip);
+  void SetKiosk(bool kiosk);
+  bool IsKiosk();
+  void SetBackgroundColor(const std::string& color_name);
+  void SetHasShadow(bool has_shadow);
+  bool HasShadow();
+  void FocusOnWebView();
+  void BlurWebView();
+  bool IsWebViewFocused();
+  void SetRepresentedFilename(const std::string& filename);
+  std::string GetRepresentedFilename();
+  void SetDocumentEdited(bool edited);
+  bool IsDocumentEdited();
+  void SetIgnoreMouseEvents(bool ignore);
+  void CapturePage(mate::Arguments* args);
+  void SetProgressBar(double progress);
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description);
+  bool SetThumbarButtons(mate::Arguments* args);
+  void SetMenu(v8::Isolate* isolate, v8::Local<v8::Value> menu);
+  void SetAutoHideMenuBar(bool auto_hide);
+  bool IsMenuBarAutoHide();
+  void SetMenuBarVisibility(bool visible);
+  bool IsMenuBarVisible();
+  void SetAspectRatio(double aspect_ratio, mate::Arguments* args);
+  v8::Local<v8::Value> GetNativeWindowHandle();
+
+#if defined(OS_WIN)
+  typedef base::Callback<void(v8::Local<v8::Value>,
+                              v8::Local<v8::Value>)> MessageCallback;
+
+  bool HookWindowMessage(UINT message, const MessageCallback& callback);
+  bool IsWindowMessageHooked(UINT message);
+  void UnhookWindowMessage(UINT message);
+  void UnhookAllWindowMessages();
+#endif
+
+#if defined(OS_MACOSX)
+  void ShowDefinitionForSelection();
+#endif
+
+  void SetVisibleOnAllWorkspaces(bool visible);
+  bool IsVisibleOnAllWorkspaces();
+
+  int32_t ID() const;
+  v8::Local<v8::Value> WebContents(v8::Isolate* isolate);
+
+#if defined(OS_WIN)
+  typedef std::map<UINT, MessageCallback> MessageCallbackMap;
+  MessageCallbackMap messages_callback_map_;
+#endif
+
+  v8::Global<v8::Value> web_contents_;
+  v8::Global<v8::Value> menu_;
+
+  api::WebContents* api_web_contents_;
+
+  scoped_ptr<NativeWindow> window_;
+
+  DISALLOW_COPY_AND_ASSIGN(Window);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace mate {
+
+template<>
+struct Converter<electron::NativeWindow*> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     electron::NativeWindow** out) {
+    // null would be tranfered to NULL.
+    if (val->IsNull()) {
+      *out = NULL;
+      return true;
+    }
+
+    electron::api::Window* window;
+    if (!Converter<electron::api::Window*>::FromV8(isolate, val, &window))
+      return false;
+    *out = window->window();
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_ELECTRON_API_WINDOW_H_
added in remote
  their  100644 451955a1fd4dfc2e9c747f18f97444085b5e0382 electron/browser/api/event.cc
@@ -0,0 +1,72 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/event.h"
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "content/public/browser/web_contents.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+}  // namespace
+
+Event::Event()
+    : sender_(NULL),
+      message_(NULL) {
+}
+
+Event::~Event() {
+}
+
+ObjectTemplateBuilder Event::GetObjectTemplateBuilder(v8::Isolate* isolate) {
+  if (template_.IsEmpty())
+    template_.Reset(isolate, ObjectTemplateBuilder(isolate)
+        .SetMethod("preventDefault", &Event::PreventDefault)
+        .SetMethod("sendReply", &Event::SendReply)
+        .Build());
+
+  return ObjectTemplateBuilder(
+      isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+}
+
+void Event::SetSenderAndMessage(content::WebContents* sender,
+                                IPC::Message* message) {
+  DCHECK(!sender_);
+  DCHECK(!message_);
+  sender_ = sender;
+  message_ = message;
+
+  Observe(sender);
+}
+
+void Event::WebContentsDestroyed() {
+  sender_ = NULL;
+  message_ = NULL;
+}
+
+void Event::PreventDefault(v8::Isolate* isolate) {
+  GetWrapper(isolate)->Set(StringToV8(isolate, "defaultPrevented"),
+                           v8::True(isolate));
+}
+
+bool Event::SendReply(const base::string16& json) {
+  if (message_ == NULL || sender_ == NULL)
+    return false;
+
+  ElectronViewHostMsg_Message_Sync::WriteReplyParams(message_, json);
+  return sender_->Send(message_);
+}
+
+// static
+Handle<Event> Event::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new Event);
+}
+
+}  // namespace mate
added in remote
  their  100644 ebdb32a30dd1cdf76511405928c076638ca7a684 electron/browser/api/event.h
@@ -0,0 +1,52 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_EVENT_H_
+#define ELECTRON_BROWSER_API_EVENT_H_
+
+#include "content/public/browser/web_contents_observer.h"
+#include "native_mate/wrappable.h"
+#include "native_mate/handle.h"
+
+namespace IPC {
+class Message;
+}
+
+namespace mate {
+
+class Event : public Wrappable,
+              public content::WebContentsObserver {
+ public:
+  static Handle<Event> Create(v8::Isolate* isolate);
+
+  // Pass the sender and message to be replied.
+  void SetSenderAndMessage(content::WebContents* sender, IPC::Message* message);
+
+  // event.PreventDefault().
+  void PreventDefault(v8::Isolate* isolate);
+
+  // event.sendReply(json), used for replying synchronous message.
+  bool SendReply(const base::string16& json);
+
+ protected:
+  Event();
+  virtual ~Event();
+
+  // Wrappable implementations:
+  ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate* isolate) override;
+
+  // content::WebContentsObserver implementations:
+  void WebContentsDestroyed() override;
+
+ private:
+  // Replyer for the synchronous messages.
+  content::WebContents* sender_;
+  IPC::Message* message_;
+
+  DISALLOW_COPY_AND_ASSIGN(Event);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_EVENT_H_
added in remote
  their  100644 6ef8aa4249a2f735b4be616507291917ad99d309 electron/browser/api/event_emitter.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/event_emitter.h"
+
+#include "electron/browser/api/event.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+
+namespace mate {
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> event_template;
+
+void PreventDefault(mate::Arguments* args) {
+  mate::Dictionary self(args->isolate(), args->GetThis());
+  self.Set("defaultPrevented", true);
+}
+
+// Create a pure JavaScript Event object.
+v8::Local<v8::Object> CreateEventObject(v8::Isolate* isolate) {
+  if (event_template.IsEmpty()) {
+    event_template.Reset(isolate, ObjectTemplateBuilder(isolate)
+        .SetMethod("preventDefault", &PreventDefault)
+        .Build());
+  }
+
+  return v8::Local<v8::ObjectTemplate>::New(
+      isolate, event_template)->NewInstance();
+}
+
+}  // namespace
+
+EventEmitter::EventEmitter() {
+}
+
+v8::Local<v8::Object> EventEmitter::CreateJSEvent(
+    v8::Isolate* isolate, content::WebContents* sender, IPC::Message* message) {
+  v8::Local<v8::Object> event;
+  bool use_native_event = sender && message;
+
+  if (use_native_event) {
+    mate::Handle<mate::Event> native_event = mate::Event::Create(isolate);
+    native_event->SetSenderAndMessage(sender, message);
+    event = v8::Local<v8::Object>::Cast(native_event.ToV8());
+  } else {
+    event = CreateEventObject(isolate);
+  }
+  mate::Dictionary(isolate, event).Set("sender", GetWrapper(isolate));
+  return event;
+}
+
+v8::Local<v8::Object> EventEmitter::CreateCustomEvent(
+    v8::Isolate* isolate, v8::Local<v8::Object> custom_event) {
+  v8::Local<v8::Object> event = CreateEventObject(isolate);
+  (void)event->SetPrototype(custom_event->CreationContext(), custom_event);
+  mate::Dictionary(isolate, event).Set("sender", GetWrapper(isolate));
+  return event;
+}
+
+}  // namespace mate
added in remote
  their  100644 87b03328073b5b2bc07e6888b41129761f878bc7 electron/browser/api/event_emitter.h
@@ -0,0 +1,81 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_EVENT_EMITTER_H_
+#define ELECTRON_BROWSER_API_EVENT_EMITTER_H_
+
+#include <vector>
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "native_mate/wrappable.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace IPC {
+class Message;
+}
+
+namespace mate {
+
+// Provide helperers to emit event in JavaScript.
+class EventEmitter : public Wrappable {
+ public:
+  typedef std::vector<v8::Local<v8::Value>> ValueArray;
+
+  // this.emit(name, event, args...);
+  template<typename... Args>
+  bool EmitCustomEvent(const base::StringPiece& name,
+                       v8::Local<v8::Object> event,
+                       const Args&... args) {
+    return EmitWithEvent(name, CreateCustomEvent(isolate(), event), args...);
+  }
+
+  // this.emit(name, new Event(), args...);
+  template<typename... Args>
+  bool Emit(const base::StringPiece& name, const Args&... args) {
+    return EmitWithSender(name, nullptr, nullptr, args...);
+  }
+
+  // this.emit(name, new Event(sender, message), args...);
+  template<typename... Args>
+  bool EmitWithSender(const base::StringPiece& name,
+                      content::WebContents* sender,
+                      IPC::Message* message,
+                      const Args&... args) {
+    v8::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    v8::Local<v8::Object> event = CreateJSEvent(isolate(), sender, message);
+    return EmitWithEvent(name, event, args...);
+  }
+
+ protected:
+  EventEmitter();
+
+ private:
+  // this.emit(name, event, args...);
+  template<typename... Args>
+  bool EmitWithEvent(const base::StringPiece& name,
+                     v8::Local<v8::Object> event,
+                     const Args&... args) {
+    v8::Locker locker(isolate());
+    v8::HandleScope handle_scope(isolate());
+    EmitEvent(isolate(), GetWrapper(isolate()), name, event, args...);
+    return event->Get(
+        StringToV8(isolate(), "defaultPrevented"))->BooleanValue();
+  }
+
+  v8::Local<v8::Object> CreateJSEvent(v8::Isolate* isolate,
+                                      content::WebContents* sender,
+                                      IPC::Message* message);
+  v8::Local<v8::Object> CreateCustomEvent(
+      v8::Isolate* isolate, v8::Local<v8::Object> event);
+
+  DISALLOW_COPY_AND_ASSIGN(EventEmitter);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_EVENT_EMITTER_H_
added in remote
  their  100644 cee31b6a620c068b728ced1a7c0242805767e2f2 electron/browser/api/frame_subscriber.cc
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/frame_subscriber.h"
+
+#include "base/bind.h"
+#include "electron/common/node_includes.h"
+#include "content/public/browser/render_widget_host.h"
+
+namespace electron {
+
+namespace api {
+
+FrameSubscriber::FrameSubscriber(v8::Isolate* isolate,
+                                 content::RenderWidgetHostView* view,
+                                 const FrameCaptureCallback& callback)
+    : isolate_(isolate), view_(view), callback_(callback), weak_factory_(this) {
+}
+
+bool FrameSubscriber::ShouldCaptureFrame(
+    const gfx::Rect& damage_rect,
+    base::TimeTicks present_time,
+    scoped_refptr<media::VideoFrame>* storage,
+    DeliverFrameCallback* callback) {
+  const auto host = view_ ? view_->GetRenderWidgetHost() : nullptr;
+  if (!view_ || !host)
+    return false;
+
+  const auto size = view_->GetVisibleViewportSize();
+
+  host->CopyFromBackingStore(
+      gfx::Rect(size),
+      size,
+      base::Bind(&FrameSubscriber::OnFrameDelivered,
+                 weak_factory_.GetWeakPtr(), callback_),
+      kBGRA_8888_SkColorType);
+
+  return false;
+}
+
+void FrameSubscriber::OnFrameDelivered(const FrameCaptureCallback& callback,
+  const SkBitmap& bitmap, content::ReadbackResponse response) {
+  if (bitmap.computeSize64() == 0)
+    return;
+
+  v8::Locker locker(isolate_);
+  v8::HandleScope handle_scope(isolate_);
+
+  size_t rgb_arr_size = bitmap.width() * bitmap.height() *
+    bitmap.bytesPerPixel();
+  v8::MaybeLocal<v8::Object> buffer = node::Buffer::New(isolate_, rgb_arr_size);
+  if (buffer.IsEmpty())
+    return;
+
+  bitmap.copyPixelsTo(
+    reinterpret_cast<uint8_t*>(node::Buffer::Data(buffer.ToLocalChecked())),
+    rgb_arr_size);
+
+  callback_.Run(buffer.ToLocalChecked());
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 321c75228c4989e90c5ae4a9068404e74f447144 electron/browser/api/frame_subscriber.h
@@ -0,0 +1,51 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
+#define ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
+
+#include "base/callback.h"
+#include "base/memory/weak_ptr.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/browser/render_widget_host_view_frame_subscriber.h"
+#include "content/public/browser/readback_types.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/geometry/size.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+namespace api {
+
+class FrameSubscriber : public content::RenderWidgetHostViewFrameSubscriber {
+ public:
+  using FrameCaptureCallback = base::Callback<void(v8::Local<v8::Value>)>;
+
+  FrameSubscriber(v8::Isolate* isolate,
+                  content::RenderWidgetHostView* view,
+                  const FrameCaptureCallback& callback);
+
+  bool ShouldCaptureFrame(const gfx::Rect& damage_rect,
+                          base::TimeTicks present_time,
+                          scoped_refptr<media::VideoFrame>* storage,
+                          DeliverFrameCallback* callback) override;
+
+ private:
+  void OnFrameDelivered(const FrameCaptureCallback& callback,
+    const SkBitmap& bitmap, content::ReadbackResponse response);
+
+  v8::Isolate* isolate_;
+  content::RenderWidgetHostView* view_;
+  FrameCaptureCallback callback_;
+
+  base::WeakPtrFactory<FrameSubscriber> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(FrameSubscriber);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_FRAME_SUBSCRIBER_H_
added in remote
  their  100644 a700d330290eda14e2375d86737be2d95df10875 electron/browser/api/save_page_handler.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/save_page_handler.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_context.h"
+#include "base/callback.h"
+#include "base/files/file_path.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+namespace api {
+
+SavePageHandler::SavePageHandler(content::WebContents* web_contents,
+                                 const SavePageCallback& callback)
+    : web_contents_(web_contents),
+      callback_(callback) {
+}
+
+SavePageHandler::~SavePageHandler() {
+}
+
+void SavePageHandler::OnDownloadCreated(content::DownloadManager* manager,
+                                        content::DownloadItem* item) {
+  // OnDownloadCreated is invoked during WebContents::SavePage, so the |item|
+  // here is the one stated by WebContents::SavePage.
+  item->AddObserver(this);
+}
+
+bool SavePageHandler::Handle(const base::FilePath& full_path,
+                             const content::SavePageType& save_type) {
+  auto download_manager = content::BrowserContext::GetDownloadManager(
+      web_contents_->GetBrowserContext());
+  download_manager->AddObserver(this);
+  // Chromium will create a 'foo_files' directory under the directory of saving
+  // page 'foo.html' for holding other resource files of 'foo.html'.
+  base::FilePath saved_main_directory_path = full_path.DirName().Append(
+      full_path.RemoveExtension().BaseName().value() +
+      FILE_PATH_LITERAL("_files"));
+  bool result = web_contents_->SavePage(full_path,
+                                        saved_main_directory_path,
+                                        save_type);
+  download_manager->RemoveObserver(this);
+  // If initialization fails which means fail to create |DownloadItem|, we need
+  // to delete the |SavePageHandler| instance to avoid memory-leak.
+  if (!result)
+    delete this;
+  return result;
+}
+
+void SavePageHandler::OnDownloadUpdated(content::DownloadItem* item) {
+  if (item->IsDone()) {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    if (item->GetState() == content::DownloadItem::COMPLETE) {
+      callback_.Run(v8::Null(isolate));
+    } else {
+      v8::Local<v8::String> error_message = v8::String::NewFromUtf8(
+          isolate, "Fail to save page");
+      callback_.Run(v8::Exception::Error(error_message));
+    }
+    Destroy(item);
+  }
+}
+
+void SavePageHandler::Destroy(content::DownloadItem* item) {
+  item->RemoveObserver(this);
+  delete this;
+}
+
+// static
+bool SavePageHandler::IsSavePageTypes(const std::string& type) {
+  return type == "multipart/related" || type == "text/html";
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 54829cb2ee0d8770de6e8b4f70aa0286a16a31a7 electron/browser/api/save_page_handler.h
@@ -0,0 +1,60 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
+#define ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
+
+#include <string>
+
+#include "content/public/browser/download_item.h"
+#include "content/public/browser/download_manager.h"
+#include "content/public/browser/save_page_type.h"
+#include "v8/include/v8.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace content {
+class WebContents;
+}
+
+namespace electron {
+
+namespace api {
+
+// A self-destroyed class for handling save page request.
+class SavePageHandler : public content::DownloadManager::Observer,
+                        public content::DownloadItem::Observer {
+ public:
+  using SavePageCallback = base::Callback<void(v8::Local<v8::Value>)>;
+
+  SavePageHandler(content::WebContents* web_contents,
+                  const SavePageCallback& callback);
+  ~SavePageHandler();
+
+  bool Handle(const base::FilePath& full_path,
+              const content::SavePageType& save_type);
+
+  static bool IsSavePageTypes(const std::string& type);
+
+ private:
+  void Destroy(content::DownloadItem* item);
+
+  // content::DownloadManager::Observer:
+  void OnDownloadCreated(content::DownloadManager* manager,
+                         content::DownloadItem* item) override;
+
+  // content::DownloadItem::Observer:
+  void OnDownloadUpdated(content::DownloadItem* item) override;
+
+  content::WebContents* web_contents_;  // weak
+  SavePageCallback callback_;
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_API_SAVE_PAGE_HANDLER_H_
added in remote
  their  100644 9f71c3432d26ba91a9445258917ffce7806ea189 electron/browser/api/trackable_object.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/api/trackable_object.h"
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "base/bind.h"
+#include "base/supports_user_data.h"
+
+namespace mate {
+
+namespace {
+
+const char* kTrackedObjectKey = "TrackedObjectKey";
+
+class IDUserData : public base::SupportsUserData::Data {
+ public:
+  explicit IDUserData(int32_t id) : id_(id) {}
+
+  operator int32_t() const { return id_; }
+
+ private:
+  int32_t id_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDUserData);
+};
+
+}  // namespace
+
+TrackableObjectBase::TrackableObjectBase()
+    : weak_map_id_(0), wrapped_(nullptr), weak_factory_(this) {
+  cleanup_ = RegisterDestructionCallback(GetDestroyClosure());
+}
+
+TrackableObjectBase::~TrackableObjectBase() {
+  cleanup_.Run();
+}
+
+void TrackableObjectBase::AfterInit(v8::Isolate* isolate) {
+  if (wrapped_)
+    AttachAsUserData(wrapped_);
+}
+
+void TrackableObjectBase::MarkDestroyed() {
+  GetWrapper(isolate())->SetAlignedPointerInInternalField(0, nullptr);
+}
+
+base::Closure TrackableObjectBase::GetDestroyClosure() {
+  return base::Bind(&TrackableObjectBase::Destroy, weak_factory_.GetWeakPtr());
+}
+
+void TrackableObjectBase::Destroy() {
+  delete this;
+}
+
+void TrackableObjectBase::AttachAsUserData(base::SupportsUserData* wrapped) {
+  if (weak_map_id_ != 0) {
+    wrapped->SetUserData(kTrackedObjectKey, new IDUserData(weak_map_id_));
+    wrapped_ = nullptr;
+  } else {
+    // If the TrackableObjectBase is not ready yet then delay SetUserData until
+    // AfterInit is called.
+    wrapped_ = wrapped;
+  }
+}
+
+// static
+int32_t TrackableObjectBase::GetIDFromWrappedClass(base::SupportsUserData* w) {
+  auto id = static_cast<IDUserData*>(w->GetUserData(kTrackedObjectKey));
+  if (id)
+    return *id;
+  else
+    return 0;
+}
+
+// static
+base::Closure TrackableObjectBase::RegisterDestructionCallback(
+    const base::Closure& c) {
+  return electron::ElectronBrowserMainParts::Get()->RegisterDestructionCallback(c);
+}
+
+}  // namespace mate
added in remote
  their  100644 31db58795e0ea1b58d72fc993d934d8b3d60b2b7 electron/browser/api/trackable_object.h
@@ -0,0 +1,156 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
+#define ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
+
+#include <vector>
+
+#include "electron/browser/api/event_emitter.h"
+#include "electron/common/id_weak_map.h"
+#include "base/bind.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "native_mate/object_template_builder.h"
+
+namespace base {
+class SupportsUserData;
+}
+
+namespace mate {
+
+// Users should use TrackableObject instead.
+class TrackableObjectBase : public mate::EventEmitter {
+ public:
+  TrackableObjectBase();
+
+  // The ID in weak map.
+  int32_t weak_map_id() const { return weak_map_id_; }
+
+  // Wrap TrackableObject into a class that SupportsUserData.
+  void AttachAsUserData(base::SupportsUserData* wrapped);
+
+ protected:
+  ~TrackableObjectBase() override;
+
+  // mate::Wrappable:
+  void AfterInit(v8::Isolate* isolate) override;
+
+  // Mark the JS object as destroyed.
+  void MarkDestroyed();
+
+  // Returns a closure that can destroy the native class.
+  base::Closure GetDestroyClosure();
+
+  // Get the weak_map_id from SupportsUserData.
+  static int32_t GetIDFromWrappedClass(base::SupportsUserData* wrapped);
+
+  // Register a callback that should be destroyed before JavaScript environment
+  // gets destroyed.
+  static base::Closure RegisterDestructionCallback(const base::Closure& c);
+
+  int32_t weak_map_id_;
+  base::SupportsUserData* wrapped_;
+
+ private:
+  void Destroy();
+
+  base::Closure cleanup_;
+  base::WeakPtrFactory<TrackableObjectBase> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrackableObjectBase);
+};
+
+// All instances of TrackableObject will be kept in a weak map and can be got
+// from its ID.
+template<typename T>
+class TrackableObject : public TrackableObjectBase {
+ public:
+  // Finds out the TrackableObject from its ID in weak map.
+  static T* FromWeakMapID(v8::Isolate* isolate, int32_t id) {
+    if (!weak_map_)
+      return nullptr;
+
+    v8::MaybeLocal<v8::Object> object = weak_map_->Get(isolate, id);
+    if (object.IsEmpty())
+      return nullptr;
+
+    T* self = nullptr;
+    mate::ConvertFromV8(isolate, object.ToLocalChecked(), &self);
+    return self;
+  }
+
+  // Finds out the TrackableObject from the class it wraps.
+  static T* FromWrappedClass(v8::Isolate* isolate,
+                             base::SupportsUserData* wrapped) {
+    int32_t id = GetIDFromWrappedClass(wrapped);
+    if (!id)
+      return nullptr;
+    return FromWeakMapID(isolate, id);
+  }
+
+  // Returns all objects in this class's weak map.
+  static std::vector<v8::Local<v8::Object>> GetAll(v8::Isolate* isolate) {
+    if (weak_map_)
+      return weak_map_->Values(isolate);
+    else
+      return std::vector<v8::Local<v8::Object>>();
+  }
+
+  // Removes this instance from the weak map.
+  void RemoveFromWeakMap() {
+    if (weak_map_ && weak_map_->Has(weak_map_id()))
+      weak_map_->Remove(weak_map_id());
+  }
+
+ protected:
+  TrackableObject() {}
+  ~TrackableObject() override {
+    RemoveFromWeakMap();
+  }
+
+  void AfterInit(v8::Isolate* isolate) override {
+    if (!weak_map_) {
+      weak_map_.reset(new electron::IDWeakMap);
+      RegisterDestructionCallback(
+          base::Bind(&TrackableObject<T>::ReleaseAllWeakReferences));
+    }
+    weak_map_id_ = weak_map_->Add(isolate, GetWrapper(isolate));
+    TrackableObjectBase::AfterInit(isolate);
+  }
+
+ private:
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override {
+    if (template_.IsEmpty()) {
+      auto templ = v8::ObjectTemplate::New(isolate);
+      T::BuildPrototype(isolate, templ);
+      template_.Reset(isolate, templ);
+    }
+
+    return ObjectTemplateBuilder(
+        isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+  }
+
+  // Releases all weak references in weak map, called when app is terminating.
+  static void ReleaseAllWeakReferences() {
+    weak_map_.reset();
+  }
+
+  static v8::Persistent<v8::ObjectTemplate> template_;
+  static scoped_ptr<electron::IDWeakMap> weak_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrackableObject);
+};
+
+template<typename T>
+v8::Persistent<v8::ObjectTemplate> TrackableObject<T>::template_;
+
+template<typename T>
+scoped_ptr<electron::IDWeakMap> TrackableObject<T>::weak_map_;
+
+}  // namespace mate
+
+#endif  // ELECTRON_BROWSER_API_TRACKABLE_OBJECT_H_
added in remote
  their  100644 329871b9e7837d4a9324034290eb3d6ae9515dd3 electron/browser/auto_updater.cc
@@ -0,0 +1,30 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/auto_updater.h"
+
+namespace auto_updater {
+
+Delegate* AutoUpdater::delegate_ = nullptr;
+
+Delegate* AutoUpdater::GetDelegate() {
+  return delegate_;
+}
+
+void AutoUpdater::SetDelegate(Delegate* delegate) {
+  delegate_ = delegate;
+}
+
+#if !defined(OS_MACOSX) || defined(MAS_BUILD)
+void AutoUpdater::SetFeedURL(const std::string& url) {
+}
+
+void AutoUpdater::CheckForUpdates() {
+}
+
+void AutoUpdater::QuitAndInstall() {
+}
+#endif
+
+}  // namespace auto_updater
added in remote
  their  100644 7f2d66882770041dddb05b61497bdf0954bf2223 electron/browser/auto_updater.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_AUTO_UPDATER_H_
+#define ELECTRON_BROWSER_AUTO_UPDATER_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "build/build_config.h"
+
+namespace base {
+class Time;
+}
+
+namespace auto_updater {
+
+class Delegate {
+ public:
+  // An error happened.
+  virtual void OnError(const std::string& error) {}
+
+  // Checking to see if there is an update
+  virtual void OnCheckingForUpdate() {}
+
+  // There is an update available and it is being downloaded
+  virtual void OnUpdateAvailable() {}
+
+  // There is no available update.
+  virtual void OnUpdateNotAvailable() {}
+
+  // There is a new update which has been downloaded.
+  virtual void OnUpdateDownloaded(const std::string& release_notes,
+                                  const std::string& release_name,
+                                  const base::Time& release_date,
+                                  const std::string& update_url) {}
+
+ protected:
+  virtual ~Delegate() {}
+};
+
+class AutoUpdater {
+ public:
+  // Gets/Sets the delegate.
+  static Delegate* GetDelegate();
+  static void SetDelegate(Delegate* delegate);
+
+  static void SetFeedURL(const std::string& url);
+  static void CheckForUpdates();
+  static void QuitAndInstall();
+
+ private:
+  static Delegate* delegate_;
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(AutoUpdater);
+};
+
+}  // namespace auto_updater
+
+#endif  // ELECTRON_BROWSER_AUTO_UPDATER_H_
added in remote
  their  100644 6ef2d7773a366ddc306ca2ff2620d7a43bb9b728 electron/browser/auto_updater_mac.mm
@@ -0,0 +1,99 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/auto_updater.h"
+
+#import <ReactiveCocoa/RACCommand.h>
+#import <ReactiveCocoa/RACSignal.h>
+#import <ReactiveCocoa/NSObject+RACPropertySubscribing.h>
+#import <Squirrel/Squirrel.h>
+
+#include "base/bind.h"
+#include "base/time/time.h"
+#include "base/strings/sys_string_conversions.h"
+
+namespace auto_updater {
+
+namespace {
+
+// The gloal SQRLUpdater object.
+SQRLUpdater* g_updater = nil;
+
+}  // namespace
+
+// static
+void AutoUpdater::SetFeedURL(const std::string& feed) {
+  if (g_updater == nil) {
+    Delegate* delegate = GetDelegate();
+    if (!delegate)
+      return;
+
+    // Initialize the SQRLUpdater.
+    NSURL* url = [NSURL URLWithString:base::SysUTF8ToNSString(feed)];
+    NSURLRequest* urlRequest = [NSURLRequest requestWithURL:url];
+
+    @try {
+      g_updater = [[SQRLUpdater alloc] initWithUpdateRequest:urlRequest];
+    } @catch (NSException* error) {
+      delegate->OnError(base::SysNSStringToUTF8(error.reason));
+      return;
+    }
+
+    [[g_updater rac_valuesForKeyPath:@"state" observer:g_updater]
+      subscribeNext:^(NSNumber *stateNumber) {
+        int state = [stateNumber integerValue];
+        // Dispatching the event on main thread.
+        dispatch_async(dispatch_get_main_queue(), ^{
+          if (state == SQRLUpdaterStateCheckingForUpdate)
+            delegate->OnCheckingForUpdate();
+          else if (state == SQRLUpdaterStateDownloadingUpdate)
+            delegate->OnUpdateAvailable();
+        });
+    }];
+  }
+}
+
+// static
+void AutoUpdater::CheckForUpdates() {
+  Delegate* delegate = GetDelegate();
+  if (!delegate)
+    return;
+
+  [[[[g_updater.checkForUpdatesCommand
+      execute:nil]
+      // Send a `nil` after everything...
+      concat:[RACSignal return:nil]]
+      // But only take the first value. If an update is sent, we'll get that.
+      // Otherwise, we'll get our inserted `nil` value.
+      take:1]
+      subscribeNext:^(SQRLDownloadedUpdate *downloadedUpdate) {
+        if (downloadedUpdate) {
+          SQRLUpdate* update = downloadedUpdate.update;
+          // There is a new update that has been downloaded.
+          delegate->OnUpdateDownloaded(
+            base::SysNSStringToUTF8(update.releaseNotes),
+            base::SysNSStringToUTF8(update.releaseName),
+            base::Time::FromDoubleT(update.releaseDate.timeIntervalSince1970),
+            base::SysNSStringToUTF8(update.updateURL.absoluteString));
+        } else {
+          // When the completed event is sent with no update, then we know there
+          // is no update available.
+          delegate->OnUpdateNotAvailable();
+        }
+      } error:^(NSError *error) {
+        delegate->OnError(base::SysNSStringToUTF8(
+            [NSString stringWithFormat:@"%@: %@",
+                error.localizedDescription, error.localizedFailureReason]));
+      }];
+}
+
+void AutoUpdater::QuitAndInstall() {
+  [[g_updater relaunchToInstallUpdate] subscribeError:^(NSError* error) {
+    Delegate* delegate = AutoUpdater::GetDelegate();
+    if (delegate)
+      delegate->OnError(base::SysNSStringToUTF8(error.localizedDescription));
+  }];
+}
+
+}  // namespace auto_updater
added in remote
  their  100644 fb07c7d60a2e9783a0744bd6fd53e8a54114efd5 electron/browser/bridge_task_runner.cc
@@ -0,0 +1,59 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/bridge_task_runner.h"
+
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+void BridgeTaskRunner::MessageLoopIsReady() {
+  auto message_loop = base::MessageLoop::current();
+  CHECK(message_loop);
+  for (const TaskPair& task : tasks_) {
+    message_loop->task_runner()->PostDelayedTask(
+        base::get<0>(task), base::get<1>(task), base::get<2>(task));
+  }
+  for (const TaskPair& task : non_nestable_tasks_) {
+    message_loop->task_runner()->PostNonNestableDelayedTask(
+        base::get<0>(task), base::get<1>(task), base::get<2>(task));
+  }
+}
+
+bool BridgeTaskRunner::PostDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop) {
+    tasks_.push_back(base::MakeTuple(from_here, task, delay));
+    return true;
+  }
+
+  return message_loop->task_runner()->PostDelayedTask(from_here, task, delay);
+}
+
+bool BridgeTaskRunner::RunsTasksOnCurrentThread() const {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop)
+    return true;
+
+  return message_loop->task_runner()->RunsTasksOnCurrentThread();
+}
+
+bool BridgeTaskRunner::PostNonNestableDelayedTask(
+    const tracked_objects::Location& from_here,
+    const base::Closure& task,
+    base::TimeDelta delay) {
+  auto message_loop = base::MessageLoop::current();
+  if (!message_loop) {
+    non_nestable_tasks_.push_back(base::MakeTuple(from_here, task, delay));
+    return true;
+  }
+
+  return message_loop->task_runner()->PostNonNestableDelayedTask(
+      from_here, task, delay);
+}
+
+}  // namespace electron
added in remote
  their  100644 5ed3ff65ab1fd629332fbf5785afdc3fc39198f1 electron/browser/bridge_task_runner.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
+#define ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
+
+#include <vector>
+
+#include "base/single_thread_task_runner.h"
+#include "base/tuple.h"
+
+namespace electron {
+
+// Post all tasks to the current message loop's task runner if available,
+// otherwise delay the work until message loop is ready.
+class BridgeTaskRunner : public base::SingleThreadTaskRunner {
+ public:
+  BridgeTaskRunner() {}
+  ~BridgeTaskRunner() override {}
+
+  // Called when message loop is ready.
+  void MessageLoopIsReady();
+
+  // base::SingleThreadTaskRunner:
+  bool PostDelayedTask(const tracked_objects::Location& from_here,
+                       const base::Closure& task,
+                       base::TimeDelta delay) override;
+  bool RunsTasksOnCurrentThread() const override;
+  bool PostNonNestableDelayedTask(
+      const tracked_objects::Location& from_here,
+      const base::Closure& task,
+      base::TimeDelta delay) override;
+
+ private:
+  using TaskPair = base::Tuple<
+      tracked_objects::Location, base::Closure, base::TimeDelta>;
+  std::vector<TaskPair> tasks_;
+  std::vector<TaskPair> non_nestable_tasks_;
+
+  DISALLOW_COPY_AND_ASSIGN(BridgeTaskRunner);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BRIDGE_TASK_RUNNER_H_
added in remote
  their  100644 f8781b9e719373cba5c2eb4b573da75711dd5e7e electron/browser/browser.cc
@@ -0,0 +1,188 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <string>
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+Browser::Browser()
+    : is_quiting_(false),
+      is_ready_(false),
+      is_shutdown_(false) {
+  WindowList::AddObserver(this);
+}
+
+Browser::~Browser() {
+  WindowList::RemoveObserver(this);
+}
+
+// static
+Browser* Browser::Get() {
+  return ElectronBrowserMainParts::Get()->browser();
+}
+
+void Browser::Quit() {
+  if (is_quiting_)
+    return;
+
+  is_quiting_ = HandleBeforeQuit();
+  if (!is_quiting_)
+    return;
+
+  electron::WindowList* window_list = electron::WindowList::GetInstance();
+  if (window_list->size() == 0)
+    NotifyAndShutdown();
+
+  window_list->CloseAllWindows();
+}
+
+void Browser::Exit(int code) {
+  if (!ElectronBrowserMainParts::Get()->SetExitCode(code)) {
+    // Message loop is not ready, quit directly.
+    exit(code);
+  } else {
+    // Prepare to quit when all windows have been closed..
+    is_quiting_ = true;
+
+    // Must destroy windows before quitting, otherwise bad things can happen.
+    electron::WindowList* window_list = electron::WindowList::GetInstance();
+    if (window_list->size() == 0) {
+      Shutdown();
+    } else {
+      // Unlike Quit(), we do not ask to close window, but destroy the window
+      // without asking.
+      for (NativeWindow* window : *window_list)
+        window->CloseContents(nullptr);  // e.g. Destroy()
+    }
+  }
+}
+
+void Browser::Shutdown() {
+  if (is_shutdown_)
+    return;
+
+  is_shutdown_ = true;
+  is_quiting_ = true;
+
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnQuit());
+
+  if (base::MessageLoop::current()) {
+    base::MessageLoop::current()->PostTask(
+        FROM_HERE, base::MessageLoop::QuitWhenIdleClosure());
+  } else {
+    // There is no message loop available so we are in early stage.
+    exit(0);
+  }
+}
+
+std::string Browser::GetVersion() const {
+  if (version_override_.empty()) {
+    std::string version = GetExecutableFileVersion();
+    if (!version.empty())
+      return version;
+  }
+
+  return version_override_;
+}
+
+void Browser::SetVersion(const std::string& version) {
+  version_override_ = version;
+}
+
+std::string Browser::GetName() const {
+  if (name_override_.empty()) {
+    std::string name = GetExecutableFileProductName();
+    if (!name.empty())
+      return name;
+  }
+
+  return name_override_;
+}
+
+void Browser::SetName(const std::string& name) {
+  name_override_ = name;
+}
+
+bool Browser::OpenFile(const std::string& file_path) {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnOpenFile(&prevent_default, file_path));
+
+  return prevent_default;
+}
+
+void Browser::OpenURL(const std::string& url) {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnOpenURL(url));
+}
+
+void Browser::Activate(bool has_visible_windows) {
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnActivate(has_visible_windows));
+}
+
+void Browser::WillFinishLaunching() {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWillFinishLaunching());
+}
+
+void Browser::DidFinishLaunching() {
+  is_ready_ = true;
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnFinishLaunching());
+}
+
+void Browser::RequestLogin(LoginHandler* login_handler) {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnLogin(login_handler));
+}
+
+void Browser::NotifyAndShutdown() {
+  if (is_shutdown_)
+    return;
+
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWillQuit(&prevent_default));
+
+  if (prevent_default) {
+    is_quiting_ = false;
+    return;
+  }
+
+  Shutdown();
+}
+
+bool Browser::HandleBeforeQuit() {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(BrowserObserver,
+                    observers_,
+                    OnBeforeQuit(&prevent_default));
+
+  return !prevent_default;
+}
+
+void Browser::OnWindowCloseCancelled(NativeWindow* window) {
+  if (is_quiting_)
+    // Once a beforeunload handler has prevented the closing, we think the quit
+    // is cancelled too.
+    is_quiting_ = false;
+}
+
+void Browser::OnWindowAllClosed() {
+  if (is_quiting_)
+    NotifyAndShutdown();
+  else
+    FOR_EACH_OBSERVER(BrowserObserver, observers_, OnWindowAllClosed());
+}
+
+void Browser::PlatformThemeChanged() {
+  FOR_EACH_OBSERVER(BrowserObserver, observers_, OnPlatformThemeChanged());
+}
+
+}  // namespace electron
added in remote
  their  100644 3913476ac4daac19fe0669b7170a4691b6f6652b electron/browser/browser.h
@@ -0,0 +1,210 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BROWSER_H_
+#define ELECTRON_BROWSER_BROWSER_H_
+
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "base/observer_list.h"
+#include "base/strings/string16.h"
+#include "electron/browser/browser_observer.h"
+#include "electron/browser/window_list_observer.h"
+
+#if defined(OS_WIN)
+#include "base/files/file_path.h"
+#endif
+
+namespace base {
+class FilePath;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace gfx {
+class Image;
+}
+
+namespace electron {
+
+class LoginHandler;
+
+// This class is used for control application-wide operations.
+class Browser : public WindowListObserver {
+ public:
+  Browser();
+  ~Browser();
+
+  static Browser* Get();
+
+  // Try to close all windows and quit the application.
+  void Quit();
+
+  // Exit the application immediately and set exit code.
+  void Exit(int code);
+
+  // Cleanup everything and shutdown the application gracefully.
+  void Shutdown();
+
+  // Focus the application.
+  void Focus();
+
+  // Returns the version of the executable (or bundle).
+  std::string GetVersion() const;
+
+  // Overrides the application version.
+  void SetVersion(const std::string& version);
+
+  // Returns the application's name, default is just Electron.
+  std::string GetName() const;
+
+  // Overrides the application name.
+  void SetName(const std::string& name);
+
+  // Add the |path| to recent documents list.
+  void AddRecentDocument(const base::FilePath& path);
+
+  // Clear the recent documents list.
+  void ClearRecentDocuments();
+
+  // Set the application user model ID.
+  void SetAppUserModelID(const base::string16& name);
+
+  // Remove the default protocol handler registry key
+  bool RemoveAsDefaultProtocolClient(const std::string& protocol);
+
+  // Set as default handler for a protocol.
+  bool SetAsDefaultProtocolClient(const std::string& protocol);
+
+#if defined(OS_MACOSX)
+  // Hide the application.
+  void Hide();
+
+  // Show the application.
+  void Show();
+
+  // Check if the system is in Dark Mode.
+  bool IsDarkMode();
+
+  // Bounce the dock icon.
+  enum BounceType {
+    BOUNCE_CRITICAL = 0,
+    BOUNCE_INFORMATIONAL = 10,
+  };
+  int DockBounce(BounceType type);
+  void DockCancelBounce(int request_id);
+
+  // Set/Get dock's badge text.
+  void DockSetBadgeText(const std::string& label);
+  std::string DockGetBadgeText();
+
+  // Hide/Show dock.
+  void DockHide();
+  void DockShow();
+
+  // Set docks' menu.
+  void DockSetMenu(ui::MenuModel* model);
+
+  // Set docks' icon.
+  void DockSetIcon(const gfx::Image& image);
+#endif  // defined(OS_MACOSX)
+
+#if defined(OS_WIN)
+  struct UserTask {
+    base::FilePath program;
+    base::string16 arguments;
+    base::string16 title;
+    base::string16 description;
+    base::FilePath icon_path;
+    int icon_index;
+  };
+
+  // Add a custom task to jump list.
+  void SetUserTasks(const std::vector<UserTask>& tasks);
+
+  // Returns the application user model ID, if there isn't one, then create
+  // one from app's name.
+  // The returned string managed by Browser, and should not be modified.
+  PCWSTR GetAppUserModelID();
+#endif
+
+  // Tell the application to open a file.
+  bool OpenFile(const std::string& file_path);
+
+  // Tell the application to open a url.
+  void OpenURL(const std::string& url);
+
+  // Tell the application that application is activated with visible/invisible
+  // windows.
+  void Activate(bool has_visible_windows);
+
+  // Tell the application the loading has been done.
+  void WillFinishLaunching();
+  void DidFinishLaunching();
+
+  // Request basic auth login.
+  void RequestLogin(LoginHandler* login_handler);
+
+  // Tell the application that plaform's theme changed.
+  void PlatformThemeChanged();
+
+  void AddObserver(BrowserObserver* obs) {
+    observers_.AddObserver(obs);
+  }
+
+  void RemoveObserver(BrowserObserver* obs) {
+    observers_.RemoveObserver(obs);
+  }
+
+  bool is_shutting_down() const { return is_shutdown_; }
+  bool is_quiting() const { return is_quiting_; }
+  bool is_ready() const { return is_ready_; }
+
+ protected:
+  // Returns the version of application bundle or executable file.
+  std::string GetExecutableFileVersion() const;
+
+  // Returns the name of application bundle or executable file.
+  std::string GetExecutableFileProductName() const;
+
+  // Send the will-quit message and then shutdown the application.
+  void NotifyAndShutdown();
+
+  // Send the before-quit message and start closing windows.
+  bool HandleBeforeQuit();
+
+  bool is_quiting_;
+
+ private:
+  // WindowListObserver implementations:
+  void OnWindowCloseCancelled(NativeWindow* window) override;
+  void OnWindowAllClosed() override;
+
+  // Observers of the browser.
+  base::ObserverList<BrowserObserver> observers_;
+
+  // Whether "ready" event has been emitted.
+  bool is_ready_;
+
+  // The browse is being shutdown.
+  bool is_shutdown_;
+
+  std::string version_override_;
+  std::string name_override_;
+
+#if defined(OS_WIN)
+  base::string16 app_user_model_id_;
+#endif
+
+  DISALLOW_COPY_AND_ASSIGN(Browser);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BROWSER_H_
added in remote
  their  100644 d7f09f8af61c3495f340dd7ff854ac8aa3b9e11e electron/browser/browser_linux.cc
@@ -0,0 +1,53 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <stdlib.h>
+
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/electron_version.h"
+#include "brightray/common/application_info.h"
+
+namespace electron {
+
+void Browser::Focus() {
+  // Focus on the first visible window.
+  WindowList* list = WindowList::GetInstance();
+  for (WindowList::iterator iter = list->begin(); iter != list->end(); ++iter) {
+    NativeWindow* window = *iter;
+    if (window->IsVisible()) {
+      window->Focus(true);
+      break;
+    }
+  }
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+}
+
+void Browser::ClearRecentDocuments() {
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  return brightray::GetApplicationVersion();
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  return brightray::GetApplicationName();
+}
+
+}  // namespace electron
added in remote
  their  100644 bc707e6584eb4ba9872d04bdc2d6b99597772a49 electron/browser/browser_mac.mm
@@ -0,0 +1,143 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include "electron/browser/mac/electron_application.h"
+#include "electron/browser/mac/electron_application_delegate.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/foundation_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "brightray/common/application_info.h"
+
+namespace electron {
+
+void Browser::Focus() {
+  [[ElectronApplication sharedApplication] activateIgnoringOtherApps:YES];
+}
+
+void Browser::Hide() {
+  [[ElectronApplication sharedApplication] hide:nil];
+}
+
+void Browser::Show() {
+  [[ElectronApplication sharedApplication] unhide:nil];
+}
+
+bool Browser::IsDarkMode() {
+  NSString *mode = [[NSUserDefaults standardUserDefaults] stringForKey:@"AppleInterfaceStyle"];
+  return [mode isEqualToString: @"Dark"];
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+  NSString* path_string = base::mac::FilePathToNSString(path);
+  if (!path_string)
+    return;
+  NSURL* u = [NSURL fileURLWithPath:path_string];
+  if (!u)
+    return;
+  [[NSDocumentController sharedDocumentController] noteNewRecentDocumentURL:u];
+}
+
+void Browser::ClearRecentDocuments() {
+  [[NSDocumentController sharedDocumentController] clearRecentDocuments:nil];
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  return false;
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  if (protocol.empty())
+    return false;
+
+  NSString* identifier = [base::mac::MainBundle() bundleIdentifier];
+  if (!identifier)
+    return false;
+
+  NSString* protocol_ns = [NSString stringWithUTF8String:protocol.c_str()];
+  OSStatus return_code =
+      LSSetDefaultHandlerForURLScheme(base::mac::NSToCFCast(protocol_ns),
+                                      base::mac::NSToCFCast(identifier));
+  return return_code == noErr;
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  return brightray::GetApplicationVersion();
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  return brightray::GetApplicationName();
+}
+
+int Browser::DockBounce(BounceType type) {
+  return [[ElectronApplication sharedApplication]
+      requestUserAttention:(NSRequestUserAttentionType)type];
+}
+
+void Browser::DockCancelBounce(int request_id) {
+  [[ElectronApplication sharedApplication] cancelUserAttentionRequest:request_id];
+}
+
+void Browser::DockSetBadgeText(const std::string& label) {
+  NSDockTile *tile = [[ElectronApplication sharedApplication] dockTile];
+  [tile setBadgeLabel:base::SysUTF8ToNSString(label)];
+}
+
+std::string Browser::DockGetBadgeText() {
+  NSDockTile *tile = [[ElectronApplication sharedApplication] dockTile];
+  return base::SysNSStringToUTF8([tile badgeLabel]);
+}
+
+void Browser::DockHide() {
+  WindowList* list = WindowList::GetInstance();
+  for (WindowList::iterator it = list->begin(); it != list->end(); ++it)
+    [(*it)->GetNativeWindow() setCanHide:NO];
+
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  TransformProcessType(&psn, kProcessTransformToUIElementApplication);
+}
+
+void Browser::DockShow() {
+  BOOL active = [[NSRunningApplication currentApplication] isActive];
+  ProcessSerialNumber psn = { 0, kCurrentProcess };
+  if (active) {
+    // Workaround buggy behavior of TransformProcessType.
+    // http://stackoverflow.com/questions/7596643/
+    NSArray* runningApps = [NSRunningApplication
+        runningApplicationsWithBundleIdentifier:@"com.apple.dock"];
+    for (NSRunningApplication* app in runningApps) {
+      [app activateWithOptions:NSApplicationActivateIgnoringOtherApps];
+      break;
+    }
+    dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
+    dispatch_after(one_ms, dispatch_get_main_queue(), ^{
+      TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+      dispatch_time_t one_ms = dispatch_time(DISPATCH_TIME_NOW, USEC_PER_SEC);
+      dispatch_after(one_ms, dispatch_get_main_queue(), ^{
+        [[NSRunningApplication currentApplication]
+            activateWithOptions:NSApplicationActivateIgnoringOtherApps];
+      });
+    });
+  } else {
+    TransformProcessType(&psn, kProcessTransformToForegroundApplication);
+  }
+}
+
+void Browser::DockSetMenu(ui::MenuModel* model) {
+  ElectronApplicationDelegate* delegate = (ElectronApplicationDelegate*)[NSApp delegate];
+  [delegate setApplicationDockMenu:model];
+}
+
+void Browser::DockSetIcon(const gfx::Image& image) {
+  [[ElectronApplication sharedApplication]
+      setApplicationIconImage:image.AsNSImage()];
+}
+
+}  // namespace electron
added in remote
  their  100644 f3f1409ab58be372e97f7b94b253a50831790d45 electron/browser/browser_observer.h
@@ -0,0 +1,56 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_BROWSER_OBSERVER_H_
+#define ELECTRON_BROWSER_BROWSER_OBSERVER_H_
+
+#include <string>
+
+namespace electron {
+
+class LoginHandler;
+
+class BrowserObserver {
+ public:
+  // The browser is about to close all windows.
+  virtual void OnBeforeQuit(bool* prevent_default) {}
+
+  // The browser has closed all windows and will quit.
+  virtual void OnWillQuit(bool* prevent_default) {}
+
+  // The browser has closed all windows. If the browser is quiting, then this
+  // method will not be called, instead it will call OnWillQuit.
+  virtual void OnWindowAllClosed() {}
+
+  // The browser is quitting.
+  virtual void OnQuit() {}
+
+  // The browser has opened a file by double clicking in Finder or dragging the
+  // file to the Dock icon. (OS X only)
+  virtual void OnOpenFile(bool* prevent_default,
+                          const std::string& file_path) {}
+
+  // Browser is used to open a url.
+  virtual void OnOpenURL(const std::string& url) {}
+
+  // The browser is activated with visible/invisible windows (usually by
+  // clicking on the dock icon).
+  virtual void OnActivate(bool has_visible_windows) {}
+
+  // The browser has finished loading.
+  virtual void OnWillFinishLaunching() {}
+  virtual void OnFinishLaunching() {}
+
+  // The browser requests HTTP login.
+  virtual void OnLogin(LoginHandler* login_handler) {}
+
+  virtual void OnPlatformThemeChanged() {}
+
+ protected:
+  virtual ~BrowserObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_BROWSER_OBSERVER_H_
added in remote
  their  100644 34f5df1b2f66bed0d09ac3aedbb7e186a9ff54a0 electron/browser/browser_win.cc
@@ -0,0 +1,259 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/browser.h"
+
+#include <atlbase.h>
+#include <propkey.h>
+#include <windows.h>
+#include <shlobj.h>
+#include <shobjidl.h>
+
+#include "base/base_paths.h"
+#include "base/file_version_info.h"
+#include "base/files/file_path.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/path_service.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/win_util.h"
+#include "base/win/registry.h"
+#include "base/win/windows_version.h"
+#include "electron/common/electron_version.h"
+
+namespace electron {
+
+namespace {
+
+const wchar_t kAppUserModelIDFormat[] = L"electron.app.$1";
+
+BOOL CALLBACK WindowsEnumerationHandler(HWND hwnd, LPARAM param) {
+  DWORD target_process_id = *reinterpret_cast<DWORD*>(param);
+  DWORD process_id = 0;
+
+  GetWindowThreadProcessId(hwnd, &process_id);
+  if (process_id == target_process_id) {
+    SetFocus(hwnd);
+    return FALSE;
+  }
+
+  return TRUE;
+}
+
+}  // namespace
+
+void Browser::Focus() {
+  // On Windows we just focus on the first window found for this process.
+  DWORD pid = GetCurrentProcessId();
+  EnumWindows(&WindowsEnumerationHandler, reinterpret_cast<LPARAM>(&pid));
+}
+
+void Browser::AddRecentDocument(const base::FilePath& path) {
+  if (base::win::GetVersion() < base::win::VERSION_WIN7)
+    return;
+
+  CComPtr<IShellItem> item;
+  HRESULT hr = SHCreateItemFromParsingName(
+      path.value().c_str(), NULL, IID_PPV_ARGS(&item));
+  if (SUCCEEDED(hr)) {
+    SHARDAPPIDINFO info;
+    info.psi = item;
+    info.pszAppID = GetAppUserModelID();
+    SHAddToRecentDocs(SHARD_APPIDINFO, &info);
+  }
+}
+
+void Browser::ClearRecentDocuments() {
+  CComPtr<IApplicationDestinations> destinations;
+  if (FAILED(destinations.CoCreateInstance(CLSID_ApplicationDestinations,
+                                           NULL, CLSCTX_INPROC_SERVER)))
+    return;
+  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
+    return;
+  destinations->RemoveAllDestinations();
+}
+
+void Browser::SetAppUserModelID(const base::string16& name) {
+  app_user_model_id_ = name;
+  SetCurrentProcessExplicitAppUserModelID(app_user_model_id_.c_str());
+}
+
+void Browser::SetUserTasks(const std::vector<UserTask>& tasks) {
+  CComPtr<ICustomDestinationList> destinations;
+  if (FAILED(destinations.CoCreateInstance(CLSID_DestinationList)))
+    return;
+  if (FAILED(destinations->SetAppID(GetAppUserModelID())))
+    return;
+
+  // Start a transaction that updates the JumpList of this application.
+  UINT max_slots;
+  CComPtr<IObjectArray> removed;
+  if (FAILED(destinations->BeginList(&max_slots, IID_PPV_ARGS(&removed))))
+    return;
+
+  CComPtr<IObjectCollection> collection;
+  if (FAILED(collection.CoCreateInstance(CLSID_EnumerableObjectCollection)))
+    return;
+
+  for (auto& task : tasks) {
+    CComPtr<IShellLink> link;
+    if (FAILED(link.CoCreateInstance(CLSID_ShellLink)) ||
+        FAILED(link->SetPath(task.program.value().c_str())) ||
+        FAILED(link->SetArguments(task.arguments.c_str())) ||
+        FAILED(link->SetDescription(task.description.c_str())))
+      return;
+
+    if (!task.icon_path.empty() &&
+        FAILED(link->SetIconLocation(task.icon_path.value().c_str(),
+                                     task.icon_index)))
+      return;
+
+    CComQIPtr<IPropertyStore> property_store = link;
+    if (!base::win::SetStringValueForPropertyStore(property_store, PKEY_Title,
+                                                   task.title.c_str()))
+      return;
+
+    if (FAILED(collection->AddObject(link)))
+      return;
+  }
+
+  // When the list is empty "AddUserTasks" could fail, so we don't check return
+  // value for it.
+  CComQIPtr<IObjectArray> task_array = collection;
+  destinations->AddUserTasks(task_array);
+  destinations->CommitList();
+}
+
+bool Browser::RemoveAsDefaultProtocolClient(const std::string& protocol) {
+  if (protocol.empty())
+    return false;
+
+  base::FilePath path;
+  if (!PathService::Get(base::FILE_EXE, &path)) {
+    LOG(ERROR) << "Error getting app exe path";
+    return false;
+  }
+
+  // Main Registry Key
+  HKEY root = HKEY_CURRENT_USER;
+  std::string keyPathStr = "Software\\Classes\\" + protocol;
+  std::wstring keyPath = std::wstring(keyPathStr.begin(), keyPathStr.end());
+
+  // Command Key
+  std::string cmdPathStr = keyPathStr + "\\shell\\open\\command";
+  std::wstring cmdPath = std::wstring(cmdPathStr.begin(), cmdPathStr.end());
+
+  base::win::RegKey key;
+  base::win::RegKey commandKey;
+  if (FAILED(key.Open(root, keyPath.c_str(), KEY_ALL_ACCESS)))
+    // Key doesn't even exist, we can confirm that it is not set
+    return true;
+
+  if (FAILED(commandKey.Open(root, cmdPath.c_str(), KEY_ALL_ACCESS)))
+    // Key doesn't even exist, we can confirm that it is not set
+    return true;
+
+  std::wstring keyVal;
+  if (FAILED(commandKey.ReadValue(L"", &keyVal)))
+    // Default value not set, we can confirm that it is not set
+    return true;
+
+  std::wstring exePath(path.value());
+  std::wstring exe = L"\"" + exePath + L"\" \"%1\"";
+  if (keyVal == exe) {
+    // Let's kill the key
+    if (FAILED(key.DeleteKey(L"shell")))
+      return false;
+
+    return true;
+  } else {
+    return true;
+  }
+}
+
+bool Browser::SetAsDefaultProtocolClient(const std::string& protocol) {
+  // HKEY_CLASSES_ROOT
+  //    $PROTOCOL
+  //       (Default) = "URL:$NAME"
+  //       URL Protocol = ""
+  //       shell
+  //          open
+  //             command
+  //                (Default) = "$COMMAND" "%1"
+  //
+  // However, the "HKEY_CLASSES_ROOT" key can only be written by the
+  // Administrator user. So, we instead write to "HKEY_CURRENT_USER\
+  // Software\Classes", which is inherited by "HKEY_CLASSES_ROOT"
+  // anyway, and can be written by unprivileged users.
+
+  if (protocol.empty())
+    return false;
+
+  base::FilePath path;
+  if (!PathService::Get(base::FILE_EXE, &path)) {
+    LOG(ERROR) << "Error getting app exe path";
+    return false;
+  }
+
+  // Main Registry Key
+  HKEY root = HKEY_CURRENT_USER;
+  std::string keyPathStr = "Software\\Classes\\" + protocol;
+  std::wstring keyPath = std::wstring(keyPathStr.begin(), keyPathStr.end());
+  std::string urlDeclStr = "URL:" + protocol;
+  std::wstring urlDecl = std::wstring(urlDeclStr.begin(), urlDeclStr.end());
+
+  // Command Key
+  std::string cmdPathStr = keyPathStr + "\\shell\\open\\command";
+  std::wstring cmdPath = std::wstring(cmdPathStr.begin(), cmdPathStr.end());
+
+  // Executable Path
+  std::wstring exePath(path.value());
+  std::wstring exe = L"\"" + exePath + L"\" \"%1\"";
+
+  // Write information to registry
+  base::win::RegKey key(root, keyPath.c_str(), KEY_ALL_ACCESS);
+  if (FAILED(key.WriteValue(L"URL Protocol", L"")) ||
+      FAILED(key.WriteValue(L"", urlDecl.c_str())))
+    return false;
+
+  base::win::RegKey commandKey(root, cmdPath.c_str(), KEY_ALL_ACCESS);
+  if (FAILED(commandKey.WriteValue(L"", exe.c_str())))
+    return false;
+
+  return true;
+}
+
+PCWSTR Browser::GetAppUserModelID() {
+  if (app_user_model_id_.empty()) {
+    SetAppUserModelID(base::ReplaceStringPlaceholders(
+        kAppUserModelIDFormat, base::UTF8ToUTF16(GetName()), nullptr));
+  }
+
+  return app_user_model_id_.c_str();
+}
+
+std::string Browser::GetExecutableFileVersion() const {
+  base::FilePath path;
+  if (PathService::Get(base::FILE_EXE, &path)) {
+    scoped_ptr<FileVersionInfo> version_info(
+        FileVersionInfo::CreateFileVersionInfo(path));
+    return base::UTF16ToUTF8(version_info->product_version());
+  }
+
+  return ELECTRON_VERSION_STRING;
+}
+
+std::string Browser::GetExecutableFileProductName() const {
+  base::FilePath path;
+  if (PathService::Get(base::FILE_EXE, &path)) {
+    scoped_ptr<FileVersionInfo> version_info(
+        FileVersionInfo::CreateFileVersionInfo(path));
+    return base::UTF16ToUTF8(version_info->product_name());
+  }
+
+  return ELECTRON_PRODUCT_NAME;
+}
+
+}  // namespace electron
added in remote
  their  100644 b04e9d46211bfb28e6e0f3628ffb3605140f1a66 electron/browser/common_web_contents_delegate.cc
@@ -0,0 +1,443 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/common_web_contents_delegate.h"
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_javascript_dialog_manager.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "electron/browser/web_dialog_helper.h"
+#include "base/files/file_util.h"
+#include "base/prefs/pref_service.h"
+#include "base/prefs/scoped_user_pref_update.h"
+#include "chrome/browser/printing/print_preview_message_handler.h"
+#include "chrome/browser/printing/print_view_manager_basic.h"
+#include "chrome/browser/ui/browser_dialogs.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "storage/browser/fileapi/isolated_context.h"
+
+#if defined(TOOLKIT_VIEWS)
+#include "electron/browser/native_window_views.h"
+#endif
+
+#if defined(USE_X11)
+#include "electron/browser/browser.h"
+#endif
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+const char kRootName[] = "<root>";
+
+struct FileSystem {
+  FileSystem() {
+  }
+  FileSystem(const std::string& file_system_name,
+             const std::string& root_url,
+             const std::string& file_system_path)
+    : file_system_name(file_system_name),
+      root_url(root_url),
+      file_system_path(file_system_path) {
+  }
+
+  std::string file_system_name;
+  std::string root_url;
+  std::string file_system_path;
+};
+
+std::string RegisterFileSystem(content::WebContents* web_contents,
+                               const base::FilePath& path) {
+  auto isolated_context = storage::IsolatedContext::GetInstance();
+  std::string root_name(kRootName);
+  std::string file_system_id = isolated_context->RegisterFileSystemForPath(
+      storage::kFileSystemTypeNativeLocal,
+      std::string(),
+      path,
+      &root_name);
+
+  content::ChildProcessSecurityPolicy* policy =
+      content::ChildProcessSecurityPolicy::GetInstance();
+  content::RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
+  int renderer_id = render_view_host->GetProcess()->GetID();
+  policy->GrantReadFileSystem(renderer_id, file_system_id);
+  policy->GrantWriteFileSystem(renderer_id, file_system_id);
+  policy->GrantCreateFileForFileSystem(renderer_id, file_system_id);
+  policy->GrantDeleteFromFileSystem(renderer_id, file_system_id);
+
+  if (!policy->CanReadFile(renderer_id, path))
+    policy->GrantReadFile(renderer_id, path);
+
+  return file_system_id;
+}
+
+FileSystem CreateFileSystemStruct(
+    content::WebContents* web_contents,
+    const std::string& file_system_id,
+    const std::string& file_system_path) {
+  const GURL origin = web_contents->GetURL().GetOrigin();
+  std::string file_system_name =
+      storage::GetIsolatedFileSystemName(origin, file_system_id);
+  std::string root_url = storage::GetIsolatedFileSystemRootURIString(
+      origin, file_system_id, kRootName);
+  return FileSystem(file_system_name, root_url, file_system_path);
+}
+
+base::DictionaryValue* CreateFileSystemValue(const FileSystem& file_system) {
+  base::DictionaryValue* file_system_value = new base::DictionaryValue();
+  file_system_value->SetString("fileSystemName", file_system.file_system_name);
+  file_system_value->SetString("rootURL", file_system.root_url);
+  file_system_value->SetString("fileSystemPath", file_system.file_system_path);
+  return file_system_value;
+}
+
+void WriteToFile(const base::FilePath& path,
+                 const std::string& content) {
+  DCHECK_CURRENTLY_ON(BrowserThread::FILE);
+  DCHECK(!path.empty());
+
+  base::WriteFile(path, content.data(), content.size());
+}
+
+void AppendToFile(const base::FilePath& path,
+                  const std::string& content) {
+  DCHECK_CURRENTLY_ON(BrowserThread::FILE);
+  DCHECK(!path.empty());
+
+  base::AppendToFile(path, content.data(), content.size());
+}
+
+PrefService* GetPrefService(content::WebContents* web_contents) {
+  auto context = web_contents->GetBrowserContext();
+  return static_cast<electron::ElectronBrowserContext*>(context)->prefs();
+}
+
+std::set<std::string> GetAddedFileSystemPaths(
+    content::WebContents* web_contents) {
+  auto pref_service = GetPrefService(web_contents);
+  const base::DictionaryValue* file_system_paths_value =
+      pref_service->GetDictionary(prefs::kDevToolsFileSystemPaths);
+  std::set<std::string> result;
+  if (file_system_paths_value) {
+    base::DictionaryValue::Iterator it(*file_system_paths_value);
+    for (; !it.IsAtEnd(); it.Advance()) {
+      result.insert(it.key());
+    }
+  }
+  return result;
+}
+
+}  // namespace
+
+CommonWebContentsDelegate::CommonWebContentsDelegate()
+    : html_fullscreen_(false),
+      native_fullscreen_(false) {
+}
+
+CommonWebContentsDelegate::~CommonWebContentsDelegate() {
+}
+
+void CommonWebContentsDelegate::InitWithWebContents(
+    content::WebContents* web_contents) {
+  web_contents->SetDelegate(this);
+
+  printing::PrintViewManagerBasic::CreateForWebContents(web_contents);
+  printing::PrintPreviewMessageHandler::CreateForWebContents(web_contents);
+
+  // Create InspectableWebContents.
+  web_contents_.reset(brightray::InspectableWebContents::Create(web_contents));
+  web_contents_->SetDelegate(this);
+}
+
+void CommonWebContentsDelegate::SetOwnerWindow(NativeWindow* owner_window) {
+  SetOwnerWindow(GetWebContents(), owner_window);
+}
+
+void CommonWebContentsDelegate::SetOwnerWindow(
+    content::WebContents* web_contents, NativeWindow* owner_window) {
+  owner_window_ = owner_window->GetWeakPtr();
+  NativeWindowRelay* relay = new NativeWindowRelay(owner_window_);
+  web_contents->SetUserData(relay->key, relay);
+}
+
+void CommonWebContentsDelegate::DestroyWebContents() {
+  web_contents_.reset();
+}
+
+content::WebContents* CommonWebContentsDelegate::GetWebContents() const {
+  if (!web_contents_)
+    return nullptr;
+  return web_contents_->GetWebContents();
+}
+
+content::WebContents*
+CommonWebContentsDelegate::GetDevToolsWebContents() const {
+  if (!web_contents_)
+    return nullptr;
+  return web_contents_->GetDevToolsWebContents();
+}
+
+content::WebContents* CommonWebContentsDelegate::OpenURLFromTab(
+    content::WebContents* source,
+    const content::OpenURLParams& params) {
+  content::NavigationController::LoadURLParams load_url_params(params.url);
+  load_url_params.referrer = params.referrer;
+  load_url_params.transition_type = params.transition;
+  load_url_params.extra_headers = params.extra_headers;
+  load_url_params.should_replace_current_entry =
+      params.should_replace_current_entry;
+  load_url_params.is_renderer_initiated = params.is_renderer_initiated;
+  load_url_params.should_clear_history_list = true;
+
+  source->GetController().LoadURLWithParams(load_url_params);
+  return source;
+}
+
+bool CommonWebContentsDelegate::CanOverscrollContent() const {
+  return false;
+}
+
+content::JavaScriptDialogManager*
+CommonWebContentsDelegate::GetJavaScriptDialogManager(
+    content::WebContents* source) {
+  if (!dialog_manager_)
+    dialog_manager_.reset(new ElectronJavaScriptDialogManager);
+
+  return dialog_manager_.get();
+}
+
+content::ColorChooser* CommonWebContentsDelegate::OpenColorChooser(
+    content::WebContents* web_contents,
+    SkColor color,
+    const std::vector<content::ColorSuggestion>& suggestions) {
+  return chrome::ShowColorChooser(web_contents, color);
+}
+
+void CommonWebContentsDelegate::RunFileChooser(
+    content::WebContents* guest,
+    const content::FileChooserParams& params) {
+  if (!web_dialog_helper_)
+    web_dialog_helper_.reset(new WebDialogHelper(owner_window()));
+  web_dialog_helper_->RunFileChooser(guest, params);
+}
+
+void CommonWebContentsDelegate::EnumerateDirectory(content::WebContents* guest,
+                                                   int request_id,
+                                                   const base::FilePath& path) {
+  if (!web_dialog_helper_)
+    web_dialog_helper_.reset(new WebDialogHelper(owner_window()));
+  web_dialog_helper_->EnumerateDirectory(guest, request_id, path);
+}
+
+void CommonWebContentsDelegate::EnterFullscreenModeForTab(
+    content::WebContents* source, const GURL& origin) {
+  if (!owner_window_)
+    return;
+  SetHtmlApiFullscreen(true);
+  owner_window_->NotifyWindowEnterHtmlFullScreen();
+  source->GetRenderViewHost()->GetWidget()->WasResized();
+}
+
+void CommonWebContentsDelegate::ExitFullscreenModeForTab(
+    content::WebContents* source) {
+  if (!owner_window_)
+    return;
+  SetHtmlApiFullscreen(false);
+  owner_window_->NotifyWindowLeaveHtmlFullScreen();
+  source->GetRenderViewHost()->GetWidget()->WasResized();
+}
+
+bool CommonWebContentsDelegate::IsFullscreenForTabOrPending(
+    const content::WebContents* source) const {
+  return html_fullscreen_;
+}
+
+void CommonWebContentsDelegate::DevToolsSaveToFile(
+    const std::string& url, const std::string& content, bool save_as) {
+  base::FilePath path;
+  PathsMap::iterator it = saved_files_.find(url);
+  if (it != saved_files_.end() && !save_as) {
+    path = it->second;
+  } else {
+    file_dialog::Filters filters;
+    base::FilePath default_path(base::FilePath::FromUTF8Unsafe(url));
+    if (!file_dialog::ShowSaveDialog(owner_window(), url, default_path,
+                                     filters, &path)) {
+      base::StringValue url_value(url);
+      web_contents_->CallClientFunction(
+          "DevToolsAPI.canceledSaveURL", &url_value, nullptr, nullptr);
+      return;
+    }
+  }
+
+  saved_files_[url] = path;
+  BrowserThread::PostTaskAndReply(
+      BrowserThread::FILE, FROM_HERE,
+      base::Bind(&WriteToFile, path, content),
+      base::Bind(&CommonWebContentsDelegate::OnDevToolsSaveToFile,
+                 base::Unretained(this), url));
+}
+
+void CommonWebContentsDelegate::DevToolsAppendToFile(
+    const std::string& url, const std::string& content) {
+  PathsMap::iterator it = saved_files_.find(url);
+  if (it == saved_files_.end())
+    return;
+
+  BrowserThread::PostTaskAndReply(
+      BrowserThread::FILE, FROM_HERE,
+      base::Bind(&AppendToFile, it->second, content),
+      base::Bind(&CommonWebContentsDelegate::OnDevToolsAppendToFile,
+                 base::Unretained(this), url));
+}
+
+void CommonWebContentsDelegate::DevToolsRequestFileSystems() {
+  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
+  if (file_system_paths.empty()) {
+    base::ListValue empty_file_system_value;
+    web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
+                                      &empty_file_system_value,
+                                      nullptr, nullptr);
+    return;
+  }
+
+  std::vector<FileSystem> file_systems;
+  for (auto file_system_path : file_system_paths) {
+    base::FilePath path = base::FilePath::FromUTF8Unsafe(file_system_path);
+    std::string file_system_id = RegisterFileSystem(GetDevToolsWebContents(),
+                                                    path);
+    FileSystem file_system = CreateFileSystemStruct(GetDevToolsWebContents(),
+                                                    file_system_id,
+                                                    file_system_path);
+    file_systems.push_back(file_system);
+  }
+
+  base::ListValue file_system_value;
+  for (size_t i = 0; i < file_systems.size(); ++i)
+    file_system_value.Append(CreateFileSystemValue(file_systems[i]));
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemsLoaded",
+                                    &file_system_value, nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::DevToolsAddFileSystem(
+    const base::FilePath& file_system_path) {
+  base::FilePath path = file_system_path;
+  if (path.empty()) {
+    file_dialog::Filters filters;
+    base::FilePath default_path;
+    std::vector<base::FilePath> paths;
+    int flag = file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
+    if (!file_dialog::ShowOpenDialog(owner_window(), "", default_path,
+                                     filters, flag, &paths))
+      return;
+
+    path = paths[0];
+  }
+
+  std::string file_system_id = RegisterFileSystem(GetDevToolsWebContents(),
+                                                  path);
+  auto file_system_paths = GetAddedFileSystemPaths(GetDevToolsWebContents());
+  if (file_system_paths.find(path.AsUTF8Unsafe()) != file_system_paths.end())
+    return;
+
+  FileSystem file_system = CreateFileSystemStruct(GetDevToolsWebContents(),
+                                                 file_system_id,
+                                                 path.AsUTF8Unsafe());
+  scoped_ptr<base::DictionaryValue> file_system_value(
+      CreateFileSystemValue(file_system));
+
+  auto pref_service = GetPrefService(GetDevToolsWebContents());
+  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
+  update.Get()->SetWithoutPathExpansion(
+      path.AsUTF8Unsafe(), base::Value::CreateNullValue());
+
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemAdded",
+                                    file_system_value.get(),
+                                    nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::DevToolsRemoveFileSystem(
+    const base::FilePath& file_system_path) {
+  if (!web_contents_)
+    return;
+
+  std::string path = file_system_path.AsUTF8Unsafe();
+  storage::IsolatedContext::GetInstance()->
+      RevokeFileSystemByPath(file_system_path);
+
+  auto pref_service = GetPrefService(GetDevToolsWebContents());
+  DictionaryPrefUpdate update(pref_service, prefs::kDevToolsFileSystemPaths);
+  update.Get()->RemoveWithoutPathExpansion(path, nullptr);
+
+  base::StringValue file_system_path_value(path);
+  web_contents_->CallClientFunction("DevToolsAPI.fileSystemRemoved",
+                                    &file_system_path_value,
+                                    nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::OnDevToolsSaveToFile(
+    const std::string& url) {
+  // Notify DevTools.
+  base::StringValue url_value(url);
+  web_contents_->CallClientFunction(
+      "DevToolsAPI.savedURL", &url_value, nullptr, nullptr);
+}
+
+void CommonWebContentsDelegate::OnDevToolsAppendToFile(
+    const std::string& url) {
+  // Notify DevTools.
+  base::StringValue url_value(url);
+  web_contents_->CallClientFunction(
+      "DevToolsAPI.appendedToURL", &url_value, nullptr, nullptr);
+}
+
+#if defined(TOOLKIT_VIEWS)
+gfx::ImageSkia CommonWebContentsDelegate::GetDevToolsWindowIcon() {
+  if (!owner_window())
+    return gfx::ImageSkia();
+  return static_cast<views::WidgetDelegate*>(static_cast<NativeWindowViews*>(
+      owner_window()))->GetWindowAppIcon();
+}
+#endif
+
+#if defined(USE_X11)
+void CommonWebContentsDelegate::GetDevToolsWindowWMClass(
+    std::string* name, std::string* class_name) {
+  *class_name = Browser::Get()->GetName();
+  *name = base::ToLowerASCII(*class_name);
+}
+#endif
+
+void CommonWebContentsDelegate::SetHtmlApiFullscreen(bool enter_fullscreen) {
+  // Window is already in fullscreen mode, save the state.
+  if (enter_fullscreen && owner_window_->IsFullscreen()) {
+    native_fullscreen_ = true;
+    html_fullscreen_ = true;
+    return;
+  }
+
+  // Exit html fullscreen state but not window's fullscreen mode.
+  if (!enter_fullscreen && native_fullscreen_) {
+    html_fullscreen_ = false;
+    return;
+  }
+
+  owner_window_->SetFullScreen(enter_fullscreen);
+  html_fullscreen_ = enter_fullscreen;
+  native_fullscreen_ = false;
+}
+
+}  // namespace electron
added in remote
  their  100644 9a35fe85ae53a4ffe98b7fb7f9c75dac12980963 electron/browser/common_web_contents_delegate.h
@@ -0,0 +1,137 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
+#define ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "brightray/browser/inspectable_web_contents_impl.h"
+#include "brightray/browser/inspectable_web_contents_delegate.h"
+#include "brightray/browser/inspectable_web_contents_view_delegate.h"
+#include "content/public/browser/web_contents_delegate.h"
+
+namespace electron {
+
+class ElectronJavaScriptDialogManager;
+class NativeWindow;
+class WebDialogHelper;
+
+class CommonWebContentsDelegate
+    : public content::WebContentsDelegate,
+      public brightray::InspectableWebContentsDelegate,
+      public brightray::InspectableWebContentsViewDelegate {
+ public:
+  CommonWebContentsDelegate();
+  virtual ~CommonWebContentsDelegate();
+
+  // Creates a InspectableWebContents object and takes onwership of
+  // |web_contents|.
+  void InitWithWebContents(content::WebContents* web_contents);
+
+  // Set the window as owner window.
+  void SetOwnerWindow(NativeWindow* owner_window);
+  void SetOwnerWindow(content::WebContents* web_contents,
+                      NativeWindow* owner_window);
+
+  // Destroy the managed InspectableWebContents object.
+  void DestroyWebContents();
+
+  // Returns the WebContents managed by this delegate.
+  content::WebContents* GetWebContents() const;
+
+  // Returns the WebContents of devtools.
+  content::WebContents* GetDevToolsWebContents() const;
+
+  brightray::InspectableWebContents* managed_web_contents() const {
+    return web_contents_.get();
+  }
+
+  NativeWindow* owner_window() const { return owner_window_.get(); }
+
+  bool is_html_fullscreen() const { return html_fullscreen_; }
+
+ protected:
+  // content::WebContentsDelegate:
+  content::WebContents* OpenURLFromTab(
+      content::WebContents* source,
+      const content::OpenURLParams& params) override;
+  bool CanOverscrollContent() const override;
+  content::JavaScriptDialogManager* GetJavaScriptDialogManager(
+      content::WebContents* source) override;
+  content::ColorChooser* OpenColorChooser(
+      content::WebContents* web_contents,
+      SkColor color,
+      const std::vector<content::ColorSuggestion>& suggestions) override;
+  void RunFileChooser(content::WebContents* web_contents,
+                      const content::FileChooserParams& params) override;
+  void EnumerateDirectory(content::WebContents* web_contents,
+                          int request_id,
+                          const base::FilePath& path) override;
+  void EnterFullscreenModeForTab(content::WebContents* source,
+                                 const GURL& origin) override;
+  void ExitFullscreenModeForTab(content::WebContents* source) override;
+  bool IsFullscreenForTabOrPending(
+      const content::WebContents* source) const override;
+
+  // brightray::InspectableWebContentsDelegate:
+  void DevToolsSaveToFile(const std::string& url,
+                          const std::string& content,
+                          bool save_as) override;
+  void DevToolsAppendToFile(const std::string& url,
+                            const std::string& content) override;
+  void DevToolsRequestFileSystems() override;
+  void DevToolsAddFileSystem(const base::FilePath& path) override;
+  void DevToolsRemoveFileSystem(
+      const base::FilePath& file_system_path) override;
+
+  // brightray::InspectableWebContentsViewDelegate:
+#if defined(TOOLKIT_VIEWS)
+  gfx::ImageSkia GetDevToolsWindowIcon() override;
+#endif
+#if defined(USE_X11)
+  void GetDevToolsWindowWMClass(
+      std::string* name, std::string* class_name) override;
+#endif
+
+ private:
+  // Callback for when DevToolsSaveToFile has completed.
+  void OnDevToolsSaveToFile(const std::string& url);
+
+  // Callback for when DevToolsAppendToFile has completed.
+  void OnDevToolsAppendToFile(const std::string& url);
+
+  // Set fullscreen mode triggered by html api.
+  void SetHtmlApiFullscreen(bool enter_fullscreen);
+
+  // The window that this WebContents belongs to.
+  base::WeakPtr<NativeWindow> owner_window_;
+
+  // Whether window is fullscreened by HTML5 api.
+  bool html_fullscreen_;
+
+  // Whether window is fullscreened by window api.
+  bool native_fullscreen_;
+
+  scoped_ptr<WebDialogHelper> web_dialog_helper_;
+  scoped_ptr<ElectronJavaScriptDialogManager> dialog_manager_;
+
+  // The stored InspectableWebContents object.
+  // Notice that web_contents_ must be placed after dialog_manager_, so we can
+  // make sure web_contents_ is destroyed before dialog_manager_, otherwise a
+  // crash would happen.
+  scoped_ptr<brightray::InspectableWebContents> web_contents_;
+
+  // Maps url to file path, used by the file requests sent from devtools.
+  typedef std::map<std::string, base::FilePath> PathsMap;
+  PathsMap saved_files_;
+
+  DISALLOW_COPY_AND_ASSIGN(CommonWebContentsDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_COMMON_WEB_CONTENTS_DELEGATE_H_
added in remote
  their  100644 da7cef5479361a662c388a5e81526c3a343aa702 electron/browser/electron_access_token_store.cc
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_access_token_store.h"
+
+#include <utility>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/common/google_api_key.h"
+#include "content/public/browser/geolocation_provider.h"
+
+namespace electron {
+
+namespace {
+
+// Notice that we just combined the api key with the url together here, because
+// if we use the standard {url: key} format Chromium would override our key with
+// the predefined one in common.gypi of libchromiumcontent, which is empty.
+const char* kGeolocationProviderURL =
+    "https://www.googleapis.com/geolocation/v1/geolocate?key="
+    GOOGLEAPIS_API_KEY;
+
+}  // namespace
+
+ElectronAccessTokenStore::ElectronAccessTokenStore() {
+  content::GeolocationProvider::GetInstance()->UserDidOptIntoLocationServices();
+}
+
+ElectronAccessTokenStore::~ElectronAccessTokenStore() {
+}
+
+void ElectronAccessTokenStore::LoadAccessTokens(
+    const LoadAccessTokensCallbackType& callback) {
+  AccessTokenSet access_token_set;
+
+  // Equivelent to access_token_set[kGeolocationProviderURL].
+  // Somehow base::string16 is causing compilation errors when used in a pair
+  // of std::map on Linux, this can work around it.
+  std::pair<GURL, base::string16> token_pair;
+  token_pair.first = GURL(kGeolocationProviderURL);
+  access_token_set.insert(token_pair);
+
+  auto browser_context = ElectronBrowserMainParts::Get()->browser_context();
+  callback.Run(access_token_set, browser_context->url_request_context_getter());
+}
+
+void ElectronAccessTokenStore::SaveAccessToken(const GURL& server_url,
+                                           const base::string16& access_token) {
+}
+
+}  // namespace electron
added in remote
  their  100644 cfc689532517feb9cc0283c3bea033dac5c02752 electron/browser/electron_access_token_store.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
+#define ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
+
+#include "content/public/browser/access_token_store.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+class ElectronAccessTokenStore : public content::AccessTokenStore {
+ public:
+  ElectronAccessTokenStore();
+  virtual ~ElectronAccessTokenStore();
+
+  // content::AccessTokenStore:
+  void LoadAccessTokens(
+      const LoadAccessTokensCallbackType& callback) override;
+  void SaveAccessToken(const GURL& server_url,
+                       const base::string16& access_token) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronAccessTokenStore);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_ACCESS_TOKEN_STORE_H_
added in remote
  their  100644 41d51d8c8347f0a1e577bd9ba6fe7eb90b905555 electron/browser/electron_browser_client.cc
@@ -0,0 +1,302 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_client.h"
+
+#if defined(OS_WIN)
+#include <shlobj.h>
+#endif
+
+#include "electron/browser/electron_access_token_store.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_quota_permission_context.h"
+#include "electron/browser/electron_resource_dispatcher_host_delegate.h"
+#include "electron/browser/electron_speech_recognition_manager_delegate.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/browser/web_contents_preferences.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "chrome/browser/printing/printing_message_filter.h"
+#include "chrome/browser/renderer_host/pepper/chrome_browser_pepper_host_factory.h"
+#include "chrome/browser/renderer_host/pepper/widevine_cdm_message_filter.h"
+#include "chrome/browser/speech/tts_message_filter.h"
+#include "content/public/browser/browser_ppapi_host.h"
+#include "content/public/browser/client_certificate_delegate.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/resource_dispatcher_host.h"
+#include "content/public/browser/site_instance.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/web_preferences.h"
+#include "net/cert/x509_certificate.h"
+#include "net/ssl/ssl_cert_request_info.h"
+#include "ppapi/host/ppapi_host.h"
+#include "ui/base/l10n/l10n_util.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+namespace {
+
+// Next navigation should not restart renderer process.
+bool g_suppress_renderer_process_restart = false;
+
+// Custom schemes to be registered to standard.
+std::string g_custom_schemes = "";
+// Custom schemes to be registered to handle service worker.
+std::string g_custom_service_worker_schemes = "";
+
+scoped_refptr<net::X509Certificate> ImportCertFromFile(
+    const base::FilePath& path) {
+  if (path.empty())
+    return nullptr;
+
+  std::string cert_data;
+  if (!base::ReadFileToString(path, &cert_data))
+    return nullptr;
+
+  net::CertificateList certs =
+      net::X509Certificate::CreateCertificateListFromBytes(
+          cert_data.data(), cert_data.size(),
+          net::X509Certificate::FORMAT_AUTO);
+
+  if (certs.empty())
+    return nullptr;
+
+  return certs[0];
+}
+
+}  // namespace
+
+// static
+void ElectronBrowserClient::SuppressRendererProcessRestartForOnce() {
+  g_suppress_renderer_process_restart = true;
+}
+
+void ElectronBrowserClient::SetCustomSchemes(
+    const std::vector<std::string>& schemes) {
+  g_custom_schemes = base::JoinString(schemes, ",");
+}
+
+void ElectronBrowserClient::SetCustomServiceWorkerSchemes(
+    const std::vector<std::string>& schemes) {
+  g_custom_service_worker_schemes = base::JoinString(schemes, ",");
+}
+
+ElectronBrowserClient::ElectronBrowserClient() : delegate_(nullptr) {
+}
+
+ElectronBrowserClient::~ElectronBrowserClient() {
+}
+
+void ElectronBrowserClient::RenderProcessWillLaunch(
+    content::RenderProcessHost* host) {
+  int process_id = host->GetID();
+  host->AddFilter(new printing::PrintingMessageFilter(process_id));
+  host->AddFilter(new TtsMessageFilter(process_id, host->GetBrowserContext()));
+  host->AddFilter(
+      new WidevineCdmMessageFilter(process_id, host->GetBrowserContext()));
+}
+
+content::SpeechRecognitionManagerDelegate*
+    ElectronBrowserClient::CreateSpeechRecognitionManagerDelegate() {
+  return new ElectronSpeechRecognitionManagerDelegate;
+}
+
+content::AccessTokenStore* ElectronBrowserClient::CreateAccessTokenStore() {
+  return new ElectronAccessTokenStore;
+}
+
+void ElectronBrowserClient::OverrideWebkitPrefs(
+    content::RenderViewHost* host, content::WebPreferences* prefs) {
+  prefs->javascript_enabled = true;
+  prefs->web_security_enabled = true;
+  prefs->javascript_can_open_windows_automatically = true;
+  prefs->plugins_enabled = true;
+  prefs->dom_paste_enabled = true;
+  prefs->allow_scripts_to_close_windows = true;
+  prefs->javascript_can_access_clipboard = true;
+  prefs->local_storage_enabled = true;
+  prefs->databases_enabled = true;
+  prefs->application_cache_enabled = true;
+  prefs->allow_universal_access_from_file_urls = true;
+  prefs->allow_file_access_from_file_urls = true;
+  prefs->experimental_webgl_enabled = true;
+  prefs->allow_displaying_insecure_content = false;
+  prefs->allow_running_insecure_content = false;
+
+  // Custom preferences of guest page.
+  auto web_contents = content::WebContents::FromRenderViewHost(host);
+  WebContentsPreferences::OverrideWebkitPrefs(web_contents, prefs);
+}
+
+std::string ElectronBrowserClient::GetApplicationLocale() {
+  return l10n_util::GetApplicationLocale("");
+}
+
+void ElectronBrowserClient::OverrideSiteInstanceForNavigation(
+    content::BrowserContext* browser_context,
+    content::SiteInstance* current_instance,
+    const GURL& url,
+    content::SiteInstance** new_instance) {
+  if (g_suppress_renderer_process_restart) {
+    g_suppress_renderer_process_restart = false;
+    return;
+  }
+
+  // Restart renderer process for all navigations except "javacript:" scheme.
+  if (url.SchemeIs(url::kJavaScriptScheme))
+    return;
+
+  *new_instance = content::SiteInstance::CreateForURL(browser_context, url);
+
+  // Remember the original renderer process of the pending renderer process.
+  auto current_process = current_instance->GetProcess();
+  auto pending_process = (*new_instance)->GetProcess();
+  pending_processes_[pending_process->GetID()] = current_process->GetID();
+  // Clear the entry in map when process ends.
+  current_process->AddObserver(this);
+}
+
+void ElectronBrowserClient::AppendExtraCommandLineSwitches(
+    base::CommandLine* command_line,
+    int process_id) {
+  std::string process_type = command_line->GetSwitchValueASCII("type");
+  if (process_type != "renderer")
+    return;
+
+  // The registered standard schemes.
+  if (!g_custom_schemes.empty())
+    command_line->AppendSwitchASCII(switches::kRegisterStandardSchemes,
+                                    g_custom_schemes);
+
+  // The registered service worker schemes.
+  if (!g_custom_service_worker_schemes.empty())
+    command_line->AppendSwitchASCII(switches::kRegisterServiceWorkerSchemes,
+                                    g_custom_service_worker_schemes);
+
+#if defined(OS_WIN)
+  // Append --app-user-model-id.
+  PWSTR current_app_id;
+  if (SUCCEEDED(GetCurrentProcessExplicitAppUserModelID(&current_app_id))) {
+    command_line->AppendSwitchNative(switches::kAppUserModelId, current_app_id);
+    CoTaskMemFree(current_app_id);
+  }
+#endif
+
+  // If the process is a pending process, we should use the old one.
+  if (ContainsKey(pending_processes_, process_id))
+    process_id = pending_processes_[process_id];
+
+  // Certain render process will be created with no associated render view,
+  // for example: ServiceWorker.
+  content::WebContents* web_contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(process_id);
+  if (!web_contents)
+    return;
+
+  WebContentsPreferences::AppendExtraCommandLineSwitches(
+      web_contents, command_line);
+}
+
+void ElectronBrowserClient::DidCreatePpapiPlugin(
+    content::BrowserPpapiHost* host) {
+  host->GetPpapiHost()->AddHostFactoryFilter(
+      make_scoped_ptr(new chrome::ChromeBrowserPepperHostFactory(host)));
+}
+
+content::QuotaPermissionContext*
+    ElectronBrowserClient::CreateQuotaPermissionContext() {
+  return new ElectronQuotaPermissionContext;
+}
+
+void ElectronBrowserClient::AllowCertificateError(
+    content::WebContents* web_contents,
+    int cert_error,
+    const net::SSLInfo& ssl_info,
+    const GURL& request_url,
+    content::ResourceType resource_type,
+    bool overridable,
+    bool strict_enforcement,
+    bool expired_previous_decision,
+    const base::Callback<void(bool)>& callback,
+    content::CertificateRequestResultType* request) {
+  if (delegate_) {
+    delegate_->AllowCertificateError(
+        web_contents, cert_error, ssl_info, request_url,
+        resource_type, overridable, strict_enforcement,
+        expired_previous_decision, callback, request);
+  }
+}
+
+void ElectronBrowserClient::SelectClientCertificate(
+    content::WebContents* web_contents,
+    net::SSLCertRequestInfo* cert_request_info,
+    scoped_ptr<content::ClientCertificateDelegate> delegate) {
+  // --client-certificate=`path`
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch(switches::kClientCertificate)) {
+    auto cert_path = cmd->GetSwitchValuePath(switches::kClientCertificate);
+    auto certificate = ImportCertFromFile(cert_path);
+    if (certificate.get())
+      delegate->ContinueWithCertificate(certificate.get());
+    return;
+  }
+
+  if (!cert_request_info->client_certs.empty() && delegate_) {
+    delegate_->SelectClientCertificate(
+        web_contents, cert_request_info, std::move(delegate));
+  }
+}
+
+void ElectronBrowserClient::ResourceDispatcherHostCreated() {
+  resource_dispatcher_host_delegate_.reset(
+      new ElectronResourceDispatcherHostDelegate);
+  content::ResourceDispatcherHost::Get()->SetDelegate(
+      resource_dispatcher_host_delegate_.get());
+}
+
+brightray::BrowserMainParts* ElectronBrowserClient::OverrideCreateBrowserMainParts(
+    const content::MainFunctionParams&) {
+  v8::V8::Initialize();  // Init V8 before creating main parts.
+  return new ElectronBrowserMainParts;
+}
+
+void ElectronBrowserClient::WebNotificationAllowed(
+    int render_process_id,
+    const base::Callback<void(bool)>& callback) {
+  content::WebContents* web_contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(render_process_id);
+  if (!web_contents) {
+    callback.Run(false);
+    return;
+  }
+  auto permission_helper =
+      WebContentsPermissionHelper::FromWebContents(web_contents);
+  if (!permission_helper) {
+    callback.Run(false);
+    return;
+  }
+  permission_helper->RequestWebNotificationPermission(callback);
+}
+
+void ElectronBrowserClient::RenderProcessHostDestroyed(
+    content::RenderProcessHost* host) {
+  int process_id = host->GetID();
+  for (const auto& entry : pending_processes_) {
+    if (entry.first == process_id || entry.second == process_id) {
+      pending_processes_.erase(entry.first);
+      break;
+    }
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 5caf0726cdd06c49b68366b09e78348ed609297a electron/browser/electron_browser_client.h
@@ -0,0 +1,104 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "brightray/browser/browser_client.h"
+#include "content/public/browser/render_process_host_observer.h"
+
+namespace content {
+class QuotaPermissionContext;
+class ClientCertificateDelegate;
+}
+
+namespace net {
+class SSLCertRequestInfo;
+}
+
+namespace electron {
+
+class ElectronResourceDispatcherHostDelegate;
+
+class ElectronBrowserClient : public brightray::BrowserClient,
+                          public content::RenderProcessHostObserver {
+ public:
+  ElectronBrowserClient();
+  virtual ~ElectronBrowserClient();
+
+  using Delegate = content::ContentBrowserClient;
+  void set_delegate(Delegate* delegate) { delegate_ = delegate; }
+
+  // Don't force renderer process to restart for once.
+  static void SuppressRendererProcessRestartForOnce();
+  // Custom schemes to be registered to standard.
+  static void SetCustomSchemes(const std::vector<std::string>& schemes);
+  // Custom schemes to be registered to handle service worker.
+  static void SetCustomServiceWorkerSchemes(
+      const std::vector<std::string>& schemes);
+
+ protected:
+  // content::ContentBrowserClient:
+  void RenderProcessWillLaunch(content::RenderProcessHost* host) override;
+  content::SpeechRecognitionManagerDelegate*
+      CreateSpeechRecognitionManagerDelegate() override;
+  content::AccessTokenStore* CreateAccessTokenStore() override;
+  void OverrideWebkitPrefs(content::RenderViewHost* render_view_host,
+                           content::WebPreferences* prefs) override;
+  std::string GetApplicationLocale() override;
+  void OverrideSiteInstanceForNavigation(
+      content::BrowserContext* browser_context,
+      content::SiteInstance* current_instance,
+      const GURL& dest_url,
+      content::SiteInstance** new_instance) override;
+  void AppendExtraCommandLineSwitches(base::CommandLine* command_line,
+                                      int child_process_id) override;
+  void DidCreatePpapiPlugin(content::BrowserPpapiHost* browser_host) override;
+  content::QuotaPermissionContext* CreateQuotaPermissionContext() override;
+  void AllowCertificateError(
+      content::WebContents* web_contents,
+      int cert_error,
+      const net::SSLInfo& ssl_info,
+      const GURL& request_url,
+      content::ResourceType resource_type,
+      bool overridable,
+      bool strict_enforcement,
+      bool expired_previous_decision,
+      const base::Callback<void(bool)>& callback,
+      content::CertificateRequestResultType* request) override;
+  void SelectClientCertificate(
+      content::WebContents* web_contents,
+      net::SSLCertRequestInfo* cert_request_info,
+      scoped_ptr<content::ClientCertificateDelegate> delegate) override;
+  void ResourceDispatcherHostCreated() override;
+
+  // brightray::BrowserClient:
+  brightray::BrowserMainParts* OverrideCreateBrowserMainParts(
+      const content::MainFunctionParams&) override;
+  void WebNotificationAllowed(
+      int render_process_id,
+      const base::Callback<void(bool)>& callback) override;
+
+  // content::RenderProcessHostObserver:
+  void RenderProcessHostDestroyed(content::RenderProcessHost* host) override;
+
+ private:
+  // pending_render_process => current_render_process.
+  std::map<int, int> pending_processes_;
+
+  scoped_ptr<ElectronResourceDispatcherHostDelegate>
+      resource_dispatcher_host_delegate_;
+
+  Delegate* delegate_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_CLIENT_H_
added in remote
  their  100644 3345ea0c21c29a299a3829d8f50bb9b8bacae8d6 electron/browser/electron_browser_context.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_context.h"
+
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/electron_download_manager_delegate.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/net/electron_cert_verifier.h"
+#include "electron/browser/net/electron_network_delegate.h"
+#include "electron/browser/net/electron_ssl_config_service.h"
+#include "electron/browser/net/electron_url_request_job_factory.h"
+#include "electron/browser/net/asar/asar_protocol_handler.h"
+#include "electron/browser/net/http_protocol_handler.h"
+#include "electron/browser/electron_permission_manager.h"
+#include "electron/browser/web_view_manager.h"
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/path_service.h"
+#include "base/prefs/pref_registry_simple.h"
+#include "base/strings/string_util.h"
+#include "base/strings/stringprintf.h"
+#include "base/threading/sequenced_worker_pool.h"
+#include "base/threading/worker_pool.h"
+#include "chrome/common/chrome_paths.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/url_constants.h"
+#include "content/public/common/user_agent.h"
+#include "net/ftp/ftp_network_layer.h"
+#include "net/url_request/data_protocol_handler.h"
+#include "net/url_request/ftp_protocol_handler.h"
+#include "net/url_request/url_request_intercepting_job_factory.h"
+#include "net/url_request/url_request_context.h"
+#include "url/url_constants.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+class NoCacheBackend : public net::HttpCache::BackendFactory {
+  int CreateBackend(net::NetLog* net_log,
+                    scoped_ptr<disk_cache::Backend>* backend,
+                    const net::CompletionCallback& callback) override {
+    return net::ERR_FAILED;
+  }
+};
+
+std::string RemoveWhitespace(const std::string& str) {
+  std::string trimmed;
+  if (base::RemoveChars(str, " ", &trimmed))
+    return trimmed;
+  else
+    return str;
+}
+
+}  // namespace
+
+ElectronBrowserContext::ElectronBrowserContext(const std::string& partition,
+                                       bool in_memory)
+    : brightray::BrowserContext(partition, in_memory),
+      cert_verifier_(nullptr),
+      job_factory_(new ElectronURLRequestJobFactory),
+      network_delegate_(new ElectronNetworkDelegate),
+      allow_ntlm_everywhere_(false) {
+}
+
+ElectronBrowserContext::~ElectronBrowserContext() {
+}
+
+net::NetworkDelegate* ElectronBrowserContext::CreateNetworkDelegate() {
+  return network_delegate_;
+}
+
+std::string ElectronBrowserContext::GetUserAgent() {
+  Browser* browser = Browser::Get();
+  std::string name = RemoveWhitespace(browser->GetName());
+  std::string user_agent;
+  if (name == ELECTRON_PRODUCT_NAME) {
+    user_agent = "Chrome/" CHROME_VERSION_STRING " "
+                 ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING;
+  } else {
+    user_agent = base::StringPrintf(
+        "%s/%s Chrome/%s " ELECTRON_PRODUCT_NAME "/" ELECTRON_VERSION_STRING,
+        name.c_str(),
+        browser->GetVersion().c_str(),
+        CHROME_VERSION_STRING);
+  }
+  return content::BuildUserAgentFromProduct(user_agent);
+}
+
+scoped_ptr<net::URLRequestJobFactory>
+ElectronBrowserContext::CreateURLRequestJobFactory(
+    content::ProtocolHandlerMap* handlers,
+    content::URLRequestInterceptorScopedVector* interceptors) {
+  scoped_ptr<ElectronURLRequestJobFactory> job_factory(job_factory_);
+
+  for (auto& it : *handlers) {
+    job_factory->SetProtocolHandler(it.first,
+                                    make_scoped_ptr(it.second.release()));
+  }
+  handlers->clear();
+
+  job_factory->SetProtocolHandler(
+      url::kDataScheme, make_scoped_ptr(new net::DataProtocolHandler));
+  job_factory->SetProtocolHandler(
+      url::kFileScheme, make_scoped_ptr(new asar::AsarProtocolHandler(
+          BrowserThread::GetBlockingPool()->GetTaskRunnerWithShutdownBehavior(
+              base::SequencedWorkerPool::SKIP_ON_SHUTDOWN))));
+  job_factory->SetProtocolHandler(
+      url::kHttpScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kHttpScheme)));
+  job_factory->SetProtocolHandler(
+      url::kHttpsScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kHttpsScheme)));
+  job_factory->SetProtocolHandler(
+      url::kWsScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kWsScheme)));
+  job_factory->SetProtocolHandler(
+      url::kWssScheme,
+      make_scoped_ptr(new HttpProtocolHandler(url::kWssScheme)));
+
+  auto host_resolver =
+      url_request_context_getter()->GetURLRequestContext()->host_resolver();
+  job_factory->SetProtocolHandler(
+      url::kFtpScheme,
+      make_scoped_ptr(new net::FtpProtocolHandler(
+          new net::FtpNetworkLayer(host_resolver))));
+
+  // Set up interceptors in the reverse order.
+  scoped_ptr<net::URLRequestJobFactory> top_job_factory =
+      std::move(job_factory);
+  content::URLRequestInterceptorScopedVector::reverse_iterator it;
+  for (it = interceptors->rbegin(); it != interceptors->rend(); ++it)
+    top_job_factory.reset(new net::URLRequestInterceptingJobFactory(
+        std::move(top_job_factory), make_scoped_ptr(*it)));
+  interceptors->weak_clear();
+
+  return top_job_factory;
+}
+
+net::HttpCache::BackendFactory*
+ElectronBrowserContext::CreateHttpCacheBackendFactory(
+    const base::FilePath& base_path) {
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (command_line->HasSwitch(switches::kDisableHttpCache))
+    return new NoCacheBackend;
+  else
+    return brightray::BrowserContext::CreateHttpCacheBackendFactory(base_path);
+}
+
+content::DownloadManagerDelegate*
+ElectronBrowserContext::GetDownloadManagerDelegate() {
+  if (!download_manager_delegate_.get()) {
+    auto download_manager = content::BrowserContext::GetDownloadManager(this);
+    download_manager_delegate_.reset(
+        new ElectronDownloadManagerDelegate(download_manager));
+  }
+  return download_manager_delegate_.get();
+}
+
+content::BrowserPluginGuestManager* ElectronBrowserContext::GetGuestManager() {
+  if (!guest_manager_)
+    guest_manager_.reset(new WebViewManager);
+  return guest_manager_.get();
+}
+
+content::PermissionManager* ElectronBrowserContext::GetPermissionManager() {
+  if (!permission_manager_.get())
+    permission_manager_.reset(new ElectronPermissionManager);
+  return permission_manager_.get();
+}
+
+scoped_ptr<net::CertVerifier> ElectronBrowserContext::CreateCertVerifier() {
+  DCHECK(!cert_verifier_);
+  cert_verifier_ = new ElectronCertVerifier;
+  return make_scoped_ptr(cert_verifier_);
+}
+
+net::SSLConfigService* ElectronBrowserContext::CreateSSLConfigService() {
+  return new ElectronSSLConfigService;
+}
+
+void ElectronBrowserContext::RegisterPrefs(PrefRegistrySimple* pref_registry) {
+  pref_registry->RegisterFilePathPref(prefs::kSelectFileLastDirectory,
+                                      base::FilePath());
+  base::FilePath download_dir;
+  PathService::Get(chrome::DIR_DEFAULT_DOWNLOADS, &download_dir);
+  pref_registry->RegisterFilePathPref(prefs::kDownloadDefaultDirectory,
+                                      download_dir);
+  pref_registry->RegisterDictionaryPref(prefs::kDevToolsFileSystemPaths);
+}
+
+bool ElectronBrowserContext::AllowNTLMCredentialsForDomain(const GURL& origin) {
+  if (allow_ntlm_everywhere_)
+    return true;
+  return Delegate::AllowNTLMCredentialsForDomain(origin);
+}
+
+void ElectronBrowserContext::AllowNTLMCredentialsForAllDomains(bool should_allow) {
+  allow_ntlm_everywhere_ = should_allow;
+}
+
+}  // namespace electron
+
+namespace brightray {
+
+// static
+scoped_refptr<BrowserContext> BrowserContext::Create(
+    const std::string& partition, bool in_memory) {
+  return make_scoped_refptr(new electron::ElectronBrowserContext(partition, in_memory));
+}
+
+}  // namespace brightray
added in remote
  their  100644 c310aa5f351f2b0c3ab4ce6bf95aa561255dfb4e electron/browser/electron_browser_context.h
@@ -0,0 +1,71 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
+
+#include <string>
+
+#include "brightray/browser/browser_context.h"
+
+namespace electron {
+
+class ElectronDownloadManagerDelegate;
+class ElectronCertVerifier;
+class ElectronNetworkDelegate;
+class ElectronPermissionManager;
+class ElectronURLRequestJobFactory;
+class WebViewManager;
+
+class ElectronBrowserContext : public brightray::BrowserContext {
+ public:
+  ElectronBrowserContext(const std::string& partition, bool in_memory);
+  ~ElectronBrowserContext() override;
+
+  // brightray::URLRequestContextGetter::Delegate:
+  net::NetworkDelegate* CreateNetworkDelegate() override;
+  std::string GetUserAgent() override;
+  scoped_ptr<net::URLRequestJobFactory> CreateURLRequestJobFactory(
+      content::ProtocolHandlerMap* handlers,
+      content::URLRequestInterceptorScopedVector* interceptors) override;
+  net::HttpCache::BackendFactory* CreateHttpCacheBackendFactory(
+      const base::FilePath& base_path) override;
+  scoped_ptr<net::CertVerifier> CreateCertVerifier() override;
+  net::SSLConfigService* CreateSSLConfigService() override;
+  bool AllowNTLMCredentialsForDomain(const GURL& auth_origin) override;
+
+  // content::BrowserContext:
+  content::DownloadManagerDelegate* GetDownloadManagerDelegate() override;
+  content::BrowserPluginGuestManager* GetGuestManager() override;
+  content::PermissionManager* GetPermissionManager() override;
+
+  // brightray::BrowserContext:
+  void RegisterPrefs(PrefRegistrySimple* pref_registry) override;
+
+  void AllowNTLMCredentialsForAllDomains(bool should_allow);
+
+  ElectronCertVerifier* cert_verifier() const { return cert_verifier_; }
+
+  ElectronURLRequestJobFactory* job_factory() const { return job_factory_; }
+
+  ElectronNetworkDelegate* network_delegate() const { return network_delegate_; }
+
+ private:
+  scoped_ptr<ElectronDownloadManagerDelegate> download_manager_delegate_;
+  scoped_ptr<WebViewManager> guest_manager_;
+  scoped_ptr<ElectronPermissionManager> permission_manager_;
+
+  // Managed by brightray::BrowserContext.
+  ElectronCertVerifier* cert_verifier_;
+  ElectronURLRequestJobFactory* job_factory_;
+  ElectronNetworkDelegate* network_delegate_;
+
+  bool allow_ntlm_everywhere_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserContext);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_CONTEXT_H_
added in remote
  their  100644 3eb568425c7f3965effef3372a4f19d215c3f559 electron/browser/electron_browser_main_parts.cc
@@ -0,0 +1,189 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include "electron/browser/api/trackable_object.h"
+#include "electron/browser/electron_browser_client.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/bridge_task_runner.h"
+#include "electron/browser/browser.h"
+#include "electron/browser/javascript_environment.h"
+#include "electron/browser/node_debugger.h"
+#include "electron/common/api/electron_bindings.h"
+#include "electron/common/node_bindings.h"
+#include "electron/common/node_includes.h"
+#include "base/command_line.h"
+#include "base/thread_task_runner_handle.h"
+#include "chrome/browser/browser_process.h"
+#include "v8/include/v8-debug.h"
+
+#if defined(USE_X11)
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "ui/events/devices/x11/touch_factory_x11.h"
+#endif
+
+namespace electron {
+
+template<typename T>
+void Erase(T* container, typename T::iterator iter) {
+  container->erase(iter);
+}
+
+// static
+ElectronBrowserMainParts* ElectronBrowserMainParts::self_ = NULL;
+
+ElectronBrowserMainParts::ElectronBrowserMainParts()
+    : fake_browser_process_(new BrowserProcess),
+      exit_code_(nullptr),
+      browser_(new Browser),
+      node_bindings_(NodeBindings::Create(true)),
+      electron_bindings_(new ElectronBindings),
+      gc_timer_(true, true) {
+  DCHECK(!self_) << "Cannot have two ElectronBrowserMainParts";
+  self_ = this;
+}
+
+ElectronBrowserMainParts::~ElectronBrowserMainParts() {
+  // Leak the JavascriptEnvironment on exit.
+  // This is to work around the bug that V8 would be waiting for background
+  // tasks to finish on exit, while somehow it waits forever in Electron, more
+  // about this can be found at https://github.com/electron/electron/issues/4767.
+  // On the other handle there is actually no need to gracefully shutdown V8
+  // on exit in the main process, we already ensured all necessary resources get
+  // cleaned up, and it would make quitting faster.
+  ignore_result(js_env_.release());
+}
+
+// static
+ElectronBrowserMainParts* ElectronBrowserMainParts::Get() {
+  DCHECK(self_);
+  return self_;
+}
+
+bool ElectronBrowserMainParts::SetExitCode(int code) {
+  if (!exit_code_)
+    return false;
+
+  *exit_code_ = code;
+  return true;
+}
+
+int ElectronBrowserMainParts::GetExitCode() {
+  return exit_code_ != nullptr ? *exit_code_ : 0;
+}
+
+base::Closure ElectronBrowserMainParts::RegisterDestructionCallback(
+    const base::Closure& callback) {
+  auto iter = destructors_.insert(destructors_.end(), callback);
+  return base::Bind(&Erase<std::list<base::Closure>>, &destructors_, iter);
+}
+
+void ElectronBrowserMainParts::PreEarlyInitialization() {
+  brightray::BrowserMainParts::PreEarlyInitialization();
+#if defined(OS_POSIX)
+  HandleSIGCHLD();
+#endif
+}
+
+void ElectronBrowserMainParts::PostEarlyInitialization() {
+  brightray::BrowserMainParts::PostEarlyInitialization();
+
+  // Temporary set the bridge_task_runner_ as current thread's task runner,
+  // so we can fool gin::PerIsolateData to use it as its task runner, instead
+  // of getting current message loop's task runner, which is null for now.
+  bridge_task_runner_ = new BridgeTaskRunner;
+  base::ThreadTaskRunnerHandle handle(bridge_task_runner_);
+
+  // The ProxyResolverV8 has setup a complete V8 environment, in order to
+  // avoid conflicts we only initialize our V8 environment after that.
+  js_env_.reset(new JavascriptEnvironment);
+
+  node_bindings_->Initialize();
+
+  // Support the "--debug" switch.
+  node_debugger_.reset(new NodeDebugger(js_env_->isolate()));
+
+  // Create the global environment.
+  node::Environment* env =
+      node_bindings_->CreateEnvironment(js_env_->context());
+
+  // Make sure node can get correct environment when debugging.
+  if (node_debugger_->IsRunning())
+    env->AssignToContext(v8::Debug::GetDebugContext());
+
+  // Add Electron extended APIs.
+  electron_bindings_->BindTo(js_env_->isolate(), env->process_object());
+
+  // Load everything.
+  node_bindings_->LoadEnvironment(env);
+
+  // Wrap the uv loop with global env.
+  node_bindings_->set_uv_env(env);
+}
+
+void ElectronBrowserMainParts::PreMainMessageLoopRun() {
+  // Run user's main script before most things get initialized, so we can have
+  // a chance to setup everything.
+  node_bindings_->PrepareMessageLoop();
+  node_bindings_->RunMessageLoop();
+
+#if defined(USE_X11)
+  ui::TouchFactory::SetTouchDeviceListFromCommandLine();
+#endif
+
+  // Start idle gc.
+  gc_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMinutes(1),
+      base::Bind(base::IgnoreResult(&v8::Isolate::IdleNotification),
+                 base::Unretained(js_env_->isolate()),
+                 1000));
+
+  brightray::BrowserMainParts::PreMainMessageLoopRun();
+  bridge_task_runner_->MessageLoopIsReady();
+  bridge_task_runner_ = nullptr;
+
+#if defined(USE_X11)
+  libgtk2ui::GtkInitFromCommandLine(*base::CommandLine::ForCurrentProcess());
+#endif
+
+#if !defined(OS_MACOSX)
+  // The corresponding call in OS X is in ElectronApplicationDelegate.
+  Browser::Get()->WillFinishLaunching();
+  Browser::Get()->DidFinishLaunching();
+#endif
+}
+
+bool ElectronBrowserMainParts::MainMessageLoopRun(int* result_code) {
+  exit_code_ = result_code;
+  return brightray::BrowserMainParts::MainMessageLoopRun(result_code);
+}
+
+void ElectronBrowserMainParts::PostMainMessageLoopStart() {
+  brightray::BrowserMainParts::PostMainMessageLoopStart();
+#if defined(OS_POSIX)
+  HandleShutdownSignals();
+#endif
+}
+
+void ElectronBrowserMainParts::PostMainMessageLoopRun() {
+  brightray::BrowserMainParts::PostMainMessageLoopRun();
+
+#if defined(OS_MACOSX)
+  FreeAppDelegate();
+#endif
+
+  // Make sure destruction callbacks are called before message loop is
+  // destroyed, otherwise some objects that need to be deleted on IO thread
+  // won't be freed.
+  // We don't use ranged for loop because iterators are getting invalided when
+  // the callback runs.
+  for (auto iter = destructors_.begin(); iter != destructors_.end();) {
+    base::Closure& callback = *iter;
+    ++iter;
+    callback.Run();
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 7018522f15ddaa570b28bad81d5b38097e3e47d8 electron/browser/electron_browser_main_parts.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
+#define ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
+
+#include <list>
+#include <string>
+
+#include "base/callback.h"
+#include "base/timer/timer.h"
+#include "brightray/browser/browser_main_parts.h"
+#include "content/public/browser/browser_context.h"
+
+class BrowserProcess;
+
+namespace electron {
+
+class ElectronBindings;
+class Browser;
+class JavascriptEnvironment;
+class NodeBindings;
+class NodeDebugger;
+class BridgeTaskRunner;
+
+class ElectronBrowserMainParts : public brightray::BrowserMainParts {
+ public:
+  ElectronBrowserMainParts();
+  virtual ~ElectronBrowserMainParts();
+
+  static ElectronBrowserMainParts* Get();
+
+  // Sets the exit code, will fail if the message loop is not ready.
+  bool SetExitCode(int code);
+
+  // Gets the exit code
+  int GetExitCode();
+
+  // Register a callback that should be destroyed before JavaScript environment
+  // gets destroyed.
+  // Returns a closure that can be used to remove |callback| from the list.
+  base::Closure RegisterDestructionCallback(const base::Closure& callback);
+
+  Browser* browser() { return browser_.get(); }
+
+ protected:
+  // content::BrowserMainParts:
+  void PreEarlyInitialization() override;
+  void PostEarlyInitialization() override;
+  void PreMainMessageLoopRun() override;
+  bool MainMessageLoopRun(int* result_code) override;
+  void PostMainMessageLoopStart() override;
+  void PostMainMessageLoopRun() override;
+#if defined(OS_MACOSX)
+  void PreMainMessageLoopStart() override;
+#endif
+
+ private:
+#if defined(OS_POSIX)
+  // Set signal handlers.
+  void HandleSIGCHLD();
+  void HandleShutdownSignals();
+#endif
+
+#if defined(OS_MACOSX)
+  void FreeAppDelegate();
+#endif
+
+  // A fake BrowserProcess object that used to feed the source code from chrome.
+  scoped_ptr<BrowserProcess> fake_browser_process_;
+
+  // The gin::PerIsolateData requires a task runner to create, so we feed it
+  // with a task runner that will post all work to main loop.
+  scoped_refptr<BridgeTaskRunner> bridge_task_runner_;
+
+  // Pointer to exit code.
+  int* exit_code_;
+
+  scoped_ptr<Browser> browser_;
+  scoped_ptr<JavascriptEnvironment> js_env_;
+  scoped_ptr<NodeBindings> node_bindings_;
+  scoped_ptr<ElectronBindings> electron_bindings_;
+  scoped_ptr<NodeDebugger> node_debugger_;
+
+  base::Timer gc_timer_;
+
+  // List of callbacks should be executed before destroying JS env.
+  std::list<base::Closure> destructors_;
+
+  static ElectronBrowserMainParts* self_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBrowserMainParts);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_BROWSER_MAIN_PARTS_H_
added in remote
  their  100644 c888de5eb3407eb5baeb8073f3d0f77988bc8db8 electron/browser/electron_browser_main_parts_mac.mm
@@ -0,0 +1,36 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include "electron/browser/mac/electron_application.h"
+#include "electron/browser/mac/electron_application_delegate.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/foundation_util.h"
+#include "ui/base/l10n/l10n_util_mac.h"
+
+namespace electron {
+
+void ElectronBrowserMainParts::PreMainMessageLoopStart() {
+  // Force the NSApplication subclass to be used.
+  [ElectronApplication sharedApplication];
+
+  // Set our own application delegate.
+  ElectronApplicationDelegate* delegate = [[ElectronApplicationDelegate alloc] init];
+  [NSApp setDelegate:(id<NSFileManagerDelegate>)delegate];
+
+  brightray::BrowserMainParts::PreMainMessageLoopStart();
+
+  // Prevent Cocoa from turning command-line arguments into
+  // |-application:openFiles:|, since we already handle them directly.
+  [[NSUserDefaults standardUserDefaults]
+      setObject:@"NO" forKey:@"NSTreatUnknownArgumentsAsOpen"];
+}
+
+void ElectronBrowserMainParts::FreeAppDelegate() {
+  [[NSApp delegate] release];
+  [NSApp setDelegate:nil];
+}
+
+}  // namespace electron
added in remote
  their  100644 c0834e5d77035a69c2c62d679e6a8f8a260240ec electron/browser/electron_browser_main_parts_posix.cc
@@ -0,0 +1,225 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Most code came from: chrome/browser/chrome_browser_main_posix.cc.
+
+#include "electron/browser/electron_browser_main_parts.h"
+
+#include <errno.h>
+#include <limits.h>
+#include <pthread.h>
+#include <signal.h>
+#include <sys/resource.h>
+#include <unistd.h>
+
+#include "electron/browser/browser.h"
+#include "base/posix/eintr_wrapper.h"
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// See comment in |PreEarlyInitialization()|, where sigaction is called.
+void SIGCHLDHandler(int signal) {
+}
+
+// The OSX fork() implementation can crash in the child process before
+// fork() returns.  In that case, the shutdown pipe will still be
+// shared with the parent process.  To prevent child crashes from
+// causing parent shutdowns, |g_pipe_pid| is the pid for the process
+// which registered |g_shutdown_pipe_write_fd|.
+// See <http://crbug.com/175341>.
+pid_t g_pipe_pid = -1;
+int g_shutdown_pipe_write_fd = -1;
+int g_shutdown_pipe_read_fd = -1;
+
+// Common code between SIG{HUP, INT, TERM}Handler.
+void GracefulShutdownHandler(int signal) {
+  // Reinstall the default handler.  We had one shot at graceful shutdown.
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIG_DFL;
+  RAW_CHECK(sigaction(signal, &action, NULL) == 0);
+
+  RAW_CHECK(g_pipe_pid == getpid());
+  RAW_CHECK(g_shutdown_pipe_write_fd != -1);
+  RAW_CHECK(g_shutdown_pipe_read_fd != -1);
+  size_t bytes_written = 0;
+  do {
+    int rv = HANDLE_EINTR(
+        write(g_shutdown_pipe_write_fd,
+              reinterpret_cast<const char*>(&signal) + bytes_written,
+              sizeof(signal) - bytes_written));
+    RAW_CHECK(rv >= 0);
+    bytes_written += rv;
+  } while (bytes_written < sizeof(signal));
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGHUPHandler(int signal) {
+  RAW_CHECK(signal == SIGHUP);
+  GracefulShutdownHandler(signal);
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGINTHandler(int signal) {
+  RAW_CHECK(signal == SIGINT);
+  GracefulShutdownHandler(signal);
+}
+
+// See comment in |PostMainMessageLoopStart()|, where sigaction is called.
+void SIGTERMHandler(int signal) {
+  RAW_CHECK(signal == SIGTERM);
+  GracefulShutdownHandler(signal);
+}
+
+class ShutdownDetector : public base::PlatformThread::Delegate {
+ public:
+  explicit ShutdownDetector(int shutdown_fd);
+
+  void ThreadMain() override;
+
+ private:
+  const int shutdown_fd_;
+
+  DISALLOW_COPY_AND_ASSIGN(ShutdownDetector);
+};
+
+ShutdownDetector::ShutdownDetector(int shutdown_fd)
+    : shutdown_fd_(shutdown_fd) {
+  CHECK_NE(shutdown_fd_, -1);
+}
+
+// These functions are used to help us diagnose crash dumps that happen
+// during the shutdown process.
+NOINLINE void ShutdownFDReadError() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+NOINLINE void ShutdownFDClosedError() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+NOINLINE void ExitPosted() {
+  // Ensure function isn't optimized away.
+  asm("");
+  sleep(UINT_MAX);
+}
+
+void ShutdownDetector::ThreadMain() {
+  base::PlatformThread::SetName("CrShutdownDetector");
+
+  int signal;
+  size_t bytes_read = 0;
+  ssize_t ret;
+  do {
+    ret = HANDLE_EINTR(
+        read(shutdown_fd_,
+             reinterpret_cast<char*>(&signal) + bytes_read,
+             sizeof(signal) - bytes_read));
+    if (ret < 0) {
+      NOTREACHED() << "Unexpected error: " << strerror(errno);
+      ShutdownFDReadError();
+      break;
+    } else if (ret == 0) {
+      NOTREACHED() << "Unexpected closure of shutdown pipe.";
+      ShutdownFDClosedError();
+      break;
+    }
+    bytes_read += ret;
+  } while (bytes_read < sizeof(signal));
+  VLOG(1) << "Handling shutdown for signal " << signal << ".";
+  base::Closure task =
+      base::Bind(&Browser::Quit, base::Unretained(Browser::Get()));
+
+  if (!BrowserThread::PostTask(BrowserThread::UI, FROM_HERE, task)) {
+    // Without a UI thread to post the exit task to, there aren't many
+    // options.  Raise the signal again.  The default handler will pick it up
+    // and cause an ungraceful exit.
+    RAW_LOG(WARNING, "No UI thread, exiting ungracefully.");
+    kill(getpid(), signal);
+
+    // The signal may be handled on another thread.  Give that a chance to
+    // happen.
+    sleep(3);
+
+    // We really should be dead by now.  For whatever reason, we're not. Exit
+    // immediately, with the exit status set to the signal number with bit 8
+    // set.  On the systems that we care about, this exit status is what is
+    // normally used to indicate an exit by this signal's default handler.
+    // This mechanism isn't a de jure standard, but even in the worst case, it
+    // should at least result in an immediate exit.
+    RAW_LOG(WARNING, "Still here, exiting really ungracefully.");
+    _exit(signal | (1 << 7));
+  }
+  ExitPosted();
+}
+
+}  // namespace
+
+void ElectronBrowserMainParts::HandleSIGCHLD() {
+  // We need to accept SIGCHLD, even though our handler is a no-op because
+  // otherwise we cannot wait on children. (According to POSIX 2001.)
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIGCHLDHandler;
+  CHECK_EQ(sigaction(SIGCHLD, &action, NULL), 0);
+}
+
+void ElectronBrowserMainParts::HandleShutdownSignals() {
+  int pipefd[2];
+  int ret = pipe(pipefd);
+  if (ret < 0) {
+    PLOG(DFATAL) << "Failed to create pipe";
+  } else {
+    g_pipe_pid = getpid();
+    g_shutdown_pipe_read_fd = pipefd[0];
+    g_shutdown_pipe_write_fd = pipefd[1];
+#if !defined(ADDRESS_SANITIZER) && !defined(KEEP_SHADOW_STACKS)
+    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 2;
+#else
+    // ASan instrumentation and -finstrument-functions (used for keeping the
+    // shadow stacks) bloat the stack frames, so we need to increase the stack
+    // size to avoid hitting the guard page.
+    const size_t kShutdownDetectorThreadStackSize = PTHREAD_STACK_MIN * 4;
+#endif
+    // TODO(viettrungluu,willchan): crbug.com/29675 - This currently leaks, so
+    // if you change this, you'll probably need to change the suppression.
+    if (!base::PlatformThread::CreateNonJoinable(
+            kShutdownDetectorThreadStackSize,
+            new ShutdownDetector(g_shutdown_pipe_read_fd))) {
+      LOG(DFATAL) << "Failed to create shutdown detector task.";
+    }
+  }
+  // Setup signal handlers for shutdown AFTER shutdown pipe is setup because
+  // it may be called right away after handler is set.
+
+  // If adding to this list of signal handlers, note the new signal probably
+  // needs to be reset in child processes. See
+  // base/process_util_posix.cc:LaunchProcess.
+
+  // We need to handle SIGTERM, because that is how many POSIX-based distros ask
+  // processes to quit gracefully at shutdown time.
+  struct sigaction action;
+  memset(&action, 0, sizeof(action));
+  action.sa_handler = SIGTERMHandler;
+  CHECK_EQ(sigaction(SIGTERM, &action, NULL), 0);
+  // Also handle SIGINT - when the user terminates the browser via Ctrl+C. If
+  // the browser process is being debugged, GDB will catch the SIGINT first.
+  action.sa_handler = SIGINTHandler;
+  CHECK_EQ(sigaction(SIGINT, &action, NULL), 0);
+  // And SIGHUP, for when the terminal disappears. On shutdown, many Linux
+  // distros send SIGHUP, SIGTERM, and then SIGKILL.
+  action.sa_handler = SIGHUPHandler;
+  CHECK_EQ(sigaction(SIGHUP, &action, NULL), 0);
+}
+
+}  // namespace electron
added in remote
  their  100644 91a7c49b7771172143cd632642f0622d56db4735 electron/browser/electron_download_manager_delegate.cc
@@ -0,0 +1,167 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_download_manager_delegate.h"
+
+#include <string>
+
+#include "electron/browser/api/electron_api_download_item.h"
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/prefs/pref_service.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/download_manager.h"
+#include "net/base/filename_util.h"
+
+namespace electron {
+
+ElectronDownloadManagerDelegate::ElectronDownloadManagerDelegate(
+    content::DownloadManager* manager)
+    : download_manager_(manager),
+      weak_ptr_factory_(this) {}
+
+ElectronDownloadManagerDelegate::~ElectronDownloadManagerDelegate() {
+  if (download_manager_) {
+    DCHECK_EQ(static_cast<content::DownloadManagerDelegate*>(this),
+              download_manager_->GetDelegate());
+    download_manager_->SetDelegate(nullptr);
+    download_manager_ = nullptr;
+  }
+}
+
+void ElectronDownloadManagerDelegate::CreateDownloadPath(
+    const GURL& url,
+    const std::string& content_disposition,
+    const std::string& suggested_filename,
+    const std::string& mime_type,
+    const base::FilePath& default_download_path,
+    const CreateDownloadPathCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::FILE);
+
+  auto generated_name = net::GenerateFileName(url,
+                                              content_disposition,
+                                              std::string(),
+                                              suggested_filename,
+                                              mime_type,
+                                              std::string());
+
+  if (!base::PathExists(default_download_path))
+    base::CreateDirectory(default_download_path);
+
+  base::FilePath path(default_download_path.Append(generated_name));
+  content::BrowserThread::PostTask(content::BrowserThread::UI, FROM_HERE,
+                                   base::Bind(callback, path));
+}
+
+void ElectronDownloadManagerDelegate::OnDownloadPathGenerated(
+    uint32_t download_id,
+    const content::DownloadTargetCallback& callback,
+    const base::FilePath& default_path) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  auto item = download_manager_->GetDownload(download_id);
+  if (!item)
+    return;
+
+  NativeWindow* window = nullptr;
+  auto relay = NativeWindowRelay::FromWebContents(item->GetWebContents());
+  if (relay)
+    window = relay->window.get();
+
+  base::FilePath path;
+  if (file_dialog::ShowSaveDialog(window, item->GetURL().spec(), default_path,
+                                  file_dialog::Filters(), &path)) {
+    // Remember the last selected download directory.
+    ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+        download_manager_->GetBrowserContext());
+    browser_context->prefs()->SetFilePath(prefs::kDownloadDefaultDirectory,
+                                          path.DirName());
+  }
+
+  // Running the DownloadTargetCallback with an empty FilePath signals that the
+  // download should be cancelled.
+  // If user cancels the file save dialog, run the callback with empty FilePath.
+  callback.Run(path,
+               content::DownloadItem::TARGET_DISPOSITION_PROMPT,
+               content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS, path);
+}
+
+void ElectronDownloadManagerDelegate::Shutdown() {
+  weak_ptr_factory_.InvalidateWeakPtrs();
+  download_manager_ = nullptr;
+}
+
+bool ElectronDownloadManagerDelegate::DetermineDownloadTarget(
+    content::DownloadItem* download,
+    const content::DownloadTargetCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+
+  if (!download->GetForcedFilePath().empty()) {
+    callback.Run(download->GetForcedFilePath(),
+                 content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
+                 content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
+                 download->GetForcedFilePath());
+    return true;
+  }
+
+  // Try to get the save path from JS wrapper.
+  {
+    v8::Isolate* isolate = v8::Isolate::GetCurrent();
+    v8::Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    api::DownloadItem* download_item = api::DownloadItem::FromWrappedClass(
+        isolate, download);
+    if (download_item) {
+      base::FilePath save_path = download_item->GetSavePath();
+      if (!save_path.empty()) {
+        callback.Run(save_path,
+                     content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
+                     content::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
+                     save_path);
+        return true;
+      }
+    }
+  }
+
+  ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+      download_manager_->GetBrowserContext());
+  base::FilePath default_download_path = browser_context->prefs()->GetFilePath(
+      prefs::kDownloadDefaultDirectory);
+
+  CreateDownloadPathCallback download_path_callback =
+      base::Bind(&ElectronDownloadManagerDelegate::OnDownloadPathGenerated,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 download->GetId(), callback);
+
+  content::BrowserThread::PostTask(
+      content::BrowserThread::FILE, FROM_HERE,
+      base::Bind(&ElectronDownloadManagerDelegate::CreateDownloadPath,
+                 weak_ptr_factory_.GetWeakPtr(),
+                 download->GetURL(),
+                 download->GetContentDisposition(),
+                 download->GetSuggestedFilename(),
+                 download->GetMimeType(),
+                 default_download_path,
+                 download_path_callback));
+  return true;
+}
+
+bool ElectronDownloadManagerDelegate::ShouldOpenDownload(
+    content::DownloadItem* download,
+    const content::DownloadOpenDelayedCallback& callback) {
+  return true;
+}
+
+void ElectronDownloadManagerDelegate::GetNextId(
+    const content::DownloadIdCallback& callback) {
+  static uint32_t next_id = content::DownloadItem::kInvalidId + 1;
+  callback.Run(next_id++);
+}
+
+}  // namespace electron
added in remote
  their  100644 a8f1e44b1a9584604025c3e8cefbddb77eb42c2e electron/browser/electron_download_manager_delegate.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
+
+#include <string>
+
+#include "base/memory/weak_ptr.h"
+#include "content/public/browser/download_manager_delegate.h"
+
+namespace content {
+class DownloadManager;
+}
+
+namespace electron {
+
+class ElectronDownloadManagerDelegate : public content::DownloadManagerDelegate {
+ public:
+  using CreateDownloadPathCallback =
+      base::Callback<void(const base::FilePath&)>;
+
+  explicit ElectronDownloadManagerDelegate(content::DownloadManager* manager);
+  virtual ~ElectronDownloadManagerDelegate();
+
+  // Generate default file path to save the download.
+  void CreateDownloadPath(const GURL& url,
+                          const std::string& suggested_filename,
+                          const std::string& content_disposition,
+                          const std::string& mime_type,
+                          const base::FilePath& path,
+                          const CreateDownloadPathCallback& callback);
+  void OnDownloadPathGenerated(uint32_t download_id,
+                               const content::DownloadTargetCallback& callback,
+                               const base::FilePath& default_path);
+
+  // content::DownloadManagerDelegate:
+  void Shutdown() override;
+  bool DetermineDownloadTarget(
+      content::DownloadItem* download,
+      const content::DownloadTargetCallback& callback) override;
+  bool ShouldOpenDownload(
+      content::DownloadItem* download,
+      const content::DownloadOpenDelayedCallback& callback) override;
+  void GetNextId(const content::DownloadIdCallback& callback) override;
+
+ private:
+  content::DownloadManager* download_manager_;
+  base::WeakPtrFactory<ElectronDownloadManagerDelegate> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronDownloadManagerDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_DOWNLOAD_MANAGER_DELEGATE_H_
added in remote
  their  100644 82543988ea9c4531a96bc3919cabc7d761e69989 electron/browser/electron_javascript_dialog_manager.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_javascript_dialog_manager.h"
+
+#include <string>
+
+#include "base/strings/utf_string_conversions.h"
+
+namespace electron {
+
+void ElectronJavaScriptDialogManager::RunJavaScriptDialog(
+    content::WebContents* web_contents,
+    const GURL& origin_url,
+    const std::string& accept_lang,
+    content::JavaScriptMessageType javascript_message_type,
+    const base::string16& message_text,
+    const base::string16& default_prompt_text,
+    const DialogClosedCallback& callback,
+    bool* did_suppress_message) {
+  callback.Run(false, base::string16());
+}
+
+void ElectronJavaScriptDialogManager::RunBeforeUnloadDialog(
+    content::WebContents* web_contents,
+    const base::string16& message_text,
+    bool is_reload,
+    const DialogClosedCallback& callback) {
+  bool prevent_reload = message_text.empty() ||
+                        message_text == base::ASCIIToUTF16("false");
+  callback.Run(!prevent_reload, message_text);
+}
+
+}  // namespace electron
added in remote
  their  100644 eb9cc39cc638ca6e81ce2e6036f5b467b5b9d784 electron/browser/electron_javascript_dialog_manager.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
+#define ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
+
+#include <string>
+
+#include "content/public/browser/javascript_dialog_manager.h"
+
+namespace electron {
+
+class ElectronJavaScriptDialogManager : public content::JavaScriptDialogManager {
+ public:
+  // content::JavaScriptDialogManager implementations.
+  void RunJavaScriptDialog(
+      content::WebContents* web_contents,
+      const GURL& origin_url,
+      const std::string& accept_lang,
+      content::JavaScriptMessageType javascript_message_type,
+      const base::string16& message_text,
+      const base::string16& default_prompt_text,
+      const DialogClosedCallback& callback,
+      bool* did_suppress_message) override;
+  void RunBeforeUnloadDialog(
+      content::WebContents* web_contents,
+      const base::string16& message_text,
+      bool is_reload,
+      const DialogClosedCallback& callback) override;
+  void CancelActiveAndPendingDialogs(
+      content::WebContents* web_contents) override {}
+  void ResetDialogState(content::WebContents* web_contents) override {};
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_JAVASCRIPT_DIALOG_MANAGER_H_
added in remote
  their  100644 46292e86419110f0e7e791ae2f8ff89ff0a0eae3 electron/browser/electron_permission_manager.cc
@@ -0,0 +1,154 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_permission_manager.h"
+
+#include <vector>
+
+#include "electron/browser/web_contents_preferences.h"
+#include "content/public/browser/child_process_security_policy.h"
+#include "content/public/browser/permission_type.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+namespace {
+
+bool WebContentsDestroyed(int process_id) {
+  auto contents =
+      WebContentsPreferences::GetWebContentsFromProcessID(process_id);
+  if (!contents)
+    return true;
+  return contents->IsBeingDestroyed();
+}
+
+}  // namespace
+
+ElectronPermissionManager::ElectronPermissionManager()
+    : request_id_(0) {
+}
+
+ElectronPermissionManager::~ElectronPermissionManager() {
+}
+
+void ElectronPermissionManager::SetPermissionRequestHandler(
+    const RequestHandler& handler) {
+  if (handler.is_null() && !pending_requests_.empty()) {
+    for (const auto& request : pending_requests_) {
+      if (!WebContentsDestroyed(request.second.render_process_id))
+        request.second.callback.Run(content::PERMISSION_STATUS_DENIED);
+    }
+    pending_requests_.clear();
+  }
+  request_handler_ = handler;
+}
+
+int ElectronPermissionManager::RequestPermission(
+    content::PermissionType permission,
+    content::RenderFrameHost* render_frame_host,
+    const GURL& requesting_origin,
+    bool user_gesture,
+    const ResponseCallback& response_callback) {
+  int process_id = render_frame_host->GetProcess()->GetID();
+
+  if (permission == content::PermissionType::MIDI_SYSEX) {
+    content::ChildProcessSecurityPolicy::GetInstance()->
+        GrantSendMidiSysExMessage(process_id);
+  }
+
+  if (!request_handler_.is_null()) {
+    auto web_contents =
+        content::WebContents::FromRenderFrameHost(render_frame_host);
+    ++request_id_;
+    auto callback = base::Bind(&ElectronPermissionManager::OnPermissionResponse,
+                               base::Unretained(this),
+                               request_id_,
+                               requesting_origin,
+                               response_callback);
+    pending_requests_[request_id_] = { process_id, callback };
+    request_handler_.Run(web_contents, permission, callback);
+    return request_id_;
+  }
+
+  response_callback.Run(content::PERMISSION_STATUS_GRANTED);
+  return kNoPendingOperation;
+}
+
+int ElectronPermissionManager::RequestPermissions(
+    const std::vector<content::PermissionType>& permissions,
+    content::RenderFrameHost* render_frame_host,
+    const GURL& requesting_origin,
+    bool user_gesture,
+    const base::Callback<void(
+    const std::vector<content::PermissionStatus>&)>& callback) {
+  // FIXME(zcbenz): Just ignore multiple permissions request for now.
+  std::vector<content::PermissionStatus> permissionStatuses;
+  for (auto permission : permissions) {
+    if (permission == content::PermissionType::MIDI_SYSEX) {
+      content::ChildProcessSecurityPolicy::GetInstance()->
+          GrantSendMidiSysExMessage(render_frame_host->GetProcess()->GetID());
+    }
+    permissionStatuses.push_back(content::PERMISSION_STATUS_GRANTED);
+  }
+  callback.Run(permissionStatuses);
+  return kNoPendingOperation;
+}
+
+void ElectronPermissionManager::OnPermissionResponse(
+    int request_id,
+    const GURL& origin,
+    const ResponseCallback& callback,
+    content::PermissionStatus status) {
+  auto request = pending_requests_.find(request_id);
+  if (request != pending_requests_.end()) {
+    if (!WebContentsDestroyed(request->second.render_process_id))
+      callback.Run(status);
+    pending_requests_.erase(request);
+  }
+}
+
+void ElectronPermissionManager::CancelPermissionRequest(int request_id) {
+  auto request = pending_requests_.find(request_id);
+  if (request != pending_requests_.end()) {
+    if (!WebContentsDestroyed(request->second.render_process_id))
+      request->second.callback.Run(content::PERMISSION_STATUS_DENIED);
+    pending_requests_.erase(request);
+  }
+}
+
+void ElectronPermissionManager::ResetPermission(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+}
+
+content::PermissionStatus ElectronPermissionManager::GetPermissionStatus(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+  return content::PERMISSION_STATUS_GRANTED;
+}
+
+void ElectronPermissionManager::RegisterPermissionUsage(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin) {
+}
+
+int ElectronPermissionManager::SubscribePermissionStatusChange(
+    content::PermissionType permission,
+    const GURL& requesting_origin,
+    const GURL& embedding_origin,
+    const ResponseCallback& callback) {
+  return -1;
+}
+
+void ElectronPermissionManager::UnsubscribePermissionStatusChange(
+    int subscription_id) {
+}
+
+}  // namespace electron
added in remote
  their  100644 4f7fc605966790033025c1e0bdb4e17a51583be8 electron/browser/electron_permission_manager.h
@@ -0,0 +1,92 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
+#define ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
+
+#include <map>
+#include <vector>
+
+#include "base/callback.h"
+#include "content/public/browser/permission_manager.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace electron {
+
+class ElectronPermissionManager : public content::PermissionManager {
+ public:
+  ElectronPermissionManager();
+  ~ElectronPermissionManager() override;
+
+  using ResponseCallback =
+      base::Callback<void(content::PermissionStatus)>;
+  using RequestHandler =
+      base::Callback<void(content::WebContents*,
+                          content::PermissionType,
+                          const ResponseCallback&)>;
+
+  // Handler to dispatch permission requests in JS.
+  void SetPermissionRequestHandler(const RequestHandler& handler);
+
+  // content::PermissionManager:
+  int RequestPermission(
+      content::PermissionType permission,
+      content::RenderFrameHost* render_frame_host,
+      const GURL& requesting_origin,
+      bool user_gesture,
+      const ResponseCallback& callback) override;
+  int RequestPermissions(
+      const std::vector<content::PermissionType>& permissions,
+      content::RenderFrameHost* render_frame_host,
+      const GURL& requesting_origin,
+      bool user_gesture,
+      const base::Callback<void(
+      const std::vector<content::PermissionStatus>&)>& callback) override;
+
+ protected:
+  void OnPermissionResponse(int request_id,
+                            const GURL& url,
+                            const ResponseCallback& callback,
+                            content::PermissionStatus status);
+
+  // content::PermissionManager:
+  void CancelPermissionRequest(int request_id) override;
+  void ResetPermission(content::PermissionType permission,
+                       const GURL& requesting_origin,
+                       const GURL& embedding_origin) override;
+  content::PermissionStatus GetPermissionStatus(
+      content::PermissionType permission,
+      const GURL& requesting_origin,
+      const GURL& embedding_origin) override;
+  void RegisterPermissionUsage(content::PermissionType permission,
+                               const GURL& requesting_origin,
+                               const GURL& embedding_origin) override;
+  int SubscribePermissionStatusChange(
+      content::PermissionType permission,
+      const GURL& requesting_origin,
+      const GURL& embedding_origin,
+      const base::Callback<void(content::PermissionStatus)>& callback) override;
+  void UnsubscribePermissionStatusChange(int subscription_id) override;
+
+ private:
+  struct RequestInfo {
+    int render_process_id;
+    ResponseCallback callback;
+  };
+
+  RequestHandler request_handler_;
+
+  std::map<int, RequestInfo> pending_requests_;
+
+  int request_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronPermissionManager);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_PERMISSION_MANAGER_H_
added in remote
  their  100644 a7c7edf5322b260e90c137fb006bcb4de240bd53 electron/browser/electron_quota_permission_context.cc
@@ -0,0 +1,24 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_quota_permission_context.h"
+
+#include "storage/common/quota/quota_types.h"
+
+namespace electron {
+
+ElectronQuotaPermissionContext::ElectronQuotaPermissionContext() {
+}
+
+ElectronQuotaPermissionContext::~ElectronQuotaPermissionContext() {
+}
+
+void ElectronQuotaPermissionContext::RequestQuotaPermission(
+    const content::StorageQuotaParams& params,
+    int render_process_id,
+    const PermissionCallback& callback) {
+  callback.Run(response::QUOTA_PERMISSION_RESPONSE_ALLOW);
+}
+
+}  // namespace electron
added in remote
  their  100644 b38d69d1af1986c2a53851d120b953be13c8dd61 electron/browser/electron_quota_permission_context.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
+#define ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
+
+#include "content/public/browser/quota_permission_context.h"
+
+namespace electron {
+
+class ElectronQuotaPermissionContext : public content::QuotaPermissionContext {
+ public:
+  typedef content::QuotaPermissionContext::QuotaPermissionResponse response;
+
+  ElectronQuotaPermissionContext();
+  virtual ~ElectronQuotaPermissionContext();
+
+  // content::QuotaPermissionContext:
+  void RequestQuotaPermission(
+      const content::StorageQuotaParams& params,
+      int render_process_id,
+      const PermissionCallback& callback) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronQuotaPermissionContext);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_QUOTA_PERMISSION_CONTEXT_H_
added in remote
  their  100644 9b91733f3f7875c89c513b363d3d626e0945645c electron/browser/electron_resource_dispatcher_host_delegate.cc
@@ -0,0 +1,41 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_resource_dispatcher_host_delegate.h"
+
+#include "electron/browser/login_handler.h"
+#include "electron/common/platform_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/escape.h"
+#include "url/gurl.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+ElectronResourceDispatcherHostDelegate::ElectronResourceDispatcherHostDelegate() {
+}
+
+bool ElectronResourceDispatcherHostDelegate::HandleExternalProtocol(
+    const GURL& url,
+    int child_id,
+    const content::ResourceRequestInfo::WebContentsGetter&,
+    bool is_main_frame,
+    ui::PageTransition transition,
+    bool has_user_gesture) {
+  GURL escaped_url(net::EscapeExternalHandlerValue(url.spec()));
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+      base::Bind(
+          base::IgnoreResult(platform_util::OpenExternal), escaped_url, true));
+  return true;
+}
+
+content::ResourceDispatcherHostLoginDelegate*
+ElectronResourceDispatcherHostDelegate::CreateLoginDelegate(
+    net::AuthChallengeInfo* auth_info,
+    net::URLRequest* request) {
+  return new LoginHandler(auth_info, request);
+}
+
+}  // namespace electron
added in remote
  their  100644 07082d7e4265a8e6933010be157896e1c4dc04cd electron/browser/electron_resource_dispatcher_host_delegate.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
+
+#include "content/public/browser/resource_dispatcher_host_delegate.h"
+
+namespace electron {
+
+class ElectronResourceDispatcherHostDelegate
+    : public content::ResourceDispatcherHostDelegate {
+ public:
+  ElectronResourceDispatcherHostDelegate();
+
+  // content::ResourceDispatcherHostDelegate:
+  bool HandleExternalProtocol(
+      const GURL& url,
+      int child_id,
+      const content::ResourceRequestInfo::WebContentsGetter&,
+      bool is_main_frame,
+      ui::PageTransition transition,
+      bool has_user_gesture) override;
+  content::ResourceDispatcherHostLoginDelegate* CreateLoginDelegate(
+      net::AuthChallengeInfo* auth_info,
+      net::URLRequest* request) override;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_RESOURCE_DISPATCHER_HOST_DELEGATE_H_
added in remote
  their  100644 7973568f1d455b06563238d17228d1ec73397693 electron/browser/electron_speech_recognition_manager_delegate.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/electron_speech_recognition_manager_delegate.h"
+
+#include <string>
+
+#include "base/callback.h"
+
+namespace electron {
+
+ElectronSpeechRecognitionManagerDelegate::ElectronSpeechRecognitionManagerDelegate() {
+}
+
+ElectronSpeechRecognitionManagerDelegate::~ElectronSpeechRecognitionManagerDelegate() {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnEnvironmentEstimationComplete(
+    int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnSoundStart(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnSoundEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionEnd(int session_id) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionResults(
+    int session_id, const content::SpeechRecognitionResults& result) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnRecognitionError(
+    int session_id, const content::SpeechRecognitionError& error) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::OnAudioLevelsChange(
+    int session_id, float volume, float noise_volume) {
+}
+
+void ElectronSpeechRecognitionManagerDelegate::GetDiagnosticInformation(
+    bool* can_report_metrics, std::string* hardware_info) {
+  *can_report_metrics = false;
+}
+
+void ElectronSpeechRecognitionManagerDelegate::CheckRecognitionIsAllowed(
+    int session_id,
+    base::Callback<void(bool ask_user, bool is_allowed)> callback) {
+  callback.Run(true, true);
+}
+
+content::SpeechRecognitionEventListener*
+ElectronSpeechRecognitionManagerDelegate::GetEventListener() {
+  return this;
+}
+
+bool ElectronSpeechRecognitionManagerDelegate::FilterProfanities(
+    int render_process_id) {
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 f1a67941b2d8fae87934f949a3b7f41ea156806e electron/browser/electron_speech_recognition_manager_delegate.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
+#define ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "content/public/browser/speech_recognition_event_listener.h"
+#include "content/public/browser/speech_recognition_manager_delegate.h"
+
+namespace electron {
+
+class ElectronSpeechRecognitionManagerDelegate
+    : public content::SpeechRecognitionManagerDelegate,
+      public content::SpeechRecognitionEventListener {
+ public:
+  ElectronSpeechRecognitionManagerDelegate();
+  virtual ~ElectronSpeechRecognitionManagerDelegate();
+
+  // content::SpeechRecognitionEventListener:
+  void OnRecognitionStart(int session_id) override;
+  void OnAudioStart(int session_id) override;
+  void OnEnvironmentEstimationComplete(int session_id) override;
+  void OnSoundStart(int session_id) override;
+  void OnSoundEnd(int session_id) override;
+  void OnAudioEnd(int session_id) override;
+  void OnRecognitionEnd(int session_id) override;
+  void OnRecognitionResults(
+      int session_id, const content::SpeechRecognitionResults& result) override;
+  void OnRecognitionError(
+      int session_id, const content::SpeechRecognitionError& error) override;
+  void OnAudioLevelsChange(int session_id, float volume,
+                           float noise_volume) override;
+
+  // content::SpeechRecognitionManagerDelegate:
+  void GetDiagnosticInformation(bool* can_report_metrics,
+                                std::string* hardware_info) override;
+  void CheckRecognitionIsAllowed(
+      int session_id,
+      base::Callback<void(bool ask_user, bool is_allowed)> callback) override;
+  content::SpeechRecognitionEventListener* GetEventListener() override;
+  bool FilterProfanities(int render_process_id) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(ElectronSpeechRecognitionManagerDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_ELECTRON_SPEECH_RECOGNITION_MANAGER_DELEGATE_H_
added in remote
  their  100644 e07b39e19c83d8fdc92187119b6dd0166f7902fd electron/browser/javascript_environment.cc
@@ -0,0 +1,45 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/javascript_environment.h"
+
+#include <string>
+
+#include "base/command_line.h"
+#include "content/public/common/content_switches.h"
+#include "gin/array_buffer.h"
+#include "gin/v8_initializer.h"
+
+namespace electron {
+
+JavascriptEnvironment::JavascriptEnvironment()
+    : initialized_(Initialize()),
+      isolate_(isolate_holder_.isolate()),
+      isolate_scope_(isolate_),
+      locker_(isolate_),
+      handle_scope_(isolate_),
+      context_(isolate_, v8::Context::New(isolate_)),
+      context_scope_(v8::Local<v8::Context>::New(isolate_, context_)) {
+}
+
+bool JavascriptEnvironment::Initialize() {
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch("debug-brk")) {
+    // Need to be called before v8::Initialize().
+    const char expose_debug_as[] = "--expose_debug_as=v8debug";
+    v8::V8::SetFlagsFromString(expose_debug_as, sizeof(expose_debug_as) - 1);
+  }
+
+  // --js-flags.
+  std::string js_flags = cmd->GetSwitchValueASCII(switches::kJavaScriptFlags);
+  if (!js_flags.empty())
+    v8::V8::SetFlagsFromString(js_flags.c_str(), js_flags.size());
+
+  gin::IsolateHolder::Initialize(gin::IsolateHolder::kNonStrictMode,
+                                 gin::IsolateHolder::kStableV8Extras,
+                                 gin::ArrayBufferAllocator::SharedInstance());
+  return true;
+}
+
+}  // namespace electron
added in remote
  their  100644 72ae43e8e94040ca4e20d7169488152123e4226e electron/browser/javascript_environment.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
+#define ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
+
+#include "base/macros.h"
+#include "gin/public/isolate_holder.h"
+
+namespace electron {
+
+class JavascriptEnvironment {
+ public:
+  JavascriptEnvironment();
+
+  v8::Isolate* isolate() const { return isolate_; }
+  v8::Local<v8::Context> context() const {
+    return v8::Local<v8::Context>::New(isolate_, context_);
+  }
+
+ private:
+  bool Initialize();
+
+  bool initialized_;
+  gin::IsolateHolder isolate_holder_;
+  v8::Isolate* isolate_;
+  v8::Isolate::Scope isolate_scope_;
+  v8::Locker locker_;
+  v8::HandleScope handle_scope_;
+  v8::UniquePersistent<v8::Context> context_;
+  v8::Context::Scope context_scope_;
+
+  DISALLOW_COPY_AND_ASSIGN(JavascriptEnvironment);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_JAVASCRIPT_ENVIRONMENT_H_
added in remote
  their  100644 a1780da9aa67e1e861e57117428bc62edc7ccbf7 electron/browser/login_handler.cc
@@ -0,0 +1,109 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/login_handler.h"
+
+#include "electron/browser/browser.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/resource_dispatcher_host.h"
+#include "content/public/browser/resource_request_info.h"
+#include "content/public/browser/web_contents.h"
+#include "net/base/auth.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// Helper to remove the ref from an net::URLRequest to the LoginHandler.
+// Should only be called from the IO thread, since it accesses an
+// net::URLRequest.
+void ResetLoginHandlerForRequest(net::URLRequest* request) {
+  content::ResourceDispatcherHost::Get()->ClearLoginDelegateForRequest(request);
+}
+
+}  // namespace
+
+LoginHandler::LoginHandler(net::AuthChallengeInfo* auth_info,
+                           net::URLRequest* request)
+    : handled_auth_(false),
+      auth_info_(auth_info),
+      request_(request),
+      render_process_host_id_(0),
+      render_frame_id_(0) {
+  content::ResourceRequestInfo::ForRequest(request_)->GetAssociatedRenderFrame(
+      &render_process_host_id_,  &render_frame_id_);
+  BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
+                          base::Bind(&Browser::RequestLogin,
+                                     base::Unretained(Browser::Get()),
+                                     make_scoped_refptr(this)));
+}
+
+LoginHandler::~LoginHandler() {
+}
+
+content::WebContents* LoginHandler::GetWebContents() const {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+
+  content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(
+      render_process_host_id_, render_frame_id_);
+  return content::WebContents::FromRenderFrameHost(rfh);
+}
+
+void LoginHandler::Login(const base::string16& username,
+                         const base::string16& password) {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (TestAndSetAuthHandled())
+    return;
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&LoginHandler::DoLogin, this, username, password));
+}
+
+void LoginHandler::CancelAuth() {
+  DCHECK_CURRENTLY_ON(BrowserThread::UI);
+  if (TestAndSetAuthHandled())
+    return;
+  BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
+                          base::Bind(&LoginHandler::DoCancelAuth, this));
+}
+
+void LoginHandler::OnRequestCancelled() {
+  TestAndSetAuthHandled();
+  request_ = nullptr;
+}
+
+// Marks authentication as handled and returns the previous handled state.
+bool LoginHandler::TestAndSetAuthHandled() {
+  base::AutoLock lock(handled_auth_lock_);
+  bool was_handled = handled_auth_;
+  handled_auth_ = true;
+  return was_handled;
+}
+
+void LoginHandler::DoCancelAuth() {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (request_) {
+    request_->CancelAuth();
+    // Verify that CancelAuth doesn't destroy the request via our delegate.
+    DCHECK(request_ != nullptr);
+    ResetLoginHandlerForRequest(request_);
+  }
+}
+
+void LoginHandler::DoLogin(const base::string16& username,
+                           const base::string16& password) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  if (request_) {
+    request_->SetAuth(net::AuthCredentials(username, password));
+    ResetLoginHandlerForRequest(request_);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 52b94dfeb2a9d57305b418d722d0ed047be45237 electron/browser/login_handler.h
@@ -0,0 +1,76 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_LOGIN_HANDLER_H_
+#define ELECTRON_BROWSER_LOGIN_HANDLER_H_
+
+#include "base/strings/string16.h"
+#include "base/synchronization/lock.h"
+#include "content/public/browser/resource_dispatcher_host_login_delegate.h"
+
+namespace content {
+class WebContents;
+}
+
+namespace net {
+class AuthChallengeInfo;
+class URLRequest;
+}
+
+namespace electron {
+
+// Handles the HTTP basic auth, must be created on IO thread.
+class LoginHandler : public content::ResourceDispatcherHostLoginDelegate {
+ public:
+  LoginHandler(net::AuthChallengeInfo* auth_info, net::URLRequest* request);
+
+  // Returns the WebContents associated with the request, must be called on UI
+  // thread.
+  content::WebContents* GetWebContents() const;
+
+  // The auth is cancelled, must be called on UI thread.
+  void CancelAuth();
+
+  // Login with |username| and |password|, must be called on UI thread.
+  void Login(const base::string16& username, const base::string16& password);
+
+  const net::AuthChallengeInfo* auth_info() const { return auth_info_.get(); }
+  const net::URLRequest* request() const { return request_; }
+
+ protected:
+  ~LoginHandler() override;
+
+  // content::ResourceDispatcherHostLoginDelegate:
+  void OnRequestCancelled() override;
+
+ private:
+  // Must be called on IO thread.
+  void DoCancelAuth();
+  void DoLogin(const base::string16& username, const base::string16& password);
+
+  // Marks authentication as handled and returns the previous handled
+  // state.
+  bool TestAndSetAuthHandled();
+
+  // True if we've handled auth (Login or CancelAuth has been called).
+  bool handled_auth_;
+  mutable base::Lock handled_auth_lock_;
+
+  // Who/where/what asked for the authentication.
+  scoped_refptr<net::AuthChallengeInfo> auth_info_;
+
+  // The request that wants login data.
+  // This should only be accessed on the IO loop.
+  net::URLRequest* request_;
+
+  // Cached from the net::URLRequest, in case it goes NULL on us.
+  int render_process_host_id_;
+  int render_frame_id_;
+
+  DISALLOW_COPY_AND_ASSIGN(LoginHandler);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_LOGIN_HANDLER_H_
added in remote
  their  100644 aca9e8dae77b70efb1ef70adf45fc9c83fdb6e92 electron/browser/mac/electron_application.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "base/mac/scoped_sending_event.h"
+
+@interface ElectronApplication : NSApplication<CrAppProtocol,
+                                           CrAppControlProtocol> {
+ @private
+  BOOL handlingSendEvent_;
+}
+
++ (ElectronApplication*)sharedApplication;
+
+// CrAppProtocol:
+- (BOOL)isHandlingSendEvent;
+
+// CrAppControlProtocol:
+- (void)setHandlingSendEvent:(BOOL)handlingSendEvent;
+
+@end
added in remote
  their  100644 682030da3936d9740808da49b453471483d34148 electron/browser/mac/electron_application.mm
@@ -0,0 +1,74 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/mac/electron_application.h"
+
+#include "electron/browser/browser.h"
+#include "base/auto_reset.h"
+#include "base/strings/sys_string_conversions.h"
+#include "content/public/browser/browser_accessibility_state.h"
+
+@implementation ElectronApplication
+
++ (ElectronApplication*)sharedApplication {
+  return (ElectronApplication*)[super sharedApplication];
+}
+
+- (BOOL)isHandlingSendEvent {
+  return handlingSendEvent_;
+}
+
+- (void)sendEvent:(NSEvent*)event {
+  base::AutoReset<BOOL> scoper(&handlingSendEvent_, YES);
+  [super sendEvent:event];
+}
+
+- (void)setHandlingSendEvent:(BOOL)handlingSendEvent {
+  handlingSendEvent_ = handlingSendEvent;
+}
+
+- (void)awakeFromNib {
+  [[NSAppleEventManager sharedAppleEventManager]
+      setEventHandler:self
+          andSelector:@selector(handleURLEvent:withReplyEvent:)
+        forEventClass:kInternetEventClass
+           andEventID:kAEGetURL];
+}
+
+- (void)handleURLEvent:(NSAppleEventDescriptor*)event
+        withReplyEvent:(NSAppleEventDescriptor*)replyEvent {
+  NSString* url = [
+      [event paramDescriptorForKeyword:keyDirectObject] stringValue];
+  electron::Browser::Get()->OpenURL(base::SysNSStringToUTF8(url));
+}
+
+- (bool)voiceOverEnabled {
+  NSUserDefaults *defaults = [NSUserDefaults standardUserDefaults];
+  [defaults addSuiteNamed:@"com.apple.universalaccess"];
+  [defaults synchronize];
+
+  return [defaults boolForKey:@"voiceOverOnOffKey"];
+}
+
+- (void)accessibilitySetValue:(id)value forAttribute:(NSString *)attribute {
+  // Undocumented attribute that VoiceOver happens to set while running.
+  // Chromium uses this too, even though it's not exactly right.
+  if ([attribute isEqualToString:@"AXEnhancedUserInterface"]) {
+    bool enableAccessibility = ([self voiceOverEnabled] && [value boolValue]);
+    [self updateAccessibilityEnabled:enableAccessibility];
+  }
+  return [super accessibilitySetValue:value forAttribute:attribute];
+}
+
+- (void)updateAccessibilityEnabled:(BOOL)enabled {
+  auto ax_state = content::BrowserAccessibilityState::GetInstance();
+
+  if (enabled) {
+    ax_state->OnScreenReaderDetected();
+  } else {
+    ax_state->DisableAccessibility();
+  }
+}
+
+@end
added in remote
  their  100644 2a3e265f059d245b77b40eaec11905c1a1e3f683 electron/browser/mac/electron_application_delegate.h
@@ -0,0 +1,19 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import <Cocoa/Cocoa.h>
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+@interface ElectronApplicationDelegate : NSObject<NSApplicationDelegate> {
+ @private
+  base::scoped_nsobject<ElectronMenuController> menu_controller_;
+}
+
+- (id)init;
+
+// Sets the menu that will be returned in "applicationDockMenu:".
+- (void)setApplicationDockMenu:(ui::MenuModel*)model;
+
+@end
added in remote
  their  100644 5d266386635714ed48619c98c16d1ae2674b5dab electron/browser/mac/electron_application_delegate.mm
@@ -0,0 +1,69 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/mac/electron_application_delegate.h"
+
+#import "electron/browser/mac/electron_application.h"
+#include "electron/browser/browser.h"
+#include "base/strings/sys_string_conversions.h"
+
+@implementation ElectronApplicationDelegate
+
+- (id)init {
+  self = [super init];
+  menu_controller_.reset([[ElectronMenuController alloc] init]);
+  return self;
+}
+
+- (void)setApplicationDockMenu:(ui::MenuModel*)model {
+  [menu_controller_ populateWithModel:model];
+}
+
+- (void)applicationWillFinishLaunching:(NSNotification*)notify {
+  // Don't add the "Enter Full Screen" menu item automatically.
+  [[NSUserDefaults standardUserDefaults] setBool:NO forKey:@"NSFullScreenMenuItemEverywhere"];
+
+  // Add observer to monitor the system's Dark Mode theme.
+  [[NSDistributedNotificationCenter defaultCenter] addObserver:self selector:@selector(platformThemeChanged:) name:@"AppleInterfaceThemeChangedNotification" object:nil];
+
+  electron::Browser::Get()->WillFinishLaunching();
+}
+
+- (void)applicationDidFinishLaunching:(NSNotification*)notify {
+  electron::Browser::Get()->DidFinishLaunching();
+}
+
+- (NSMenu*)applicationDockMenu:(NSApplication*)sender {
+  return [menu_controller_ menu];
+}
+
+- (BOOL)application:(NSApplication*)sender
+           openFile:(NSString*)filename {
+  std::string filename_str(base::SysNSStringToUTF8(filename));
+  return electron::Browser::Get()->OpenFile(filename_str) ? YES : NO;
+}
+
+- (NSApplicationTerminateReply)applicationShouldTerminate:(NSApplication*)sender {
+  electron::Browser* browser = electron::Browser::Get();
+  if (browser->is_quiting()) {
+    return NSTerminateNow;
+  } else {
+    // System started termination.
+    electron::Browser::Get()->Quit();
+    return NSTerminateCancel;
+  }
+}
+
+- (BOOL)applicationShouldHandleReopen:(NSApplication*)theApplication
+                    hasVisibleWindows:(BOOL)flag {
+  electron::Browser* browser = electron::Browser::Get();
+  browser->Activate(static_cast<bool>(flag));
+  return flag;
+}
+
+- (void)platformThemeChanged:(NSNotification *)notify {
+  electron::Browser::Get()->PlatformThemeChanged();
+}
+
+@end
added in remote
  their  100644 f7ba2f3d888d933266bc62eea033ded94a477065 electron/browser/native_window.cc
@@ -0,0 +1,620 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window.h"
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/electron_browser_main_parts.h"
+#include "electron/browser/window_list.h"
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/options_switches.h"
+#include "base/files/file_util.h"
+#include "base/json/json_writer.h"
+#include "base/prefs/pref_service.h"
+#include "base/message_loop/message_loop.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/browser/renderer_host/render_widget_host_impl.h"
+#include "content/public/browser/navigation_entry.h"
+#include "content/public/browser/plugin_service.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "content/public/common/content_switches.h"
+#include "ipc/ipc_message_macros.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/geometry/size_conversions.h"
+#include "ui/gfx/screen.h"
+#include "ui/gl/gpu_switching_manager.h"
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::NativeWindowRelay);
+
+namespace electron {
+
+NativeWindow::NativeWindow(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options)
+    : content::WebContentsObserver(inspectable_web_contents->GetWebContents()),
+      has_frame_(true),
+      force_using_draggable_region_(false),
+      transparent_(false),
+      enable_larger_than_screen_(false),
+      is_closed_(false),
+      has_dialog_attached_(false),
+      aspect_ratio_(0.0),
+      inspectable_web_contents_(inspectable_web_contents),
+      weak_factory_(this) {
+  options.Get(options::kFrame, &has_frame_);
+  options.Get(options::kTransparent, &transparent_);
+  options.Get(options::kEnableLargerThanScreen, &enable_larger_than_screen_);
+
+  // Tell the content module to initialize renderer widget with transparent
+  // mode.
+  ui::GpuSwitchingManager::SetTransparent(transparent_);
+
+  // Read icon before window is created.
+  options.Get(options::kIcon, &icon_);
+
+  WindowList::AddWindow(this);
+}
+
+NativeWindow::~NativeWindow() {
+  // It's possible that the windows gets destroyed before it's closed, in that
+  // case we need to ensure the OnWindowClosed message is still notified.
+  NotifyWindowClosed();
+}
+
+// static
+NativeWindow* NativeWindow::FromWebContents(
+    content::WebContents* web_contents) {
+  WindowList& window_list = *WindowList::GetInstance();
+  for (NativeWindow* window : window_list) {
+    if (window->web_contents() == web_contents)
+      return window;
+  }
+  return nullptr;
+}
+
+void NativeWindow::InitFromOptions(const mate::Dictionary& options) {
+  // Setup window from options.
+  int x = -1, y = -1;
+  bool center;
+  if (options.Get(options::kX, &x) && options.Get(options::kY, &y)) {
+    SetPosition(gfx::Point(x, y));
+  } else if (options.Get(options::kCenter, &center) && center) {
+    Center();
+  }
+  // On Linux and Window we may already have maximum size defined.
+  extensions::SizeConstraints size_constraints(GetContentSizeConstraints());
+  int min_height = 0, min_width = 0;
+  if (options.Get(options::kMinHeight, &min_height) |
+      options.Get(options::kMinWidth, &min_width)) {
+    size_constraints.set_minimum_size(gfx::Size(min_width, min_height));
+  }
+  int max_height = INT_MAX, max_width = INT_MAX;
+  if (options.Get(options::kMaxHeight, &max_height) |
+      options.Get(options::kMaxWidth, &max_width)) {
+    size_constraints.set_maximum_size(gfx::Size(max_width, max_height));
+  }
+  bool use_content_size = false;
+  options.Get(options::kUseContentSize, &use_content_size);
+  if (use_content_size) {
+    SetContentSizeConstraints(size_constraints);
+  } else {
+    SetSizeConstraints(size_constraints);
+  }
+#if defined(USE_X11)
+  bool resizable;
+  if (options.Get(options::kResizable, &resizable)) {
+    SetResizable(resizable);
+  }
+#endif
+#if defined(OS_WIN) || defined(USE_X11)
+  bool closable;
+  if (options.Get(options::kClosable, &closable)) {
+    SetClosable(closable);
+  }
+#endif
+  bool movable;
+  if (options.Get(options::kMovable, &movable)) {
+    SetMovable(movable);
+  }
+  bool has_shadow;
+  if (options.Get(options::kHasShadow, &has_shadow)) {
+    SetHasShadow(has_shadow);
+  }
+  bool top;
+  if (options.Get(options::kAlwaysOnTop, &top) && top) {
+    SetAlwaysOnTop(true);
+  }
+  // Disable fullscreen button if 'fullscreen' is specified to false.
+  bool fullscreenable = true;
+  bool fullscreen = false;
+  if (options.Get(options::kFullscreen, &fullscreen) && !fullscreen)
+    fullscreenable = false;
+  // Overriden by 'fullscreenable'.
+  options.Get(options::kFullScreenable, &fullscreenable);
+  SetFullScreenable(fullscreenable);
+  if (fullscreen) {
+    SetFullScreen(true);
+  }
+  bool skip;
+  if (options.Get(options::kSkipTaskbar, &skip) && skip) {
+    SetSkipTaskbar(skip);
+  }
+  bool kiosk;
+  if (options.Get(options::kKiosk, &kiosk) && kiosk) {
+    SetKiosk(kiosk);
+  }
+  std::string color;
+  if (options.Get(options::kBackgroundColor, &color)) {
+    SetBackgroundColor(color);
+  }
+  std::string title("Electron");
+  options.Get(options::kTitle, &title);
+  SetTitle(title);
+
+  // Then show it.
+  bool show = true;
+  options.Get(options::kShow, &show);
+  if (show)
+    Show();
+}
+
+void NativeWindow::SetSize(const gfx::Size& size, bool animate) {
+  SetBounds(gfx::Rect(GetPosition(), size), animate);
+}
+
+gfx::Size NativeWindow::GetSize() {
+  return GetBounds().size();
+}
+
+void NativeWindow::SetPosition(const gfx::Point& position, bool animate) {
+  SetBounds(gfx::Rect(position, GetSize()), animate);
+}
+
+gfx::Point NativeWindow::GetPosition() {
+  return GetBounds().origin();
+}
+
+void NativeWindow::SetContentSize(const gfx::Size& size, bool animate) {
+  SetSize(ContentSizeToWindowSize(size), animate);
+}
+
+gfx::Size NativeWindow::GetContentSize() {
+  return WindowSizeToContentSize(GetSize());
+}
+
+void NativeWindow::SetSizeConstraints(
+    const extensions::SizeConstraints& window_constraints) {
+  extensions::SizeConstraints content_constraints;
+  if (window_constraints.HasMaximumSize())
+    content_constraints.set_maximum_size(
+        WindowSizeToContentSize(window_constraints.GetMaximumSize()));
+  if (window_constraints.HasMinimumSize())
+    content_constraints.set_minimum_size(
+        WindowSizeToContentSize(window_constraints.GetMinimumSize()));
+  SetContentSizeConstraints(content_constraints);
+}
+
+extensions::SizeConstraints NativeWindow::GetSizeConstraints() {
+  extensions::SizeConstraints content_constraints = GetContentSizeConstraints();
+  extensions::SizeConstraints window_constraints;
+  if (content_constraints.HasMaximumSize())
+    window_constraints.set_maximum_size(
+        ContentSizeToWindowSize(content_constraints.GetMaximumSize()));
+  if (content_constraints.HasMinimumSize())
+    window_constraints.set_minimum_size(
+        ContentSizeToWindowSize(content_constraints.GetMinimumSize()));
+  return window_constraints;
+}
+
+void NativeWindow::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  size_constraints_ = size_constraints;
+}
+
+extensions::SizeConstraints NativeWindow::GetContentSizeConstraints() {
+  return size_constraints_;
+}
+
+void NativeWindow::SetMinimumSize(const gfx::Size& size) {
+  extensions::SizeConstraints size_constraints;
+  size_constraints.set_minimum_size(size);
+  SetSizeConstraints(size_constraints);
+}
+
+gfx::Size NativeWindow::GetMinimumSize() {
+  return GetSizeConstraints().GetMinimumSize();
+}
+
+void NativeWindow::SetMaximumSize(const gfx::Size& size) {
+  extensions::SizeConstraints size_constraints;
+  size_constraints.set_maximum_size(size);
+  SetSizeConstraints(size_constraints);
+}
+
+gfx::Size NativeWindow::GetMaximumSize() {
+  return GetSizeConstraints().GetMaximumSize();
+}
+
+void NativeWindow::SetRepresentedFilename(const std::string& filename) {
+}
+
+std::string NativeWindow::GetRepresentedFilename() {
+  return "";
+}
+
+void NativeWindow::SetDocumentEdited(bool edited) {
+}
+
+bool NativeWindow::IsDocumentEdited() {
+  return false;
+}
+
+void NativeWindow::SetIgnoreMouseEvents(bool ignore) {
+}
+
+void NativeWindow::SetMenu(ui::MenuModel* menu) {
+}
+
+bool NativeWindow::HasModalDialog() {
+  return has_dialog_attached_;
+}
+
+void NativeWindow::FocusOnWebView() {
+  web_contents()->GetRenderViewHost()->GetWidget()->Focus();
+}
+
+void NativeWindow::BlurWebView() {
+  web_contents()->GetRenderViewHost()->GetWidget()->Blur();
+}
+
+bool NativeWindow::IsWebViewFocused() {
+  auto host_view = web_contents()->GetRenderViewHost()->GetWidget()->GetView();
+  return host_view && host_view->HasFocus();
+}
+
+void NativeWindow::CapturePage(const gfx::Rect& rect,
+                               const CapturePageCallback& callback) {
+  const auto view = web_contents()->GetRenderWidgetHostView();
+  const auto host = view ? view->GetRenderWidgetHost() : nullptr;
+  if (!view || !host) {
+    callback.Run(SkBitmap());
+    return;
+  }
+
+  // Capture full page if user doesn't specify a |rect|.
+  const gfx::Size view_size = rect.IsEmpty() ? view->GetViewBounds().size() :
+                                               rect.size();
+
+  // By default, the requested bitmap size is the view size in screen
+  // coordinates.  However, if there's more pixel detail available on the
+  // current system, increase the requested bitmap size to capture it all.
+  gfx::Size bitmap_size = view_size;
+  const gfx::NativeView native_view = view->GetNativeView();
+  gfx::Screen* const screen = gfx::Screen::GetScreenFor(native_view);
+  const float scale =
+      screen->GetDisplayNearestWindow(native_view).device_scale_factor();
+  if (scale > 1.0f)
+    bitmap_size = gfx::ScaleToCeiledSize(view_size, scale);
+
+  host->CopyFromBackingStore(
+      gfx::Rect(rect.origin(), view_size),
+      bitmap_size,
+      base::Bind(&NativeWindow::OnCapturePageDone,
+                 weak_factory_.GetWeakPtr(),
+                 callback),
+      kBGRA_8888_SkColorType);
+}
+
+void NativeWindow::ShowDefinitionForSelection() {
+  NOTIMPLEMENTED();
+}
+
+void NativeWindow::SetAutoHideMenuBar(bool auto_hide) {
+}
+
+bool NativeWindow::IsMenuBarAutoHide() {
+  return false;
+}
+
+void NativeWindow::SetMenuBarVisibility(bool visible) {
+}
+
+bool NativeWindow::IsMenuBarVisible() {
+  return true;
+}
+
+double NativeWindow::GetAspectRatio() {
+  return aspect_ratio_;
+}
+
+gfx::Size NativeWindow::GetAspectRatioExtraSize() {
+  return aspect_ratio_extraSize_;
+}
+
+void NativeWindow::SetAspectRatio(double aspect_ratio,
+                                  const gfx::Size& extra_size) {
+  aspect_ratio_ = aspect_ratio;
+  aspect_ratio_extraSize_ = extra_size;
+}
+
+void NativeWindow::RequestToClosePage() {
+  bool prevent_default = false;
+  FOR_EACH_OBSERVER(NativeWindowObserver,
+                    observers_,
+                    WillCloseWindow(&prevent_default));
+  if (prevent_default) {
+    WindowList::WindowCloseCancelled(this);
+    return;
+  }
+
+  // Assume the window is not responding if it doesn't cancel the close and is
+  // not closed in 5s, in this way we can quickly show the unresponsive
+  // dialog when the window is busy executing some script withouth waiting for
+  // the unresponsive timeout.
+  if (window_unresposive_closure_.IsCancelled())
+    ScheduleUnresponsiveEvent(5000);
+
+  if (web_contents()->NeedToFireBeforeUnload())
+    web_contents()->DispatchBeforeUnload(false);
+  else
+    web_contents()->Close();
+}
+
+void NativeWindow::CloseContents(content::WebContents* source) {
+  if (!inspectable_web_contents_)
+    return;
+
+  inspectable_web_contents_->GetView()->SetDelegate(nullptr);
+  inspectable_web_contents_ = nullptr;
+  Observe(nullptr);
+
+  // When the web contents is gone, close the window immediately, but the
+  // memory will not be freed until you call delete.
+  // In this way, it would be safe to manage windows via smart pointers. If you
+  // want to free memory when the window is closed, you can do deleting by
+  // overriding the OnWindowClosed method in the observer.
+  CloseImmediately();
+
+  // Do not sent "unresponsive" event after window is closed.
+  window_unresposive_closure_.Cancel();
+}
+
+void NativeWindow::RendererUnresponsive(content::WebContents* source) {
+  // Schedule the unresponsive shortly later, since we may receive the
+  // responsive event soon. This could happen after the whole application had
+  // blocked for a while.
+  // Also notice that when closing this event would be ignored because we have
+  // explicity started a close timeout counter. This is on purpose because we
+  // don't want the unresponsive event to be sent too early when user is closing
+  // the window.
+  ScheduleUnresponsiveEvent(50);
+}
+
+void NativeWindow::RendererResponsive(content::WebContents* source) {
+  window_unresposive_closure_.Cancel();
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnRendererResponsive());
+}
+
+void NativeWindow::NotifyWindowClosed() {
+  if (is_closed_)
+    return;
+
+  WindowList::RemoveWindow(this);
+
+  is_closed_ = true;
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowClosed());
+}
+
+void NativeWindow::NotifyWindowBlur() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowBlur());
+}
+
+void NativeWindow::NotifyWindowFocus() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowFocus());
+}
+
+void NativeWindow::NotifyWindowShow() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowShow());
+}
+
+void NativeWindow::NotifyWindowHide() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowHide());
+}
+
+void NativeWindow::NotifyWindowMaximize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMaximize());
+}
+
+void NativeWindow::NotifyWindowUnmaximize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowUnmaximize());
+}
+
+void NativeWindow::NotifyWindowMinimize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMinimize());
+}
+
+void NativeWindow::NotifyWindowRestore() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowRestore());
+}
+
+void NativeWindow::NotifyWindowResize() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowResize());
+}
+
+void NativeWindow::NotifyWindowMove() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMove());
+}
+
+void NativeWindow::NotifyWindowMoved() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_, OnWindowMoved());
+}
+
+void NativeWindow::NotifyWindowEnterFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowEnterFullScreen());
+}
+
+void NativeWindow::NotifyWindowScrollTouchBegin() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowScrollTouchBegin());
+}
+
+void NativeWindow::NotifyWindowScrollTouchEnd() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowScrollTouchEnd());
+}
+
+void NativeWindow::NotifyWindowSwipe(const std::string& direction) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowSwipe(direction));
+}
+
+void NativeWindow::NotifyWindowLeaveFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowLeaveFullScreen());
+}
+
+void NativeWindow::NotifyWindowEnterHtmlFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowEnterHtmlFullScreen());
+}
+
+void NativeWindow::NotifyWindowLeaveHtmlFullScreen() {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowLeaveHtmlFullScreen());
+}
+
+void NativeWindow::NotifyWindowExecuteWindowsCommand(
+    const std::string& command) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnExecuteWindowsCommand(command));
+}
+
+#if defined(OS_WIN)
+void NativeWindow::NotifyWindowMessage(
+    UINT message, WPARAM w_param, LPARAM l_param) {
+  FOR_EACH_OBSERVER(NativeWindowObserver, observers_,
+                    OnWindowMessage(message, w_param, l_param));
+}
+#endif
+
+scoped_ptr<SkRegion> NativeWindow::DraggableRegionsToSkRegion(
+    const std::vector<DraggableRegion>& regions) {
+  scoped_ptr<SkRegion> sk_region(new SkRegion);
+  for (const DraggableRegion& region : regions) {
+    sk_region->op(
+        region.bounds.x(),
+        region.bounds.y(),
+        region.bounds.right(),
+        region.bounds.bottom(),
+        region.draggable ? SkRegion::kUnion_Op : SkRegion::kDifference_Op);
+  }
+  return sk_region;
+}
+
+void NativeWindow::RenderViewCreated(
+    content::RenderViewHost* render_view_host) {
+  if (!transparent_)
+    return;
+
+  content::RenderWidgetHostImpl* impl = content::RenderWidgetHostImpl::FromID(
+      render_view_host->GetProcess()->GetID(),
+      render_view_host->GetRoutingID());
+  if (impl)
+    impl->SetBackgroundOpaque(false);
+}
+
+void NativeWindow::BeforeUnloadDialogCancelled() {
+  WindowList::WindowCloseCancelled(this);
+
+  // Cancel unresponsive event when window close is cancelled.
+  window_unresposive_closure_.Cancel();
+}
+
+bool NativeWindow::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(NativeWindow, message)
+    IPC_MESSAGE_HANDLER(ElectronViewHostMsg_UpdateDraggableRegions,
+                        UpdateDraggableRegions)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+void NativeWindow::UpdateDraggableRegions(
+    const std::vector<DraggableRegion>& regions) {
+  // Draggable region is not supported for non-frameless window.
+  if (has_frame_ && !force_using_draggable_region_)
+    return;
+  draggable_region_ = DraggableRegionsToSkRegion(regions);
+}
+
+void NativeWindow::ScheduleUnresponsiveEvent(int ms) {
+  if (!window_unresposive_closure_.IsCancelled())
+    return;
+
+  window_unresposive_closure_.Reset(
+      base::Bind(&NativeWindow::NotifyWindowUnresponsive,
+                 weak_factory_.GetWeakPtr()));
+  base::MessageLoop::current()->PostDelayedTask(
+      FROM_HERE,
+      window_unresposive_closure_.callback(),
+      base::TimeDelta::FromMilliseconds(ms));
+}
+
+void NativeWindow::NotifyWindowUnresponsive() {
+  window_unresposive_closure_.Cancel();
+
+  if (!is_closed_ && !HasModalDialog())
+    FOR_EACH_OBSERVER(NativeWindowObserver,
+                      observers_,
+                      OnRendererUnresponsive());
+}
+
+void NativeWindow::OnCapturePageDone(const CapturePageCallback& callback,
+                                     const SkBitmap& bitmap,
+                                     content::ReadbackResponse response) {
+  callback.Run(bitmap);
+}
+
+SkColor NativeWindow::ParseHexColor(const std::string& name) {
+  auto color = name.substr(1);
+  unsigned length = color.size();
+  SkColor result = (length != 8 ? 0xFF000000 : 0x00000000);
+  unsigned value = 0;
+  if (length != 3 && length != 6 && length != 8)
+    return result;
+  for (unsigned i = 0; i < length; ++i) {
+    if (!base::IsHexDigit(color[i]))
+      return result;
+    value <<= 4;
+    value |= (color[i] < 'A' ? color[i] - '0' : (color[i] - 'A' + 10) & 0xF);
+  }
+  if (length == 6 || length == 8) {
+    result |= value;
+    return result;
+  }
+  result |= (value & 0xF00) << 12 | (value & 0xF00) << 8
+      | (value & 0xF0) << 8 | (value & 0xF0) << 4
+      | (value & 0xF) << 4 | (value & 0xF);
+  return result;
+}
+
+}  // namespace electron
added in remote
  their  100644 ff46845fef38028b3c3280e7409c94965c769853 electron/browser/native_window.h
@@ -0,0 +1,364 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "electron/browser/native_window_observer.h"
+#include "electron/browser/ui/accelerator_util.h"
+#include "base/cancelable_callback.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/observer_list.h"
+#include "base/supports_user_data.h"
+#include "content/public/browser/readback_types.h"
+#include "content/public/browser/web_contents_observer.h"
+#include "content/public/browser/web_contents_user_data.h"
+#include "extensions/browser/app_window/size_constraints.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/image/image_skia.h"
+
+class SkRegion;
+
+namespace brightray {
+class InspectableWebContents;
+}
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace gfx {
+class Point;
+class Rect;
+class Size;
+}
+
+namespace mate {
+class Dictionary;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace electron {
+
+struct DraggableRegion;
+
+class NativeWindow : public base::SupportsUserData,
+                     public content::WebContentsObserver {
+ public:
+  using CapturePageCallback = base::Callback<void(const SkBitmap& bitmap)>;
+
+  class DialogScope {
+   public:
+    explicit DialogScope(NativeWindow* window)
+        : window_(window) {
+      if (window_ != NULL)
+        window_->set_has_dialog_attached(true);
+    }
+
+    ~DialogScope() {
+      if (window_ != NULL)
+        window_->set_has_dialog_attached(false);
+    }
+
+   private:
+    NativeWindow* window_;
+
+    DISALLOW_COPY_AND_ASSIGN(DialogScope);
+  };
+
+  virtual ~NativeWindow();
+
+  // Create window with existing WebContents, the caller is responsible for
+  // managing the window's live.
+  static NativeWindow* Create(
+      brightray::InspectableWebContents* inspectable_web_contents,
+      const mate::Dictionary& options);
+
+  // Find a window from its WebContents
+  static NativeWindow* FromWebContents(content::WebContents* web_contents);
+
+  void InitFromOptions(const mate::Dictionary& options);
+
+  virtual void Close() = 0;
+  virtual void CloseImmediately() = 0;
+  virtual bool IsClosed() const { return is_closed_; }
+  virtual void Focus(bool focus) = 0;
+  virtual bool IsFocused() = 0;
+  virtual void Show() = 0;
+  virtual void ShowInactive() = 0;
+  virtual void Hide() = 0;
+  virtual bool IsVisible() = 0;
+  virtual void Maximize() = 0;
+  virtual void Unmaximize() = 0;
+  virtual bool IsMaximized() = 0;
+  virtual void Minimize() = 0;
+  virtual void Restore() = 0;
+  virtual bool IsMinimized() = 0;
+  virtual void SetFullScreen(bool fullscreen) = 0;
+  virtual bool IsFullscreen() const = 0;
+  virtual void SetBounds(const gfx::Rect& bounds, bool animate = false) = 0;
+  virtual gfx::Rect GetBounds() = 0;
+  virtual void SetSize(const gfx::Size& size, bool animate = false);
+  virtual gfx::Size GetSize();
+  virtual void SetPosition(const gfx::Point& position, bool animate = false);
+  virtual gfx::Point GetPosition();
+  virtual void SetContentSize(const gfx::Size& size, bool animate = false);
+  virtual gfx::Size GetContentSize();
+  virtual void SetSizeConstraints(
+      const extensions::SizeConstraints& size_constraints);
+  virtual extensions::SizeConstraints GetSizeConstraints();
+  virtual void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints);
+  virtual extensions::SizeConstraints GetContentSizeConstraints();
+  virtual void SetMinimumSize(const gfx::Size& size);
+  virtual gfx::Size GetMinimumSize();
+  virtual void SetMaximumSize(const gfx::Size& size);
+  virtual gfx::Size GetMaximumSize();
+  virtual void SetResizable(bool resizable) = 0;
+  virtual bool IsResizable() = 0;
+  virtual void SetMovable(bool movable) = 0;
+  virtual bool IsMovable() = 0;
+  virtual void SetMinimizable(bool minimizable) = 0;
+  virtual bool IsMinimizable() = 0;
+  virtual void SetMaximizable(bool maximizable) = 0;
+  virtual bool IsMaximizable() = 0;
+  virtual void SetFullScreenable(bool fullscreenable) = 0;
+  virtual bool IsFullScreenable() = 0;
+  virtual void SetClosable(bool closable) = 0;
+  virtual bool IsClosable() = 0;
+  virtual void SetAlwaysOnTop(bool top) = 0;
+  virtual bool IsAlwaysOnTop() = 0;
+  virtual void Center() = 0;
+  virtual void SetTitle(const std::string& title) = 0;
+  virtual std::string GetTitle() = 0;
+  virtual void FlashFrame(bool flash) = 0;
+  virtual void SetSkipTaskbar(bool skip) = 0;
+  virtual void SetKiosk(bool kiosk) = 0;
+  virtual bool IsKiosk() = 0;
+  virtual void SetBackgroundColor(const std::string& color_name) = 0;
+  virtual void SetHasShadow(bool has_shadow) = 0;
+  virtual bool HasShadow() = 0;
+  virtual void SetRepresentedFilename(const std::string& filename);
+  virtual std::string GetRepresentedFilename();
+  virtual void SetDocumentEdited(bool edited);
+  virtual bool IsDocumentEdited();
+  virtual void SetIgnoreMouseEvents(bool ignore);
+  virtual void SetMenu(ui::MenuModel* menu);
+  virtual bool HasModalDialog();
+  virtual gfx::NativeWindow GetNativeWindow() = 0;
+  virtual gfx::AcceleratedWidget GetAcceleratedWidget() = 0;
+
+  // Taskbar/Dock APIs.
+  virtual void SetProgressBar(double progress) = 0;
+  virtual void SetOverlayIcon(const gfx::Image& overlay,
+                              const std::string& description) = 0;
+
+  // Workspace APIs.
+  virtual void SetVisibleOnAllWorkspaces(bool visible) = 0;
+  virtual bool IsVisibleOnAllWorkspaces() = 0;
+
+  // Webview APIs.
+  virtual void FocusOnWebView();
+  virtual void BlurWebView();
+  virtual bool IsWebViewFocused();
+
+  // Captures the page with |rect|, |callback| would be called when capturing is
+  // done.
+  virtual void CapturePage(const gfx::Rect& rect,
+                           const CapturePageCallback& callback);
+
+  // Show popup dictionary.
+  virtual void ShowDefinitionForSelection();
+
+  // Toggle the menu bar.
+  virtual void SetAutoHideMenuBar(bool auto_hide);
+  virtual bool IsMenuBarAutoHide();
+  virtual void SetMenuBarVisibility(bool visible);
+  virtual bool IsMenuBarVisible();
+
+  // Set the aspect ratio when resizing window.
+  double GetAspectRatio();
+  gfx::Size GetAspectRatioExtraSize();
+  void SetAspectRatio(double aspect_ratio, const gfx::Size& extra_size);
+
+  base::WeakPtr<NativeWindow> GetWeakPtr() {
+    return weak_factory_.GetWeakPtr();
+  }
+
+  // Requests the WebContents to close, can be cancelled by the page.
+  virtual void RequestToClosePage();
+
+  // Methods called by the WebContents.
+  virtual void CloseContents(content::WebContents* source);
+  virtual void RendererUnresponsive(content::WebContents* source);
+  virtual void RendererResponsive(content::WebContents* source);
+  virtual void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent& event) {}
+
+  // Public API used by platform-dependent delegates and observers to send UI
+  // related notifications.
+  void NotifyWindowClosed();
+  void NotifyWindowBlur();
+  void NotifyWindowFocus();
+  void NotifyWindowShow();
+  void NotifyWindowHide();
+  void NotifyWindowMaximize();
+  void NotifyWindowUnmaximize();
+  void NotifyWindowMinimize();
+  void NotifyWindowRestore();
+  void NotifyWindowMove();
+  void NotifyWindowResize();
+  void NotifyWindowMoved();
+  void NotifyWindowScrollTouchBegin();
+  void NotifyWindowScrollTouchEnd();
+  void NotifyWindowSwipe(const std::string& direction);
+  void NotifyWindowEnterFullScreen();
+  void NotifyWindowLeaveFullScreen();
+  void NotifyWindowEnterHtmlFullScreen();
+  void NotifyWindowLeaveHtmlFullScreen();
+  void NotifyWindowExecuteWindowsCommand(const std::string& command);
+
+  #if defined(OS_WIN)
+  void NotifyWindowMessage(UINT message, WPARAM w_param, LPARAM l_param);
+  #endif
+
+  void AddObserver(NativeWindowObserver* obs) {
+    observers_.AddObserver(obs);
+  }
+  void RemoveObserver(NativeWindowObserver* obs) {
+    observers_.RemoveObserver(obs);
+  }
+
+  brightray::InspectableWebContents* inspectable_web_contents() const {
+    return inspectable_web_contents_;
+  }
+
+  bool has_frame() const { return has_frame_; }
+  bool transparent() const { return transparent_; }
+  SkRegion* draggable_region() const { return draggable_region_.get(); }
+  bool enable_larger_than_screen() const { return enable_larger_than_screen_; }
+  gfx::ImageSkia icon() const { return icon_; }
+
+  bool force_using_draggable_region() const {
+    return force_using_draggable_region_;
+  }
+  void set_force_using_draggable_region(bool force) {
+    force_using_draggable_region_ = true;
+  }
+
+  void set_has_dialog_attached(bool has_dialog_attached) {
+    has_dialog_attached_ = has_dialog_attached;
+  }
+
+ protected:
+  NativeWindow(brightray::InspectableWebContents* inspectable_web_contents,
+               const mate::Dictionary& options);
+
+  // Convert draggable regions in raw format to SkRegion format. Caller is
+  // responsible for deleting the returned SkRegion instance.
+  scoped_ptr<SkRegion> DraggableRegionsToSkRegion(
+      const std::vector<DraggableRegion>& regions);
+
+  // Converts between content size to window size.
+  virtual gfx::Size ContentSizeToWindowSize(const gfx::Size& size) = 0;
+  virtual gfx::Size WindowSizeToContentSize(const gfx::Size& size) = 0;
+
+  // Called when the window needs to update its draggable region.
+  virtual void UpdateDraggableRegions(
+      const std::vector<DraggableRegion>& regions);
+
+  // content::WebContentsObserver:
+  void RenderViewCreated(content::RenderViewHost* render_view_host) override;
+  void BeforeUnloadDialogCancelled() override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  // Parse hex color like "#FFF" or "#EFEFEF"
+  SkColor ParseHexColor(const std::string& name);
+
+ private:
+  // Schedule a notification unresponsive event.
+  void ScheduleUnresponsiveEvent(int ms);
+
+  // Dispatch unresponsive event to observers.
+  void NotifyWindowUnresponsive();
+
+  // Called when CapturePage has done.
+  void OnCapturePageDone(const CapturePageCallback& callback,
+                         const SkBitmap& bitmap,
+                         content::ReadbackResponse response);
+
+  // Whether window has standard frame.
+  bool has_frame_;
+
+  // Force the window to be aware of draggable regions.
+  bool force_using_draggable_region_;
+
+  // Whether window is transparent.
+  bool transparent_;
+
+  // For custom drag, the whole window is non-draggable and the draggable region
+  // has to been explicitly provided.
+  scoped_ptr<SkRegion> draggable_region_;  // used in custom drag.
+
+  // Minimum and maximum size, stored as content size.
+  extensions::SizeConstraints size_constraints_;
+
+  // Whether window can be resized larger than screen.
+  bool enable_larger_than_screen_;
+
+  // Window icon.
+  gfx::ImageSkia icon_;
+
+  // The windows has been closed.
+  bool is_closed_;
+
+  // There is a dialog that has been attached to window.
+  bool has_dialog_attached_;
+
+  // Closure that would be called when window is unresponsive when closing,
+  // it should be cancelled when we can prove that the window is responsive.
+  base::CancelableClosure window_unresposive_closure_;
+
+  // Used to maintain the aspect ratio of a view which is inside of the
+  // content view.
+  double aspect_ratio_;
+  gfx::Size aspect_ratio_extraSize_;
+
+  // The page this window is viewing.
+  brightray::InspectableWebContents* inspectable_web_contents_;
+
+  // Observers of this window.
+  base::ObserverList<NativeWindowObserver> observers_;
+
+  base::WeakPtrFactory<NativeWindow> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindow);
+};
+
+// This class provides a hook to get a NativeWindow from a WebContents.
+class NativeWindowRelay :
+    public content::WebContentsUserData<NativeWindowRelay> {
+ public:
+  explicit NativeWindowRelay(base::WeakPtr<NativeWindow> window)
+    : key(UserDataKey()), window(window) {}
+
+  void* key;
+  base::WeakPtr<NativeWindow> window;
+
+ private:
+  friend class content::WebContentsUserData<NativeWindow>;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_H_
added in remote
  their  100644 04e2e6f0011cd87ce55b36add9ec0f85b95c4050 electron/browser/native_window_mac.h
@@ -0,0 +1,152 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include <string>
+#include <vector>
+
+#include "base/mac/scoped_nsobject.h"
+#include "electron/browser/native_window.h"
+
+@class ElectronNSWindow;
+@class ElectronNSWindowDelegate;
+@class FullSizeContentView;
+
+namespace electron {
+
+class NativeWindowMac : public NativeWindow {
+ public:
+  NativeWindowMac(brightray::InspectableWebContents* inspectable_web_contents,
+                  const mate::Dictionary& options);
+  ~NativeWindowMac() override;
+
+  // NativeWindow:
+  void Close() override;
+  void CloseImmediately() override;
+  void Focus(bool focus) override;
+  bool IsFocused() override;
+  void Show() override;
+  void ShowInactive() override;
+  void Hide() override;
+  bool IsVisible() override;
+  void Maximize() override;
+  void Unmaximize() override;
+  bool IsMaximized() override;
+  void Minimize() override;
+  void Restore() override;
+  bool IsMinimized() override;
+  void SetFullScreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetBounds(const gfx::Rect& bounds, bool animate = false) override;
+  gfx::Rect GetBounds() override;
+  void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints) override;
+  void SetResizable(bool resizable) override;
+  bool IsResizable() override;
+  void SetMovable(bool movable) override;
+  bool IsMovable() override;
+  void SetMinimizable(bool minimizable) override;
+  bool IsMinimizable() override;
+  void SetMaximizable(bool maximizable) override;
+  bool IsMaximizable() override;
+  void SetFullScreenable(bool fullscreenable) override;
+  bool IsFullScreenable() override;
+  void SetClosable(bool closable) override;
+  bool IsClosable() override;
+  void SetAlwaysOnTop(bool top) override;
+  bool IsAlwaysOnTop() override;
+  void Center() override;
+  void SetTitle(const std::string& title) override;
+  std::string GetTitle() override;
+  void FlashFrame(bool flash) override;
+  void SetSkipTaskbar(bool skip) override;
+  void SetKiosk(bool kiosk) override;
+  bool IsKiosk() override;
+  void SetBackgroundColor(const std::string& color_name) override;
+  void SetHasShadow(bool has_shadow) override;
+  bool HasShadow() override;
+  void SetRepresentedFilename(const std::string& filename) override;
+  std::string GetRepresentedFilename() override;
+  void SetDocumentEdited(bool edited) override;
+  bool IsDocumentEdited() override;
+  void SetIgnoreMouseEvents(bool ignore) override;
+  bool HasModalDialog() override;
+  gfx::NativeWindow GetNativeWindow() override;
+  gfx::AcceleratedWidget GetAcceleratedWidget() override;
+  void SetProgressBar(double progress) override;
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description) override;
+  void ShowDefinitionForSelection() override;
+
+  void SetVisibleOnAllWorkspaces(bool visible) override;
+  bool IsVisibleOnAllWorkspaces() override;
+
+  // Refresh the DraggableRegion views.
+  void UpdateDraggableRegionViews() {
+    UpdateDraggableRegionViews(draggable_regions_);
+  }
+
+  bool should_hide_native_toolbar_in_fullscreen() const {
+    return should_hide_native_toolbar_in_fullscreen_;
+  }
+
+ protected:
+  // NativeWindow:
+  void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent&) override;
+
+  // Return a vector of non-draggable regions that fill a window of size
+  // |width| by |height|, but leave gaps where the window should be draggable.
+  std::vector<gfx::Rect> CalculateNonDraggableRegions(
+      const std::vector<DraggableRegion>& regions, int width, int height);
+
+ private:
+  // NativeWindow:
+  gfx::Size ContentSizeToWindowSize(const gfx::Size& size) override;
+  gfx::Size WindowSizeToContentSize(const gfx::Size& size) override;
+  void UpdateDraggableRegions(
+      const std::vector<DraggableRegion>& regions) override;
+
+  void InstallView();
+  void UninstallView();
+
+  // Install the drag view, which will cover the whole window and decides
+  // whehter we can drag.
+  void UpdateDraggableRegionViews(const std::vector<DraggableRegion>& regions);
+
+  // Set the attribute of NSWindow while work around a bug of zo0m button.
+  void SetStyleMask(bool on, NSUInteger flag);
+  void SetCollectionBehavior(bool on, NSUInteger flag);
+
+  base::scoped_nsobject<ElectronNSWindow> window_;
+  base::scoped_nsobject<ElectronNSWindowDelegate> window_delegate_;
+
+  // Event monitor for scroll wheel event.
+  id wheel_event_monitor_;
+
+  // The view that will fill the whole frameless window.
+  base::scoped_nsobject<FullSizeContentView> content_view_;
+
+  std::vector<DraggableRegion> draggable_regions_;
+
+  bool is_kiosk_;
+
+  NSInteger attention_request_id_;  // identifier from requestUserAttention
+
+  // The presentation options before entering kiosk mode.
+  NSApplicationPresentationOptions kiosk_options_;
+
+  bool should_hide_native_toolbar_in_fullscreen_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowMac);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_MAC_H_
added in remote
  their  100644 7fe60a43f141fd72ad518ee47c6b0fe94ac0227d electron/browser/native_window_mac.mm
@@ -0,0 +1,1096 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_mac.h"
+
+#include <string>
+
+#include "electron/common/draggable_region.h"
+#include "electron/common/options_switches.h"
+#include "base/mac/mac_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/public/browser/browser_accessibility_state.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+#include "native_mate/dictionary.h"
+#include "ui/gfx/skia_util.h"
+
+namespace {
+
+// Prevents window from resizing during the scope.
+class ScopedDisableResize {
+ public:
+  ScopedDisableResize() { disable_resize_ = true; }
+  ~ScopedDisableResize() { disable_resize_ = false; }
+
+  static bool IsResizeDisabled() { return disable_resize_; }
+
+ private:
+  static bool disable_resize_;
+};
+
+bool ScopedDisableResize::disable_resize_ = false;
+
+}  // namespace
+
+// This view always takes the size of its superview. It is intended to be used
+// as a NSWindow's contentView.  It is needed because NSWindow's implementation
+// explicitly resizes the contentView at inopportune times.
+@interface FullSizeContentView : NSView
+@end
+
+@implementation FullSizeContentView
+
+// This method is directly called by NSWindow during a window resize on OSX
+// 10.10.0, beta 2. We must override it to prevent the content view from
+// shrinking.
+- (void)setFrameSize:(NSSize)size {
+  if ([self superview])
+    size = [[self superview] bounds].size;
+  [super setFrameSize:size];
+}
+
+// The contentView gets moved around during certain full-screen operations.
+// This is less than ideal, and should eventually be removed.
+- (void)viewDidMoveToSuperview {
+  [self setFrame:[[self superview] bounds]];
+}
+
+@end
+
+@interface ElectronNSWindowDelegate : NSObject<NSWindowDelegate> {
+ @private
+  electron::NativeWindowMac* shell_;
+}
+- (id)initWithShell:(electron::NativeWindowMac*)shell;
+@end
+
+@implementation ElectronNSWindowDelegate
+
+- (id)initWithShell:(electron::NativeWindowMac*)shell {
+  if ((self = [super init])) {
+    shell_ = shell;
+  }
+  return self;
+}
+
+- (void)windowDidChangeOcclusionState:(NSNotification *)notification {
+  // notification.object is the window that changed its state.
+  // It's safe to use self.window instead if you don't assign one delegate to many windows
+  NSWindow *window = notification.object;
+
+  // check occlusion binary flag
+  if (window.occlusionState & NSWindowOcclusionStateVisible)   {
+     // The app is visible
+     shell_->NotifyWindowShow();
+   } else {
+     // The app is not visible
+     shell_->NotifyWindowHide();
+   }
+}
+
+- (void)windowDidBecomeMain:(NSNotification*)notification {
+  content::WebContents* web_contents = shell_->web_contents();
+  if (!web_contents)
+    return;
+
+  web_contents->RestoreFocus();
+
+  content::RenderWidgetHostView* rwhv = web_contents->GetRenderWidgetHostView();
+  if (rwhv)
+    rwhv->SetActive(true);
+
+  shell_->NotifyWindowFocus();
+}
+
+- (void)windowDidResignMain:(NSNotification*)notification {
+  content::WebContents* web_contents = shell_->web_contents();
+  if (!web_contents)
+    return;
+
+  web_contents->StoreFocus();
+
+  content::RenderWidgetHostView* rwhv = web_contents->GetRenderWidgetHostView();
+  if (rwhv)
+    rwhv->SetActive(false);
+
+  shell_->NotifyWindowBlur();
+}
+
+- (NSSize)windowWillResize:(NSWindow*)sender toSize:(NSSize)frameSize {
+  NSSize newSize = frameSize;
+  double aspectRatio = shell_->GetAspectRatio();
+
+  if (aspectRatio > 0.0) {
+    gfx::Size windowSize = shell_->GetSize();
+    gfx::Size contentSize = shell_->GetContentSize();
+    gfx::Size extraSize = shell_->GetAspectRatioExtraSize();
+
+    double extraWidthPlusFrame =
+        windowSize.width() - contentSize.width() + extraSize.width();
+    double extraHeightPlusFrame =
+        windowSize.height() - contentSize.height() + extraSize.height();
+
+    newSize.width =
+        roundf((frameSize.height - extraHeightPlusFrame) * aspectRatio +
+               extraWidthPlusFrame);
+
+    // If the new width is less than the frame size use it as the primary
+    // constraint. This ensures that the value returned by this method will
+    // never be larger than the users requested window size.
+    if (newSize.width <= frameSize.width) {
+      newSize.height =
+          roundf((newSize.width - extraWidthPlusFrame) / aspectRatio +
+                 extraHeightPlusFrame);
+    } else {
+      newSize.height =
+          roundf((frameSize.width - extraWidthPlusFrame) / aspectRatio +
+                 extraHeightPlusFrame);
+      newSize.width =
+          roundf((newSize.height - extraHeightPlusFrame) * aspectRatio +
+                 extraWidthPlusFrame);
+    }
+  }
+
+  return newSize;
+}
+
+- (void)windowDidResize:(NSNotification*)notification {
+  shell_->UpdateDraggableRegionViews();
+  shell_->NotifyWindowResize();
+}
+
+- (void)windowDidMove:(NSNotification*)notification {
+  // TODO(zcbenz): Remove the alias after figuring out a proper
+  // way to disptach move.
+  shell_->NotifyWindowMove();
+  shell_->NotifyWindowMoved();
+}
+
+- (void)windowDidMiniaturize:(NSNotification*)notification {
+  shell_->NotifyWindowMinimize();
+}
+
+- (void)windowDidDeminiaturize:(NSNotification*)notification {
+  shell_->NotifyWindowRestore();
+}
+
+- (BOOL)windowShouldZoom:(NSWindow*)window toFrame:(NSRect)newFrame {
+  // Cocoa doen't have concept of maximize/unmaximize, so wee need to emulate
+  // them by calculating size change when zooming.
+  if (newFrame.size.width < [window frame].size.width ||
+      newFrame.size.height < [window frame].size.height)
+    shell_->NotifyWindowUnmaximize();
+  else
+    shell_->NotifyWindowMaximize();
+  return YES;
+}
+
+- (void)windowWillEnterFullScreen:(NSNotification*)notification {
+  // Hide the native toolbar before entering fullscreen, so there is no visual
+  // artifacts.
+  if (shell_->should_hide_native_toolbar_in_fullscreen()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    [window setToolbar:nil];
+  }
+}
+
+- (void)windowDidEnterFullScreen:(NSNotification*)notification {
+  shell_->NotifyWindowEnterFullScreen();
+
+  // Restore the native toolbar immediately after entering fullscreen, if we do
+  // this before leaving fullscreen, traffic light buttons will be jumping.
+  if (shell_->should_hide_native_toolbar_in_fullscreen()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    base::scoped_nsobject<NSToolbar> toolbar(
+        [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
+    [toolbar setShowsBaselineSeparator:NO];
+    [window setToolbar:toolbar];
+  }
+}
+
+- (void)windowDidExitFullScreen:(NSNotification*)notification {
+  if (!shell_->has_frame()) {
+    NSWindow* window = shell_->GetNativeWindow();
+    [[window standardWindowButton:NSWindowFullScreenButton] setHidden:YES];
+  }
+
+  shell_->NotifyWindowLeaveFullScreen();
+}
+
+- (void)windowWillClose:(NSNotification*)notification {
+  shell_->NotifyWindowClosed();
+
+  // Clears the delegate when window is going to be closed, since EL Capitan it
+  // is possible that the methods of delegate would get called after the window
+  // has been closed.
+  [shell_->GetNativeWindow() setDelegate:nil];
+}
+
+- (BOOL)windowShouldClose:(id)window {
+  // When user tries to close the window by clicking the close button, we do
+  // not close the window immediately, instead we try to close the web page
+  // fisrt, and when the web page is closed the window will also be closed.
+  shell_->RequestToClosePage();
+  return NO;
+}
+
+@end
+
+@interface ElectronNSWindow : NSWindow {
+ @private
+  electron::NativeWindowMac* shell_;
+  bool enable_larger_than_screen_;
+}
+@property BOOL acceptsFirstMouse;
+@property BOOL disableAutoHideCursor;
+@property BOOL disableKeyOrMainWindow;
+
+- (void)setShell:(electron::NativeWindowMac*)shell;
+- (void)setEnableLargerThanScreen:(bool)enable;
+@end
+
+@implementation ElectronNSWindow
+
+- (void)setShell:(electron::NativeWindowMac*)shell {
+  shell_ = shell;
+}
+
+- (void)setEnableLargerThanScreen:(bool)enable {
+  enable_larger_than_screen_ = enable;
+}
+
+// NSWindow overrides.
+
+- (void)swipeWithEvent:(NSEvent *)event {
+  if (event.deltaY == 1.0) {
+    shell_->NotifyWindowSwipe("up");
+  } else if (event.deltaX == -1.0) {
+    shell_->NotifyWindowSwipe("right");
+  } else if (event.deltaY == -1.0) {
+    shell_->NotifyWindowSwipe("down");
+  } else if (event.deltaX == 1.0) {
+    shell_->NotifyWindowSwipe("left");
+  }
+}
+
+- (NSRect)constrainFrameRect:(NSRect)frameRect toScreen:(NSScreen*)screen {
+  // Resizing is disabled.
+  if (ScopedDisableResize::IsResizeDisabled())
+    return [self frame];
+
+  // Enable the window to be larger than screen.
+  if (enable_larger_than_screen_)
+    return frameRect;
+  else
+    return [super constrainFrameRect:frameRect toScreen:screen];
+}
+
+- (id)accessibilityAttributeValue:(NSString*)attribute {
+  if (![attribute isEqualToString:@"AXChildren"])
+    return [super accessibilityAttributeValue:attribute];
+
+  // Filter out objects that aren't the title bar buttons. This has the effect
+  // of removing the window title, which VoiceOver already sees.
+  // * when VoiceOver is disabled, this causes Cmd+C to be used for TTS but
+  //   still leaves the buttons available in the accessibility tree.
+  // * when VoiceOver is enabled, the full accessibility tree is used.
+  // Without removing the title and with VO disabled, the TTS would always read
+  // the window title instead of using Cmd+C to get the selected text.
+  NSPredicate *predicate = [NSPredicate predicateWithFormat:
+      @"(self isKindOfClass: %@) OR (self.className == %@)",
+      [NSButtonCell class],
+      @"RenderWidgetHostViewCocoa"];
+
+  NSArray *children = [super accessibilityAttributeValue:attribute];
+  return [children filteredArrayUsingPredicate:predicate];
+}
+
+- (BOOL)canBecomeMainWindow {
+  return !self.disableKeyOrMainWindow;
+}
+
+- (BOOL)canBecomeKeyWindow {
+  return !self.disableKeyOrMainWindow;
+}
+
+@end
+
+@interface ControlRegionView : NSView
+@end
+
+@implementation ControlRegionView
+
+- (BOOL)mouseDownCanMoveWindow {
+  return NO;
+}
+
+- (NSView*)hitTest:(NSPoint)aPoint {
+  return nil;
+}
+
+@end
+
+@interface NSView (WebContentsView)
+- (void)setMouseDownCanMoveWindow:(BOOL)can_move;
+@end
+
+@interface ElectronProgressBar : NSProgressIndicator
+@end
+
+@implementation ElectronProgressBar
+
+- (void)drawRect:(NSRect)dirtyRect {
+  if (self.style != NSProgressIndicatorBarStyle)
+    return;
+  // Draw edges of rounded rect.
+  NSRect rect = NSInsetRect([self bounds], 1.0, 1.0);
+  CGFloat radius = rect.size.height / 2;
+  NSBezierPath* bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect xRadius:radius yRadius:radius];
+  [bezier_path setLineWidth:2.0];
+  [[NSColor grayColor] set];
+  [bezier_path stroke];
+
+  // Fill the rounded rect.
+  rect = NSInsetRect(rect, 2.0, 2.0);
+  radius = rect.size.height / 2;
+  bezier_path = [NSBezierPath bezierPathWithRoundedRect:rect xRadius:radius yRadius:radius];
+  [bezier_path setLineWidth:1.0];
+  [bezier_path addClip];
+
+  // Calculate the progress width.
+  rect.size.width = floor(rect.size.width * ([self doubleValue] / [self maxValue]));
+
+  // Fill the progress bar with color blue.
+  [[NSColor colorWithSRGBRed:0.2 green:0.6 blue:1 alpha:1] set];
+  NSRectFill(rect);
+}
+
+@end
+
+namespace electron {
+
+NativeWindowMac::NativeWindowMac(
+    brightray::InspectableWebContents* web_contents,
+    const mate::Dictionary& options)
+    : NativeWindow(web_contents, options),
+      is_kiosk_(false),
+      attention_request_id_(0),
+      should_hide_native_toolbar_in_fullscreen_(false) {
+  int width = 800, height = 600;
+  options.Get(options::kWidth, &width);
+  options.Get(options::kHeight, &height);
+
+  NSRect main_screen_rect = [[[NSScreen screens] objectAtIndex:0] frame];
+  NSRect cocoa_bounds = NSMakeRect(
+      round((NSWidth(main_screen_rect) - width) / 2) ,
+      round((NSHeight(main_screen_rect) - height) / 2),
+      width,
+      height);
+
+  bool resizable = true;
+  options.Get(options::kResizable, &resizable);
+
+  bool minimizable = true;
+  options.Get(options::kMinimizable, &minimizable);
+
+  bool maximizable = true;
+  options.Get(options::kMaximizable, &maximizable);
+
+  bool closable = true;
+  options.Get(options::kClosable, &closable);
+
+  // New title bar styles are available in Yosemite or newer
+  std::string titleBarStyle;
+  if (base::mac::IsOSYosemiteOrLater())
+    options.Get(options::kTitleBarStyle, &titleBarStyle);
+
+  std::string windowType;
+  options.Get(options::kType, &windowType);
+
+  bool useStandardWindow = true;
+  // eventually deprecate separate "standardWindow" option in favor of
+  // standard / textured window types
+  options.Get(options::kStandardWindow, &useStandardWindow);
+  if (windowType == "textured") {
+    useStandardWindow = false;
+  }
+
+  NSUInteger styleMask = NSTitledWindowMask;
+  if (minimizable) {
+    styleMask |= NSMiniaturizableWindowMask;
+  }
+  if (closable) {
+    styleMask |= NSClosableWindowMask;
+  }
+  if (!useStandardWindow || transparent() || !has_frame()) {
+    styleMask |= NSTexturedBackgroundWindowMask;
+  }
+  if (resizable) {
+    styleMask |= NSResizableWindowMask;
+  }
+  if ((titleBarStyle == "hidden") || (titleBarStyle == "hidden-inset")) {
+    styleMask |= NSFullSizeContentViewWindowMask;
+    styleMask |= NSUnifiedTitleAndToolbarWindowMask;
+  }
+  // We capture this because we need to access the option later when
+  // entering/exiting fullscreen and since the options dict is only passed to
+  // the constructor but not stored, let’s store this option this way.
+  if (titleBarStyle == "hidden-inset") {
+    should_hide_native_toolbar_in_fullscreen_ = true;
+  }
+
+  window_.reset([[ElectronNSWindow alloc]
+      initWithContentRect:cocoa_bounds
+                styleMask:styleMask
+                  backing:NSBackingStoreBuffered
+                    defer:YES]);
+  [window_ setShell:this];
+  [window_ setEnableLargerThanScreen:enable_larger_than_screen()];
+
+  window_delegate_.reset([[ElectronNSWindowDelegate alloc] initWithShell:this]);
+  [window_ setDelegate:window_delegate_];
+
+  if (transparent()) {
+    // Make window has transparent background.
+    [window_ setOpaque:NO];
+    // Setting the background color to clear will also hide the shadow.
+    [window_ setBackgroundColor:[NSColor clearColor]];
+  }
+
+  if (windowType == "desktop") {
+    [window_ setLevel:kCGDesktopWindowLevel - 1];
+    [window_ setDisableKeyOrMainWindow:YES];
+    [window_ setCollectionBehavior:
+        (NSWindowCollectionBehaviorCanJoinAllSpaces |
+         NSWindowCollectionBehaviorStationary |
+         NSWindowCollectionBehaviorIgnoresCycle)];
+  }
+
+  // Remove non-transparent corners, see http://git.io/vfonD.
+  if (!has_frame())
+    [window_ setOpaque:NO];
+
+  // We will manage window's lifetime ourselves.
+  [window_ setReleasedWhenClosed:NO];
+
+  // Hide the title bar.
+  if ((titleBarStyle == "hidden") || (titleBarStyle == "hidden-inset")) {
+    [window_ setTitlebarAppearsTransparent:YES];
+    [window_ setTitleVisibility:NSWindowTitleHidden];
+    if (titleBarStyle == "hidden-inset") {
+      base::scoped_nsobject<NSToolbar> toolbar(
+          [[NSToolbar alloc] initWithIdentifier:@"titlebarStylingToolbar"]);
+      [toolbar setShowsBaselineSeparator:NO];
+      [window_ setToolbar:toolbar];
+    }
+    // We should be aware of draggable regions when using hidden titlebar.
+    set_force_using_draggable_region(true);
+  }
+
+  // On OS X the initial window size doesn't include window frame.
+  bool use_content_size = false;
+  options.Get(options::kUseContentSize, &use_content_size);
+  if (!has_frame() || !use_content_size)
+    SetSize(gfx::Size(width, height));
+
+  // Enable the NSView to accept first mouse event.
+  bool acceptsFirstMouse = false;
+  options.Get(options::kAcceptFirstMouse, &acceptsFirstMouse);
+  [window_ setAcceptsFirstMouse:acceptsFirstMouse];
+
+  // Disable auto-hiding cursor.
+  bool disableAutoHideCursor = false;
+  options.Get(options::kDisableAutoHideCursor, &disableAutoHideCursor);
+  [window_ setDisableAutoHideCursor:disableAutoHideCursor];
+
+  // Disable zoom button if window is not resizable.
+  if (!maximizable)
+    SetMaximizable(false);
+
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  [view setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+
+  // Use an NSEvent monitor to listen for the wheel event.
+  BOOL __block began = NO;
+  wheel_event_monitor_ = [NSEvent
+    addLocalMonitorForEventsMatchingMask:NSScrollWheelMask
+    handler:^(NSEvent* event) {
+      if ([[event window] windowNumber] != [window_ windowNumber])
+        return event;
+
+      if (!web_contents)
+        return event;
+
+      if (!began && (([event phase] == NSEventPhaseMayBegin) ||
+                     ([event phase] == NSEventPhaseBegan))) {
+        this->NotifyWindowScrollTouchBegin();
+        began = YES;
+      } else if (began && (([event phase] == NSEventPhaseEnded) ||
+                           ([event phase] == NSEventPhaseCancelled))) {
+        this->NotifyWindowScrollTouchEnd();
+        began = NO;
+      }
+      return event;
+  }];
+
+  InstallView();
+}
+
+NativeWindowMac::~NativeWindowMac() {
+  [NSEvent removeMonitor:wheel_event_monitor_];
+  Observe(nullptr);
+}
+
+void NativeWindowMac::Close() {
+  [window_ performClose:nil];
+}
+
+void NativeWindowMac::CloseImmediately() {
+  [window_ close];
+}
+
+void NativeWindowMac::Focus(bool focus) {
+  if (!IsVisible())
+    return;
+
+  if (focus) {
+    [[NSApplication sharedApplication] activateIgnoringOtherApps:YES];
+    [window_ makeKeyAndOrderFront:nil];
+  } else {
+    [window_ orderBack:nil];
+  }
+}
+
+bool NativeWindowMac::IsFocused() {
+  return [window_ isKeyWindow];
+}
+
+void NativeWindowMac::Show() {
+  // This method is supposed to put focus on window, however if the app does not
+  // have focus then "makeKeyAndOrderFront" will only show the window.
+  [NSApp activateIgnoringOtherApps:YES];
+
+  [window_ makeKeyAndOrderFront:nil];
+}
+
+void NativeWindowMac::ShowInactive() {
+  [window_ orderFrontRegardless];
+}
+
+void NativeWindowMac::Hide() {
+  [window_ orderOut:nil];
+}
+
+bool NativeWindowMac::IsVisible() {
+  return [window_ isVisible];
+}
+
+void NativeWindowMac::Maximize() {
+  [window_ zoom:nil];
+}
+
+void NativeWindowMac::Unmaximize() {
+  [window_ zoom:nil];
+}
+
+bool NativeWindowMac::IsMaximized() {
+  if (([window_ styleMask] & NSResizableWindowMask) != 0) {
+    return [window_ isZoomed];
+  } else {
+    NSRect rectScreen = [[NSScreen mainScreen] visibleFrame];
+    NSRect rectWindow = [window_ frame];
+    return (rectScreen.origin.x == rectWindow.origin.x &&
+            rectScreen.origin.y == rectWindow.origin.y &&
+            rectScreen.size.width == rectWindow.size.width &&
+            rectScreen.size.height == rectWindow.size.height);
+  }
+}
+
+void NativeWindowMac::Minimize() {
+  [window_ miniaturize:nil];
+}
+
+void NativeWindowMac::Restore() {
+  [window_ deminiaturize:nil];
+}
+
+bool NativeWindowMac::IsMinimized() {
+  return [window_ isMiniaturized];
+}
+
+void NativeWindowMac::SetFullScreen(bool fullscreen) {
+  if (fullscreen == IsFullscreen())
+    return;
+
+  if (!base::mac::IsOSLionOrLater()) {
+    LOG(ERROR) << "Fullscreen mode is only supported above Lion";
+    return;
+  }
+
+  [window_ toggleFullScreen:nil];
+}
+
+bool NativeWindowMac::IsFullscreen() const {
+  return [window_ styleMask] & NSFullScreenWindowMask;
+}
+
+void NativeWindowMac::SetBounds(const gfx::Rect& bounds, bool animate) {
+  NSRect cocoa_bounds = NSMakeRect(bounds.x(), 0,
+                                   bounds.width(),
+                                   bounds.height());
+  // Flip coordinates based on the primary screen.
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  cocoa_bounds.origin.y =
+      NSHeight([screen frame]) - bounds.height() - bounds.y();
+
+  [window_ setFrame:cocoa_bounds display:YES animate:animate];
+}
+
+gfx::Rect NativeWindowMac::GetBounds() {
+  NSRect frame = [window_ frame];
+  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
+  return bounds;
+}
+
+void NativeWindowMac::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  auto convertSize = [this](const gfx::Size& size) {
+    // Our frameless window still has titlebar attached, so setting contentSize
+    // will result in actual content size being larger.
+    if (!has_frame()) {
+      NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
+      NSRect content = [window_ contentRectForFrameRect:frame];
+      return content.size;
+    } else {
+      return NSMakeSize(size.width(), size.height());
+    }
+  };
+
+  NSView* content = [window_ contentView];
+  if (size_constraints.HasMinimumSize()) {
+    NSSize min_size = convertSize(size_constraints.GetMinimumSize());
+    [window_ setContentMinSize:[content convertSize:min_size toView:nil]];
+  }
+  if (size_constraints.HasMaximumSize()) {
+    NSSize max_size = convertSize(size_constraints.GetMaximumSize());
+    [window_ setContentMaxSize:[content convertSize:max_size toView:nil]];
+  }
+  NativeWindow::SetContentSizeConstraints(size_constraints);
+}
+
+void NativeWindowMac::SetResizable(bool resizable) {
+  // Change styleMask for frameless causes the window to change size, so we have
+  // to explicitly disables that.
+  ScopedDisableResize disable_resize;
+  SetStyleMask(resizable, NSResizableWindowMask);
+}
+
+bool NativeWindowMac::IsResizable() {
+  return [window_ styleMask] & NSResizableWindowMask;
+}
+
+void NativeWindowMac::SetMovable(bool movable) {
+  [window_ setMovable:movable];
+}
+
+bool NativeWindowMac::IsMovable() {
+  return [window_ isMovable];
+}
+
+void NativeWindowMac::SetMinimizable(bool minimizable) {
+  SetStyleMask(minimizable, NSMiniaturizableWindowMask);
+}
+
+bool NativeWindowMac::IsMinimizable() {
+  return [window_ styleMask] & NSMiniaturizableWindowMask;
+}
+
+void NativeWindowMac::SetMaximizable(bool maximizable) {
+  [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:maximizable];
+}
+
+bool NativeWindowMac::IsMaximizable() {
+  return [[window_ standardWindowButton:NSWindowZoomButton] isEnabled];
+}
+
+void NativeWindowMac::SetFullScreenable(bool fullscreenable) {
+  SetCollectionBehavior(
+      fullscreenable, NSWindowCollectionBehaviorFullScreenPrimary);
+  // On EL Capitan this flag is required to hide fullscreen button.
+  SetCollectionBehavior(
+      !fullscreenable, NSWindowCollectionBehaviorFullScreenAuxiliary);
+}
+
+bool NativeWindowMac::IsFullScreenable() {
+  NSUInteger collectionBehavior = [window_ collectionBehavior];
+  return collectionBehavior & NSWindowCollectionBehaviorFullScreenPrimary;
+}
+
+void NativeWindowMac::SetClosable(bool closable) {
+  SetStyleMask(closable, NSClosableWindowMask);
+}
+
+bool NativeWindowMac::IsClosable() {
+  return [window_ styleMask] & NSClosableWindowMask;
+}
+
+void NativeWindowMac::SetAlwaysOnTop(bool top) {
+  [window_ setLevel:(top ? NSFloatingWindowLevel : NSNormalWindowLevel)];
+}
+
+bool NativeWindowMac::IsAlwaysOnTop() {
+  return [window_ level] == NSFloatingWindowLevel;
+}
+
+void NativeWindowMac::Center() {
+  [window_ center];
+}
+
+void NativeWindowMac::SetTitle(const std::string& title) {
+  // We don't want the title to show in transparent or frameless window.
+  if (transparent() || !has_frame())
+    return;
+
+  [window_ setTitle:base::SysUTF8ToNSString(title)];
+}
+
+std::string NativeWindowMac::GetTitle() {
+  return base::SysNSStringToUTF8([window_ title]);
+}
+
+void NativeWindowMac::FlashFrame(bool flash) {
+  if (flash) {
+    attention_request_id_ = [NSApp requestUserAttention:NSInformationalRequest];
+  } else {
+    [NSApp cancelUserAttentionRequest:attention_request_id_];
+    attention_request_id_ = 0;
+  }
+}
+
+void NativeWindowMac::SetSkipTaskbar(bool skip) {
+}
+
+void NativeWindowMac::SetKiosk(bool kiosk) {
+  if (kiosk && !is_kiosk_) {
+    kiosk_options_ = [NSApp currentSystemPresentationOptions];
+    NSApplicationPresentationOptions options =
+        NSApplicationPresentationHideDock +
+        NSApplicationPresentationHideMenuBar +
+        NSApplicationPresentationDisableAppleMenu +
+        NSApplicationPresentationDisableProcessSwitching +
+        NSApplicationPresentationDisableForceQuit +
+        NSApplicationPresentationDisableSessionTermination +
+        NSApplicationPresentationDisableHideApplication;
+    [NSApp setPresentationOptions:options];
+    is_kiosk_ = true;
+    SetFullScreen(true);
+  } else if (!kiosk && is_kiosk_) {
+    is_kiosk_ = false;
+    SetFullScreen(false);
+    [NSApp setPresentationOptions:kiosk_options_];
+  }
+}
+
+bool NativeWindowMac::IsKiosk() {
+  return is_kiosk_;
+}
+
+void NativeWindowMac::SetBackgroundColor(const std::string& color_name) {
+  SkColor background_color = NativeWindow::ParseHexColor(color_name);
+  NSColor *color = [NSColor colorWithCalibratedRed:SkColorGetR(background_color)
+    green:SkColorGetG(background_color)
+    blue:SkColorGetB(background_color)
+    alpha:SkColorGetA(background_color)/255.0f];
+  [window_ setBackgroundColor:color];
+}
+
+void NativeWindowMac::SetHasShadow(bool has_shadow) {
+  [window_ setHasShadow:has_shadow];
+}
+
+bool NativeWindowMac::HasShadow() {
+  return [window_ hasShadow];
+}
+
+void NativeWindowMac::SetRepresentedFilename(const std::string& filename) {
+  [window_ setRepresentedFilename:base::SysUTF8ToNSString(filename)];
+}
+
+std::string NativeWindowMac::GetRepresentedFilename() {
+  return base::SysNSStringToUTF8([window_ representedFilename]);
+}
+
+void NativeWindowMac::SetDocumentEdited(bool edited) {
+  [window_ setDocumentEdited:edited];
+}
+
+bool NativeWindowMac::IsDocumentEdited() {
+  return [window_ isDocumentEdited];
+}
+
+void NativeWindowMac::SetIgnoreMouseEvents(bool ignore) {
+  [window_ setIgnoresMouseEvents:ignore];
+}
+
+bool NativeWindowMac::HasModalDialog() {
+  return [window_ attachedSheet] != nil;
+}
+
+gfx::NativeWindow NativeWindowMac::GetNativeWindow() {
+  return window_;
+}
+
+gfx::AcceleratedWidget NativeWindowMac::GetAcceleratedWidget() {
+  return inspectable_web_contents()->GetView()->GetNativeView();
+}
+
+void NativeWindowMac::SetProgressBar(double progress) {
+  NSDockTile* dock_tile = [NSApp dockTile];
+
+  // For the first time API invoked, we need to create a ContentView in DockTile.
+  if (dock_tile.contentView == NULL) {
+    NSImageView* image_view = [[NSImageView alloc] init];
+    [image_view setImage:[NSApp applicationIconImage]];
+    [dock_tile setContentView:image_view];
+
+    NSProgressIndicator* progress_indicator = [[ElectronProgressBar alloc]
+        initWithFrame:NSMakeRect(0.0f, 0.0f, dock_tile.size.width, 15.0)];
+    [progress_indicator setStyle:NSProgressIndicatorBarStyle];
+    [progress_indicator setIndeterminate:NO];
+    [progress_indicator setBezeled:YES];
+    [progress_indicator setMinValue:0];
+    [progress_indicator setMaxValue:1];
+    [progress_indicator setHidden:NO];
+    [image_view addSubview:progress_indicator];
+  }
+
+  NSProgressIndicator* progress_indicator =
+      static_cast<NSProgressIndicator*>([[[dock_tile contentView] subviews]
+           objectAtIndex:0]);
+  if (progress < 0) {
+    [progress_indicator setHidden:YES];
+  } else if (progress > 1) {
+    [progress_indicator setHidden:NO];
+    [progress_indicator setIndeterminate:YES];
+    [progress_indicator setDoubleValue:1];
+  } else {
+    [progress_indicator setHidden:NO];
+    [progress_indicator setDoubleValue:progress];
+  }
+  [dock_tile display];
+}
+
+void NativeWindowMac::SetOverlayIcon(const gfx::Image& overlay,
+                                     const std::string& description) {
+}
+
+void NativeWindowMac::ShowDefinitionForSelection() {
+  if (!web_contents())
+    return;
+  auto rwhv = web_contents()->GetRenderWidgetHostView();
+  if (!rwhv)
+    return;
+  rwhv->ShowDefinitionForSelection();
+}
+
+void NativeWindowMac::SetVisibleOnAllWorkspaces(bool visible) {
+  SetCollectionBehavior(visible, NSWindowCollectionBehaviorCanJoinAllSpaces);
+}
+
+bool NativeWindowMac::IsVisibleOnAllWorkspaces() {
+  NSUInteger collectionBehavior = [window_ collectionBehavior];
+  return collectionBehavior & NSWindowCollectionBehaviorCanJoinAllSpaces;
+}
+
+void NativeWindowMac::HandleKeyboardEvent(
+    content::WebContents*,
+    const content::NativeWebKeyboardEvent& event) {
+  if (event.skip_in_browser ||
+      event.type == content::NativeWebKeyboardEvent::Char)
+    return;
+
+  BOOL handled = [[NSApp mainMenu] performKeyEquivalent:event.os_event];
+  if (!handled && event.os_event.window) {
+    // Handle the cmd+~ shortcut.
+    if ((event.os_event.modifierFlags & NSCommandKeyMask) /* cmd */ &&
+        (event.os_event.keyCode == 50  /* ~ */)) {
+      if (event.os_event.modifierFlags & NSShiftKeyMask) {
+        [NSApp sendAction:@selector(_cycleWindowsReversed:) to:nil from:nil];
+      } else {
+        [NSApp sendAction:@selector(_cycleWindows:) to:nil from:nil];
+      }
+    }
+  }
+}
+
+std::vector<gfx::Rect> NativeWindowMac::CalculateNonDraggableRegions(
+    const std::vector<DraggableRegion>& regions, int width, int height) {
+  std::vector<gfx::Rect> result;
+  if (regions.empty()) {
+    result.push_back(gfx::Rect(0, 0, width, height));
+  } else {
+    scoped_ptr<SkRegion> draggable(DraggableRegionsToSkRegion(regions));
+    scoped_ptr<SkRegion> non_draggable(new SkRegion);
+    non_draggable->op(0, 0, width, height, SkRegion::kUnion_Op);
+    non_draggable->op(*draggable, SkRegion::kDifference_Op);
+    for (SkRegion::Iterator it(*non_draggable); !it.done(); it.next()) {
+      result.push_back(gfx::SkIRectToRect(it.rect()));
+    }
+  }
+  return result;
+}
+
+gfx::Size NativeWindowMac::ContentSizeToWindowSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  NSRect content = NSMakeRect(0, 0, size.width(), size.height());
+  NSRect frame = [window_ frameRectForContentRect:content];
+  return gfx::Size(frame.size);
+}
+
+gfx::Size NativeWindowMac::WindowSizeToContentSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  NSRect frame = NSMakeRect(0, 0, size.width(), size.height());
+  NSRect content = [window_ contentRectForFrameRect:frame];
+  return gfx::Size(content.size);
+}
+
+void NativeWindowMac::UpdateDraggableRegions(
+    const std::vector<DraggableRegion>& regions) {
+  NativeWindow::UpdateDraggableRegions(regions);
+  draggable_regions_ = regions;
+  UpdateDraggableRegionViews(regions);
+}
+
+void NativeWindowMac::InstallView() {
+  // Make sure the bottom corner is rounded: http://crbug.com/396264.
+  [[window_ contentView] setWantsLayer:YES];
+
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  if (has_frame()) {
+    [view setFrame:[[window_ contentView] bounds]];
+    [[window_ contentView] addSubview:view];
+  } else {
+    // In OSX 10.10, adding subviews to the root view for the NSView hierarchy
+    // produces warnings. To eliminate the warnings, we resize the contentView
+    // to fill the window, and add subviews to that.
+    // http://crbug.com/380412
+    content_view_.reset([[FullSizeContentView alloc] init]);
+    [content_view_
+        setAutoresizingMask:NSViewWidthSizable | NSViewHeightSizable];
+    [content_view_ setFrame:[[[window_ contentView] superview] bounds]];
+    [window_ setContentView:content_view_];
+
+    [view setFrame:[content_view_ bounds]];
+    [content_view_ addSubview:view];
+
+    [[window_ standardWindowButton:NSWindowZoomButton] setHidden:YES];
+    [[window_ standardWindowButton:NSWindowMiniaturizeButton] setHidden:YES];
+    [[window_ standardWindowButton:NSWindowCloseButton] setHidden:YES];
+
+    // Some third-party OS X utilities check the zoom button's enabled state to
+    // determine whether to show custom UI on hover, so we disable it here to
+    // prevent them from doing so in a frameless app window.
+    [[window_ standardWindowButton:NSWindowZoomButton] setEnabled:NO];
+  }
+}
+
+void NativeWindowMac::UninstallView() {
+  NSView* view = inspectable_web_contents()->GetView()->GetNativeView();
+  [view removeFromSuperview];
+}
+
+void NativeWindowMac::UpdateDraggableRegionViews(
+    const std::vector<DraggableRegion>& regions) {
+  if (has_frame() && !force_using_draggable_region())
+    return;
+
+  // All ControlRegionViews should be added as children of the WebContentsView,
+  // because WebContentsView will be removed and re-added when entering and
+  // leaving fullscreen mode.
+  NSView* webView = web_contents()->GetNativeView();
+  NSInteger webViewWidth = NSWidth([webView bounds]);
+  NSInteger webViewHeight = NSHeight([webView bounds]);
+
+  [webView setMouseDownCanMoveWindow:YES];
+
+  // Remove all ControlRegionViews that are added last time.
+  // Note that [webView subviews] returns the view's mutable internal array and
+  // it should be copied to avoid mutating the original array while enumerating
+  // it.
+  base::scoped_nsobject<NSArray> subviews([[webView subviews] copy]);
+  for (NSView* subview in subviews.get())
+    if ([subview isKindOfClass:[ControlRegionView class]])
+      [subview removeFromSuperview];
+
+  // Draggable regions is implemented by having the whole web view draggable
+  // (mouseDownCanMoveWindow) and overlaying regions that are not draggable.
+  std::vector<gfx::Rect> system_drag_exclude_areas =
+      CalculateNonDraggableRegions(regions, webViewWidth, webViewHeight);
+
+  // Create and add a ControlRegionView for each region that needs to be
+  // excluded from the dragging.
+  for (std::vector<gfx::Rect>::const_iterator iter =
+           system_drag_exclude_areas.begin();
+       iter != system_drag_exclude_areas.end();
+       ++iter) {
+    base::scoped_nsobject<NSView> controlRegion(
+        [[ControlRegionView alloc] initWithFrame:NSZeroRect]);
+    [controlRegion setFrame:NSMakeRect(iter->x(),
+                                       webViewHeight - iter->bottom(),
+                                       iter->width(),
+                                       iter->height())];
+    [webView addSubview:controlRegion];
+  }
+
+  // AppKit will not update its cache of mouseDownCanMoveWindow unless something
+  // changes. Previously we tried adding an NSView and removing it, but for some
+  // reason it required reposting the mouse-down event, and didn't always work.
+  // Calling the below seems to be an effective solution.
+  [window_ setMovableByWindowBackground:NO];
+  [window_ setMovableByWindowBackground:YES];
+}
+
+void NativeWindowMac::SetStyleMask(bool on, NSUInteger flag) {
+  bool zoom_button_enabled = IsMaximizable();
+  if (on)
+    [window_ setStyleMask:[window_ styleMask] | flag];
+  else
+    [window_ setStyleMask:[window_ styleMask] & (~flag)];
+  // Change style mask will make the zoom button revert to default, probably
+  // a bug of Cocoa or OS X.
+  if (!zoom_button_enabled)
+    SetMaximizable(false);
+}
+
+void NativeWindowMac::SetCollectionBehavior(bool on, NSUInteger flag) {
+  bool zoom_button_enabled = IsMaximizable();
+  if (on)
+    [window_ setCollectionBehavior:[window_ collectionBehavior] | flag];
+  else
+    [window_ setCollectionBehavior:[window_ collectionBehavior] & (~flag)];
+  // Change collectionBehavior will make the zoom button revert to default,
+  // probably a bug of Cocoa or OS X.
+  if (!zoom_button_enabled)
+    SetMaximizable(false);
+}
+
+// static
+NativeWindow* NativeWindow::Create(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options) {
+  return new NativeWindowMac(inspectable_web_contents, options);
+}
+
+}  // namespace electron
added in remote
  their  100644 459872dc07685e449bf394b60772d64761109cf3 electron/browser/native_window_observer.h
@@ -0,0 +1,84 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
+
+#include <string>
+
+#include "base/strings/string16.h"
+#include "ui/base/window_open_disposition.h"
+#include "url/gurl.h"
+
+#if defined(OS_WIN)
+#include <windows.h>
+#endif
+
+namespace electron {
+
+class NativeWindowObserver {
+ public:
+  virtual ~NativeWindowObserver() {}
+
+  // Called when the web page in window wants to create a popup window.
+  virtual void WillCreatePopupWindow(const base::string16& frame_name,
+                                     const GURL& target_url,
+                                     const std::string& partition_id,
+                                     WindowOpenDisposition disposition) {}
+
+  // Called when user is starting an navigation in web page.
+  virtual void WillNavigate(bool* prevent_default, const GURL& url) {}
+
+  // Called when the window is gonna closed.
+  virtual void WillCloseWindow(bool* prevent_default) {}
+
+  // Called when the window is closed.
+  virtual void OnWindowClosed() {}
+
+  // Called when window loses focus.
+  virtual void OnWindowBlur() {}
+
+  // Called when window gains focus.
+  virtual void OnWindowFocus() {}
+
+  // Called when window is shown.
+  virtual void OnWindowShow() {}
+
+  // Called when window is hidden.
+  virtual void OnWindowHide() {}
+
+  // Called when window state changed.
+  virtual void OnWindowMaximize() {}
+  virtual void OnWindowUnmaximize() {}
+  virtual void OnWindowMinimize() {}
+  virtual void OnWindowRestore() {}
+  virtual void OnWindowResize() {}
+  virtual void OnWindowMove() {}
+  virtual void OnWindowMoved() {}
+  virtual void OnWindowScrollTouchBegin() {}
+  virtual void OnWindowScrollTouchEnd() {}
+  virtual void OnWindowSwipe(const std::string& direction) {}
+  virtual void OnWindowEnterFullScreen() {}
+  virtual void OnWindowLeaveFullScreen() {}
+  virtual void OnWindowEnterHtmlFullScreen() {}
+  virtual void OnWindowLeaveHtmlFullScreen() {}
+
+  // Called when window message received
+  #if defined(OS_WIN)
+  virtual void OnWindowMessage(UINT message, WPARAM w_param, LPARAM l_param) {}
+  #endif
+
+  // Called when renderer is hung.
+  virtual void OnRendererUnresponsive() {}
+
+  // Called when renderer recovers.
+  virtual void OnRendererResponsive() {}
+
+  // Called on Windows when App Commands arrive (WM_APPCOMMAND)
+  virtual void OnExecuteWindowsCommand(const std::string& command_name) {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_OBSERVER_H_
added in remote
  their  100644 470c32a21fbe2e1623686c4c17818ed6bbd2a5de electron/browser/native_window_views.cc
@@ -0,0 +1,1030 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_views.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/views/menu_bar.h"
+#include "electron/browser/ui/views/menu_layout.h"
+#include "electron/common/draggable_region.h"
+#include "electron/common/options_switches.h"
+#include "base/strings/utf_string_conversions.h"
+#include "brightray/browser/inspectable_web_contents.h"
+#include "brightray/browser/inspectable_web_contents_view.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "native_mate/dictionary.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/hit_test.h"
+#include "ui/gfx/image/image.h"
+#include "ui/views/background.h"
+#include "ui/views/controls/webview/unhandled_keyboard_event_handler.h"
+#include "ui/views/controls/webview/webview.h"
+#include "ui/views/window/client_view.h"
+#include "ui/views/widget/native_widget_private.h"
+#include "ui/views/widget/widget.h"
+#include "ui/wm/core/shadow_types.h"
+
+#if defined(USE_X11)
+#include "electron/browser/browser.h"
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
+#include "electron/browser/ui/views/frameless_view.h"
+#include "electron/browser/ui/views/native_frame_view.h"
+#include "electron/browser/ui/x/window_state_watcher.h"
+#include "electron/browser/ui/x/x_window_utils.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/ui/libgtk2ui/unity_service.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/gfx/x/x11_types.h"
+#include "ui/views/window/native_frame_view.h"
+#elif defined(OS_WIN)
+#include "electron/browser/ui/views/win_frame_view.h"
+#include "electron/browser/ui/win/electron_desktop_window_tree_host_win.h"
+#include "skia/ext/skia_utils_win.h"
+#include "ui/base/win/shell.h"
+#include "ui/gfx/win/dpi.h"
+#include "ui/views/widget/desktop_aura/desktop_native_widget_aura.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+// The menu bar height in pixels.
+#if defined(OS_WIN)
+const int kMenuBarHeight = 20;
+#else
+const int kMenuBarHeight = 25;
+#endif
+
+#if defined(OS_WIN)
+void FlipWindowStyle(HWND handle, bool on, DWORD flag) {
+  DWORD style = ::GetWindowLong(handle, GWL_STYLE);
+  if (on)
+    style |= flag;
+  else
+    style &= ~flag;
+  ::SetWindowLong(handle, GWL_STYLE, style);
+}
+#endif
+
+bool IsAltKey(const content::NativeWebKeyboardEvent& event) {
+  return event.windowsKeyCode == ui::VKEY_MENU;
+}
+
+bool IsAltModifier(const content::NativeWebKeyboardEvent& event) {
+  typedef content::NativeWebKeyboardEvent::Modifiers Modifiers;
+  int modifiers = event.modifiers;
+  modifiers &= ~Modifiers::NumLockOn;
+  modifiers &= ~Modifiers::CapsLockOn;
+  return (modifiers == Modifiers::AltKey) ||
+         (modifiers == (Modifiers::AltKey | Modifiers::IsLeft)) ||
+         (modifiers == (Modifiers::AltKey | Modifiers::IsRight));
+}
+
+class NativeWindowClientView : public views::ClientView {
+ public:
+  NativeWindowClientView(views::Widget* widget,
+                         NativeWindowViews* contents_view)
+      : views::ClientView(widget, contents_view) {
+  }
+  virtual ~NativeWindowClientView() {}
+
+  bool CanClose() override {
+    static_cast<NativeWindowViews*>(contents_view())->RequestToClosePage();
+    return false;
+  }
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowClientView);
+};
+
+}  // namespace
+
+NativeWindowViews::NativeWindowViews(
+    brightray::InspectableWebContents* web_contents,
+    const mate::Dictionary& options)
+    : NativeWindow(web_contents, options),
+      window_(new views::Widget),
+      web_view_(inspectable_web_contents()->GetView()->GetView()),
+      menu_bar_autohide_(false),
+      menu_bar_visible_(false),
+      menu_bar_alt_pressed_(false),
+      keyboard_event_handler_(new views::UnhandledKeyboardEventHandler),
+      use_content_size_(false),
+      movable_(true),
+      resizable_(true),
+      maximizable_(true),
+      minimizable_(true),
+      fullscreenable_(true) {
+  options.Get(options::kTitle, &title_);
+  options.Get(options::kAutoHideMenuBar, &menu_bar_autohide_);
+
+#if defined(OS_WIN)
+  // On Windows we rely on the CanResize() to indicate whether window can be
+  // resized, and it should be set before window is created.
+  options.Get(options::kResizable, &resizable_);
+  options.Get(options::kMinimizable, &minimizable_);
+  options.Get(options::kMaximizable, &maximizable_);
+#endif
+
+  if (enable_larger_than_screen())
+    // We need to set a default maximum window size here otherwise Windows
+    // will not allow us to resize the window larger than scree.
+    // Setting directly to INT_MAX somehow doesn't work, so we just devide
+    // by 10, which should still be large enough.
+    SetContentSizeConstraints(extensions::SizeConstraints(
+        gfx::Size(), gfx::Size(INT_MAX / 10, INT_MAX / 10)));
+
+  int width = 800, height = 600;
+  options.Get(options::kWidth, &width);
+  options.Get(options::kHeight, &height);
+  gfx::Rect bounds(0, 0, width, height);
+  widget_size_ = bounds.size();
+
+  window_->AddObserver(this);
+
+  views::Widget::InitParams params;
+  params.ownership = views::Widget::InitParams::WIDGET_OWNS_NATIVE_WIDGET;
+  params.bounds = bounds;
+  params.delegate = this;
+  params.type = views::Widget::InitParams::TYPE_WINDOW;
+  params.remove_standard_frame = !has_frame();
+
+  if (transparent())
+    params.opacity = views::Widget::InitParams::TRANSLUCENT_WINDOW;
+
+  // The given window is most likely not rectangular since it uses
+  // transparency and has no standard frame, don't show a shadow for it.
+  if (transparent() && !has_frame())
+    params.shadow_type = views::Widget::InitParams::SHADOW_TYPE_NONE;
+
+#if defined(OS_WIN)
+  params.native_widget =
+      new views::DesktopNativeWidgetAura(window_.get());
+  electron_desktop_window_tree_host_win_ = new ElectronDesktopWindowTreeHostWin(
+      this,
+      window_.get(),
+      static_cast<views::DesktopNativeWidgetAura*>(params.native_widget));
+  params.desktop_window_tree_host = electron_desktop_window_tree_host_win_;
+#elif defined(USE_X11)
+  std::string name = Browser::Get()->GetName();
+  // Set WM_WINDOW_ROLE.
+  params.wm_role_name = "browser-window";
+  // Set WM_CLASS.
+  params.wm_class_name = base::ToLowerASCII(name);
+  params.wm_class_class = name;
+#endif
+
+  window_->Init(params);
+
+  bool fullscreen = false;
+  options.Get(options::kFullscreen, &fullscreen);
+
+#if defined(USE_X11)
+  // Start monitoring window states.
+  window_state_watcher_.reset(new WindowStateWatcher(this));
+
+  // Set _GTK_THEME_VARIANT to dark if we have "dark-theme" option set.
+  bool use_dark_theme = false;
+  if (options.Get(options::kDarkTheme, &use_dark_theme) && use_dark_theme) {
+    XDisplay* xdisplay = gfx::GetXDisplay();
+    XChangeProperty(xdisplay, GetAcceleratedWidget(),
+                    XInternAtom(xdisplay, "_GTK_THEME_VARIANT", False),
+                    XInternAtom(xdisplay, "UTF8_STRING", False),
+                    8, PropModeReplace,
+                    reinterpret_cast<const unsigned char*>("dark"),
+                    4);
+  }
+
+  // Before the window is mapped the SetWMSpecState can not work, so we have
+  // to manually set the _NET_WM_STATE.
+  std::vector<::Atom> state_electron_list;
+  bool skip_taskbar = false;
+  if (options.Get(options::kSkipTaskbar, &skip_taskbar) && skip_taskbar) {
+    state_electron_list.push_back(GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
+  }
+
+  // Before the window is mapped, there is no SHOW_FULLSCREEN_STATE.
+  if (fullscreen) {
+    state_electron_list.push_back(GetAtom("_NET_WM_STATE_FULLSCREEN"));
+  }
+
+  ui::SetElectronArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", "ATOM",
+                           state_electron_list);
+
+  // Set the _NET_WM_WINDOW_TYPE.
+  std::string window_type;
+  if (options.Get(options::kType, &window_type))
+    SetWindowType(GetAcceleratedWidget(), window_type);
+#endif
+
+  // Add web view.
+  SetLayoutManager(new MenuLayout(this, kMenuBarHeight));
+
+  AddChildView(web_view_);
+
+#if defined(OS_WIN)
+  // Save initial window state.
+  if (fullscreen)
+    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+  else
+    last_window_state_ = ui::SHOW_STATE_NORMAL;
+  last_normal_size_ = gfx::Size(widget_size_);
+
+  if (!has_frame()) {
+    // Set Window style so that we get a minimize and maximize animation when
+    // frameless.
+    DWORD frame_style = WS_CAPTION;
+    if (resizable_)
+      frame_style |= WS_THICKFRAME;
+    if (minimizable_)
+      frame_style |= WS_MINIMIZEBOX;
+    if (maximizable_)
+      frame_style |= WS_MAXIMIZEBOX;
+    // We should not show a frame for transparent window.
+    if (transparent())
+      frame_style &= ~(WS_THICKFRAME | WS_CAPTION);
+    ::SetWindowLong(GetAcceleratedWidget(), GWL_STYLE, frame_style);
+  }
+
+  if (transparent()) {
+    // Transparent window on Windows has to have WS_EX_COMPOSITED style.
+    LONG ex_style = ::GetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE);
+    ex_style |= WS_EX_COMPOSITED;
+    ::SetWindowLong(GetAcceleratedWidget(), GWL_EXSTYLE, ex_style);
+  }
+#endif
+
+  // TODO(zcbenz): This was used to force using native frame on Windows 2003, we
+  // should check whether setting it in InitParams can work.
+  if (has_frame()) {
+    window_->set_frame_type(views::Widget::FrameType::FRAME_TYPE_FORCE_NATIVE);
+    window_->FrameTypeChanged();
+  }
+
+  gfx::Size size = bounds.size();
+  if (has_frame() &&
+      options.Get(options::kUseContentSize, &use_content_size_) &&
+      use_content_size_)
+    size = ContentSizeToWindowSize(size);
+
+  window_->UpdateWindowIcon();
+  window_->CenterWindow(size);
+  Layout();
+}
+
+NativeWindowViews::~NativeWindowViews() {
+  window_->RemoveObserver(this);
+}
+
+void NativeWindowViews::Close() {
+  window_->Close();
+}
+
+void NativeWindowViews::CloseImmediately() {
+  window_->CloseNow();
+}
+
+void NativeWindowViews::Focus(bool focus) {
+  if (focus)
+    window_->Activate();
+  else
+    window_->Deactivate();
+}
+
+bool NativeWindowViews::IsFocused() {
+  return window_->IsActive();
+}
+
+void NativeWindowViews::Show() {
+  window_->native_widget_private()->ShowWithWindowState(GetRestoredState());
+
+  NotifyWindowShow();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowMapped();
+#endif
+}
+
+void NativeWindowViews::ShowInactive() {
+  window_->ShowInactive();
+
+  NotifyWindowShow();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowMapped();
+#endif
+}
+
+void NativeWindowViews::Hide() {
+  window_->Hide();
+
+  NotifyWindowHide();
+
+#if defined(USE_X11)
+  if (global_menu_bar_)
+    global_menu_bar_->OnWindowUnmapped();
+#endif
+}
+
+bool NativeWindowViews::IsVisible() {
+  return window_->IsVisible();
+}
+
+void NativeWindowViews::Maximize() {
+  if (IsVisible())
+    window_->Maximize();
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_MAXIMIZED);
+}
+
+void NativeWindowViews::Unmaximize() {
+  window_->Restore();
+}
+
+bool NativeWindowViews::IsMaximized() {
+  return window_->IsMaximized();
+}
+
+void NativeWindowViews::Minimize() {
+  if (IsVisible())
+    window_->Minimize();
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_MINIMIZED);
+}
+
+void NativeWindowViews::Restore() {
+  window_->Restore();
+}
+
+bool NativeWindowViews::IsMinimized() {
+  return window_->IsMinimized();
+}
+
+void NativeWindowViews::SetFullScreen(bool fullscreen) {
+  if (!IsFullScreenable())
+    return;
+
+#if defined(OS_WIN)
+  // There is no native fullscreen state on Windows.
+  if (fullscreen) {
+    last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+    NotifyWindowEnterFullScreen();
+  } else {
+    last_window_state_ = ui::SHOW_STATE_NORMAL;
+    NotifyWindowLeaveFullScreen();
+  }
+  // We set the new value after notifying, so we can handle the size event
+  // correctly.
+  window_->SetFullscreen(fullscreen);
+#else
+  if (IsVisible())
+    window_->SetFullscreen(fullscreen);
+  else
+    window_->native_widget_private()->ShowWithWindowState(
+        ui::SHOW_STATE_FULLSCREEN);
+#endif
+}
+
+bool NativeWindowViews::IsFullscreen() const {
+  return window_->IsFullscreen();
+}
+
+void NativeWindowViews::SetBounds(const gfx::Rect& bounds,
+    bool animate = false) {
+#if defined(USE_X11)
+  // On Linux the minimum and maximum size should be updated with window size
+  // when window is not resizable.
+  if (!resizable_) {
+    SetMaximumSize(bounds.size());
+    SetMinimumSize(bounds.size());
+  }
+#endif
+
+  window_->SetBounds(bounds);
+}
+
+gfx::Rect NativeWindowViews::GetBounds() {
+#if defined(OS_WIN)
+  if (IsMinimized())
+    return window_->GetRestoredBounds();
+#endif
+
+  return window_->GetWindowBoundsInScreen();
+}
+
+gfx::Size NativeWindowViews::GetContentSize() {
+#if defined(OS_WIN)
+  if (IsMinimized())
+    return NativeWindow::GetContentSize();
+#endif
+
+  return web_view_->size();
+}
+
+void NativeWindowViews::SetContentSizeConstraints(
+    const extensions::SizeConstraints& size_constraints) {
+  NativeWindow::SetContentSizeConstraints(size_constraints);
+  // widget_delegate() is only available after Init() is called, we make use of
+  // this to determine whether native widget has initialized.
+  if (window_ && window_->widget_delegate())
+    window_->OnSizeConstraintsChanged();
+#if defined(USE_X11)
+  if (resizable_)
+    old_size_constraints_ = size_constraints;
+#endif
+}
+
+void NativeWindowViews::SetResizable(bool resizable) {
+#if defined(OS_WIN)
+  if (!transparent())
+    FlipWindowStyle(GetAcceleratedWidget(), resizable, WS_THICKFRAME);
+#elif defined(USE_X11)
+  if (resizable != resizable_) {
+    // On Linux there is no "resizable" property of a window, we have to set
+    // both the minimum and maximum size to the window size to achieve it.
+    if (resizable) {
+      SetContentSizeConstraints(old_size_constraints_);
+    } else {
+      old_size_constraints_ = GetContentSizeConstraints();
+      resizable_ = false;
+      gfx::Size content_size = GetContentSize();
+      SetContentSizeConstraints(
+          extensions::SizeConstraints(content_size, content_size));
+    }
+  }
+#endif
+
+  resizable_ = resizable;
+}
+
+bool NativeWindowViews::IsResizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_THICKFRAME;
+#else
+  return CanResize();
+#endif
+}
+
+void NativeWindowViews::SetMovable(bool movable) {
+  movable_ = movable;
+}
+
+bool NativeWindowViews::IsMovable() {
+#if defined(OS_WIN)
+  return movable_;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetMinimizable(bool minimizable) {
+#if defined(OS_WIN)
+  FlipWindowStyle(GetAcceleratedWidget(), minimizable, WS_MINIMIZEBOX);
+#endif
+  minimizable_ = minimizable;
+}
+
+bool NativeWindowViews::IsMinimizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MINIMIZEBOX;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetMaximizable(bool maximizable) {
+#if defined(OS_WIN)
+  FlipWindowStyle(GetAcceleratedWidget(), maximizable, WS_MAXIMIZEBOX);
+#endif
+  maximizable_ = maximizable;
+}
+
+bool NativeWindowViews::IsMaximizable() {
+#if defined(OS_WIN)
+  return ::GetWindowLong(GetAcceleratedWidget(), GWL_STYLE) & WS_MAXIMIZEBOX;
+#else
+  return true;  // Not implemented on Linux.
+#endif
+}
+
+void NativeWindowViews::SetFullScreenable(bool fullscreenable) {
+  fullscreenable_ = fullscreenable;
+}
+
+bool NativeWindowViews::IsFullScreenable() {
+  return fullscreenable_;
+}
+
+void NativeWindowViews::SetClosable(bool closable) {
+#if defined(OS_WIN)
+  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
+  if (closable) {
+    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_ENABLED);
+  } else {
+    EnableMenuItem(menu, SC_CLOSE, MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);
+  }
+#endif
+}
+
+bool NativeWindowViews::IsClosable() {
+#if defined(OS_WIN)
+  HMENU menu = GetSystemMenu(GetAcceleratedWidget(), false);
+  MENUITEMINFO info;
+  memset(&info, 0, sizeof(info));
+  info.cbSize = sizeof(info);
+  info.fMask = MIIM_STATE;
+  if (!GetMenuItemInfo(menu, SC_CLOSE, false, &info)) {
+    return false;
+  }
+  return !(info.fState & MFS_DISABLED);
+#elif defined(USE_X11)
+  return true;
+#endif
+}
+
+void NativeWindowViews::SetAlwaysOnTop(bool top) {
+  window_->SetAlwaysOnTop(top);
+}
+
+bool NativeWindowViews::IsAlwaysOnTop() {
+  return window_->IsAlwaysOnTop();
+}
+
+void NativeWindowViews::Center() {
+  window_->CenterWindow(GetSize());
+}
+
+void NativeWindowViews::SetTitle(const std::string& title) {
+  title_ = title;
+  window_->UpdateWindowTitle();
+}
+
+std::string NativeWindowViews::GetTitle() {
+  return title_;
+}
+
+void NativeWindowViews::FlashFrame(bool flash) {
+#if defined(OS_WIN)
+  // The Chromium's implementation has a bug stopping flash.
+  if (!flash) {
+    FLASHWINFO fwi;
+    fwi.cbSize = sizeof(fwi);
+    fwi.hwnd = GetAcceleratedWidget();
+    fwi.dwFlags = FLASHW_STOP;
+    fwi.uCount = 0;
+    FlashWindowEx(&fwi);
+    return;
+  }
+#endif
+  window_->FlashFrame(flash);
+}
+
+void NativeWindowViews::SetSkipTaskbar(bool skip) {
+#if defined(OS_WIN)
+  base::win::ScopedComPtr<ITaskbarList> taskbar;
+  if (FAILED(taskbar.CreateInstance(CLSID_TaskbarList, NULL,
+                                    CLSCTX_INPROC_SERVER)) ||
+      FAILED(taskbar->HrInit()))
+    return;
+  if (skip)
+    taskbar->DeleteTab(GetAcceleratedWidget());
+  else
+    taskbar->AddTab(GetAcceleratedWidget());
+#elif defined(USE_X11)
+  SetWMSpecState(GetAcceleratedWidget(), skip,
+                 GetAtom("_NET_WM_STATE_SKIP_TASKBAR"));
+#endif
+}
+
+void NativeWindowViews::SetKiosk(bool kiosk) {
+  SetFullScreen(kiosk);
+}
+
+bool NativeWindowViews::IsKiosk() {
+  return IsFullscreen();
+}
+
+void NativeWindowViews::SetBackgroundColor(const std::string& color_name) {
+  // web views' background color.
+  SkColor background_color = NativeWindow::ParseHexColor(color_name);
+  set_background(views::Background::CreateSolidBackground(background_color));
+
+#if defined(OS_WIN)
+  // Set the background color of native window.
+  HBRUSH brush = CreateSolidBrush(skia::SkColorToCOLORREF(background_color));
+  ULONG_PTR previous_brush = SetClassLongPtr(
+      GetAcceleratedWidget(), GCLP_HBRBACKGROUND, (LONG)brush);
+  if (previous_brush)
+    DeleteObject((HBRUSH)previous_brush);
+#endif
+}
+
+void NativeWindowViews::SetHasShadow(bool has_shadow) {
+  wm::SetShadowType(
+      GetNativeWindow(),
+      has_shadow ? wm::SHADOW_TYPE_RECTANGULAR : wm::SHADOW_TYPE_NONE);
+}
+
+bool NativeWindowViews::HasShadow() {
+  return wm::GetShadowType(GetNativeWindow()) != wm::SHADOW_TYPE_NONE;
+}
+
+void NativeWindowViews::SetMenu(ui::MenuModel* menu_model) {
+  if (menu_model == nullptr) {
+    // Remove accelerators
+    accelerator_table_.clear();
+    GetFocusManager()->UnregisterAccelerators(this);
+    // and menu bar.
+#if defined(USE_X11)
+    global_menu_bar_.reset();
+#endif
+    SetMenuBarVisibility(false);
+    menu_bar_.reset();
+    return;
+  }
+
+  RegisterAccelerators(menu_model);
+
+#if defined(USE_X11)
+  if (!global_menu_bar_ && ShouldUseGlobalMenuBar())
+    global_menu_bar_.reset(new GlobalMenuBarX11(this));
+
+  // Use global application menu bar when possible.
+  if (global_menu_bar_ && global_menu_bar_->IsServerStarted()) {
+    global_menu_bar_->SetMenu(menu_model);
+    return;
+  }
+#endif
+
+  // Do not show menu bar in frameless window.
+  if (!has_frame())
+    return;
+
+  if (!menu_bar_) {
+    gfx::Size content_size = GetContentSize();
+    menu_bar_.reset(new MenuBar);
+    menu_bar_->set_owned_by_client();
+
+    if (!menu_bar_autohide_) {
+      SetMenuBarVisibility(true);
+      if (use_content_size_) {
+        // Enlarge the size constraints for the menu.
+        extensions::SizeConstraints constraints = GetContentSizeConstraints();
+        if (constraints.HasMinimumSize()) {
+          gfx::Size min_size = constraints.GetMinimumSize();
+          min_size.set_height(min_size.height() + kMenuBarHeight);
+          constraints.set_minimum_size(min_size);
+        }
+        if (constraints.HasMaximumSize()) {
+          gfx::Size max_size = constraints.GetMaximumSize();
+          max_size.set_height(max_size.height() + kMenuBarHeight);
+          constraints.set_maximum_size(max_size);
+        }
+        SetContentSizeConstraints(constraints);
+
+        // Resize the window to make sure content size is not changed.
+        SetContentSize(content_size);
+      }
+    }
+  }
+
+  menu_bar_->SetMenu(menu_model);
+  Layout();
+}
+
+gfx::NativeWindow NativeWindowViews::GetNativeWindow() {
+  return window_->GetNativeWindow();
+}
+
+void NativeWindowViews::SetProgressBar(double progress) {
+#if defined(OS_WIN)
+  taskbar_host_.SetProgressBar(GetAcceleratedWidget(), progress);
+#elif defined(USE_X11)
+  if (unity::IsRunning()) {
+    unity::SetProgressFraction(progress);
+  }
+#endif
+}
+
+void NativeWindowViews::SetOverlayIcon(const gfx::Image& overlay,
+                                       const std::string& description) {
+#if defined(OS_WIN)
+  taskbar_host_.SetOverlayIcon(GetAcceleratedWidget(), overlay, description);
+#endif
+}
+
+void NativeWindowViews::SetAutoHideMenuBar(bool auto_hide) {
+  menu_bar_autohide_ = auto_hide;
+}
+
+bool NativeWindowViews::IsMenuBarAutoHide() {
+  return menu_bar_autohide_;
+}
+
+void NativeWindowViews::SetMenuBarVisibility(bool visible) {
+  if (!menu_bar_ || menu_bar_visible_ == visible)
+    return;
+
+  // Always show the accelerator when the auto-hide menu bar shows.
+  if (menu_bar_autohide_)
+    menu_bar_->SetAcceleratorVisibility(visible);
+
+  menu_bar_visible_ = visible;
+  if (visible) {
+    DCHECK_EQ(child_count(), 1);
+    AddChildView(menu_bar_.get());
+  } else {
+    DCHECK_EQ(child_count(), 2);
+    RemoveChildView(menu_bar_.get());
+  }
+
+  Layout();
+}
+
+bool NativeWindowViews::IsMenuBarVisible() {
+  return menu_bar_visible_;
+}
+
+void NativeWindowViews::SetVisibleOnAllWorkspaces(bool visible) {
+  window_->SetVisibleOnAllWorkspaces(visible);
+}
+
+bool NativeWindowViews::IsVisibleOnAllWorkspaces() {
+#if defined(USE_X11)
+  // Use the presence/absence of _NET_WM_STATE_STICKY in _NET_WM_STATE to
+  // determine whether the current window is visible on all workspaces.
+  XAtom sticky_atom = GetAtom("_NET_WM_STATE_STICKY");
+  std::vector<XAtom> wm_states;
+  ui::GetElectronArrayProperty(GetAcceleratedWidget(), "_NET_WM_STATE", &wm_states);
+  return std::find(wm_states.begin(),
+                   wm_states.end(), sticky_atom) != wm_states.end();
+#endif
+  return false;
+}
+
+gfx::AcceleratedWidget NativeWindowViews::GetAcceleratedWidget() {
+  return GetNativeWindow()->GetHost()->GetAcceleratedWidget();
+}
+
+void NativeWindowViews::OnWidgetActivationChanged(
+    views::Widget* widget, bool active) {
+  if (widget != window_.get())
+    return;
+
+  if (active)
+    NotifyWindowFocus();
+  else
+    NotifyWindowBlur();
+
+  if (active && inspectable_web_contents() &&
+      !inspectable_web_contents()->IsDevToolsViewShowing())
+    web_contents()->Focus();
+
+  // Hide menu bar when window is blured.
+  if (!active && menu_bar_autohide_ && menu_bar_visible_)
+    SetMenuBarVisibility(false);
+}
+
+void NativeWindowViews::OnWidgetBoundsChanged(
+    views::Widget* widget, const gfx::Rect& bounds) {
+  if (widget != window_.get())
+    return;
+
+  if (widget_size_ != bounds.size()) {
+    NotifyWindowResize();
+    widget_size_ = bounds.size();
+  }
+}
+
+void NativeWindowViews::DeleteDelegate() {
+  NotifyWindowClosed();
+}
+
+views::View* NativeWindowViews::GetInitiallyFocusedView() {
+  return inspectable_web_contents()->GetView()->GetWebView();
+}
+
+bool NativeWindowViews::CanResize() const {
+  return resizable_;
+}
+
+bool NativeWindowViews::CanMaximize() const {
+  return resizable_ && maximizable_;
+}
+
+bool NativeWindowViews::CanMinimize() const {
+#if defined(OS_WIN)
+  return minimizable_;
+#elif defined(USE_X11)
+  return true;
+#endif
+}
+
+base::string16 NativeWindowViews::GetWindowTitle() const {
+  return base::UTF8ToUTF16(title_);
+}
+
+bool NativeWindowViews::ShouldHandleSystemCommands() const {
+  return true;
+}
+
+gfx::ImageSkia NativeWindowViews::GetWindowAppIcon() {
+  return icon();
+}
+
+gfx::ImageSkia NativeWindowViews::GetWindowIcon() {
+  return GetWindowAppIcon();
+}
+
+views::Widget* NativeWindowViews::GetWidget() {
+  return window_.get();
+}
+
+const views::Widget* NativeWindowViews::GetWidget() const {
+  return window_.get();
+}
+
+views::View* NativeWindowViews::GetContentsView() {
+  return this;
+}
+
+bool NativeWindowViews::ShouldDescendIntoChildForEventHandling(
+    gfx::NativeView child,
+    const gfx::Point& location) {
+  // App window should claim mouse events that fall within the draggable region.
+  if (draggable_region() &&
+      draggable_region()->contains(location.x(), location.y()))
+    return false;
+
+  // And the events on border for dragging resizable frameless window.
+  if (!has_frame() && CanResize()) {
+    FramelessView* frame = static_cast<FramelessView*>(
+        window_->non_client_view()->frame_view());
+    return frame->ResizingBorderHitTest(location) == HTNOWHERE;
+  }
+
+  return true;
+}
+
+views::ClientView* NativeWindowViews::CreateClientView(views::Widget* widget) {
+  return new NativeWindowClientView(widget, this);
+}
+
+views::NonClientFrameView* NativeWindowViews::CreateNonClientFrameView(
+    views::Widget* widget) {
+#if defined(OS_WIN)
+  WinFrameView* frame_view = new WinFrameView;
+  frame_view->Init(this, widget);
+  return frame_view;
+#else
+  if (has_frame()) {
+    return new NativeFrameView(this, widget);
+  } else {
+    FramelessView* frame_view = new FramelessView;
+    frame_view->Init(this, widget);
+    return frame_view;
+  }
+#endif
+}
+
+void NativeWindowViews::OnWidgetMove() {
+  NotifyWindowMove();
+}
+
+gfx::Size NativeWindowViews::ContentSizeToWindowSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  gfx::Size window_size(size);
+#if defined(OS_WIN)
+  gfx::Rect dpi_bounds =
+      gfx::Rect(gfx::Point(), gfx::win::DIPToScreenSize(size));
+  gfx::Rect window_bounds = gfx::win::ScreenToDIPRect(
+      window_->non_client_view()->GetWindowBoundsForClientBounds(dpi_bounds));
+  window_size = window_bounds.size();
+#endif
+
+  if (menu_bar_ && menu_bar_visible_)
+    window_size.set_height(window_size.height() + kMenuBarHeight);
+  return window_size;
+}
+
+gfx::Size NativeWindowViews::WindowSizeToContentSize(const gfx::Size& size) {
+  if (!has_frame())
+    return size;
+
+  gfx::Size content_size(size);
+#if defined(OS_WIN)
+  content_size = gfx::win::DIPToScreenSize(content_size);
+  RECT rect;
+  SetRectEmpty(&rect);
+  HWND hwnd = GetAcceleratedWidget();
+  DWORD style = ::GetWindowLong(hwnd, GWL_STYLE);
+  DWORD ex_style = ::GetWindowLong(hwnd, GWL_EXSTYLE);
+  AdjustWindowRectEx(&rect, style, FALSE, ex_style);
+  content_size.set_width(content_size.width() - (rect.right - rect.left));
+  content_size.set_height(content_size.height() - (rect.bottom - rect.top));
+  content_size = gfx::win::ScreenToDIPSize(content_size);
+#endif
+
+  if (menu_bar_ && menu_bar_visible_)
+    content_size.set_height(content_size.height() - kMenuBarHeight);
+  return content_size;
+}
+
+void NativeWindowViews::HandleKeyboardEvent(
+    content::WebContents*,
+    const content::NativeWebKeyboardEvent& event) {
+  keyboard_event_handler_->HandleKeyboardEvent(event, GetFocusManager());
+
+  if (!menu_bar_)
+    return;
+
+  // Show accelerator when "Alt" is pressed.
+  if (menu_bar_visible_ && IsAltKey(event))
+    menu_bar_->SetAcceleratorVisibility(
+        event.type == blink::WebInputEvent::RawKeyDown);
+
+  // Show the submenu when "Alt+Key" is pressed.
+  if (event.type == blink::WebInputEvent::RawKeyDown && !IsAltKey(event) &&
+      IsAltModifier(event)) {
+    if (!menu_bar_visible_ &&
+        (menu_bar_->GetAcceleratorIndex(event.windowsKeyCode) != -1))
+      SetMenuBarVisibility(true);
+    menu_bar_->ActivateAccelerator(event.windowsKeyCode);
+    return;
+  }
+
+  if (!menu_bar_autohide_)
+    return;
+
+  // Toggle the menu bar only when a single Alt is released.
+  if (event.type == blink::WebInputEvent::RawKeyDown && IsAltKey(event)) {
+    // When a single Alt is pressed:
+    menu_bar_alt_pressed_ = true;
+  } else if (event.type == blink::WebInputEvent::KeyUp && IsAltKey(event) &&
+             menu_bar_alt_pressed_) {
+    // When a single Alt is released right after a Alt is pressed:
+    menu_bar_alt_pressed_ = false;
+    SetMenuBarVisibility(!menu_bar_visible_);
+  } else {
+    // When any other keys except single Alt have been pressed/released:
+    menu_bar_alt_pressed_ = false;
+  }
+}
+
+gfx::Size NativeWindowViews::GetMinimumSize() {
+  return NativeWindow::GetMinimumSize();
+}
+
+gfx::Size NativeWindowViews::GetMaximumSize() {
+  return NativeWindow::GetMaximumSize();
+}
+
+bool NativeWindowViews::AcceleratorPressed(const ui::Accelerator& accelerator) {
+  return accelerator_util::TriggerAcceleratorTableCommand(
+      &accelerator_table_, accelerator);
+}
+
+void NativeWindowViews::RegisterAccelerators(ui::MenuModel* menu_model) {
+  // Clear previous accelerators.
+  views::FocusManager* focus_manager = GetFocusManager();
+  accelerator_table_.clear();
+  focus_manager->UnregisterAccelerators(this);
+
+  // Register accelerators with focus manager.
+  accelerator_util::GenerateAcceleratorTable(&accelerator_table_, menu_model);
+  accelerator_util::AcceleratorTable::const_iterator iter;
+  for (iter = accelerator_table_.begin();
+       iter != accelerator_table_.end();
+       ++iter) {
+    focus_manager->RegisterAccelerator(
+        iter->first, ui::AcceleratorManager::kNormalPriority, this);
+  }
+}
+
+ui::WindowShowState NativeWindowViews::GetRestoredState() {
+  if (IsMaximized())
+    return ui::SHOW_STATE_MAXIMIZED;
+  if (IsFullscreen())
+    return ui::SHOW_STATE_FULLSCREEN;
+
+  return ui::SHOW_STATE_NORMAL;
+}
+
+// static
+NativeWindow* NativeWindow::Create(
+    brightray::InspectableWebContents* inspectable_web_contents,
+    const mate::Dictionary& options) {
+  return new NativeWindowViews(inspectable_web_contents, options);
+}
+
+}  // namespace electron
added in remote
  their  100644 1412c047227d6fae7bba45289031615e3d76718c electron/browser/native_window_views.h
@@ -0,0 +1,224 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
+#define ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
+
+#include "electron/browser/native_window.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/accelerator_util.h"
+#include "ui/views/widget/widget_delegate.h"
+#include "ui/views/widget/widget_observer.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/ui/win/message_handler_delegate.h"
+#include "electron/browser/ui/win/taskbar_host.h"
+#endif
+
+namespace views {
+class UnhandledKeyboardEventHandler;
+}
+
+namespace electron {
+
+class GlobalMenuBarX11;
+class MenuBar;
+class WindowStateWatcher;
+
+#if defined(OS_WIN)
+class ElectronDesktopWindowTreeHostWin;
+#endif
+
+class NativeWindowViews : public NativeWindow,
+#if defined(OS_WIN)
+                          public MessageHandlerDelegate,
+#endif
+                          public views::WidgetDelegateView,
+                          public views::WidgetObserver {
+ public:
+  NativeWindowViews(brightray::InspectableWebContents* inspectable_web_contents,
+                    const mate::Dictionary& options);
+  ~NativeWindowViews() override;
+
+  // NativeWindow:
+  void Close() override;
+  void CloseImmediately() override;
+  void Focus(bool focus) override;
+  bool IsFocused() override;
+  void Show() override;
+  void ShowInactive() override;
+  void Hide() override;
+  bool IsVisible() override;
+  void Maximize() override;
+  void Unmaximize() override;
+  bool IsMaximized() override;
+  void Minimize() override;
+  void Restore() override;
+  bool IsMinimized() override;
+  void SetFullScreen(bool fullscreen) override;
+  bool IsFullscreen() const override;
+  void SetBounds(const gfx::Rect& bounds, bool animate) override;
+  gfx::Rect GetBounds() override;
+  gfx::Size GetContentSize() override;
+  void SetContentSizeConstraints(
+      const extensions::SizeConstraints& size_constraints) override;
+  void SetResizable(bool resizable) override;
+  bool IsResizable() override;
+  void SetMovable(bool movable) override;
+  bool IsMovable() override;
+  void SetMinimizable(bool minimizable) override;
+  bool IsMinimizable() override;
+  void SetMaximizable(bool maximizable) override;
+  bool IsMaximizable() override;
+  void SetFullScreenable(bool fullscreenable) override;
+  bool IsFullScreenable() override;
+  void SetClosable(bool closable) override;
+  bool IsClosable() override;
+  void SetAlwaysOnTop(bool top) override;
+  bool IsAlwaysOnTop() override;
+  void Center() override;
+  void SetTitle(const std::string& title) override;
+  std::string GetTitle() override;
+  void FlashFrame(bool flash) override;
+  void SetSkipTaskbar(bool skip) override;
+  void SetKiosk(bool kiosk) override;
+  bool IsKiosk() override;
+  void SetBackgroundColor(const std::string& color_name) override;
+  void SetHasShadow(bool has_shadow) override;
+  bool HasShadow() override;
+  void SetMenu(ui::MenuModel* menu_model) override;
+  gfx::NativeWindow GetNativeWindow() override;
+  void SetOverlayIcon(const gfx::Image& overlay,
+                      const std::string& description) override;
+  void SetProgressBar(double value) override;
+  void SetAutoHideMenuBar(bool auto_hide) override;
+  bool IsMenuBarAutoHide() override;
+  void SetMenuBarVisibility(bool visible) override;
+  bool IsMenuBarVisible() override;
+  void SetVisibleOnAllWorkspaces(bool visible) override;
+  bool IsVisibleOnAllWorkspaces() override;
+
+  gfx::AcceleratedWidget GetAcceleratedWidget() override;
+
+  views::Widget* widget() const { return window_.get(); }
+
+#if defined(OS_WIN)
+  TaskbarHost& taskbar_host() { return taskbar_host_; }
+#endif
+
+ private:
+  // views::WidgetObserver:
+  void OnWidgetActivationChanged(
+      views::Widget* widget, bool active) override;
+  void OnWidgetBoundsChanged(
+      views::Widget* widget, const gfx::Rect& bounds) override;
+
+  // views::WidgetDelegate:
+  void DeleteDelegate() override;
+  views::View* GetInitiallyFocusedView() override;
+  bool CanResize() const override;
+  bool CanMaximize() const override;
+  bool CanMinimize() const override;
+  base::string16 GetWindowTitle() const override;
+  bool ShouldHandleSystemCommands() const override;
+  gfx::ImageSkia GetWindowAppIcon() override;
+  gfx::ImageSkia GetWindowIcon() override;
+  views::Widget* GetWidget() override;
+  const views::Widget* GetWidget() const override;
+  views::View* GetContentsView() override;
+  bool ShouldDescendIntoChildForEventHandling(
+     gfx::NativeView child,
+     const gfx::Point& location) override;
+  views::ClientView* CreateClientView(views::Widget* widget) override;
+  views::NonClientFrameView* CreateNonClientFrameView(
+      views::Widget* widget) override;
+  void OnWidgetMove() override;
+#if defined(OS_WIN)
+  bool ExecuteWindowsCommand(int command_id) override;
+#endif
+
+#if defined(OS_WIN)
+  // MessageHandlerDelegate:
+  bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) override;
+
+  void HandleSizeEvent(WPARAM w_param, LPARAM l_param);
+#endif
+
+  // NativeWindow:
+  gfx::Size ContentSizeToWindowSize(const gfx::Size& size) override;
+  gfx::Size WindowSizeToContentSize(const gfx::Size& size) override;
+  void HandleKeyboardEvent(
+      content::WebContents*,
+      const content::NativeWebKeyboardEvent& event) override;
+
+  // views::View:
+  gfx::Size GetMinimumSize() override;
+  gfx::Size GetMaximumSize() override;
+  bool AcceleratorPressed(const ui::Accelerator& accelerator) override;
+
+  // Register accelerators supported by the menu model.
+  void RegisterAccelerators(ui::MenuModel* menu_model);
+
+  // Returns the restore state for the window.
+  ui::WindowShowState GetRestoredState();
+
+  scoped_ptr<views::Widget> window_;
+  views::View* web_view_;  // Managed by inspectable_web_contents_.
+
+  scoped_ptr<MenuBar> menu_bar_;
+  bool menu_bar_autohide_;
+  bool menu_bar_visible_;
+  bool menu_bar_alt_pressed_;
+
+#if defined(USE_X11)
+  scoped_ptr<GlobalMenuBarX11> global_menu_bar_;
+
+  // Handles window state events.
+  scoped_ptr<WindowStateWatcher> window_state_watcher_;
+
+  // The "resizable" flag on Linux is implemented by setting size constraints,
+  // we need to make sure size constraints are restored when window becomes
+  // resizable again.
+  extensions::SizeConstraints old_size_constraints_;
+#elif defined(OS_WIN)
+  // Weak ref.
+  ElectronDesktopWindowTreeHostWin* electron_desktop_window_tree_host_win_;
+
+  ui::WindowShowState last_window_state_;
+
+  // There's an issue with restore on Windows, that sometimes causes the Window
+  // to receive the wrong size (#2498). To circumvent that, we keep tabs on the
+  // size of the window while in the normal state (not maximized, minimized or
+  // fullscreen), so we restore it correctly.
+  gfx::Size last_normal_size_;
+
+  // In charge of running taskbar related APIs.
+  TaskbarHost taskbar_host_;
+#endif
+
+  // Handles unhandled keyboard messages coming back from the renderer process.
+  scoped_ptr<views::UnhandledKeyboardEventHandler> keyboard_event_handler_;
+
+  // Map from accelerator to menu item's command id.
+  accelerator_util::AcceleratorTable accelerator_table_;
+
+  bool use_content_size_;
+  bool movable_;
+  bool resizable_;
+  bool maximizable_;
+  bool minimizable_;
+  bool fullscreenable_;
+  std::string title_;
+  gfx::Size widget_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeWindowViews);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NATIVE_WINDOW_VIEWS_H_
added in remote
  their  100644 ccc583f4004e7f8489d1d0fa918d2d8253c88e13 electron/browser/native_window_views_win.cc
@@ -0,0 +1,156 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/native_window_views.h"
+#include "content/public/browser/browser_accessibility_state.h"
+
+namespace electron {
+
+namespace {
+
+// Convert Win32 WM_APPCOMMANDS to strings.
+const char* AppCommandToString(int command_id) {
+  switch (command_id) {
+    case APPCOMMAND_BROWSER_BACKWARD       : return "browser-backward";
+    case APPCOMMAND_BROWSER_FORWARD        : return "browser-forward";
+    case APPCOMMAND_BROWSER_REFRESH        : return "browser-refresh";
+    case APPCOMMAND_BROWSER_STOP           : return "browser-stop";
+    case APPCOMMAND_BROWSER_SEARCH         : return "browser-search";
+    case APPCOMMAND_BROWSER_FAVORITES      : return "browser-favorites";
+    case APPCOMMAND_BROWSER_HOME           : return "browser-home";
+    case APPCOMMAND_VOLUME_MUTE            : return "volume-mute";
+    case APPCOMMAND_VOLUME_DOWN            : return "volume-down";
+    case APPCOMMAND_VOLUME_UP              : return "volume-up";
+    case APPCOMMAND_MEDIA_NEXTTRACK        : return "media-nexttrack";
+    case APPCOMMAND_MEDIA_PREVIOUSTRACK    : return "media-previoustrack";
+    case APPCOMMAND_MEDIA_STOP             : return "media-stop";
+    case APPCOMMAND_MEDIA_PLAY_PAUSE       : return "media-play_pause";
+    case APPCOMMAND_LAUNCH_MAIL            : return "launch-mail";
+    case APPCOMMAND_LAUNCH_MEDIA_SELECT    : return "launch-media-select";
+    case APPCOMMAND_LAUNCH_APP1            : return "launch-app1";
+    case APPCOMMAND_LAUNCH_APP2            : return "launch-app2";
+    case APPCOMMAND_BASS_DOWN              : return "bass-down";
+    case APPCOMMAND_BASS_BOOST             : return "bass-boost";
+    case APPCOMMAND_BASS_UP                : return "bass-up";
+    case APPCOMMAND_TREBLE_DOWN            : return "treble-down";
+    case APPCOMMAND_TREBLE_UP              : return "treble-up";
+    case APPCOMMAND_MICROPHONE_VOLUME_MUTE : return "microphone-volume-mute";
+    case APPCOMMAND_MICROPHONE_VOLUME_DOWN : return "microphone-volume-down";
+    case APPCOMMAND_MICROPHONE_VOLUME_UP   : return "microphone-volume-up";
+    case APPCOMMAND_HELP                   : return "help";
+    case APPCOMMAND_FIND                   : return "find";
+    case APPCOMMAND_NEW                    : return "new";
+    case APPCOMMAND_OPEN                   : return "open";
+    case APPCOMMAND_CLOSE                  : return "close";
+    case APPCOMMAND_SAVE                   : return "save";
+    case APPCOMMAND_PRINT                  : return "print";
+    case APPCOMMAND_UNDO                   : return "undo";
+    case APPCOMMAND_REDO                   : return "redo";
+    case APPCOMMAND_COPY                   : return "copy";
+    case APPCOMMAND_CUT                    : return "cut";
+    case APPCOMMAND_PASTE                  : return "paste";
+    case APPCOMMAND_REPLY_TO_MAIL          : return "reply-to-mail";
+    case APPCOMMAND_FORWARD_MAIL           : return "forward-mail";
+    case APPCOMMAND_SEND_MAIL              : return "send-mail";
+    case APPCOMMAND_SPELL_CHECK            : return "spell-check";
+    case APPCOMMAND_MIC_ON_OFF_TOGGLE      : return "mic-on-off-toggle";
+    case APPCOMMAND_CORRECTION_LIST        : return "correction-list";
+    case APPCOMMAND_MEDIA_PLAY             : return "media-play";
+    case APPCOMMAND_MEDIA_PAUSE            : return "media-pause";
+    case APPCOMMAND_MEDIA_RECORD           : return "media-record";
+    case APPCOMMAND_MEDIA_FAST_FORWARD     : return "media-fast-forward";
+    case APPCOMMAND_MEDIA_REWIND           : return "media-rewind";
+    case APPCOMMAND_MEDIA_CHANNEL_UP       : return "media-channel-up";
+    case APPCOMMAND_MEDIA_CHANNEL_DOWN     : return "media-channel-down";
+    case APPCOMMAND_DELETE                 : return "delete";
+    case APPCOMMAND_DICTATE_OR_COMMAND_CONTROL_TOGGLE:
+      return "dictate-or-command-control-toggle";
+    default:
+      return "unknown";
+  }
+}
+
+}  // namespace
+
+bool NativeWindowViews::ExecuteWindowsCommand(int command_id) {
+  std::string command = AppCommandToString(command_id);
+  NotifyWindowExecuteWindowsCommand(command);
+  return false;
+}
+
+bool NativeWindowViews::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  NotifyWindowMessage(message, w_param, l_param);
+
+  switch (message) {
+    case WM_COMMAND:
+      // Handle thumbar button click message.
+      if (HIWORD(w_param) == THBN_CLICKED)
+        return taskbar_host_.HandleThumbarButtonEvent(LOWORD(w_param));
+      return false;
+
+    case WM_SIZE:
+      // Handle window state change.
+      HandleSizeEvent(w_param, l_param);
+      return false;
+
+    case WM_MOVING: {
+      if (!movable_)
+        ::GetWindowRect(GetAcceleratedWidget(), (LPRECT)l_param);
+      return false;
+    }
+
+    default:
+      return false;
+  }
+}
+
+void NativeWindowViews::HandleSizeEvent(WPARAM w_param, LPARAM l_param) {
+  // Here we handle the WM_SIZE event in order to figure out what is the current
+  // window state and notify the user accordingly.
+  switch (w_param) {
+    case SIZE_MAXIMIZED:
+      last_window_state_ = ui::SHOW_STATE_MAXIMIZED;
+      NotifyWindowMaximize();
+      break;
+    case SIZE_MINIMIZED:
+      last_window_state_ = ui::SHOW_STATE_MINIMIZED;
+      NotifyWindowMinimize();
+      break;
+    case SIZE_RESTORED:
+      if (last_window_state_ == ui::SHOW_STATE_NORMAL) {
+        // Window was resized so we save it's new size.
+        last_normal_size_ = GetSize();
+      } else {
+        switch (last_window_state_) {
+          case ui::SHOW_STATE_MAXIMIZED:
+            last_window_state_ = ui::SHOW_STATE_NORMAL;
+
+            // When the window is restored we resize it to the previous known
+            // normal size.
+            NativeWindow::SetSize(last_normal_size_);
+
+            NotifyWindowUnmaximize();
+            break;
+          case ui::SHOW_STATE_MINIMIZED:
+            if (IsFullscreen()) {
+              last_window_state_ = ui::SHOW_STATE_FULLSCREEN;
+              NotifyWindowEnterFullScreen();
+            } else {
+              last_window_state_ = ui::SHOW_STATE_NORMAL;
+
+              // When the window is restored we resize it to the previous known
+              // normal size.
+              NativeWindow::SetSize(last_normal_size_);
+
+              NotifyWindowRestore();
+            }
+            break;
+        }
+      }
+      break;
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 dbeabe15142fd505b5aa9ad2d3d7362876c33bc6 electron/browser/net/asar/asar_protocol_handler.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/asar/asar_protocol_handler.h"
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+#include "net/base/filename_util.h"
+#include "net/base/net_errors.h"
+
+namespace asar {
+
+AsarProtocolHandler::AsarProtocolHandler(
+    const scoped_refptr<base::TaskRunner>& file_task_runner)
+    : file_task_runner_(file_task_runner) {}
+
+AsarProtocolHandler::~AsarProtocolHandler() {
+}
+
+net::URLRequestJob* AsarProtocolHandler::MaybeCreateJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  base::FilePath full_path;
+  net::FileURLToFilePath(request->url(), &full_path);
+  URLRequestAsarJob* job = new URLRequestAsarJob(request, network_delegate);
+  job->Initialize(file_task_runner_, full_path);
+  return job;
+}
+
+bool AsarProtocolHandler::IsSafeRedirectTarget(const GURL& location) const {
+  return false;
+}
+
+}  // namespace asar
added in remote
  their  100644 98647a56e5a3103524262c947df1ee18d6ac5428 electron/browser/net/asar/asar_protocol_handler.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
+#define ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
+
+#include "base/memory/ref_counted.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace base {
+class TaskRunner;
+}
+
+namespace asar {
+
+class AsarProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit AsarProtocolHandler(
+      const scoped_refptr<base::TaskRunner>& file_task_runner);
+  virtual ~AsarProtocolHandler();
+
+  // net::URLRequestJobFactory::ProtocolHandler:
+  net::URLRequestJob* MaybeCreateJob(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  const scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  DISALLOW_COPY_AND_ASSIGN(AsarProtocolHandler);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
added in remote
  their  100644 dda5b8fdf29155291fec43494ec2fecd8e2b7ddd electron/browser/net/asar/url_request_asar_job.cc
@@ -0,0 +1,346 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/archive.h"
+#include "electron/common/asar/asar_util.h"
+#include "electron/common/electron_constants.h"
+#include "base/bind.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "base/synchronization/lock.h"
+#include "base/task_runner.h"
+#include "net/base/file_stream.h"
+#include "net/base/filename_util.h"
+#include "net/base/io_buffer.h"
+#include "net/base/load_flags.h"
+#include "net/base/mime_util.h"
+#include "net/base/net_errors.h"
+#include "net/filter/filter.h"
+#include "net/http/http_util.h"
+#include "net/url_request/url_request_status.h"
+
+#if defined(OS_WIN)
+#include "base/win/shortcut.h"
+#endif
+
+namespace asar {
+
+URLRequestAsarJob::FileMetaInfo::FileMetaInfo()
+    : file_size(0),
+      mime_type_result(false),
+      file_exists(false),
+      is_directory(false) {
+}
+
+URLRequestAsarJob::URLRequestAsarJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate)
+    : net::URLRequestJob(request, network_delegate),
+      type_(TYPE_ERROR),
+      remaining_bytes_(0),
+      range_parse_result_(net::OK),
+      weak_ptr_factory_(this) {}
+
+URLRequestAsarJob::~URLRequestAsarJob() {}
+
+void URLRequestAsarJob::Initialize(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    const base::FilePath& file_path) {
+  // Determine whether it is an asar file.
+  base::FilePath asar_path, relative_path;
+  if (!GetAsarArchivePath(file_path, &asar_path, &relative_path)) {
+    InitializeFileJob(file_task_runner, file_path);
+    return;
+  }
+
+  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
+  Archive::FileInfo file_info;
+  if (!archive || !archive->GetFileInfo(relative_path, &file_info)) {
+    type_ = TYPE_ERROR;
+    return;
+  }
+
+  if (file_info.unpacked) {
+    base::FilePath real_path;
+    archive->CopyFileOut(relative_path, &real_path);
+    InitializeFileJob(file_task_runner, real_path);
+    return;
+  }
+
+  InitializeAsarJob(file_task_runner, archive, relative_path, file_info);
+}
+
+void URLRequestAsarJob::InitializeAsarJob(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    std::shared_ptr<Archive> archive,
+    const base::FilePath& file_path,
+    const Archive::FileInfo& file_info) {
+  type_ = TYPE_ASAR;
+  file_task_runner_ = file_task_runner;
+  stream_.reset(new net::FileStream(file_task_runner_));
+  archive_ = archive;
+  file_path_ = file_path;
+  file_info_ = file_info;
+}
+
+void URLRequestAsarJob::InitializeFileJob(
+    const scoped_refptr<base::TaskRunner> file_task_runner,
+    const base::FilePath& file_path) {
+  type_ = TYPE_FILE;
+  file_task_runner_ = file_task_runner;
+  stream_.reset(new net::FileStream(file_task_runner_));
+  file_path_ = file_path;
+}
+
+void URLRequestAsarJob::Start() {
+  if (type_ == TYPE_ASAR) {
+    remaining_bytes_ = static_cast<int64_t>(file_info_.size);
+
+    int flags = base::File::FLAG_OPEN |
+                base::File::FLAG_READ |
+                base::File::FLAG_ASYNC;
+    int rv = stream_->Open(archive_->path(), flags,
+                           base::Bind(&URLRequestAsarJob::DidOpen,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != net::ERR_IO_PENDING)
+      DidOpen(rv);
+  } else if (type_ == TYPE_FILE) {
+    FileMetaInfo* meta_info = new FileMetaInfo();
+    file_task_runner_->PostTaskAndReply(
+        FROM_HERE,
+        base::Bind(&URLRequestAsarJob::FetchMetaInfo, file_path_,
+                   base::Unretained(meta_info)),
+        base::Bind(&URLRequestAsarJob::DidFetchMetaInfo,
+                   weak_ptr_factory_.GetWeakPtr(),
+                   base::Owned(meta_info)));
+  } else {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           net::ERR_FILE_NOT_FOUND));
+  }
+}
+
+void URLRequestAsarJob::Kill() {
+  stream_.reset();
+  weak_ptr_factory_.InvalidateWeakPtrs();
+
+  URLRequestJob::Kill();
+}
+
+int URLRequestAsarJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
+  if (remaining_bytes_ < dest_size)
+    dest_size = static_cast<int>(remaining_bytes_);
+
+  // If we should copy zero bytes because |remaining_bytes_| is zero, short
+  // circuit here.
+  if (!dest_size)
+    return 0;
+
+  int rv = stream_->Read(dest,
+                         dest_size,
+                         base::Bind(&URLRequestAsarJob::DidRead,
+                                    weak_ptr_factory_.GetWeakPtr(),
+                                    make_scoped_refptr(dest)));
+  if (rv >= 0) {
+    remaining_bytes_ -= rv;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  return rv;
+}
+
+bool URLRequestAsarJob::IsRedirectResponse(GURL* location,
+                                           int* http_status_code) {
+  if (type_ != TYPE_FILE)
+    return false;
+#if defined(OS_WIN)
+  // Follow a Windows shortcut.
+  // We just resolve .lnk file, ignore others.
+  if (!base::LowerCaseEqualsASCII(file_path_.Extension(), ".lnk"))
+    return false;
+
+  base::FilePath new_path = file_path_;
+  bool resolved;
+  resolved = base::win::ResolveShortcut(new_path, &new_path, NULL);
+
+  // If shortcut is not resolved succesfully, do not redirect.
+  if (!resolved)
+    return false;
+
+  *location = net::FilePathToFileURL(new_path);
+  *http_status_code = 301;
+  return true;
+#else
+  return false;
+#endif
+}
+
+net::Filter* URLRequestAsarJob::SetupFilter() const {
+  // Bug 9936 - .svgz files needs to be decompressed.
+  return base::LowerCaseEqualsASCII(file_path_.Extension(), ".svgz")
+      ? net::Filter::GZipFactory() : NULL;
+}
+
+bool URLRequestAsarJob::GetMimeType(std::string* mime_type) const {
+  if (type_ == TYPE_ASAR) {
+    return net::GetMimeTypeFromFile(file_path_, mime_type);
+  } else {
+    if (meta_info_.mime_type_result) {
+      *mime_type = meta_info_.mime_type;
+      return true;
+    }
+    return false;
+  }
+}
+
+void URLRequestAsarJob::SetExtraRequestHeaders(
+    const net::HttpRequestHeaders& headers) {
+  std::string range_header;
+  if (headers.GetHeader(net::HttpRequestHeaders::kRange, &range_header)) {
+    // This job only cares about the Range header. This method stashes the value
+    // for later use in DidOpen(), which is responsible for some of the range
+    // validation as well. NotifyStartError is not legal to call here since
+    // the job has not started.
+    std::vector<net::HttpByteRange> ranges;
+    if (net::HttpUtil::ParseRangeHeader(range_header, &ranges)) {
+      if (ranges.size() == 1) {
+        byte_range_ = ranges[0];
+      } else {
+        range_parse_result_ = net::ERR_REQUEST_RANGE_NOT_SATISFIABLE;
+      }
+    }
+  }
+}
+
+int URLRequestAsarJob::GetResponseCode() const {
+  // Request Job gets created only if path exists.
+  return 200;
+}
+
+void URLRequestAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(electron::kCORSHeader);
+  info->headers = headers;
+}
+
+void URLRequestAsarJob::FetchMetaInfo(const base::FilePath& file_path,
+                                      FileMetaInfo* meta_info) {
+  base::File::Info file_info;
+  meta_info->file_exists = base::GetFileInfo(file_path, &file_info);
+  if (meta_info->file_exists) {
+    meta_info->file_size = file_info.size;
+    meta_info->is_directory = file_info.is_directory;
+  }
+  // On Windows GetMimeTypeFromFile() goes to the registry. Thus it should be
+  // done in WorkerPool.
+  meta_info->mime_type_result =
+      net::GetMimeTypeFromFile(file_path, &meta_info->mime_type);
+}
+
+void URLRequestAsarJob::DidFetchMetaInfo(const FileMetaInfo* meta_info) {
+  meta_info_ = *meta_info;
+  if (!meta_info_.file_exists || meta_info_.is_directory) {
+    DidOpen(net::ERR_FILE_NOT_FOUND);
+    return;
+  }
+
+  int flags = base::File::FLAG_OPEN |
+              base::File::FLAG_READ |
+              base::File::FLAG_ASYNC;
+  int rv = stream_->Open(file_path_, flags,
+                         base::Bind(&URLRequestAsarJob::DidOpen,
+                                    weak_ptr_factory_.GetWeakPtr()));
+  if (rv != net::ERR_IO_PENDING)
+    DidOpen(rv);
+}
+
+void URLRequestAsarJob::DidOpen(int result) {
+  if (result != net::OK) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           result));
+    return;
+  }
+
+  if (range_parse_result_ != net::OK) {
+    NotifyStartError(net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                           range_parse_result_));
+    return;
+  }
+
+  if (type_ == TYPE_ASAR) {
+    int rv = stream_->Seek(file_info_.offset,
+                           base::Bind(&URLRequestAsarJob::DidSeek,
+                                      weak_ptr_factory_.GetWeakPtr()));
+    if (rv != net::ERR_IO_PENDING) {
+      // stream_->Seek() failed, so pass an intentionally erroneous value
+      // into DidSeek().
+      DidSeek(-1);
+    }
+  } else {
+    if (!byte_range_.ComputeBounds(meta_info_.file_size)) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+
+    remaining_bytes_ = byte_range_.last_byte_position() -
+                       byte_range_.first_byte_position() + 1;
+
+    if (remaining_bytes_ > 0 && byte_range_.first_byte_position() != 0) {
+      int rv = stream_->Seek(byte_range_.first_byte_position(),
+                             base::Bind(&URLRequestAsarJob::DidSeek,
+                                        weak_ptr_factory_.GetWeakPtr()));
+      if (rv != net::ERR_IO_PENDING) {
+        // stream_->Seek() failed, so pass an intentionally erroneous value
+        // into DidSeek().
+        DidSeek(-1);
+      }
+    } else {
+      // We didn't need to call stream_->Seek() at all, so we pass to DidSeek()
+      // the value that would mean seek success. This way we skip the code
+      // handling seek failure.
+      DidSeek(byte_range_.first_byte_position());
+    }
+  }
+}
+
+void URLRequestAsarJob::DidSeek(int64_t result) {
+  if (type_ == TYPE_ASAR) {
+    if (result != static_cast<int64_t>(file_info_.offset)) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+  } else {
+    if (result != byte_range_.first_byte_position()) {
+      NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED,
+                                net::ERR_REQUEST_RANGE_NOT_SATISFIABLE));
+      return;
+    }
+  }
+  set_expected_content_size(remaining_bytes_);
+  NotifyHeadersComplete();
+}
+
+void URLRequestAsarJob::DidRead(scoped_refptr<net::IOBuffer> buf, int result) {
+  if (result >= 0) {
+    remaining_bytes_ -= result;
+    DCHECK_GE(remaining_bytes_, 0);
+  }
+
+  buf = NULL;
+
+  ReadRawDataComplete(result);
+}
+
+}  // namespace asar
added in remote
  their  100644 e4c5320cf4d68838c136d0f94bd84ecaab373a39 electron/browser/net/asar/url_request_asar_job.h
@@ -0,0 +1,131 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
+#define ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
+
+#include <memory>
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "electron/common/asar/archive.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "net/http/http_byte_range.h"
+#include "net/url_request/url_request_job.h"
+
+namespace base {
+class TaskRunner;
+}
+
+namespace net {
+class FileStream;
+}
+
+namespace asar {
+
+// Createa a request job according to the file path.
+net::URLRequestJob* CreateJobFromPath(
+    const base::FilePath& full_path,
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate,
+    const scoped_refptr<base::TaskRunner> file_task_runner);
+
+class URLRequestAsarJob : public net::URLRequestJob {
+ public:
+  URLRequestAsarJob(net::URLRequest* request,
+                    net::NetworkDelegate* network_delegate);
+
+  void Initialize(const scoped_refptr<base::TaskRunner> file_task_runner,
+                  const base::FilePath& file_path);
+
+ protected:
+  virtual ~URLRequestAsarJob();
+
+  void InitializeAsarJob(const scoped_refptr<base::TaskRunner> file_task_runner,
+                         std::shared_ptr<Archive> archive,
+                         const base::FilePath& file_path,
+                         const Archive::FileInfo& file_info);
+  void InitializeFileJob(const scoped_refptr<base::TaskRunner> file_task_runner,
+                         const base::FilePath& file_path);
+
+  // net::URLRequestJob:
+  void Start() override;
+  void Kill() override;
+  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
+  bool IsRedirectResponse(GURL* location, int* http_status_code) override;
+  net::Filter* SetupFilter() const override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void SetExtraRequestHeaders(const net::HttpRequestHeaders& headers) override;
+  int GetResponseCode() const override;
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+ private:
+  // Meta information about the file. It's used as a member in the
+  // URLRequestFileJob and also passed between threads because disk access is
+  // necessary to obtain it.
+  struct FileMetaInfo {
+    FileMetaInfo();
+
+    // Size of the file.
+    int64_t file_size;
+    // Mime type associated with the file.
+    std::string mime_type;
+    // Result returned from GetMimeTypeFromFile(), i.e. flag showing whether
+    // obtaining of the mime type was successful.
+    bool mime_type_result;
+    // Flag showing whether the file exists.
+    bool file_exists;
+    // Flag showing whether the file name actually refers to a directory.
+    bool is_directory;
+  };
+
+  // Fetches file info on a background thread.
+  static void FetchMetaInfo(const base::FilePath& file_path,
+                            FileMetaInfo* meta_info);
+
+  // Callback after fetching file info on a background thread.
+  void DidFetchMetaInfo(const FileMetaInfo* meta_info);
+
+
+  // Callback after opening file on a background thread.
+  void DidOpen(int result);
+
+  // Callback after seeking to the beginning of |byte_range_| in the file
+  // on a background thread.
+  void DidSeek(int64_t result);
+
+  // Callback after data is asynchronously read from the file into |buf|.
+  void DidRead(scoped_refptr<net::IOBuffer> buf, int result);
+
+  // The type of this job.
+  enum JobType {
+    TYPE_ERROR,
+    TYPE_ASAR,
+    TYPE_FILE,
+  };
+  JobType type_;
+
+  std::shared_ptr<Archive> archive_;
+  base::FilePath file_path_;
+  Archive::FileInfo file_info_;
+
+  scoped_ptr<net::FileStream> stream_;
+  FileMetaInfo meta_info_;
+  scoped_refptr<base::TaskRunner> file_task_runner_;
+
+  net::HttpByteRange byte_range_;
+  int64_t remaining_bytes_;
+
+  net::Error range_parse_result_;
+
+  base::WeakPtrFactory<URLRequestAsarJob> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestAsarJob);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_BROWSER_NET_ASAR_URL_REQUEST_ASAR_JOB_H_
added in remote
  their  100644 be5e2e2104c73c4e918ffac8046f6c2bd38fe2ec electron/browser/net/electron_cert_verifier.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_cert_verifier.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/net_errors.h"
+#include "net/cert/crl_set.h"
+#include "net/cert/x509_certificate.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+void OnResult(
+    net::CertVerifyResult* verify_result,
+    const net::CompletionCallback& callback,
+    bool result) {
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(callback, result ? net::OK : net::ERR_FAILED));
+}
+
+}  // namespace
+
+ElectronCertVerifier::ElectronCertVerifier()
+    : default_cert_verifier_(net::CertVerifier::CreateDefault()) {
+}
+
+ElectronCertVerifier::~ElectronCertVerifier() {
+}
+
+void ElectronCertVerifier::SetVerifyProc(const VerifyProc& proc) {
+  base::AutoLock auto_lock(lock_);
+  verify_proc_ = proc;
+}
+
+int ElectronCertVerifier::Verify(
+    net::X509Certificate* cert,
+    const std::string& hostname,
+    const std::string& ocsp_response,
+    int flags,
+    net::CRLSet* crl_set,
+    net::CertVerifyResult* verify_result,
+    const net::CompletionCallback& callback,
+    scoped_ptr<Request>* out_req,
+    const net::BoundNetLog& net_log) {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  VerifyProc proc;
+  {
+    base::AutoLock auto_lock(lock_);
+    proc = verify_proc_;
+  }
+
+  if (proc.is_null())
+    return default_cert_verifier_->Verify(
+        cert, hostname, ocsp_response, flags, crl_set, verify_result, callback,
+        out_req, net_log);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(proc, hostname, make_scoped_refptr(cert),
+                 base::Bind(OnResult, verify_result, callback)));
+  return net::ERR_IO_PENDING;
+}
+
+bool ElectronCertVerifier::SupportsOCSPStapling() {
+  return true;
+}
+
+}  // namespace electron
added in remote
  their  100644 34343f3e5c717c052c0b176e7e502eee0e44325c electron/browser/net/electron_cert_verifier.h
@@ -0,0 +1,51 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
+
+#include <string>
+
+#include "base/memory/ref_counted.h"
+#include "base/synchronization/lock.h"
+#include "net/cert/cert_verifier.h"
+
+namespace electron {
+
+class ElectronCertVerifier : public net::CertVerifier {
+ public:
+  ElectronCertVerifier();
+  virtual ~ElectronCertVerifier();
+
+  using VerifyProc =
+      base::Callback<void(const std::string& hostname,
+                          scoped_refptr<net::X509Certificate>,
+                          const base::Callback<void(bool)>&)>;
+
+  void SetVerifyProc(const VerifyProc& proc);
+
+ protected:
+  // net::CertVerifier:
+  int Verify(net::X509Certificate* cert,
+             const std::string& hostname,
+             const std::string& ocsp_response,
+             int flags,
+             net::CRLSet* crl_set,
+             net::CertVerifyResult* verify_result,
+             const net::CompletionCallback& callback,
+             scoped_ptr<Request>* out_req,
+             const net::BoundNetLog& net_log) override;
+  bool SupportsOCSPStapling() override;
+
+ private:
+  base::Lock lock_;
+  VerifyProc verify_proc_;
+  scoped_ptr<net::CertVerifier> default_cert_verifier_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronCertVerifier);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_CERT_VERIFIER_H_
added in remote
  their  100644 e6aa9d5e15cd40ad614c2c9d706b167d54a6513b electron/browser/net/electron_network_delegate.cc
@@ -0,0 +1,401 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_network_delegate.h"
+
+#include <string>
+
+#include "electron/common/native_mate_converters/net_converter.h"
+#include "base/stl_util.h"
+#include "base/strings/string_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/browser/resource_request_info.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+const char* ResourceTypeToString(content::ResourceType type) {
+  switch (type) {
+    case content::RESOURCE_TYPE_MAIN_FRAME:
+      return "mainFrame";
+    case content::RESOURCE_TYPE_SUB_FRAME:
+      return "subFrame";
+    case content::RESOURCE_TYPE_STYLESHEET:
+      return "stylesheet";
+    case content::RESOURCE_TYPE_SCRIPT:
+      return "script";
+    case content::RESOURCE_TYPE_IMAGE:
+      return "image";
+    case content::RESOURCE_TYPE_OBJECT:
+      return "object";
+    case content::RESOURCE_TYPE_XHR:
+      return "xhr";
+    default:
+      return "other";
+  }
+}
+
+void RunSimpleListener(const ElectronNetworkDelegate::SimpleListener& listener,
+                       scoped_ptr<base::DictionaryValue> details) {
+  return listener.Run(*(details.get()));
+}
+
+void RunResponseListener(
+    const ElectronNetworkDelegate::ResponseListener& listener,
+    scoped_ptr<base::DictionaryValue> details,
+    const ElectronNetworkDelegate::ResponseCallback& callback) {
+  return listener.Run(*(details.get()), callback);
+}
+
+// Test whether the URL of |request| matches |patterns|.
+bool MatchesFilterCondition(net::URLRequest* request,
+                            const URLPatterns& patterns) {
+  if (patterns.empty())
+    return true;
+
+  for (const auto& pattern : patterns) {
+    if (pattern.MatchesURL(request->url()))
+      return true;
+  }
+  return false;
+}
+
+// Overloaded by multiple types to fill the |details| object.
+void ToDictionary(base::DictionaryValue* details, net::URLRequest* request) {
+  details->SetInteger("id", request->identifier());
+  details->SetString("url", request->url().spec());
+  details->SetString("method", request->method());
+  details->SetDouble("timestamp", base::Time::Now().ToDoubleT() * 1000);
+  auto info = content::ResourceRequestInfo::ForRequest(request);
+  details->SetString("resourceType",
+                     info ? ResourceTypeToString(info->GetResourceType())
+                          : "other");
+  scoped_ptr<base::ListValue> list(new base::ListValue);
+  GetUploadData(list.get(), request);
+  if (!list->empty())
+    details->Set("uploadData", std::move(list));
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HttpRequestHeaders& headers) {
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  net::HttpRequestHeaders::Iterator it(headers);
+  while (it.GetNext())
+    dict->SetString(it.name(), it.value());
+  details->Set("requestHeaders", std::move(dict));
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HttpResponseHeaders* headers) {
+  if (!headers)
+    return;
+
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  void* iter = nullptr;
+  std::string key;
+  std::string value;
+  while (headers->EnumerateHeaderLines(&iter, &key, &value)) {
+    if (dict->HasKey(key)) {
+      base::ListValue* values = nullptr;
+      if (dict->GetList(key, &values))
+        values->AppendString(value);
+    } else {
+      scoped_ptr<base::ListValue> values(new base::ListValue);
+      values->AppendString(value);
+      dict->Set(key, std::move(values));
+    }
+  }
+  details->Set("responseHeaders", std::move(dict));
+  details->SetString("statusLine", headers->GetStatusLine());
+  details->SetInteger("statusCode", headers->response_code());
+}
+
+void ToDictionary(base::DictionaryValue* details, const GURL& location) {
+  details->SetString("redirectURL", location.spec());
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::HostPortPair& host_port) {
+  if (host_port.host().empty())
+    details->SetString("ip", host_port.host());
+}
+
+void ToDictionary(base::DictionaryValue* details, bool from_cache) {
+  details->SetBoolean("fromCache", from_cache);
+}
+
+void ToDictionary(base::DictionaryValue* details,
+                  const net::URLRequestStatus& status) {
+  details->SetString("error", net::ErrorToString(status.error()));
+}
+
+// Helper function to fill |details| with arbitrary |args|.
+template<typename Arg>
+void FillDetailsObject(base::DictionaryValue* details, Arg arg) {
+  ToDictionary(details, arg);
+}
+
+template<typename Arg, typename... Args>
+void FillDetailsObject(base::DictionaryValue* details, Arg arg, Args... args) {
+  ToDictionary(details, arg);
+  FillDetailsObject(details, args...);
+}
+
+// Fill the native types with the result from the response object.
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            GURL* new_location) {
+  std::string url;
+  if (response.GetString("redirectURL", &url))
+    *new_location = GURL(url);
+}
+
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            net::HttpRequestHeaders* headers) {
+  const base::DictionaryValue* dict;
+  if (response.GetDictionary("requestHeaders", &dict)) {
+    headers->Clear();
+    for (base::DictionaryValue::Iterator it(*dict);
+         !it.IsAtEnd();
+         it.Advance()) {
+      std::string value;
+      if (it.value().GetAsString(&value))
+        headers->SetHeader(it.key(), value);
+    }
+  }
+}
+
+void ReadFromResponseObject(const base::DictionaryValue& response,
+                            scoped_refptr<net::HttpResponseHeaders>* headers) {
+  const base::DictionaryValue* dict;
+  if (response.GetDictionary("responseHeaders", &dict)) {
+    *headers = new net::HttpResponseHeaders("");
+    for (base::DictionaryValue::Iterator it(*dict);
+         !it.IsAtEnd();
+         it.Advance()) {
+      const base::ListValue* list;
+      if (it.value().GetAsList(&list)) {
+        (*headers)->RemoveHeader(it.key());
+        for (size_t i = 0; i < list->GetSize(); ++i) {
+          std::string value;
+          if (list->GetString(i, &value))
+            (*headers)->AddHeader(it.key() + " : " + value);
+        }
+      }
+    }
+  }
+}
+
+}  // namespace
+
+ElectronNetworkDelegate::ElectronNetworkDelegate() {
+}
+
+ElectronNetworkDelegate::~ElectronNetworkDelegate() {
+}
+
+void ElectronNetworkDelegate::SetSimpleListenerInIO(
+    SimpleEvent type,
+    const URLPatterns& patterns,
+    const SimpleListener& callback) {
+  if (callback.is_null())
+    simple_listeners_.erase(type);
+  else
+    simple_listeners_[type] = { patterns, callback };
+}
+
+void ElectronNetworkDelegate::SetResponseListenerInIO(
+    ResponseEvent type,
+    const URLPatterns& patterns,
+    const ResponseListener& callback) {
+  if (callback.is_null())
+    response_listeners_.erase(type);
+  else
+    response_listeners_[type] = { patterns, callback };
+}
+
+int ElectronNetworkDelegate::OnBeforeURLRequest(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    GURL* new_url) {
+  if (!ContainsKey(response_listeners_, kOnBeforeRequest))
+    return brightray::NetworkDelegate::OnBeforeURLRequest(
+        request, callback, new_url);
+
+  return HandleResponseEvent(kOnBeforeRequest, request, callback, new_url);
+}
+
+int ElectronNetworkDelegate::OnBeforeSendHeaders(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    net::HttpRequestHeaders* headers) {
+  if (!ContainsKey(response_listeners_, kOnBeforeSendHeaders))
+    return brightray::NetworkDelegate::OnBeforeSendHeaders(
+        request, callback, headers);
+
+  return HandleResponseEvent(
+      kOnBeforeSendHeaders, request, callback, headers, *headers);
+}
+
+void ElectronNetworkDelegate::OnSendHeaders(
+    net::URLRequest* request,
+    const net::HttpRequestHeaders& headers) {
+  if (!ContainsKey(simple_listeners_, kOnSendHeaders)) {
+    brightray::NetworkDelegate::OnSendHeaders(request, headers);
+    return;
+  }
+
+  HandleSimpleEvent(kOnSendHeaders, request, headers);
+}
+
+int ElectronNetworkDelegate::OnHeadersReceived(
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    const net::HttpResponseHeaders* original,
+    scoped_refptr<net::HttpResponseHeaders>* override,
+    GURL* allowed) {
+  if (!ContainsKey(response_listeners_, kOnHeadersReceived))
+    return brightray::NetworkDelegate::OnHeadersReceived(
+        request, callback, original, override, allowed);
+
+  return HandleResponseEvent(
+      kOnHeadersReceived, request, callback, override, original);
+}
+
+void ElectronNetworkDelegate::OnBeforeRedirect(net::URLRequest* request,
+                                           const GURL& new_location) {
+  if (!ContainsKey(simple_listeners_, kOnBeforeRedirect)) {
+    brightray::NetworkDelegate::OnBeforeRedirect(request, new_location);
+    return;
+  }
+
+  HandleSimpleEvent(kOnBeforeRedirect, request, new_location,
+                    request->response_headers(), request->GetSocketAddress(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnResponseStarted(net::URLRequest* request) {
+  if (!ContainsKey(simple_listeners_, kOnResponseStarted)) {
+    brightray::NetworkDelegate::OnResponseStarted(request);
+    return;
+  }
+
+  if (request->status().status() != net::URLRequestStatus::SUCCESS)
+    return;
+
+  HandleSimpleEvent(kOnResponseStarted, request, request->response_headers(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnCompleted(net::URLRequest* request, bool started) {
+  // OnCompleted may happen before other events.
+  callbacks_.erase(request->identifier());
+
+  if (request->status().status() == net::URLRequestStatus::FAILED ||
+      request->status().status() == net::URLRequestStatus::CANCELED) {
+    // Error event.
+    OnErrorOccurred(request, started);
+    return;
+  } else if (request->response_headers() &&
+             net::HttpResponseHeaders::IsRedirectResponseCode(
+                 request->response_headers()->response_code())) {
+    // Redirect event.
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  if (!ContainsKey(simple_listeners_, kOnCompleted)) {
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  HandleSimpleEvent(kOnCompleted, request, request->response_headers(),
+                    request->was_cached());
+}
+
+void ElectronNetworkDelegate::OnURLRequestDestroyed(net::URLRequest* request) {
+  callbacks_.erase(request->identifier());
+}
+
+void ElectronNetworkDelegate::OnErrorOccurred(
+    net::URLRequest* request, bool started) {
+  if (!ContainsKey(simple_listeners_, kOnErrorOccurred)) {
+    brightray::NetworkDelegate::OnCompleted(request, started);
+    return;
+  }
+
+  HandleSimpleEvent(kOnErrorOccurred, request, request->was_cached(),
+                    request->status());
+}
+
+template<typename Out, typename... Args>
+int ElectronNetworkDelegate::HandleResponseEvent(
+    ResponseEvent type,
+    net::URLRequest* request,
+    const net::CompletionCallback& callback,
+    Out out,
+    Args... args) {
+  const auto& info = response_listeners_[type];
+  if (!MatchesFilterCondition(request, info.url_patterns))
+    return net::OK;
+
+  scoped_ptr<base::DictionaryValue> details(new base::DictionaryValue);
+  FillDetailsObject(details.get(), request, args...);
+
+  // The |request| could be destroyed before the |callback| is called.
+  callbacks_[request->identifier()] = callback;
+
+  ResponseCallback response =
+      base::Bind(&ElectronNetworkDelegate::OnListenerResultInUI<Out>,
+                 base::Unretained(this), request->identifier(), out);
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(RunResponseListener, info.listener, base::Passed(&details),
+                 response));
+  return net::ERR_IO_PENDING;
+}
+
+template<typename...Args>
+void ElectronNetworkDelegate::HandleSimpleEvent(
+    SimpleEvent type, net::URLRequest* request, Args... args) {
+  const auto& info = simple_listeners_[type];
+  if (!MatchesFilterCondition(request, info.url_patterns))
+    return;
+
+  scoped_ptr<base::DictionaryValue> details(new base::DictionaryValue);
+  FillDetailsObject(details.get(), request, args...);
+
+  BrowserThread::PostTask(
+      BrowserThread::UI, FROM_HERE,
+      base::Bind(RunSimpleListener, info.listener, base::Passed(&details)));
+}
+
+template<typename T>
+void ElectronNetworkDelegate::OnListenerResultInIO(
+    uint64_t id, T out, scoped_ptr<base::DictionaryValue> response) {
+  // The request has been destroyed.
+  if (!ContainsKey(callbacks_, id))
+    return;
+
+  ReadFromResponseObject(*response.get(), out);
+
+  bool cancel = false;
+  response->GetBoolean("cancel", &cancel);
+  callbacks_[id].Run(cancel ? net::ERR_BLOCKED_BY_CLIENT : net::OK);
+}
+
+template<typename T>
+void ElectronNetworkDelegate::OnListenerResultInUI(
+    uint64_t id, T out, const base::DictionaryValue& response) {
+  scoped_ptr<base::DictionaryValue> copy = response.CreateDeepCopy();
+  BrowserThread::PostTask(
+      BrowserThread::IO, FROM_HERE,
+      base::Bind(&ElectronNetworkDelegate::OnListenerResultInIO<T>,
+                 base::Unretained(this),  id, out, base::Passed(&copy)));
+}
+
+}  // namespace electron
added in remote
  their  100644 89f4290145df57e14d6e01a6654c8b294da7e644 electron/browser/net/electron_network_delegate.h
@@ -0,0 +1,121 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
+
+#include <map>
+#include <set>
+
+#include "brightray/browser/network_delegate.h"
+#include "base/callback.h"
+#include "base/values.h"
+#include "extensions/common/url_pattern.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_request_headers.h"
+#include "net/http/http_response_headers.h"
+
+namespace extensions {
+class URLPattern;
+}
+
+namespace electron {
+
+using URLPatterns = std::set<extensions::URLPattern>;
+
+class ElectronNetworkDelegate : public brightray::NetworkDelegate {
+ public:
+  using ResponseCallback = base::Callback<void(const base::DictionaryValue&)>;
+  using SimpleListener = base::Callback<void(const base::DictionaryValue&)>;
+  using ResponseListener = base::Callback<void(const base::DictionaryValue&,
+                                               const ResponseCallback&)>;
+
+  enum SimpleEvent {
+    kOnSendHeaders,
+    kOnBeforeRedirect,
+    kOnResponseStarted,
+    kOnCompleted,
+    kOnErrorOccurred,
+  };
+
+  enum ResponseEvent {
+    kOnBeforeRequest,
+    kOnBeforeSendHeaders,
+    kOnHeadersReceived,
+  };
+
+  struct SimpleListenerInfo {
+    URLPatterns url_patterns;
+    SimpleListener listener;
+  };
+
+  struct ResponseListenerInfo {
+    URLPatterns url_patterns;
+    ResponseListener listener;
+  };
+
+  ElectronNetworkDelegate();
+  ~ElectronNetworkDelegate() override;
+
+  void SetSimpleListenerInIO(SimpleEvent type,
+                             const URLPatterns& patterns,
+                             const SimpleListener& callback);
+  void SetResponseListenerInIO(ResponseEvent type,
+                               const URLPatterns& patterns,
+                               const ResponseListener& callback);
+
+ protected:
+  // net::NetworkDelegate:
+  int OnBeforeURLRequest(net::URLRequest* request,
+                         const net::CompletionCallback& callback,
+                         GURL* new_url) override;
+  int OnBeforeSendHeaders(net::URLRequest* request,
+                          const net::CompletionCallback& callback,
+                          net::HttpRequestHeaders* headers) override;
+  void OnSendHeaders(net::URLRequest* request,
+                     const net::HttpRequestHeaders& headers) override;
+  int OnHeadersReceived(
+      net::URLRequest* request,
+      const net::CompletionCallback& callback,
+      const net::HttpResponseHeaders* original_response_headers,
+      scoped_refptr<net::HttpResponseHeaders>* override_response_headers,
+      GURL* allowed_unsafe_redirect_url) override;
+  void OnBeforeRedirect(net::URLRequest* request,
+                        const GURL& new_location) override;
+  void OnResponseStarted(net::URLRequest* request) override;
+  void OnCompleted(net::URLRequest* request, bool started) override;
+  void OnURLRequestDestroyed(net::URLRequest* request) override;
+
+ private:
+  void OnErrorOccurred(net::URLRequest* request, bool started);
+
+  template<typename...Args>
+  void HandleSimpleEvent(SimpleEvent type,
+                         net::URLRequest* request,
+                         Args... args);
+  template<typename Out, typename... Args>
+  int HandleResponseEvent(ResponseEvent type,
+                          net::URLRequest* request,
+                          const net::CompletionCallback& callback,
+                          Out out,
+                          Args... args);
+
+  // Deal with the results of Listener.
+  template<typename T>
+  void OnListenerResultInIO(
+      uint64_t id, T out, scoped_ptr<base::DictionaryValue> response);
+  template<typename T>
+  void OnListenerResultInUI(
+      uint64_t id, T out, const base::DictionaryValue& response);
+
+  std::map<SimpleEvent, SimpleListenerInfo> simple_listeners_;
+  std::map<ResponseEvent, ResponseListenerInfo> response_listeners_;
+  std::map<uint64_t, net::CompletionCallback> callbacks_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronNetworkDelegate);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_NETWORK_DELEGATE_H_
added in remote
  their  100644 a07f31caa209bdf91d30d0d629aba525a18574a0 electron/browser/net/electron_ssl_config_service.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_ssl_config_service.h"
+
+#include <string>
+#include <vector>
+
+#include "base/command_line.h"
+#include "base/strings/string_split.h"
+#include "electron/common/options_switches.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/socket/ssl_client_socket.h"
+#include "net/ssl/ssl_cipher_suite_names.h"
+
+namespace electron {
+
+namespace {
+
+uint16_t GetSSLProtocolVersion(const std::string& version_string) {
+  uint16_t version = 0;  // Invalid
+  if (version_string == "tls1")
+    version = net::SSL_PROTOCOL_VERSION_TLS1;
+  else if (version_string == "tls1.1")
+    version = net::SSL_PROTOCOL_VERSION_TLS1_1;
+  else if (version_string == "tls1.2")
+    version = net::SSL_PROTOCOL_VERSION_TLS1_2;
+  return version;
+}
+
+std::vector<uint16_t> ParseCipherSuites(
+    const std::vector<std::string>& cipher_strings) {
+  std::vector<uint16_t> cipher_suites;
+  cipher_suites.reserve(cipher_strings.size());
+
+  for (auto& cipher_string : cipher_strings) {
+    uint16_t cipher_suite = 0;
+    if (!net::ParseSSLCipherString(cipher_string, &cipher_suite)) {
+      LOG(ERROR) << "Ignoring unrecognised cipher suite : "
+                 << cipher_string;
+      continue;
+    }
+    cipher_suites.push_back(cipher_suite);
+  }
+  return cipher_suites;
+}
+
+}  // namespace
+
+ElectronSSLConfigService::ElectronSSLConfigService() {
+  auto cmd_line = base::CommandLine::ForCurrentProcess();
+  if (cmd_line->HasSwitch(switches::kSSLVersionFallbackMin)) {
+    auto version_string =
+        cmd_line->GetSwitchValueASCII(switches::kSSLVersionFallbackMin);
+    config_.version_fallback_min = GetSSLProtocolVersion(version_string);
+  }
+
+  if (cmd_line->HasSwitch(switches::kCipherSuiteBlacklist)) {
+    auto cipher_strings = base::SplitString(
+        cmd_line->GetSwitchValueASCII(switches::kCipherSuiteBlacklist),
+        ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+    config_.disabled_cipher_suites = ParseCipherSuites(cipher_strings);
+  }
+}
+
+ElectronSSLConfigService::~ElectronSSLConfigService() {
+}
+
+void ElectronSSLConfigService::GetSSLConfig(net::SSLConfig* config) {
+  *config = config_;
+}
+
+}  // namespace electron
added in remote
  their  100644 4f96936754b74b63d7aec53ce7ba2aedde285b3e electron/browser/net/electron_ssl_config_service.h
@@ -0,0 +1,28 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
+
+#include "net/ssl/ssl_config_service.h"
+
+namespace electron {
+
+class ElectronSSLConfigService : public net::SSLConfigService {
+ public:
+  ElectronSSLConfigService();
+  ~ElectronSSLConfigService() override;
+
+  // net::SSLConfigService:
+  void GetSSLConfig(net::SSLConfig* config) override;
+
+ private:
+  net::SSLConfig config_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronSSLConfigService);
+};
+
+}   // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_SSL_CONFIG_SERVICE_H_
added in remote
  their  100644 10e3b93de7b8059c9b688732b031697f47186dfe electron/browser/net/electron_url_request_job_factory.cc
@@ -0,0 +1,113 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/electron_url_request_job_factory.h"
+
+#include "base/stl_util.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/load_flags.h"
+#include "net/url_request/url_request.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+typedef net::URLRequestJobFactory::ProtocolHandler ProtocolHandler;
+
+ElectronURLRequestJobFactory::ElectronURLRequestJobFactory() {}
+
+ElectronURLRequestJobFactory::~ElectronURLRequestJobFactory() {
+  STLDeleteValues(&protocol_handler_map_);
+}
+
+bool ElectronURLRequestJobFactory::SetProtocolHandler(
+    const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler) {
+  if (!protocol_handler) {
+    ProtocolHandlerMap::iterator it = protocol_handler_map_.find(scheme);
+    if (it == protocol_handler_map_.end())
+      return false;
+
+    delete it->second;
+    protocol_handler_map_.erase(it);
+    return true;
+  }
+
+  if (ContainsKey(protocol_handler_map_, scheme))
+    return false;
+  protocol_handler_map_[scheme] = protocol_handler.release();
+  return true;
+}
+
+scoped_ptr<ProtocolHandler> ElectronURLRequestJobFactory::ReplaceProtocol(
+    const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler) {
+  if (!ContainsKey(protocol_handler_map_, scheme))
+    return nullptr;
+  ProtocolHandler* original_protocol_handler = protocol_handler_map_[scheme];
+  protocol_handler_map_[scheme] = protocol_handler.release();
+  return make_scoped_ptr(original_protocol_handler);
+}
+
+ProtocolHandler* ElectronURLRequestJobFactory::GetProtocolHandler(
+    const std::string& scheme) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  ProtocolHandlerMap::const_iterator it = protocol_handler_map_.find(scheme);
+  if (it == protocol_handler_map_.end())
+    return nullptr;
+  return it->second;
+}
+
+bool ElectronURLRequestJobFactory::HasProtocolHandler(
+    const std::string& scheme) const {
+  return ContainsKey(protocol_handler_map_, scheme);
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeCreateJobWithProtocolHandler(
+    const std::string& scheme,
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  ProtocolHandlerMap::const_iterator it = protocol_handler_map_.find(scheme);
+  if (it == protocol_handler_map_.end())
+    return nullptr;
+  return it->second->MaybeCreateJob(request, network_delegate);
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeInterceptRedirect(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate,
+    const GURL& location) const {
+  return nullptr;
+}
+
+net::URLRequestJob* ElectronURLRequestJobFactory::MaybeInterceptResponse(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  return nullptr;
+}
+
+bool ElectronURLRequestJobFactory::IsHandledProtocol(
+    const std::string& scheme) const {
+  DCHECK_CURRENTLY_ON(BrowserThread::IO);
+
+  return HasProtocolHandler(scheme) ||
+      net::URLRequest::IsHandledProtocol(scheme);
+}
+
+bool ElectronURLRequestJobFactory::IsHandledURL(const GURL& url) const {
+  if (!url.is_valid()) {
+    // We handle error cases.
+    return true;
+  }
+  return IsHandledProtocol(url.scheme());
+}
+
+bool ElectronURLRequestJobFactory::IsSafeRedirectTarget(
+    const GURL& location) const {
+  return IsHandledURL(location);
+}
+
+}  // namespace electron
added in remote
  their  100644 4623e6c94cb5adb130f08efb27dc22366255e9ca electron/browser/net/electron_url_request_job_factory.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
+#define ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/memory/scoped_ptr.h"
+#include "base/synchronization/lock.h"
+#include "net/url_request/url_request_job_factory.h"
+
+namespace electron {
+
+class ElectronURLRequestJobFactory : public net::URLRequestJobFactory {
+ public:
+  ElectronURLRequestJobFactory();
+  virtual ~ElectronURLRequestJobFactory();
+
+  // Sets the ProtocolHandler for a scheme. Returns true on success, false on
+  // failure (a ProtocolHandler already exists for |scheme|). On success,
+  // URLRequestJobFactory takes ownership of |protocol_handler|.
+  bool SetProtocolHandler(
+      const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler);
+
+  // Intercepts the ProtocolHandler for a scheme. Returns the original protocol
+  // handler on success, otherwise returns NULL.
+  scoped_ptr<ProtocolHandler> ReplaceProtocol(
+      const std::string& scheme, scoped_ptr<ProtocolHandler> protocol_handler);
+
+  // Returns the protocol handler registered with scheme.
+  ProtocolHandler* GetProtocolHandler(const std::string& scheme) const;
+
+  // Whether the protocol handler is registered by the job factory.
+  bool HasProtocolHandler(const std::string& scheme) const;
+
+  // URLRequestJobFactory implementation
+  net::URLRequestJob* MaybeCreateJobWithProtocolHandler(
+      const std::string& scheme,
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  net::URLRequestJob* MaybeInterceptRedirect(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate,
+      const GURL& location) const override;
+  net::URLRequestJob* MaybeInterceptResponse(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+  bool IsHandledProtocol(const std::string& scheme) const override;
+  bool IsHandledURL(const GURL& url) const override;
+  bool IsSafeRedirectTarget(const GURL& location) const override;
+
+ private:
+  using ProtocolHandlerMap = std::map<std::string, ProtocolHandler*>;
+
+  ProtocolHandlerMap protocol_handler_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronURLRequestJobFactory);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_ELECTRON_URL_REQUEST_JOB_FACTORY_H_
added in remote
  their  100644 0425364c7ce4ed92960d77c7b9772351494dd4b4 electron/browser/net/http_protocol_handler.cc
@@ -0,0 +1,26 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/http_protocol_handler.h"
+
+#include "net/url_request/url_request_http_job.h"
+
+namespace electron {
+
+HttpProtocolHandler::HttpProtocolHandler(const std::string& scheme)
+    : scheme_(scheme) {
+}
+
+HttpProtocolHandler::~HttpProtocolHandler() {
+}
+
+net::URLRequestJob* HttpProtocolHandler::MaybeCreateJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate) const {
+  return net::URLRequestHttpJob::Factory(request,
+                                         network_delegate,
+                                         scheme_);
+}
+
+}  // namespace electron
added in remote
  their  100644 570f8fa50fec76f14bd8a70c95b4b70bb7accfc4 electron/browser/net/http_protocol_handler.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
+#define ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
+
+#include <string>
+
+#include "net/url_request/url_request_job_factory.h"
+
+namespace electron {
+
+class HttpProtocolHandler : public net::URLRequestJobFactory::ProtocolHandler {
+ public:
+  explicit HttpProtocolHandler(const std::string&);
+  virtual ~HttpProtocolHandler();
+
+  // net::URLRequestJobFactory::ProtocolHandler:
+  net::URLRequestJob* MaybeCreateJob(
+      net::URLRequest* request,
+      net::NetworkDelegate* network_delegate) const override;
+
+ private:
+  std::string scheme_;
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_HTTP_PROTOCOL_HANDLER_H_
added in remote
  their  100644 0cad1065961363e23a75a6c1363bb05c298751c4 electron/browser/net/js_asker.cc
@@ -0,0 +1,75 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/js_asker.h"
+
+#include <vector>
+
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+
+namespace electron {
+
+namespace internal {
+
+namespace {
+
+// The callback which is passed to |handler|.
+void HandlerCallback(const BeforeStartCallback& before_start,
+                     const ResponseCallback& callback,
+                     mate::Arguments* args) {
+  // If there is no argument passed then we failed.
+  v8::Local<v8::Value> value;
+  if (!args->GetNext(&value)) {
+    content::BrowserThread::PostTask(
+        content::BrowserThread::IO, FROM_HERE,
+        base::Bind(callback, false, nullptr));
+    return;
+  }
+
+  // Give the job a chance to parse V8 value.
+  before_start.Run(args->isolate(), value);
+
+  // Pass whatever user passed to the actaul request job.
+  V8ValueConverter converter;
+  v8::Local<v8::Context> context = args->isolate()->GetCurrentContext();
+  scoped_ptr<base::Value> options(converter.FromV8Value(value, context));
+  content::BrowserThread::PostTask(
+      content::BrowserThread::IO, FROM_HERE,
+      base::Bind(callback, true, base::Passed(&options)));
+}
+
+}  // namespace
+
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   net::URLRequest* request,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback) {
+  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
+  v8::Locker locker(isolate);
+  v8::HandleScope handle_scope(isolate);
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Context::Scope context_scope(context);
+  handler.Run(
+      request,
+      mate::ConvertToV8(isolate,
+                        base::Bind(&HandlerCallback, before_start, callback)));
+}
+
+bool IsErrorOptions(base::Value* value, int* error) {
+  if (value->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict = static_cast<base::DictionaryValue*>(value);
+    if (dict->GetInteger("error", error))
+      return true;
+  } else if (value->IsType(base::Value::TYPE_INTEGER)) {
+    if (value->GetAsInteger(error))
+      return true;
+  }
+  return false;
+}
+
+}  // namespace internal
+
+}  // namespace electron
added in remote
  their  100644 3d846f25fede7a774ec1aedb53249d7081639a93 electron/browser/net/js_asker.h
@@ -0,0 +1,108 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_JS_ASKER_H_
+#define ELECTRON_BROWSER_NET_JS_ASKER_H_
+
+#include "base/callback.h"
+#include "base/memory/ref_counted.h"
+#include "base/memory/weak_ptr.h"
+#include "base/values.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "net/url_request/url_request_job.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+using JavaScriptHandler =
+    base::Callback<void(const net::URLRequest*, v8::Local<v8::Value>)>;
+
+namespace internal {
+
+using BeforeStartCallback =
+    base::Callback<void(v8::Isolate*, v8::Local<v8::Value>)>;
+using ResponseCallback =
+    base::Callback<void(bool, scoped_ptr<base::Value> options)>;
+
+// Ask handler for options in UI thread.
+void AskForOptions(v8::Isolate* isolate,
+                   const JavaScriptHandler& handler,
+                   net::URLRequest* request,
+                   const BeforeStartCallback& before_start,
+                   const ResponseCallback& callback);
+
+// Test whether the |options| means an error.
+bool IsErrorOptions(base::Value* value, int* error);
+
+}  // namespace internal
+
+template<typename RequestJob>
+class JsAsker : public RequestJob {
+ public:
+  JsAsker(net::URLRequest* request, net::NetworkDelegate* network_delegate)
+      : RequestJob(request, network_delegate), weak_factory_(this) {}
+
+  // Called by |CustomProtocolHandler| to store handler related information.
+  void SetHandlerInfo(
+      v8::Isolate* isolate,
+      net::URLRequestContextGetter* request_context_getter,
+      const JavaScriptHandler& handler) {
+    isolate_ = isolate;
+    request_context_getter_ = request_context_getter;
+    handler_ = handler;
+  }
+
+  // Subclass should do initailze work here.
+  virtual void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) {}
+  virtual void StartAsync(scoped_ptr<base::Value> options) = 0;
+
+  net::URLRequestContextGetter* request_context_getter() const {
+    return request_context_getter_;
+  }
+
+ private:
+  // RequestJob:
+  void Start() override {
+    content::BrowserThread::PostTask(
+        content::BrowserThread::UI, FROM_HERE,
+        base::Bind(&internal::AskForOptions,
+                   isolate_,
+                   handler_,
+                   RequestJob::request(),
+                   base::Bind(&JsAsker::BeforeStartInUI,
+                              weak_factory_.GetWeakPtr()),
+                   base::Bind(&JsAsker::OnResponse,
+                              weak_factory_.GetWeakPtr())));
+  }
+  void GetResponseInfo(net::HttpResponseInfo* info) override {
+    info->headers = new net::HttpResponseHeaders("");
+  }
+
+  // Called when the JS handler has sent the response, we need to decide whether
+  // to start, or fail the job.
+  void OnResponse(bool success, scoped_ptr<base::Value> value) {
+    int error = net::ERR_NOT_IMPLEMENTED;
+    if (success && value && !internal::IsErrorOptions(value.get(), &error)) {
+      StartAsync(std::move(value));
+    } else {
+      RequestJob::NotifyStartError(
+          net::URLRequestStatus(net::URLRequestStatus::FAILED, error));
+    }
+  }
+
+  v8::Isolate* isolate_;
+  net::URLRequestContextGetter* request_context_getter_;
+  JavaScriptHandler handler_;
+
+  base::WeakPtrFactory<JsAsker> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(JsAsker);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_JS_ASKER_H_
added in remote
  their  100644 fa88add14883ca721355322ede8281dbf5499d9b electron/browser/net/url_request_async_asar_job.cc
@@ -0,0 +1,49 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_async_asar_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+
+namespace electron {
+
+URLRequestAsyncAsarJob::URLRequestAsyncAsarJob(
+    net::URLRequest* request,
+    net::NetworkDelegate* network_delegate)
+    : JsAsker<asar::URLRequestAsarJob>(request, network_delegate) {
+}
+
+void URLRequestAsyncAsarJob::StartAsync(scoped_ptr<base::Value> options) {
+  base::FilePath::StringType file_path;
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    static_cast<base::DictionaryValue*>(options.get())->GetString(
+        "path", &file_path);
+  } else if (options->IsType(base::Value::TYPE_STRING)) {
+    options->GetAsString(&file_path);
+  }
+
+  if (file_path.empty()) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+  } else {
+    asar::URLRequestAsarJob::Initialize(
+        content::BrowserThread::GetBlockingPool()->
+            GetTaskRunnerWithShutdownBehavior(
+                base::SequencedWorkerPool::SKIP_ON_SHUTDOWN),
+        base::FilePath(file_path));
+    asar::URLRequestAsarJob::Start();
+  }
+}
+
+void URLRequestAsyncAsarJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+  info->headers = headers;
+}
+
+}  // namespace electron
added in remote
  their  100644 ee921c64337d81d28b5b4b37165b753979a5abed electron/browser/net/url_request_async_asar_job.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
+
+#include "electron/browser/net/asar/url_request_asar_job.h"
+#include "electron/browser/net/js_asker.h"
+
+namespace electron {
+
+// Like URLRequestAsarJob, but asks the JavaScript handler for file path.
+class URLRequestAsyncAsarJob : public JsAsker<asar::URLRequestAsarJob> {
+ public:
+  URLRequestAsyncAsarJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(URLRequestAsyncAsarJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_ASYNC_ASAR_JOB_H_
added in remote
  their  100644 56a1b94b1f82b724b33a67d669a3a690bf4d5b3a electron/browser/net/url_request_buffer_job.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_buffer_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+#include "base/strings/string_number_conversions.h"
+#include "net/base/net_errors.h"
+
+namespace electron {
+
+URLRequestBufferJob::URLRequestBufferJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate),
+      status_code_(net::HTTP_NOT_IMPLEMENTED) {
+}
+
+void URLRequestBufferJob::StartAsync(scoped_ptr<base::Value> options) {
+  const base::BinaryValue* binary = nullptr;
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict =
+        static_cast<base::DictionaryValue*>(options.get());
+    dict->GetString("mimeType", &mime_type_);
+    dict->GetString("charset", &charset_);
+    dict->GetBinary("data", &binary);
+  } else if (options->IsType(base::Value::TYPE_BINARY)) {
+    options->GetAsBinary(&binary);
+  }
+
+  if (!binary) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+    return;
+  }
+
+  data_ = new base::RefCountedBytes(
+      reinterpret_cast<const unsigned char*>(binary->GetBuffer()),
+      binary->GetSize());
+  status_code_ = net::HTTP_OK;
+  net::URLRequestSimpleJob::Start();
+}
+
+void URLRequestBufferJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 ");
+  status.append(base::IntToString(status_code_));
+  status.append(" ");
+  status.append(net::GetHttpReasonPhrase(status_code_));
+  status.append("\0\0", 2);
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+
+  if (!mime_type_.empty()) {
+    std::string content_type_header(net::HttpRequestHeaders::kContentType);
+    content_type_header.append(": ");
+    content_type_header.append(mime_type_);
+    headers->AddHeader(content_type_header);
+  }
+
+  info->headers = headers;
+}
+
+int URLRequestBufferJob::GetRefCountedData(
+    std::string* mime_type,
+    std::string* charset,
+    scoped_refptr<base::RefCountedMemory>* data,
+    const net::CompletionCallback& callback) const {
+  *mime_type = mime_type_;
+  *charset = charset_;
+  *data = data_;
+  return net::OK;
+}
+
+}  // namespace electron
added in remote
  their  100644 0868cb64f43aa61bb082dfde76894ff8211321b1 electron/browser/net/url_request_buffer_job.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "base/memory/ref_counted_memory.h"
+#include "net/http/http_status_code.h"
+#include "net/url_request/url_request_simple_job.h"
+
+namespace electron {
+
+class URLRequestBufferJob : public JsAsker<net::URLRequestSimpleJob> {
+ public:
+  URLRequestBufferJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+  // URLRequestSimpleJob:
+  int GetRefCountedData(std::string* mime_type,
+                        std::string* charset,
+                        scoped_refptr<base::RefCountedMemory>* data,
+                        const net::CompletionCallback& callback) const override;
+
+ private:
+  std::string mime_type_;
+  std::string charset_;
+  scoped_refptr<base::RefCountedBytes> data_;
+  net::HttpStatusCode status_code_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestBufferJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_BUFFER_JOB_H_
added in remote
  their  100644 061a1a67e17b507a0b499eb41577ce8bb2dfa8f3 electron/browser/net/url_request_fetch_job.cc
@@ -0,0 +1,240 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_fetch_job.h"
+
+#include <algorithm>
+#include <string>
+
+#include "base/strings/string_util.h"
+#include "native_mate/dictionary.h"
+#include "net/base/io_buffer.h"
+#include "net/base/net_errors.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_fetcher.h"
+#include "net/url_request/url_fetcher_response_writer.h"
+
+using content::BrowserThread;
+
+namespace electron {
+
+namespace {
+
+// Convert string to RequestType.
+net::URLFetcher::RequestType GetRequestType(const std::string& raw) {
+  std::string method = base::ToUpperASCII(raw);
+  if (method.empty() || method == "GET")
+    return net::URLFetcher::GET;
+  else if (method == "POST")
+    return net::URLFetcher::POST;
+  else if (method == "HEAD")
+    return net::URLFetcher::HEAD;
+  else if (method == "DELETE")
+    return net::URLFetcher::DELETE_REQUEST;
+  else if (method == "PUT")
+    return net::URLFetcher::PUT;
+  else if (method == "PATCH")
+    return net::URLFetcher::PATCH;
+  else  // Use "GET" as fallback.
+    return net::URLFetcher::GET;
+}
+
+// Pipe the response writer back to URLRequestFetchJob.
+class ResponsePiper : public net::URLFetcherResponseWriter {
+ public:
+  explicit ResponsePiper(URLRequestFetchJob* job)
+      : first_write_(true), job_(job) {}
+
+  // net::URLFetcherResponseWriter:
+  int Initialize(const net::CompletionCallback& callback) override {
+    return net::OK;
+  }
+  int Write(net::IOBuffer* buffer,
+            int num_bytes,
+            const net::CompletionCallback& callback) override {
+    if (first_write_) {
+      // The URLFetcherResponseWriter doesn't have an event when headers have
+      // been read, so we have to emulate by hooking to first write event.
+      job_->HeadersCompleted();
+      first_write_ = false;
+    }
+    return job_->DataAvailable(buffer, num_bytes);
+  }
+  int Finish(const net::CompletionCallback& callback) override {
+    return net::OK;
+  }
+
+ private:
+  bool first_write_;
+  URLRequestFetchJob* job_;
+
+  DISALLOW_COPY_AND_ASSIGN(ResponsePiper);
+};
+
+}  // namespace
+
+URLRequestFetchJob::URLRequestFetchJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestJob>(request, network_delegate),
+      pending_buffer_size_(0) {
+}
+
+void URLRequestFetchJob::BeforeStartInUI(
+    v8::Isolate* isolate, v8::Local<v8::Value> value) {
+  mate::Dictionary options;
+  if (!mate::ConvertFromV8(isolate, value, &options))
+    return;
+
+  // When |session| is set to |null| we use a new request context for fetch job.
+  // TODO(zcbenz): Handle the case when it is not null.
+  v8::Local<v8::Value> session;
+  if (options.Get("session", &session) && session->IsNull()) {
+    // We have to create the URLRequestContextGetter on UI thread.
+    url_request_context_getter_ = new brightray::URLRequestContextGetter(
+        this, nullptr, nullptr, base::FilePath(), true,
+        BrowserThread::UnsafeGetMessageLoopForThread(BrowserThread::IO),
+        BrowserThread::UnsafeGetMessageLoopForThread(BrowserThread::FILE),
+        nullptr, content::URLRequestInterceptorScopedVector());
+  }
+}
+
+void URLRequestFetchJob::StartAsync(scoped_ptr<base::Value> options) {
+  if (!options->IsType(base::Value::TYPE_DICTIONARY)) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_NOT_IMPLEMENTED));
+    return;
+  }
+
+  std::string url, method, referrer;
+  base::DictionaryValue* upload_data = nullptr;
+  base::DictionaryValue* dict =
+      static_cast<base::DictionaryValue*>(options.get());
+  dict->GetString("url", &url);
+  dict->GetString("method", &method);
+  dict->GetString("referrer", &referrer);
+  dict->GetDictionary("uploadData", &upload_data);
+
+  // Check if URL is valid.
+  GURL formated_url(url);
+  if (!formated_url.is_valid()) {
+    NotifyStartError(net::URLRequestStatus(
+          net::URLRequestStatus::FAILED, net::ERR_INVALID_URL));
+    return;
+  }
+
+  // Use |request|'s method if |method| is not specified.
+  net::URLFetcher::RequestType request_type;
+  if (method.empty())
+    request_type = GetRequestType(request()->method());
+  else
+    request_type = GetRequestType(method);
+
+  fetcher_ = net::URLFetcher::Create(formated_url, request_type, this);
+  fetcher_->SaveResponseWithWriter(make_scoped_ptr(new ResponsePiper(this)));
+
+  // A request context getter is passed by the user.
+  if (url_request_context_getter_)
+    fetcher_->SetRequestContext(url_request_context_getter_.get());
+  else
+    fetcher_->SetRequestContext(request_context_getter());
+
+  // Use |request|'s referrer if |referrer| is not specified.
+  if (referrer.empty())
+    fetcher_->SetReferrer(request()->referrer());
+  else
+    fetcher_->SetReferrer(referrer);
+
+  // Set the data needed for POSTs.
+  if (upload_data && request_type == net::URLFetcher::POST) {
+    std::string content_type, data;
+    upload_data->GetString("contentType", &content_type);
+    upload_data->GetString("data", &data);
+    fetcher_->SetUploadData(content_type, data);
+  }
+
+  // Use |request|'s headers.
+  fetcher_->SetExtraRequestHeaders(
+      request()->extra_request_headers().ToString());
+
+  fetcher_->Start();
+}
+
+void URLRequestFetchJob::HeadersCompleted() {
+  response_info_.reset(new net::HttpResponseInfo);
+  response_info_->headers = fetcher_->GetResponseHeaders();
+  NotifyHeadersComplete();
+}
+
+int URLRequestFetchJob::DataAvailable(net::IOBuffer* buffer, int num_bytes) {
+  // Do nothing if pending_buffer_ is empty, i.e. there's no ReadRawData()
+  // operation waiting for IO completion.
+  if (!pending_buffer_.get())
+    return net::ERR_IO_PENDING;
+
+  // pending_buffer_ is set to the IOBuffer instance provided to ReadRawData()
+  // by URLRequestJob.
+  int bytes_read = std::min(num_bytes, pending_buffer_size_);
+  memcpy(pending_buffer_->data(), buffer->data(), bytes_read);
+
+  // Clear the buffers before notifying the read is complete, so that it is
+  // safe for the observer to read.
+  pending_buffer_ = nullptr;
+  pending_buffer_size_ = 0;
+
+  ReadRawDataComplete(bytes_read);
+  return bytes_read;
+}
+
+void URLRequestFetchJob::Kill() {
+  JsAsker<URLRequestJob>::Kill();
+  fetcher_.reset();
+}
+
+int URLRequestFetchJob::ReadRawData(net::IOBuffer* dest, int dest_size) {
+  if (GetResponseCode() == 204) {
+    request()->set_received_response_content_length(prefilter_bytes_read());
+    return net::OK;
+  }
+  pending_buffer_ = dest;
+  pending_buffer_size_ = dest_size;
+  return net::ERR_IO_PENDING;
+}
+
+bool URLRequestFetchJob::GetMimeType(std::string* mime_type) const {
+  if (!response_info_ || !response_info_->headers)
+    return false;
+
+  return response_info_->headers->GetMimeType(mime_type);
+}
+
+void URLRequestFetchJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  if (response_info_)
+    *info = *response_info_;
+}
+
+int URLRequestFetchJob::GetResponseCode() const {
+  if (!response_info_ || !response_info_->headers)
+    return -1;
+
+  return response_info_->headers->response_code();
+}
+
+void URLRequestFetchJob::OnURLFetchComplete(const net::URLFetcher* source) {
+  if (!response_info_) {
+    // Since we notify header completion only after first write there will be
+    // no response object constructed for http respones with no content 204.
+    // We notify header completion here.
+    HeadersCompleted();
+    return;
+  }
+
+  pending_buffer_ = nullptr;
+  pending_buffer_size_ = 0;
+  if (fetcher_->GetStatus().is_success())
+    ReadRawDataComplete(0);
+  else
+    NotifyStartError(fetcher_->GetStatus());
+}
+
+}  // namespace electron
added in remote
  their  100644 78b819d068f2c0fc0845739b728c95a0f6d37799 electron/browser/net/url_request_fetch_job.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "browser/url_request_context_getter.h"
+#include "net/url_request/url_request_context_getter.h"
+#include "net/url_request/url_fetcher_delegate.h"
+#include "net/url_request/url_request_job.h"
+
+namespace electron {
+
+class ElectronBrowserContext;
+
+class URLRequestFetchJob : public JsAsker<net::URLRequestJob>,
+                           public net::URLFetcherDelegate,
+                           public brightray::URLRequestContextGetter::Delegate {
+ public:
+  URLRequestFetchJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // Called by response writer.
+  void HeadersCompleted();
+  int DataAvailable(net::IOBuffer* buffer, int num_bytes);
+
+ protected:
+  // JsAsker:
+  void BeforeStartInUI(v8::Isolate*, v8::Local<v8::Value>) override;
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // net::URLRequestJob:
+  void Kill() override;
+  int ReadRawData(net::IOBuffer* buf, int buf_size) override;
+  bool GetMimeType(std::string* mime_type) const override;
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+  int GetResponseCode() const override;
+
+  // net::URLFetcherDelegate:
+  void OnURLFetchComplete(const net::URLFetcher* source) override;
+
+ private:
+  scoped_refptr<net::URLRequestContextGetter> url_request_context_getter_;
+  scoped_ptr<net::URLFetcher> fetcher_;
+  scoped_refptr<net::IOBuffer> pending_buffer_;
+  int pending_buffer_size_;
+  scoped_ptr<net::HttpResponseInfo> response_info_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestFetchJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_FETCH_JOB_H_
added in remote
  their  100644 0db713e4b752a4c58c8edfbc0911b09a2a163206 electron/browser/net/url_request_string_job.cc
@@ -0,0 +1,59 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/net/url_request_string_job.h"
+
+#include <string>
+
+#include "electron/common/electron_constants.h"
+#include "net/base/net_errors.h"
+
+namespace electron {
+
+URLRequestStringJob::URLRequestStringJob(
+    net::URLRequest* request, net::NetworkDelegate* network_delegate)
+    : JsAsker<net::URLRequestSimpleJob>(request, network_delegate) {
+}
+
+void URLRequestStringJob::StartAsync(scoped_ptr<base::Value> options) {
+  if (options->IsType(base::Value::TYPE_DICTIONARY)) {
+    base::DictionaryValue* dict =
+        static_cast<base::DictionaryValue*>(options.get());
+    dict->GetString("mimeType", &mime_type_);
+    dict->GetString("charset", &charset_);
+    dict->GetString("data", &data_);
+  } else if (options->IsType(base::Value::TYPE_STRING)) {
+    options->GetAsString(&data_);
+  }
+  net::URLRequestSimpleJob::Start();
+}
+
+void URLRequestStringJob::GetResponseInfo(net::HttpResponseInfo* info) {
+  std::string status("HTTP/1.1 200 OK");
+  net::HttpResponseHeaders* headers = new net::HttpResponseHeaders(status);
+
+  headers->AddHeader(kCORSHeader);
+
+  if (!mime_type_.empty()) {
+    std::string content_type_header(net::HttpRequestHeaders::kContentType);
+    content_type_header.append(": ");
+    content_type_header.append(mime_type_);
+    headers->AddHeader(content_type_header);
+  }
+
+  info->headers = headers;
+}
+
+int URLRequestStringJob::GetData(
+    std::string* mime_type,
+    std::string* charset,
+    std::string* data,
+    const net::CompletionCallback& callback) const {
+  *mime_type = mime_type_;
+  *charset = charset_;
+  *data = data_;
+  return net::OK;
+}
+
+}  // namespace electron
added in remote
  their  100644 bbcd1cb6a88fe96e3544152fa9f62efdfb4a51d3 electron/browser/net/url_request_string_job.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
+#define ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
+
+#include <string>
+
+#include "electron/browser/net/js_asker.h"
+#include "net/url_request/url_request_simple_job.h"
+
+namespace electron {
+
+class URLRequestStringJob : public JsAsker<net::URLRequestSimpleJob> {
+ public:
+  URLRequestStringJob(net::URLRequest*, net::NetworkDelegate*);
+
+  // JsAsker:
+  void StartAsync(scoped_ptr<base::Value> options) override;
+
+  // URLRequestJob:
+  void GetResponseInfo(net::HttpResponseInfo* info) override;
+
+  // URLRequestSimpleJob:
+  int GetData(std::string* mime_type,
+              std::string* charset,
+              std::string* data,
+              const net::CompletionCallback& callback) const override;
+
+ private:
+  std::string mime_type_;
+  std::string charset_;
+  std::string data_;
+
+  DISALLOW_COPY_AND_ASSIGN(URLRequestStringJob);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NET_URL_REQUEST_STRING_JOB_H_
added in remote
  their  100644 e65cfb2c1c3396fe6c7d9552fad32770644aa309 electron/browser/node_debugger.cc
@@ -0,0 +1,203 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/node_debugger.h"
+
+#include <string>
+
+#include "base/bind.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/browser/browser_thread.h"
+#include "net/test/embedded_test_server/tcp_listen_socket.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace {
+
+// NodeDebugger is stored in Isolate's data, slots 0, 1, 3 have already been
+// taken by gin, blink and node, using 2 is a safe option for now.
+const int kIsolateSlot = 2;
+
+const char* kContentLength = "Content-Length";
+
+}  // namespace
+
+NodeDebugger::NodeDebugger(v8::Isolate* isolate)
+    : isolate_(isolate),
+      thread_("NodeDebugger"),
+      content_length_(-1),
+      weak_factory_(this) {
+  bool use_debug_agent = false;
+  int port = 5858;
+
+  std::string port_str;
+  base::CommandLine* cmd = base::CommandLine::ForCurrentProcess();
+  if (cmd->HasSwitch("debug")) {
+    use_debug_agent = true;
+    port_str = cmd->GetSwitchValueASCII("debug");
+  } else if (cmd->HasSwitch("debug-brk")) {
+    use_debug_agent = true;
+    port_str = cmd->GetSwitchValueASCII("debug-brk");
+  }
+
+  if (use_debug_agent) {
+    if (!port_str.empty())
+      base::StringToInt(port_str, &port);
+
+    isolate_->SetData(kIsolateSlot, this);
+    v8::Debug::SetMessageHandler(DebugMessageHandler);
+
+    uv_async_init(uv_default_loop(), &weak_up_ui_handle_, ProcessMessageInUI);
+
+    // Start a new IO thread.
+    base::Thread::Options options;
+    options.message_loop_type = base::MessageLoop::TYPE_IO;
+    if (!thread_.StartWithOptions(options)) {
+      LOG(ERROR) << "Unable to start debugger thread";
+      return;
+    }
+
+    // Start the server in new IO thread.
+    thread_.message_loop()->PostTask(
+        FROM_HERE,
+        base::Bind(&NodeDebugger::StartServer, weak_factory_.GetWeakPtr(),
+                   port));
+  }
+}
+
+NodeDebugger::~NodeDebugger() {
+  thread_.Stop();
+}
+
+bool NodeDebugger::IsRunning() const {
+  return thread_.IsRunning();
+}
+
+void NodeDebugger::StartServer(int port) {
+  server_ = net::test_server::TCPListenSocket::CreateAndListen(
+      "127.0.0.1", port, this);
+  if (!server_) {
+    LOG(ERROR) << "Cannot start debugger server";
+    return;
+  }
+}
+
+void NodeDebugger::CloseSession() {
+  accepted_socket_.reset();
+}
+
+void NodeDebugger::OnMessage(const std::string& message) {
+  if (message.find("\"type\":\"request\",\"command\":\"disconnect\"}") !=
+          std::string::npos)
+    CloseSession();
+
+  base::string16 message16 = base::UTF8ToUTF16(message);
+  v8::Debug::SendCommand(
+      isolate_,
+      reinterpret_cast<const uint16_t*>(message16.data()), message16.size());
+
+  uv_async_send(&weak_up_ui_handle_);
+}
+
+void NodeDebugger::SendMessage(const std::string& message) {
+  if (accepted_socket_) {
+    std::string header = base::StringPrintf(
+        "%s: %d\r\n\r\n", kContentLength, static_cast<int>(message.size()));
+    accepted_socket_->Send(header);
+    accepted_socket_->Send(message);
+  }
+}
+
+void NodeDebugger::SendConnectMessage() {
+  accepted_socket_->Send(base::StringPrintf(
+      "Type: connect\r\n"
+      "V8-Version: %s\r\n"
+      "Protocol-Version: 1\r\n"
+      "Embedding-Host: %s\r\n"
+      "%s: 0\r\n",
+      v8::V8::GetVersion(), ELECTRON_PRODUCT_NAME, kContentLength), true);
+}
+
+// static
+void NodeDebugger::ProcessMessageInUI(uv_async_t* handle) {
+  v8::Debug::ProcessDebugMessages();
+}
+
+// static
+void NodeDebugger::DebugMessageHandler(const v8::Debug::Message& message) {
+  NodeDebugger* self = static_cast<NodeDebugger*>(
+      message.GetIsolate()->GetData(kIsolateSlot));
+
+  if (self) {
+    std::string message8(*v8::String::Utf8Value(message.GetJSON()));
+    self->thread_.message_loop()->PostTask(
+        FROM_HERE,
+        base::Bind(&NodeDebugger::SendMessage, self->weak_factory_.GetWeakPtr(),
+                   message8));
+  }
+}
+
+void NodeDebugger::DidAccept(
+    net::test_server::StreamListenSocket* server,
+    scoped_ptr<net::test_server::StreamListenSocket> socket) {
+  // Only accept one session.
+  if (accepted_socket_) {
+    socket->Send(std::string("Remote debugging session already active"), true);
+    return;
+  }
+
+  accepted_socket_ = std::move(socket);
+  SendConnectMessage();
+}
+
+void NodeDebugger::DidRead(net::test_server::StreamListenSocket* socket,
+                           const char* data,
+                           int len) {
+  buffer_.append(data, len);
+
+  do {
+    if (buffer_.size() == 0)
+      return;
+
+    // Read the "Content-Length" header.
+    if (content_length_ < 0) {
+      size_t pos = buffer_.find("\r\n\r\n");
+      if (pos == std::string::npos)
+        return;
+
+      // We can be sure that the header is "Content-Length: xxx\r\n".
+      std::string content_length = buffer_.substr(16, pos - 16);
+      if (!base::StringToInt(content_length, &content_length_)) {
+        DidClose(accepted_socket_.get());
+        return;
+      }
+
+      // Strip header from buffer.
+      buffer_ = buffer_.substr(pos + 4);
+    }
+
+    // Read the message.
+    if (buffer_.size() >= static_cast<size_t>(content_length_)) {
+      std::string message = buffer_.substr(0, content_length_);
+      buffer_ = buffer_.substr(content_length_);
+
+      OnMessage(message);
+
+      // Get ready for next message.
+      content_length_ = -1;
+    }
+  } while (true);
+}
+
+void NodeDebugger::DidClose(net::test_server::StreamListenSocket* socket) {
+  // If we lost the connection, then simulate a disconnect msg:
+  OnMessage("{\"seq\":1,\"type\":\"request\",\"command\":\"disconnect\"}");
+}
+
+}  // namespace electron
added in remote
  their  100644 8e650804fbb843ed07f8a008016042708f7d35ed electron/browser/node_debugger.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_NODE_DEBUGGER_H_
+#define ELECTRON_BROWSER_NODE_DEBUGGER_H_
+
+#include <string>
+
+#include "base/memory/scoped_ptr.h"
+#include "base/memory/weak_ptr.h"
+#include "base/threading/thread.h"
+#include "net/test/embedded_test_server/stream_listen_socket.h"
+#include "v8/include/v8-debug.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// Add support for node's "--debug" switch.
+class NodeDebugger : public net::test_server::StreamListenSocket::Delegate {
+ public:
+  explicit NodeDebugger(v8::Isolate* isolate);
+  virtual ~NodeDebugger();
+
+  bool IsRunning() const;
+
+ private:
+  void StartServer(int port);
+  void CloseSession();
+  void OnMessage(const std::string& message);
+  void SendMessage(const std::string& message);
+  void SendConnectMessage();
+
+  static void ProcessMessageInUI(uv_async_t* handle);
+
+  static void DebugMessageHandler(const v8::Debug::Message& message);
+
+  // net::test_server::StreamListenSocket::Delegate:
+  void DidAccept(
+      net::test_server::StreamListenSocket* server,
+      scoped_ptr<net::test_server::StreamListenSocket> socket) override;
+  void DidRead(net::test_server::StreamListenSocket* socket,
+               const char* data,
+               int len) override;
+  void DidClose(net::test_server::StreamListenSocket* socket) override;
+
+  v8::Isolate* isolate_;
+
+  uv_async_t weak_up_ui_handle_;
+
+  base::Thread thread_;
+  scoped_ptr<net::test_server::StreamListenSocket> server_;
+  scoped_ptr<net::test_server::StreamListenSocket> accepted_socket_;
+
+  std::string buffer_;
+  int content_length_;
+
+  base::WeakPtrFactory<NodeDebugger> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeDebugger);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_NODE_DEBUGGER_H_
added in remote
  their  100644 21c02d74e2372989ce170a00fc5684ee1e119618 electron/browser/resources/mac/Info.plist
@@ -0,0 +1,36 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleDisplayName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundleExecutable</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundleIdentifier</key>
+  <string>${ELECTRON_BUNDLE_ID}</string>
+  <key>CFBundleInfoDictionaryVersion</key>
+  <string>6.0</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>APPL</string>
+  <key>CFBundleIconFile</key>
+  <string>electron.icns</string>
+  <key>CFBundleVersion</key>
+  <string>0.37.3</string>
+  <key>CFBundleShortVersionString</key>
+  <string>0.37.3</string>
+  <key>LSApplicationCategoryType</key>
+  <string>public.app-category.developer-tools</string>
+  <key>LSMinimumSystemVersion</key>
+  <string>10.9.0</string>
+  <key>NSMainNibFile</key>
+  <string>MainMenu</string>
+  <key>NSPrincipalClass</key>
+  <string>ElectronApplication</string>
+  <key>NSSupportsAutomaticGraphicsSwitching</key>
+  <true/>
+  <key>NSHighResolutionCapable</key>
+  <true/>
+</dict>
+</plist>
added in remote
  their  100644 dac213ed9d8c096d0b8c3a8848b1d3c4ab545059 electron/browser/resources/mac/electron.icns
@@ -0,0 +1,3373 @@
+icns+������������+���������������������+�������������������+
++`�c�tW���U]]]�_J��5�����x_�k�}����5��������-����ɕ�PCW$r\��`��l_�x/���D{���-�5JW� ��t�c�Nw(�Ѧ���GZ��n�[��q`���:th�_��_L��K&755M2d����ׯߠ���555WUU��]]]�:;;�u���h�q���u�޽{�m۶m�%K���_������x���|����q��]0x���G�p�-����O~f����liiY!C�Ȉ]��".�)��(�ә�H�����	�,����T�aCFϰN��O��O�o���[/U�>G����-h�h�!v����C=�����])���e�с���R�My{���>D���_�p͚5_;r��K���]�=���ݑ����;���%dCFdՁ���Q!z�d}�d
+�Vz�<p���3hР+O��V���ѕ*>�>آ)]��Ϊ���թ�*uiL�RCK�8V�m�:l��T8H�!�Q�A�z=��{�u�c�<xp��O?�m]&��^���Bo��H�~�d�ט�{�k.\�uuu�'��o�Ȼd�fW�o �Ș�0�gʵf\��*��
+������R��j�҈~�*D���?��7�����O�A��ȗX(�����xgD�"�@��/�u޼y(���K��Vݤmj�J:�Ի=S�d+S�:m��0��2+/���U�ꄣ����<tp��r��r���٤}�Q���/���_��`v�h�ec�����Gwܯ7~��_?���o�J���/F����[�g�Ooo�Ԑ+��L�2A�˽�XN5��j0$��\ܰQg�ʺ@�P���?�*�;;S��#��ԊF���[8|���������e���3��}GB=�`x���MR��ǎ��k1teب��Fw�\�ݐcƖqh���ML8C�e�;)p�.R����-���
+�k��ĺ��9G�֭[�s�m���E�m)����5��6xF�?���N�Z�kJ����I�v���'G�0�����$��$t2��&'�p�!�c@ٯ�%3�T*�f�d���"O�Vו���>�ylե��p��
+GxGF��ߎ+��?쌳��h����$���-]��9s��g5��R8����-UZ-qE�AM�:�b��J+/eRʶ9��\o����r��ו��ɜ�uHG(��:����dOS��'0>^I+=b���J_O8_N0�{�B�"R��/��W��*ޢ���KP�$������r��?�<y��t1̆���J[�݆�³B�3�����c@��ԺB�����L�hԂ�(���u�&3�oD��Y�.W�Џ�J��F��緔l?����F�#;�u��}}֬Y/��:xy���|:t1�+��X^N�x	M	�M�ˍt��i@�H�� �P�d)��t�zA+��#\���u���$�F��*m��ʸ��C(��[��ьnr=mB���d�t���_9�j�>�3�<s۔)S��0>1�_|�*������FDy�0WF(�&��(�
+5-Z/GI���2�M�h�x�[7�^DQ�0(�����.��e��r���l����R�lke'�Ӈ����g-��2��zL��6�L�.ѩ��u�cZpJ�NE����t�=�|@���5�$$���-�I�����(��7�8���Y�28�H@ǔ�3�+���P�2��
+(4�����*�アW��$�F��(UX{��y�"�DAy#�y#�Ik8΁*���@{V�C�M5��ݭZ�3�8�.�`�~�ny�H��=�VΧ�ht�����������2D}�$����f��e��2C�[�
+�P/�b�7���]_�
+�B��sf���cX��ҁ�<ϯi;��:�����Vw��tp�����3�A�I�ӿ�kTO	�ϗ�0z��J�3��+�	`�V��c~��j��ɗj��/���[�lN�%��M�ɟ,�ÃO�ד�˖-�V}}�yA��=��=j�7��,Ea-0A�b�	'�ZFu$��LQ'"@���T���%��p݀������/M5[�����,H�g�J{Y�E>��%A4tӸ�w�B04ʢ�/��'���`	�:��B�QO�u���h;ܲs�=�sz����X6FFB�Io�I����LL&k��K�Ǐ�L�F�m����&[�G\��{L{��nN`�R5�f+��(`���묞ۼLX��C0�ܬh@�I�7�K�^]�tT�P_��o,a���6�_ktl��fYL&d�?s,�`�ʰ&�AeI���`Pެ��q�ե4B�>m~��e1�I�o�s���v(��p��:+��1�	����]�;������4�;��iڢr�߰ykjhoI�k�l!��z�)q�S�N�"��Li�e}�g��N؊�/�����Y�ӓ�T�S�D@�����~O��:��[��[A�����|�ĉo3ë��d��Z��Yo��P�j�'
+�KJ� �<�����:��`s+LU�j
+7h�S�t	�JJJr]P6P��r��LP��Q��]�M;�����7�56%�9d�)6���G���7�a�i��1��قl�L�(�NΨ?+�x��JXi*��;��y�ЛQ6�X���w�i�(Bmm�/�p�&�kU��vCs�+�Z�?�(ۨ[�u�p"+��Z�6	NгCi�1�:aXzO�fì�պV�����ƈg�\u�!���G�s�;���G-N���Fiku�6A��\@���a�� ��R@"E[�6��.�Z@�����تF�m��[�n�N�@n�>����I��6!����1�si�	��`i����v�@c���|o���=P0#k����5ja{�kޟ�����wlMGw�������hsjR�m��8#�jR]{��#CvX��!B�+��<�A�pO���C%������mn����ꠡ�T���	����?��?�N�4iBl�H�4�i��V=҇u�6�d�FXo0%�1�iq��wI�4���e�Ζ��UkҺ���6&gy�^tK��rT��0t�&wÆ���{�o�0h�]��BNe��9L�m��̺5ܸi�M�.^xqz��GM�Ͼ�<͜{NzbѢ�t�
+�CI#��0�r��qiƴ�iʄ񩵪&���H�\�E�ڇ���3S"d���v��t��� �]Dz�\{�U;�������Ϯ����W�:�½�p<@<��qƌ7�z�
+���o�(�!m�@C���0J������Ő��-��V���d���ukK��j�Sv���رn�������_}�(�`Ј�0ޠG���[�mM��ߠ��Miˎ�S0����67N�H�X�6n�&���F��M-G��]����/���4��;cF���KRkm��l�|��ڍ���.	�G�cѴn%��
+�Uf�<D��uj�!��k)p�c����$����c���C�Y���jV�,@q���!���1���
+�T�i��L��,���"�H��=��tσ�7w�)��^$MC���9��aõx3P
+���9R[�q�E6|x�{ι��-&T1R���k)�eߞ����駏>�����=8�|�I�>Q2r��F���ٌ�wss���K44��sT6�9q���3m��fZ�'��Lg�lL-�h�8�GVԄUl�� (3���G��)5Yr��ڑ���2���U��P�PY�y�[��O=�����g��wvV������s_SJ�c��D��!Ȓ�g�9M�g�>�Hz��šu�?>M�25�7!:�/7���;+���k��hm	~�W�����^����zqK�d�p�K+q1ts*��٤�@���Ah�5%����P9j��gU�ʞ$e_x�e��G�e��\/-�L�9u��$�`)��+ғ�>g�p������Yg�M3�1�. +�FD�F�r��8IYqS��-[RG�&�5����]�9�eW]��u9ڹ}�.���K��k���+����eD(�VZ!�Sґ� �)҉O��1';A�?��?>Gt�g�cN��2`¾��M��B�!f�*F+�VAAB[��
+�l�bq�#�@��	N��g�4�ڠIV�͞ڐ�����IQ��%O��vEw{�lJ���;��O>���`/��\y����t���S]���N@�K����%�iLS�x�F,��)�����f�&��^y��!���ט� ��R�g���`	wrTj�p6�Ćey�wj`C�8�;�<��`CG7��O}�+��ו����Xe8+N�[�oKs�s��.��R�F�2 �[k�����~�͙��r��w�L�<K�2a�]0��c���o��f�N�*���Y+#d��������-��E�ˮ�&M�<EE�ʆ4���2�Ο����n�Sg`�>�E����̭<ԃ)�b�t��fT��`���n۞143�Z@���@��NA)#�I�Ti��c`���;Rئ+?R�W��f�-�� *A�Ӣ����B<�©��4Q�%�d7�����m�^V�0l�<=E8���R[�lX=�w�ڛ�c{c!hAO�4������J�NO�7j�o�-^�
+�&�9���M��Y+W��fi�\bW>�]�7�z�H��4���@T�g�3p!�ܟ���k�u�ԍ�hu���&"�M�,��9\^k�: o��`��)Юl���`;�o���6T�9���Q�P/|�d��Q�7���I�6"d\o*"��<����j	���U���7X�Sϯ�Hw��>3���~�����������/F/h@������9}.��(�$��Hgʆ�h@�Р����+z	T������P�a�C��!�O�H��.�ՀP@l�tC�
+�8���+5��u��G�)��/�����Ľ���`�:
+삋/��kЀM\-�aJm�c�Q��*����z$l©�ڔc��L�����oVv�f���CS�����6nՊ�I�t�~�*�<�� �(W��/	��?�N0�M�*�8GɁE���o`FVX��m�e^�v(���+(L�ԫ#,W���V�>����7Y1�.��*��s������3U��aJB96��@�x7��M5��R�6�4�W~_��Q
+��>�w��[j��~
+�db�����e�Uɧ�{^� Sg�3�|Ӆф�r~��c���w�b~0n/��I�D��6�vg�1%�Hx�ϽM�X���9@ �K����܉<#H)�Q@��5�+�bY)}<�ܦ�����ҧ��.���ҲmX�[Èi�`���i6%�.�W&�<h!��� �,����i�|-�zAȣ�`a��\��n&���Pm�$ok�Q]N6��6lڜڎ��|�hr���d���B+VlE���=*��hIW��=�5��9�/H;u�^��)����ӭ�~ �ѷԂԍq�#4�,�
+pW��W\�ݳ����u�V���_t���-o��
+�֟�;�V%�	\%�8d��SV�.��4��1�N�Ӑ��LN�y ��B��)��L�+�B�s�-���+p�ut/����q�nsJ+�i��H�8��v+r"Z��z�{Y�_$�r,�}�}���Q����,0�9�y�=-��f���k'C��IS�\�C�_���39�H-��$T�%�YtFT%�%ᠪ\���������ʔ ��6����<4����@��H�\
+����ElTC�2��pc;�l|(8���A��<���2��Xi�Xx$P���PT�VQXB��b��}�p+7H+�<i0���J�&�N��!��^���v�*���l
+y��V��Q�4y�t�+�����m��Ҿ~9�]z}{����pPt�
+��]>�A��%P�44HS�eȔ�vI�z��h��&OB��Rlޡ��va�F�����oJ�1i�8�v�ŁǑ�U�#k�d,��d�r���:I��]	�)��(����r+?�Q�*87��ߩ7y���˕正�H��E%�TJ{��|��1��)��.i�d,긤7a�	�:�����w��S6��+��9�-[���_�U����Z�3r�b�b�G�1S/��F�Ӫ���S��K��E���52*$�ʹ�t���/uơ0�P�e��2ۅT��2��D�J��&
+���OƬ�v�0n9VT��r����8�h<�|'` �L>��!*^��T���ٙB��Z�z������Ml�M#4�ؚ�`PV7~�i�޼����$�,z�ء5�o~�{��%Ϥ1��C��t�(�F�~!L��mA:��^����=�=D���~@*�n�c�p��XŤ��4��hj�4��Aw/FZ<��`A�=x�H��c)Y�5��#��&!16�+��Ĳ}�Ɨ5Q,84�Q��3�5���}n�/�+b�^y%�ӫ[/\�v��yGXA0��r�~z��jo�r�"]����O.�K��V�[��.5�eϽ���~��}�6�X3G�EmDFV.�^Ť�5RqɁ�{�rV��9m�E������jw7�n��L������M�@���
+Cþ$�䬢�ɱEe���>�=��+��aG(�񬸲��V�ߵ�_���k����ݪWߕ��aa�|ED#���m�Q̾�U˖�g����A-x�n�Ҝ�ǿ�{��!C���֨���������gc4�G�цR��;Ӵ�1i���j�g�c��\�Pl������կ���1zMl����d���F=����?��ݮ�����Cr �9�ַ
+is�g-�J�o���<Vli	q�!\�:�t��;����{�֏K (��8M��w	�ƭ��ثE�׬�* ��;P���tI�Bd2@1���G��IO<��P+f*�KA��������^=S��y#����vh�#܆uo�I��1�6ۊGwf2��.�����]�b�Ԉ�\�ܪ`�c:@_#+Ƅq��e�y��T�g���4J�n>H��n��%ܢM��\r�5zOP��~\�^��@�͌�h�u�Y� Zm�g�X�/���<~~���L�K�,=���!��.��#�2�fh�W�G���=��{/�*�ت��=*��^�s��㪍��ϿV���T�4wx�z`:h��Ҋ���(�BPX��(��f<x��Ү҄�;6U|@�Z���6�eMl�)xpm����?�2�hޮ���Jj1���%��G���՚��M&͚�Y�!�sp|��4B�1|���u2���E2�T�c���w�V�u=вͦ*�,y���tj�m���0Q^�����#֧�:Ҽ���z�����^x�1U���* N@�58�^���bl�:f��ŋ�'�ݿHi�U�r�g��b��l�Mw�K�?���#k'p鹓�3D^r�ui��ən�΃dZ�����P����/}���R���z��^gڹm��O#Q�!���t�&Mv/��}߷A�Zt���+v�r8��-#�� ���_^v�e�����f? ϭ�9� |�8�]
+�rC�\I�7_vU������Ӷ�w?9��O�Fh{�@-�׻s3f�I^~�}��X�c�~�aͪWM��v�NjBٚ��+���a��*�e��&�Y����\_�=��.O�*!}��h�â�|���<ki����.����6n�d��0O��������%�}��!t���%�e`�g���@�3�-�1�N�\�!.�Xs�~�V��K��;u�X��#�Ch�MЎ�F�(+�J�n
+�|���,!�ӻ�E����'�\~��i��>����(}+A��ݳ+�?�:�=pP�<���Ͷ�K+�ٹ3�������A�����Ҏ��|@�^�6l�d���ɠ�&H�qB�L�����Թq�0�n�֨C��$X�#z>���d��.��W�J!��+�X�.͟���闟^f#U�o����oiN?��^=.F���]NΜ=73΀Y�J1��v*uD:�g*'�=�눿�����g�z�]ʾ��ޏ���/�>n��=䖘����5�\s�j#I������JT���R��UFli@���)/�3ܘq��:=�k����bCZ#'�`���Y��ϱ+�C�_o�c�f���2�px��K�"n߶%����z=�}Z��}�	m@ѷ�"&F��q��jG	�ڀ@
+Y4ϸ
+ri�]y�X�ɛc#Pрb������<�o����w�����~��9y]+�������
++X̉
+}�0���#(4��S�l;K��B+�v������>�o��oܡ�X���w+�Gث��V�99d/]���w�@:�.|\x�Ϟܨ�=�cu��&��+���#�h�C4�8��������?x�vMQ�׀)�	p������@Ą��U>�Vs���zA�5Qܛ"c��W���6������cQ�^�U��0~>�,��z���r,;A8B�8+�����;��W\7l+�&�zs�0|�r��:�s������;o����7n���Ç7j��^o4Ц�z��<�:���X�2G��M�vi�r�6d�Z�|�n-_�S9/`��1<��0n�Go�^r[x7:@Q��3`lF�0zeu�s�S�w��4�B��H�	a��1Y�cM�s�8b�Z��,��L��wE��\�»�BА1�	�KD��#1���">a����=7Z�I�Ex҄��wٹR	�2�z�S4"�0��+�B�|1��*�|�Xq/h�+ӕJxW
+هPE�V�q�bY1����cb�HW�u��s�/E���(Ƥ�y�T,뫍aT�èQV������/��}�VLC�2�����+����}����5����o�3|J�,+
++�WW됶�����c�.�Q��[�5��}�	K�,9aʔ)�Ə�D���Ç�:�jp79�M^e�����w�޽F�Ī͛7?�������#���e������k$�	����r&��M�p��W��������OG���w�����y���7�7�7O;��cO�>}��cƌY��:����.-�J�/�)���j�p����o}��o��?}�W�����ϊ�	��B��.ҡ�Jy����.����)W�#��O��O������s�:�7O�4�L-�OЀbRx���8}��7z��ޱc�}6l�����S����_�����&D"���ws�C�e�@��(�^T���S�:~�����<����?��3f�E�3YGQ�X�8h�Ĥ�b�V��Y��n���?��?��[Ԗ�ژH5�lӟ���%y���%	b�ʗ5ػu���_��N;�s~d�̙�6���H�29��Ǜ��{��;�-�~�2<�v��+4\��?�ӷ�M݁_��>�-C��@�QQ�{����)�q[n��	����|�\�^�D�洿]t��+܃���-�k��*�Wy���g�����/^��Q�F-�i�`�_�����?Xy��/��?�t��ޕ+W��'>�}�+_����	5`B�P:@M+WhU�����oVK���I[�nNC���@���P������,�\s�5�u�Y�����f���7`�7����"�v���qX�Q7��D��a�p��Y��R�0^�S�ɇk�\e���uc�wy��=�DL���x��!"��X7��wq������롤�����}梋.�N,L�
+hJ�&P�D�Ci��Ci�(��w7n�M�`�|�UW����O���mw�p�`*GNL���{����4vi�+�0�S�	7%��`CB����RD3L<���ʄ�(���e�=�8E��#�d�e�=&���G��k"��;������m��E�$���-�����PJ=@?�{��B��������+���GN:餏�������P+a����FZx�Q9&��}�{M�������K�H�:���`��+�כs�.�+%����ХboN��DYPP!ش�扲p�fJ�I���f���*�Yp����iӦ�����'?�䓷�y��Ck��;$��ö�zm���8{���@����(K����+����]
+��
+>F�U)W�2�T�`|�SA��Q�/����]�=�%�!ԃ=P�&踷^�x��T���@��9����j��6�"�ٝi7���1���ҨL�����=a�w��D�mE|R!~8����'�٣<0F�N��9%��?�)�3�4�[<*�����th�:��O�j��N�%���o��%�oh�?�ʧ`]���<�G�Z�C���@G2�+���킰j�S,Ȅۈ�aA!�m�U������#�6+��tJ�%��~�g�z�pJ����Ut���M��Gldx����fce3���ƻ��Q��A��t������#�9�D��¬24��sY�qԂ�#U�ڭAQO�AC
+f%:��`��-/aW��򸚮�X�	y�͵��5^H}EM<�+v�D�T+���&��ԄV?���Y���fX3U}t�|��R�9�=�@_�lҭB�
+����/������+p5͋�+Xu�+SW #�KT��<FN])�Bu����d��O�Ɗ.Hkz1lm�		����_+�!�|e}j�~���x�F}��������;����Y[��:��[}����?�&D`�,N}o3���Op-Wi_  #�"8\@���'Xk ��H���`�99�#y,%J�_,�[y�\���CH��H9ac��QE��݁	}ѡ'9��5�K^d$�?a�ʅ���~h����S��#x)���u�F0�j��e�}�z�u-������f�������}��u��Z	��X��A��x�&w��k�-���j�]�p�[o��/&N�x��O�ܬ���.�9*�*83+oe��6��]h�ǋ �A��^*�I>h!"�z_�b�B}�ud�`nQ1���r��:�և^Ӥ����U-`�>��������u���a�Qq�������㏯	36$צ����9a_m5���pŊ��v���#��{͍[��%$��D%
++�0��%K���~���u��T�k��j���}�}��U�q��j����z�����]�v��q�@�`�CP�!�A2I��
+��K%�r�}ю"W��	;<D�Q	���͓�6c���d!�r�ן,O@��v��+炦���z�%��:7����/��Kȫ�P��)[`@�%���ې��]����ޓ��JS�ԫ*��
+�=�|
+"U���=��׵�͊x�t]�U��?FL
+�@1Z���T<���:TW��ȹ`9OOe������<I������6��Y?��C�$���%��G��PTU�Iv�����$�`R�m@4	�r�a�b/�8��L0�R0^wxX��ۡ
++
+<�YH�V̀6E��&	�H1"�H�6�D9�[mVY�f�J7P)�6X>vH>܁��)_`n�
+n�r?Ԥ}ݩ�y7����:��~:"��
+%�Ԟe�Ą炵B�J���F����Z-��; ��Vt�=m���Ħ��i#VU��.�V�q��Y6����8t�u�]���K����PQ�[Z�}7��>y_�D��f��2�q,P�_$�鎯2ylH��Do��-����^��6e������[Xې6���<�-@4ŊӲ%�L�]�6�Ϊ�b��P��"��Q6�jV��CU�.��fUm3��mG��^&9\�g���(?~��6Q�ʩ�Ի�fΰ*Hʼv�bGL���+�hZ���ͺ;�\�Eo��ܱl�er��̜2�I�
+4W1KQ�vX���ʶr����9_����}�g~�@-��߮�  %��qG�/X��'{��E@LE�D�-���a�*C�I�c��΄YW�-AxOD:��䍀��K+=���P*��D"���	,��I����8	�&>�t�
+i�-eW�T��S��S��f�M�|���%��.3�J{���d�]4&�4�Ī�y��&��0K��%a���I5��g����ͅ�u��TǍv e0�^�����o�+���Y9�l:���c@��>�F �L��KYm_
+ֆ_
+*�!G{t��� !�ʶ�P��C	��(2����;��g�3��ik�'I�#�P��J"��o*kQ)��BY�����j�eR��S�3*�h����D��q�{�˼R(X���,��)R?Е~�1X;�U,_���j�?V2Z�!/U9�i��'�ޡ�6M�F̝��6N+�+����lg\5���+/�mF��"DY��\�����F���n'3�$�!��o���_m���."��a���	g��s�i�~��-J�J�2�P����cP��I��k�.���������WXBtX�2!!��!�/E�\ � 7�e�)t9�\�A�2���p�BV��ٗ�P/I���xx<\�'��&i��5����y,�Y��Y����/4;v�jƏ+�>��I+:��Coa�;�cX�P/�6VEk;%�ʶ7uQֶZ���W��f��S)�(�8o�U�UM��WUe����9�������+W��I�&]X��7���O���v�]��#��M����e`�`�:��q�E�	F`x�n�$�!Lf���d^�%��j�LL�₴Y��卶�]�r '�}�v�b���S4\w��ͷn�ٓIj���Z٪r��mo:���3��5ļ'�7ӻUҕ�_���S*
+��Ͷ7�ø��9�������D��8A�7X)�k�,Q�8z1�A �!���Qې�V�EX&:�ҷ�e�F�2v�u�;]�n��ſڹ�$Н+�j���+�ز�\��S�� ����2��DLۂs=+)
+с��U�܂Ԋ	G@ЗO�:��Q����F�ӛ�]��,�dokA!"H5D̢n�7�IX�kY%;�G����p�-����nv�#s��/�J\9bD�d�<����_�fq��ρ�C=�y�X�v����k ��T<!�*L�]���TP���`FQp���'�b�>*JF��dh��չ�B=��%O��I>���Ն�3g����]v�e|a��	����Zd�W;���c�=�ܣt���u�W|ˉ�cd�ɿ�m��+�v�aNG�(��8�eR��OzÂΰ�7�#0Eo����Ad^լ7��|�z����m���ҟ���r�/;	��74�j�o�Ab�#F�hf͙�̙;�eLh̀@��7��lۼ1�aH:r��	G1�+�+�!�l��+�O�h("�jB�ǁ��}��s2`��y|��?�nʔ)'�v߹�kxT������^A�'�WP~W4>�n����f�ʯ��o�<�V�&�[� �..�����;Kg�~�D�^��G��m���#r"�T0@� 
+J%ٷ�5LP
+
+��"�JІTl%LL�r�\U�������+�Ԑ�0t9�5m�%}��ٸi�m���s�=7�m+�%�ݬ4,5�V���4*v*ӷ~����$��S�����	(�n,	�a��M��5���r��я~�G�5[U�S������'��+���@#�����W\�>}��rN�©3�l����S�'�.{��@t�Ν%���QڛPt�l�Q{�+N�EE-,��ҏȓ�ΰ�j>���ڶ�d����}�g;ms0��X���r�'�"�U�?l��	�h����/�؎�Aq;2�0�<�n�2,�~�v�ߦ���w�(W�F��p=C�������X�qD��m�+��Fu7�袋�q����#+��+�J�a;�a�~t���|�3Wj���0��ʳ寐t��[��F�xι��?�s��R���k���#S�Yx+��h=z�f���W}ޫ�>���SO��)���-W�@�1\ņ��3����+G&�l�Sb�|�a_I+�IzD�����<,����)ؗ����Ǭ�֡F.[w�'�X��#F�Xԡm� Ϭ�o�C�����%��"<�6&-�-"�Ò*�Z^��T� ��(��S�C�� ��6��$�C9��.�cY�y����鰛�2�]Xea�����|�$o������ov��9�WH�J�9��.��9�ef�?H�tq�7��y��U�N7��؇~�1~R�^��W�En{r�EE��5ZzXYԩ��@��]Aih�L�p�]�cJܖg�8)�����P�����j�=l]z��.�,="|�ng�b���)��G�1�nذ�>����ze�bA�0�^��J�+II��e�𠆲w0�V�o�a�����-mDD�c�~���f!tSV�cC^/�
+J:0Nյ�G>���?�ꫲ
+p�����!����9�.��:N?��y=���]� �k����,I����<`< "���,�?�'@!�=��ʷ�U��@��4h�'p(����P�!i�'�;8�a�)��Z�,70���Ö�W��O,]}U.��#)�Q��r^�s��=�[Q�/�E�MO%M�i�.(�h�q�ך�z�(RQ�5O>�y�[.lV�
+Hށ"��OE�P~S!�)��Qe+��:z�Ȟ��")�L�cdt��K�d��������"����+�ۮذ�Ƙ�K�"~�	H�ǌ�\�w5#G�K�{������UW7#�J�>�^��oL��N�埍�S��N)�N���萖��C�����+%�`��yeI="������m�_���
+(D�֕��B�r��yf����
+���t��"4BZ��'�i?	t�e%3�q��7V۪GW��K�qئo�x�b���Op�ު��
+��[�p�m�+H�w��0�C���ΤȠ`�8��r"P�uj�j����<g(��T+���#U���&ѝ���d�.�-C�h�b1L��uW�^�U'��-3���J�#���V+*����#�RO�+���/[d
+d��؛�	B�m2`�Ñ~]+p�D03ا���$�	
+r΋�*�|��s\�.+J��Q>V�8�x'*�,9$�����ov`�یi��	�=-4����Oj���r+����xXZ�<E���j�,ѳyLF�^MJ*�|�ް�����z4J�#U�C���KM��65�e&�z�q��V9����l�p\��8���P��I���E�EkϘOݕ<v,r��S"�2�$%>>j�������*+�2�l{����4�=�9��[�^�ŷ�٤o��a�f��m�b�U��];�Q��>Z�ոŦ���董�Θf��O�:����uFjP0��2�D�X�����Dh�ʞ��TF���؍�i���<�;�GI �Uh'��~��E��y�4��|2�*S������f�v�����4�m�O�ݬG����X��v���&襣�z�`�6~�̓!B�٬�����Gb��-ػ�m9���꾢OMG��Ob�8������p�
+a�^�;[߁T=09�����X���	Ж���"��r��`|�U!My�9�A��I/��>���L��'?�L5�+F���춶B ���@�+Y�'����y�z��W�T��������nuk
+:0Z�e	�`�CD����&�ΆT�r��H+�Hvh�z��JGA���أ���n����7�Ѭz�I�H*,��i��)w�*�JU��`�u�q˗��g��h⬽%�8�=SG��J.<��_�o��t��e�Lط��^s�C+��u�M�2l(�Y�<}�~fl��0�y��t}Co
+G[!������S��:��F}h�	~R�{+^9o2)�v�|�d�l]h�)o!�B����6�;e��~V�E�@0���� ��I��.��Ip$#4'�OuvN+ѭt��gΕx��?�z��͆
+b�J�%�9n��f�>�5u�.p�E����H]���+��)�x�v��=J�C_�ݪ���74^X�l���"�|���w�GO�-Q���I�ZA�L#wR�N��vp�
+�|��n������}�nZv �I-�SH�%?�>_Ę;o���Y��&�.��|��uZ���꧞h^���j��;�}��f�V6�o6>/��zsFR�,c�I�q�ys�������I���Z	l������,K;��?�{P�b�ܮ Զ��g!"�w;�?��ڀAjOa�a�6�k���1vgK\/ޯZ��s��~��Jov��^̼H�s${E��VG~�J�G���~��w��0�<[*�O<��~�ˉ�H@��T���q��d�YtZ����ѥ���C��g�Hl��!�Z�(&<���G#0S5P��ͥ��7-�e�4Ȼ��&5��,i�Z���>m��8S摙��Mј�J|��N����7<���`�=w����R��̤F
+&�UD\ț�e�X|���<�Ps��kՅ����<X�ǎ;�9�3��-���[t����]{~�'~�3���q��z��'��ʌ��e��uu��'�']e�aO���|���.��9A��ݶ˟���Oa��<-^u�P$��UBy|���;bF8�A�l�h"A+��MG��T��K���:}Ԯf^�-�ֶ,�c!O�T��;w��`�5a�;q
+�A���m��ȑ�6���ę�w��v{t���d��ҽ{�Q�d��@�3��(&�<���Zt+�#����7,�gΜՌ�-Bpn2%�'S�X̝�8������������{"����XB��0"sԁi�0bd3w����z�y��͛��f/� �:��r��g���!��h��\�{�1Z��0�}�~јW1�����6�t�X���D�x�l��1���H|P����50t��f�N1��;�٢ۣ<'�8��µ�o�F4#)��p��
+�AE\�������>X	N+���K4�'^3D4�7�"���\�dX���'\G��^lE����O}�Fk�Q[O<��u�zʩ��-Z��]���ij��������S��a	?��iq�L��H$�8�ۃ)�|��atytH�����F`��x��S����>��ͧϘټC_Ν�2��TIr�a%&A���7�Q�-ܓ`
+�n�%2?��f��H�a�ϓ��w�Z:�g��`XiC�h�ծ���*���o�Yz\3~�x�F
+cÇ��~���l,<��6v��q%�S�����8q��l��������d�����Dj�j�d=u��������uߺ��J>����o6ճSf��7
+���.�eo0��~m���7)w+���iw�f�Yu!C�V;��V�4 =�lش�y�N�8�Y��vFXao�������S����Y�[�֯CRڧǆ�F����"�D��+,a�Cau��zWJ�*�-��AcC���L*Vn�;�1��8ަI�-T
+x��P'��_�G��o����-�@*l_���q�#�a��r|t�J��̿MDВpz]��O�)*x�I��6��\`(:2K�+JC�n?��Mw�����ν,�E��EE���ӫu"���cF5������M�Q�S��l���xb��l���B�Zw�_ա�h�K6uy�
+�*n7��~�Ĉ~P�cc�A6 a)���-J�e%A�M9�c��+�v��?�q�po��}��w�+��u�kꩧ.�A�c��#��(��p�z�^���p�Nȅ-���E����+:ē��
+3yt�O$Ϸd���a�#+W�4f~���t<\�j�
+�3��-th���ng�bH��D����h��X��j��x&��#N5��]>�oՕ�A�h�d��挳��+���
+u�2�q�OM�R�?����WP
+(WI�%�l'm�H�h�6��%|*���I��o<ʌ���v4�tKr���g􇝉<q¬����v��m�x�+��l�~	<��^��v�- ��uai�=�%�H��T�1�Hǰf=̾ŏ��S��x�Ē����=�	��u�1zDq��sȉF�N9����?�ci|��1{
+�A�,i����NG����`0�hT!��<O&.Z�	S����+�O�O��Z��l�@���`wj��� �S4�r�q`�C�~�Wk}=��˯����þ	I��VY�Þu��=�
+�h���3+�=p9ܮhq�5�0�Z:DP�$��C�9���%u?����Ӽ���^�	�v��P�h���f�*(����˥Kʰ�!�2�Fmv�GKY��@A�p7�L��A���p���)9�q�SG	���-4�9WA՘��q�d'�`��J��ξQh�>��Y'hC�����m1���4��,���U��[��9a��2wڴ����]o��;$��I���g�MlZ��l�۟�
+~`ş<T�SɅ8�Y��z8�Gީ�y�s��Mp�5O?�L�TkcȮL���O/�xc)��{�L�Bv�x�``�r'��O��h3�\FH� �L�q�1%Z����Zl'��a�m��z���o���sCz;�Fb�)��+6\}�4n�B�<��g�A�rk�>��«R���G(E�JSYϱG��H?[�"9�7����\$X+H��(�F���&�t������SUo}��i�X������~��]�>p+6����|��ؔ�ݻ#��a"��x-D�g�v��X�p��I�T,���h�D*�6�d��x�4أXJ,�DG�QԵm�"/
+S&�Dm�}���*-�J��>�SM��d#N3+�t��u�u��7}u�����;?��x����b��baB�@�2J�r�ᄐ���<�B"��u�a��m��Ї/8up��[tU�+ M����vg����i#X���a�^�~ yF��ɑ�ul�E�#���6O��&����{^�F76⠼8�~� �!�M%���4I� �"��%������>G�[�v-�kb}� �$��<|j,�6)Rpµ�^�k��)�ة���n�T�+Sx�NZ*ƶ��&5e�4�v���Ѓ\��)��%�6�E��٫��M瓜�J� gh����p��uԑ��A�2\� W���� ٛ�i�s��z$�����G���=���3sU��|������o?�/�t����Sch�M� �VZ$؝XvԝY��-ˬ6T\�]z��[�qL��W��j|ūǮ+b���;wU{v�h���2?�O�[y�B�\��G�⢁�	F0 �M�+�B���4$Y��|YU�"OՈg>�G��?G�1~�ϣ6I���c�"'�������>.%
+��>�re�&�q)M�|�a��y��c��w�����{n=XS�k������C��F��A"m\L�A�Նg4���G�L߹�j��G��ư��A��?�0r��l��N�WMkI۵11�M�eѡ�t��H~}v,r�"����УDu��h�*��gt��Æ���(�b��ތ_T�WQ�K&��5�����%�lQ�0��&�=X���qр-��>%`w�v�����(6R�8dߴ�AZ�m��h��ŋ�f`���v���V;)j%ٕC~8�<w�:�Mp�A!T�$��j���6.��y�D)��[p��B*6A>�1a���\��R�@E�D��܈S�&�(��ۣUz�y���q��Mg���:uZ���}�Z���B`1��
+�ʙ>m�I���&��̌�knȰ,�N��gZp��Wq ��g�X:� ��j�iS�"����J�[��'EA�Xm���;��!'|(6�(h��~ff��=�y��>ƅ�⁍A���k�3r�=ae\i�Ú����Pa��9�2Of{�,t��v��?J�&k鿣賓� 	�g.���-l�4-qF���z�@G`w0��(��oY�TF.J3�̜,ZI���3�+�|�!'�!��(��)�R�+(p>��"��������,(�����Лe3����Õ�0DD�E��{W>���p�j����{��[�YE�N,�qɕWk5.�%WD��&�3%var��ִd��&�X���M]���E��W�ǻTG�I�>Q����D`ۋ.��=�O�R�NM�x����40�r�+	�6�y$�u��|h�ŏv����'���+{K,%ı�ei�-Я2��! �ٟ������z0h�M����\t��pF`h�Xl�K�q�)�+�a'?m��-��bM��=��9�9ITp�d��]���V�����o�k����aI�3?q^u��|��裡D�hly008�geE@$�;#��]V(N������gW���C�S���_$`�7y�)ŔX^�/�:�V3+2훘���Cz�e�>�G�J�^'Z%�Pv<�p��sд.�+eY�e�H�J<Ef���%d�	���x1&�f�@*J8VvX��	�Hi`�<�&0���8E8�>�x�l�s���ubt'������
+�:6{Bm��0��K�!-5ɢ+FU�,�]�b� ��k�T{�����q4��i��L�8�{�����������y
+���s�U�Tg�s�t�Gz(̄i~X�(1�r�_JL��Ϟ���-�\!��J�����ɼpR���"[vj'=:()�9�u�M�Y�H<��!?:�O،��N����7�����N^���{5������6b��K�b�h(�
+����T~��K]���bR�m[�'�2��Dt�,���+�=�IyC˳�`��?q"}/^���HkL2�.[���"(n��qň!����-v��8����0+�Q��4.�Le��K^����G��4����Ͻ����*�Z�ga[�_:0?4���%��7�!�l��զ'�{%=�45{�~͑޾�	I�H��U~�o�he�����O��g�z��\��mAW��ȃ���y�H�))�wy����3��0�؏t+�c�`5����J!��M�jS�E[�}�����"�<\::a�g�h=r⬣s��zȐ		>ɦѺs���.��ɡ�ʨu�z"4'��߂�����%`��O�V�6��6_��--{�M��w�g�v,�w��)z���j�^/.F�?l�fti��٠]n<@m����(3�b�B{�OбS>N��)�H^��A��·]����"/p6�1��!���v��f��+���q��$���/��/�8��D���/�ӾA+n�̪Y�ZR��V���~����z� �a�6�����������t�Z���S]w�� ��$ծ����@<��]ІN�a(v³��!�F��MF�+md������d���eĎ>f�B	u=��P8����i�q���<l~l�ba�姝��=C���7Df�����JV��H�]����]w�� y`���l2��F[���Z��.�����86��
+ +���B������Lɂ��!h#[�7�Ff*�[T[HVf5Q�N��H���ް��jpc���n�E_��\t�Kd�5��_��d��AMB�O�����dKI�ˀ�S�FI>F��\A7p��c�G�*e����׌���x�X��������j�5Qk�'#�,�;��ȵl� �t�&�K��
+S,R�U�t��ӡ��cz=�/����q��LZ�{[�c��8��]y}����c��$O��<���F$}l�Ύ��8���	fDG.��+�l�B^����#y���Kh{%X�~}Q)�H�+�ltm���m~]� U���@J��9.H�)'r���Y$�B�u~`Xx\y%HQ�(�?��0aV�SD�B6���V�qv���+=�U�Gȗ�/��:M˞�QG�Y֣p�Jk�d+�iQ�XY\ٹ�e
+����rA����TcMbI�� 1)* ��ɤ�ľ��;�b2���)��n�)�Mu���b�3�I�n;)L�MӀ>n�d�eb���"��1��XG�A������>8�'����3�l���/�^�a�Yd�eX��u��
+G���j�|�Ym4W�?
+�c@�h��=S+�8�V�**ԡ����	�^�������S��껚�{�}T/�����hԕ�z]{�g5F?���߈9b�x&�<g��$���')'�+R��|'OF�����?�G~xǝ�n��z���ҷ�n���'��f�}7J廎t�x����}�a�T��x4�}�xS��Ɣ�n\?�k�%
+ʹ�\W�S7��g���e�Nokf���O�_^:��N���԰�S��d&����`����¢<�����_��Y�f��a5EX��Z`џh�O{��P
+�g�>�")Ms���r�8�Ai1���bEU�2�H�e��r74��p-'C$�ϲ�9j�>�[Hџ:�ܥ%D�bP�me4V�G�2 -���tTG-^\}��HN�&N�����TϽ�b��.��x���1�׽�ӟ��͘�ƁMh��N��``�٘��*0�Gvc�}5TT,���+�����3u�߲eS�c}=;�(!q�5W�;n�]�L�D�IBU�ã��?����@�	���$t�E,��Ȉ�E�&�,�"�+�:�1S�03	
+��ˈ�p�J��똳
+�7��F�w5#�z�B�q�����;���p*y����uv5K/�p�C�,�j�g�m�	�a�@�q%}I��ho&+W6�qz�E7\�
+�++�c,$�C'�$HF*��K�Z�W��M3fQ]|��v"��링 =���U�
+��>L�A�q�+J&�1L�m\�""Rhg%�+?��j�&�KU�?س�ڢY�.Ya�t�W��B��a�s9{B1�-��-�>>�# 
+���)r��IՎ�X��.=�w@�z8U���%�G�:�1�G}1*$yE.�Ь�=�/��E��r��(s�O�,�ƧѠ�VW�����#�t�/��=�c�ϸ�@,Գ��!�%���ZI���K��7օd�M�jS�2��J��D�r��
+{���J̓��9�K�ٿ�ߤ{GT��.jm��]J���7>���4Ȗ��؇@��S�/��2�@)&>k*� �	qTJ�D�ۣ2�V�_*���ų�؆��!i�o����BE3K?������9H|�c�Uu����̬�h�/>�5N�L=�>R�@H�t\����DM����A���|�����h@=�sfE ٢'�;괝�y񑍊L����$}fۉ�g!~W���Nt@Ǿ؋-
+j�ao����W���1c0�ͱx������އV̵n���V�N<yy�T���{'�r�UF�b'u�������c�R�p(��G8�!��Ǜ��#�&!M�И��8y��W����EDn7r9�K}�w�kQ!���#�L��]�vm��t�%�m/Z�fM�d�ڹE�2��}Tv���j!uP�,��V�>�#���g�,y!���)/ϰ��;�+at���yw�/~���wT�������5�N��쎆o^l-���D%[@�
+�h��Y3�O���3[�Ag+��� �S�<�z��7�5���Jǀ��p���D-A��~B��B�����D���)T,JJ���'�W�{�n���a���$���~�Zn�C3���O\ri]h�?l+�؈I���u>�-��!߾J��U��5�����E"�N��3i�ep�3�v"�>V���+��h�[�ɣ賓�$��<bևI�e����2���w��S�)�$X\*�݊��	�Q�K����K��c��8��ƙ(�d@k]ʯ��*�p���ߟ�A���l|4�v��@O�o���	o&�p���m�{�J�`��>����f�ǭ����@D��ai\� ��#D�۸����ox���k��]}�O��Si�����?�?�wBqȩm��4xt��F��R�lJ{����?��6�)�J��נ�N����}����}�"t5�Į�l��T�/�P��6���v�Xy��8sA:�8+��`���"�<��uc��sew�9��v����֬�Ī�t�2U1G��B��\lE�����u܋��WY7Yt܋��+ dx���x�+�M��Cg���P�,{�+�Ϡ�U����(v7"jL�U���+Ec��G��ӲSW�W�j�f�q6��V#	0���#��ہv1���^j�P�ĄȰN$��@�bo5�н�rL���ט��[��ڎN"/8���ȶ�x�l'�;�9�)s`�L����-�YA�X�J�VH��^�'B�r-�v�e�U�]zi�^���f��	�MS�����)���uY	fc�\� l'�6�={���lE����@��'��&'�h�fI,)��P���}��۷���+8e����Y
+;��)3�1
+��bJ[m�v~x*�i�+L<d�d>�
+m�$~�n�Fk��(6�r�E�l������/�b?����%;y��o��/�O{A1q�-��`0�[��ɯS8t�_��~��a$~#�j�?�BX�O}�n$lA�������.mmC�L���4#+N��"�fA��I�>�8W��,$;�x�9�Y"�dg������z묓�8�\ZJI���'-?�:W_�q$�P��I�d��mw�!�n�J�NAy�|d�G`ц�d�;�NЗ,A��������QC�����Pl�>�x��A����gȑK�}:�|����P�H�wx@i�ȂA)y�+���e����m6䚟x����/(Y
+m�~��g��C�5��&6b����(L��<I�]Q!D��K����@�&!������"#�`S��ȹlz!�}�=��@lo<�È�.�r��L�p+l�%A˹+���#(!8@o�X_!��+���}]@��s;!�Q^+|Vf s�4p�'P�+lCp�l�Cd��(J��yS%J��&�!��\%�I<�,�.2��Q�)��	,)(����~:m������F��/��(Gܴi3�.�+�jp]�/��b�	?��ӫO\|���`$>v�|�z]?/��L-t6�:W�LơH�E�����&!�+$�}��ܖ4 �'(~���U�ȡS�8�(����װ�m�.&!�����Q��4Y˭����w����På#내��[��:d+��B���!W1m����U����i�i�'ݧ�����w���?��M[�ҪCy�� �b�p�uJ.�^	GA�Sy4b
+�sB8��y�ļ�*��(�V�!D��`�O\+J�L��z`��m4
+����!W����O���+��H�1�S�_���J}�\d����B�E
+_��?�&�Z��S�����f�f�	̉����|�+˫���+Zz9.��z���~�:F��IP�I�<�}T�{�ƨ�2L�B[̐�<��Ф��=�D����(�e_��P��G���+��Q����@���U�r��"���:^�q�EA�H6Mu��ne��m+B�:C�_̳�h�3+$��q��5A�H6��6�B-5_���N�b-÷�>��|�Ń(��p�@�3���=�x�~'���9g�`:�r�$^�
+�ƣ��YM9���S�Ez���h�PdH��D���s檰��ۋ�r���r�p���Q�y��|�w�/����t�L�L��F*��@�ڷ�Smқ�����<�L�{�n�F������^m~te�z��A���_/l0e�m)�����ɳoԆ�	�!F��l����2���:m��OO�9��2�f"BI!;bW(�u��Y�p)O����Y�Q�T�gp�% vi�E��2��ό-�!����a��.�b�I	�8y�fr�i��[��׺gkN����#��*�c�6MK|!� q ی|�rѕ?��Ң�4�2V%>�p�vT�O��0+=Nġ���-�)���"�)��V-@n�\/��f��n���Z5��`�h�����8�\?��5"/hT���������M#���N_��Tb�J�}.��$���=zܨ���1�VCw'}\��d��xB�̃�B�:8��+�����@�����sEO�T�+]	���o�e�"�A�%q�5Jc�`D�3�]��ESq�
+	-@߭N�+g4�X�$��{�ԉ�bu�9Z�g�:�����Z$l�'r6�_i�������.�~�?}�Z���_#b��7���j�^J��9�&��>���d�wXⓜ�����5�s��}F�v���!d9��Q�G[1(��3?A�����#;��ED#��^L��F�5���J���rdW��}D E�L�����؜���o.�2�Z�:AR��M�u*�az��:/�o�D��Tq@���P��B�f���� �	ב�}�h�rT��R�k�
+�{�p�=�2+P�rX1aҀ�̧�Mқ�W���9^�%�Ҩ���%�V�����_�zu�~-�c�j��	Zrl��H[�A#4�5�qQ�b�\@�ܔ���!1�/#���l*Z���sw�@��ԟ�U��
+����N�}��0H�()0��\� 9vB��<� 8C`��j@�0����"��mÝ�� �3H�[��z�2	;�(
+C$F�+��"���\�}	��0�H&��p�k�+� 6��wm}#�J%���gժUZIzۚ)S�,J�����&B�"e��38�~��$�M)*G���E]$� �KN7j��
+�W�ч�J�Y|��n���W�����5�]rLu���w��c��t�ywǮj�/_%�ʒ\[�6�#c�|��N�ɑK#�(,?�L���~Zm�}sJ�,����كj���g���Z�h�n�U[���V�@L-���	ڬ�Π/�fC�Bo�M�AD��+Ԗh�x(�Q6�ǫ�z�I�S�G΁�uG�<���E�D��J=��=I==�IT|�i��<ۥ��Ў�F�PͲ���\qj5W���]{�-{���S�����xY�r�N��b��iӋ���Gqdt)�)�Y#�������@.	���!|ĉ_&a5an�`�������3g�,KT;�9zeſ�W��l4���f��j@^�P>�Ԙ�A��2A�Lf�����u^yuMOy�Ê6��[_�T|Eg�%�Us���6�u�P4��"�Fj]u!�2[�#B&M�\�)�:��ڴA�ZQ��痂��}N�*ޯ�,^XM�YP_��ƂZl��XD�`lx��A��]�^�Tv�g�|��1X4�v���ub�s.�8�5�bUS�b EN�޶o����ԡ��Ln��f/Ѿq��j�W�.M����[�V�ּ����܋��ͩ��vf�I�������0(h
+�
+:���K\GtR;F�5���}�Ց��z���ַ�u�r6jc�0��"p�I:�+�7~�N�~m[�N��U	��n���6�$u�x��k{��N;��^|�e}������Iv� �c��k�n	~��K��c�T�*���~��\ɮc�M[�NY�C���n����a���#�!��X�-�QZ+A�~�x�}�}_�n��+�x)|�f��"#+|u���<t����}/g:�\&N�P�׫ʬc8I��{8;����-$cd�bQ�|��5�v ��c�&Tc���V|n,����s�c,+���U��@*�ѩm�~
+ݤ�;Z|�ˋ�V��&4d����̙�Z;j��j�^b"^�����!($A�#��Ѓ /UR�8�OB�9jo5o��{��O��F��D�+M���􊙙�� �u���p��E��Ԍ5���D(?�++����Ez�yk������9�S�'�λ��Գ���Y�m�Z������'M�s�O�֨��(�G�ݼb��+��<q ۍ7�����zJ��gf�f�Gi*!�����RI�}�[��r��IN�Raۡy8�`IL`g��ҒI�6��,f]Bba��)KXԱ>>��T(*�ӦM�,��,
+B!�&hR�'.�	v�J�����Gh�9L�+�N莅(��Ӵc�e����������i�ZhUW�\u�o�뗈��-�@�%ɯ�Ŧo~�_uk�u}]��j��1,��o�c��zh�pct���D�7�!��1�_��5�(�+�48�[F(aQ42p(@[r*� ^TX�f�e`�9uā=�غ�Ř�]��%�q�&t%C��Q���>Z�y��l���ʑRݒŋ�z�nJ��{���N*݂�������#���e�	�}��V��_�E�I�r�A��(��pͨp�~�j���?s}5K��ʪՃ�
+|GݭZ��o���;~o�E~O�,:�1X��s3���i��YT+�+�;Ta����GŃ����+Yț2y�s�D-k�۷GW/�8KdN�1[��
+�\�n�#.��(PT`�-a?��	0�SX�����(�w �w���{]��K�R���y����'w��K���"JD����@'�}5'��e˖}�`^IӴL�d�δ]��%����&�+�J��"fQ��t�Z3��0�>
+�[��5s�Ω�1����85��
+|���I7��Q�?Y��f�R���)r]��Ŋ
+,���Z����t���.3��Z��کEJS�;tX��G�+��T>����EGk����}��Ӱ��^l�v��\�����)�O�}��j�:N�<Ek��mɘj���f�6�r�5.�l)����5�mz��{���$���as]d��n�����2���8�k.�&i�� ��M�,;V6���\5��Ǌ�9�\�����!�3�\{�� �^��Rٕym|���ڵe��q�E�9���K:�]O��k+�z�q�]x���rl��Ty���D�e"/��4�3�� )+HJچ?�l}�ߢءW�v�i��|պ��F�UT'�~��xit���ː�O?�a����������/�g��K��vӘ�߼�D]�s�i�!���2�u��ꪗ�-z��׿�tu
+���Aa��ĳ4�32�Lg��a�nx<�'Qq�<�q�fM��b'6n�6j	��hJw�O�dHdp{g�哟���i�ᭈF�+|�#��&�F���fu���ռ��l1�@����O}�S����>,2e���
+�A�[��CBG����w)���q�c��[��w�}��}��W2=3jr��g�������+<({ˇ0x��;n�ֿW�miSG5#�Y�_X-׌�&���8TF����*68���{��3���c/�>��/Vvu~3�G�AR�M8?+��� ����!�DE��Z�k�2l��C�߶��û��o��Ӣc��.��:�P�/>C�80RW^W_�%�~`�L]��~�����^���ꫯ�;Q��v�/��~���D���p@��=��󯂸{���ƫ�;JcGVD�l���"-H�,r�~`�;<I�S�t;0y�4-ȱI�=�eg��u&[|�q���}�Z|�q��L�l�r�`r�f�1�Pr�.�I3Άg-?����+.妓�Q�nRoi�c�б�
+온����Nת�'h�N�S��١��>35.��	jHÕU��зۄ����3Sqg�~��ʫ�PQ?9W[u��.�vt�~�8Oӹ�8��2o�Wa���l��5�&k��U�]�5��L�W�g]I_���n�m�SB?Ж����?���=�4��#�?��$�+�R�����N+A���o�����s�?�?Ғ<>(���@bd�%^0���++�(S)�t	���)Z��<�:�c�/�s�9���8�3U�3?�+�N���R��[;q��|)�b0 ����*&��gV�/zP3�x;���kٙL��&��9�Nx����~˫^�����6i��X_~X��w�T�qȄ�&�o�8X�OփT��p�>B_?C��8�fO�Z��p�lc@����qf������B��}^-���v=�(���āN�P�鑩?R��#���m���>��:�럍��;Y�� S���b�����E�ِ�ơ�a
+���b�[��f)0R����eK�j͂�e9�R��������{��_��׿Q=���գO<�@��Z��O����F	�0�C��R�'T;u]K�mR���m�}]�~>**f4u/�s@��݈:d�p\�<��in����Gw��QI8;?0=�H�=��#��o7pwriK�c��K9�+?��ӫ),3�J����;��0/&���4;a�'Ѯ?���:�L]���L��-������;4����C�VͧH9	-����;��4��?Smy����Έu�ܞ��v���&}Dn��V���G@*&+'��=�+y?�ӆ��^3�+���i�@J�+Jh���!蔧}�����<�Y��0�8
+i����ˎ���w�z��]m�L�@s��	�֗��Hm�uzg[�΄����e���i����3�W^}�y�+)/]vr��p�_� \i���z���?��_���S���ځIY����/}�Z��%�����(������ ͡�r#/;��8��>��l��ˮPpH#�qrX5e�^���$K��du+��g�C5 $�����Xӵ���*O[R���Jx�f��6WO�_[��F��|�+�+�-	ƪ<LD�ɝw֜YWc5q��o�z���XԄ��m+Pv��, �������΄��`����3�mrpRB��l��2�k��0�[;`�m@dA��~����ްZΖ�^��9L�?񘣽H�^���i\'�
+�4)�ZH��#Z_o��	����~�h�c���')���Ϭ��H�`!��m}���zS�+�P�Ƒ���nnid��Y�q�����C�O�k�@��!��O�{�	�+k%��hƊSN��ꜥO����;+��t�_�G��)+O�~������!v���'m�ٍIWT����������;L.;�ԫo���:�����Q�t���7\�p�t��Q,4������%��o��~��{��+=��{���b�Nȓ��������=��K�H?Δ:�I��cU�v�"���>��s5L��gJ��o�했m=w��Ѐ�!c�@Rz��4Ѹ����F)㋪����"��>����5��#3|M��������i��?Q߿�s�|G��r�kv`�-llۑxĖI=�^z���4��H�-e�{���TL��p��|��z���<�%��MX�7��kQܯ�[���( ?;=�O��7~���+��Sk7�٘g+��G���Бbf
+y��h t��6i0��+=y{�Gn3Xp���^���]�6�e#)R�!c���L�|�q��Ügy�D}s��G��|N��~��=tr~V<��OT�]~Eu�)�V�g����dF�����DJX���?#��8q������v}$�79�}��_���>y׿������3��>�ԍ�G�}l��
+p[�BK>������H�w���Nя�<��(\K���d�$��A�쇣�7����Ǯ����ݾ^}�_~׿^�:3�ז8�2 ������3��}��n7��P�Gy�&=ܾE4L�����ĥ�L�~�	�9+I��ml�B)��7P^G|�J�{�,?��s��@{[��K��{gcWu��
+l����C<0ARGj!B�@J�tDw$�� ���D�R����nAaJ:�J(�&RC���0����v�y�UN��>翵��ֹ�\vMgU���{���u����O�F���bT���wh����IC/Ll[����w�'��nx>����Ξ����|+��jc�V.|N�(L��
+c$�
+e�{<�Qv~�6��
+��2�̥�$u����X!O��sy�����\����e�������n��̄��=&����d�wӦMϟ?ۅ^�9m+I������~&��L=PY�L���%���4�X$����~�>��<�_�Ð��r�_6��&��!���4�ʩ�!�ԣ��
+�l4����7�lYZ*'0�����A9�K�h�Ɇ��[�#�S]������wZa/��2���L�G?3Wr��.*VF�+�8t�%x���{�k���_��}���}�χ��{�oMwy��+Z6�i���2�z<)�exAE����J�ˤ	*=�@s?�x�F�����S�������Z)�ڧ=�Ǿ���9�m۶�^�֕*.�E�{`����
+ګ;.���+���i:$��{�齆G9��؊��ioQnkˉW��*���v*V�6S��`��V�=��~�g�#���X�u�7p�^�q����&�y��W��k_���u���T�����V��M�H�Ld=�h�e�fY������?�}�ƍt��2"�2�F%�2|ᑡ^.�ۆ�w�m2�+I_?��!�r+B�3̓v�Y����^���ģ��vk�i���_(�J�gɿN���.�u�]�w�^I�u'�z��#��K="�����	?F�sݶ+�44!�����c���P_��^��zv n�V!&}I�u^��A^.�/�ښ#<�+
+O�̙K`�1�
+N1�p���S9?(;�@��2-�$f�$B
+)�(y���H��n8����X
+�����m�9I��P�?�����.D��R�5���;���o��y�W~��^�û9eM.����3?,Ӟ������v��|�[�/�F�|A-1�|��s#�<LT`���+@�2|P_$�\uX@KҌ-MZn!�=?W/K������@G�v�.قC�Er�_��%��T�~�����(mT׾9:��zh~[�>"<�s��7���믳�߬`�Wq������>-�G$C�<�!�ޱc��}����y睷_wn��!A��!x�I��K��u��)�����*J�4��P��j�u�A���WaN�R�#�z�ˊ���B�\gQ�e>ؒR�h��/d�~QοǪ���g���g醞9���.;m����%������7�abݒ�{~+��*��V[���1¤��/�M�ܶ����|�����	��h�#�^�%�G�:�J�?��O����%?��ys�A���Iw+��_�]��Fv+���I���)ݢ�bS�TW�-Ж�.92��S���k��_��iJ����y����P͏�����O>��d���+��*܌��|<����������O�6�����#G���$�z��1��� U��t�b��{/��G��+V\{��	�׭[�9.#z���6�D��m����;Z��|����i��^{�?�㯛~��_m��'�2N���|;�G�{oo.�3�<�g^�;{챰#+N˹�Yw�ʟ.gp��W_��+�X���y:y�V+�[+�]�y����U��H���ϕ#����}
+m��ի���yzzq��W�/1O_HZ���<�w81����������Y�!œ�s���=����G�~���+��v�6mڴ[/����A8O�9�f F��<��u�v�,���^�I�P�#�q3H�`٠'n�ஊ�iy9��Ʃ�;q�!��z �yn�X�@�+
++�]�3�_g`ޱ�#��δMҦ�E�J�T����^n����k��T>�f9�^zz����0�q��=�L���j�+鶲�&1m����rPC��y��1�k�m��)z��y��	�����vaO��v�7��H�^zz��@а:�3�3�L���ڭl���	}�j��Â��'<�	�?��#Uu�'n>�c�:���7r�!�7m�tԆ6�[�n�ڵk7�Y��]�'썒�g�ֲ�}��-����_�}�۶msY-�x�[�l�r���{��w�}�w�q�M7�t�u�]w��_~˻����T�'N��ȅ�|P��<zOf�С����V꫞�9�`t ���g`z,���Х;��0<&^&���zԣ����O|�S�z�&�S�>��>��S4���I�xM�GI�P-s�&�%M�L�MMY$��
+�U�ߥ��[t�p�N�t�=�\{��7Y'	�~���k_�����/r���+xɻ���Qj��֭̊�n�{�3�_d����3�=��t�n�E�T�2hn�o�¤��IOz�a�zի��TM�g�����5��ě)�	s�?����Hg�S��j����-�/��>>���/��?��/������_��.�rR���È�D�ҸZ��ʠ)����؇3P��>܅z����~�C/�.Y�L�,_����?�O~�}�G�TM�gi2�0��m�e&�~ho�T���j�W��������K���'����^���_�׽�F�8��	�]��Д�G+��/޼v+�t��^��v@����L2��E�H��@��=����?�5�y�S�U�g�kv����O|�m��9t���B(��xvԟ����[n�僗^z�_��_��(r��N�uU�N�-�>.�neн��3��p�	�z�g��g�����-�n�,�Mz������<餓�����~/�_�ѻ>���|�Coy�[>�5��.r2pOּ��R'�&�)��m��E��g`��@�{u�=�>�~:�n'���j���U�!���p�o��o}���y�QG}��������+� wV�+P���C��g`we F�݅�q���W��S�xU�y������7��=�q߳iӦ�c�D~ ��cۛ�/�_�o��>���|毞���G�� �
+�k�5�Ok�_���)�N}��=��������+�6-;��@M�U�햦�K��Ne����=��v�I�<�x���<���������O��t��Q�p-;\M���OO'�ExS�]վ_S��Z�l۾�E�J-��[ugd�5K�D7J����&1aB�hU�G.U?���mi#7jk�Z�����H\�v��:魗|�ڵ�}��K�{8ʢ�Z���`�ߡ���կ~�~��~���#����f"����K��C���s�>�P��^��v?*��B/��I�������������o޼�����	+'!ڋptV*;k�6�)�T��>�=ZݩY���k�hb�l�U5�*����	��@|r<�ׄ�5�7rAzr��#�l�
+�+�M���O>���������%/yɿJ�9 q��ƨ՜ۆO�d��=��@��6�=�@��M]I*�&}��6n�x�>��ӟ���x��t+.8�;j6�e�X �y�*��8F��˳M�@6���	>2r���	�jP$����?�l�Q'G������N˾��ۘW��������_����-��^��@� }�D�Md�wib\إ�l?�@��M]]/zf�����8�iO{�Oh�"�;SVPwwg�>��]��o�U����׬�l��6$g(̺ҙ�i����}W��h�,���t�t)-JL��J�6�,V�1U=+�����᥇�	o�� �8��8�1��\�g#�+9kh�&�wG�����y'�O9���uJ��z"q���z.�,�ݞ��/?��n��.�%�Ї^s������9�]$���SeJ�¾�X.�������G���ڥ&~^ջ��xǿ;��~���ƕ<Y;`b_W�5Y<̕la����7��8�c$�瑔�Й�*�����<�Ĩ�$l�x4ml��M���ē�1�2/���JL���`�Z8�fO�k�f%��d�P�i��	ܺ�.1�}�e���h��X6����!`!r�d��X��o_ҍ?hx��'8v�	��Z��{�Yw���;��;�I�/: ����u�@���^z�e��7��]�f��|����7?U���	=�wNM��	{�ý�w����3/wh��
+ߗ���Z�'!�ZO�L��cb���L���Ĥ�WY�t���ú&�]k���ᾞ H}9�/'1l�%N�d���<�%�Љm5�ґ�b�V��{:�]�3�g��F��s�ę5h�M-J�Q}`_�/=痳 ��ݖ��9KK�u�p��~��!��=S9��\��������=�y�^�O	�V-�}}�9KY�����g�x���} �_�5��_�;ꕯ|����=��C��ˢrg�+:�p>��ߨ��o�U�]�=�Mq&&����3��JV�H�Iʏ�����k&�B�I\�,DX����K{Y[��a�vS�%�~�s;[)�ɩ�G\&����{���crԳ�@�L�XZ�c����S4���	~�#�Ρ��:��]:
+�
+�ԏ�݁G�݁�a�8�t��Z�}�j�<��w��^�����G�>'�[��+��Hts�E"�������(���`4���S��w^7?���=�����^v�'���qN��eހW�V�҅E��c���w�ަ����W��ҫI3&fq�O��4���Ә�BW�^���zN2j�>��n�2�L϶i�@���eo��>��O�Z�$@��I5��IA�Y.=+�W�=��-�(��Ƨ��S���g�F�`�ªnճ���
+
+���;+Z<p�G�԰a4�$a�(e�oP㘵ۖN��ݚ�L�7���}#虘V���AM��i{��7]~�����;��$�
+�{�k3T��R�hE��^����+�Xc/R>���:AX,�1���f�@��"�"�~��>p��)�W�9�"��N��s�z����G�#���i�����j����P�E�S�i{��N���җ���n��.��d����B�m-��m����<$���.����m]�v҇��R���у~��nݺG��Gʼ�x�p�����g��j��)s��0��cL�B�0X��4�¤�A�z�~1| �?�s�����d<9�E?/��9���89���h~H�9�!��HC6����
+�������PE�A{�����e�$脞��O�p �O$�U�F@�=�s���?"���=�Ģf�� �m߸l��&���;a�7��j��}1�I��by�������>*E~��;�	+!��oM5b:L�"}�>��`�?��$@�8�k�)s�X���2��Ex�礅���&�蕱DJ%���+s��~�@f�*��>u����b�5����Տ����o��SP��%Bdf���J괖I/�[��ͬ�-e�Tr�b�w��.]�,��؏�ؙzw������&�C��j��Zz*1��)��{��%���>����[����������c���0}��FWC�����B��Q%���\�=q`SF�C��O�O�^���;� ���Q����c̔�hAϖ0B�R�h�8��Pވaĉ�7J"k~e:�g�?h����-�N�o
+!�
+-��/��흣ֲ�׸�8�W?�7��|1��Q�����#p���c'Ҋ��D�:�M<7i_�^r�*��S�xpf�%[��_�;�_�ds���9��/�����+���|p��!M�;�K^�Dܛ�C�������nW�喺�?D��w��������K��)d>Ԕ]=���Ǔ�_�H�5���:�Q�@��̔�ԕ0b:��c]��[��tD0M����c{�B*�T���@{����IM�â��o�C�r��F�;p���v$��
+O-u�!�`.>	I�YZ��������:ɀ*9T��5�*/q:h�I����\�J�p��KbvJ���mEH���A7d1Yc���" m���D�L�G8\Rs}��J�H�hH/�J�7J��P��ߡw��������A�܍k-+�@^�����}8��>��	��������������O>�E�6�T5~����tɗ��S:UO��c�������&��4�3��4c4
+S�X� ^#U�)[YL�!��,#���b"ń:cԴeT������>q��o+EoK��@�'e�6�xR��N���c}��_�DlD�S�=Q
+k���s,�m�$�=B�:M��C|��d�eW�l�Uj�KMY����n{�^���_���x�p{PnkñR���>���;����kt��ٮ�0JCS�m~ozӛ����=�7����ۡ����M���0rՖ5zq�X�[c��a2���`��801�i��,��Y�6�l*��K��<|3��j\��+�үl6�D`i�o�h�S��&��޼�֭[������^���:�i��ƕN��.V��},���������^na�g9���?�#��?��!�-�g�+��ej}5��Ol��7s�%�-���hW�YQx��4|%>?x#z8�p��K%��� �}�"�NĜ�P��@ceC7�D0y�;|�vd��k�w�N�Hw8`�T����#��F}����ez��B�r������:/�@�h{�FYRm�����q��6��}���.���Bчhy�
+��4�_�I��$"d+zp.�|�YA���J�ɰ�}�P�iēh�f��ٵ�iD<.3��A�;�Lu�?�b?�D���U�}�\+Mh�Ϻ�E4���$o��BB���V��ێp��ʴV��J��ȑ��i�1��j��
+��6��y��Ό@�,�TqEl�0�َ��\ا]��^}�E�,I>��	�ၯ�k�F�a ������.�6����@����h�Z�E��������8;{_h����-5�S�����3�_8��c�;��4H1��@a +ԋ.�E����rxs�Ń-�?b@���̱d�%�q]���j�pO���إ��~����,L���aO�X��+��[,�����A�b_���Օ����D�cB�0`P��r��@��Al��h*?Շ�[�ͬ�$�"�qB�s0��E�)fvK4X��(d>i�|$����G��B�8�K�|�]�42f*�fe�,r.��;��~��nЋDo߾U8����	A|d o%A�>�/�<���^'�i:	x���l�+u�L��O�C���?��n�W	�{y�W�*Ỵ�B�z���l����e`���E��P��a�z����6=F��}�_��_�V������%ρ0D���t�[]J�k鐎�;�}�K}���=�y���-]������  �h�n�1�Z(�����/6Jy�f��!5��LIC0�؇j�aʽ��@�Ii�C��k 7P*9�a��ã�����n�_�������&�(�'�$z�;�)�\g���2��8!A^��*�S=����ɶC��X���Į��k��1�i�i5`�r�vg�poP��7(eO\��;�B����!�S�����mV�1�`ݰ�o�P#�jK�O�f��t�&{�����t)+�~��O��k?�~ +^�r�!Ox�K_��{���E�w ^T�Ë��a�@�P��������Vڼs丷��-���o�����>�V{n��u�/7 �V�kz?������P���L��f,5mdT1R�b�Zu�M�5X`���gp��Y������&fᖯ�N<Ǜ�U��;�����C]����I>EQ�E�;��#��J�!��T[�HB�CG��Wɍ��فЄ��sAND��Dl��XGRN�J�8
+;�8���F��r�������O�)����۩c�}:�tX#�Jt�5_x�g�)��Gt���5A2p�+-$�@[K��1q��VS����ȿ�tVt�v�3��������!��펗��rx�\�'p�^���u��rx���]�t���{��20�{Y\=��@m���f�I�N+C���W��k�r[�0EB������N��!���d�F�U���e�F�]	]��嬶JvՎ:KVG��8R	2�oӌ�|���`Lf���B�}�ׁ�i��S�7,Ї�d�T�t�H��X�x�A��L��l	�F���,�Q�;�+�9�N�fe��@W��ux��+ӯ
+§8��@`��6��7��"+Z�̓���ś+�N��Сi�Ǜ����@�({8�;ஶ	�ta��G���	�|�;���[�Ӳ��Mz��s�]��|j����Ū���n�W�DD���\��-0�[w9>ZoF�1��J�X��?�Ive�RNƴB�n�T���U>�+q�f1@2ao|�sek��}	���.u�Us�3fڌ��05�
+mӥ\�;�S�7�M�"���f]M������8��������֧i_H�y��?�AO
+�����721��n���fa�ϊW¢�Աg:H���#ܡ�7�#�?��NU��;&lO��Gx��+���3�l��$��)w������.��r����w�+�%"���^���^���=j�M�a^54��=�K.�^}&�
+�{|�)��ܫ��u8q\e��+�:��ΰPZ:8}��e�����?����y�j�M�v�	�]v�O�p�	/V{na@����k���F�z��W�P�Z��g�4\-!{䍁̓�x��viMF#?ԫ��א;��&�k�Lk@��Fq��2ǩ�ʲF(��K7Σ���(�(#V����g�+8�%c�Xç�]����w�� }��0Cw�OX�����w;�CF"Fz"&:P��-v���Z����%�#�1J��PW,U׶�z�~˃����O|1cc���(���Ƭv��U�z
+��{(�!�=��eܴt,�m�f=|s����'z+F��9�t;ps^����}d\-[��rL��l��bDQ��{�%����8�=�Siڃ�%�G\�J����v�K�j�W�m@$��="��3��ewp>L��w]�E��T^1W�iӦӾ�����]s�5�����4��O�ai˴��:��3�O+�p��1�٤ѕI�A�@�H�v�o�|�^�@P*��VOy8�Ffl��.���+}ϸ̏�Ǿ��w����y��ھt�\M�7ž��y�d�Y�|�c{�y��?�n�&HrXh��eu/{ �������y�.5�S3���я~�{�>��_��o���u�_~�AK��^3�p�rp{�f0`P��Ճ�4��Ҥl�������	''A+,�W$��d��A�(��9��#���."b�1T7Ŝ[��=�X7��Z��b4ɪ+Ur��_���Fؓ"���X{�����#ΚV���8��A;J��6l�o
+�ĵ:��}�S���s�9��rs��zW@?	؍y_�w��t݇���5u�0�Ѧf��I:p�_����{�ܦ��]�ɟ��T�8&�x԰��E�`�hݢ�0���Jf��L��N^�'��rM̳wXxθr����K&S��1mk"1�W�q��h�4`�����.qp��*�+�r��xEX�-��f�+����=C�S��g�G���:>YH�j��^� O~����D��د��S�
+�NV�q
+�Ր؊皶�C+���?�A�H?T3?�#<�Y;:F�p�ִo�0�/~i�5�����RO���w%�r]+��^��!��my�&r�V���'se�����?�Y���N��K��O�����V¬|�đx�f�_~B�#���z.��x��
+���}K��DMY$�R����+_�w��X�	���B�UC�"�4u/�)���&�K*����xO��e��?�����)����'�n+��g{�ʃ~:�<�@0�x�σ�gB�Q񈞂]NP1�#��gV�`Y�� ���q���#E���r�:>�\~�
+��T�G�J+N��c뤾c��y,Tq�*��x(z�o7�0W��X��#�\��*�=U�}�׾�3��C��$@��'����&�ZDfg�z���=h��v��@嗺]a�e��I������>Xu�RS(�G���[M�����^ ��'@���kd��DCOv��c�l������U�N�c�#Ҝ�l3Z7N"�+?M�����l)���V�ۖiy�6�e���9W'�*�����^�Q-�;�������b�'΀+>� �-��!U��,�/[�������)����ӎ`�}*=����q������
+�U�?mئ_�8Z좩)�Y<�E/'G�-��կ~�:	��-[��q@{'�=��(�E�!r�^vab��B�5d�rK�.��Q/�9I���ұ����Y�+��i��M7���3�<����.N�;�$�M��ǽd8;�\T^�ۥ���7w�q�~�ӟ��#�<����,:��`k����~���z����Ee����J퀓r��[��[����%���5`����1�3��jl�ً��aʭ(y����h��%�F`���([�A?���m�w�ez�+K@�3��[�,��{��|!��MM61�'':���7&���1&���"&U26�	�z(b�az�%�q�e�m���$�*Y�����42~�
+n�Fܯ*b�C	���N��6D8d�G�.5�o��;
+u���U2���U�-���@�>�����`#�ҳzB�!�AV����ɾ�y(�G陀G�˓.�(�_6mV%s��������=�IO�?n���/ɼ�4�ݓ�w�=��+���S�ʲ:v�/����X㕏�콂�V��c�1���]:f���'m$\e��W��3x��rxm��2h�o�喿=������|Y��q�4I{�[w8:@\T>�ۅ#�]���UW]���s�����Zt+��u������d�͝�c�M|��rb��.��>Z>a`ES��J&|���\�H]#�&����LN������I��Fn���9g�>��?L��!��%�r���6��(����K���~�F%Ut���TlO��/N+{hQ�d�"���=�aR�uim|Fq:%&1����A��6���A���W�����a{�g2b�1�K"����p�^��D�c �)�^1�G@���1�`�K$T<O�Z��P5�	�ra���[���s2�����?F0��Zy['��&�Y��Fk/�%K���N�6D��v|��p���҅����+G0"e^��b���йt<��U�8m�I��蹀C��W��]E?'�}����ϝ+E�G��&��&현Q�(U�t��v��³?�p�j8!t��a�D�H��p�u���o��'0,f�t�a�C��z`�1���E�;O@	�Bl?7n5�(g6��J��y�������,�2��J	�����+EY9`�J�emSX�jT5P��.�O�Y�i�~���^�؃�䆉]��I!�̊<AOq''X-/Bþrd���������ZY೎��]�u��"�C��ʷ-��>�qse�{b^@�&l16/q�O�Z�J���]���?&��9�Z��F`*&T��Ɔ�m�*9�b����Ψ�ë]����ᘏ�F�Ɩ�a�;�$�U��'WYI�/�)Nc%�H��R�v���#Ӧ�_��=Aj��/+�%56>⤎X�t��Y�T��]cƚ�O魠�!{�0&26���Z+9h�1�RS��,T/)92>$�n4SV=�q١O�袋��7�1pP�vc�*�����E����3�xcY�3th`��±�O�*5��@W݉!�Z��QEÌ3�Y2��9�(Xp�B�@�6V��)�7��3��ٓ��=�Z�-�B"�L	���JUWj����*l�W���T�sYG�ox�߁�Jclɓ�Qje�a�6Ns�ψ(1�'0���Ƕ�/�o����V�Q�N�����k "�uX\c�Y>D�q���x�e�D�w�@��ur����!C�bh���/�" k��8��n(cSx�Զ�g��1�tPtD�+�؞�6�L [�6y����.��{;�҃���ҟXÏ;t!E�������3Fܹ��J�a	�(�	v��1�&�
+m�%Ɛ/�-��_��@�:aW�Jw%{=�#�X�����]'�'+q��P�a��BFLD��o��V�'�3LR�pN��b�O��������5�Ķ���Ylf`�bXQ26/�Tn��������2?�O��<��,�	n�]�F�q˪��Oc�~��v+	H?��Xn��"kH`I;m1�-��/y����u͋U،`��.�X����?�~٨�2{g�Ɖ��P�.Y+�2��=�1�]�@�v�!�P�~j7�OI������훵N��p(�v�V5�kc�8�i�~�Oܙ�#�v�k��}��
+G:j�!�h�9�WGT;�����+�@�5�M��A�8���}��UN��s]�&��+��Qذ�OVt�5�x[�j�mP+���'M�7����'���v��ߢԞ�;���G�b�z��<��7>�iO{���]v�ewH�w,*˅���d��f�\Q�R�M��l��^����?ݴiӓv~���1����k~���������l8�}+��G�)��R�\��毂���M�]_dB���.��O]U.�=�g[b](��ڞ�vx؞�ibđ���pɓ��ց��1�8Nh��?}`�o���r6$߿˓�bȭ�Qd���	��tŗ}��x�d{4�lH�0�����<������ںt�N ���}A���{｟>��~H��r��q+\)f�ɏH|�C2��hT�p=0�7�G�1`�����D|�?C|jLr``7VL�L�T,暀���F_��_0�CqH��Mz�8��'6CѶ|"�O(8֨�[�5N�	6c]�U�'�0��n
+[?�6�P�Q���v�I<��Uy���t;V�\[�ۚy`�9���zd����\���x�҈�dɎ_ 
+�:9�������>�6�a�t2��נ)��#:ވ�r�+vL�'z�dۘ�r�#�:ג�?l�]w |�`X�2�Wa�H9_Z:\�߰i�_�˯o���>�1������iq'�=	 !��]�t���e2�����.�B�.�]88�K.�)&�:��[�H;�jmZS&�Oh�K�Dp-�����48�#x���Z�<�[d5D���"��,4"Fa"��Pz��f8���B�]�G�e>�2��Qz�"�(�3��=��YQ�=K�� /(YZ�d���{������Y.M��~`��\����uDby���B��H��>�B?�l��&�>~Y�3,SC0�UM���P�G�Il�G��K����3���"fPv;>@T�)�SM�O�\Lyf�:�26'Sja���L�4���DN2'L�ď��>Y?0@��@��sDE��(w��X+�ӭa[�`�2[�KktS|��X��:Ь��c��U��^��Vl7���,\sB���g�%?��{bLc��́��Э�J�Ԟ1��/~�lx[ cm;�Bg�C-V�����^g`�s�W;!;���ǿ���N�/�q�T��f�YMw�:Ш[��:�>��tޭ�	n8�Ep�>���f���`z8�c��S�1`�W1�eWMt_mPr�p�E�=^�� ��&d	Y|��^��F�ɻ�����'����g��ô3ū���'�1�n`���]�+��^K���+.�֤YZQ�++5�n7����s�cl�kL�1�>�D�?\i��.%rzP�dNh"���!��Q���ܦ��P���
+��52�UG
+��5�f��S�����g���"G���6 {� I��E�5v��60��ؘ�!L�a�M�B�V؈1	��͕V���a�Ghl�!Pp�~� o'aڇd��=D�\M\�l_�{�:�:X'ޡ$S�����C�൷��6�_c�)���X����=	�s�q#y��������^��@�#]u�p�ǽ��o��}��E?��k�v�:pЧp^���ʟ�%+�>x��Ղ~OtC�c·ˑ�A,��I@P�EM�M�S35`YY)3�g���`P�$yԬ1��k�W���v��%�CF��aJ	i`9�g�ҍ�@��y��@e��Xx��=H���,]���TA�ٕ��new��,en#Z��v�+(�b-���"���a�}�Hp�K��1:%����u�Lc�����S�Gt1Y�\N�����}`Ё�NC�]�5t8�����3su�ƃO޿��ÜX��R}*~Վ�\�?єa�p+V����j���1j��˜p����^8�D���B�����������Do�2�y;p	=84;|���AR��ğԏ�ܪ��g$�G'lO`KȒ�쉿�g^����jQ�b��X�b2�I�̮;+���a����kۃC	ϸ�/�i�Z�gv['?���2�$�c(Ī%,�iQ����mL�=�;�ڥxC-"|F��.^�v�{i|EڊPs���v؆���X��0�-����e�_��p���"G�R���$>����ab"B�b=�b	~�Yhl�JF��q�|\E��l��e�a��$}�����B 2������7��+�ŗGj9�Q�P����>��j��	#�v��H��ȑ�p�_���2vM�2�N_���A��Mr�_�l\���1	w��X�t���KO�o
+{|��Rtē؊-rZ�c�H˖-W=������������w=��Á��m�ZD���%3[����@儺]j�$��a}ݵ�^�ۛ7o���wi��%z��F��q+��RzH�%�+/�L��n��IM�i��gϞ?������k;��{���<��׊'(���8V�]������|�3o�T�e��2��Y�[����%?��)L��2M�̋Ls3� �d�	�
+ü��|�cè�3��[�l��K]������[��.mp�2�����l����*^V�K���C�d�<��k�j!��X����:�j�c��r��@�K�"�Q��6)r�čۖ�e����:h#n�#��+|�Ͳ�Q[���,�J��ص�U}��U��ji��
+ڠ9��F�#�eb19I��4�JO����Y%c�CZڔ���r�;Ռ�x<c��``H�3�e�&VZ�Bâcy9��I�T��ؑ'zY���؉.�b���i`�#g8~y߀-�	U���@�W�Ť�,5������1Ck{�t�rp�����
+��붉�emJM��[w�Ν?z��W���M���3}{����^Yf�;��9=`�,�~�O}�{��޿����/9UO~�Q����Gu�,�X}�t�1&)�SU}\����M��K�,��S��B�f��%g�Ɖ��l���+�v��ʚ��@j�6J-F�,$Wڕw��Vݱ!��<	p/~3C^�wn:?UG^b^p#���"F��F#|�C����H�	w����z�~������N+F�R��;e��Zƾ�����>��74�RƑk�|�1����3��`���CE�6<>Ӳ>!��Z4��A��@I�i���Z0N��E�qm�+��_�c_0������WR|���>rAd�,�A���-!��Ґ�,��!m�n��m��6���V��ht��(�NЖ'+J��x-�������œ��*k��V[�Gc�[×\��:�#*�d;�����a�qn �E���_k�Э�	��Q3/Na����{E�z��YB��L`W�jq��1`���c���X�9n6Զ���;,�}����!�?);������<��+���ͷ�z�-2��+�晇��-�����]i��۔�����1���Q�RG�=%LZ� ���5 !)��5�F�-ѽ*ⶋw�U����E�X��X�Y+C,�V��������}o��Xѩ��C��fN-��QF鲇��|F.�ogAd���#VS�ZQ��z�7�UP��i9Y��+��z^��&�giD�oq��k��`����m\���o�΋}i��&�e���*���3��A�+��S�yY�8�-,��uQ�T�&=m�A�W�vh��:���{`��麛�2�|ǝ�}{��������<�����Ν���X��t�Vr^ ��Q�.А���0�n𺽶A���l���L�6g��)C�)�:��I�}�[���*�Œ
+~��{N�Ča�Fb9a{֥E�$Bk��>�Sb�s/� U�i_El8��ذU6g��8���\�$Fs5	�}!�Z�방Z��+x�+-��&J��w���FD��M��>�u��g|ڛA~�zN��u�L+q�b���e��1�+�Xᄫ�Ĵ�ь{D�+h���d1��{��vD��+�l�G� Z�J,��ز�E���ڼ��)��|�p���F����P�yjE;�@R��H��jHp(�aHY�{��Ńm@�cc�����C�����G�Za�a��q�u8���V���"1��/l�vi��4�� ���xX�k����������K�r�9�k7Ԡ饀��Z�M��c�AkC˶��������p� �,7��������������k r�:JL��z-�����ߣYڣ-�H�:�fA�i8��'!3-�jz�{����Ԧ��D:�آ��B/^E&d���bۍ^&u"b�qWe��J��z�M��z���X	�A	N�Qn<Ǽ����E���d98*n��$�b+���f����M�,�*����ٿY�ݍ��>�ش�)Z��˲�z�ȡÏN�|���~Îc��K��656Z��d�������@���[���t��;m:��v�e3iC'�<a2i>��J�~�<U�˻�{BOv�f5�O��l�!�G������}4?'tc�w��Zܟ3��;>Vi�	U��F���m�6b�y��Nt���%�/RhX�f=k�k�<!�&]�(�C�/���E%���kH�fc��B�u�b�n8��15[%7�J�;w֍M�����{��s����q+�E�>چ���/�XO>�o�O]�*�R������Ey���I�˭/+ƶ<$P�d�?��E�u
+��4۵��䟥}t�_:�{Ƙ�$	>��Z�Ѱ�=]ya{F3�yB�~K��Ц������m�g�4\�Wb�_�Fa�ٷo��5��ʶW��E�&�jS���aY�k�[�jګ�>.ۻ�7m"y�b �V۸�TDBW�*A�<Aq�#�� �,n���Xe[\#�vsD96=OZ�;�n���d���l�/'�+ƬJ�xj�D�mDK�M�w-ر�������Y��Y����A�ŇE��/�E��1qH�>�⳨��d��{�&+~u�Es�k��Z>t��"���,�O��3��B�W��s����OLw�}����X���,�g�s��+��~��?8��_6���/�.����SO�U����=Bc/�+����.�p: F�@+ǱC�1X�(
+�r���R'��p�۶����_��QzLF�3������v��-_x��#�@�+k<k��Oӆ6\욶]VMY�C9��}��>p}@�ux�-�|�+�{ի^�Ͽ��ToԻ�1�|���S.3.ٓ�N4�B���ڽ"!�-OR$t��H�-q��q�Ն��;���e��D�QN�֗�$����O���HG�Ɍ
+�}���U�֧k�q���J��k�eՒ<6	��}�Ӽ�0/��~?�%{����"��1!��v.�s��v��+F�䒢QC�]5�d�p�f�@�������Q�6~*��y��HzAs�J�
+k^���_</�+z�H�b!<�#�>���'��r٥�M����ظ�8�`h��2�M���z�Z���x]��EL1�LH+>@�_�?n#!e�u�n�=��l��^)!�8����;D�8�F�[��%d���LQr*����v"Nò}_�)N�3|*�X���}������J������<�e�E�4ڬ������v�sƖ��=���h>�cY`y+kY28�0~!c��!���H�>�i���A.zj^�9�8��_����mƱǾsdG�P/X���������m"ڻ��g[m-�5��٧��F���W�	�9f>��wD������;��SM�xNHG��<�ި�T]l�?b�S��,y+��w,q~�R���+�3����-����,�u�e���D��(�p��,9�W��c����*�QM��1�-a7��w���Sq�n��ܭm�g�H�����*_rA)�Ԋ�e�Jy?�q���M[�����/�DL���S]��e�)�|�{����b��8������r2�Rr_lL@p+��������k�4DkS�W�c:Y����������ST�6h��ua�k������>�8Q%@�S�$ _�a2�h&(�|�6�i������N
+.�����Y�`Qw��M;o�1,~^���qA���
+j.8+i�Xc�x�Յ\��]"K?�#-d)�R�k�?;�q2D�эj#����� �9�+&�=�j7t�g	�iB�d��ˡ�@"�u��
+k���$rDY]�hڪ0��	���s$�h��.�B��S9�A#��6lݺ�4���-�i�=����gW�^5�t͕.�4���հO6�0-.^[���X�B?�ߙ(�.hȨḮ��l��HC����
+<�<��h߃��s�
+�w;�TWӾ�A\ꀈ�(`�6j�B���u��a}�Њ.����w.D�ج�_����b�>8נ��ھ�#5�K��]��g_��[�cEm�װ@��Z#U9�E,:-?��&?� �����x,�9�e����kw��>����i�N�>��BnU�v�٢��S'�����,w�n�Hq���;������>�ן>�:|.*����d�aK�c����n�!��K��e?ё��9��߻hmĠbp���w[;�K��Dr�H��h)�Y5j�f���,�:���Q��J5�0����u�pW�p�.㟦���;�T��]�Sh�"$�s5'pa%����;���a87��%�2��W}�K֊�tޏ�1�~t�/⓳�J��Ǩ��C�ᆇ�G2�V��w�㜠s�3�3�Q�n"� ��r�������|�?�iӦK��@��a~��'N��ƏL�L��2ϪИ������I��C4|&�'��B�����A<%_�i=iU��Q��v�r��ŉf.D:.�i�ĴK�]��B���5�D�3��g���ϴ�N8����|��;=+f��4m�7:���+���p"��^���ߺi�����_�Xeí�]�#�C�O��?~j��|x:�p�����$làJǞ�ĊO��l���;�����&>�e����ed��<�آWX���8�]++��k�����&�\��=LXj��:mC���7�!-��kcnh��^���ή��N��E�H2YF������vԕ��Ǿ�����%~�Ņ:h���ۆ�nb"K�Y��_!����u�WuU�Z�Zz�g,E�i�v����7o����OI��+4���&>i/<�ǵD#��y��"�z�����{V|��s�ai�NGe���j�s����y��W��T����b�}�:f�1���ˍ�'��.���������_�ܓKf^<$�M
+z��X�?�����G���@�՞��� /w��t��$�ؼ)�y�b��45��X�`�Jٴ�@nl��hY�#&�9K�4����'�`�\C�Z��'�}(/>�H�,�YY����/$�|�i�hy��3m�R�
+|k �����k�8ZQH<M�lu�۹�c�p0&L�%C�Բ�?Ӵ�v��E�%eU��x��vZ=J��M��c�>w��&��	eh���t�gNW\v�t�y�N��t���߷��Fw�w|�G�kl�'I��\1�����������W���~l�ǘs/dr��l��yC�|]i�,(��TS���1�ο/.
+��u�F]T�eM/31v0�"�<MrG}�D���?n�/�A��걩>��AJ��C��cBq��j/���?I��EĹ*�f�w�Rq����=v����"��v��$����?���B}�L6�U�;W�̙�o�=6���U��o9�l���Q4�={���]����[�a�7\�����^�{�3V�B{�1z����/�?�˲݃��ֿM�S}�>�jG�uu�<�3=;y����IäfL�/�H2m}w.C5}ds^b��A�\숆s��m�i�հ�,d���!�K_B��]E٠����Q<��f#ix�V��J�^ę���(�5U��y���\�45�=f0#�<qB�/G�PV�>�X�,���'��R�,�͞:o���s��[�'���'K ��9������cVQM/{�K�n����|OZiй�]$�w~�nomu��K6D�n@��]�gZ�s�j������#/�"����/zR��$VץXٓ=��U�h,@��.�ql�Lg���ü���pd-��9F����)[��s��p��M:ֳÓW�d���u%!�Fw�_V��6:"�&=��F���1(!���B
+]��	2���'+�
+���+��S��Q_l86��6���I��ΏÏW��D�}�'�e��w��ݿ�wy�]S��z9X�`=��Z���t���{R��1G=Q�J��>�~��I��ѭLȌ��G(�Y.�;4\�LY�1�]���XOɤ�+��.'R����5F�ば*o��bէY��z�~�]�5>�H4B��E/���@,t�|9��2����	�������?�o+��z�q�9g��U�J��R�/��7�~�F8V�Y{r97�͉�z�/Fp��\І����>��x%!z�	80�x��%�E�y�jt��'�Ɖ�����f�'K���|��>���\I�x�^�����4��"��a����Jo���ܱ��c5���2�Q�|����k�?�G��R?I;�N�ٿ����1��)���'���0���r1��S/O��w�����+_����Oj�N?L�ޅ��+��˶�N[�/�v�t�. N�/2F��yX��YV;j��8בc�Xs�R�!(ݐ<E����t�k;«:ɀY�F͌�%��
+�:cl��	N?�K�Q%�؊R��n�s1�b���c�n��R-x�ֽ�+�~J�|�/'f����&Ǖ�͛��$)Axm���y��ia�3�VE=<ǣ�JH�5n��g#j���Ǵ�S��|��Ѧ�����}�C�Н2x��=���F�:N�vL�9��U|�U�65+��W<�v��o:��Z�[�w��Q��k��z��g�}��տYW���+�Ac�0�����|�|�y�dJz���b���x�VFb���D���~����)�0&L�1`#Jua:����g%c�D�jZ��Ҳ�:�膺h����R蔌�����/�X��H�D��n�K��@O\}A�Rʑ�t,E��&<�
+�6�Ǿ�+[�����\�/$[��MQ�l�2]��K���"����G|ĀǆDG���n�?K7�Ͼ�����k��O>Y�ܹ����']�<��O<�w�[~��J|h_"��7x�K�;mڰqڤG4UXYS��I��:�9�׎��E�q~C�X�G�]P�!*��,'��˜��k�Slb�6f��ΑM�ɘ��� ����/�2zN�c�b��w�1*��r`7ϊha[�%G[Hȏ������
+�p�5�K.�$��s��+A�`�>QKI�mA&'Y�8(�?�T�D�K�_������n�������Vf?�pd�<w�z���K/��}����+/��5r>���0�6y�����DU�j-v݋'V1�䥟�Ͱ�X^�m,�C�t�^��8������9+�(E�_�S���+875�u���E����˻z�ki�Sض�Ā]@�cQ!6��&K�kj+����t�S�/�f��${� ���*?����7X���9�c��Q�n�����F�����Q�)�py��&�ԕ|ٖ�����[��ݼe��K.�;�/�(r�X������49��1���Kߒu!�NJ�}�"�����A����v�u�������4M���.8���d���v}�p7߼��qR�o��Y��,���=��/z���?�K?m���4����������ǂ��;�!�8t׹ұ3�e����[�2��Xx��u�*��&Ϭ����:}�����W�D �L؎]�4#��yW�>�g�Q�sR1�f9Tw�R�7���?ց�S�Ce�濟��~�.1ٸ���vj�k���f8 ���~��"��y=D�cd�`8΢IiZzk�z9�9�[���7�#��`�v���\�4h����g�S���c�����>�կ~�ϡ��zنw���z�F�&=�g����h�`�FcB�B\\�0kb[��*�8��?�.�Oߌtb����"�����B���ݶ�c[�A߶��M1�/�U���*��ؖ����%Z�Fb�G���6-�j�	�Mpݞ86�r��IV"o��1-���}��G�:�.?A��k#���>>�_S�Q��"��5���x����p���68Σ��3�8�/(�2r#_��b���!J�aO3��$�r�K��׸
+%������3δ����M�fۯo��?��{�4̶Y@Iu��Q�޲S�q��`Ǿ������p�P��R��9	wٞ���<�����n_��)]�r!�\�~��b�jjȇ����EM��>|�8�&#v.���9T��p�@؞|W�g�n[�����Lg�L��'�����J���2_�+K�_�#Bh�m��-��sAH��˚M1W�ģ�r��f�����r���cm����S��/<7z��:�G$���I����z�+^����V�<�u��߬�q�Z#ѣ��1�౛������0�K-�l	���y|#�	�R�Z�ݕ��+�_r +ݏm�Ee��逸�q_i��4��`s�LhB�ņ��k�/Yc��e��m���5?�c�n+�P���S�ᛰZ_)��m��E��Q�Y$�5+���I��,�,[��F�cY[u�X�#e��M�h�2���M�%�s��������Y|*J�
+Q�4V*w,a���`��|���SSD��bI�Ƀ�W�ɏ�y��<vҏ��zY�3���+1�O�?��3�{v�;�ޝ/+;���/�{�CG'n�2�{��Z�uan�J4�}J�j�b���H,�+�J��$����j�b8
+:�S�8>���>N�&�U�\c�� g�W��C�rr80G~ැc�h�V��+��v�<���;σ�	�	0�9G�"ERjK�[j�A�-���ø�.�����n��6O���eσ��e%S�TjI�D1�Y �L$�����u��.A��(+'��R��bUs�o�>�� �q�WL�o��K�X�G��\p�^=x������9+9r\�43�%.�	��O[�g�۾X	��A��b�j�_��,(�̸� 9��U:���#l����}8��8@��P��8(�X8�g6[nY����Gp�=�Rh�W�A���4������'���PK�m+="7����i���ͩ�����s^��o���<�G���������n���������?��N�ܴ�|�	�=:��R�B�	`
+�i�QJB�V�5++���G���B�=1�ck��g�n	�t�	Ýw�m��\d4��������sO?M��]z7+.�O���&���P[z��e@@G�/¢��g�~2<���,��roR#a�o>+L4+/m#V��7�j�]�X����,����9P��%�U*���&K�3(���`�P��D����6���Zv19��
+�y��U$��Lg�����dD�n��v�2>5O�5=���u�c�DC\�M�5���������=��0��M?�٥cw�Y9�i@�ml_�7�7���ǁ��0��ў/��~p_.�A�e�3ۚ������t\�������E�S;kq��S�I��Gj8�7�j#[���ZÁ-m�e��x�31#3;�LÊ�ư�}��m.M��Q�)��m��{5-}��GM��j��(�h,O�����͋���ώ�W�RF���E3\Uz���"\!S�)�gڇ���өW{ߠ[��f2k�C3��Gj}N�i��~ӘA�"�zQm�}���Lz��	y�A%��vL��D��W_��a���LI�7m��`����o��+�w�Q`y���7�#le�����e#d�?2f1�ي�9��/f�!!�d�ʖ�bh���	^x�K���(�A4+6�d���mE�s3�̀!���ޜ}�PF0�����͒)A�@MjB���t'##?;"��Cʸ7?Z��Ȏ�����>rPl�j��h�l�}'�t�_QS��ǜUO�o����{����+�8!Uߓ�0������e:L��QJ��3}@[v�m�'��B;=h�RH�ɿAȇ&�/�)��ً{-CJm�b?���n1"Zׂ��l�	߲��+@�ֽ������F,�.�Z��a�'8Ö��A���V��F��dJ����Wv7�v��X�Z]������VȞ��|�6	�i���/����~�O��eY�!@`�&_������O8���ԑX��/X������1G/�!.���Z�d?�0��N�P.���H$��X��q�Zj�PIF�ϡѸ�W1�#�T����hZ��饍n�x�����2.�t�S��X9t�%�m��o&�Ac�ԟVz��5��˲�q ���o��ij9�g�!W�H�|@�y�M�6�r�)��V:d�\�=��E����W�.�LƓi@q�L�'+Oѷ���j-0꾲��u��BL��Y����K���U�lɰN���և6g�<X�v��t�F���u����ͫ�Y�0�n���u4�P|��A�)1�]�@����_�18ǁ4�/�Ç,U^�<���i�N��5�y���i�	��m��7K��C�U�}���xPL�:�$t���U77<�������r�����mj��E_\�_8<����'��F�Ѩm�^%���~]��^��*��*�3���J}�)��ɾ%(bGԱPm���;Q����5<^�9Lأ4%�2a0c�m�"jy���1*���s?�g��Pˌ��#�u%�5�v�S���@6��6Z�5��w�J�4(�0'/U0�j��0��g�<�^���b}�)��9�t"+e���Ώ��6	�gg�rv���
+�}½���M��9����U�Α�CD���2��>�'~�u�g~�T3�EO�Xd;� <��ahB�����)o�Y���4��DO��GRߗu��V��1\s����}����ݙ�-ߺ���K.�A��a�~�����MG-[D�Q������P�`Q<�8
+q����.9�Ǉ_��{�q�-8�B��ͼ5��HǞZ��UQiue}�B�5�x�Ѽ����3h	6��(r���|�I���3y�	�o[8�7��g8s�A��FKGbF�+g�GJ!Xjf��>ػ�~����������P��J`1V-���Vxh��ח��?�P�$Hڂɲ$>�I1�U�$�=��$WEJ��Ik �L/ܤ��L+�o����?K�b��3��V�:顇���w���H���g��oWg���:�+P}$��_�\�ڐ'!k9�����/�R-��A�/�p[�y�΋>��6��i�^�'��MX���䨁o�Vգ�j��]uhr�E|�\v�,�K��%�[�r��.G_�����_���ȯ�ݭ��{��ٽ�߿_������?;%aU#J���������`�/4�V��q�zV�f(��d�|wY�o�� �E�t覥��A+ի��+W+u�yݚ5��uk�G�߭_�zݰF��d�(1�����ȣ��ؿw��I6Fq��]���q�p�U/g��\�IE�5��l�+4WhV(�����-�Th��wo<���ry���g�y���S�W�b\yC�uz��r]�GH�mC����k���?�|�9M�7���Y�z��W�_�_-\5�~�i��Gi:c���hb���z��>N�K�zݖxm���U9��m?1�l�?�&V2�m'1m�{(�*���t����ׅ%ÇR@N�X�=w�c9��.�zLi@�r�Fx3���
+Zd���W�<p.p �B`#'�g���v�S��7�dA���)��X[+ME�u��/�kJ�+�$��Ú�R_3B���2�0�m:��%�+n��ϥ��kq}����Gb����3Ͻ0<��~@,� A�= �t�q��P���k!ߩ�>]�ԑ�J,˵S٨�M��;���X�[Ts��a�n4r8kܣ/(�g{�MF%R�,T�@�4��7L�FތFUB׋\$���yX�B~˔b��f��/��<L��3���}�<>s��h�S{%C���r0�e��"�o���K�EË|�����kp�ϟ����h:v��+��AU�����ׯ_7�a�p�6����-���6W3�hg���C�Q��zUW�^�=�hs�	�����C4�gb�<���%�ܷ>�K���v�!r����42�.Ά���>��`+�b�ґ��q���񏢄H���VR�xf-,�<�͓י\�CGQCpb���O�>������SO�k�
+鵼0a9���vM��CMy3}�ZB�z�<�R���{������S�������Y�a8k�)Õ]4�tܱ�\<��H�Ɍ'h���V*�i�l"����Ѕ�(���݅0kn��EeM���J	�~�u������$����+e6�BsIՌQ/PURur�&��o�N$���Ar���	~��Df�s6�I|v�͍���P�(�:��m�諆,�Z`KjM2�p�a���J&Hdz�0�°��<_��C�?q�'�c�RX��II\���8rLP����{x�p�C�~dxmw}ӦE�!<�*� �Fh�!��V�\b�nSS~Z>��Y]#㹗^��������1��/h���'>^РFc���ew���2���Щ=*�bo��#���E&Qi��9��E2�|��K�+tG�L�b����{��lxDWm^}�U,�>������|�>�t����P�ڱ�d���P����z�p��gk���}ڽ� �/]!+�Dn�as�0h�xب�>�h��K���x�iݳ�s���}V��E������]�;�[�eӲ�����|]��v�hڦ?)�M���Ak��_�����N:e��*Hmc�iFm��)�g
+[�ݶGoū,��&��mP$�����j`'�sʙO3ymy�w��5<��q���xlx��g�#�a�?���ñ�E�~�?�׬5k7{�p�'�[�ɲ��u�u���Ǟ���6mv�Tv(	���~�ž�&J�a�+6�v�+�x�az��-4�$�D�vº�ǎ[�:0������H6�
+;�d����.�ۺV�����h���mO�Ll�OzPF�˟}��A6��ڏn�������e�L�D(s��$yvz����7�u���5�l5V�7o�.��M��\�Q���w�9+EXС�1q��q�=�d��H��t�G��kk�D�h���Z��+�Nך���<S\:��n��rh�˾JC��G��m�-�<��>Ʉ�����A�Q�ne�n�|d���l�G���j�Ŋ�եנ`��Oa)��W�3�8j��3GSl��[+�;�ݦ�2m;wB�|{�V�m��e�,��VN?-��o-������,Ӏp�D��?�G{�_��_}X_��(�?��`&��,��_4l?���� Gۘn�n~��d$�T���J(lxU|�L{��8!s��Q0�a�O� g9�0[���*����)�趥�8��z��<p�٨�g� x�^��h�Y����K
+�t?���K�]z�k��Z��#G�)ݦ�+���;�{|��_q��x>�����i���S.�����32(�5h&ٓ�Eд$�)����df���¶'l_�Dg�.Щ�	�F��D
+��<У)E�k�},/��r}�Qr�#9i�Ȑ�?((�ۭ��G�)������w����ؼC_���_�xzᙝ���Mɶ؀P�����\��M��f�l�MTL�.�Y�g��MԌ�9v�ۦMǨ�IBjR]������_0F�@��f�]#���YUa#Opd㬍���t��m�_f�R/-һ�y�Ο�Dd><�ѥ��Y\�rh�����ؼ����2;Tc��: ���^���ciAU��_�x�{.�������5�fxꩧ������c��n��ǧ�u����ޫW��+�5z�!E��+�/�7�_�g�2�䃐�������?�9y�������<�>ޱ����Fm�"�)�R8�c�њ"���UPђ�b��F��)W4K�(ݒ�dQ:�Z�8_)�d#������ηƐU�;�5�c���Y���bkÚj�_��Q�6���+�[��c8j���(��W��uG����.]v]��
+���Ϫ:F��Q�Iܿ��a�n�*X/{t9Yo��k�_��ʰS;�Wv�^捃z�hNz�~	,��>���B�+��",>��E�����5����ⱟj#��~���<2ܢW�ޭ�%O�7-�x�'�j
+U�G�շb6*ݮn+�ݷǷ�Ǘ��/���k�;~�b�M����}~�FW.>rݵ�&?`�_��<}�o��3�1��y��J�(�Xp
+���8;r��X�T���D�؛J�ȅ\X�6�f��O���<ا+��2�X�,֬��K�Vk,�D�<�}Y�J�0ȡD�t��̛�o��iLg+��>G]v�e2�dà'5�*ݦ���q��C�3-S��b�E5G�}��䚜ĳ��p`�]}'�+t�Q�	c�-U�{�/(YI׻��G�����;2�Ͳ�m	l�3m��4_�qQ��;���o�+Y����)"�
+hg\�d]=v{�q�qz+�q���q�m6�+eu�%7��x!|ed��|g4�	��K��\����^�����\jC�1T���+;w�1���^��Ͽ8����d.��Gm.�eߋ��� )g��@�R���  �1g�H�	U�_0�R4t��^�ǜ�c5eZ����dv���}�fJ�e��<�b6)=v���d�Hy���h�p���w�~��m~�_vG�튧�~��a�"9�@�Uߥ����ԯ������ޕ[�%J���ի���l���$�	���:�۩��^|qx�'��������-�Ii!���.�����|��2���tظa��zcب{<}���D'{��2ׄ$V�ȵ���b�Z�������c4�@N]�"2>�F''�>�1�%��6����>�D[^}h<3A�M/�02+F��z�B��|85������[�^t�M7����\ ���w�6RêU�H�20	��̘NX�e��AiS��|��J1��+�oT���N�C�����P��*_%m'Yۈ��6�δ2$����R�|m�-��:1�O�m��EY$g+"�{e+��#���/�����@�0����m�UOw��}ƨ�Q�u�(��	��uk�SN٪�޾v�I�2=H�Kz"�ڹ�[������+Rd�ܱ(EV��@���C|+J�ZsO�㪧��OC���\AxR��󸾦��~��cb���q���
+��'��9{�s{虀XԔPL����e\bké]���hk��� R�>d�@��HM�:ƌ�Y�G��z�J�R��P��j��䀗��	ImM��
+ӈ����-������_��s�3����Z�x�;E����+?�o�Az`Ʒ��FP9Ҡ�[�G$�C�=�W+�ƴ�+���$Vm3�xh�Z�g��t��{�+.���L���o�GW�|u��!�c�����P��\l_�1���+ ��8����=��Sf�I�xJ��R?<��s������"Yɾ��������>��Z�v�j�K�����y+�z%�����b�Z��ႁ6S=��o]L&A8"��J��Z�� B�����Φ[Wm�zė&~�q�o)����_��d�����3m�|à��sY����*v��h��R5s� P���e��a��"n��\	 8>X	�/���dh���.�:R�}A�f8�ͅ���qV9ؗ�8BM^hkS9H�0�+,+�{�d�A�c�~X~;}�w��c\8�����^˻0��1������Ȫȉ�q��.�ܗ����7�m��C=�5v���q��I�8`�XXV���-�෕�aى5�'�?��96�oo��h�1�Vnu��S�)��v���Ȃ�ڢ#�re��5��~-�!�N�Q�3/��w-�ݻ�i����_���l#Rv����Y���m멧��Ǐ6빌���y��8����B�k��1��>+�nƧ+G�"�[N�i1�G,ȃ��U�xP��+lAձ"X�[+aH��U3�v�����2��&�H͐��_�$�t��l��^��ϗ6MiQe��H�& .2!��t�c�4XN���ߠLj�8syx��%�Vc�O�{�����7��V���:]^=5�BțhAő=���Ft,R��5>�.8�T�x@��S��5�H��^��/튯,Ԃ�B��,?g,x�C�j�_I�B�Jx���#�"G-�E���e��zO/V�[؂��~�o��������}+t�M`X�������_�oWlՓ����z����+7�ٙ J���{�38��G����7��M��՛��9n̵�w��pե�+�+�co����#���FOf�M��-�K��uC������uŊ��UW]3\|��m��:�u׏��k���1	��bZ�F" �b�ٯ~�k�^�+=�5�^�W}P%�l!F���8Y�[����:ziS�9�
+I0�&贱Ps0����]Z�4��A@�{��.+o�{m�w�@����f��:�񁱚��j�^|��@�{`$���X����6v#��}�U������51<P���1��>��ܱI-��l�op+g���|x���|�m�@��ʹ�N1\mj�8c��_�Ȱ�o�*�q��:b�no��KH��׭j��{8|����y	��p+N�3�d���>Ƨǟ(E�H>Z���5�,Q���6�ib,���C��m�bxy�S�@�������b��ѽqvx�1��Rr��K�N�E6V��u#�:ޙg�5����/���Jh.�c��TW�8����7Q�a�+)�9��b(�e�8R�2��`�$�p/<ؑcp���*2�N�Ȫ���+�j&��#?6��%���
+,2��(~�L�6hV8R}ZiS7��JǣűSҙ?��_��R>���ٵP/�Z[�X+X�ӽ���b�"���1@��q�(:����?!&a���6v�Jrk]�{�:,�m�H��m��/��TAtر�?g�������>��?S�}fF����7nK�}N��ѶC��&��m�g��c�g䫢����a�˞|�I-�+ �ː7�?��w̻�7���M���!�?��?��?�V/L������G��ח/Y��K�6�%2��ַ��2'X�T��	/��!s��,`�g[Ŷ0��ŗ� ��8��e+|B�Ejc'���j���(o�C�͉�������LP���9^�+��s���%W����� �>,tW]���*����`+^�W[j���k��=<�[;�l�8l�޻��ms�uْX�I���a��]���U7Pdi8xM+z*)�x�SN�>���x�&�K����O\�>�mݑa�`9g�>6�G)Ŭ��+
+����@m )�/�r�7�s+I��TP�!D��r�pQ�D��^*'<R�	~d�m0晁$(r�Q�Erl��iI�"�&$4�*��+t�c�k�`E0���t[��4�[�+t�#���6�=�J���#s0����������6r���v��m_Љ	j��j����'����3u��\�����N��F~�te�[��}�3�p�AA����9��*܂3v��6�nC|�{����s���G�S���_��1����V�)mwz�-���/�I�Q�����p�e:K�s/���G?���+���9�����Mr+��Q�ᢺa��F��^(�LM��E򏝣�a[}����X��-��Ǉ/}���z�pX
+o> Db&��n;�����2,�+�k{��T?R�7)��X!�^�^�1��hiͦ���s5)�3��S���)�IH�-�n�6���wy��T��>�cT�6(D`��������A��'����/_<e	�l���W�Lmj��x��i�|���%����Fꘒ>�_x����
+�����}���y�.��>��M�K:�lJ+��K\��:�9H�P`1�K�2=Qj��d�4��}�,��d�n����U���;ÑR��O=xQ�qFj8�x%�Iӱ� ���x�Э�9��.|<sBkY:vR��|f%m~C~��.�m}�}��յ�
+(�N���k�C���6�
+�K�V�@��,+0���M�K�[����E�����8�k��`�7~ߤ���;�Z!%��u�y��o����'���#��Mc,�M���]A!|��5��BFr#ɱ|@��z~����̒�ȺN� �LCM�Xf�m`�[�/��	:�o���ɂ����(]�NN�5}���@:�1;��Q���/#�0�:0�/�������=]�G��zI���lT���ߥ�5�蒜$���� ������n�F�t� ���3Hz�}��� 	�k�ч&��ia~+����k���#lQ��bE[A��c��o�ҳ?��{zx�F�*�]��9�_PĬ��+��lf�́>ݚ�p�n9>�^�G��@��4���?X��.dO�OP˳l|@�[�0�	4��xhq�J�G�-��`�@"
+J��gt�����̖�Nk�t�m�c߶c��+h�l-�GM�alO"�/��6�2�t�W����Y
+K��;���T���N�i��B�K��^;d��'D�#k��g�j�Z59
+Dl)51|~��c�8���W�PB��=�)�8��Z�0ɜ���>�4x�o��}&�qtL/95�mrT�e��>P<�7t��?&+g���]_��"ӈ|,�l�Q_r�sbZ�D;ٱ���L5��(=�P�&|6�b`[������0���9Տ�ȧ����C�^,����=V��D��@'��F��7/_2��Ɗ�e}?�~�+�����!;����2���b�����۪��YzKާ>�����z'�I���.���z�)x���I����g��8�&��u$��t��CW��1E��P�H���J:<��=g=��s���q)9m��x|X+�a#��Ϭߺ�vV�1V�Y+���,�l�ʃ�>7]�G�ͣ51�X�h��5=7���y��G�`���q��y���>|���W�-�v]0TT+V�v��,�N�0Y4�s�SI�LeDќV��8�1ެ���\�'_�`�E�������;�@�j�^��1BD(m�������ՖSC���)o�{�7}�)p�r�9-IR�IZ�1�J�>����I�XT��&���#�Ё���78@��n�NC�cl\�Y��GG?{a�cf/���R����cy�S?�sy���Q�ʊ�D��b�8̐��Mo<|G.�w�q�6>����~D߹S�Sl�$^V�v�B˟����M5���\WCGߋ?҈�9n2�g^��x@04a�q��NQ>J�GB֓�=�(�\G.��O�������|����k	LAb��a1 k	6?V�����0'��L��E(G���`�+�DK��f��~�$��6�^[�\����g,���uC�v�9���
+�F,������ȃ�b'�c�1����f"�h�1�ȧ��)��U��&c%��D
+Pp����u�G7���M��P���rBb���ה"f>�'7"�Ad���/}@e'��l{����w���q�>�,�W:Po���U+��UC�2�w��7���^��&��J��+ ���H_B|�Ļ)C�<�0r��Fc	�ė;c�|��GK����_����?�����x�/>8vs�������1��7������|����ˇ�{�ߢ�#c�GwU���L��1x�İ���&~�ȋ�L��8b4ul�P�w��i{ ,�BH� ��Sr��x@\>Z�S��|�������x�C�́����b��G���u�9�RS��~����c��?c#F�A���̟����𠐂�.���M|��y�
+��<�÷������|�����Vo�h����?���?��P���y+�c��R�?��'(��-!2Q����u(>�c<r�#�Ӿ�G�����[�#��*�4�G�x�F4z���.Js�yl���&�v�#����v��K�7�ɯ�M���T~��o�[˭�S�c'6	?�����3֟NF�����iC;��l%���k6�@wD¥���9�t�?:�H��ųA�L6+G�B�ß{���3<1���
+�T���λб?��x�@�S��ݐi�On�ȺR�廅%gKĸk.J���5�	��荿z(��W9�j�u�ׯ�M��{g.���3����G�~*����|I2��}�W��+�O �1q!�'ҽ������o�*�s�K��'@??���]���yP˦�G�Ƽ�Or�De��Cy톡ދY�v27��X�°oJr��@y�r*�9��(��hSe�U��q"Ϥ�~�	v�6NPa�+E0:f��3�����t�W�~�:�ށ^u����嗱�b�iN-=�:���id^ϕ��UO�ؔ	����rC1%�C�>B��J�W��T;mC�R�(����O<��;�1�M̨W�G3�}��2�����L����r
+�&�����UN�qn�Q;�Ξ^8+2���@����<�\>R;��{�Д����l�1_�}W+yX�/�
+q0���J}0�_��@��X�k)9;*@ם:���!Oޠ�mj1����c.�C�7��i�D�h�.��-ǧvŌo|�Z�U�k9�5�����=���3Z�s�K�*�_	z���������X?��1�yᯤp� {�Ȅ�lu�p��a"1���I�^$��"Ս1��G�6�r*��ģ�R���Ɗcb"�368�saS|e"L�r]*��>"���!��L�TE&m�HN��ª���l�C^c��*�Q6��5md�u�7�'f��(�*Ϲi�J��q삋�,��y![��"�(>!�6��A�D��"0
+9@~��&
+V���ܽy�٭^\�Q�ߚ�_��?��"0���!�����5nMʷ�Gz������?���q���\���w�m]p�aa��oD��S7=v7�7qOX��h�R��h����}�׾��z�ضe��yxe)^mhlDKc�!O},�vQ�s5]�r����&�-�i@m�Aޗ��Y�I~��(�jԸ��s���������3J�3&6������R����p�r������UZ�h?�G�c���f���Kj���z���q˚ϛ�����n�\N�P��M��Cȡ�a*��:��X��g"����v�Bε��+�OYE���;N����o﮻�t9�覝�0M˧��y��}�J�Wc��G�>�	IG�I��5xMX(==���dC�ylã�z3��.N6�+1��e���L�uj�Jų�OW�M��g��Z0#;�y{i�ܒ���B��}A��X�͆N���d�\�Y����.q���\B��?�c�`��[#H	�wpW~��y��g��b~��g���(������������w���nɗ%�ܬ�c����xn��#jF7�2����γLőq.�ۓ^��fd&�_�Rֆ���YO!X�X$`8=p�皵���|D��i�,.��O��W��B�OL�B?�+v͋N)��C���� ��z�o�s�����n&F������kb?�&z��o@`�	+�����/��p���ͷ�EҸ�-�J��<=���Muw���Ł��X:�e��Ʌ���4��=-�9sz�R��xED�\sQa�����䣉⩞������g�����9g�t^�O�[c��r"���|�s1G��OmC�7�Exd�ó��Ȱ����~��>6QJYڔ$����C��l_�G+�[�4�<Q ,>�ӻg|�@��,����.�I��Oo�G�x
+�M���A�۫�f���p~L�}�yv����&��:)_my�8�u]�w��c�y=�����O�������\������uyG�w~�;oͻ�����?p���g(ɑ~������[��$d:y�f,����8�n��;"F6m�#����b��d`'p���L?���h�߱�u�V����ikG+���S�"B�`�|��#�v��k."w�uO�8�¡��$vT���'?}xun+���5�=����|�\��;��^HI �zP;�Z�F�������F����Z�2�0��Ķ�+��\�����Q�x{�2�X8L;���
+���ԕ�A{��ㇼд����/
+l�N�u:�b� ��]:��#v'���N��`s�1�"E"KB���,�q�9��'O�3���\.�_�=o#�Eb�>�ý+q�`R��]�bQA�E+��Z(��{�H+S��͂���]>}b����?���O����Xdu0�8e�\фч�6���_C��dD���o�[��^��vev�}��G�~,�^P+�պ8h[����������PSv��x��L�o+&��v#�,?�N����e�>���("��>�R|6Ј;���s�M/!L)�y�����c�'�<��O�;?淘Ԕ��Ӱ�ˮ�!^�/���w��Û��_�Ƌ��u��Φ���~r�g�.E&R��8�~|v@:��@1�e�D��`��5Z��L/V�����O�������)�O�q�9��|o.�!%s&.`���:(��G���s�Y//�w��y��������XCu���'{�o�*}ƹ�>C���rX�k���}*N����k�h4gA�촭A@Kα]Z>*�:���T��[5y@0�JG
+��������S�b��͈���6+7to�(m��z�!3���4��f�J�};����P];Ÿ�_쾱ua�p�q�5/��ee�[Aj��q�2���s�n+�q*oػ�z:�cjәi���7MA��=ruS}p�U~'GbP�����)6s9����0�B���Zt�H]���Z���Z/��Y{]a|@!�N:��9��/�:UFmIW+�O^(+��6T�0t&��`(�F\�BCoqF+��魞K+c�ϑ3��DC+5��SӾ1k�u�L0��J�۽sR��o�g��]O`x�\p�嵭5�f7�}�¶w�D��=�Hak �����G�Q����0�)I�&{.o3��y���r�p� ��)1v���|�2>��R���ď+�m�y\��<+}*:�\�e��S[������͆���@JlS�<�-�0�}�3�9�o��>�яF���j�|p,�ơ���{�J^������վ�r�"��í&qKs�&L��+)]�E/%?�v���Bm?!-d���{+n0+T�g���	��ʀ욏�����t�r��5��piD�c���=8}V|b���˜	ޔ�鈪W��2�5<�}��F@�8�v���W�%�+�l�!\��׽�+%t����Ґ��+�ۦ~��$%Kz�VL��ɗk#�f��a��	*B��=0���n&�Q+t���A�%Ït:4��"�x�� ��b��S��le���`�Ɵ,C��,PzDt��z^�3������|��{V��#���i�|����|��9f���n���*G���f"���^��U(:f�ް�wx�?���W߈:������ޟ���Qo�h��ɠ?b[��������w���p��kt�5v�X*ԎsX�q���pV������W��]�T�_h]Z۽�ן�IU�S�l��ι��yA<����vD�1���8CF�|Ɣ+�yY�A3�[g\DJw(1�x�_�,����b��K,)�M7��S�O��գ(�֨E�hy���wߕ��x�,Ԍi���r�N�V企�	�~��M��:7Z�7�:~h���g
+�L�=���T�e�BZ��)���>�b���u����#r�-��f�b�'?|rm�SB��5��R�fl�>6��}m�n��9@|��D�����{����-��m<��@(GL2V,0w���|A+��udË0k����ok����?��\zΑ���WԖ�l�����G�e��g�ͧ�x�3A��;Tk�6x�b����WYސE��u�lf��������Ə�ǟ>�7o�S�>�W.8EI}C���_������������\4����B��'��&>���K�3ȋ���|ܑ�`7��;MD����M������#f������t�S���s����E G|���g~�i�ɉ�`��U�G�B�6������e ���r���e_��mR���\>.�����ؾN� D9H��5�E���#�M7'��#�
+�k�:�����'>�)�OC�/sz�+��R���+k��p�qQ�7��H�g��i�@��Z]����>��v>R�79'�ƯXx��m�k('��)��³�w�Cs�ǖ�f9����D��z���~x�G�i�d>���>��KT��w���B~�l��K�Y8�7 S2���<��Ћh\D3K�I��&2<=��S���MF���C�������#�d�M���`�Ӈ6xX�̘�et ����[iia�.�.Z�q��i[e����\�6&h���Q����F\�X,�t|3R�>�	8~sㄬ��ć�.&pr|Ͻ�>�|~��a5���w��í�}�v���z�`���6ct�j�Y�tJń�#���)ݗ��- ��S�?�?v��_�O�"�G���F�b-_�}��o�ݿ{x탯����n7�&&9r�O)�5L���~/��!X�D���aM+�V����H�_9kC�R���?s������y�<�R��FD9�0`���3}���MA�b�Z�0ʅH�'���ȩU}]�i�xk�'V�Ũ��t���8`g�^�3���`]4M:Z[:�����:X���&��5*���	��|�.�)1�H9^"p`G~>'���}��?z�_�蟷pۭ�n��V}�����1�q|vO{�!�Vy������6^�#�`^f���)/��46�J�a��X��H������&������)��}�$4�H���fJ� �i���_�(���Q�<k��NW���曹���	�� �
+�|_dƷe�+�ɷWް_�t��"B�;x[�'s��=�%$�2;.^kF��S��g��c`�vBxÀ2�E�j�9��4Gf��l$�v8�hhk�S�jB���]=��b��;��4�e/6��,��eR�8ĭ=�����X�Q�"uʼ�5�=��65%�o~�w�m{yT�v7Њ�qtI.�SV�]��x�Xܙ�W�#��m+�c||o��;.�>3����ܣ�&��gB`��}B��9��em1��||)��*
+p�}��+��i/m�#Y��L�94�j}{>/Q
+9��l���b���nn6�������FI⍈�d��Q�Ѥ�˝Z��f��*0�CX+��y��b����>Rγ@̓{�`c9h���|��nz߀'�d�x�0��in#������nU�!�b�uB�h �Z{A2�y�ڝ�!vP6w�k�<0��AwJ�Q�����58h|m�����Ô|�j���h`�^�|j�kߋ��U������/!�@���K�]wݝ�����65�����˧~:�g�6]��vq��b`[3{:a��ER&���>��P�F�ڽԔTʥُ���߰�O�j�i�pёiÅ, &�(<���Ơ�` .{W]���+�����G�Њo�/�H��W?�`�+��٩q$%8#�vd:F�v�P�$T��Q�j��<��b���<E�YeƟ3,���-:��9U���N�� @C[<r�r�����"z.O�b}i�P��a�A.^sp�:	���4��~�_v�飀Y���e���M��"����@N���sȺO�g���z�yی����<c��ß;|2k�Q��AK���<��R8����E�c�{ؗ\w�eh@r��i��Y���4o�k��5���+� 9���i�@����-�ʌݧ@-h�W����29WW����k�#�gIU�v�S�7���F���/(lQ��3+�ym���8�U&>� -�>ȁ���E�u�}��Q�/F�%*Y�7s܋���k�d���t�����o}�[ogts�A֧l{����[��c����C<�.��R6�}�9��Fy�<1�$P/�i�q��@�cl���4-�m�.i&Swe<���Y�Ҝ���6��Z��O��u�t�󂃈���A��Y$�}�`����u�W�w�1�&������2/��y�[�4�ܒp"���0�~�z�zՆ�߷&λ}ڿ���~���G��/����'���۶&�y>_!{��o�}xͫ�]}�Ǽ�$F}�l^�k~�W_;���S�8�rN�0E�T���O.H����<v';i1B}�f#)��s��,��-��2�ۆ�T�U`��S�[��-��Γ��p�)��t!_#�������j0�c�W8�(�F%�+%�{e�L��/�������c�0��:�
+��i���=~�Eb%�0V�Է�I�p��+vZ��_�_���F�!�Q|��M%g;s���DT����m�5�&���*6�tèO�I9��.��0)��&K����_�Zc��"Fl��\b��\���ԓ8�U�|�������,@�Ɂ7�ቋ������C��T_�;�)2�חm/�b�4������+z�p���lh�c�)d��+c���>��[�N�g��=���#�����5�g+E�E:%|X-h4&���z�&2�����<Ҭ�����cY+�������>o��u�g/(AU<r­1�������W	h�18ˉ��n�pԏ�Qj���ح�cFj��/�'��Bg��z>���3�^d�w���y����'��m$f
+ސk���6yb�8v�B8"`�g�?�L+22�̘���@p��_9׃s{���7�����Q�v�m[D8)�}��l#gǗ_��?�{QG��
+2�z3�<B���H�؎+�`F��d#g�,�}cf�{��d�p�P3����3ѹ+��62����rz)���!��GЅ��o�LZ-�;���S{a�.w�N�.����U-]�ʙ����r�p	�����1>#��u���޾�����t��غ��n�)�o���y��of�6�Iч�'�����.b~v7t����Qݙ���X�����_��O�4C�Aٚve[�F���{�w��_���:�
+?N�f@F!d��lƭ[l)d4�9�r�+����Ν�_�9����̻�'8���r����^�Z�I�i��6�i#�Bɇ�|"O�w���{B0�����q+uۇ�7��-R����3v���d��̏�Y+�y��A�H�X��8��s��jSW�9�c�ύ }�؈����;F���v�e�@�~�����ѯ0;�������{Cd�\T,f���Κ�=��M�7���ƿ~wů~�7�,VnFO�#f�������&�`�����,��5s�A�����u����8_��R�S,���8�����[�D�h8,��O_��-��:#��ϧ*BEǽO|Nke��yl	"�7:Ka�t�k1p���dt�ڄD�`�s�M\hm�˜v|�F�+�:�/��ճ������563�{\�X���a�ܯ���&��L&��ňL̥޻v	R�LN��֬��p{�f�L[Ӣp�\����rw�4�H��l��X�7z�Iw�	��d�(ƪ��+�Ֆk����H?�-+��P�PS��c+Gq�s�$G�����P�wZ۳���q�_�4$��4�O+5v�����[�I���F@�Ն���9��ۘY��%)�.ќ/��qbG2�N �B��N���onlY�����S��Ԟ�6_���_��
+�xJ�nuF�"�.�-���	\*1�W?����@��NN%��Y������3�� ��>`B�XC�ph�cpY�!(d��z��s�c��J��O{l�:�zא>�X-+��j0�근��������\�����a��v�+"�?��u�TS`1C/����-�E63�#��%qx���3� �/%c*���t˭ϡQ֪�>���=�l���G�IT����m�.#$:_��׷���)%��=���C_�5���E�����K3��tf��� ;n��C2GX�|��#�y
+�h657;�WN"Y5xEI7tJ*�����;��i�p2��7(�)O�C��Y�����Ps�������s¿9B��\dy�S��'fބ�v�͹�9w^.�ë��'l� �9s����eWt���U���m����C��윘̳
+(�C�aҊ�o�-��k���|�����	q.�|IL�U	9u�5��{�s���ڽݙ������������o����H�����*�w��^az�F)9y��#b�����ʟ��9�6�98�UXx���I�k�����e}N����f'�"`�g�	ڻN(e���z�f;�o-��F|�Ih/�K�����W��M�`j�?le����(s��9OKY!?e�'����.\�?����M��H�g�|`ױ� 3ib�1K�bH��I�p�>��/��^v���.s��3a����"�)�|a�]�x�I�I�Si�}e�O���*�Y����o��"����S��&9}�a���G@���!^�f�CA�y�X�a��e�կ}-��(��P���@�x�h+W��5�bO�Fn����Ǎ����J}[�;�~��Y��Ĵj(~d�<d�i[pho����/�P4pGA��Y�WD��}6/����L㫷7�%s��aW]���D��~wi|A$O]���<xU����.�hb5�^䥙��D��M��W�+�?���=A%�a�9R�*f��c�!�+l� ��I�_)H����a�[/�����[P�jm�+�|���dJ�6N��mc����8�\��J��z���C����Kr�Ҵ�V�����Q|��c+tf~@g0X(L@�ƻu@�b�;	2)�IC��C/BN�5q�BI=�]�:Q{3��_�R��c��6�rv��ф�JZ�����쌐����O�@y�h�%N�v�'Ej]�K���>u��l_QD?�W��u����och�*U�g�r�������7���㝹���st}*M��O(7��7��[��O�u8��+nb�Y��WQ�� �7}�3ƣ�n��{��r�iAL��æ����-���!���v�j?�y���W2O��R|"�3�7���7����m���=�믻n{��o/{ɋ�����hU�ʌ˃٢�y�eO}��5�G��qcS&��?���'�,z����B�ӎ<��a�\R3�j���K/�̯�-G0,������9�|k+7����@�TuMq6m�'{ճ�q���Z�\0.2n����y�EǼ�Ț�����2��$4*�v��
+}��.m�9�b��d1�.�e	��&��~�����+�گ�n������.�g�ǧ����7����yW�7؏n�~��`{����ӟ�l�w�NPR�з�n����Mo}�vi>���-}���#KtyЖ�62����o\ -�0��@�;&����b�]�;+y���_���{˕��ܨ#����<��
+��%�������󗏡�y,��{_d/"���_�W���̙��	~��-�}fN�|���\L��=�_�5���b�c�����2��J.�	ǹ^��2�D�l����W-�R�� `��h�
+q�c7���a!�Ղ3���8бAm�3��'�G��bw�f�Jx�c�p�����t��rQ��D1���a��������iHu���Mm.��Z���;��?�68^S�n�Gxz���p��гK�ctK�т=lg�>��Q��K3v�2f'�N�x��X�Xm癞Ϋ��5�9�g��`��FD'�C�3���Б�	���Q����g�y7b��:O����D��R�d�k���.����ݓx��'(<Bď�)�{��+F7��4�R~�1��3c	V~�X|�&1�o���7@�)h����`(�-8(9�s��O�7���\�G��.8�`�<��O��Z?���,��3+���y����|-�ґv�]3��(>�H���Nf��Б$��JXDϼ�!m�X���4���������=�eU��e)����K-d�T�����ox�bKTzB�)�e��{������g>���]��?��sjLD��<�3��o~ۯl�\���.^�!G,���N�k��n '(����SfH'�iߌ�sʟx�$�6ɑM��_��litoq�����7-�.>@3���k���������;�?z�j_�O��M}�G&��A~��?��?{����u��\D7B�4����qMІ�?��*���v�(��T��<4�+�H��[o���+��������Ď.�8|*7�Y�����a����gd�'���|�o�]����ʙՁG��bЉĚ��?��}�JK��q�:��aF9��-��`2����0�Fc�\�vZ�5��s#�5�]_q�yF;t}��|����13��؎�6��sq�=K�&q@������1Gq�-����&��e��F�ʎ����i)O��D{�=V�0�#=z~
+�[�F��b�m��7XL���+���O�/ya+k��*�HN"k�a�56z�YG:y�A3�skdǦ-F�r�.������G��*_zb�z�;3�#E�?��0�E4z����y.�X.kQ��Ms�����W���l��w�5Wo���Wm��]���w]^Y���o~c��9�8������L���_q���/��ݦ]��K	�X�}(�>cΘb�QR�#`�ȍ}�"��'@�M���Od0�.�i�p�Rw�5���kT��n
+�u: �<���z=�џ`]�����������T:�<�S�𵇝E�, ��"���?�C�/�Cν�Q�
+�c%��{0�+-���'��7��R%��d���^��-MK8D����]/�a����%'�̃�_S�C�s3�K�aH�!B�&�8AWu�єp7k�24�x�ȄmK����C��Gz}@o��|?�O�g+ee#�.넚���'����F"~sa���4��p�i%gؠ�j	�O��#�ɲ�Lj�b|�G�DuU�k�cqN�9Ni�H���O�W���K��F}�'���@@q��^2�O[I�?���R�>��}ޝt��
+fF݉�$;��$���f�jC����_���=��xtx@���Lz
+4k8�m��Nl{���H/
+w"���MoC�o�'�=��F�E�F��ԉ
+���b�x�Ł�BUn�<<�P���?�HUM����0&���G��6hL��pH�ħ�/Z��������O�-�5rR��'�Щ_�?���/��M=T���M��a���1��mG81r�C��n@���A�9$]c�b0���tԉ.����E�1h���I`�/¸������>����m̮n�4��>��-���	��?���bޖ�o��'�|D�|�*������x_�1F�I�1&�\�.5�m�1�_hĎ�V1���y�+�(0��Z]�	#���TO�4��Z�{�b���N��=�(ΚcJ*�\Zp��\)ޓ���{m��Kt0���l�>�U���:���ѿ��C��4x��[++R�K��X*Wft����&�=�U>�m�|ѣ}`��W��DTl�z��9�O��{���-�<��ɿ?�|���_�J���?�_����I'k����'��Z,d�r�Վñ�m+�n����\�N�ݻ��pȓ��R�{��䀺��0�b��~N�#��X~�2����>�5i|�Ӯ_m�|���`�T�6N�{�)p�0���n�`r�?i��������c��{0�+�S�q�rܸ=�Ů�t�;ء�{�ko���`j�X��	�C�߾`3����bd٨��]{a��+c-�����k�bS��[�ɗW���md�U��iXz���gRB�o��I+4���Ob��������"?P�`���|����w~P����|�o/|�K���M!#���}[E"g$�� )�c̏�"�f$ �@e����$W�15ҝ?����ً��-�&w[𴋻&*�8�W@���Tv>�1EM��q�UW��ڝ9!����7�ԏ6W^}U��v�
+��@q���[<9��8�VɃ����Jb�9"���i�����FMO�\���?|t;�ׇ-<S&Vق�om�k!�̝�6(`�+:Lƿ%���e������~��(�k���9V,�W��Hiju��A_��UDr5/���e*B���4��Zq?��{"���t�q<]+�1Y��~T���'��X'��mP�y1�B�䆈-�_����i��ˈ4�X4�̯�a�2ӏ><"�+sr~�3��}�[�:c;h�j�8Tf�K�&���W��:����N���Jt�N��k/p�����$@y����n<hw;쯀ˊrQiF���'
+T��z?���ۍI�4+��#�ڼ�RDȣxb�OC��G��`��'X��a9/8�6ǵ5]�:6�s'td&}�a���`�q~��6ۡs`��w<{���;:�o�[�?͢�`Ę���綤�s��X�G�G��n�����O���s���H�n.P�K;������@s���}��I�>��s<�(=����������恍�L��z��Z��B�_�N���Y�Н/ӍIx�lL@m���Ձ�}x̿���U{��^����ի!�k�c�x�3��M�#�˦+�����.�2�����#l����ӘV.w�q%h��W��	<^,�s�}ۯ��o�{��=��4�Ց��
+�����^���x�u��$����tڍ�/DL�5�"�91������{1�t�� ���\��u�;����cr	Wc�0�u.�KK�]o�ľ7����Z����llY{�N."��������%�\ G/����-{`2��sNa��������m����G�(S�������OK��{��O�v�����$��HOx}�yI�q��Rh����Z�i�g�sbq����'�5�+�_s��/�j7��7��pM/lx�5�xR�ѷ�e��+�b$k�5�n����u�+Z�����?8Q�#Y��B,^ P��{a����.���88��g�>�+�	�)�r~�����O�-$�r6Q�>&�254�/B��������5�֬c�Y>�(	���چ�+��4K�N����N1��䏳mH&�,ޣ,K>L<����6U|�*v�c":a+��<�0u�H�K+zpR�}�q0@�a��V
+ݵ���u�8�k�*&u�}�Ef�v��O�B��_���BW][S��x��(�[�G���:��?w�{m?�o�u�]�0��$8g��Ę�}��.vXB�ݠeeĜ���q�+����2ٙ��&�E�Lg��Y���ɓJ?���P���ذ�����][���e�9iĄ��Z˽:��+֓}�;z�FaG�~{�����U��c<���;�u��nѫ�i��e+|��o~��]��}��Fz"��2�G�)p٣~��~>��.����ԍ���c�����x����x�/���go?��n�?�yj_��B��[�l��V"̴��|�Ɓ~jt� �)�ԕ�a�Gs'+9Y��װL����6�k��8	�	���?��R	�D��	�����?�}�����|m�p]Z9��z�e�kr�����I���rz��kڎ��z��F���^}F���,<�,؋�Hm��\O�&k��b
+�{P3���@05��m.~�!9@�V�v��w-;E���������������jUs"c؛�~�?�'���C�� b�?�!⤑�">��� ���D�ck��������t��y�?z�,`��!��y1�Llchp��~�7�#�H:�7'8];ծrM�@���"5�b��_�~^4~������n�N�"�xd:�:��Q둇c������_���?�y�a�[+)<�;����
+t7)�+�O�!Jm���31�;����	��k���i���e�����&��^��d�!F����#��7޸���^>H����G���ԧ�:�.:~������^���M�+�+]�pS[>4�xb��;_ɧ��D��+8�|T(k���L;��5}4*�me�H������J�ku��FP�G̩9�k��M��p����j�t (
+u��o�a���᪣ӵ�8a�Ԧ.x+O��o]����~�m|��Fy�%|�qM>��@nѿ�;"�˷���K�^�?��x��N���Z��H�6���|e����<������vi>;�W�p��1~|5�����M��e߰�-bj!�Rn!�Y>]�!t2��y�Zl��щ�*U���1�BC�[0y�P@�� +���������f0��As��}�Wl���H_�8K�҅���Ѓ�4�[,^�My����vI.^���ʺ)o|5�pW>x�C<4�wꨬ\��@�+v��R�]yͯq'%�k>`����n�D_>,��;wR+���Hd,�[�Ӷ�p8�M���=�9������a�o���~���0�w��NP���lW_{mnc��+a4(��:b>���s=��I2�Ǳ�"?yMg�>�&2r�%G���ө�\��/�Z-(���|
+ؽ���pf̝_r"�x���?�����6���!��F&���_��m�߾�������&X�v�3�Ù��~�s�۞w{>#з�*:�XF�����Ux�R�DerH[r!�9��g���,Nm���X��+�p]��T7!��|I�\4�\�5_˜q��<�4nx��@�(���iY�B�f�����Ӈ�ۯ}��ѩ��k��ʈ��v3Wv�گ,y����Ѝ�$7�y���?�i>7oL7u�=�Ǿ'�~�/+�u#����m�P�\L*�ȵR����԰�hЙ'mj�u�2O�0���Wj;]�Se�j�Yp>jL�v�+�՗����i]�[�4�s	t�W��>j����_���i>mw+�@|��.��i���T���o���#�{�ڞE��e��� ���ƛo=���)��4'����x����`@�Ҫ�4<�|n���?o��O"e�"��
+��޺��T���q7�֓}��Lg�^T�cU�ݫ�'��\T�8�G����6�]>�Sq�L/>�����I_::��3��+<h6��׵1F�Q�'�R���ښ��}8d�3��e^���!���4w���D��G��+aj��ԧ
+H_ct=ɷ4�V��!H�3���?8bj��u����9I�\2�5'R����f,"�`��v��#>΂rYc`��uc�<4�x}�9`@-��v?+�>���貉jnё^k�#�<���|�R4���G=Z|�r��ۯ��O�+$|�,���N�p5/8�<�K'�Z�yu�:��TH��ݾ�{�F�v� ���{[`)Kl}���X^s1�����tq@�UK��ä�������q���T�7����[+6����A(�Y*�1nN�Aoh��I���N�`N�MW�&��=�jhV��G.��D�v:<0�Q��v^������}�)p�0�,��7w+��������5�Ӯ�8�g�Xl1g��C0����XD��D�� +�0ե�	25n�t����]�
+z�e.A+�T������O^�Ћ��1ǠAS�4f��Ǉ���7���-+�r�Gp�C��t�']9l��#9�je�[��YgU�+O+�Čr�ӝ�+���9M�"3�ƻ�0�ࡌRh�ٚ�,&�
+WC�d���o�aU#D\K��_����Y(bu�c��|�������?Lj����ض���F����O}�`\��Kz-Q�4�����+���[�
+ U7��w��'OX���}a�W��׼�=c��o�,�ٳ�8[s-�9P{��7h�-�i����j�3@@�M}�ALt�ϷYiN���]�[�����Av#�^r�Ʒ�"��d�/��Z�৳.����!��a.ԄQ�ތ"qi�X��	*<�s�(Ȫ��2�%|�?e�[�Gi�������m���'�N}e�_Bˊ~�"����C���Zs�G���A<ȃx�+�5�Cb欯��X�z!M&����Z��+�c��f=��9�Hs΋(�+��BBU��'���ꢻn.x�������.袠�HH���JB��L�c;�m�s<�lI�d�����u����>9&�����Y�y���gzϱZ�R�+�'���6uG��E��Af�o���b_����m���w.";r�_>��ι`�;���Qϓ�y%��YֶT=�Od���F.-k�$&z:][�EU���3�6e�,tH|T%�;��{�q�.��p��$԰��+l|�/���i�D�9�j+Mp��=î_	�3 ��ߦ��0=���Yl���v\��#��a�=���|�U��%�j�{&�1���`EGF�n��%�/����s�LB�$���L�ASG7�z[b ��Ŗ�C��^;��A��Jb.�Ǡ��*^��k�^�	�h@
+���'�o�ɟ�^��WC��8����RH�������}�o5���=zW+�s:�kk�!�q'3d	��۲Z�"��?��+<O�ٿ����ݗ/-n��i��cSɠIP��wo_Ԡs��'���td�կ{���w��|p��e�-�t�|�������6����W��K���=��G ��'@\��u�@"eB�N��?��2|�k0�M�BY7�`�țB�叁��Wҋ�����W��	�Y#��aZ�W�j���Aj��~S�"�r�vm��g����b�F�61��3v��tH?O�8�"���W��޶Mv�)]O���-�Hw���R��Μ�F6+f�L���6�'��S�įĹ�G!��Z��KAW4Z�!L��K+�0��$�%b�f<��	��b��s�!۩8�d^J����^�l�&i�m�F�_T���v0���@+(����c5��?B�^���T�g�+�������L�b���:O���S9++��>�+Vg��Oq�vgKr����;��i�h���f$f|F�_�%�/������o������k�cl�x����`������>= x�Y�d�g���Ǘ駂1�RO�o��^�r�������m����X��b��4k�\�Hi�0:Fj=�f�3r�v�'�Љ���׃	��"k�{��:%���ק��>@T�'��F6)9�ī�9LO�
+@�5xjDx�ݺe�s�_�;Bd�?���=Ƿ��Q-�:���Jց���l�~��`��*��:1��J��� @�Z��#dh\��\��~�ʄ��'��+�����#0ܢY?�ێ�\��}�ةz�x�g	�T6||d=��#�M(�t<�丰J|�w�mh�Q�֋���/�Y�RN�0�^yYZeA���6Ra���<N2�I��Y^�+^I��j("�#R k�H��p�E�X3$[�4���}��`�uP��0�`�ї���|�?l30��/y��G�#Gx~�T8Ql���h����+%}�R������ΕM��m�-��.�I.]ư�?tv]�g����7Ӯ={‵c,8�-�8�!x�mߞ����� ߭" ����/ټ~ڡ� ��������Zy��Y׷��ْc7�0E]) 6��y�mR���8���}0A�&��Z�ƀ}n��QZ�+Q�0�I��vD,?��ʏe1ɇV�l�`��e��c�Z���9W�dA�t=��/ғ���J�N[wl��愙hؤt��٭��G��J�j�gO�b�`nS�/:Bˮ7H�4sM����+��ء�"B�*E����3SMb��mT��%6�/��((���Ùm;vN?������qǬm�$��lc��I�9�+߸I��SI�v�v+���^+�oĕ
+���;ԙ��E/1�O��l(rǆ^���DA��j�hK��)�ne�FP�M��-��l�uC�!R�y�)+>x�%b��a���S�X��`"�℀Y<�����ߦ�������R�%r�m·�Q)(ܼ��+Z�bp+��J���0�-���A���oq��+�5�ªa�f�\�؁����Z���zכ�2��/�-װ�2�I��+�)G�%-�����2�F�U->��q�������1m�B�(Pfv�����0F!�* �WJ�gZ����%8kZ��dX�0�k��,���+�5�m���Eu>��H��ƿ�4��7�7W���@�D1�">��>\r��nI,�D�+�de�}_���3ghE��c�����G?�48f�W<�<�(FG���BG0���}�����Gf�L=`ӡ��7fu�,<_㓂�Z��2���!W�mJ�:�_����}̀"�H{�U�%ne�2ˠ����3�*Z͓��!\���,��a������о�����<�@q�ܓ��6o��W��GX�i�z�����cj�=n(�y��\2�II��Һz�z���?6�+I2���u�	]DU�����[��U(�Y�{KJ���y�O��=�u�y]� )�_С`\4;n^��������N_�Y_F��MM��¤K6�?m�Ci(�jD&r&��Ad�[���!�V���T�yY�;�j�`n�L�aB ~+	G6+>��+fAT�/ݞE�.�땝�8�h�e�y�Ah\��F��+�
+�I�<�mv��=�� a+��`�b/�K�_v�*��Ä�%�e�s�E�t�@@��6ʝ�U�4.�l�s�����e��&>P�٥�Vh[��b�]/�Յ�:bmr�g�����=��n��V���*���>�Bt�E�SJgs
+�� �����I��t���_��CǏ?@�u�G�+v��S6������謴0���h��YƄ�q1�cƶ삕�\E_\�]�҃�c�=�l�e��G��"�?����Ut�ө�mC�.��'�����d"�R�蜯�3���v+������M��f��}�8��2�4�aZ�:������V���G+:?.
+Py����cGO�u+MǑ�~�`4�˙�I�p��s<غy㴃W���<���󦧏�������	�p��a���J��G����\�A�vd�� ��B���}&ڪ��C���K���m�|SRc�x�(�c΍?��3z{�G�����Οxǔ���S�F�?o�~���g�OG\������nrqe���ϕ��j�u�0Q�3PO�x���E���m���0)SL�Υ:����Vl��R����/QГ}ګ届K1L3d;���,9��do�V��N�8��?���؛�)���%�e������ǒd|�:L�9��}$�r�q/���L3�8
+h��UoE��N��^��uۈ����!�6�E�:�������Za�к��VU8�un�y����?��~ze[��x�۷��(9p�v�M춄5��hY�}Ɯ���@
+�
+z{o�"�����v�F���m{��XC��2�eǳܿ��U�?[h�������D&�q$�5��zq����FOcmL��D��O��m&T�S��-c�S6��9�;�;���΍��v(ݨsE�-ê�hc�g�Rn�i8�Wac�����`�]猪�tZ�ء%#2��;�uP.;�Q�%�9P�8��"\g+��C1$r����;bՁ��q���K_r��Ϣ�3t����%���_�����u�}R��C��'��]�ї����AR-���f�Rr�>H����C:�q�:��
+]�A�F�Z.�E�>��ȋ����E�x
+G�b�}���p	n��Ƅa�('��M�z�]J]��/��Jv~��hk�Jip�[��jn�+Ѝ�"} �d�g��������Ж��B��ֆm��%�V�8�U0�(���G܊A��\��	9$p�do�J�E�&�e�)��1D7Y���p�ݦJ�Bv¶�nܴQ�����=�m�.߼aک˚�_�5(��u׃�۲1��	�c�a?F&����%98,�ZJ+Bo�i0��6m�d!��Ǆ^1��/���B��q鏘�ul˰y�uI�g�����5��t��r])٦<r��8�M��'r^gۮa	�1��%~pA�z2F����2iY�,zǓm�pH;Xh�a�p��v���+�2n7>B�3R^�Y�?#z@���90ea{�M���w��.��Ӯ�lPߧ�1Ltqg�pl��ô`�Q�r�#���[M~����Qqt��r���cU�2Àe���M1=V�r���[�vh!k��}��?d�*���4o6?,�:x�д__���}U�ҋ/�֯��m�J`ݴQ�tvC��< y�U2����l�3��YOL��ɛ�ꏢ �R�ć�}��v	�+��IЭۦk��^��>4=��c�6��"��:�"6��Wo�IgsONW\z�� ��n��
+��`���l@�aO�S��iL{-X�US�/��$����6���0����(��E��/��SciټE{�6*s؋M�'Z��� ��$���|���7��m�X��9.��O��7�y����u�}�D�J�^�����2�����X\5E����P.��/�m�>�����O�?�~������������R\@S��>���C�{���;�ݻvL���[k�J�v��ο�����6���wc!W+�G�҅���u�f�/�Uo���K_6�ؽ{z��&�l�T��4\h������������?]z�ų?|oХܭʉ+ .�9��T�!�kڗ/�5�V���ر�1`϶+�r��d�|i£�+�9`�D9[�H_���qi�����k����ַ�
+�^A�典�{�ĴO�:~���ګ_��h̲0?mb`����4ۢ����ϕ����	��]-��v}Y�W�×�G��%%�M�B!�S+ �K���+_�C����}�Β=�n{�)t��iZՈ��Y�q�vǏ]6�_�5��L���7��~ܗV����7��=2����秿��ǧ�(�Gc�9:̊G�)R��N�?���z�p���k^�7�1P��Z2��YDҧ8C�,\����ڿDе��`��H�'ӹ��}������K��VO��|��鄯`�O��i�G����7�9=���%_8mܸ�]*.=�	����:m�],��U�=����Ш��Hh-��%-�����J������)2��V�}��=�َ��G�ϢTH�Up	��j7�|t���`%�G�������-�M;��׾NWpx+d�.��)ȥV��x�-{����&}�r����X�^a��m�Gu�98�s1��&��?��1�?ن���+���Э���!+۰�V�7+�ic��R��`�%[�kY�*�0��G<�Fy�/�+�]���%&k�\1Nڶ`�1��Ӱs5��f�;���G?��_���k+m�!l�f�S�!���~fگ˷�y���-��K�^t2_n\��9��1!j��V�5�P�ƈ�:�����K}G�qZZ����`WzHr���̡��'��ـvZ�E��/3�	�tk���g����$��
+�bޢ�2��v�q)ך`��$SQ����glןs�X"-��mV�R�iK�ʓ�����!ly�x��!��n�.+֊��R��zw0[X�<_`�s���pT����-?2��t�C}q=��U�:��-cy�dĂ�<��?D&\n7iR喔(L�+�����j�2-��e�7^�u�,�]�����]:�ԋ��>�A=[��cU<@J��;��jAT��p����	�F���(�1<T�PvpTv�7g�m�d�Y��2�/��l��J����x�9����Z�s2sX��֐߷o�'t��sb����ׂ�U��ˋ���+��x7zA���U�i��A
+�w��"����@�i�N��g�hS���bCc����l�NkM�n�g���W5�IQ���M1��Wn����|V����1��){5�ǂ�k���Sx8�O���+_�˥��>�\��{9��b������������V>K�0�&~T��<A	z�"���\gH6b;�O��K� �W�|����/��Հcz�e!�X	������嗿~#I���w�r���7g���+O!0U����"]&����<Y�����T=��eW� ��{��{�NG�>H����U�"}�CÅ�\��o�F�N�HgV�;�[U�ܵ_�?�F���YxE��o|��u;����xőJ">E���b�t�et�m�k�M���e=����k9|T��{}�Kk�^�#c?T��۱���q`���w쟮{�˧-��}�%6ۉ��(�-o�L �6I;�/�*d(BG���6��|�Ŵm`Ʀl�b��b��"+�Hs݊��g��:����}������1��!ʍ��Gl:G:3�&��u�J���.R�D$	�dV[Q?��"$��E3Px�9��R���q��>-![�֩>|,�M����W�A�#�c�����\�E�����)�=����Ӗ͛��tp��N��ت	f�/?������J��%�Ρgo}N��f�����6�@ǉ�(X���`�6��d�X
+��-S &�M��Do���䀩mzF�Ư�O�g|�SdT�"�eW�ķm�c��O��0M�ֶR�n��� YL(�>D��'%de�8�Ưh8�~�_��&�!�R:3^���-ö���c�'�;�w	�5��_�_���Y�����R��Lۆ�]7xCĩ��R�+�p��P��~���V8m���l�FDo�e�R��?�~���=�K�/`�u�#����'��w�6����"nZl����~f]�L'4¦�O��GyD�@)��0�^�ڂT�Dc�z�ꞟ��I��
+�3��P�;HAp��G���En�ҝ�M��/s��D���`
+��ĥ?��m3qyB+܄ae{��f��� �:ڱ)��Xw\�3�����������r"�6�Lj�e��D�^��Co�Q������=�����<��Gq��[L&,e�u=�׿aڠ7��8���E1�-�	�9H�F&}MN
+��o=:o}��<���@s1�ۊ,+m0�	�ݔ�*3�%|�*���:O|��^�K�W�g�_�����ZW�r-/�e�Nx�X�X��+���}�.����?�#�5�	NI;6�q�y�~v���S�5Q��֝�`{��
+j?�S��f�Ҝ8�,Գo}`���^��d�:@[N���"��ݳBB���Lڷl�#�Wx.d��xܽ���9 1)(b/NE89�߸qڭ+2efE�'t�V�r0�+=�L���d�I<�L����Q��7n�Y?M|<�UHXY����uٯ}��W���ӹ\ͩ�'���}�w����~�s�Ӈ���S)k�D�����8���Q��/Nwv5a���lZ�b��:ȯU�m8SiۧӉd�c��תi�\�m��u��Z��IlB䂓�ծ
+:u�Ɓ�e��ê������"2W+R�zb���n�'�lH��N�kL��S��]��8�è'A��A!u?Od��+w�~���.��%���R�c�'�җ_�=�7r>}���bقƳ	��ԁӛ����)�@���]��R{l����<� �Ω��/���G��[�g$�+g�ڣ#<���K=ěZ�4�+%؃���+����S?�e�{L
+��q�^�\�r�~�CCWU��Dq�lM�Hހ}\�/�י����9z2��!}m������mi�a1��f+�?����g�5if��r��	��e�Ο�����"&��.��IO:L�R�)��q�Qg ��ٝ�O#����Y�v�E�|��1n�P�w�چ���B{��DX2>�O[z+��k�r�-`1�%�p�-�\�qW��� <�p �.�{��
+�}��ܷ]��ZF�ƙ�$���9݂A����:��}+��}ޮ��i�ٷ�-��q68h�*;��kUW/2��+�>�+J�	�c����s�&S~R�Kr��<R�A�7ڟ:�	x�AO������	�Z�����z?�x��G՗��.��P1�D+����u���|��_�?�)i����r�;����p[�ek�^bu�?,C�<�+<;t+��@'����������ܬ�}��6�����!�{�<�+^ف�3u8����j�"�vgY��tu0:s 8�gg5�[��Nv������M�}5`E"�����q>��ӓO���M�y���|@�3pm������l'����}��W�H|����x�.ggr &���48�7��g�F���%쐓����-�����c�\��f�Ro����e�[��y>p�ȓ���D-$��a-�>��t�#�w�'o�p�q�u�O����}z��u �ߋ���P�CÖX@��$��O�'u��a����~oz��?2}K_�;������&�:��X?������h�����+Xp �4ma�9`������h�Р��w}�u��Jp��jT9OY�̂�}+rv+�C���׾�ǅ�E�������m��Ұ�,`p�m~(T����-٦�h箷���ڈc!%������=h��#^�^�&�Ĵ�瀞#ܶI8}$����?s����O�Uр�ݒ7��]��%ݺ�.���~˟{�UWmy�k^�4
+���	lP��߬��)���ٷ)�qκ!8r�m�
+yK��6Ef�o�=�b�X��[|Şc)Yt���e9�Qw��œ|��c�>2=����}8��^@��y���կ�~ڨ���`t���{&{^�ܡ���р��c&�6ɗ�xB�ǀ�]���7�������2��Y+ՔΌ��o�K�s�Y��+�\�M��y�������p\�c��x��1}p�s����W�4h�K_�{���^1��w"�9�g51`��H��PG]�81�1.���}�L��S)v	��8ǿ�;;v��O�L�<=��vT>�+�0��|[D�E��m^��{ǎ醯�O�[N+��ƁZ���2}�i���ꇉ����:�sy��G��������ҪDV@Ӥ���ʗ����ɸ�pn7�ȟ┓nE��h闊��[����߯�����\S�#�1px�W���5z��aP�+�E�@��������N2)�^��e������}f;X��'q%N��E�sο�TYS��e��E�B� ��@���A?�&c]�ʫ���3ߡx"��]7�<ٟCپ�؋����6q�N��n����goC�7ٻ�E*a��)D��N�����A8�3������˧�]���wT�d��k�� p�m�w����é�E����q�G�<JW?��)?�&_�c۶b3&t�t��� A?�Ļ��o����y~��o�c>{5�|��q|������n^uw��\�-)��/�����+H�Rؼys1y��Y�x{��ko�a��	|AL�(�y8��G��8�
+X�����2���n�����$�ʐd�]�a%��/����W;?s%?�3��wg�N��{0��^�&M����/�5\}2x9���+M>Ea顫,�$���y+�t����0SY��2�c3̯j���v�+ij_�S�!��d��@�T<��`��b��ك�O7m��>b��Q�Y6Z8�Ϟ3�x�@)]yQ+0���&U-%��������U]\���u��[�Է�о⤰��ڵO&�%�o߾��?��?��ӂod�O+�A�������9d��I�� D��!�w�J���@&M�a>�XEd�}|��_�{���I# u����M��V��|4���0M#�~x7=�u?��s��4��?'f{�i]�d���L��yH��}ȃ�aK
+��!��4Yeh��'?�Lq)�A�$wޚ5��{l��+ht�x,ߩ�Ӈ�W,�[0��`�$�m!�dH89���{���zOGC��h�<��%Mb	/��2�Mr��A3ēD�n�M��#S�ɗ�ү��^峏�޲v��,�~$�@6�b��I_lk��󨲂�VqUm�^R�&qm�ŝ��VZ)kI;n�Dm+'v+��g��&�KP���
+.7Z��<��9�����7@���,'�~�Iw�7+�;�m�������yU�"OeSE3���B݈Vy��OI�p���s�l���|lgϞ�K��hե4��A4]@��`|	2-��G?�I��ۅ��7�7��^�x��W�uϿ�'#�2�!D-ɦd�[�LD��*!�'��X�����c3�7U"��cNȠz+ߩ��ɃM���m����W4�쬿.�*ۮ~����+0h��n=��+�oܸ��.����?G��������ۉ���*���Um������?��Ԁ�L��H�Ԁ�g��=�`���|@�,v,1���Ò9�4c�(F:�	��꘮/�/�R*�k����P�Fxe?���V{|͜=����T����$w�ϲ�B�عN�%H	�}.o��gb�_�Dʓl���oVᄅ�[S$�M_���_H�����̼v����1��ƽ[7U��mW>/���/��l㋍�
+�P���6��S[(�j�	/����FC;�g��x�b7���`;��\�3N�H@9^�p&�#��o�X��f�_zYq�%���1�u�y���W�uH)H�I*�LSa����A�M$G�b��"+y��!����z~��2�7��F��s�3�ʌiӊx��tA�瀵�4ʎ8Ӓh.��8�߆�Om��;���v����)���+���,?��{�D�[��W��]X�}�w_��)�6#^�]U�����1i�ȡ�$Fܘ�C����;���ۛ�O)����[����
+"S��[���O��w=͆+���kD�����[�>v�k��w�L����++��"l������Sq��:�1t�ԙ��8��Dc���P��^"/�Ae9J���o��Zt�nB�)�K:�l!l
+��U��9�kŪS�/�X��E3�"N��u��d�^���7_d��S��$�\��j��ΣzW���򪩼�\,��/,�d�aI0��)7~&�4L��"�a�9�`��'���+xyo�mI ��~��S'����X�K��;z��+&�bH�?h��AyvB����yI��n�c�dld���\>B����{���|�T}XA	i�luaP�h��y�!~ⶸcA�3�\�w�~^Z�7���<�g;��"x�s_���J�@�E3�`Ǧ�+V�,���늩�*R*�����m�oYaB��	�GG6�Sۨ�d�]nI�Wg����EG�&tܤ)��?g��c��1�``4���n����c��A.�y�/�4�]� ����`-����.!g����-[ƾ���~G(���7�E�(�*�9U��/�G\�Q���t'y���1@�tY�IX�NM�z.S1���P8��#x.������u�vIͅ�A�P�o����w�e.'� ����hן��)��]�{(�ɩf���m�[��m�k���V,2��y�93��p�iR)P�3!���>_�L�ʷ��i ���E��S��%撊<fc&�HcL��K+Px��f�Uj����L![�D�#|FnNu�?B杋��lΜ9��1Gx�v���x�'H�����W#u��م��)V���*W%�Cw	��>@�#�_��z���6ј���=w��a��4|G�`�B4X�ols�����V��d�ܚ&�1����GΟ�s���_y������[�����������}�-����t�MY�*
+y,/5
+��ҟ�MELvY��)��)e��l-�a��B�ٴk%Ȱ�6y(��o�q��>Q��ul�Ҏ�O���a��pP$dP$�`u��"�%�J�%����}Y���?�'}|��o�<�L�6?���,=��k�Ɔ�]hW��؈��s־?wpzl
+�+�10g��u��y����ViM�z��i�s����Gq�]XXds�3�4N@����%�ȅ_7�Eش!�1"yb�P�k�����i��Fa��Փ�:�ˢ�&\��!�*C�|?���}+�'�mr�G�T����ON���+=ɮ��RI�_���V���}&��/x��A�Xi��4�#�O���S�1���1�j�J���k�uk�M\��ROu��)����"�[�i�`t22�����r��|����ʻU<�]�lYq��p~�`�{���.n
+���I���y��>R�.�ETL�r�j^.�^��(��>�\�)�m�/��E��'�Y�s�*��]��+�,.����w�=�bqc�"<�E|��E��2�8��/��D��󳾫N?��ѥW]U,[q�����Z]�\�JPy���tMyi�7��W�t^�J����wKݮX��=��_q����5������,��o���/�فz�Mg��1�pE#���9�P��iB] �g��'N�6�|\�����2�1`E��Z؏���b���g�NG
+�N4��6�:?�s�L�k�m�W/ߚߤ3���1�xn�?�|~�}7�ރ3��xM��ɷ���v72�R��?�'~�pq�?�	?�ᄪ�UW^Q��n��+���F��<����n��x��|~z��D0y��'���zg�r�SB� ����5r����
+����M��ׯ^��-Z��5�oi^��=�O����y��Ǜ��A{��K/�8m��?�~� nh�b�����]3:�Fd��&�H�+!�V�T;X��+�0*(i-̉_F1_8!͆��VM��&箪Vjd���Pw�~μ�'ȼ��w�}7q��}�.��vYC'��C�"���yO���inT�+���ߤ#�d[�'KZ�E�b��Q^��p�q\	�!�O�{��W�c��l�O!�e�p_����>�+������o�}�z��m�.nvn/��s�{q��>�xio�{4��Y{�!�i��L>%��T3i�b¤���댙����Yv�*߅1_��G��1S���5���Y0�ek�m
+���h.�~�~R��!Xc�F�O��� Y��F�eE��|͖��0�?vL��o�L�;��Y���Z�DV�kP��*-q҆LhӛO�}tL�!5�ɑt���I��w�}��/���Kw�瀫���	[� �,#��󦑥���������z�es���z	��C���s��b p�y�n�"��]�c1�N�+D��R����U~)�卄��{�E�+���E8��*H��
+����yf�C�C0eՀ�#>WH��I{���3};�4��w��C6�0+Y�INּ��)vS�|�7�M���R�nS��(���I�'�m���vI���)RK�_6lje��@����JÔG�R��52�����G��<�=��=�������o���{�������o���	�Ւ@�V��9���%��tt�pA�m��W��ܦM��X�Q�vKq�M�ͣm 1j��r���L�L�T��%��|fP~b0~R��f6Pw�4!�1'��F�e�zZ>��J�����K0�*�3+��.ߘQ� ��?A�3y�]�F�cQ��.�U�?38��dUr����ܞb26+�'�F~����&M�
+!A��Z���Gg���>�7x����s�|i?!��$hx�=�%D���[��ɵ�Pg�[�Y��>BD�/a�ŲM�#-�eH�|BD�I�p�DVɏ�R�|˹�h�-\c ���p�?�Tq�e�p��u��P�+<��,t/?ğ�����O	,��o~��������FqE�����jA6r�$�A�P�WyI#>�ݮ�3��^�
+鶁��u�$��)��{I��O�`떜�E68����K�,!U����3�%4�L��ŞJ����I7��� �����1?'��������;߸�j��Ħ��g�����������}�M�澬=r����_�/�������}���}����jU��_��b:.ῴ�OR�OV�ɜ��_Z��e|g��%�e�F��{['z��������N��F�3њ���u]t���M=�|~盃���	�3+0���M�:,;�*��ѐ�n0�!n����)�I��V�I���I���ouEiM#��+O=�Xv��V�𔗁0��?�]�Of�E7|~�0\�6>�3�C��O>�L�Ӈ	UU�l�'�rjq��ӌ��4�6����K:?�:ـQl��ځ:�Wǌ��H��X�DSzH���������(Mp��>��%H0�DHM<*�����*v<Xd>A�-^�/�+�%��w05�\-������G}A������|���;x�����b�N��o}&UL>��-.��m��%K�.7��ׇ��6�z�p����S��?�����s�sr~���Q�K��k������u����P�����+!�M�m���#�&Ǎ�ɔ-ǋ�z����>���hq��K/�w񫡭A}��a'�v��]��z�o�h��;o�&�����p�֒)�������y��_�����/�9�͗]��F����������3�y�����dO�b�"�G�G����'?�ɿ��gy��D-�Z���&�=Q�+���H�[�@kz��A�yP!Ո&���ݲ$��CcQ4�l�J�>�n��)��8���whŘ-�Q�p�I_�'� q�-+A�+!�*��~��O�,Z��xo��лi�Q��P���^+��ӵK�,6���[AV�� q�u(՟�?����I���磏w�{Ѳα��1�0a����|�}��h�l���P��7�j ���h�	#��-����_��U*�B�W��nx�O}G�)�Z��昋1�����?����C�x�_��{-��Z�	X3���6��p�+\��w�nD�Y^ef��l�^t����ɲ�@�@�*���
+�uj�*�vX
+Qْ�I&p[���f���)RR�^�"l
+(g!��,q!d.�������M��ϯ+��&���Y~|�u�⅋����7�)���{�s+~��'�SO9��>u*���8��.vnT�	�x������M_��ˌR�������U���?X}Y�T��O����˿RL�>ݫh���I���6��-A���q]I�#G�u����o��ӧܹS0��qp7�/�D��>$�Á���g��=���0�nG�Bߴ�3OQF��F��݆�A8a�Հ=����������X�I�:P�K��);P!?��� S�H<���`�	�&�@!��ĳ�M^2�,�c�2S6�I��DZ�����) >ew�wԟ���2mZ�~�s���	�l����>�>�M+�q@k���Ig��O\���[�n�{��ޫ���u.S`SP��{����+�, ˬ�&7Bf�&FAc�Ae	-�`"M�T˜��(&�"�M~d'� h�N��(hyPYBDK&�H'����/,���]l|�uS//�yni�������a�|ٲb��Y����́��ﳫ�bHD��-� �<�5g�������M�Kz�y����p���=�O�>S��8���0���g��*1���U�ђ	&�фːè��EA�*�$�-!^)���(hyPYBDK&�Hí�K����|�:7��ƀ�\#t9�9<�(�����g^x������Q�1Ǚ�q��Vׇ�uo����6J�C��{�[�2q�kR߼é�5u���l3_��Y�-Ә7+q$"��)���Y@�k�j����c�r/_O�/��rZK�d��L��$��H4}�&y1I�t����[䛒� �à�Kqs�k�]|Wx�lm� +F7�����G�żY3��-�z3�w}��u��AKHa%�Sd|�O�#~���lDXZ��?-n���q����`�.;���kގ4�=� �Q�	I6���%XS���s_g�&����IW2"&��� �Mq��*N�y�o����\�4��	:��1������hz���;]�g�#��0\7+���[����A�ŇNU]I�~�vbR� C��i7K{	w��t��� ���X���u{T�Sn�h�ǁ�w�x��(i�a8��ڗ���y��s�T��!��Z�	݇�Y1�?	�=�8y�s����Sӥy>�B/��rI�ks��e>�z�����τbb���Z����?�i�,���ic��~�=M��&\:�b֜�ŵ����)S�}����5�����C��i#m���O��q��p���}q�z���G�G�E�Y�ng���!%qL�06+�N̜8־J8W��>������^cc��x�G�B̏�^��vd�����̘5g�(��n�F�4�����_�sĕ?��O���~?�)�E=�M�9m����?�я�>���x	n +�v�	j�ۺm[��C�cB;���q�����wn�B!�3��˟�8i�y�����_%l
+[�6����Q��[n�'���~��J��MP��\���ޏ���#P���ʾ��e\F%���}܍����7î�{�8�ǯ}�k�x�7�27!v��_�:�h��!҆�<ʇ��f��@Ȩ���1�U}|]��"\����w/^ܸ	h]������g�N-^���f?�t^@)@��{������5�V��uk�,��j����k���?�s���{߸�؎��T8U�h��.0���-�=���/*-\���2��`��7l(~|�=œxC�=qP�r$�Y�w�gƬ��;�{_1}����k�jL�+V��^��N�ۯ�?��t����%d���S�c���8�`9�IA%*au��q��w�v�)��Ն�s�T��Tw_s�5����
+7+']1n��"�� H�/��++R������ua5Yi3C��r����Q�9ɣ���9`婧p�ߞ���0]Ð {���7�F���
+����z�x ���WL�>7NrY�B�)����(��G-��m8뿳xc�F�Kj�RVBj�&���/Y����_~�����������k�O��ҳp�_W�Hgd�x�|+�c��~��~�3�4|ӧ~���+�ӈ҂��1��{�g6��]���姀Rf+Mʱs��)L�-���1�<h�lМ(e2�O����OΤ�f�v@/�z�"9�0�q^ח�'3]��"�Z\[�E$=Ⴙ|�/�j\� �e��j
+�E3^;��p�C���� ~@�_(p�rUׁb��W��k9�o��oa�N3����2���/_W�Xy�����D
+*&�kw)��0���C}Œ�>�kS��i�{�ͷ�~ۅG�>�������N���7Az>?�O������"#q�z)h��5/	��5��˗/�y�g^T
+J�;����v��Ve����}�i�b['��֔/���*�C	#����$g�����A M��u��	S0�D����t˗X�?�f��0��L�-�Yg�p)~�&ް��0�F<��֜]\��w3g��v��������W�e���Yx_�����@t:Q��sD3�|Ѿ��o�ӿ�˿܇�+�\��@���j�$M��	�:FN��)�uS���'��Ӽ]�<�f�;˖-{˱p�<[������ t-M
+�%��)t�0ȟ��2r���TE� ��zg
+�\_��.��V>�2����o��3y������s�]�ߊw[u�ޗ�W"odkm1u�uW}fUQ̞;���k��K�Z?&9o��w�It	+�,�������#�_�������y��T��wm��b|�W���3=�++�;uP�R�<\	؊�� R��w.�|>i�
+A�SA`(�I�M�΂�O:�*�"V�V�'_eO�{>�#�_B�����:�s[*}��wn��c��.*�8�<;+�9{�5�n<=����D%��=�o\c���U.]V�����%o��8����2!~���[�����?���נ����O�/j.$��Nm�'y"����|�����~�韁�����*?.��|��':b#,ذauʫc}DA]	�v ^ ��o��oށ�����c'd:�+���GJ��n���_g]o㪾U/8��`�}�c�/�����!t�g�7+�iཬj��4i��O�{_~������_t�E��'���������@7����4��执�e��e+}.�/�;N���L��W�ڍ)�"�e�i�W�#�x��r*#2�W��=�k�*��^���9�o��������?��?|��o|+�"Ph�YdǱ)b9R����O��l�'��ԫ�������_Bw��"2S74�~-H	�	#�҃�Q��g��3�ſ�� M�i�&����?�h^����v�+���P8a�pʯ�(0S�%K�����|�i�.�[0[�Y�f?�����K��/��t�0K���ş���>t����1���(ƛ�ف�Mx�Ǿ�;��;7C��u�_ӂiq����GKڨ�zF{���z�4a��(Ũ��7y	��t�M��dɒKQ���'�O��@�$�9�;gь�eEU�\XSZ�6�hD�s.(Ԅ��d!C��F���<���Z�n����տ������:�3\�?�g�6l�/_���0_���ǩP�Am+�F��xr<>#��k�&�ezX���=_�*f�`�{�q��"��!�7��O�����di{�A���֚��D$s�[��B�K��W��¼~��{_�s�-��3p��X�Dڸst	'<Ұm۶�����}��7�x��#r��}���o+P��GU��;IN��)��!}��A�A��K�Qq���~;��O���}����u�|��i�M��9� �pT�����Z#H�^]�+�p�+M���w���W.���KСǩcW"+Ly&0���|������;m@�&qRH��U~F��P�0KRG	�u���.�p�a�"Iqr����0���l!�@�P�Z*�'�k�G�^�S���c{ʿ�|nM����z��~P�J^�g�WL~��1�S����A�~a�ӆ��X#O���������կ~����G�b�E^g�1-��EęfT��h��6+�1�Dk�4<N�ϟ��'ړ�\䵨j�i�Ҹ���� z��Ӱ��D�e�D���������u�Y;W�\�&�j0F�I�@h��A9cf�$��>�h����f�MW4��G\��S�*)�m���)-��?L$'�ze�싥��vBY-����7�_�I>���V��KY�E����k����Px-����y��j�޿_��ӭ��'8~�'K_��?�� �8b����	�v(n+����O>y����]�"r����t\��ňd�&��m+���Y�ׯ��u�]��ߟg�T��=.�M7��P��ň��	{��8����< _*r!'��+����9�1ظ	�x�W��A��GJ�l��c!&~Vx;��bA��ȉ�4�0^���c�i�M��N&�hbp�j�F����n��`���)|�k��|Ѿ���-�s6A��)���)�ᡛ<�/����q�>PҲ��r�+�m�2�3�a�KB^��1��xH����Sz�zI�Ab2�꟩T	"O��O!��2�3�!��??��Cӂ=��#�i��u�]_����훐��t��z-�JG�<���[�ጣz������o�Gz��ν������3�<s�U������2���m�� ��-^p�&C�֔|ɴ�����ĥ�F���l&�i�K<��/\�YekQ7}`d9�%L�p�(�!�#�� �P{����^��w?X�a�P���?����ۋ���rS}��n��_?����<�ϟ�����E_P+����M7}����mЩ��6��k��b!o���������+��7-�
+�6T�đ��h�7.B=��#Iu�a�e!�7.��D[l���'�����>��@�Y�Ḇ$J���=�����?��v��bn`����b�����>$/��W��0r[�Fe��?z�|J;���4��}�ȑ��_�W�&��SRlrG�Gr��8���"+�-ڞU�Q�4p��S$$�	�.zi�� ��?�V�ŶaC*�8��N�"����?u)�Fϱ��E���8`[L��?K��9S���e��{��r���O���ӟ���%$�#R��u҇L�ik1�"]��=4�s� �+v��E��	�E_�=���Q�"a�	渉Qu�8��Z��g&��H5z�)�aP�l 
+v��q��+�2tc�8$]V>1�g2İp�Aa�l���pJ/^6����'N�����&��4F����|G�8����_�L����3��Ư9>��S����f�$�V/�#�e����W���f�{���m۶��E)L��L������Ab�,B�a�"���pb"��`[˓[�xdZi��߿��í�{����Yr+_f�!�Ct�m3���4ٛV���x���r<�j��Ǐ�}�k~��\���vJa�g�6�[�u��10��e�s��`d�k�Ǚ�J��xԧ���رq�����ܦ.��ys�t{0�d�Hb�.�m�#��3䆤%�ژ�:�$(=�I9��5�	�)�7�#FD�Q+��Jyu�Y_�򗯘;w�z4����2𤩇LC��G'��l���3��=�i�0CT��,R@��W̡��0ߋ`+�+q���!�`C=hU�ICbH�)bɺb�5	ՖnGġV����U������4���Y5x�Ǌ��}4�<���`x�kژV~B<��_���|�����r&�T��+q��h��?���;w��o��E]�"�:<xf�?+H���>�81a"�}���7�Ǻ���>�����Y���xL���7�����k�W����c�{��o�������G�"�y�w.��x�_^w�u�G^7��x�!E'p&~b��)'�N	4y`��Q��Oh�
+�	wnc1�ę8eă�:�C��AN߇w���!/�xꕯ|����ޙ�X�+�t��6�m��t�[	��g��W<O�7�@�FZ�'��a]om&��C���?��1�fD����c��G��Ǆ�D�� w������7��>N�[] ��e������[��9��������)Ә4�1�c�XT'#�0:�{�&v�#�\	�}�Z�%�뭐w��������O�Xl�&�4`b�$9i`����Wf��<1����=/�U|y�h|6o`r�<���Ŗ���+kð��P�tf^k;{�A���R�ݗ�S�暡l�R�m�l���?���\��=0��?����+m�#��߾}�6}�����[n����$e��L�3�3�[;��_^U�;�������A���rj�sh���넟G�V�Z:eʔU���'��Moz������v3�v����V��)�=���욌+S{��Kx��5�b�x�	���M���N���*���o�q;~��o>�>�*�oRLR����Zٿ�]]S����О���w�}�S��_����x~Q
+�66�Nޤ���Ӗ���u6��vc�2ƺ��5�v��.:y�N�(�k|�� �8m��I��>���0y�~@���N'Բ	�]��Lk/���Ԟ�}�g�z�K��'tӢ�o�M	:L��J��3��&��]���?�?�C�+�Kw�4p�k�Ԟ��p�/g���??$}�r�1*۟��2{���پȇ}���-o�S^���[��g�1\&p��5�i���-"�UÐ9���rcp$�eD��X��+�	�&�2}�/1.�+��(!~*xY�&ث���0X��.+��Ft�.ȣ|�ot�Fn�ó����}��R��T�O�l}��+�
+���d�����d�o���?��Ơua�t
+�ğ���~��H9�}�{ߙrU�y��m���$"�#	�'ْ�(�=(�;쓟	� �+x�o"��1U�'���+#�����<x�/J�y�����S�}�C:�-oy�es��Y���'}�e�գ��O�@��ݶG�a�	ヲ 849bи�+@�cg@��zL����q	w��f��zO딍w]S�����*�o�[�2�m�;w�|��n���%�?/6�R�N�L�:q��o���i�~���X���F�sʸ�,nw�A���Y^�*����͂+�j��W\q����	y�g|��
+�M��W�}���?��E��B�����O
+�e�
+>*�3��WֶM��.�}����;��aS�IrxXpL��O��v2sI�,�Z�;tY̬�2�2=��8�7o�|��7�|���o9�����T�GB։��IuIk,bO��D�3zۇ9Y�@y��5�4����b;x|�T��Њ뮻�s�9��{{{�n��`'`[�,���־Lo�+�����9$�!I�C�F:Ӊ�v��0��5ȓdA1,�8�\���}�g2lB��1{��,&ac]OO���;��� ���^I蠃L�#�
+�;�<�֟�����m}k_���,?<<|P^��7�p�==��>���8���1�V
+�h��+#��d�d��;m�,Ek;��ii�!�C ������d����~�1�T�@cKW]�z��9��R�*��k�� _ �hɒ%�uZ��Nֿ�>c�:��O��2뿬?�n���u��봾m���Yl}�R��a�2�=��ַ���}$|$��R����@'w�h��ZOZcЩ"�Z��#P�+C�B�<;��yqQK���-���#��+.�t�%�2d�'�q���&����+6����.KXR�:�_�\�ֿ�/[���־Lo۳|;�������zO<�����w�}�%�o���7�퓢߿/ln·ɘ�M�[�嵍���b�7��+���㏿(�x�ᇑ�d����D�$Kyb+O%j+�|��2�cy�M��@ZcK�w��H0�9xNt�~GZcK�/+�.+X�	��B�,��U�Y6l�'O̗�͓�,���@�'�@�#?+T~<��-����\�d�W��n��^N�w��v���/��˒���3�G��CR�؏H9�
+n��%K&W���a���x��6y��?b�HS��#p�"�I��#0"��E�[:�C�b�|�r�+�e4�+�����ϐ�?k.0̜%Wf���N�҇"�)�x�3O2�~� 8$I{P
+p�B'�eP��Jb�/p`��݇��3�����!y��aI�%��wx$v$y$|ʘ�EԔ譌I����*�K���_��y�[��G�G@O@'�qo�#����'-M^cж�-ey�ꁫ�h{K�����b赬*;,�FC$n�S9�{��hr`�+m���C1u�[�[Q=mS�u��Iȣ�w�8)�dtR�F=%��'��2к�	�3�A����i�����a��t�ϓAnc+��Z��u5��)+��i}Oy;�I�%M?���X�I����v����M���ޑ	���h�(טrb�t�qʷ��h�R8O��K
+��)�"_
+�<��r�EX�,>OF]�cM���X�2+M[��*2�h�"�����(��?���be�/��'�_��)u�ڦ*m��;x&\�=IL�+:X>�	{����j��l�k�"%��h�������k��QO�yt���U�a�����M ��I��G �ԱSEfm,�����g�����:ik�V^ƣn��է��� w�xr"p�&���]�W�;�R�NdZ�u�ezm[D����/ҧt���n�����@�tk��Д�x&l���<]�A,�1�Ulh[WI�E6y�<9�T���g��x
+"��I��)Wy<&U��n٘���VI�ݲ�J�݉G�#P�@�ɥn�G�#p�#��1�n���UI䩺��K�r�G�#���vї��x�o<���m�#�x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��B�?��p;OH��+
++��?��?��/}�QOx�P�o<���(�Bq
+��P���~�ݸ����چ�VxH"���@r�I�ݸ�`N��������p��n�(������=�\r��_��W��?O
+ĝq��<QP�P��h�����[�Ƶ��}m|�B@! �r�t@d$��B+! ���@�x�&�B@�s�������㕅^�>��cw�*~�V�}��K�7~���N;�1x��	k׮},�䟈��?���WF�HA�gK�Qz�|�~�܂/�~!2�Χ֯�}�~�|������Ma�[q���q����j��w�q��W]u�M��û�k�qb`W�k��St�%���qiS�����v�իB@��@��0B@! ����5�x���}���A{,�yE�����:j�;���N?���<�ȓ���P�?W�O�wƩ�Y�S�lu�Y�H�i-�ǵ�.�����e_˻���Χ��D��~'~��<s�Ƈz覻��&���w�woO'x"�O�/� ���!�z�ԭ���V�q�^��B`^#P.��5��B`�#0��A�/�%M��q=�W��J>��b�9�y�귾���}���xܺ2������N�L�n!c��ꂶ֯嵏.�ɖ�����eߕomߥ?��:���?���;����?kx�w�����k�Ã��I>o Z�uO�(^)�}u�B�M���B@�y�@������B�@��o@�+��h�Y�m��EO���������=��sO>��O������,��diG��[��
+Ps2⥶�UVy����t��ϰ�����x���}�������D�G�}�[���9�o��߹��o��'?yÇ>���7���	��u" d�j9FS����O�B@�q�[L���jzB@���@�g~�5.eAGO\�������?�3V����/�=�I(���+�?�B��I]]�Eߥ�%?���������+����k�}�~�<�D_�?�:�Z��<�F��/�����k��G?��A�.�)��8)p~���������W^���I>c ���k��W���鐧&��s�X�ͱii:B@!�h���y帋n���yu�W��c[���/�C�N���?��=i͚5Oƕ�ǡ��-��&��
+��Cƞm<\ؔ~��T��8���|';��w���`�[�p���w�L�k����.������~����sx�+
+~>�h��Z����_m_��w����_���w������]���}����u��u������n������k?����+��/i��S��KS�-|�H�B@!0#X�����B`~#��9]�萏�K����g�-[z���S?�S�ظq�3V�X�Խ{�.���`얈͞��E|�s��x]�Ow>�O���������o��G?��k_���=���o�Wʻ�_�b}�=�Q4el��s�*��3�X�͈d��B@m��%�����f0�y[�m����yԹ���G=�QO�S�����P*��+PX��6��Lw�.L�;�鎧��#�������+��+>���]�_߸��3 �xC�}I�q=��r���O��! ��AD �1�B@ ��y\���Q<�B^���]~^�_�[�W|�#yҩ����?�x��ǀ�&��B`���7�{�_���k����}�u���6L�'���,ңP/���J�)��)y5�1[���
+! ���"��i�`B@!��?��q=�GY�k�O�[��9�����O<��k׮}6�뱵����
+o��bj���b�s��~>�9��ܲe�Wo��������_|��ؗq2�?;E:�a4w�J��W�I��z�ѫB@L��/��@� B@�q#P���6z/�e_�qk��?��?=��/~�Oq�?������q�d��h�5n�4�p��,<h���.�'=;�?��O��q���q�@��KC׼��(��q�&��S�@,�0�\! �+! �@�@�Y��t[O^�/i~�����C������Nx���˟ʅ���z_���Z����_���W�Z�w~]����q�}����5������;j<k�j|�q�}����5����u��~_y�����ۿy�-�������˾��/��0�g�t���|�jB@!P!�Њ��B`�#P>��G���t9^�1�׿��K.�I���a~gb�͓�^�8à�W��q���}�_�������Z^ǫ�ky=���������ky_�Z��_��x�~-�ǵ�ھ����~-�k_���ky�֯����W���ھ֯�}�k��-��������j�Z^ۗ��݆�~�_��_���Ͼ
+��I+�(��1]���q�#�6>ҫB@���B@G 
+���=����ǘ���S����w=����Kp����^��b��a˞�\p������Ûl�}�u�w��̵Mw����ץ�%o�S�d���K�K�g�m����.�.yۜ����޽{����C�Х��ۿ}|į�_��}lW���%�4[��H�B@�y�@,R�1��B��?c=�H�,���S�W?�)OY�����}�����+W>�z釺�-��ٺ
+�V's�������Nv~�� ���L�78���~�l<���G��n�z�w���K���7~��k��c�+Qȗ'�m|���>�ꅀ��q-@�*�����3�=�����x!����������_����t�K0^;�|��ȡW��x�7Q�^���dǛ����k���l�'�o���f?������_|�߾�Mo��ʻx2`/�(�oC-_�/��g���_�B`N#�9=IMN!P!P������G:6�'����~�������sџ�����v*Mw����&zů+��7�����cl:�7���L��8Y����o�p��|�k^�O�; �
+���(�㤀z	�R`o�8�ꅀs_�ɩiRB@���?�b=HǸ�k:�x��?߷��}�u��/7n|9���&k��h�
+ӝ�t��a���x��h�{Lw�ѳ�N�IB��~*ZW<Ľ��{���/��w��!��;�"A�%�a�{�4[-wnÏ�z! ���D �srr��B !P��x<=ub����^�[�W_z��:�S�]�j�3�`�ԝ�ֵ`��3̡�?�����^�j�3���=��#_�����y��^�U|U�'¶[]�Ǹ.��1�Ћ�z! ���B`J�s
+)MF�و@��F��k��g�;�s�|������;�\,N����(g! ��lC+��.��I�}�s_�nݺ3��&��M�����$����7~_�b������7~_��I̃�o����T[Ƀ�o�����.��_��m����-[�|���>��W��z�y"��'0S�6�/e5ͱ�B`V"���B`�#P~������=q ���5h�]vٳ�'~��˗/*�}[ۂ5x}}�G?|�g�#`<>'�3��Lw�.l�;�鎧��F`���t�={T�=�P���%ߺu�7񜀿>묳������=��"�t�a���䍢)SB@�*b!<��V�B@��@��F���~�tGz	��(���G?���<�1�[�d�񱈥�d��͞�.ػ�]�����K��K>Q���D�����e�8v��;��œ�����˝8.����@�r&7V3{x��ݍ�<>{��?��-@_<�����!1mȠn��Om�s�.7�n���<S�4U�_�4���L��B9�e��VΟ2���X�S�Y���~m�wܕ_�|X�ݻw����}��?��?�i�x+z�^�3b*�ӑ˘��\Rԍ6���{�� Q$�L���]�q��`�5#F���ON�'	x�`!K1 �<Y����[��J�+����m��c��¾����H�T���O�x}��x]�.��?p�w�����=������w���Cs��ɢ�^Љ��r�B@��@��<c�SbB@���3��&/�mt�_	�5�Gtҫ^���;찗b�ȓ�u]q�4_դ��_m�'�K������Z�����~-��k����_��dǧ^�/���g�v���Q"lG�K����+�t�y?4q�Q�Rߪ	�I��fzPąu�G1�+�9��#�]r�%�;�S^�lٲS�m���w!�e�%��w���ھ��j�}�w�w�'꯶/�ߌ"����߆�ү�{���q]�(�Mq�hq�_�{mL9��
+oM���O��M�v��H��!,�#�|!�A"�&L򔄡S�'���!��밡=X������ʊ>_*��F�S�K�X�lC�m��/0��G��p�g�+p�a5Z��:|"t]��bX�e�%��v���ھ9n|���}��z<������)�cǎ��>|��g����]��|N���ym4yl���s�*����o��B`�!P~6�����{^�_{�	'�+�g��~oX�x�\�����ؔ:傳��忶����'�Z?���:�0�a��x]�k�Z�KμX�?��=����S��o:��)쬘L�$żj^��ȋ�,�&�+Y����bsU��P&���J�[�c�+�D֌�g&�����x��:�ቁh�������Y�u���k�.y�֯����W˻�]�����~��ί֧|Ϟ=?���/���r�-��@�P���s��/朙�&"��,F��Lj��~<�,�y�=~���'�|�-Ztl�dۂq"�v��뻯�.�.y��j���_���M(����w�+�H�+��*s�]��ek+�]+9h���KܤC5T����l~��\�/���� �g_�V��ѣ�~�:�ܹ}�O�Is�g����}�e<w��#�����ay�	�0(\�'��9����2��(��z`L~x,t�[5�F<��N���W	V-�7v(�8'x�D[y���D?_���������D�7��_�|w<���+��;p+��ځg�^i��7= ���
+�i��-+��}H��
+l�y�?�������o�)}� ��E,',-�P(�0k�u��ܒ�����R�ݚ�9��&f?������������=X�2̗<�������Ѧ���Q��Nw>�o��]2*��+����{��m�j+��a�
+NV�V�&3��a�b̙^��R/�J��z��~�2,����YD�\ {dǔ�#�I#6��\�"-�\K<���؜iO6^��Ў��/#��>����;��\�'+! �@�9S�1.{�ö���������e�eŊOc+}���Wdp��C𭀃1�hQ@2f����H��F��H'4��և�4���f>�Qr`'A��j�6+sN�z�y���J&���u��z��v�?��0NH�$�.���4��O��b�0���q�H,����Db_G�v@�1�`� ~����[���	�8s�#ʱ4�Ac1y�-�ώA��W��;���+d
+%��"�D^�6Z�s��FFL��mncB��[y;$��R'��'��D�J6��aK�d�s1;
+\�m�c��|��/�+++��=]�5�k��b��<�Ggt溥�����Y��)+��d �ƎBW�� ����7Γ�T��>�$	X&���6���;;�@�]��l�<v�b�o�/D�1�6���}�(��lƐ��a$�f6�y�$|��5��9cD��m`��L1���c�Y�7���&",l"�7;�1d1�H�|��ɾ��xI)��W��&�`�q�[#��ĈM��0�5�?�$;?~8?������ �2p4n��3��\ٳ�{���LM�+���&��"z�h�����S%�q{('��.�O��iKΜ�/���[!wҋ��=������|�s�*z�_6/��v+�لB�4�a��5�^J�s��c^q\:n���i��E�������=[����J�zq�f��8�<C?M�>�����" ;Vx�+9�@��#s�!�I`hЇ�{�΀h֑'$��B+ښ���f�N�k��ԅ�/}�c�n>"�~�+�T�Y��va�K�����a�ޏ�儠G�����\8��[ݑ�	O��E�ܒ�����b�]��S�a:�<��+�[�k�����ǀ�^[���W���(�T��c���gϞ{�����O��O_����$�Cظ�Gm�˞4uԄ����?���@�ً@��t��4�m�2������U��e˖=����X�ۂ���.�Z^�&]ǯ�}��W^��믶�3�O�+W�9�6�Y����B�z<� �X=�����C�TP���`��+��5���Y��ݺsyp�j�����\��g�k&Ṙ.H�R:VG��{��яiS�����J<���KF�)v�3hsQ���`o�W
+,N�$�	o�q�� iZ!K��{� ��c��+���C�cc?Nȧ+��	2E��ԒO����|;�4�{�ЧS�\��T|%��fGg6�0O��š
+}�@ ��b��$O�u��7�<�c+�5���;��,����>O�l�~)#������ڞ:e�ү�-���_�k�Z�����~ȷo����~���w��~>�Ƕ����,��k�c5! �@'���&���@��t[_�Hs����=nX[�����lo]�v�(�P�-T��j�Z^ڶ���z\����4�:�:�:�4�qk����GP���0�;������4�s�R��Z��햃	Y��.��*�0sZ���#,S���q�t�@�(f��qN��v�5u)0���x��a�*{��M�M��$/Qw���CP����9���xs�L-8�'�>�`�9��9��+��pǘ����ώ�2�P���Y.��Iй�=ب�����;��I����%G���9|�3A�H����<����������n�}�+�Ћ}j|�I�S�i�R~�=��Z�,.^�����������Qj�g21��Lu�5;?�8��T�F%�`�9�fls^�4������q>H0�;q��g���R
+��dK���d�TW��~�˾K��͟�����?~���b�+�:i�C��_��$�I�q.��S>٧k����e*�':	�&+jB@�a��A����K�G����|���s�o�{�O����`�~��>�֥�%/}����(9�����Y��+I����a���t�G1�B�s�����L���W���T��M-��w:�|���� ʟ�8�e^)~�Ǭ<X�����a�&�Je
+���fb
+�\A��i|�b����htz-��J��md2�^hO�Zk��P��c�K[+�#YS��%�!��CmRd@M|;��G3;Љ��w��c���Ș+Vr�+��]0vˎ�c��sd����K�H��u��ǳ�g]̝6�+}�7�(�x��x��W��'?�vm1�r����;�^��7��Q���[���o���H�ٙ�<��6^�&R!0��!<��D�m<�5�����?�	O����������n�9/|�"�F�rAF�����.]��_�x����wb��j�}c����	��f;��31,�i��!�<6�s����|�_V�%�n@y+^<�܊*0,oz��,����X��b�xv��z0L�s7TA�&�Q���,5�!����vF{JL%kG�ư��Ұ�6��g�`f�.1��ٖ�;H
+����8'?&������1h�bx��P) /��Ӑ�u�o�J7e8�x��b�0�/4���j�����]dȨ�Aw�-t�oi��Ԏ7���!!����q�&�\���t�n��)�l�4�i[+>�3��|�1�7��Ջ�F�rˇ}fÎ���M�<*�0��*�̵�����<�&��?7����ڛ�lڲPA!fs���4�Ρ/=]�<ˆv��=OT�x!k�MC��볜�ۻ�gk�û�S�Qn�t`[�dec� ��X�P
+��ӹ��r�x��2��2�I��V�4���7όI����ЫG�>�`��6f���9(���L:ZR@0�'�]�Ŏ�����4Cϵ���� �ag�BcʲϬh
+�!�{����S��}&��M@��,�.�~��ߤ>
+L�ﶆ�M��d<��[��&�h|E��8�����}>!O;E6��mQɪ�����#�B<�����g�#����mظ[b���A��)�F5! �9�
+�<?+�"���|M��G�k��0�����7v��cw���fK���tv�:¸���g�D�Ɔ�<�<�����G�'\~��^��n�Y��I�.	�I�����b�z猪��Q��1�e��
+>��3fh5Es�j�5]�|&idY�={#/&�Kh��o�~XDN��0�>a-/�N,�nb�`Fބ�Z2�]X�6e�U�];"3�`�<ؓ`1m�����Ja�ZU�$�hOњ��"��⚪�Ę���z�k<�ٱ�W�d��c��h^�kqj{23�#S��|�s�-Oj'�x���/�{p���#����R�ԃ�3�@�Ťr�Ԅ���k~5��ȷyQ�����~� �6�+t�����ȭ��m�ψ�W
+�d�Pb�n&M5bG>u���+��;&��/wX�����N����CaM[SB !P~�t�ُڸJ]�q���_~�kN:�_��~����'Y�͞�KnJ�e�������܋���6��=�s���)C��"�ԂOۙ�S�4�Ա�>'W�K/��H��(w���wG1�6%qSn�~��_���x��)�%��-���\�n��[�Ū�&Τ#�t��T���+<��M�(Ic�H'y�u�a��6�H��؞2I�y�NW--�>B���&c�C�0����8H��-3��JĂ�4��_S)dA�X�o�F�n�	�G���]����Db�Y�,!�9a�a����OF�آst����%_�C�y��f.����\����͇)o><2�"	o���s�$�r�x��.[���'x��99�L�����Ӥ��v��x�,����U���������#\O�h�����go��?{ֳ���{_x�^�Q�YN�-���hc�E�����_��1g�RG�|�]�5�17�����������4�m<�����ྲྀ-��w�:�țqu�V\�K�]i�s�=�lQ�qQ��7���8���g�-U`s��V��QP������v/��d�dڌg11�y���҃�W����r�f
+ilSu���~T+S�}%���_�R7��t$�Ŭ�ME��
+}K�M8A�@"��-�>�&��+?��L�ۭ����b�0��f��A9ԭK��M=��RZ>(��l�@H��6��Ǟ��hfE��Xc��"jh&�u�뀑���yR��C���c�X���[���)Ʈ��#7{@q/Z�~~Yf_:Iz����?����!��=�+�n�ߏ��*?�O;) �kV�0�b46sU�&���ٚS3^�}cc���_`��f+�4��]�+�-v#�S/﷚f��u0�;`k_k@v�o�D����3���<��i��}c��]����\���OІ�L���y�����/���{�	l+�y���ᘭ�K�)�E����\�L��{M��@����I�c.���~�C/��g�y��^�x�q�M�q����������f�K�cb����93����3�ũ�J�rB��qR�Y=?�`.)A��.+��"9��ȋ��ol۟�>�M-;�r`��=Ř �-�B��h�&�8c���'+��E?��|���;�P���+���#M�o���Ϳ��.���T��`\긏Q��]�6�/h<��}:v�DN��	�Ҡ*
+�!ҩ��)�5�`��(�<���i�[�1WCP^M�@L&�<p;���Z����mΥt*iS<�e���~,.^�c� q����9�����TiV�4R��Wc�1Ȱ<��_�#:��('%�i�h�������X�oəuܖì��&%�t�R��I�~-o�ѫϿ�Omo�G��r�-���m~H�<T���q��9��_�:��Xqⁱi��q�� �W
+���6��x<���~�5#~�����;	z��,��/}����qr9��ݽ������'���m?H�mL8�P�%���s��sl����p��3�c}]췍�q�����t�e���	'��&�W�"��=lA6��k�}Iӯ��MI�z1.uJ:�}�S�ߋj���cc��[��R����K/�U��s�i�}G��DS'�6h�K>6���RoF��C_�a6M	��{��$�c��(�3/dnE��Q�Z�E�T01I�l'�F��l�i��ګ;6Q�)�����!r~��S9_�f��%ߊ�DS@������T<�<�f�ё�vq�ޤ`�cc����7��Ӑe�r��6��N{nm��QC�R��̞���Fls��\¿��ȁ&���e���Z~L���	�\h���.|��KJ$�Z���7�l;�E>#zs@_���S8v6������3C��\&̙��ׄAc���w\�c�Ǚ�,'��2�Z��c���̜z�����w����	?)�����5��/�w��MI�+uJ:���s���)���g��/mC?��|�l~2�̷���'oݺ�?���j�\ ���x�D���B@���#;R��{;h�5���Rl�ҥK�ꪫ^���?�b񱺊aîN_y�^0u����kym_ǯ�}�O��ȽyǾ�G�*?<�^H��C�v����P�8���I�/\R)�[��cr#�(<L/�P/�-�16�r	�(�r<32�r�-,&��gؙ�0�����#��aH�d�)��bi�/ȓ3<��E�ď�3�X1
+P�����P�q����EޡZ8����wX�A~���x��w-�%Y���WZ2�O�_9�r�$�~��M���v��H�����l�|�J��Oby�̅F����зy��\�ha~�o�N��4H3�����e�aĞͳ3�"�����?�s�Z�����!��-��]�Og�6_���ܫ��}���o����W��;x�M�űI1i����0�9��0�h�����r.ԅ_~=�%���$���v�	:��o�g_T*Z�~-/L��l�����k���~��nx?�Ի��+�[8��r�5:nѾ������+�4�2�>�c=�#��Űx�S�8+�{��!���`�yz�s�l��z�cL�AK�~�z+/n���Yd;~�Ks��xacA8@c��&�,�Q��yV�/�5%+`�-va���|�gV!���8�A����BȎX�w�$���!��\��q,�4萓W��/�U
+Aw�W�Éƫ�����L_���_����;��0�[��@�ж���=�Մ����f�,�������˾���'��+7n�x�W\����G�	�������P��ھ�m_�w��x�~-��u�Z�#|���]x�2�T\�6%4c�nP'˴�%���65_V��X+f�/痋(X��M+eJ���9����c��-�(�����t���k��M��D��:;M+��N�g
+��4�Tf`��8,��>h(z�i�4���8� #_�Q\��D���Ji�1g�ɵ��q,��M}�8�=��T%a&1W�i��'�M��t<���4Kz�3����)O�ܔ�K�g�f��N�*FX�o�#��{�_3
+�ӑR��gQyǜªķ�*�s�Jn�R.�P��{�2�� ��i>+��m8S;T9�=���f{��Ml�ϑ�"{�B`��Õ�c�_D���XΦ�ǉ�%-�#����������:�*'%9&u����c�(H|?F@��j��1���q��+q�xT�|�6W�1lefY���5��)M���8����W�P��k^��[������6�r7��/�������托˜�E�/����~�:�wB��u�Eo�O�te�n�W���A�R�H�fD&��-���(x��d���(��Řxht-�����"�P����=�f��i���2�����q�(���i繅�s1Jg |7���L�����nM=;na�`�C�,i��i�2x����FE,;�,^�o$�L�ͯn������$�q
+���~6��ıK/揽͕�������rPC�2���r�q͖���q!O�츷���m�?>T�IPϏ�`qa���!�uW�s)p=�N�;B���<諜Oi��W����M�������s�g?���x�+^�����6�6wF��+�X-�P��c��:Z�qF��Z���XG�ҙ�L'��A�I1D�T �A�&�lBp�$��n��q��u_��������f7��\����y��q�y��}?�u�Ϗ����/:�֧+m�i�fI�0�05 j�9.��֋q�>Y�^�p�11h��[>p�GV����ڔ��ƜI���'��6I�'�~ND�=l��)�]D|��_��ʗݶ�c��?��-؆�U����F�N�O�7���;_��w>�?�]�s�߹��@
+BQ��A����C>�s��8��#�������+�@W7L�2��=X������o���������[�{����y���K�*-��yTg�7�f��._o*`���k���c�����?��w�Y���D^zz�/%��l@\���/�-h��,\5D��������`�/~��6������?q��.s�H���6m\��E���etl�k>|�GxL�+8��-�9�q�� _���gR��%����B��^�BO��3<���iۋU$��`��C�b&�4��߽�$��)!��͢6�!m����&���sy�y<�Ȧ{n�a��(�Ϟ��>H�#�E'%���M���o���4Ā*2¿�}���3�E�m�������������H73��
+�iF�z)��}nĤ���n�+0���~jO�~����p�5��w�a�Ǐ"�Ob(�$&��y~_�}.s���s���	�t�N���Տ^ՈQ�Ω�U��w]s�����F�C?���O�����xƛ�p��@
+wu�B�ۮ'_/�Y���OP���	J��\�s�S���W�������-��o|������e���g��Y@��FS�7����ĸ�/|������<���SE������u�+l`��U�U}�\>�q�{�W�W�?�'����O��?!��w�B�~�k�������.�L��������X��^�s�0��Y�d�.YvdsRO[� 6�G���I���<�����c6�1{�5:ln����XPZ��,�Y`�m��OL�]a�&�x�صOϢ��o��C4�r$�a炪y��A��%6L��G���-�D0��H��&��*6�rp1�y��~�;x7z��TgC'�q�KbR��#���<|���T�~��x��x��%�h�|A6cO[rs0f6@��=zA����9�4t٧���'>4��sW+軐������ۼs�Upfb�w�c>.�h��.�$�w�&Ʊ����#s��`2T9̸���\H@������/VI��!t&�Ɩ��}lS+�S��_0�5�G�d$k�n{|tj�(!&����qC�w��,��(�+u��$b/+����	dS��
+��o�ж��8*���.{�������i�[ݘГ����G�AR����O��䓄��ߚA-�/5�����i6:��!�OP�����c ���-�>Fl��ŉ��י�&�AE<B�:�{>R�L��&0�X�sn�k�@Ù��Ό�44t�s�����7�јmӑ���2Y:9��)3�ӱ�M���8!ncbt��I����nԌL����m�y���N���"�\���=��;���ŋ�O8�'�F?���߬7~XS���n��n�՝ʌ��\�s��
+�S���\�s�
+�|���u�\>���w��ӻ��͋^��J����1n(w1�E-N�7dxl�u>��w�^����,,�ϫ/H�7eӒR:�)�>����E�p��Ŵ��\�� ռ`�(�ěq;�|d[�,���1�oæ[1�g�X�N���q]�g�-ˤ��P���Q�=J��"�]fa��AM�ݷ�o�p!�ix�q�I"���Rpy�ݪg�������?�M$yħ}� Bx.�����[x��ض�/u'gn�ߥZ�)!ٱ+�]��.�C:�3|�"�����g�n���J��e�sIG�3-|g,b�Z��G.`��x��1����=��L��\�ǓG�0��s/D���u�g��ߞ�\�<����-�ژ�Ⱥ-N�='.�o�_����{]�=��59����|}��ypa����7�5��Ϲ:����L}Tr35ǟ�+b����ʬ����o�b@���F�xrl�Fڒ�5���r��8��`P�#�]z��m+��~-$g�5\�af�0xk����-��.�s��J�9��kt�w��Rmxf08����1?���[|A���z1�n]�`�ޥ��)�Ҫۦ(ls�`6c`v�&�ݘ��K�v G�T�@j"��b�	Ŝz\ƃ��z��]N�+\�T�8E>�9W����~�U�?���g�Ӟ�v�ȯ��������~��n�-�öG����2���o��:�?��v.�߬�ȯi�v\�U�:_<�
+��im��Å�ʌA�-8um����Q�S�Y�V�����,�)}���J5+~�f�?��Q>|���<$��Df�n,��^免he1+]�=;�"d|��	B&��Ёa.�s��@���;�Ġ���3�z�c���Q>���1���}� ������!�W:��ޞ�@G�~��&�m�ُån~��Z������kq&M����b�:�8��X:�eO6���%�%�f2�<ǎ�p3/t�jv����X��Y4���-S�����>�fO�6�V��r`�~�&���tAڱ?5���	�.�x��\��m�&�uސz���~̙^&�gr~d~���yos���|�?�SCO�r`��]����U>rt�1�رcOn��졑Pl��뜬�Dcq��y+��`?��uv�s������ޟl2����G�3�{��>tx{B���F��Fz�1uN��Յ�J}�<[����Z����-��]L�i�:�+fS/�����od_D����>��׾��ߨ�����W��Z\w�x������2=칝+p���P��Y�q�vq���]��|�L�թ̪�T������7�����O��?�_/Gn� �to���v�|�@�
+�p�G���4���{����;?L�����ƒ"=+eb%=k�^s�Ӻ�`\���N]�َ������<��b|�&��������n���%�KkJ`�id.�/��/��E0:jKkݎ�E_�q���'��6e�a���HC�Hǃ�rE��Љ	x��h��kB��z��5;�y�;$�4	�k+PN`%�:�r8d�5_S�eK�xJ9v�#��#%Ql�`�(�NSG�ls@JS�п��dt��o7zAG�ԉ���XٟK�\�L�F�q���lJ�6&V{# ̗��T�-�%����d�&��γ�|�3�PKg����F�0a���'�v�&5+�)��zڸU�{L����A�����rL�[�΍X����2a?/���<�p�χ��+ek���:/��1���O?�\�y�㇋*a��
+O�����1MEl�Z�G�M�3֙�4���a����h~��c�>������݇�s��l�<2�xY��˼�_k��z��MbRfD�!�{|�)PY?����9H)B�L��H�!
+��N��;J";n�v"J�F<L�N�=^j:8R+�X��;	��G~4t<��H�u� ��~�]�h����C]�q���	�S���RG�LσɌ�3��Yh��̹���-��py��>�㟹�aS�ga�Ȋ,۾��,�8^}̊�ck�@U�w�&��㎋��e|�B���z=�{�=o�<�$j�Y<ھ��|�]�}�O�j�/r�N{q>E�E��Y��F��Yzt�����1=����%����\�s>F��E��(ޙ�\�۱���N_��1/��/���~�~��^��W�]}���N_���L�H�)��*����*_��E-�~T���viG	��T�ŝ��L�˺T�T�i�F��Q�6f�J��f	��X4m��K-�]��Bi���v��.��F��������8�U�;������c;f�2�= l-\�A��ݟ葫3���u�$
+�6C.Y�
+g�d� ���f�	����\����F�$Rmf�ƵW��'�L!��p,��<s/7	����M�!��%W$B�rh�����^qT?���
+\_zN�9�C&���Ş�-��N�§m�1z�­ܳ�<W���b,�6"V�S���&�Q����o�4�(~�gr	�^s*�m��j���q��O��Kv�|���ZpQs�')� ��7��&D�3$�m���w��_�3!��9Vl4�6C��u1��ܘ��F���̓,DB�r�^�����t��7��%��I36Z��6��c}f�s��g������x@��/sx����>mv�p��7�<'qx�8�ks���4�)vtm��_/߻������/��{~�u�{*�O� ;/�l����~��8W�1���${�z�;W`��~~U�?��c)�����O����r���I�G�.�t�7j�/��7�?���������?��S�bX�mm�+<XO}�י�\�s�
+��Ve�>@Vf�p*?�y�{�}?��?��/zы���@�H�S�S�����Vǧ���-�w^��#]�Q�6l,~4�r�,8�ٰr�AN�F��%�sh�`�M̽0T�u!�$0B�ݪ�C��\t�wi�K!+<�
+�����w�>W�
+�++���M��a����,��1����Ç����ߋ����A���l������+V�\D�w-�g��!�f<�;��QJ���D]����p�N[������z�%��r�x�,�^]�=&|YĂD��	��+-�1 ��Q%���i�ZcX4�#�tI3�;g=�ѭ8"b�K�͍\D`�3p�4�<������;1�(#�_��0��H[�����Z�hB��`V�`�>V���C`~D�:ؖ�8zR��]��ݏl9uɚ��%�.���jO����Ze�_2���3��bU>��笘$���F�ΏC���N�*�WP�踇Ϊ��f���j?93m�M��ӇԡG΍�I�$ g빀s���M�1�>ALb�i�s��9��T0�G-�n���1��4v/H��׿Uc9�B��]�8�����x#�Vy��J\�x�M~GL��0���J�|}��8��j�H#v���l���sc7��M�:���d��-&iG�s�1���]�f�х?2>Ɂq����<Z;}�Ǒ/{��zͺ_?H��;��7�i���L�9�������[I鮻��m_��_���ɟ�s����'��.+�+�(*��QP�]�8W`*��i�Oe�<X[���4��7���e/{�_�|wq����Fj(���h���A-�����.~A器��/�@�UE�a�l�>7P�U�s0����.�����__����Ul~����aÏ�t��5�xz8�j�cX���q�VQ�#��dc�f"}�0<��o�Bm�<1��b�s��:��&m8��	����y��&�aς�1a^�{��'.0S`�3o�C�c�,�1۪�q�ȷW~�H��֬�������+���DÊ=���qE}��f�2�6`�f�$�d�q��=��Ѷ�Ñv�E
+bW��3�X�\��%�|>�(6�+ƲD7){�:瀜k!��+g��6��8<t�βw���y��}p�#�����"�+���F�� xP![�6�q�S��̻�3�(��<O��<Gv|���~��M}3�	��������W��߫��]+`��#>]ގ�TCz��D/#r�q#��l�_�9��l��6��(P�����i���$�֭��lR(�d� ���$сz�3o��N�p����;����f+��v%�O�S�8yk��8IW�}6��b'uS�w�Q1�*�)5@�j!\�����h2`ۛQn�K:R��]�[S"$Z{aW�B�w�q㼢���+�bћz��-��D��OEs7���ޔ��y�p}�>���;���yv��<����r�ΟDJ��Q
+P�30k��q���?tIs��yR�XCv��`@�9�h@@��P������Ff���I�>!Nt��'^z�C/|�	yg��?��Λ��X�O��{���/��/��������}zPv+NI\��8CknR2�c�wp�e�"��vժ����)A��㚘l�!��J�º��pI������w\���j����[���࠹.�|K$'�g<�/�������{����#7+�+p�8�+\Q����K@�*���o����o��o�n}W��dD�ɰ@�E}������ծ�U�.�Hc�r�E�B��Y�i���h�*->���;.P�IoIr�t�c�	�aVw���0Bz>��}�����8�����ƿ:��q$�{�`��@���#�����"+��_X�[���zT�S���ݚ�5�����OV��b��j}F���6Ԇ'Wc����~��(��%|m�Ձ���"�K�����(���9ƂKn9�I�o��6�Є5�V&5HW��Y�$�,Ɓ�q�иk�8��:�	ʺ�_ҮA�<R��D�T��#?�r����<n��Q��-Z�D�I�z��l�&Ƀ�sä�E�pcPK	��X���`�(�%��i������|��x��|��Gx��cf�8:���Z=��,ܼ;Rꅪ��]y=n���+l�`�s,�.-���q��1m\�9������8:L�m]/������0M��ݖ|��&�����;�x;M�XV|�P+S�gŤ���f�$�O�UI<���E(P,׸O<O������l8���E���������0�+��;�D��̼�b�r����S��$��_#:8SG��B?l�;a��_	x����?�0�v�����������N3�Z��T���_��z�iS���s��qn履��8W�
+�G�?��w��Iozӛ���/}�7kv�~
+�z���N��?�k�T,U=
+:�����p,��V��T�e���oG���䰖�
+W���tQ~�W�D�bw�x����łҨr7����ҴJ����9�0ҷ,�}�3v'�Ϋ\v�����e��|��*X}B�-��&�L!�Y��
+3��0YE/��@ݮ'F/��rL\���o�+<L�纇�M�
+�+�����O���¿�g��u��V��ߗ�E�N7x���c��~#�GkgNW5^�ߢ���M��YQ��.
+���:�1�|k�5���u+���a|
+�}(�Ony�=�9�5@S�:-�ԑ�d�5>:�}�si4�C����lk�0�)~�1V.GFL��]]>�e}r�m=�gtE���_D�7�"��m�^���U�9�l�8�oΡ0[%��?��83�Z�'�f >6�E	��K���IKt	j#E��@q�9~��@8U:*8��0�7�\
+��u�tSw���ʀ�q������ts�Yz�}&+�i�5�.׾�q��TW����\̮�囵׾��_���O�������������)�������H�U��bP��	�<<W�\*p�p>�x�
+�/$���/�W�������W�����o�����'/v�a�;��&��nd�i��ߨ5�ý�Wez^��w\��^�?�K+6��rB'���.@?N1/��vߟ�=!���*Iŝn�j�9'�`'Ã��4�x�o�����o[s����c�~�pTc?�GP�g�,o�[Y2N�K5jĺ�3�q,�q����wy4������ճ?3L�Lэ�n��}����s�'�F-z��^�5>2�7&��w���F��@����M!3��w��M>�C=� ��������Kaω)����ƆX9D�r��|؏}+>ܤ���8e";G������N�װf��_okvu�kj�@�Ą��XN��l�Yb=�4�g��i8f.���(�nd�=I�1��pOu�����^p�6su�Rb:�$ퟐ��<FL��2W8�w��C�weN��!K�A'Y�9Ѵ����2�ُ������o.K��D&Zh��B]����		����Ӹ�k��z���/��O�FB_�ċ�r��a�3�-%�9q>����?��t>L���n�J���\��w"�ݬ�z8���ކ�9��uR&/X�q��_�Jla�-�#��qր�ۈ�M�1�<��Y_�K+�
+J�ׂF�(�Q���%A��9���u�3�VU��C�!�j��z=�0W�b���yx���P�`��t��?�'|ݏ�owq
+�(LC��0#�D,��Fx����B���I���I��/o}�Iڱ̛�s`�/N'����!'��c������sJ{39�W>@f��1�HX�L���}�:P�D<��ʻ�N�9�2�<]_�Y�[$�+�p;)�tQa.��3I>�fK��QWrJ�e�2ͼ�_�G��:�����ߚ�M��M�i�l���޾:�ޤs[��6�<��8>w?�q8�6��[��+(�Z�M��MgwǷ���۪ "�TS?��!����^A�2􌔫j���l<�Ͼ@7���m�=4'>=�"�g8���t4oIyt����D�<Ra�:��N��(����}�Â<�S�8�'?8���졉y*����a�������86c��z�ם;�jݛ�m�oP@#�4��L����m����\s�.���O�o����<��fP��W���r�Jʭ��+�o+i1�}�R�y4H������xq`3G
+͖������cH�P��� 	/�`�w�87����EÂ�~�����������Cp�v>@L0�l��~倊��}3	sY�~G�@�S~\,{Z�9������c'Sc������)�c�4�>`.����]+�I�I�����s&o=Ժ��c4&�&g�Qr�'�o����no黏�k�C���3��q�8�h�s����Z�K����n���6q¤���<WF]���e%��I�ύ y��V�YS�̯�s�K6:���|\���S0�MEZ��{��M�\ba�?NDt��_@d����Ѫ��01+�"�������@Ǖ�y�����?����^���*�/�`VO�����s����w�.?�/��C�7�e���q�cQ�u̪��
+��#]�g	�ʧ�Sbi�Ȳ���!d�Jϻ��z��[_G�]*����B24�Fc^m�?8w��a�)�itQ��H�pn�q�RF5�8��Q&�Z�2��ǸYl:��0G�N5.(l�ؽt�`b����'��2���m����>��<&�|�H[&i����=_�M:^�s�DOo��b��S[5��x�hk���e��28�đ�&�b/��\$d:8�{�<�X�{:�;g拯��"�ĥ�.,}a<�
+�9��E��d�?sW?y'�07��ػ��\���Pi)�Z�Ɂ|��<�LB���!g�Q��A`���F�\e!���޾���Ĩܚ�6<L�l3&+�}M]z�*ƿ�͏�)����=M���'�(���]� �D0=.��?��ݾ˗���@����_�?�s�3������m
+��ꫧ���g�\�ۥ�+���$���.v��.�S�i�s�z+��'�=���؏���W=xIEߞ�f/��Ͼ\?��״�y��Oh�_�Id-�Y�<FMo2\��.��#Y��Ek�.J��2�:�z�"��)2������}G�Y�Y�_n���XL�K�+�;�+��
+�������G��#%n�3��ia��d�>�� q��e_.]sF�t��k?b��lZ0PZ�͉;C��~�N�~e+�I{�ORYGO�~n�
+�68�In�)�'z�W`?�+�_�`ŉ���O����������o�앟��6=�rk�lޭ_���ׇU���s/��`b~���k��[���%�vP�¬M�!��,~�]����ҵz�9S�ib5��8fQ7��{��IO����қ��I@e1N�w�jP�f��ձC�SKdq;׌��h�T�� �ٞ��g�ķ<��	?����b��-�;�
+C�sM� �Ck#9��,x�+�Dg��Br}��JٿqH-�,^y��3
+TZY��0�}8�y�8�x���y2��'s0�{�OL�?��XGB�����$?/�̥��$0��o|���$�q��=}������HЏW�1�}��~N��c���|�G~�G�������_俬G@E���!uʇ���I2���Wxb�!>�JpN�6��~�#w\y�ygLσ�����?��_����zQ˫��O���>������}�?���N<�^'����;z~�B	(eT�wCf�#���5�/|�{1%�_��)ܞ��6��k8�,�XP�5�;�����]��"1�����߱�wȡY�<�:��7|����w�|���Řz.4h���9�ы��g���X�{�n{r������y�}�'ӾZe��u��|l����\�!���Ox�������d���]#�����,���������������b^���6n�q#�m�)�x4�Rr��e;�	�y�r�4����|I`�{�/�9�)��Z���2�E��|�q.���1d2��H���GC�ӻ��]K9�z���xr��!��״�٧V�~��<�.����y�$��#7��ü��z�_n�>���4��sA���oY��s��03g"����u	53��M=���j�|}ǿ��|��q���},D��0\��?OC��,��0�������L-�o��2�Ce>�i����½�|����#O:�Iw�jr��?t�KHvµM�5$xo֥����~+���Ut�z/�Y���ǲ)^�����O�����V��YL��X���yB��*nV�&�C�C�?��8�p��2�h�C�ES>��vp�ƴ�t��Z�gj�؇�ִXQNYɡ��O�д_��bϢxGW\����q�F��E�u�M̕�`�0B�!GTr�u	����e���yޒ����`�G5��H�m�*��W_�f_EK�D��;�,Z�h�qd�uD�Ȫ	�M��uN�|u���4�Ź�~)^&��(���>���>�a�1��x߇��0n�����%t�e:=�=E������0�g��N?�̫�`���<�8!����J������;ω}���!�7L ��R�8�MO��o�����N �A��q%��G�1f���u:K?�/��5:c'?'Ŧ`.�&i2�?>��l���sRn&Bg���a�IcbM9��\-���]��E�1C�䧍�=�Ө��Qy����H��S\�\�0:�?�F5N�|5	K��=l`3B:�sX��ֻ..>��m�>y7oy�[�C?�h���C�X��R`��yh���4��v�����l����yr�
+��9rǕ۳��e�z	����o~��i��i� �Q�c�ט,���ޅ�I�[ş���������]�_sz,5��qp.��y��2�c�Y\��*Άч�`iXy�ݽ����D���i��) IƑ�-��C8��b>5FN!/�#A0�`KqS���|�*�Ybbw�w���`��<���g��c�����φ��&�6 C��L	*�H��R���G��iU�uR����T�&�J+		��"�c\�ec�u��0�O��9�~�u_�Y{��7��g`���Ϻ�=\���~��<{��;}���`t���0���T����#�*4�����(+�k����p�h��@~8��3���F��Q���������V����x~1�>�s�,��P���^����-����-o�����+,��)(/&��N�'��CӐ]ڥO�
+lg�'l����bW`_���n�U������7��?��O���)�A����=('���r��޸qxl*�A�~�1P7r_)�������Xf�ט����	��ǆ�J�&[z�9]���	ıA��	=ɼ��F��Ĩ� ��un�r{�־�c�cK�Q?u;+@ًv��^�[���A�&ָނ����w8F��Z��3�0���q����d�V�~Pq&w���M��_z��`+?��A�>G;zd���������	�`;C�yQ8^;]��KMCvi�
+<!+�Ƚ���$�8�����;.ݞ+4��?U�y��;���y�s��^��˿2o:��P/x�����<�;��n�ߤ+��h��:�3?�5�fK6��g��ᙖ�� 	.��e$T�WW4�޾�~6��u��+���]�Yxԣ�X�WV>s��z6�ٰj6|C��4=��Z_�Ǒ�%�:]	���,�B�0hX�nL�w�6r�0g�#�+�o,���|���p�o�x.Rk�ߵ@�<�r=`��x ���k�SNV|�������s�ãQ����'�pi�K3�3��C�l+7_�7�B��B�͜��s5W�zgd�
+u������'<�a{�P�!���������ș?<�/�cr���X:5k�H<�����|�r��b�zi,b�u��1�:i�!�U,���qӓ	�A�y�%	k+7����E�[=O|�	s�1�A@�7�+9�W�+��(���7�CD��u�{�*�,�CX.���9�yH�bڌ���MM�V��f
+w"�P66ǵ���o;i�}jc�Yb���L���r]|[�e�/��FX�kg��6��+�����`Y��[��#?j%�E�v�{�����GI�9��+��k�<j�8����������aiڲ!������4��9��OD�T��H/d`���E^���3:K��8'�5�� ���>ۓ�ku�_"�+S)���#m��F�}?���?����k�T`�&�h'���r����*����������K�����o�d��ƞ`
+Ë$�C�%����.xBT�8�<!ҹ$q��\7S�w�x��\��K?C_��W���c?�c���F���<���?���w�u���q�u^l�eм�gq����$��&�oƼY>n�e<��q0��ٶ���;����~%胇�HO�Pt��p"���kȵ�q�������9����Jc�͆g�CZ|�)e��3iۑ�����{�xL\�l̈MB�'��2���>��©y�iPL�ox��p�3&	0x���p���ޛbɱ��֎�J.�^���.����7{MH��&��6����۞��y�Ir�ah0ڇ���;��qs�����6��yM�=)/��5)=��΍��g}(�cǿ�P�9�E�H4�*�'+��r�(��	�z���?x�a����I:1��mhܛ����bO�l�Nl�5D�[�H�����]�%� ��R��Msp�@�?������^�9�.�U�t�A}�k�.{��V����hB�gb�M��?�|�Uߚ:�&~���,�Ox��f�N4�$\;\T�t!���\"�a�-j+^S�Z�U��;�Ցf���?�!My�x���;.��d�^��+Z�`�.}��&{o<���.�P�%�~:�^~ߊ�r4+��yfv	�/Z���Aw\����f�1_��_��?��?�O��g|�Ʒl�������?�}4��d>�K׫�%�?�Ehi��J;�;�����$:5�*��ؾyA?����g� ����ٔ�/�pL� �a���2�JU��h`:�5��$^�V����8��6�f���=k�����&�c�T#<V��h�ޡ�F��1����%���	�F�}1TyVV �K��X�9�q�uա���^f�d��������_�l��A+6��`O������ =��d�Z#1�s��Nb�u��._���ͬK�v�V���+<n*py+Ct�D?^��nMk����|��G?���?x��v-O��Y^}�D���A7����$y�O[ra'�\�b�~��ncT��hY��x8<t���t�OT%�~ ҿl�5>�ݖ�l^�?�����bh�I�UBݟy%^��+
+��P�;��]~�"��z��-���Ѕ���c��;7m�E�Xz�����´4
+|�IC�_鯝D�_c�dL[Jf�c;��R��m�1;��g�c��zHȑ��+�n5g@�|,`R��;n�㧸�Q��d��8�8v'A�����|S`����<����3�I��i�ubVl���/ Г�p-��v��]}����̈�Ȟ_��m_�yC�$������`���92�Z9�#�1�v��7�S��\6-}to���J3BG�f�,+ ƈ����4����|4�MOM����i��$�`b]xRK���=?c�Z�˾q�uPGS<�l<���*VCkL1&L�e�5��4aD���^�mșx4�:�{l�ǜAG�ރ������X#K��e���\78s���u+g���y�3��n��2&�H�?��r J���s��4l��+������+;\����b3���C��Ï��א��c��"���Ư4�wT�#�:�I�c6�	~�Ёl��b�n2���|�p��y�8��0l{};$�i{Ö�uk���l(o�G��J+$k�"��E)?�>�X��<q��bX�$�U�j�7�G�Vm��^y�K���uJ��e/{����x��:+���IKU��0�X�h(B
+�&��@����n��'1�t�f�?L�%�蟿�Vj<�^L�ck'�Xq����ǓO���<[��}��H�[����k1�t�}�#~׆tSg���N8�@�xh$e��\�]����д�g>�n哿,�;6��?�9�%���_�a������.*v��bzm�жCU����2HLɛ�7�1�Ug�Q�3�]O�](�%���ir;旙�d[�֋I��F2�!^�x��{�\�1:��<H���a�h���[ʫ�0��>s4O4C��<�nLKW�scL�3+*��g���Az�O�w�m�ƿ:�;C��C�c�Ԡ��b����$�=?hc���~>�'���9b��ٰ���k����2���kݎ%�l���FV��T�'�~��J��G�k ����p\��v.7��[ٿ�}�������[��������4���p��i�/�R��U����������t{����}=�������o����q�qM��n����5��`p]<Tگ��}�������0ϟ^����Zzl�(��]s=�����}��@��]��LMI�X��y��xm`���[Z℮ǥC�b2�Ǝ!��F�a�2@���K����7�x{�?�-��u0&c`��_,V�����_��O��Ͼ@a�k7��c��Tgp�Qz���n���&�����gV���dvW��{�}@��W��-�泱��Ȗ���W���R7���B�`zoT����΋���!���l©�+lo��E�� /��,tǥ۳˃����zֳ^�ۿ���ó���o��^@�����+���֗�~���J�_�[(6����n�?Xp��ehl�9tC�>�v˸�?���"�nVr��ˉKM�sQ�Y�p����O\c��nG��gS<0�J�Ql��p�G�&{+[���"Vk��<���&��:̽M�xG̼G�l�ʗ��d�0A����'���RF���f\ 䒝�2z`M.��Е��xO?��PX��\0K>F`����4>�[2t�m���O���z�v�����۹<�/yO4����+��������^j%��V�<rh����Ni�l���w&�3X�~����o��{s^�b�z."~]?ǭ�y��2�u�ڃ�\"��)%q���FY�@o*��R�>w�5*8�|.;$��G�8�,����(y��v�-�$2rB�fI=^B�:DG>e6<�)��/�� �os��|�Ƃa�mj��"��1,��ژ���VTt<�맢��S?�|�0�t��y�I�����H_�S�|�֨�zͥ���DD|�,���uݲ%���lg����i:|�������g�?�]ң�#�?��?���������z׻~O��7&]<��r���W����]*�x���^Kӟ������<��O}������?������b�X���C�����sC�������,TF�������A@/��,`�6E��<�D�+�V��0�l�p�Ȍ�G,�c~x+�"H��QQsϸ��o`��i}$�ƛ�+6�N?�S6Bbۏ]��`Bk��{��&���ę�+��<n���M���ۡf��E��!+��m20�'Z�9��>bGd����b'Ց��o�!��T�ȕ9G]~��v��OT(Yu�pGT��kc˝c�Ǘc��[}���R�|�����<����e���>�~ł�[��)o0�|���9�X���9�w��;���5L�9R�u�8�mn����DY��(f�u|x3?�����D��>��aR����/�����@�ha8���\�qj'`�}���7�nk���1+�h��O���2��yO�I?ܩ5f�7wv?��Z������G��d�Mʸ�F[�t�爚G{؇�8ͱ�{ ���<.�bG�{4�c>e�/�q���+p�ti�
+<*����C��n����'��o��;���ő~��"�;}3�]g�w���'��o����Z�(*Å��5�{4.��徸�c]ˀ8��u�f�a�p��X���8B���&>:,
+��K{i�G�ר�zn0a����CNņ�Hs�._�L��-c�I9����9�H����ZT��]�D��0LLjU]�i�V�|S�NFe��Ăo�I��3qD!��K�C�U����S��Om��^]�YU|u���}}�=�<)��5v}&����/���.|�pfA��m4����u��6N;?�{5)��Gs���R��^�S:)��#~N��otM�1Dko�u�Qs�΍n�-�a���8��U�����	��pzh����,�f�%»����A��8��Py+�b���mX+���qv����q��:���U�Z���W.��՟�4�B�O��r����U#���R��x֑��~��-W��֮���6q����Gh��o�W���g?�F��)ފ��°ɱ����,��a�>r�<�z�Vm����,��������?L�c� ����#�	x��8ڂ(�؛�g\�&7t��Cv��˨5�]{�GLp�ѩO������N�Z�X���Rq�z��z��L��֍���_�T=Ua]ծ�Zk�-���EZݛ��N~��n�k��׿���/�?4�w�!+<Q�=�J|	�!T������_��/�17��{ի^��|��~����/4�;}3�^��w��;o�+�]���t��W��_�����T�?ל[^y�U�z�/�mz�&����	Y��-}G������b#unw�"Q˃�����,�V�F!�̓������[x#pgt�"\A�=��+̬�'�׏�Ԗ�n�b��xxed��[��aE[��u��5�C�����ˬHAS7YLVo�"%�a[��G��Ӭ�h8���o�(,���y�6q�@L<�^qE7kځr��|b�V0�#p~"���r��3�?���Fg�km�i_������|Xv�?<aGF�\���n���u�����@�D�M�x�N��Zx0�H��n�嬽�K��Fղ� ��X`�C��g��HuH�X�Gl����y���d~a26���?bc+�J��6>�1��:���0;�kd�<1P'�D�+FG9�`����{X�#34̳�G�1*F0J(���	���~���4�h�g�|&�m��0�ĸ2��DZ�Ν�'�)���\C��̯��u+�DWZ�g��`v{�Hq�l��?`Q2^�%��H�{�牋0�@�t���yP��6�7\ۑջ.3��Z�^�O<������+>��l�ӄb��#qݩzI����Ѝ�b4���)�F�ȕ9%�Y/�z^�(�e�:,C��`�`�>�M�b�;�ѐ�36��d>�H����Qa�W�'��) ����s>��Y�R�ZF����N>�nX;g�#;�|�d���ȈxVF�uO�YT�SbO��"�w��={�wnv����G\g/P�����y;}���wM��u<9��t��A��+���LH�@.�r�ى��[ի'e�������7~��}�?�	����m�	��{a�-�CT���ǟ��@6\_r=���$��%�El����Y�ys0<h6�<��z�:\�m'{蠄JT♍�jӟځQ�f�i��$���+�e"F9 ښ��O�c��+&34���:���s(����0�b�%X��	2,��Z�����6:,�Zq�φ���^Q#�Śna�K�X���9a��dn�U�u�����.��͹�UԽv�k=7��y������ŝZQ���i�ʓ�Y\p�����ɛ�ɸ��^m/��h4>z5���)�z8�5�^��=�� aj �iF�]��W��)�L}�������V:�om��/+�y�!=�X�b|���Jl�����q�� �9��ܛcTlz;F��n`���$I}. fj>��'X5f�+�oX��p�¤ꩯUo�@�!���ꑷU��aϬ�<�ԥ7��4�7)�HH��H�u.��(
+Ϛ+��Ow�]:`�?���	�f�Wd�]{	{�����+U�
+�+�JI"#���8똞W�:�p�٬����'�8�pbG+��e<{$7T�54ܑ/���-�sյ�8+�c�j���/u���~�V3^5XM
+���kP��A瓴0��^��� 8x'����H���8�7S�w��ђe��E���@�oq�ʵ�,����)������|�u����~j��33��i���6��t��%~��?��:ڶ@8�7;��r���oo���c�c��o��E���mֿ�C�S\;�Sca���i,}��<Ǐ1�&�o��!s��Rk+�&vs�c|��<'�M��JM����˩i�&��[ķ�v�g�e�.�/S��Ӛ"뢟���YB�5��z�5�p���F"�Μ���'��3�y��a�i��9B0�?����έ���Q��n]����Ꮖ����@������'e�;�]�W�
+��V�6�Q��������vu�Νࡳ����������/y�K��?������ZK��N��۟/�K�
+\+����H4����$�?�iG��ˑ͹�������\+��d5��w.�Kӈ^��#��b&�^�})ZD�Ht�܀w�[�80ʤ�i�A,������z֕�;eY�#ksl'�kq��?l�@�-�(�B}r}�Y3xz阸��14kh�ϫ�x�5����7�m6uz0���(�k1>����82^��A�l,����1�$6~��{4���'�Ǘߗ��xXv��zo��B_zNE6x�c�o����c������Qf�"�Z�l��
+�}���\[��=��.и,�=>ʓEV0H0�<�->���٬��S�?k^�}�4����]W��=B˺��{i�mS����%�w���9ō��΢q��Np)Be���.+}]��1J�Әw�u���K����E_����?�S?�ǒ�o/��$V�z�0�]�:��w��G��+�b53��&Rp<�4��E7�ꌥ���c�S�+�+~�f���$��'X�`���fM+�(��2Po�D����<���(��B����8�9���s��<&��_�9O<X�UaO�rrͪʹ����	�G^+�1/���2����K0�<���<�"�����t��ͩO�ۯ�5a�`�+� �/gx
+еb��ea�$kj�n2k��.:Y��W�J�i��^bk&h+w�d]O�,��xh����J�~�qg�^��?��x���S�4�ݞGK��t�:���NW�aŸ�N�y&�^���?��/~��=�������������Zg��j���(��x��B_*�Q����G��'���~B��4=�����w}�w}��}���o:y?[��ܸ�ӽ�;�/w�ֹ���u}���?��f��0\�����\�%b#ܿ�z.�|r�k}��\Y���o�n�7���"�����"����r��j�.m��'�M��ٷ끇RY������x�ڂ7�5F�O�:���uD&r�
+wQ��E@Ũx;�|�p�:��8:D�S^c�=�g]Q�`�D��)k��o,�N�{b��y!�br����=f(r�̼>LB�̯mql����e�&�]V}�2_�[���2�n0�kP��|<������"����&��xuH���=1C�6|������x���i	�� *wN@��9�"M�3��@�Ff�Dj�nM��;_&�=O�]@�ã-�3&p	2賆�f��bκ�&�#<ŭ��l�˚�N�������L��{w���>����+��	b�y>���j�6���c�¥�=v�M L>ą����4�i�Z��<�$����ŴYɊu���o�<i��v����y�q���O��FÜ�Ī7�9�9��mb9D�Z��?Jv�7�&(���	R|�;�H������k����'���!����'z��<r��������|r6��x:��&P��eI,8&넹�'�؛��;C4Y7f�>��_�Pd�[��G��~N[��u�9�[�N�����������_������������<�뜏�+e��C?���?������S���B!�I��|N�''u��'��������c6n��?���=���mw���Yc8a2�"&���P[�pYuAo�%���+ԣ���ip6~`�NlK���I\��GW�n�٠�b80��~���[:x�ـOWt0��~#�_���t��l��Sy�v���̳�w�����K�1w��:��ic��Z(5��p���ę]�^.ew���3Ʃ��0�`�2��y�����=�9@,{�Q�P+g?�*�?Ml�I�l�/�dY�W�n'���uZ�}��'�qrA�ϟZ���Y�<���L�Ϟ����h5�)�I�WW~Y�?�������?h�8���+�W>���l*9ɮ)�V?�A�#�����@ ��qb���woBB���u5��J��^V��,�|b��l�F���Wt�)�`H���x�9^���B&N�YR�'\m��Cݴ%׸�oV��~`�d���,�R�1���z�0�qyֹ5��>F�|j2��A�Z���k���k���|j�aT�+�6���V�l��R}s]�q��q����Gˆ�ǿ8��Z��Zc\�Ԋ��$��,��h�94O�|���aǎ�ھNj�0ϴ��E�?|��$�C�(D�{n|�=���7�)�kZc�8�ʎ�V�fr+��p;���o����������o����[�ÏP(^~���K�齇��K>��}{i�
+<Z���{���u����t����W��I��7�	\�=T���_���+��'7�\��9�nov�i���=c�D<�\�����n�Ч�k�+�q���z���3��V|�k_���ҟf����'h䷻�ܭ�u>w���U��J��?p�ƻ�t�f�7[U��G�B���7��{�����}b&L��p4D�V��ɖ�9����OȲA�
+@�S�?I�v3�7+������]c����W��ߢ���Qi����C	��D����̻��?P_�tm��*+ �=���A�Z�>�C5�=��(��q3�X�Ӎ����E��]��7�o�x<�AB����k`�ѧB�v��6��r���+�8�-<?D���r0���9N��a���p�8�`�3gəK�3�8C�r�A/���S��+�':蛽�R!���������o�� �f��'s^�?���J3X�݋�m�E�o� �����s�ݛ�2��.γ��8��n@�|��Lxc�Xd�Ѿ�O���`T�d��������t`x�
+�Wf�����{fň�P��O}�u��
+eb7�c�4R��߅�7��ԩA:^�F�P ��Ff��p���ҵ�T��ں�6�f}>�1�-+���:��z̭�|l2߇?":s~D�s)<�����V2��,�]5&�9��[A�J��!�N�"C�x�ʋ�_jد�[r�����X*G��r3׼b�:�f�3�X�{�O��IL`�o����V�,���n�A� ��A����.�%��Լk`��R�6��Ƨ:ض���	4z0�A�95�a��0{�$t���.2pm7�:1+\+�sB�1����l��=�	G*�e��<lq�G�Z�T���!��$�\"��,\5��9�{�-�v�s3v�#���6>�f�ge{�L_�@�8[-����QO���f��?%u�c`��!��Z�<H�(輇XM�h�z�抵n~%#%�z�#Vp�ub�>����^~�aݵ�?l��x��1s��%����=�kE?��K����<t0Mn+g�~`���岌m���>q ��g���ɺ"�i�`ڣ�U�.�}_v��>�ۚ~�1��K~8%��^kӪ��C��=���+Fs�����D��7�8���ᒎs5�1J��g��m���d�����J}�?���{W��	2�̃���&q\��r��[�l8�������r�Ib�(�����x����T�.=��?��145u�t���o�Q��Sy�P[z^j�֘Z�GV;�\Oj�B�fR��O�l�y���΃6�AEZ[j�s���j>�"�e��bȈ����4x��y��7�0C<����_���7��^�����r���Uc�i����R�G��������`*еFN3fw������~���/��=��|��wݺ����Pyw&����vr|�K��_y�=zL�X���[{0�(r)�p.�1d�Pݹxڧ7\��y�Ѝ@.ɂ�����H6��7��[.L����{�;�#q���3��������=��Q�F$��h?�u���ʧ�W=L'�
+��fi�+�wWKP����{~�t�­una�N�wN`���[I���17���G�S�W˫�xo!s�*X{�t����cF�E�V;��rn��K���-���q3�h�{�3'�ca��~�����Y��?$����.�����y<+U���_��M��A��%�
+��.x�*�3�#��|��*�u���}q���{���/��o�{�zֳ�m���p_ n����w�rsH�\��b��G���\@���*e���I��u8q`Z�+\�&������-/9��������(��me�#��m��1U�.���Q��=�K}�3<	�������17^3S�h�����ko�0�������׃�$O3�^3��+���^+����3��4�߱X\'��E�k��(z������<L<�;�XhXl��Ք���ډ��s{v#�¸�wx���)����` 
+�.�t��=:�œ+r[��c8�T"L�eZ����ަ�>��?<��������zѠ*�6��s3bdZ�����o|5bu6}/�:e~������t�z��8^����v���-����T�ַ�����������P(^��/���{�K�T�a����V�إ�@���C�/vٌ����_��W}�}�]�s�;��Íw3��O�E������3�OBsa�\���"�ᴈ\@�r#�*,+���a/��w����{���Y޷g<'����0�1��M�	����(!RQ��QӨD!�A���H���*�!m�*M��i�8J*��RY�Ƅ��&��	6�bS۱S��=|�����k=�}��flL���}ϳ�u����s|߽w�Spk O�7+B,'��+��0�A�����S,��r�ȍ] ����XMϧ���y@J1dD0��RI��u��IrS*�i�_�{�	��z��:��j)yk=s,P��ѓ�W��<��x��O#o7���9�9&�E�c�l�'΅#��fh�KzP�]l�/�vl$���:�q����|ꔗTH4/���d���(H;P�&y��}����{��d�f��cǒh�C�J�ak\la�k�v�=��������Y���.;
+��
+�X�,c,�C	�1H�|�f����<Nl���_K�"�-8����k��Pq�#�'�_^��\D��6��6��T�3Љ�A^��;�	uK+o������z�k^��O��QƮ�Y���{}i�
+|�*p�%���R^��*��J�зڸz�o/|���G����������R{��N�N��G����˱�2��o��c=�?��,ܜ�9���FJ�R*_�Мu�Ǧ�/�2��į���p��yF�7��6�ÈdBt���m.��s4dۈ��8�M�=�YX�����L$7��?[���|R�d�F.���0�2Z"���ˈ��SA	�b��㕄�u�3Na�^8�{�W1�_�`�<��/m��3Aő��7�zp��|&�Hő<��pD+�ޖadE�"�ћk���2���FU��f�8���+�z�ŗɌ�d0]K�k�7b����l��E?�GN�!\c��*Pļ��/1�1��c��޴��!����� �z�Lv�1־j�x%��EOϾ���������|��H��������u��D�^��R0+��%�����̘y�y4n��_������5�0�`b�s�����6�-kyt�ȵ� ~���������xY##���?o��L�F/�D��X�s����Z�?Ur�95�9��l|���q�\��p�>?M@c�t�9��kA<�Y~��(�e�1�|N���EL@+�����~��:��lTMklM�o�;.����?=���+�E�o+}TСL���BS�U�2����	�b��bP�
+����=�����DKX�#��M�EF�����%�|b�|en����\!E+��s��.T�^���k,H����Ws���M�d�z2��~f�Q�7���xƗ.7�=v�3/�c�^C�C>��5�袓#��
+~�N��K{d���J���C�A�SĆf���w$�O�g<� /��`�,0�k�)�kr<���:r�'��d('���*+�nv6z�C	�8��=���1O�-��Tt�ʅ���]D'�X���0C��Z#��k��_�j#�9H���4܈0�q^t��[LQk&��� �-�Dv����.&��T�1������*�o`�?��Z�%:�U��n����p�+4��=��#��������<�D�sr`ܓ�N���X�;��I�\����?��W�׍{�Ս/�/1�@�qqt\&,�X��G�_S>����z.�"O�ʽ7��Sy��	u�R�r�g�3������^'�'��MΩ�APH2�4��:>�O-hG^�(7�V��Q$��&>u+��x��z�ܼ"w��E�v0v�c�����$'�`��+�p2`�t��,�G��Z�Ln1�_q05�h�d�6��};ND���C�����������=�X��Vi��i��I��I�\~í�q��۾����{��lnh���FB���MC����.��*�#󳂸_*�*�k��C�o������?�c?�����ݞ�����|�O�;]����9���8�לO���_�8����N�[���[:\8�̐�҃�F4�.�\А�"hA�
+;�A�\CM�F�Þ��*�e�@�H�{蘊�E�0�7{�bh�7� ��ޤ{Xk뵃�cEvS(����k���\�t8y�p�(S0�H4�c��b����a��+ګ��p�x�#��v5��N�������R��Ň0�����{hh�\0�Y������\/�.S^�$��HR��\/��"J�kppD%�*+�u�y?�r��>;t����b���?
+!:ਁ3���R�hX�9o��$N���"������*��?��X!�@<�nĖ�٧M�p+8�`�8m�<0$gMY5R*�lG��0�	 �\CI����gV(+�ANs���'�Ҙ�ѵ=)E[�"�R�<o�M��!k{�ʋ��	��m�'Npcŉar���*�_���^)�K��\�o�K'x��b��ܦ&�����$",��^j����IZ�U�b]J�.X~��|��oQ� �=m����pl�Zv?�t��ʝ<���>�!�[-��V������z/����'����8֤�A��o�c�^��Z���@#�Z*`
+n��4��C��ب�U���dK��@�'6P4Ne|N�V|g=;�4��$b��̎G��/��{��a̖�W�[����3���Z{)ܴ���c�x�uD�*z����-)���n.�޶
+�咫�\-�zl��z���+\��s�T��/�+��_(��p����t��'����ň���!���?
+�S�y?���MΞ�|f���*�<Pぽgf�c̏����Nw|�9%jR�]	�O��I�1x����#7Ot,��7���_��{��'Z�ƥ�<1��Ϸ#z�<�:�W*7�����^�W�zg��u���g-�Z�^���?�+�ڍl�^�׵k�	E!4Y��-�:3=Zk|*���S��(��&���yx,�N��8Y>��"?֪��?�;�2����Y�?����[�.ŉLHb�+,;��:E+�;�)����k�����o��_��_��&����m;�+��
+<�
+\ѓ*�E��
+t�=t7_?5�߷����g��W~�W��3���?t�b���kO���x�J��zS�[+���g���/�q%m�nާ@����)�ik���А�xy�a�i��1���̼�)��U�jէz����x�S��[�b�ȳ���_�ɱ�I#���>��q	��q�3�]��GF���o���M�HM2:^͙��U���A,���Ѷ��?����ɰZ~�`�m�M�F�dt�?'c�2	�sA֫�9�Ϭ��7�J��Fh�ߎ%�o���q�����DJ!��0ՙ9���YV+re�%�a�u�p�&<<�/&�75��4��pRH�V�r�P��GnۃK�k��?tt{s&��C�;/�1�x��+���@�����K��C���IM+ş,/��!���,�k�}S�\v��&��& �?b�����T+S1�>��'�'��/�aG���5�؋���Am�Yy�,c9�R=�����/\�qk<&�:(��×_ϕ�N-z��\��nĨFTݯ�FfѶ+��J���d�d��M�%I��%F��Ǖm���'>�c;�X��ۈy�@���_�WO���`��^sa'�/�s=&��ﰽ�E�_��IԒ���F��=<�J���N�-���0�	C�?p&s��A�{�d�.���e{�{���}J\ǣ�"�M����R��5�p���ε�J�6<��Y._�.�ޗ�V����=��p�D��acZǄ˿���𰀤L1�	�/��6�D^���8?�m�E/�U|��g���{����W���{���Q_+�����>o��G���S��'~������::���_B��4���'�r�����+�L��o>}�UD�:k�Q��[CH=j\F�Cu�.L]��g���Vϰ6�i�գ�kz�C������U����AA��I ����+~dvlE$0��+u�pXw�sk����+�|�-����:����9���u��۽1�뗝qᘬg�����||��mY�CF��0vY�x��I�rJ�d�4�TPF�0��U�X:c�'�1?�?�D�����\[�u�zQ1����0�#k"+4����
+3^�Ip�bE#��n���t���A� &�nя(v��{/�I֝v���YkA�>��>���gl�������b�Y�C�?")[�|��ԼGZ�p�������p�	m|�8+�~S�@�n����<�uL^F?	ο8�Gy�b�G?�S?�!E���DF%]���\D�
+�u.��KuQ�*�uCNsꆷ��l_������G~�G^w����Ɵ��ߨ��;]�z�x�A������"h.�\L�ז��Z<�Ց�\
+��;0P�.x�ŏ&����/%F�VkX{T��M27I���$L�`$��#Gblz��i��CI�v/�DzХ���_��U�x���Z�����V��M�n�<�fD���{;r^];�_-����dlC���g�����_�W�j^�|�!�3w��r1�NlNv���,�\�צ� ��M��q�����M���K�#�&�+\�[�tRGj1�N�2̧���U�d�T{�t���Y�e��S����]��G���<��n���,)ouKH���Ċ�i�b����:e��ʎ��yy�G�Y��AǮ�"��\=.�����-n�]礞����/��͈�R�kZ�ra��j��{<^��ڈ]c���W��Y6:�5~�lK����"�S�����ӂ����O2ϊD���4V�b'��!ƽ�e CO]�rA�T�Zjә���/�IαQݔ���<���������Ә\'��S�h�3W�u��>�J����8$9*6@6WHմk�|[�!��h�5,G����%�u�æ�sz������4�>��x�&���"�Du�y�����SUQ�k�Q"n0c�%"ھG�2�yy���4�j�9�;�%x/��3W��c����9j~ƚur��Y�k<>��c�������o~�U�G�1U�Hz�4�Nkxi�
+�]�л;�֥�@���Cw�A�~���֗�g���~���������Y���8��W3�js%�2LL���-־-��9��m
+~���>~�����i�fז`�bx&�^��4�7Zc{HF�
+����%D�,�ӹ��/W+�+&\�]3����m��6����(a��W�����������/c���|�G�;����wk�7J1��F����M�Td��]ڥ��+jҒ��+�Ժ�f��uA�Ӯ���/��Z/�u����iׅf;�kt	+��Z��CG#b��Y�M$ղf���MP�V{���̲�O���?�9V�qr�7E���x����~��O}���1ꛤ���w����`JRz��?�o|<Kٔ��#�9R!��e�=�v��q��b�����9p���k�5`#���y�r1�����O�.>����z�[�Z0>�W*E������{����\�(�-��#�3BƆɽ��S����^���4�SŰӕ�v��ϝ����<�9���?��?�g��"m�c;�$.%��q�����T���F�ºT ��e?��tOR������w��k��[���M��A���ʜ0���Y��{���8�	�z��Ϟ�Y_��}|ʱJ5��K]/nV	��u� 6��#�\�<�=�4.s���<��g|�^+Bo~���c/`M��ٍh<�t҇��wG<��&�o��xdر��X��WO��c����v�7(�B�^J0����µ�Op�H�Nɮ��=;��M��Y퓁T����a���N�!Z��f��!�p���msT�������ghs �'/�����tL��`�@G�眸V+M�=@����E�����z��}�^=K=���b��׆�kʷ�ap�=7=M/��Ob���h��a�'�bc�зh��Ϊ�ll�yOP�0�)&� P�c:��}i{���b=z�}�+pގ"�K.�K�d./+�}Jя��'�Ş5��H�D��z���qN��a1��
+��|W��9�X�l��h��8�b��<k�c��.�t��|l���ǉ�q$�D�^�v��#|9�����ⲽF0����o\ ��Gi���=�c��oD�n�����3J�e�6s���z��xI.Ĕ�0�M��2n������5��_�U_�M����-oy�Gd��8]e�1��۳��M�B^*pZ��B9��et}�N��w�����K_��G����塇����tB��S����q8�V�\Ƹ2������?�q��'|�C���}F]�{�m����Թ:XY,{EO<�|������ظS0N~��hܼ`��v���#8�Y.�KƟ�w�ǫ-���N\�f@0��v�6����r���4��|�ڿ�iP��8ܸ�;�ŭ�zM2,�eC�����e@u$������������3�y`;l�f�W疺9ݡEp�̧m�Y7R�9<(nɉ3��Mͧ�v��>��%l����_��t�9�IE��kx�cjbC��[�ahP�꫷��O-p���M="�sI��_{�9l��9;�N(Q�P�(Ă�=lm�i�y���w'��Do��c7]��Gg�!��=G�����36�F;���D.�b�w�+_&�:�^�P73��`:7���{��d�8T�s�]ߙJ>������al��<�f~\/��d����C��j��y�5���\;��3}a`@�i��kG�J\��	�l�7���wŶ֔��������C7��w:�&�#��E'�s����:��N��d3�1����ґ>5G�5>�	Z�}�\?<h-�9��C��<�:����.�c�5�\��d�'��=��C�/��f��|�?!E���m���;���S�訣���Λ��u}�A��Ǿi��trxf���?���_�[���`���~��7>�ѫO��'�>u㱫�}J~��W�=�iW��z������ЃW���W�������wc5䊑щ�W�	�ŀ���z�KL�s>v���i�nD�ĺ���1��ji�b�^շ4��V�i�8�u�h=�vN
+]?��<m��o�<D��W.�4���zx����+�c����v�`������o�y�/��192�9��t�́@��Ays����As�oa����K\�#�9펺x��9�z��p�@��,^c����4�[8췬�#\0s��mF�+ܲ]��4WUx��۳��{��~�w�ߖ����	Q:�mw�?�����;׿��ퟺ��W�SX\O�N�f?�i�B�.Z��@<��ыO.�9G�ɥ�K�a�k�{�<H ͗�0e+�qI���O�L9Er�8����k�����3�o��>��Զ(����Q{��Okf]�B�V�4��-��x�	o�+�+w��}$Ǽ���5l|[9&�����C�qvmQ��a1���;�u���_ӧ���
+~�>�yW�������+���|@�V��E��g?���to��9�{��w����R�a�[��c�n ���ͱ�|����DJ��U��qTf6��������W+hqY�!�cs�v�Ə����/vle�${�2?ntP�s�zCr�����P�&Q�Y;]��~�r�S����qԁ]�1~�x�LF"�l"?o�s��+�J��>}7���^��׽�5�y�����c:as�Wk���YO�;훽3]�Ţ�N���y����>s������W��'��b�4F�qCL�`��|��XT�|�Ut����s�a��>���>��S��>}�C��/N�ǻ�� ���!��CK�w�z5.�?5��un|jg�tS���;<����5�M��������ጟa�'��+G��@����ϙ�3/��P��_�<k!�@ҫ<�ȩ�����ؘ�~��$6�Y3	W��`5��8l�G"�����$�q���'T��~�}(�a���2��ȼ����أ皏�%�/����P`��|>!�b���` $/�o�H�(>��4��Y�͠����K��=�����?O?���.�3Q;%c�ү��W�G����z���ۡ�v��z���|\os'�O<��/��/�]n�z�?��i}���5�yH�fxT�ߥG�2w�гE#k�� =��?5hp���
+�Ӡ�[�%�o����8��=k��9�>@��@m�;~�ϲ�C.¥�"~_��S5v��}BA#�����4���N��46[��)��F�
+�4���ă�U��|F���G�+HGYL.�i�q����s߂?��`�]l��.���pil������X���V�}��������`0g�VV(�}�i`s�Ԭ{T�o�z�z�#G=C�8�j��v�ϕ��(8E�\+on��������K�%����_|��M��O�]���h�ɌV!b?�|�ֱ6R�F�)��J����
+r��M�+?ڳ�%6V@w:?�V�����܄�'��-tw㬾`F�08�oT��YO\݁���'����������M1/�A�up�q��-^�7?������z��>�W?��?q���`Ku�tR76k���]Rw�����o���W�����<����?����7ǎ-h�\�k��Jk��T9�َ��\s(ϻ�|̂<O>���[�.��K'_������$6�����!2�Ů���
+'�T]���ٜӱ�B����7\�6:�v�g������"��J��|\�2�=�&{c۶#��}' Zq�;�[�1����󬯑�#�[�.g���G,�gM5��:��Q-����uy(E�Vg;̉[��F����Dv������dTkd��fq=G]���O��@?�@�:ۙ����c�7Z�jc=�Y�~�kj0Eǯ5��v;��鬒`s�C�x�����%�3�x���Q�?��5�O�U������S��~���v=��B�o=�������S8��k���+�*��G�9M0�)܌WO��S�T�殿�`�%��Z�X5�^�y�?�F�G�C_��ci{]8��}�i~����Zb�Zv
+���{��O�~�.�D�С���V��Kb�?�ֵ�� ͷ،�Jr�wmE���X��ۣ�5l��
+8:ϒ����}̕�hL�]#{r;��y���?��_�_�݊��զT��+�\|��B�o�x��P��T0�傒OM4�U�2n
+zq�P[_�7샃���@�@
+>7�H{}Ų�#ޕ�?Q�DC�v�������~3���9���חD�3���6N���r�O����U�!HH\���a���?��s��i!l��/2��(Qp}A��/���a�&�L�e�ه���>@������,q�f�"̢�&j�!T��똇���e��-����[��K��HS�l�u�_�d�nU��$���8����ȱ%GBp識�'mr�]e�=�}CI>�q�8l[{��^�b,Pդ��_x�����7^�s�7�DK��ћ�z�4z���PL�e����D`~�o�=���W���O@�_�_�i�.[}K�!��Q͵���Z1?t�d������Z�8װ����V�Xx��6�S��p���4'C7Vp�yć�����3X��PE�ֿx�K�k�:ϋ[�|K��������~i�E��鉗��EғRRH^�m�"�\3�
+L�$�Em�S��ƍ�<[ΐ�s���3�6��w�M�"ݐ�S�\�~9b=4lk�NU؍��]�\�`��_�T/�`s44h�8t*���6�>�1f�A�.(�a�5�:[�P^'���'�a����F�~�p����r8�`~��F�o9C���5�k�`�ьOC�"}�D�2<Y�>	���o�t�ݸ\���ZW�~�3;�|R9����'�K[[��޽}>�/��/��7n�ԛ���O~?u��U�kd��$��م������mF�Z>]{�Ɲ�yϽ*��_���mo{��Лɯ���'����4��D�u}��m��?�\8���2O�q%^�%�::��a���'O�s��57w�����G�x�oM�Z7��4�\K��%v"�GSy�����Q�(�hr#0��r3*E�g� �ɫ��Q��g�qX}�G�#�:�2��:�o��O� �m��;��K����������UOV�b/�r2`���k���(ҧ��G��9Uo{�.�ѧ�X����σ���fƐ��Z�mb��Gnx�P���9�.6ˁ4K~a!k�:�2��<��`�ZK׷lR���Շp�kP�/��VqĀVm��Z�!2��Cz��Nn�;U�M@c�����l�=�-��ײ�z\$�'���_���S�q���{?�SW���o[u2�$�{�tN=�|�Q��\���a�����Jڽ�%/�����?q����itC �y@�]��OLax������4���4��u)Bȿq�d]�Z�L���a����r���nQ��f蜄��_�^�����[]F�.�Ծ��I@�b�Z�^��E)�S�9'`�c����2�S��I*�z3x��q�\��$���jV{�i��_�sC[��Y�x�몉S�QX#`2-�=�O�z]��2��9��0���bM�]��M�2�)u�=mz���`�re��e�y''t�s�~���S�ɿ�v�Sn+�}ׯsK`54^��ب����د�G,Mcԫk�mg7^�c �W�/��1�t?$q�|����w�}��_|ի^��~�x�l��]t>¢�+��-^}b�%N����O��3r��[�K���e+�Ą5���0O�BH�ґ�����S�Tw�%I��o�s�t�)i��'@��~��0�'����0Qj��QB�1�5;�]K�Ӱ������YY�ںg�͇�F�Wt�y�ѱ�^�q}��yt��hQDi�x�X7�E}�,��6�����]�c���񧆝�=W���_�o��]�翻��6�<������<��[~�~�?xC[�Ū�B_ڥ�V���ڲ|�0{��{h����Ϸ/҃�W~��}�_ӟ�{�g[-��q�{B)�:�z�<��=���\�uYQ+h��W������G���eA���-�{��������_~��?"{�+�e�L�d��2�+���]��a^�
+t�w
+߃��~y(����p�[�����f���t۰0������N��{��>����p��cw;J�.JR�v�����u��˟����ys_����A���	e��U���+7��A0+��+���<���n������7�jrm\�=�v�I��*��o�h��'q�B~��������Ϲ�WFX���|dλ��5�5��K�$ܱR'z�MA�,���1EM~����˫�}���۱���zmBic�WҜu��FQo����׀�$��:x��� ����C����_��H�{\��
+x��y��F��_��_����{�_�S�ޘ�;ߺ�2�}C�YZ����GW�nW�XЋ��i���ǹq�?�J|g��#��Q=�}v�{D0��d�n���=^=�-nY��nh~Q���7�-���wl�!҈!D��`^�P��}�9�m3��Z�xP��7)�<�F�ĉ2J���$Ճ�e��6r���o?@�g��T@b��C/j��g]�����ņb��$Mg%IwI�m�%}9&��8��C�?r�4����	�Lz5�'�,Q�oXNZ&�=�?��p�����AK�хIn��Ͼ�G-�̏��[���$�V|׿䅴Z�k�r3>µ�� �-��og��l�i#��ct&}��Z@��I�%��Ù� 0�"�Q6�Os�+[����'��2�xl<|�<���}�+<^�ߩ��>����N�������Od�������t�EN4a�(�qËV���Ty����X��㸓�|�����_3c栴w�/wN_����+Ͻ�gG:6*�M���F�Zy��}��}�w�w��ڀ��:�/�l���M��)���쟎�X�����G����ӭA�cgs���DPs��R:i�A�qS����z��ǘK�� 
+7����Ӱ�CO�mB�P�p�ы���D��'���rƷy`���Ж���
+��e,}�s��{ק��AF �Q�<ED���,~6#�y���s6�����Di��.���[y���_��U�|�}Td�o"��n���3����S?<���!8���ȣ�FCE�o~�[}����&(�zh�^�Y���"�֍=��q�Y$�ѡP>ki:���
+?hb�ÕK�1=Ï�1�E����y��3�%�1O����������#���������Jc��ג�|tl��`և�����x�*1j�T�5/E)6�4܎��?����_��������� �N�oX;8�Î��V��Y'�+�s^�H�iK��+�]i�㶜�����]��S�fƿ���$U#Qu��������bF���Y��^z�a�]�;����Cc��d���b����*�rb$(t�a���u��&�J��H&o�zm���@��}v�������X�������/����������C���j�-��� R��\��H���s~������	�O	P^�Co���^�������^��&����\.�`������~Jt�w�x;�[Jٛ�oTx�l��=�Ǌ��4
+V��b�%���Ź�hul߽��+!���5f����-�£��|��jQ��Kl�\/�q���|��+O2�E�4`��\yxcՏ�eU��?Z�KS��2|i$���ߔ@O�<������8�𑃾��B'WB�g^��K]�rȱ~\p��|2O^����w�̩�8�aԠ��Y�	�(�Փ�ױ�R�̧�c�X9'��ʷe�����2�������z��H|��v$��w1L"$�7\k�&�"11��gL2Q�B��$82+���;���d����ON��_z,�q�|�����W�C[���PZ�R�R/0�0�e�j���\.8�/9����%�c�=v��_~�{���J��F|��E|p�ו��E`k��\����-��t�倳=�PS{�?����#BƵ������$��U�o�W�����=/��G�x�WS��r}U��qp+��<�F'�~:B/�%��d�q&�]����W��3��+p��3��q�o�.��2���5�=�+�^/��q��S6�n���c������4�7]���l˸��D"�т�T�&��ё���>����/S�}d0YKpO�gb7
+x��v�J���M��%ytV�q�.�I$�8�\,[N�:��ݐ��H��T%p��2:d�����bZ��s�g����Dh�,�+_��;d6]>���	>Mx.��`qX�5�����V��0W��E�.u"-���f?�Z)?��A0�X3ӈ�Cm��N�:�5	{�%@J4��z�<s�d�;1��Q�;#Po0��";�\IU�df+�+�O|&����_԰kmv���l�/�c�Ĥ�V������W?��o��_��5��z=e�����l�{���,�+�h��C�?�h����CJ��S�����P|�x�57��:-Nzol���qȿ�s'u�D����U*n���FL7x��<�Þ?Ȍ��u���76��(\+��j�9�$�x��eG��#��~�XQ�%@��ID��t�`f]�Í�{H>�=l&����}D/<�����sb4�ȉd�����U���Փ�*�"�Qx��+w0�&M`x�6����qḍf��=�ņN#��GP{u�,��$���=yI˧�:h�\Li(;AtI���ׇׄlU ��M�6QL�漣��A*������d�+�y�k���?��o�������Q��`+tHG�bz�~���
+��?��ӏ��O�+C��`�\�nd�^��uz��^w�k�kO/���OM5��2&dngQ�x��ӻ~睧������I�v��;��y����_����*�+{%����� 8d*������
+
+�A���ڸ$������Y\j���w��`�b�Me˖�1�3�d����T�ん:�1r����?���v���|d�bY����a��W�4<��o����ŧ�����/�+�Cr��uE�ы�W-�Cp�Ow�8}c�����qH����{���Y+�
+\��J�d��h����vmYy(�z�w|�w|�����NյnVН���.���)�1v���|D��;�M���Rtg�+N2��B=I���e��'��ٌ���Б��;�>��1
+@s�IaE�C��jb�*7~"����p�������C>1��X/�䰰XgmS`�T�G������?�������0��ag
+N�,Rg_�
+��&:���}���2�בGc�{�ԗ+����u�_�eT0��P	�[/�m7����������~���?	/�(#�3���1n�`lq��G�]-"���<�m1�4���TƟOM�?�����QQ�҄"�nj������@]�!G7+<���l�{\����r��F����׽�e��m��_��YAw�����r�Lj���������[N�hc��Dy�X�+6����ϥӗ����ښ�������V:����uo�:c�7Vωuµ0�fd�����w�_��_��4pwj�ܝ3c��`���Wy(�j�|��	��~��~�!C�E7b����&������{���L��=X:
+yV�Ԃ\��C�e�8w-tn����c{a��4r�s񝤜��[�e�y&��X	fYj��'Lƈ>�"N+(A\+�L^l?2J�׿<e�?�).Rs�z�vȼ�n�|[�J?���$ L�����b[�J��+R>��7�����y�T��`I�F�Mdj����`��v��K��{����+��9�i�U��j�5<�d$:���!sb�5
+T���շ��<����:8���{n��d�X�d��f]�'6�'lZj�ZC�ʃKlp�EKG�*n?bY�8�6�'GP���/�<��Pk��6�A[����+8y��k���x���/���JtM�S���mop鮻�o�
+\�p�N��H����_��=��������}�E�������x���#����q~�HZhH,�Mp�"�ekĖ��ޠ$<z�m���!iLz�T���rT+���lnR{�s�?��sC�1���6׹2ԡ�s)�Q�:3ִ�#���O-�U 74����y߭��$d��J,\��}�H��(�>F����t�]j������XX��Ŷ�v�A~ٖ*O׶����Y"bŧ����bL�W�
+V9��_<�y��7�-zx���[:'D#^��V�m���Vٟp�:�^�r�o�xS���`��g��M��-�4F�j��
+��ѵ��5f�u\r���P|�C�+>ۃr@"�$�z@�
+����i�'��_����e��匙��:xd<���O��*�A��G��2�+�94�5+�՚>�n?�6:r�T����f�f�����>�S���e�t���t`�q��G��8��%�A���z�Q��8��dS��<�:J���Sc����>|aW�����z�\<��Ӿ.R�q₥�pF��]���W�����.�MR$FJ:3������������a&?�=W+��/|��Gx�R��J}u�ch�O�c�g�bb�s�c̸���A	��4燰��Ϛj�܃Eë�ĵ#��#�^
+�gN�г'Ϡ7j�C��_����e��;�j:h��<��C�1��ҽH�D���_vH5��j7u��v�W ;���e2s�}������=���o�l�7!x�J�єR��НGwQ�m�S|j���L?��q�� w1�uЎw�ݳl�����l������E�� �u���^N���Y��-v"5_$�RǼ�N��k߼�^uِ�k���/)��-g���fp��Eb��V���Ӷ��G�'�1�8����k(y.Ar��d��D�&y�"5]��g~|8���X�?,�����䓭:A�����[��]�����;�l�2�z�:�:$wiƣs��#��9#�4wP?7L
+Ļn�c@<���+��.�rbK�:F��
+Q�����Ŝ�XIC���^j�����Ҋg�e�Zu��h#���m���e���5��|m��Y���_���<4y�:����U�'��B&���	���aQ;��q�?:j�돎�����=/�[��8TV䇵��7*A��:��J��G@^i�q/�Oܫ7�9:A��/2�GiN��oA�&�Xm]7�8��ed�\ߕ�]�F����6J�V��`hrH.�"/7���H�Z��!�����Gf��N�aշ�aO��Q��7���8Մ6/�@L����`��VI��ce��j`w乏Аv�ŝ�f�=v�3H���M�b��^h��n��e E���Y�cm�P���qb�bo�j3���(|ꋚ\��r����ޢ�T�����������떎ڌ�5u�����V-lYf��1�T��*N�A&!�L��($a_Q'�f�#�>C|�m��Ndic��2�Տ�הŷ�>�����*���(���=F��j�bW���k
+��_F��Kv+��z���9�c/.Q	��R��u��wST���jϮ
+t���2���ٟ�ٿ{�w~%��ͤ�y�]m�є�t�-:���Bw����������=x�l��wK�ѭ�ھ��gn�xrS�@�A�[�����X�?�*ET�2�k&BN����������w��#ޤ��y�GN���5�8��(:�12g��?��<�2�mb�1��3PD�q�!'�L�j���}�0�R]��]$��3��-V���$~gmƉ�����I���\E`��8�����������ãb�p�!��3�E�O<�N�`������ë�V|��>$Q����\��r@�:!�q2q��?�JX�b��$���Β�<6�cF.���t��M&��(-�i�0�θ��<����tl"yK�Z㌗���:��#?1��%j �0���xP�><@�OZ����O~*���
+���r��YJ������x�c1��d|G|�pĘ�r�}˩-2N���.���?Tz5r���/{����?1+^����%��m�=?Y�~�`�`��Q��Y�Ғ�c�w=��a�ɥ�&[���
+8H��ML��"Ƒ����Ŀ�h�j8FF�Y���cc!1 +�{��·��K���_l��/�pӗ��?� W�U��~��XH��c��6O��������v�۰#}���QްЊ�0�1V�ך�E+�m���\t�ǲ�\�(������e�G���^L�Gm'��#�`��O�6�R.c���9����vd0.�Ҷ�4��qA�+�p��gO/����s(�R����K9À/Js�F`2��n�(~�����|�XU8wA9h����t���l>���i�lZ^��i \��?+ysFo���Y(K ��y�Y����[�(E����L^d��ս��RZ�ɺPH��U�+)��?��.>��I┷�1-�5�1'c�`�B��wg"�z��1Q����#":(��@��i�w|��G��V�x:��XP#�߮���(��}�d�OjR����o��㽓��O
+Ɇ�+�6��q�0�D���:a��&���q�W&��,V�O,4>��!��d[3t���[f8քc]��a�w�x��%�����5������o_/����%����23�������e�x�J�9w꺀z�q]{��F��~�������ާ�(V����+}t~XK].�|��	��N>>�9wV��%Dnr΍��?�1ca;�Ț�'�r#q�<�8�l(16�/�ʭ����X�1>�o^hfY;����	c�e �Vl��"N�\��F��@ǵ�Jӄu���'�ƨU)��g��g%�̣����vYSve���g�w_��c������>�	N�9�G�d�Jf��"�<�A��8c��Ӫg�����k*��H-����[�mI���X�I�2�Z$�1���H�Q�k��`��AX74\�3�D]	�_�(5�4�+҉!>o��sD�Ɠ�/{b�!'���������ۓz��p��S��Ьv�7@���i+D!�;��Љ���ֿ��aD�p3���y����/"iF���&�1Y�W'� |h��@��=3��PPM�::5�/��V1���P��F���V�T��}H)��Q������H�d5���O�~���4(+Y�w���ajYe�Y,�|P����'���miF�+!�3�2p]��#r�\��0��=as��Y��mH��%��;ꄵ���N��3Q͙_$�,�zQ�N^Bc+��@c����@�^+��ʀ�]�+���ּM%C����:����->�ǏV��.��6��̹�Н���T���?������o�_���<=�����c�D����Iث��mh��}�����n���Y��6c�;h'.����#$"o_���dy�1>j�l�0_L�a���|6[�|�K�`tĊ����D'��Ԭ�y�\�����C�����,�p���5D�j3�	%Y�^���gV&�ǂs��Y#^����l�����W��R��`�#Ŗ��\�:�R��S��r��u�	�FF<5��{��~�Vշ��.�%���˲_���xX�G0c[���+@�6������qB돵�w�K5XoPl�5�������m�hG���'����/ƈ>�-��_ʕGLcϪ��Ȋ�5<�s����<xFu6Ω�gFY�4�}��iu6��v��}�T�����&��`�Z��2�_Gw�R���{��j7s�ثv�U���~!��)�ۋ��o��o赯}�wu�`��;����>���;��V[�E6�L���Qve6G�Л9�[���	#;��x�+�ň�y��ͬ2�m����VAu�?��Øx^P�w�y�&>q���K�|&w2�S�!�ǞO��ݸ�#�t�+�į����z���+]���a$@d�9{��ty����lUW�%�=�:��⊛J�F?�7y��f� K����A�C~6�ߖN%��Nm�&+�q�#�����������RX_�F��+y��G<��!"���	L�j�4�6ꄎ�O���'ɽ!a�*4c	�ǢV3�e>���̈�(�w�5⿦����Z�|jԕ���:�s6���{d��{�jX��"W���I>�mۧ�:���':�92�-z�m�����m\bA���'����^$>�W�xVM=�PK��G.�u����L��̛�gM)+����	~�~�U��PG6��M��|�U�?j�*�����y�B��$t_����<3~�{�������,����A۷�j�O�������Vػ�1��r�~�*�y�"�w6R�o^�c`*���\�$l`6e��Y��IW#�)�m�����(%��#4��W�ܸ������ꄆ�i,z�i�O&���\���&:4��*B����$�3��H���b�~�m����ACt�@��Wu-����j�} ��@ 잮��A+Cۿr�ၸ���>�;�����9�DKk.P��ډ]i���&>�7�;v�P��f��d́�n����ur�\��_���E%'��纗�t��ع�`��7�H����AL�?�q��*%�ؔv:�*�n,�B#����#}�Y���C(��O�Vj���(v�Xŋ��s�l?��-�\!�D�
+��&��zƬ$@�'Ʈ��n'�b�/>�oz��{^��57-�/��X��/ߐ�01���Z73/�&�d]����F}�ꮴ.�7�@o4�&�-���.�>�_��Z�L}��Z���i��/|�/?�?���r��_�;v���HoR���y	�lYG~!*9����/�z���C��&�ݬ���{��|L��o�+���r>�������o}�[�]���oł|ƭ��|v�=z�ߴ����^�P3e`3��zk��7���+h��\��JR�]�����C�u�\�7�8�����}a�>����ؚv�GBh6�)sQ`ܨ�E��`��6#���F��h��b#�1v`�F"����4���e~$��f[���8��F�Zz�*���!2�t*��g�e�\>��+����~�1�T��:����N09�
+�!c;�
+��a�/+]�YO(Hնe"=����MY��˨��V�.�:S����~Ӕi�:����)w��!�ױ���x��������#��&��6(w����W_=l�R<~
+�7(���ϑv��8�_���u�D�/���7/�e��~u���}�oK���;�O~�s��W\�\��d��iT�q��Ny<�7��0�LX���ץ+�c,�yCB�� ͽʶ����Z�3���L_}C�e���@�㝮Ɓ)<+D��spf]&7��F7�`�0ֿD�P�x�Ɓ�u���e����?s�~�����k�Ĳ����S3�L�>�VsƘi�`�����>�UY�����5P�;^%Js�g~��+����:._���ê��>���Ï<�\ç�˭{ϑ���*0g|`���{�Z	+Z��,焚$�f������Q��&��5B�y�i	�$Bc�g�k�[�ڼ4���ze�o^�IA�Jr�:ŗ�������?yټ�|�@��+	�ȭ{4hps%5&>��"�i,�t�����3�f\�g�b3�l�R�L�҈^��ϰ��)����b����a	mܻ�H�m�7!)Ɩ�*����q"�J���)6�2zO��m<I�f|��T<�3��	�k����ղ��ë��E����ē�Q������g|�m��G�e��OO�.���i�/�V;��E�(����ҝ�>C�X�ud��$�g�κ�曯�����W}�@���`���0;8���
+x�y��yx�*0_dлG�t�I6ӗ��=�y�����NoݟN\޴�H?Ӈ�66�L��~}��ϋwReC͡�D{���<�������)�_����qc�6O8�8����F9c�_��?��V���'
+³A���8a(���M����Ǵ�l�;���9~�pތ�,���e��+:9R�B���5��"�>;��"��/�|8�Xs&?�q�?{�A�8PPlᓇ�n�����b���z��{��/Eĵ�NR��0���?j*E�5?��ˆ�6c�f�Tv�2���b�A��*&�sp5�MLpr�'
+4�eش-�%&��7�e��%ƘhL�\4)Z�gpԌ��H���NC��x�x��v��Z�zF���(�3��Oc�s/���1��Z+$�u-��3~��?Y�@"�;9~F�K��S�Cڸ7�^3�O��/�;z���I�����뉔<S�t�1>jC*������{��o��B�}��^�����7��ތk�8ن�3i���v{�[�d~>q����r��3O�1�n��I]���@�Ih��D�_�����Kɲ��P��|�6��-?(�+M�����l� �.��:��;��aU�k�O7*�o:����s����!",�@��2(�Kg@z����}ꔘ۔�����vf|nFh�e,�saG�Q�C1�M��#>>zR��@2��9-�m��#�9+�1g+
+�j^�a�먈�&�c)ձ����t\"I]��c�� hd�.1�N��j��j����=e~��<��c|�ʛ��ⷼ�-���]���t(����zo�p48�+�ey��T��\��9�W�.�����n�����7���k�����b�&I?Ӈ�?�_\�,OUۋW��[sl*�i�����&�ǭ��f��r�|�����Ço�+-z��E��ןk�-<+n�P`D��K�=^�L8��ħ���}�k˽��}m�}��.X�Lx�45�L�m_����W��>F^���61��!��d��������%|�:��B?��t��t˷}�zX����X��g?�\��W,?����4o�<�|���=�"���}7���x�R�I�C�bd/��\�r�״�0�OX�@��˱oT���
+3�cl� �34���?�,h�YnŎ7�h�ȨtR0�r�b�~B̵R5FO�ZВ��b[0D��z�B3��d�L��(�D�f��DWxF�bulv?��?����/{+G�]W0h�^R�Ƞ�w0@��(�d���%&ti��E:<c���Oэ>��T?��?�:��Q
+��m#z^���n
++(ȧ�E%�_�;z:��t%q;vb�̟�~� F�a<Üj�5�/*����稞�W�h춖���^�{�{>6�k��o�)��y��x���Od{�s��Go+��� e�|��u1�	X�M����xİ	�̈́k�'��G�6�h�M�/����{���	�\�Y���1p����g������ڣ�������W���V�"��+L��/�K��&^�r����מzr+�i�a7���l�`D�:��3�
+�޳�i�t���&ӵ�G�_�0���k�/��]O�kf���,���b�+P�����j���
+^�<O�p��~��u��3�|&dcw��k�Tس�C=��]w�����;�C��wDz2cs�q"74�v�U��+%�J��֬!U2hCt�gэ��L5������cļ��r��L����=$��w���������i^�3O�8��5¥إ�ѿ���O���ˮ�ry�%�mqi{j��-����oy����~V�H'}莽Q�!�s"��?�7���~�ˣz���W��Qۣ�'h������5��DN���uViY��s�B���	���X��*�e--��`u/�1���%�aP�-t��B�s�&�=/�}��@�`@�*�ly�Ƨl�0������ѭ�����q�3�=),2��������d���;�� 4�J]�/u�5���F�
+�fb�_a�SeՖu�U|ڮc�{��eh3a�G��h��A��C���g3�JM;WpM����ǦY�6+G�c.iR�A���D7kϲ���}��!:jv�-\X>�C��+f�&��v�k
+�A�|b�8���:���Rm����H�Z�`�q���j�F�q�?��wPn��Nc�n\�6�zo�LM����{��W���_��[�Pǔц6֞Sr���|W�hr��8����s�c��{�F��ox�������;v��cs�`���a�7����;ޮ�>��?k��G	_�hm1N�7�r��+ ����Bdj��M���7fr�lb��1岑1�l�������v~r؟���/nt���WP�c7$i��Q'!����v��R�M�`��;�RY�5��Y=P�M ���f�{1�yY!��U���4�u�hD�8�|8s����'��� ?Jd<�3���`5M?�_i�s}R��3�M��k_)���p��4=/���/�j��.X�n�����o�^}���5z|��|�ϖ}���O<^���m|��Ƿ�����?ka�w#�'����:��{�|K_<{�	�<Ya��8��X���:����!�/Va�kY;>8�4��R��$�5��j���>�v�y��W������v��5��K:��9��J���]g�Eg�[#l�����z[�ͺxrh�:5����89&��s����m�Bf���McC�̢��'k�[��}[��x�������a߃	:������ƺ����kǣm.�8����^�w'���LQ�M��E+���]D)7��&ф�Qo�`Q�,IE�E&?�t����d����GȄɼ�v=�ܰT+�ݼR�̞�����+ݦ�6N�ªEu��4L2����"�0ʲ�+c8js���ô���X=(�ѵ=ē���-w�u�r�=�DKl�	���Y{Y=m����o�����������r���\;���/^�;�?Ｇ	�Q�|��/.�gY�����n��q�?1�.��l�9���	��~��]��SϿ�Su�x�׏����s����H�'O�_^G}dB�d�HW��WV��gp�\j��d��pjҵ[���[�{��L;IĶQ��,�E���눞@���B(AE�	DE�A�{X����;���Ok{��ж�Э��8�P��g�X���X�U�>�	8�bk���}lV���+�A���6
+G�3�YQgVLG�d���u��l���/�/����������_���~�hn\�}��o��O%���O�*�����������-d�>��ǋ[u}�d��8�8�h�}A5i���������KOk�����VjE@�6�0�/��T��F~b�n��g���1��S=�K7��)�g�e�j&��_���;��0��"�ꇻ�Z0=�����k=͘��y�\v,�h5�Np�9y�k�y����i~���ؓ_��u�B� "��V�3���a4�X�--�e�bta�^���(ǳ>��1!ٶ	��وj�\t�k��)cuZ�
+�9QRg�p�NWa���X,�+�S��<���~7^s����;�s�q�l�Xp���>@�HWB�M^m?4m�'�ec�����Kl��'�8goX�լ'��]�ӎ�>��O�;�tL徯�u��X���:���&��z}����ܤ>�%GZ�G(vrzX�{��A��o3o��^�4��0���h��Vɲ���y�1���)��>*^B���F��"�Z*i8.�K���d�>l?T)�(8����k#	&,�|����s!Ѻ>����l���о��o\l���:� ��ԧ����sI��u�g_~&(=A9�z&���ɩ>pz%�G��9O����s�'�מ��]k�ǃ-u^�֮��|�T���z�����/~�~�#��M+n�U�"l�1��܃�b7Ǯ+�+T�.P���v��1��V
+��!�,,���y�'e���
+���:V\��?c���mǌ/�9���O�X�]!�t&��n�zDIr��g,�x��9O��8
+0�/�y]"�}~��Wk��t�<��^���K��[�`0�ʹ-�HuaKV�a�+�M[�:Z��lDXO~y�m�A's�R$�k����Σ������	�����].$�ԯ���:/�5�nj�
+�͓��N8������7�D&����K}R8��'��E�����d�[��
+��{{���6qw�7��m%�����+�)�{���sߜ�l�ԭ_E@�>�R�f�Z��&�z��m�n��t����\Za>G��y���t���s�����0���_�w�J� ���9�}�΀
+p<jgVz���=�.��s0�_�c?�c�mo{ۏ��E?_ܽq��)���Ǹi��nݓ�����[��ۅ2�+ٚ'���h6c6���-B���̋`~|s���?��gKo��|�in6J!�&0���������c��a�����m�������+ׁ���4.[�TqGn��;z��'��0D��bH#��ٜ�x5I(���w,�P&A^������l��j�e��G���ۼ��=�hw��](^7Rm�%i�1�(���QL�&{̖FCOo_)�@N�u��wtm�e>pŃ�1�i��Q��{�(}C�F3@IǎF4���0z5?XL�
+��+�Z����߱��Sk��`e��n�ɶ��_p�b����뺦�gat��`�����y�V�ُ,\��U��7L��q���X����1���������޷���/7�t�r��%y;k<-j���m'���z��sM|�:cӛ���U߶��"��e�K]��-7�M��5���׿����kٚWٖ��K4�Cm3�`Iƻ��5w����Ǩ����>���-��1q�~���GFk��s꾊}K������E�S?�fY���q�������4dt=7�)��	Z��+�̱u���
+�ݤ;���]�_�6��{�8ky�9ʻ����k�+�91S�r��xHN3
+��տ��O�$�X"�f�A�ɯi���+�^t:�o殨����C�k�mec�Ud��k9�1�Ohj�9��r,:�!)z���������~�j��3���lK��90������P��t�ն�tQ��C����<��:�P��3��$�-����SRu����\����JC�����F?%���+�pfMH��iKQx�8�M�b~�����ɟ|��~���O�O�������g�7�LϘ��/_�+�Zc�y�U J������4@��8���|�/�5=�{�)"�0�o}A�,/yɕ��_���෾�����p�>��|��T�v
+�����iH!�iF͈�V��M��^z�Ox���9�_x������^���nZ����/���`�W �`��}�]x$�J�2��E}�����_�z����n��l�P-�'��V��Vq������}�,2��^:k�^���Q���IS�*���K�Dd�-w�#��x�P��d�0K�ѭj�Xk�x�Æ��:���A�6E�t��0h�>S`���9��ړ�L�ɪ�?}$�;�֫1��ơW����X�l�@R����z��Nbn}�YX1#��)����m�q�Pk��7���ʾ�M�J�OSYI>�죕�����x�@�A�-���k(`�� `�M�Լ�����cjՅ�A1�l�u�bX\t����@2濟!(���Q<k�W�����Ǧ\Kst�E[ 3=�"��y��:���_�_1������;����)�}TW�0���X��7+c!�ZcE��s4�5|���6�&4�Z�^�D&��_��峟��+��M�����{�b��u�b���m��X;~t������e�_n���r�_�\p��W��}EK���(V3�&�r�S��
+�Ѻ7�@F_������ܳ|Ǎz+�Y��Ǿ�p)��ˏ���p��k�cd���&���_^x��>���n���~+��/�r���뗯���z衖���gf�t���ޯ�����91ߴs���)5>���eB2n��x^��T��p�9�5?׉��͡K�>����CQ�:=0��D�d�{������o�E�=�����1����E�6ۚ�h�5�zLz���h0|��OO|�膽A'A�Ƒl�C�m�z)f^�~�~ٌW���M�oe�����`�s����*��͝|x\��;VH�d��<�+��/{��>r�-��)�Gt�+*("Lc�:�m�k�ķ�Сu�Q���}�ؼ����{�h����%�D԰m�����j�\�J���<��g�j�V����l��6�9�*�z�mo�3cJ'/+0}�(.����fz�n���~���x��+���ů�VuޥZ��-�7���H����t��Ý�N���g~���C&�莏��;�ST9YVvxo��h��*}x�y檖�`c��7<7DL����<�[��W�F��m̑���V��h�~&�&�F�N�r�W(��u��
+��_|�\�㨳7p�ܓ���'��U�Ӥ�6'�E*�k�4�+T�3�^7+���>7U�K��I>��o�G�_������sc�����KZ��ݜv�c������sJ��M�Ӯx�K����G�:Z$M�}� \�~�]���r�������{��|:5�1���,7^󪒶D�x�O��/z$�A��
+�����T{�͐��<�Q{H%�5���2޸�4d�?�>�4��ےǴ��j5sĸ��H}��1�[Ҳ��B+_� �In���,k��5?��7��	1u����w�6��]���>�OI7� +F;'+�|��g�/�/��_����o�a��ͩ�u#�&�\�o����>v��5}�_�图ľ�'��]��ֻ��$;i�����Q@}�Q0mMnd�/5�y�F���F����CE�M�7F�0������7���Z���n�Ɲ�,���5h�����)Gu���׺R�
+pÏ���4%�O��F����3~y��_��	�Wj� ^ۚY)$ݡP�L,�	v��Ԥ�D�#W��A:~"[�+6�u�GEK�vz|�~���@<�L��|�Ԍ�1���п������{1��H
+����9�C�Z���Z��E\=�����տ�����F�s
+1v(��{�d��3��VM�y(��.Amf�\�G�C���1jڌb:�o��,�3�OȮ���?�߃���;g�4>hs��V��?z�Yx�#��n����t�;�������˹��O�bi�^�0�ø���/��p�r����6
+�V���~z���3�~Qo+ĸ٬�0��Tf|�Xs�2t8HF���n����Ej���M�
+̾ʏqg���[�ӷ4{��v��Ɯ؛�~F�2l���<�K:k�m+�a�k���m l��8�ú�٨�Fp�K��o�{g��Q��BM:�]S�{�N�j�=x���G�䚒�(�M�;��F�s�}a�ȷ�	�n�mC��j�+���mi��Y�֟v�	_9��H��)���;X�O�茦A�!;�h�B��)�m����N��x��@#��sW'�4�,}r��
+%�u���^"��V��j�r'�v�����^�h�ʑ�!�6�7/
+���n�{�6��Fw�2#걾Eg~��OV�7o����^D�����U��!lM��7%�54����xdm_�����H���W��sً�b�����[�%U�/{��i�C��<����F��m0t+,�@V�P���1ۃ��Ot-G��$9;z�7u��A���d��K����D|�Z�׸e��Dx�ݖ��d:V���`����W��M+(�Q{�*pT������г�7z>�����o��_�O�o����/���w�ٮ��|��T��Ԯ�G��76oZ��J�6�TC<�a�o���[E��\ݦ�֞���a��7�x!�M�_P��!�ί7���5(�9�V2��m�y�楸�G�2�\��X �9��acc����*�(:��9����'5A�\�C��࠘�V-6��Ď����^�}��&��m��зrx�I�_��|�S��J�4�J
+��������bB�2z�sV︋g�!�.}�];�h�P���u�N�i~W�cj~��Xy����vs��k�#^���L�מ�0�\�^��0ju�zn�+��D䰝��Oj5j`��\0��i�����(9/0+Q�i��Q����5��-�� ���z(��w�������r�~'>�ll��׵�JGX�\+�4��3c��]�}�����y�`��X�]ϻ���}���Z{��?<�������2�ǋ���,}^+;�q�6��2t�+f&��+gmKa��?8D�M�`�q�?2qA��i�=bI��w����� ?�eDC/�z��8����e�<M����:/��� 
+A���&�ږ7p6��R���@]n�z�Q�1a5�N��k��'q�z��G�uɈ���O�^ׁ���y��j�JC��0
+�Ҭ���3��_+��Y�rh?�\_�m$���4l<��$&�e�v?�0�(�3m�O�͉}.1��e��t�P��;f���r��"����nZ�a��x�E­���Qe7�Y��c�S�12�`O���ڍ��p�S�4�ء[z��iO�3N���~�����{�O~����4�������������k���?�����.���s�~�����6�S3���X)Y"xы_|z��H�{�⽓7���F�"o�O$b}�{�wzͷ��K�X�H�O��]���'f~��Vv��L���O�������95�5
+�1�|�n�i��+�켠�+�&#����+:���y�y^�X��-x:��!#����O(u�>���^�o0ǼF��K�o�׵�G�:�%�Ϋ���~���_��_z�x�w-u�ն�x�lun�OAn�)(�5.r�G+Y����s	���ڐ�۴�-��1[�j�`9�\g>B�:��߱%t�䞖��?���\��7x���RgY�`��+��6�	�s���{��}��	�X��
+����QW�"��@[��f!��?��O�z�oj�d��0�o=a���x�mЉ%D��n�����r��I�P8�W:�0�V{�Q+���Qł]�ċ^h��������S���q�����0e}d4��6s���w���ݸ��ѹ�ַ+�
+�ou8Լu���><����w������������J�q1^٬�w�8���<�u�������=�T�;rS9�<?@�$o��{c݅9^~_*�J�F��bv���J0�Q��yٖ=�i�ٮ�;��}����Bs&G�����+�R}
+<�rAZo���ɘ�����~�7�}�w|��*��^��<V�R.��p/����~��l�lȼ !%���T����xޙ��
+�X=�*63^4z�Ћ�l،��wp���m	���P�l�l��D	^@����x7�����A��?5FT�g�*#��Rc���!e/^�(`_�7-�d�O�f#	���y� z=��Tr�݋�M���Pǯ���G�i�;�@o^c/x��d����:�����`��|9��+{�����O�ҕ�FC���J�s��ދ�te?sC4��������S��G�ɶ�Az�����?����ox�/��:�¿=i���!2%��վ��
+�����~T�z���ܹ˃������;������7����lO���>w��ot�����s6U�r�t��_q��7�Ff���&�����΍�>�~e(�/�i�A^j,P�W����% jnXM����SF��iO�&��Q_��k�8��"l�������������&�E�4�ܼ8
+v��N>e�e|(�{�.s(���^�9xst��3�'��#m��o,+��g=���6h���>d���,B|�︪b?����1�`��`o�M���x��@���Ѡ���S�E����m����9uO;����;�������'d��&'�9��TL�FIB�+�Km�X�b����Ȝ��%��7~�����`,��8pត�M�(`zˇ�u,�7}�ם��?~�e���o|n¢���3RZpC5[e%�b���/�����q1�}4��S=��P*�9J÷��>��7���Tu�S�0���Y�o��Z������:o��G�+օ-���mS�DI,�?��]3��+<^̮g�T����u0��K�A��R�>FU\lPQs�	��{F���z��V�(�b�C���H��7��?�Ea0�	����䚚D�}!E��GQ'�E7"��o����Z��:ϛ)���ƶsj}%���m�����J�{����0;y"���F�|�?�A$�N�F�\�s3�ܖ��;f�1��oE��㗑�y���W������}��Ś�������x����)���[+�K�o>�	s��������=�O>����+�kqA�����O@�����M������@�zPJ��HBd�O�D��4�����n�C[���B3��%3^)xR�ٌ�~�����\�T�cLе���;N�����w?G>�+t����%�������m��N��mo;}�56a��R�������o���`m�T7�v�^t\�y�7��!��k��a��9u��Q������z�;���>����a�^0��XN���+l�1rƎ�f����%NT �E���~0P�#��x���yF���'��c�}�:�*�yS���+T�M+٘e��^{FͿ0���Ӳa/�1&*WS|�|=,@q0�+�s.n��|5�g�#~�.C��`�۵ญ�oP�#�����K��2��9a��c�o��1i�5��j`��Cly�̻>��>��:r��eOՙ�κ�Ժ ,�L���5��0Ցp��8h;ݱ�N_�
+<����o�����EO��q��oy�[�S����ԋ�@w��ID���[���q����A�4xkO�M}	�Y)r�{��A^ndh�]>DHIMf�E�#<���q&���̈́��7�x�6XHd�����L�	C��v���i�������~>���9��9r�E\���@�#�]��yPK7�e;!mh�t4�Y�����;��?z�I\�s.*�{�Ԑ�L�Z�&�AV�+6]S�8߀ٯ�G9�7�=y2r���IN@4a�X�wZ��f�MWk;tr@S5]/��z1��>߱��,�:ph��M/��H�2��"[0���6X�Pb5A��3A�[9y�3�r�]��6��&#�Ԗ_�=F��H��;^s���3�ƞ�_x��J:Z_g�����?��_���C:���7��;n?���V��+�%7@�{��?1��͉F7��^\K�\�,=����W�^�q�eHp�X1����s	����e
+�]M�:�p�3���v>�Ĉ�߽�.}i�M�Gm$��ĘA<djL����.��{N'|*��gF�(T{���9���%P�+�;�Teol���mz�-ǎOz�A& ����[Yь�ft���ž��|�d}���߃M<:V)���|�UT���!Q�z�U~��Q���<�+�N�ALM��f8T�%>����9���������=J��I�A�ß�>?�(NMmrs%�5t*[Dkp"���5��uHL� �{��ݞ�:^��9h��������;	���i���;|�s��.��.Q��m�t+(�3�V��xG7�;�<�����t��w����7f�D_i���t�{������+���uL��+�����s�@����_C6c�=�쁢j��c�I���نs������2��c��"\[FЊ�~o��[$T�{<{����W}�oeK4�c;�������m���)f��h�G��ƚ���{O����k`�-k�C!���C��O?4�������G���!R���]D&�|}���g/�(�G��k+~
+
+4s�*���_�(����i�dߌ��4�h�굃���O1���{
+8��Cz�+���Ze��;�nVI����N�@B�Z#X��EۡDj�j�^���y��]$���>y8�⃜��9Х�)=�@]k�-}asϋ��=B��у�7�7*���:�"f��f6�����*vv�~�W<�w
+�s�3D���T�+p�ak��oj�3��#�5��ɝQ�˼>(���mu�_��s�~��]�v�����c�+���Z�����ߡ��*�_w�}�_��v�+�����S	������<���^�ַ��M�/4��`���z1��ŷ˫���ҿN^��w|xŦ����8=�����5>�686Cv8�"�J��R�HJ����י��O�C(��k��0�.t�b+��hR�5ۚ���-RM��+��j�߃	�,,5�{�99Y�8ڈ��G�p
+S�+3�`X6�ӆ���9(clW|�%o��9��oN�Csf��(W�e>��+��4�Z.R�����`�P����E�I�9�'�%���c��"�J�(2��7_�E/y�����0=�U״FBO;�yC��?��ӷ}˷��^��+��o���z]�g��k��>i���7�K��/�n���
+x��1n�__�^���X�����{��{��
+sі6��p�L��7rE|�{�i����~�c��7(�����s>���f�i#I��a�7˭���ۏ��w�?��:�8P��:"�x�N��!F4B�;�U�8�����%P|���$����:wr�'�IJ|~ƹk4���Z�����$oj�U:�E�˧�	%��.�ƮPu$Q����i	�8�/�԰�����@��tR_j��	�"�����؀�;���S/4<�6@l
+��w��9>�5������	�40T|�e�+6�Ps!3D�����4�w^�~ͭ+eg��=6q.-�37��bq/�٣Ʃa8@���WZ8� 8�L��4��Qq�+��ߞ���rf���U1���%&�7�S?-����!M��[�A+6+��c#n|�\#n�+��z*/Q0��j{�RC�	,M�+?|�ۚ��Y��(�x4�e`�r���ʇ��A��
+�M�����DtyT�����Pln1������p���y P�t�x����L��]���	�Y��na�I��V�8S'^+�������������Ɗ�]�`���K��4c1o�4l��6�rΗR�l<y#�{W�75?�fm*:�3�!�C���#���,�)����s��%�Z@�������5�8�7��c��`P���Z��xG��uNc@��Uf\�A����{о���d����%��s����o��e�9d�Ҵ/���d�n�_Rn��%��Zci*}��«����������g��^�;}����[q�#��]��n�G}�C��ݛ�.coj1��:�u|�5���K�%��O��/��E&*
+�
+Ho�h�eu����7�� �	�����`�o�1.!���
+�i_�y��;�Ԡ���k��tb�M'�,���Ǎ(7~�pL[�pD'.
+/9�,����UPk5�hD)Y�iٔXrL5�1b�P��Z�̓�c���zD�_ b�����}��_�+ͬ�x��|%I�V�	�%@����:�"~bL���Ho�q�|7���C�@�u��jX�(��Y�l�-dFj�,�A�}6�j��Z�^�<Tޫ�N+q�B��ml�"��b���ua)�~��ϙ`�_��p&�x�/1�؝C1�#q="�Nv��j�\���+kw�ϵ#K]׹~m��x��_�̷��-o����r����=��V��ؖ�MF���"�5����>t_�Sw��_��7��Uozӛ�]hŐ���E�_��鿘v�����'�/�?*_~����s�+r�yd��ݕ![�jU@
+DMZ�~�X�S�ӑ{�8&�G|}G55��1�w+���v�%�Xk��X*P#4�Ѫ;�\l���0`�6,|�T��h�����g���~���V&f��k�74��q�;��'o1��+��p�a�:y\hY��S����@yr�=~����F|�}�7��"�����^��F�n|E��N�ح���!�5��K1�D0��h/[�9��G���s��y��,j�!1^'����k�<�vfi1�p��9�MB��ٱ׻�\�"�Йyvƍ�Z��krz��:;Cu,��i��������@����L[���S�ι�J�G���S��]�^����]�~0TO]0cy�AOt����`�/<�L~���_U�(�o�f���[V��K#���uP�Z��s�o�(0z�[+��!*��1�u�,�q~�S�<�Zo�ݩ�|�k�\�:��O��^�%�m�!}L
+V��\�h�ub��$ԍ[kܨ���!+/���h��Lt�^i��$b��+���&�}U��R��тt|]�w~�w�����{#�5�7,�ظ|�����S��G�:�����y��/�_�q����%�|bp�����9nJ�/��j�y$�$<b{5��$���ԡ���,��Lo6�:4v� N7��5>�f�n�JN�ml�Ӹ�|�%���F�z+Sx�����Xۦ�,ǿ�z����	H��͹/��o�$�q��E{�c$D�	�!vR��r�!�i��e�w���<F�V���ģ��A����W��7XȮ6bR���r����_��n�O�)�~V	�΍���ݐ"��ѡ,��P�1�X�+"��oxc�zO����N8G^��"h�s̐V��x��ߜa��?o6kd{��k�au��i�Ø�	�5@S�k��un��6��t~��5��ͼ�:���傖��n��������T�W�r9z��������9+�OU�+���>*���D��v��H�I@��	�;����,�#=�����\l���z���ju��NU�p�wWh��e�v9.��x���^��b����Rpc�1Á)癓ю�Zh����Ox�9�z�5�p�2;fCʚ�E��܊c.X�ݺ),�	�m�tF]��@`�yĊ��87�3��[�גDO�W��������Ku�I�ֽ��Ԑ5�xF�qa�8=�G��N��o3}���8�;��6{��nE�R���#^Q"�u�H%����?@���T�A�1+���_�D+5��$/Zrf��7x�_*��R�k$X�	���R�.!5O+8FYKu������VH|�o����.�_b�9	-l���;�B��t���p8��y�	��y���q����,=C޽o(�#Z��n����׽��?�3?�'�=8|�d�����-⋫�����l��[�'�����?��Ͼ������{Nݸ�w�:;o�+�/���������#�E2��_7�/�7�k�B��l�݋��qu���M0��ㅱ��7�� G�,��G]�����5'L����Y�o�(�>���ꦥ2�i��s�����P�ő)T����mr��|S���Gׁ�@A�VL���n3-BZ�5t��2�3�ҏm5�Nޖ���x`��m� 6���C��vx`�3*/�?<u��U�v��Ư�B����P^O���譚j�D�l"�N�UA�k�(�y�������z������b!J����\��n���u]+r���I�k�xq�����/6w�s|C�o}�-Ń�:+�42�Hi�w8NΈq`��0�S'a9!3�>}�E;����<<��>E߼1�g��|�H��"��������x����|*���WPu�`=.��/]���7z�=�p����"TP���>�ѳ;ٟG�+�`�c�:I�?������
+f��!r����4�X}�p<0u��zF�#�;-�����|:9�q&�?�y���1� t�����R�V�	�.w���!X�׵˅{9~�~��꫇|榵^l�u>Yg����ؼJg/��̆�3�H�:�`�,O:�����2�ʛb�k�Nv5:���� /����7�Q�N��
+9<�$��t��]�4	��x������n��Y6�+�G��K��@��<>l*�>0�b`�9W��ɼFğ��;N6|чU�����]ߊ���m�m�Xk�u��[rL�����ʟ�JTǑ����̇�O&�Ǳ�ǁ�[��oN�<�U��Y��@~e�eֆ��Ӄ.��g����4�~�âF��4&`GOm5>lxhM�XѢ�A+w�b���h�3�'��"��H��|/D��}�W߯�7��u��3+w��`#,ck�,k��YG����������3H���[�{=��ϰ�^{x�ϒhu9��<�`��+&V�?k��)P�/��ڎ�C+`�^�Γq����[N�O��O�r�UW}�7z������q���;c�,�OD9�E��BX����Q��,tF����nl����6�EX�%R1����m&��c/����{"5�d�p�B��G�>%S�wtX +�#,������ʲŽ������v���%5^d��g���H�*Z��b%��	�F��^bN��?6�`-m�NU��z�S�Rz0�Z���w�ZAZ���D㊨�ȝ�}(3KUS�`T�]#7��s^"Ęql��2�=��˜�ܲR�Z���S�"\�K+�vB68"��їB�n�B��`׳!93�4J/��6d���L�6�	A�qB���CcDu�!}��f]+�#��_1�]�Z�bH�A0k����r*3g��J���6VG��w�k#=�����G	�q��
+�M��f�wt[�}tR��<ț��*q�ۅ؃������o�kA�7�n^���ed=���y�a�=�FpV� lnc���It֚-�w��˱˯HJ�ki���|���b.L/Ggl4�lz��'�߾�|��x���0��h�	f���;���`Lٷ������쏷5!
+'v��a(ުm��+r5���ƙ��}
+0	ƺ�G��C�-�5�����򶿂d��5`�+����?^H�k��W�|���l+�[�)��6�L��'�6=��Ʊ'��;$�H�0� {�iWP]�T��������_�Qr�s��ƞ-p�F�J����X�
+�^i^��}��������R8��+�SV`Ѭ˜��C�t)/��>l��E�N���B���(��A�o>��عV����'N|����ϼNa^�o�:�N������Y��n�"�����<I����տ����ZP�����C?��4����LO*�}�i��(Y�6��E��%�Q+"���'g�[Ţ�:�X��٫lj�ڱz���1�}`��zkbHy}�4��=|��v���������ͳ�h��#�*�������O��:S�j#Éj.���P�V�Z������f�>Y�Հ���2�t��"Nb����`ko�����e�֜�l;���	���zF}Y��sӨ�b,T���'+�κ����d�@��=��y�����>�q߾�{? ���,6�e+?:�_tu�8��1��0tL�p<�y#��%܀��UE$z�9�z�4F���}�rK���0PڢRj��x�%	->@�[������uQ��y�~�3�<qI�	,�s��u���g�������C��r�f�5��/�.��/h¬x����cl����O��e�~���˾��ڡ��(��9�~
+`�K�fچ�lf���E���}�������@�֫O�]���O����שY�N`a�����=���r�7�x�5��rˏ�x�6(-
+3}>���63���~�9�����q��g�,$�Q^t��שޙ��21ǃ�B��`�|�qc�Y��c�rٙ�E�<S:|�x,R�[���o�\HY2�Z�m�/�8Y����*�L�`�W�7���j���p�Tn�#�6�4��L��8��Z^�H�?�����iSo�TWX�s�o��\Rr�]䜁Ss=��wm��Ɔͷd�e���d�v"Yv��uK,�~U8���
+��5���}E�p�>�8�ʄl"*(�T�2u<l:���Rslb��3�
+�{+7�r�2��@�qEs`��@�G���M�í�/��;5!
+.N}uԸ�@CǱ؇�n{��xT���u�/��sC��*��q��Hu���њ+P�}��q��}����[l:|���eE�)r1��mN$���U��/�>�lW^Wi�nҍ����\��?��N�F<%��6��G��Ǩ4�
+��C���h�u_Cw�3hՉל�Dk��.x"�i�[o[n��f��kY�*4=X�NoZ��Q�1U�'?�����>+}<��/��8c4�1�5�G̀v�q����Ot��FX��x )�>�	�m|Ա֞�	$��NȄ�6(�	���{�b�jӚ����P-/u>��^�%�^�^�Bk��+"X�rc����sa�������m��C��4��1&�5��%���>�^��Fm}�P�����՜#�>�e�!���`+��٧1LqR����}V֌�b�b�g��͵��p� l�Cm��������A�}���:6uMcX�QWI�������A�]y�Nf6��D7�P1xj��V��I�R��2��_AT{�PN�P��Q����?�?��"~�k;�+��Ecs{>��z��&�:�uf�[tĽ���1@L�z��﷗Q�^G_���9*0Oҙ�ތ���>����K� ۯ����h�#ݹ�uf�5g���W�O����FY$H���z�a%�љn���~���Y��(�2/Ԃ͈X-������׶H�e'�BBNz:!�4�\/c����%e߁>h��Nn�6r܈B�O�s����,�9
+#q�t2�Et��S�h����P���7-C���v5J��r��*���ULw��xBk븲��D�t����&���
+�;�/@)�#����cP/w3t�8��I.��4��)���9��_�2J<s��2�w~����ԭ��K4��7ڦ����V�ֆ��x�����7�h�-҆]^4�یKh|Z�"�lY+��G6l���k5;��E)1%��������z��?�����}gO#��Av��� ��vŞ�"�5��e���l�ƌ���oz$�r��א��6cYՈg���Z��<
+�����}�@�y����7v��z�w��=��\xs���"�v.��&����}��N�������Q\_�_0Ǡ��)~hY�D���N�I*9��a" �h��&9O�W����s+��sX�i��qs#��H��|.��lSG#�.[t����[7���7$�d�MSj�UEf7�ҷ�E���|{@��~�OXq$��Gn�bޖ�7<^���2�x����.l&����<�n<�B�@�o,�Jk����P��s���ph��U�7�Χ�yY���H�d`�P�\��#���'�`�9�927d3�c��e;�?+)�НsK8�s�Wlֳ7��W JOl5k��FM��6�+`�|�{ah�o"c�J�w�}����F㘨z�uP�i����
+}�/�U,�`W�����u�z��ٻ�Z^:sv�۾�g(��ƴ*eOK��=����O-�|�Ҩy����V��x={����^Y����j����t�]{�P�9{�|��8d��5�h���:^��Z±�5�z�5�0�B�)u�U���"p�ՓG�Zu0���(�ة�f����z�ѥ9����_l�S�����E���j�;����>�E<V~�'�6�O��q@l���My+C<1�����H0C�Zo��]��+���^�8+���"�a��`���<Zi��?�`5"��Z��*D[��^&�?�>op����z~�#����ja^�Hl��|B�Q�Y���f���+>������n��x4�D;�#S�����+-2phkmR���ey��pÁ��z�;ۯ��ܴn��Sq�k|����;��������)��o���ǋ��_b�G��.�ܘ�@9���e�i��^�|���7��?������<%ߋ7�m/o���Ӈ�XX�H��B�S���>�E��'��Uy�o>c���F��D�>Z��+/��W�ۭP���q�݂z7N~��1h�;?�Vk��p�ĳ�V,���q�#�hk�RL��چ>u�Eh�Z�����o`ĉ�d�g�機L�F,��y���d�ùj����F�-��gS'?���x�*�D�f05�!�"�Xז�0S�ó�@�je�8����A��4�zӀ��?P(M������m֛��.t]s���<��R��J��c�|Ԗ�ث�b(��{�y�����q0�5�����]��#T��:�k+�ݺ��ê�T�c�))p��	_a�+|��_w��o����}��Q�;G��|��c�嘑^�w�
+�U����@����H3�+���0"z��X�yJ���Y,Ȧm�4��7Ɔ�����ѣY������1:�=�P[}�'}3]/mz筚�,��k3TµjCp�bd��[7����{�6*���{D�f��i=�/?���moy�r첣���+HZ�d�5*�u���ە���C���rl�u�b��X����W�$��Y�;�Ӛ�I��k�R�� �R(7�n6E����2D�k��Ǝ����xh`��(g���c߭�U�-X�m�%>�.M�x��m�8��lT=L�,�+�rNԸbK�&u��9,x��4�V|�k��<G�6�Μ�=��Cu���7�xi�Mf7h�T�f��x��_>��-'��g9�i� ��`��̱�N�'�VP_��E�i%���P1U��_��⮶��:~Y^w�|�8:�V�݆��i��ڢ0�_�tc������n��C�нRy=���p�ݍ7����@]A_���v8���yMk����xǏ0�� �ix}Pt@�-�mf�����1ӭ7c@?�_$z�w����n�XhX�t�Wv�p�f�<t�"t9T�)������>�1�l�
+7[���8il��.b衏��:/��rӨI�'��}��y�w��£��u�}����	�Z�F�Ux����F^�y�!S_�G:�:�`�E�ԋ|5��l�!.����U���O�c��<0�#��k�p��&s>&W[�+��=���f���r�s�%����<�_�T������:� 1�y������Z}i�w�ҋa�ߘ�pL�+�k[��AO9mi�b������ ��4��V����AV�P�ҍU��}W���6YH�1jCoZ[���x0��,W�N�ߨ;�ר?�ڳ'���"�P?�RK�3�;�sW�@��nyO�k����C���1O�!Y�w��k9@[���_�|s�!���v��o��v*V\�͘����+A�(L�M�E�ٱ��}�Rt��ց��~K�:���=�bh}���+&���^�	����kbSS��a�W����4�L��ο���g�Y��[8lq赘^�#��A���O��xa�3X���l�a��;"	������}���e3@!%첟���F8NY3�јOx� v�]���hrs^0ۉzj�����v�a�8�<o�	��<>|�&��dz�u��$q^�i����'lJN_���6ǀ�%�Jڌ>�ΛZ�#׬��A�F����ys����������>Hb��$Q�Y�|�+��{�F�@4M��p᷸t��h���zދ�/V\�_��R���t_����mz�l�w�_q�˗ydy�����dُ�4��9*��I��Y���-����Y^��$�[hÜI�0��_���[)>v4�c';6x!�����s�;�Y%��
+�0�g�(¢G��kQ<9
+C7u�����QŋbQ��C@G��]C�\��U����˵p��97�𬫞fA�НP�ڿu1g����6u���O���I`���9WHb&�n;��F���x3+�em�����!l0r��ڰĊ+�+�U���ɦ������Q����.Y��ލ����
+�ۮ?�n��֢�z4|�%�z��k��i�ԫ�=t�q�t�~��
+��B+������I����z�C=����逰�m������s��̡��3,�YH8ƽ�����r�'2N��^��_�
+Añ�%�߬��d� ������`���R%�v�^��D,��QR#g�L>y��ϗ�Z}?u�r3�5N�jp
+ٝ�Ś��r��ֵ�"&N�<�]�7��B,M�'��R@��W/��c�bI�c����9O�?�,�%�����Q+.b�ol������m�TǮб3�^Br�1�ď�����6ϻ����}J��O��g�d�W�x(Kw�ו[Y����Xq�.y��_֎�����:�=�����痓��u����/.gΞYΜ�K?�EZ��g�D�cggΜ���*���a��>t�h}�^=����I���K�cG�.�����e��K5�w�/S��aE�� �� ��ڋ����(^>�zRZU�}8]��o��c��~���3u!XB�=o�\�T����u֨��E,�zy����9��a�+p���������w�B�7���Ez���{�ѻ���>+5�I�AM�����<�jt�����hT��Ш�+��v�m����Q��&Rv�[�p{��!�e~8��<$8~�ˉ�W,W�u��q��_q\�dϱ$��t�C/8s�3-�d�
+?4;��X!��h�y�u���.9�W���)��Ga�V�*���m��]��О�*Ɨ�{�������h�&����f�e�:.� ���Th��֢'P�K�k���N�"�Ԋ�{��JrW���i��q�:��E�ê���q��-�l}+���}�U {��T��T������Co������w�u���W�����r`�+cM��Q3�!�9ƚ~�>����*~��FbFmp(�J/k��u3�~7{�u�l�k8C�D5ϦaٿȄ�6VHh�En�R(9�:ǥ��?"���}�@��l�iV������cj����c�_�M�����~쫏-����w=�V+��8�޵�N-��G���_��rL���=�O�i���ui�_�+�Þ��ym#��s)fN3�e����
+�6?�E�Q�VFe�D;�xHه�Z�`b�#ǳkz%�Õ�D���l#�h�b�F�C=s>'�΁���JɤON	޹�9������N�Yτ����!�!��I�k��,ϕ`g�=/ސ����)�^�;�T��A�8K՚[��(�_?z����4J�$�|*�z�9yѫg�RG�hC)߮O+���ώ���
+�X��O?J��q��+����PAX��\f�)&kf�XkE�F�i�l�[R�TJ�.�p�x����M8���vIf��T�W6���h�ˣAVw�)�JZt'��زw�t�����O��ƿ����1�:ʮr��j��;ϧ�,���F���������ܲ/��QK�8�9��W}�t�l��FB�֟}C7=�|�V�6;��P�P*��2�N����w��Rpm=�+�I�$��YL�j������m�w��wd�w����j��@�b�7��W���A��Z8+�z͟+�e#j�b�iħ��u��+?���	E�\
+κ>1�����Ԏ�.0��'�e߈����_b��!Pbb.d�K�+}Z�ج��Κk���ޠ����������r��a����x=[?���H�ճ�y>�K��*C��+�Q�^ǭ�����k,+�+=��:��+�Ê����8X�:f"�r)\rs��i�+l�C�+�Rr�E��^U1D��'��A\�	���&dS����Gy�0�q��w��'?��u�lP,h1��D���}Q��q��S*n��eU���+'N#28y,�HZ�<HS҈��v��ق�]z��:K4,�aD�L�l��F�ʮ-�蘮�2���3�����i-�2���7Έ�{,�4 �cz��.���f��i`֖�y6��O<�����ܽ_X��~�K��c\kSU;�˖�<���a��L�w/2����{5��;��v�_�Nܻ�S�����⬓�����o!�O�Z~��hyX�W�'?��"�)D�������%LEhB��n��ʼ�P(c�w+�TJ\�Y��T�41���/�eŒ��5�l�oK���{@�Ka���
+Lk���ژnx�0C
+�0H�u�V�t�Ё��u��_�EC�1��H�+Γ��	�,�p��.��7ܲ��oX��x�B�ߤW��	���ۧ��x��˃< 	�*���+��>�����/7�p�1�3���n*8Y�+ja}����ɹ������ߵ�����Z��ο�SĿ��o���[�t��
+�k-*A�ƻg��*W�A�$�+��+��`�ɣs@���~��n������~�����Np��EQ�^�ǻ'��~۵p����Dk��'hz^<���׭?��9r�6�k� /�ʁڼ݂�����o1(����$��K�c��/���Y�j�1�.ϴ|���Eun�^�xJ�"ܼs���ܱ��2�9(c'(��m}�k�����9�Šk+�s�i�i���8kK+��`�q�u���nهQ��1t@ǻ�w|��˧�k��~���>�r���������'o�����Is��Gn��6�N���>��4���'o_~�=�PO\_�w�i}|d�������5ܡ?2�q�n/'5]�A]@�3�
+|��aol�#�uy.ڼ	�X+dw�+�9��/479v�}H�x��Z.���6~����H�s��p��XIqtq�i}��>�����ҏ�}ո���|�w$�����w~��n�=���X��Rr��������I��E�cvX�|�o}����.3�9�*���v"�����~Dt/�j���xTz�w�M�Ӷ�	w��Ļ��W�P�ǹ�u7�vy�[޴|��W�|����1���Oc>��o����I�kʎн^��ӑ�Z_W�����^���b�S~�m�^}-��F��+�����ヮ�S"����
+�s���)b��Ig��s�����kη���7���u�4P�	�8�G�r)�i�����z��.�Q""�G�M�!��n���5W��2�x�y���$>\����񀧀��oz`.u���+p����]���#s���������������6nhja���Y���o��n��9�E��)(9g����9a艬�<A�E9J���;+dwҥ�H��lR8[����h�r8/�ҷ�(�2=�=run�lS���"�ڄZ��c�Rz����u%[m������'�W�V)Tr(,��G�ݼ�Tjg�ā�}6ע}6�8&�X>I1�X)>���m��89싁BڈS�s~��n�"�F:��9~z��o��ٷ�3��iId%������N�Ļ@����|�ح�:���������_\>��?Y��x��������[Cn�++]<y1����p�˰c��;��T���5�V�.+}%~�ڋ�h�,W�_�ݢ?�lb��i`īj*6Z��07H�{�x���ö���/�J1��/��a���#f��\q�desmr����u��Jj�ƞ�J����L��2a^�aY�6��j@O��I�'���-W����y�hݵ��m9p����a�{�x�Ʒ/
+%�;�o�~jMn��O4�~�f�sF���NXm����t���5�@m��<<AvL�oQ��N��oͨ�̟��?��_��r�uh��]{���zV��+�3�j��s����	��zf�bS4o�I�q�k;�"�EË��D�b�S.��֑��`C0�����K�|?�e��VS�Oz������������h1L5Y_Kj�;��}V���z���������M~5�{���U�Ml��(�u4R۞�����?���y�ށW��~A���|�-ˉ��^��C�Q��Zy;��u���/��3�?���^i�:"�<H9��l���\z�e��R����r�wi*ٮ�{'F-ֆ��inٽ��Wt�b?
+s����O��?������;��ۖo����+��J���2�<���Gt���������R�a5C}��Ԇ��`1�#�zu��;xKِ���.1�%,Z|X�h%���r��'��:ն� T�����k���`PO˱i�(�4ظ�Y���>����w@����9Aڇ�'�+ś��m[э�cQ�������ӵR�ѵ+!�������|zhի\� �����e��x���Z7M'�n??��;�s��ᷔ~�u۶e�X��>����?����'z��>�;�O��m)����rup��5��{�藗�n{���a~�`�˃����½�<G�i�g�srq4<s��r�5W/���:	�*�CN�|�~��_и��۶/z�&5�Z���Gی�3.��/��h��ct�e��mc"h�L����gl|<����]��{��3��<y����_�F���q�`^����Aͧ)��#F�y+���lڜ�m:	�D� �7�r��@����o�0�0��O���9��:�,8e��|m�5��D��?��4V�$���	d]��R���cG
+�z��2P��i��Q�.v]UNZn��~Xyxt��8�������;F�J݁�&�_�Xl~bG�}ј��:d/��QYk�zbn����c'�ܾ�nV+�-x�$pp�����\d�T�N��E��&<p�4�����O"TbR��C:A�ai[��J��Gݯ��(��˰��o{*�W���L�,câ�=ac�Ρ�"��M����'ˤ�v�s+"�?��v@Z��I�#�+.H����σ0/ڑ1�����/�� {��(`7���
+���{����&S���hX�7�D�EN|`�Ĉ��?�2Џ�ڶ��3.��흨'�V|>;Z���7o���N��>4�Ix�w����(.;�M-.�N����t�Ų ��[�#e����"�b�;%`��Q�����"��������:�S��O�H�E�aZ�t�Q����m1�\J�u�՟pm���S�P۶C�,�ONԗ8��>ȅT|2��X�����O�I�}z��;�X�e��d,I�W߰��?��iKgc���x��"��xt������>؛��i��*,��<�`��9��@ҟ.lZIZ��ࣴ�S���l]�p��l�a�J"}[��W���?�+m�ۿ���6��ғ����]C���}���|�u�{ݯ����8��v��L�$]o�ޜr��ۧG��W$��RR��Er��λ�j׎�]kU�S;s���	S��Z�}�cG��n'���T���������"��cUc�gA�c#|�����q�3���Zj�:e�;ݶ�>>!�O4�f�D8�-U��<6g����A�q�e���+�*���?��+���Y���>RK^�������QR)A��0�i�wRn1X�}ڤv�ȓx}�*��j,������n�ԧ>u��<S��C�v�ۥr�Z���O+G6/&P��R��X/�	��%���됵~���9�TC����4A� �B��w,��&:�G�wOc"�:�`�u�'EG��I����-�Bǘ5�I!�!b(~я�h�s�R�u�B�~�ܨ�V�9����@!Ýeb5xm���	�ܿ�2V��v^�S�"���r�tK,z�)�A�6�V�C���)��v�>h)��(��X$�`9�C���+ݤ�8vu�7-�
+�
+���$����`��r�er��r��E���6��4��ͺ�F��S�I���?��S�s�S��G�h��?m�׋}�uj.���5G2��HTZ^�Fg܆G�����EB�ж��E��<�Y��s�1�ò�:k�;U����HsY�����P� �CO>�O��>�t��^�ȳ�b�ʏk�g��:��v�)��i�Ȧ_�S��b�:M�pٕWN��|sE��6&�1�ko������gڱs��n����/���ﯫ����O_�oz����FG�V�k
+���2�5L���F��ǧ�/������dF@ȣ�nS�����|e��o�>���L�\uպH��-�!=���a= ��c��;���f5	���㙛�z+��|��׊"����ŌD+ǿy�1z����v��	�jt; 85����+'+|�^`��[���G�DĲ� �H��������¤��9U��GAs-p�����ڢ�f̱Q��4�ݦެ��u�޺>������t���6�mj�@i��>Q���0$ch��g {R��m��m߾}g�{��G�'�@{�	�4����H�#z�Ƣ� �4��c?�<xiX�;�
+���X¼_��ill-2#rS��IN��Xߜ��\�	q/���bAN��"�zh��	���ů|y���Qc���ǰk��B���W�a��YU�|�X2�)q�	�I+�{}T�����#��]dʎ��n���m�,����}-5����P�Mk��߆X��v�[�^��y~�����%;�K�>���~Z��X�����"�І�/��9�{��<����!Z�骽z��ȵ����4�	��g��(�fCo!�B~��a_��x�m�=�~���V�6�1`�i�38��t�����o�����r�W�Y{b��\󆟚n�+����y@�����ݻw��G~~�ܧ�|�S�_����O�'}���3~O�Sw�=�]�_ �8xh��?��>�u��|��pN#o��N���D�#�$��Gk�+`��^�	օ��n"��/��e@���w��L�*c+I6�;���+~�f���t���Ea��d��c�I�b��6^�do�4�f�l?K��E��ԮK�ހGS%��������C)�Sd�X��W4��wf�����[��b!��9&��(�g��+�2
+�Xw��������[�'��]|�ڭg�g��
+�c�2=�k�YÞ����(]o����+�[�#:��~��^��?�����>����Nޑ����'Q��r��t1���eR�"+^�e�	*}] ���P3���:��[�t��e�&ҳo�k�����Ԫ�l�
+b�U�����-��.�aRT�-mZ:7T�|DU��9gp��.-r	�Ql,����A�6	1�1!��l���Q4�ؒ���-(��+^�6BlY`[1���hk:���݋z$@����+��@�nrV��(k�߭98�3
+��+ʓ���`�54_duΓ��ŒWH����dRӧT����O���d'��.7	��ȁ1�d�?�z�G��[~��)�ޣe<'�G-�b
+�?����ߤw��w��%�gV	�Z�FM�ɝ��v�Nׅu�:��m{lD~��_?=�7���L>��t��}~'�{���ƛ��ϝ�ſ���+&7�p��A��ﵺ��^n�kڌm��`�إY�f�"4\?i��y�?\�t�n���?<]~�@��yu�n�q���݉QX�>�!��VU���M��N$�|��d�d��j����_�8BPWm/rժs�	��.7���J����	����y Ĉ����/\��0��ߒV�^�Q'����G%ݼQ�k��Lk������c�o�J�r|SuQA�'Զ�T�Q�0I+����RbE�i��&qS�L���x���9�G���^�ֈ3���Bۂ˳OE�c�C��Ўf�l��E���R=�s��VY���9�U�Q�<�"D7[~w�w�����!~�����~w������駟^Ї|��s��yt,�.�͢i�	O?!T�֠��m�X�_�����;�]��v�ڭw/wO��>��䝻�����v?�m�.����۵F�ͻ�������C�T��/�#�G�5��G����;����(��>��������ܳ�Nr�;�����:{�x�P�䏗�={�L��/c:Yyi�+���38-�\�橾\?����Ht�mޚ^�`��?�׹�F��Ljʺ��.�uyq��ַLy�{uP��!���>e����#p߽�N�>�pzH��s�I<�����/h?�����u(�U��9ƭ�_<�֚Ý�����WL��D�s�j�^�V�m?�����|��w����8��)�Ojm|�Ԛ ��Q��_s����x�۰��JR�@��5�����l7Rt��lc3��Ѿ�8����~��z�y���o�1��/$�s�>C�x~��AD�O��؟����4՞��ƒ�n^%�*F$Tx���/YC%6�[�	��f�o��~g�Oz�2M���*����5� �gQ봍�8��Om/гC3�8b�Y������t���������}u���3�<s����M�}�_�n�/�7��u��DQN|��Ӏ=�_-���>�w�w�y�/�1�B2����A�E��^I���?�$?m��";]W[ݾ�^t��ZYj^�®�v��܆F4�s�g�?�H����~H����U�Z��G۬D?8s"+�Q�::��R���#�b}�Ԥ7~'n���&V��8~i��]71�ѕ�NV�Y����_�/���U�K�5]��t���u���NYS� ߸][o�G���n�6a0B]�8oȯ��z��3y��ׯ3��g�>s��v��]���Y�3o�qR��G҅9��v��1��K�.�u��S�K������yJE�N���C�飷�������������|�U^D�J��Pm���HRC�ܡޱs���_�or��i�DҌ�g(*΃b,���u�=q5������G���c��aϒe�hX5|R�4��]���߰��ث8|5�i�t
+��8?7�Zi=�\<�p�mӵ7�4���{C�i��q؆��F����#���@�b�X�o��h��)�K�~w-�����75A5���*Tiڦ�_y�k�|�-x/C��ҳ~����ڷm:M7�Ѝ����{ƹ�^Ws���3Z�z�g��Oާ��^l���~���z�w�<�o"<�"v��tD�'H��6�ڮ���];!~�!X4��#l9>%?���f��~,��¯�~�R�|���ۿ{��k?�sӁ��.�K��ɍ����G�t�e����_�aZ�j��:2�%��}�T�m�{%Qy]"� ��@�3�Z�D��QCM�-�1�e�%~�^�Fq�K����
+��׍I�6<5,�q>E��>�4�.�}��1Ɣ������w���m�����U��ڍ?kP�ew*-|,�7Č� �O����0"hs�᧝�:#�Z�[C�9Z#��;��|�W�>0�7��m��zcb?�X��[��=9ŧ+�n��+����#�'I��3W�"��T*�|��]9($ͭ���p�`�q-�lg���p�v��+,V^d��b5�l�iKj��12�-$r�����agC�֥g�q�H�o!��u�)��Y�\�D�'�n�!��@"�}�}��j�H�9�Em\����n��c�A��\�&��@F��QްQ�n��m8hT��=�ii��m�3\��G�������}�n꬏�����MV`�]�s�⿅�Z���#����d��DN)6-�"CU�~�/�9��$+��߸2��m#,�şw+й艌/+��|�]Z��9i-��V�x�������~�A�?���?��c�S�����L���9�7��h��%OV?�O��5�_��_�v��;��e�t���s�g��|X.�X���Kk^oC.��2Y?Jd�O��<�W��g� ��E�}�.�y��t� ���F�~T��'Tˊv�& �-5<|q�-���yA�?�X�㋴s\���ņx+���X�ŏEڐ�k%��^9V���}�?F���R�Q��<�4k�qE�)�NM��6L�����%���!�5475�GvԱ=K�_�L5e�&����+y�)i���7+�������,�֠Ⴟ�o��,�Lhg^@�;,�+���ϑ��FK��\�887���/:��OLB0m���s�sJL�P���G�"�����k��@f�+ ��;Q�(GGu�q=+��.�BP�>���� �v4M��]H�!���cnEk6JC��땹����߬-|d7�
+>�����8�o�憏�/�oh�q��	h�I�/�r�Y"ңx�U��$���`��:e��k�:������(�g��ݑ���P�z��F�i�2NԜs6Jc�	Z䁂Toc3�K%�N鴏B��-هdXnX�4ݯk�K��z���p�ŵ�����pgu�O��d ��5�D=g�4^፞4�5+b���m�~]�կ~�����ю[慪��D�h��R�7����^���r�DѶM�b*KBX^-l��Z g�t
+���]�,w�9@�*WĢS{�m�K^���Ǔ��8>����tgY~m�X9Px���O�U��t�����SН5���=*��K(�M�i��"S�1mdٶ.(y��-yr�\��5$e�x�H��h����V�7ъm�hc�@�EÐq��q7",2�=��
+T�w��l�d�Un���ƹ���������t��F��!+���Z0��?z+�F]6ͣ��Зm4x��y�z�.�L�u���KD� `{�e]�\3�r�3o�:�K�ڻvI�c�4JC��a��$0�"��^6�����f��O��Z$�}j"�=DZ�H���b��+��-�ţ�s��<�?��׾�m����^�T���D�:Q��OK:��O�A,�;�	ӹ�*ڔ�����ju���1a�x�_��|����T���(�œd*}x�
+�EO�fz�qՆ���$�";/+k��Tp>t�s��y��1U{+~�nY�טu���������w����D3?����uM�!m��DY�K'�A>�_��믾����{���upx�f)\���2/uX�_�_�c�N}���Gr/�O��+��S�<yBh��2��C�Y�D�R!�JI�s@p�;���h������0�����a4���2��q��g�?�h��
+ω':����e/�`���S���E]X}r�������[1X�6�<��d�Y���:^.;�֥�N��x�����Z�a���wL�#K�B��1\x��� ����$�l��SEj�e��΂�W?\~�.�Ś��J�s����'?��*�̒4F�lz��Gj��*��۱s�t�%�M�]y�t�(��~g�(��}F�&>�[�(��;=���t�z��4T���5��;�� ���И{��<dD0�%s�O���t<���_�0�������6�4��-'��'�xT�׾.m�3��X��È��\tHE?f�\D���Д5��)_,v]����jytz�m����O�;��α��˵|cS�/N�:���<�����g-��1��ֆv�Җ�7C�>�9�	�<v�F��U{��������z_z�t��W�'�:
+�;}�Kl�~�׎���G����秛��^�|�������_}�#��m>�c
+�Ǳ:��Mc�E)8�(J?�D�e���5�6�����a��+P�I(�ߓ����&=P�����������Y��Ki䦌�#��/��:����3�֯1�G�ʐ����a�x�7◷�$�1���=n�S��Rl-(Y�����y^�:��A��nȀ���d�%�,^�)�3�]ZE���G��A��DӺ��ck�_�5_B0�l����5�kЖ<�/3Ք�'�)�6�q��-��ڔ�X������d�w>*������`�\kΡu��j�9�+x��>�䎯��{�O����{�4�F��d���?j�1�ެ8�ί�Ad]�ȑ#�\p���y����E:�_^�t���
+�2�g��hͣ�������ܹs��_��Ǜ฀L���T>���=�8�,���5��Ih��XC�KJR�V4��e�cO��������������|����BH �.R)}��;�^k����˜ki�����Āҍ��lRxp��
+~�'�z��͖}��,��ꢄ����[y `C��,��bb��|='n�ʡD��/��Ků�/�$i4|u+���]��7�/�.}~EhfK��9��횘R�M4������1��/�<�����~����}+ؑ����͞���j�;�ыԪ�j�G�D�|ՅM�_y�t�����]�������X%��%}�(�bNh�33�=CMma9*9���Ri�����$I�0(U�4��y`�5v�̬r��"K�eX�Y�Q�E��o���/9w1Zt%�}Jx�_�g#��?r�Qm��VTdN�4(v;���΂�[Y�-
++.���Hh���\,Ϙbz�K��I@3���|q��YG�	|�Q�\t��*O��@��Ϲx��7��1`?46��V�T7��d�
+g�ۜ�Y�u�u��������s��5����#�������P��0���Q��>q`u�7�D��I{�G?�ѷ1ɻt�k�c�x�q����u��w������#�E�>m�I$�� �M�J���)l{��C/���ŗ�8.�N�Ă�(����2(*�a���++/D�x1�`40gMX���*��ft�;z9p���%@�L�ӎi��#Ǹ�>��k	���OI�֘09u+>h�+l�F���l�@��N�R���X�t��G=���A�����2cl	���ݴSW���Ү8�`���!������m�}���u�o?���^}���xQmW+���g�ïТ�6�.�����E��Yz'���I�i{�����I�ˢy�̑?���k{TZT�L�G�s����T�
+#��uKƤn����d��ܦ��KXr�j�X���V�}���:Xo�Uƌ*[���g���s��������׍"�"V��˼�j��*�d,��U�c�����!Xm+�7�8r�!�����`o�o��m+�|��Ο�׳ λ@�j�رS
+�c��(�Ʈ9n�m��r��z��h����聳���~=��#e�1�m��b�^�jx�;߮_D�)�#zQ�]Gm�'h��lVvk>"?�@��i�Ʌd;Nd3_�%t�	7���,���@(���~�����T��)�6}���%��u�tD_����ۦ[�}����&��ڤ�v�RGG��D��jh-ߒKla��_��n<7��?�]"7��@?S�}����J�b��˸?O?{��ǏyI{4h9�ddKIs�J��I�2d�s�^.#ɚ���'�R�7�'Fٕ�q��+�&/+�b���U�7lk���ͺֆ��󀟼�x}��x�7!:+�I:~�`�5��k���sEm������P�*�x�,�K�$����@���e�|�A��,��Xg�U_��]i�U:[�#Y�iAӸ9��ID�o�����O(8Qz� ����2�������r�; �$?��FL�����gJ���-��`�/�)Vw!�\��@a�β�Bs۪�i��a�ڲ-�=�J���Zy�g�R[�[���},L� 3��m�]Í���lg��1)�7��`����/���wI�����^�t�W'Ab'ʘ�7+Xt��DTM�9Q�7��Z����lΝ:J��,xj�g�
+X�=�I:�� ݾٛ��?�?UZ|�nS���2�hS�x�y�yѬ�����c�~��ܱ]�L&�ŀiK$"qA��8?���'��Gh������B�{0�S�Ů���&��ɛl�5͜��v�=VV��Ա�����?m|�}�xhW�� |߰SVl�b�Q:�e#5=�k��we��y����g�L:�f]��0�N��qͥk��_�����?߬��kD�Č$�%��+���־�b�,�qҰ7u�v��������>�����l�bi�sQ�m&�fe��M�z]�)-�ݡ��cGVQQ0���v���h`�Ţm����mPVƮ�V���	"X�tmY���Zt�"�w�B�6���z}[D��p+�ac�Y)�fR��~�`���wW$��~���P�	�LA8MB�j�\T?��3�_��O�G?.}���U[�壈�@�?5؛�GO[���FO�����������SO-߱!Q��?y�[*�>�"�=�|��q�?���.���a]��n�n*J���7C4��3���w���-+��1���8��L�ln�N�m�}H��.�=���G��"a7ʗ�y{�|��yO�;z��wO��c�{0�>��������Xl��S4���gr�ˀc��>?��*���ŗL]���={0.�����.����`�+ӱ�Q���[����g��l-xR�Y���|b�]���������X�1C����G&��~�ͷL?�Ӝ~��O�����>K��R�yIt��=#&d�}|����/Z�u5YO�7�O�c :�6���z&N��6���Ηs
+���&F��>���O�~��p�կU~o��A7��8��a������f���v�RC:\6����36N��$?�:)���P��4.��ܨqN#8� s�In�Q\�K>��+�yb%/i㡍z״��|�����U��~r�,R���mEzw׶V2��>:�p"PNe�,��AgZX���"{|E����Xo=���,�Z�=s����ɿ�����!P�;��R'������'��U��f���������#�D�'��/P��5�,L��I����;�AN�_Kҧ���-#�g�#����!Wf.3�F�	|E!H8�o6b�=�bV���K���QV��6M]�Ħ=�-Y |bEC�:U�d�O���������|0�%���+W����夫K�)dZi���Ë��+������,��_/Q�s�E�+��6K���"�B�P������h��R:��bZc��{7ؒ�	�w)��O�}'��n�W:�񫼳G!�٦����=���#a�=�j.��Q5�������fv��'/pR��8��m���\�9_���/~�kz�����`��Y��r�rMC����^�L��r�t�gN��Ї������b�r�!"���6F3涚4�ߎC��!�����o�X)G�6��l�QG][����	#�].��;�1E7�I2�x��7��aC��]�)s��+'��q�b=��/=��'y�B��Bc~"f<�=?�
+��QN.���I��+��n+7U�R)L�G��ø�K��� 7�$=�]sIw����c����d0��J��'t����������t�w���Ǟ���p�+�s��Hä庆 G�Q��m��-��+x���ŧm;��C칆���j�o|�w����2]�w�O�{�p�6c�w��|�;��v�V��`y�kk���ܢ�_�+�d�9d����R��13���u���ӣ�<<=���Q<7�NB�;���.�>E<�L_`~=qD{����+y��w�(����I�y��/"��=�@K�`j���6@�}\�cl���_�,��c���-�=$���ձ��;l�[�կ<\��ך��C��ꖸQ�u�+]0�R�6��;O'��x��gҾ���}��s��o�dv)�O�|�h��
+]+1�"��'ս�e�/�X��
+o�=#օ�z���IC�׎��u����	㿅����޵w�ޯ��_��xN/�頻n�������'+�׶kJ�?<�
+n�sdX�Ã�>��h� �Z�zK�f�-���K0���]0"��d0�>�ط@�"��O����V����*�o	�Xi�G���2W4��&�4�]Z&	�����.IJ�+�.c��AE�¥-��-�x���o{�t��c�M'�K)�y���V��GS�#������%����X��d���i�
+
+��x6n/l3����z��k���f�W?Lɩ�y��ڌ��5*@Q�1륟�:�sd3�Y	���?�r�3�[PR�C���|3�X]�li��W�IU�S\��,��2����~�l@)ġ�����(�<˂gZ�K�V���Gg�큇����������it
+����9\���T�(ybF/�ݦ�l�SFjnEA��W��[t�ީ".���?�����e.�˜(L�Y�/c�uT�Ϻ��ō�9�Z=���N(��/���X�TۡDCm5h�'l�O|�N���+�;n������Ǳk@h�t�-Ӈ����[7���_��mK��nL��*D�#u��E��`c:�<��bm��n϶�2��a��d�{2:=���z6�x��3C������@
+;w����w��_�ۿ�~���K��a9N�_�x`/co�4��?��i�YgN�s��y#c��Ӏ��O6#Z����^����℘t�<�Ϛn��e8���?,.�䙞ĥ�y�أ-˰���o�Y�V���a@���p~f�l�8�B	��%_�z�X\+�X�֦i���������3t�9rQ�'$��vNq�v����1N�w��#E��5d庭�t���ȷm�+)v��1�����c�"f"�?mY�
+�O�ˈ�ɀ�ђwl��G�c$��m���Id��v��i�l#�.U�1�y�ey�k^�����>�I��Ss�x/=�1_9��"�~!�`���O)�����tޖ>�ⷬ���ū�z��O�VB��ξ��G����?����a����M|,��V��
+���z�@q���6��v��-�xK{��`�����K�K.�\��?0m߹|M�Ō�x��{][sH�F�G|��5���8ԥ`��i�(�g�k�T���~�5�R�퉟��Kc��T���~*����)��z���+�u��$�7�
+�y�'�k+�c1�]��Y�1��=�8>��}�(ϫ������ݴk'���`:Y[~�㐟�`R�F�����9�5��ٜ���J�3OW.h{�
+���f�������������_��lHٱv%�j9���+r$��#dp��e���yފ�8����JhX
+׺�ae)XY[j��O:�ս���[Ens$���+Ӵ�,5f;-.{�p�mI�ַ�����K��uܿ__!��Y�:gX����U�v�R��C��\�6u]����$�c�:)�~&e��WH��~`}���@ȍ�]���~ޮ]�.[������56��f;ȓr�	�y�a��^�La���Sѱ�{͑.���3,���)^�L�0J��+�����׼@+�����(�����r��9��R�T}���{t���xШ�:}��mɩo�~������y@�+s� -�Q*����MMY�C]ݶ���g�h�W5��O�;�_r�t���}!Y߾C���2��9_�j~zN�?�[e���е$
+S	x�-��h�+m�K�c#�O+Ɵx@��	.=_ց�%{Pq��_j6B�&w�3r�;)�X�ۈ1EY�\����h�A?UT�Z0�Z1�G|�fu���+��:�'J�l]��R���n��=q�B�r��t��;�X�HGcZ�Ikm�&�:�^�Bc�jFZ�yؙ��}.p}w<�3��y������	��be��1j����?p���Ɔ�?���aƮ��e�����T���k���#����A���,&�����E���y����L8>�8���z�^�
+�T��ߺH'�NwoD��Gڌt"w�Ɇ����Jv8��볥w��ll�[����q1Bk!�<7�°p�����w���o�l����mk9R�6~gG�X^V@#F�<b�v�Hl���N2�oo���AE��]�p�&~;����>�꨽_E��n�-+���y�\��U��§���%GG��䒁�g�IX*�j�w^�����s>f��p��ٵ�$��|p���e��-�K&��������V��`�hx��)�m͈�5��j�o���~�'�+��*�"
+����J&��u0�BC��������7��T;%5�([׽�I���H�sa���8r^Dl;�ɀ�67�*{�9%�o�7�H�=t��K�Q�d�� �z,j�#/�s�Z�!"���Z�.՜�t'�cnaē���aG��O48+&�ó@�@6���D�;J��9�=�]y�s�s�(�s/:�����n����9��+.�ǝ��
+<����Y�|��Ғ�-}op�O�,��J�r�x��{8��F~٤����O^�����)}��(�q5	��d�Ƈč���gST�8��"��3�_�P��ѯCR�љ�#�r�4������|���-5?C��Q����X~|ѡ�V�oϑS_7RK0Ѓ��O�4�O��#*�K���V_2���s۾���7�ᛗ<�ꤷ[��s���'1"���y/�^��?깩E��T��@�k��j�]� ��h���<�zu�qw�rQ��e�y鉞�?�s_�gM6<:�rKNOD�N��~�@���	6<��J�1s�1=�ֲ�-;?a��������K��R��$G����N�t�;5�:��;O2�װ�X��_�t,4��^؀��oH��1�O��������s<�!^9K�;O�ߪ/�����>=|xj}nl�^�	��ҡ�����v��W��H�*u̸t��6�U���|����"����-�L����Kt�C�*N��x��7�}f�Ḱa����ָ5r,��L��Z�+k~������\8���0�4�������L�P����n�����zG�Z(��mL����G>����/|�v���W���$�����g���D<���RC��ñ6WM|yR���	NX�=O���IF��'k"��X|b���h��
+T�LVޗ5Z�#"��7�`��[�s����u����7l_ֿS�Վ&8�ty�u~�ڢ�x���?w����/�� ���)Z_ֻ4;�����)b���M�Cj���������0��a��D�ڋ��I�J�h>��7�~���U�$ֲY�Q1%;��2��N]V��С	���$،�.�gu���x	�ņ�k��H�uD�=�i��'���#�q_�1'�l*�:]zy�y���7Z��izT��FD��5f1Ч&��?�� ��?�� ��
+�7�\��ob�uMi�׋+>*�F��ǰ��N�,���{�>�?����9��K3.�4}կ�꯾�u�{����XOp�>n�&���;�����^?�W�x�+�Ϝ:Y#}#<}*�o��~�-�l�z3�-i���ʌ�{���(��G�>	B��1e�ml0�q� O�0�6��]�&f����D�/�����"`�Kc�#�vW@6�*�X�X���Guv�Ң���R��4 n��<�2W`#k���]M!��[_Ӊh����Sz��Zt�ԙg>B���*O��J���7���Y}k3��*mr��$C'�s�h��s�nzuw���wc`����s/�sa�����Ae�{���0N�_�A�00V�Cs#b@���&y�V1��>���hv*hz���bϏ_D0>(ы�jh��O��0��E�v'��^+?�t��1M0�s��8�?�c%�}��>�w�=�L���Q��c�g��׻�]v��.�n+��2���_���?~�>����?���[<Ysk&6�
+?y|7�?��7�!y�5@�����>�|��ۋ^�����۝z�u�]�%zꖢ	MϢ�����y�K�ǷS�b����gݬ���s�RH�5v�yn�-�����ƞ����׌%ƅ�|Z�+j���H/��8���<k���E���������~�>�r��:��D���9O��4���Ҵji��N��3��	���>������=�e�/���৛c�1�4�<m����MZ\���!.�l1�<E�tK^<�Н�u+�NA�ď�/`�E�Ҝ�1���I5ĳ��n��a�Wnъj*�iCtb;F��'��zE�Bɒ�kb�����ly5���|�q`@S?���+暋G�H̃J��^C�4�v��.�B��_X]/q�W.���D���<P�Bfݮ80=�����ɿ�#~Gom�	���.�~�g���~��ۧ>�1�L�V�V��9y� }b�o��L�C����ߵ����_^����5���<�u�$�=��OLؘ=}���'�Ԙ쬾�+����Ժ�O��&��o���j���W�a:�H'+�^xN��k�x��'6���U&믺��j�OĔ܂C�1Vs����g�����]֕�d��7x���.���'N(4*fCz��?..^0����o=d4����-���v+(�����4}Q�~����~�Mo�0s!��Z��ڊ��x��'���x{��J��7��{S��&�9?�<%�ěU����'��d�W̰[����!��fY�>7���}�hq�^�+k�%�.����vOho(����S���uEj?s��t�@>Y�D�<UO�;�Y��\'�4���FcG>ќ���Џ#p�f�����vϛMe�A���j�^��^�:C+����[�cs�n�A���ʧ�f����^k��m��V.���щ$�`R#D���v�}n�g�˔
+o?�1Rc}�����9el�A���£s�]1%��t��k�=j�H����Ms��F�AuS��ǉ�5Su�u�;�j� ����e��Mjhb��G�ځ�lj�>�`ւ�8���p�&�8tw���:_�X^���n�}'���~;�ɦ/qr5ɾh�h�=�=��,��	������c��z�w�_t�w\��w+��Ó*�T}V��M0�7����o��ߍnb��mG:x�j���郾 W�ڏ��On��~�bimJҦ�U�M�{^R���jb��+��Z+�����O�'��E�M�����	l��Ѻ�H��e���g���1Az��zY%/^�A�#:�bU��_7a���ܩ�Z�}��:��4�0��/�Q+-��8&��W{E��_���]j�q�.�α���7F껊bn��9i�є�/�x��SH��<���4}�W���G���߽������~�_:'~��F{ɿ:��������j8�`׈��ϥ�^��஻�o�^���ߞ��g��.����f����'�naƶ,�3$KZ,��k��zoF�:L�ĩ��G��Z��|�qV��]ylmi�����!F���H��M��yHo}�.,�'PW_}�����]!(���O~��O+1q�e�Ƀ1��l�n���_�����d=�[@ɦks���@��L��95��}\����/�g���W¸X���#+j;���1�XP�{`�YO�L8��utwb��j4�z8�c�-}r�%]��`-�]C(��Һ�;�\3�c'�}h�>996���<�"���e;��������^��ãO(�Z��5���t�W��,1G��1x�,{����?�����
++��U���_�6��hk�D�I��*Z��`�#�d��!�+��c.��,��ހ,�{2]�!'��є��x`���ػ�y�+�*V�5�/��A%kd�뜒_���M�����4��;��Xbض����F?����3��,Jɬ�,Ɓ�%E��f�u���8B}�h}���°o��x�:����(�D�������?�/���?�=�����*�W���t��1������E��(�?աo}vQ�'_�v%~�\���,���0�,��C�g�×m:���Q �����Gs��Xi�ˏ������[�����r�6�L������%���8���o+��w�k��׾o�W�z�}ۺ:W�����	J�د���Se����\sm�ZLa3w3穇��r�����l�������0f��=����F��;\�u�w'������+=r��
+����//�`3?�<�}Hb�;W�[7֎�ZTc+j�"g��N$bh������Q��=*���O;U۵W(`�X�˻t��2�G��ž�=���c皞�}�xnD3����{+ҟ�������;�>o���'���x��Քݏ�z\�ӣ>K6���|�D��&�]�'�5��CC�0~��������_���M�����qMy�B����I-Z�D�xT�u�>Z��ԅF<h�3Z�+��e��w����Wۏ��Om7>�Y^+���)e��|+6tt��6�I�b��Na5�D-w�ax���<�κA��NeT�e��&�sFR_��P�Z�c��&�bת=.����:_ ,\PϺ��z]���t�����G$���ڐ���T��� onI�#���B������l98������
+2<�0��Y��\}�7��ZM��ț��X������	3��K.�t�џ���>m���1?�=?��G��G�������sk���z�߅�����a��|'ұb�9�����e��oz!~V���-Sn+��Ѕ'��WB���Xq%[�ɞ��	B�z��8���'b���������[i��M	(rB�� �JH�6�ĉ�Q����bT���ڹ��򖷃+�%U��C�����[-c���G1K�2�t��K��e?�3�Loi�3��[Rvkϒ\�G�fa���ײG��&>�@�h����p#�_�G�RuƉǥw�5�+u���܁2�<A���Ѡ�����w߈�莓�Z�,
+����`<��/��˟^?��7��Uyl<u�'$�[		�:����E}�Ӫ#��w����
+n<�S�����
+��\�o�T_��Ο��}\��z�V����8��3zv��	߭K{�*��7ޤ��߳�v�s�M���?��1�;ٺO��CTaR.���yd����:>�x��H�!jXu���^U��[1D�����G���!�Vrz�X{�t�0������ȸ8��:��1Jg�N|���o�Ao5��R)ѹ>�_y�9����'��r�H��,�V�+���]�w �]+I��8���>@����E��.�n��nؙŉ���?�$D����1x{������e�ԕ7�!W��n�y8�/%��ñ�x���G]c�0k�@��b�x���Ҭȡ����ӌ��Z+�ֱ9u΢�k�gOO||�K_z��~W�� ��z�R9�������9?����¹�nx�q�v�PgSG4�+��c�X��ߑ��ڬ�U�lo��3�
+_7�����)A�[o�0X+v��w����T[�f�ť����ޮ')�H����P����NXj���Eo��(=��w�4p���`��5��J� �h�;l_T�!�=g��-W��dMc��s�5� �x�.��ox	�\H����T�Z�����"��[bV7��юp�!o�Z����/5���7&3��5>�n9��1���+���W[�:�V���Q{\��m�K�j�>8�o��T��D40����f�dJ���vt�L�[�`�^tR�qS��~�|v(��P���{7��vf���,̒�8�R!�4��+o<����#��q� ��>�UG��j@?떛�w��mfuέ1k�<1v̠]y�L��������B���vL���IM6�8Q���zcsN�F�D|��Guo�9F�^ռq,	*+��_q����5#V�qF	�+�ΞB#�i������z��#�@�5!���rN������}
+��Guj2^��C����?&)���q����w��~]���t�O�+�Ӎ�������Q�ˤ�2
+��R,cWm�#i8:��&'+�"I]�E�vD����W���I�~�Ն~�kb0�h#Pn��>0�gC���P��Տ/R�c�Mos���������a�{vj{ϑ���+�0I����x���~-�w��?m���=��h�@���!�Z�7�U���;�۟�[�i�*���6�e�m��S��A�9��:�.V��2��с�e?�>SH�|b!v0"�ո����!]0l���1l�52���y�\}��C>�|�^�~p����M9�>`a$-��J�r�2�W���Ƕp��̻��1Yx��"V�C�� PԈ/��V�6�8�a�^'�4|q�r����������A}��@Y������Y$�&�p��rҜ��F�n��ڟ�ϱW���x����e۵��ˏ�Z��|̟������[����SkK?q4�LPu��=��YkI��<'�K<6m�6~W<k��V1����O㘵�B�{{��n}�L������5��^��ySg��Zc(y�A�߁�z^�����)�� ���)��+1Vf��8�D���_<�����'P�'N�/"C�L��pTU%ܸrI�x͑ |.Q�ǀ+	ƗU�����lS;��+s4=1���,
+}��e
+�k�k E�(o��B|r�_��d�G�/._Z��	��:Y�E��H�e�ݶݧϨ~��_�'FRCSM��:>я�y:+�!^�mǑ�	�We�7�x��Q(�^��"@�'L����`�F��1�/a�X+�(<>�r�1���л�mW�_)���f�.5��b�p�(�e��y�M=YY�t-&I�����^�̏~��j�ӄ��=���b��9
+3�4��Xymp��_��lk�ZOZ�^�H�[����&��+��Y�j��!���!������5űK�y\z�3��	���,9�௫S�����[O���"�{?C�s�8��m��_r���O�l{ۻ�<�A.�t�:"n0Kӯv��!��Q(=:t�@<��;~�3���XO�o������AR34h{��B��ꜷi*��ꢽ���؃�<#��NA76�+�u(�2+����v^c���NNs<��Ǐ��bb��b��|L���W�I˜3�u��ǹ�W?�K��Y�ys���&���~�_�J>]�~"d��sඉ/�U$���Z��,ݵ�W�~{���[��x�����w|Ҵ;[��\���k��+�)/�'H]s��'��qT�]�:�	��oUP�e�z&�E�{���׬�Yc��Қ��c�.�J�)H�����q_��Ehd�Pqx��Rx���=�G�4\e�H����{��7��g������<W����Η+��G�4h�Gh��c�\�r��΋2؃B��i������VA=�3ԁ[��Vg���X�s	e�,�i�z�4���.X^�4����x"�	�[�:^�Z�v3�u.̒�_�Z�hӮ��g���;�K��K��8�9l�5:�~͈;?��On����~��!*bHu�J����5?�.(˱�4�v(��i::@j��zG����u�Ǘ꡷[�V���d�a���>^��9�<����<P��ćvbI�Q�޶���U����6ˇS����W��7��?���zA��_�����۸^>�˄�P����
+�=�����O^]Þ �rT	"�co��]U�P�?`5!㚱�jO��y9ؽ+�h�=X��%Ҹ��O��]�vJ��[P@Tc�@�A+N�*i�4�n͝�%�i�5#��\��d��k�]��ß�b ��9//A�P��B�^��4Z�r��煓��g ���	����#>�5�ܸ�ĩ�h	�x��+����F�k1"�e��;,�/�k�zڭY[Q0����'���!�v/#����o��M�B��}��	�g?���?���[�cw��}�kO�]j�����"�o}sjA�'
+�����&v�d#޺��f�u��?�zk��V����T�����<�4�׽���NA ��ol��H&�����8�W��#٣��Mr/Uk,o�����?}���?�#�8������o?���-}8����NDzNf�h�&`5��T3P��O�)����	:n�}�H���;�A��3$C�4�0�j�Bue؞{"k�ܤ��A�����X�Ob��3�ˠ�`�������	��G18�y�
+�@3�����:L,���x�1������~&�U���15V�Z�`��sg��=�S3�	X_�;Koѵ�x�e0�F��H��X}uۣw}��<g�s��y��h g��^�B��ܖ��v򏋡�?��_��_�I��(Q/M�v�U�أW�#]�#�H�%�+F�4��m��+���ٙ�`΂��L?}bO*j�G�!��1?�/Y���'^����4wT����SݝCF�����On��,	�r�/+��_j��q�<u왠����/=���1}h�j_�[���W��7�G:�+��,��fl�(�ɡ�G�:�S��^�Plq��D|��T��0m�z�H�^�Kd����i=Ԋ}�Ƅ-�Ǧ��Ë󖶼�yHL.���3X.�Н�1��C������[��	5�Vs�k	�i\�f�dBtt]l7ٴ-�=�$���=��+�;o�7Q$,�����#�J����j?G�R�R��?j�~�ܻ�	���	����@"sI�[�z3<+y.�17k��7�0�g�la�0"\�p���9I:����{.~}R�V�i�>���lx>K�M�ŋ큑�����V.V%+̔���w���7Ĩe�6s�"���;lC�+P7<��\Ǉ�JL�St�����������=�QQ��]l��x�=��47���:��l�z����^�1��.s��ĸ.��]�����=�:OWN/k������g��?�G�_���jl�F��-$+9xD���?�g�Ė#�f������Z#�܋ϟ��o�}�a���y7`�|?{A ���Q�/pʣnQ{d� {n�:�AM��K�Q�Ѓ��Z��9N7�v��p�5�7�(��ʜ�J�^
+R���Y|:R2�{�����;N/���(��B����ko|�S}Չ�#H���vt}�)��1vS���q�eڜحa1������{'h����&�<�}�r�E�9]ي����e�4���S���R���`�G��d�0,�CiGު�i��FP������q�ď?������ Y��������1�y?,7�?
+�o�Z�!���P%�yx<��c��˰N���@�D��j~�;�^�^�^u�<�>;q��tɿpܯ!�/��w߭[�������7���L�lao�&w�D��o������1���ާ}�o��o=���M�Nf+j�U�~ۻ��Ff/���o����~^S��j��mu\ͼe!s-���x����r��E�7X���Mk.��!0���[m˯hC��u�sх�ؖu��M�����D��	N�dS3���;fm#Gh`ќ6�ڌȾ61��n������i�	<�'���$y������7Y�9�+���t1!�z`�}ft��I�P���`j�9G����C]�3��iA6�h�8��%O����0m�z���?���9�q��i�0<{#<L�.�|b?��񹈎�i�[VMau���0c46��8�C�����@� ��?�ʗf��k�|��ػ���r��T�6��~��['��B�����7Ey�>+�l�}�Gp�o�:��їB�J�d��b��9����.M�I�3�vw��cQ�BƁ}!����Goy�o��׏�i�L;������N������t�8�.SUrA���\�'8�[@nWPt�1|*���r��5����ٟ?���&):�%�D�ƿ-�"c�����c���%���3�/c�O�~WL�^��G"�R7��;b���/�������s���Q���yW:��L;���u��#�3g1H����8��8��䟚��8h!1^�YvTT�@#%r@RT{(�(�}�}Ӯ��=��w���N?���A?$���4l"L�ڸ�/�|��_=��/}��B���.%0�m�<��0f/@���}QUP'���"w"�X�P�/!���^�7�+MXi޲~�1�η�|+�4��ܘc��w�KҞ��O֣7`��K�ep�х��R���bsEf��z��$�j���1�h�Yٔ����\��}'��?��͈O:k�?e\|l������~���:��{�7���(��p�Mfl�Z���qL%>��9Gb�Ղ�~ܘK_5j�	�l�8�O�<�S������i���g{𥁒K�Z�B�k%�1P^a�u�3�����:�H+��=�|�#��=}JsBM�_�f�oD��7���z�y׻��=�u�����h���#q�C�H�[���+�
+K��-?�O��Y.���ȴQ,7���,��HIH����[����Q�E#q�N-'�>���t9ct�:>��-�:��$��������zx��KVXN������|W8�����|���ut�����E�?[s��1d��նu���z�X�{�7'X|�D�����N�G`�M��?2��D���R����x�ձ��zij�����7`���k�f�:q'>��?��~:Ϗ�$'cT�S���#z���I��!O���"����B�3�G������^�7`[�t�w���6��<�q��{����}�ߜ������*x�F|���:@��S�><� �jկ#���?��O�\T�# �w�b�jD4I��M�:���x|Ъ�}	VƄ=�Z0!J1�Uŀdg���s���e�3t]�b�Ŷ���W�#�>���	�?>��tXz/Ab��?�1��u��ƞ?����4f�Q@TQ�c��'��1���	�z3|�op�����P�9_.D��dx�E�_��v(���xR\�Xj���U��sϝ��o�Ԟy�%�*�؇��^JqN�۽Z��6+��4a��^�`�m:7 kDȥ����Gh�w��X�^G7dÓ�\d�}�O��5ʝw���y�;���Z��Y�����8��o�
+W�g��'��	�I���`������}�1��O�q�vԦ���؏Y�<0D$��z"��µk�.k ��K0����{�&>ڬu�$���4���?�H��R\D��`c�#*Iۇ>��DT<c�w�ه+����=�F�T�8܌�щ�!ŗ�zy���Tx�[����8~Z��������>�6.��O�<��o�J8�����Y���s��W�F�9j��s��a������7ya�4�K�-�3<+M|�7(cd�������ۚ�w�#~��}0���v	2�U�_���I�
+'+a�d	u��/�6h���_�#ݦ+OM�v�\֯'o��8��իW����g?�٫��`��X�K����RZ���b�7��Yލ����~��7R��&v'5��/'b����Q�\kd�����/�D���v��.���bN,h-dB�*��z����X99h����;��l���	��q3 �54�D��%"�W�κ�7�G���I�\7ƆM��s�i�ٜ��x�\��c��8H�N��Y�g��4fIl��l+�5� .��kѐ&>�j���FUS��l�а�B�+i���ٱl�Mޯ.� -7q����Ot>�[����A.=�(���u�N\,������ 8Ko�*�9\@����'h|eR#�s�;�Xg����],v��r��P�'�Y��[IG�H�7�������V�	>�M�ۥ�.�5�]�7ZW�5�rz+y��ߵ�8��=�CҲ{]8^�Ck��ă�4�;�q��_���������?G�O��6������!�u��X>��F�1O+A�r��~��1�����<����.�b����`fV�8�]��!���wp����?��<��'��d��|F��=cH=�y�ɑl��'���Y'`�	���5��W�!�4He�ޡ�/���FM��q�mA��R��_���m�����9��p����l��=ut��$���3�Қ��t��5�D���?�zO-Gf�[��J��mDդ��`��ڂ:xB#�^�+�ic�:�#���r<�/�PS�������[���b\�<�-2�P�y/.�|�Z0Ƥ�+>��[��:�5��2~4�8]��,Cx�vd>Z+���6b��A**���&����ʛ�3u�a���}	j49��Vo�0[�}v����`|�-[�kl1O�<��s��+����{�/��v�Ղv7s3#�3Ͽ�w�?û��[4.�>���&��uە�^Z��^�>�o׻�����_��k������Q�k2�����-%�Ii.����!q�מkd	v����Inp�h�<�H.0CC���)�]���o�D�]ض�@�5l��b�#HGEd�m����!��f���b�_�<
+��46�s��#=��q��\�#��?���&�pں�#2h�nlɇ��~�+�Zk�SS􎯡cn���A�C�eC������!���|���{�+p��8O.�
+MT��,kG$fQ����ﹻM��R��̡j�F�m��ŹV��
+����-%�Ԇ������׉x ��G�lS9w���c�ه4�	|��d���?��Jj�x%�a}[�uǾ����!��φP��mT�a��Z���A����C�V���_0��^���Nq�b�b��������`+�,�M��\{��m�����9蹯�׿��??|���?׻������Q�+�-����u���ِq������8��֗�=�O��v]�2���O�Ml���6�ݑ���A��;���p��E+b�J��Ɨ�Z��L�`�W/A�e�5a����!����E��V������� �v�ƪ�����`P:��{;-������`0f���h#��Z�M{��ϑuAq�dw�o���C9���#�tu����&񋓼�W�F�9Ј~�)�<���7��/�S���OJj������	+"U1cSO�uC܎�?���z�e��%�����(�K�.KV�4e����;��6�A��P����=�w�G,^v���4p�� 8��\�ͦV�z6�!�S�B��L|������[�c��?<���7��j�l���x'���d@����x�8�Q?c�C.tn�@d�ƒ�:[�v�kL2�p*F��:����"�?{���j�N��^�
+5e�*ܝ�� z��;*�g�Hu�s�Կ����kȿ�L���#yL����[�	�/5'	�R�M�K��%m1��6n�+�'��Ơ��G�BFu��tG��uݑ?����p��f�+Uc���@�Úv��ޮ���9k[o;ԟְ�6��],?пּz۵��Ejuę|���I<� ǜ�>�"��Q4�,Ld�,^��Am6pC>x��^��=Mf���'����42�`�.�͖������=�)������"�C�fkS����}���/��}���죀cS���{��l	����A��ڀ1s�t�����n�����:ڳ^D��	b�]�&�÷��^��w~��=�=�<m`�
+�Xwg|ȜE��mr攵�ڢ�3��2{��G�����x��y=�ű� \�j�f�U3�r�^搭��U���)��;��Öc�s��Z�f?�;���us&�+o�(�&�ڤ�g^�'���i��7��\�e^ˇ�	~i�_�C{�{��AU�'+�o�)��Ѓ��޻1��@$KZ0<������O�[1�\�M���qﾞ������^�vzⓟԿ��Y[�ct��nʻm����(y�5��3'�)�d^=
+�](n�6�~*���xlLu�2P�1V�h��9e��X�^�5OG�iۛ��N�%T���}��(����>�ˣfr.1m-����G��U?j�?;�'�7~� �36��)x�-��"~ќ/	:~��7��q�����[.�Phh�����#�>�+���"3O0���|�W\�,J|FT;�_%νIǾ5(m;�/�B�Dkt����y}�$w�)IJ:{�|j�	8�λ%ڷ�+����t�`7�}������!�����g�������%�س�sU>�7��[�m�C��9pڡ���1r��C�r%al0����mMC��84U�Xw;yK�_�=�!M�P{|B�&-|G��c�7(>����K�+逡 2�B��8��y�WR�Y8�]�W5d{�.ޠ��ο��qoʚ#n��*{$XEl���;�FG���rD���e�$T��\T���TX�R #�0
+gQ��G
+�&7F!Zs��"fs�d�,�*�Y�][fX |�H�z8�����8�ٓ,H,h�L�]?���e8����+�{VсPM[N��ſ:������µ�i�'��m4�1�r3��[�JV���Ϝ��ԧ�7�y�.s)���,�]*Rߡ,�����4RT�ɧj�-P�6�/j�/2P�B/cggt(t��F�����1�d�m���+��3�ࡃy���J��#�4~|���ykSʏ�.�:�����6�1e��b�F1*�@�}�����v�.���+^����"�y�s��.��9��~��8��or��Y�����H��{`�6�� �r�;G�"�]��G;|	�!Z�����o������s�=rE'�w.ƃɉGM��Oq<ư@t���%��~)k��sG�f�Yc&��CN6���okb���:���6�Ј����C�- Yۇ���Vt�ep�S�K9����ʜv�.�G��-`��;���G�E�^�X�|��Ī��Y�X˗A`�$"��%�}�C,����d�m���������~s�V��~]�������M�KX�XQ�y]�]얶[7_Ԕ�Q~�~R5v��Ǹ�ӿ��l���:�v�8~�?)������+�U�rt��[?�\W��ɑ�K!��z��f���F6��u�a�I�W�ذ�S�1#�+�p��F�۠�s�^����\S\l透��#��eD����9v�9�D\�b�܀)/d0=�skַ�}�O���ܐ3|	>��N�7��8V�f��ʵ�W��������Y�9+q����Y+
+*�:�rff�3f+&����+��l���n�ZXҷ͎��qb�$@<����o�a�y�6�$b���n�u�gǁZ���>�%�����O����N�#s��Fc�����r���P�N9P�m�A������C�4&����ٱ���S�T����Vp'.:�8Ť�y!��D���Xj��M5,���g�KD�}��v)=�/����A18�v���[�~��������o}+�lЬÏ�6�V�C�l�hW�u��1����W��>��O�����|r���6q��\&9�"�ز0B�O�my�����������Va]ɬ��?�[��wl3��c��ǒ�ķ��੘���OHM#7�}@Y�4tM�0E�1�yR?�"+��Ah{�(͜�	�r��QH'��D?�Ҽ�Ƚ��-}��+�|���?����uym��>���'~�O��q���a_�F�?�RM�:%������O^'�M'��ޫ��μO,:ʁ�8�^�h=�Al|�¦\�=��K��3������j�(Tʹ;_�X�7�Y�׷�0�®a��Nr��<d�1o�l�;1���-r�b@n���l�kn ��7v�:fᚻ�ز:,�Ԁfyk[b��紮G>����Hl��dj�q�o�ֽr��SO�^z��[�?��G�{SF��EY��������n�0�����܌�+����y�Õ�:Ds���X'�G���Z��2���UF=8��/��0F^=>�E� {�%���X�B������vb��y�O�����]
+��5��/����(3���㣆��\9B��L`��rk�(Zr����"�o,��f��E9�͐���>��64�{j�S:���+��)xp���`<l�m���0x(�xKr��I�*�R�~ `�s8����f�8��rOH����R��0�<6�pp[�C���R�=6��#��*sYۇK�M��*��X�>�{;+GJpBZ�܂I�/U~�����q��wi������Nl�0I\�=Xj�*���<d��\Z��A�R�c@8�4�pT��Cl��ѓ�"��s���_�ׯ]����9	3�M~ꊟx��k~�i���u�s����Õ{�7OT�Ѷ/n��u�K?~Gf�����0�b#�oND���Vk�ᷨm�b��#a�x��5�hHp�`I�QӴ�<t� ��crP��d쬓��){,�-����YT�d����:���ӽz���=^����{��O�?�����M�!<��֯9��7�1i���8}R��|�+y�;g	�z�׿�0�nhj���jg �'����$�����sm/	gU��Au�2����T$��_�sy��̚X��CT�cs���nd1�w�R�c:�����q3�r&���+���f`@�=����c�lt��q~5l.��t3}�$��O�%��"��|Į�x�qh��10ɮ�ۨ�@�UlQ!bI��Ҭ�C+�Ǝ�v,5��ն@�`i{�`?��5�?X��rLޛ�i�/*�cq;o��L��M�U�v�Z����XFF�4��j����N��c`�9}�� �w�c�F�xjڜ��+�crdM��חڪ3.}z<N>���`��|�\��>��<H�>TQ��y�� �*�����d��@��N<���g��O�T��}l^��_��t�q�O����[ޠ��W�����G��~�Y��2��p:��3�A;?�V��[�����O�~�A1��\C���G,� %�~3ܑ9�y$��1�ɷ�b�ƿ9J���L��=
+���'*���eP�R��E,2�o��=�t[��%ʬS�Y����+���{�{���S���"�Ο]���)�������O�|�;�C�y�����3�H�G�'���d��AΛ�}"�CG�0?=E�� ��ȸ��CW9�IՄ9��3�1�65�����*�F���{�O������7L�g:�,�b]����@�	;>��	��.�Sij��c��hk����Y�b���t�C�9���?�Fb��g���'u���<���bބ!|��"zV�`���QL[��a��v��(pLNܚX�;g��m��!��c��:gI�0�JP���Fě��|י��|��J������=H2���Ш`���N��Ǘ�X�;�C�Fx���@G؎_���?�&���O�:����أ�M{��Q�F4�_�zsow��5�'�+	�ÿ%ʭ�+;�"V$0�0���K	��S��:�8��� &V��#yCo]P��3�j����f���95!�p`���Qߨ�9�S�@�eA�������P��H-�\�D��K!�E��D�|Ǐ����395�Ql���e�D��ݩ�f��CX��a�q�?4�K�vk�c;N��Old��w������;!���r$�xJ���ɿ;}��x޵"��gd\����){���g��X�~�y��GO�����}o��#�qS3=a��Cj6��\r�.�}���.,��v<p�;��&�۰	2�\�+�x�x2Ň���w�������s�,K:�%[�f�7���%m���cp��t�)�L;����t:Iӆa
+-�Z�e�e2i��Ml˖ddI�u���~���>�9��tXϳ�k������������%���c�DJ��K�`+�?�<�G�=N��s��z�+f�o|n�ۡE��Uv�TL�jy}�z��w��<��|�=2�3æ��8��2^h��>��(��`0̴ؠ�뚫N��_�$[�.��%4���1F{�î�iG'N��&���(��c����g��g]�x��;f�~g�:�G�U�w���Q��K�
+c<�����Y�`���x��#�Q9�Ԋ����@��]�Am�%��	��x�����a�qI���B����#���������.��^|�E»,;��Dy)v��Jﯨ�M�z��ɟ�I}�[�c�t���D��ە�n[�Qi�����&���Qo��(�]oኑ�P(=!��\�`�H�Q�Y�ر��n�e���F�M����W�.���%fx�r�\t&Z5W>ͯ>����|�K�/�
+Uo-hx6>N|8�~.�y(`v0ť�l�gY	1���O]�G��᫙{7#�����9�Q�|P�}G9�C�=${a|p�8@�"A���c��G��c{	��C���m�0�Gi�l�R{��^�&���o�g
+�z�gr�aL��*�y�-�F`�g[!\%q���Bt{�$!\�<�}-�p���bY�m�u[��ئP票ݦ�:&���@��� �0r����ӓ���Py!�Z1���_~�����Ϝ��_��ӛol�'I���56��H��{���99�1��U����'
+?��O��������B<v�6��5��>c��[���Nr,�isa�-{J���l����^1�fbk?��+;C<�L�RB�\��<4Կp��Ȟ��v[�� F�U�<�]?�,= ���؊OP�,ck3Y;�m�ZZzړ} ^dB����a��)�e߿��=��f���^j%3#�>|�؊ra��v��I�E�.2mğ|�ӎ�l�g	Z��:,�6���/�+4�{� e�q؈���ұ������qi��rE���a<(��M��k+5�4U�Y~�reA�A�1"X(5]�U�p���N�C�xT3�x��8r�dƎ�#�����7CLj{��y(�|>""9y�;�5~63Z�~=�V"�b�d=����G�b��1hh�Tm�hr���nx�r"9g�_�H��g�N��t����9�I ��g��O��S ���1��7�q6ʂ�v�x/����>�KC_�>yęP�e��y��'	�]8y���V|�C���9?V־J�}������q������gq��`S{�aBqC���ā����?�-S�7���h�7cc�R|�C����7��[��
+	�U��[��}����p���+e����F\������&���_�����<d;�Br��2��yK<w�B:_�wg�A�d��Jۇ��<�6qȢ�Q��%ț���N�j��ײϋ��+��h�6������?�z��9�лBQ���m�� �W�����n}�w�\��H���*o�����p����z[�0oܼa��Df]��zQŲf�rD��Z��S<�=�p��d��2�J#$'ov"x'�Rb�S���s����.���qZ�D1AX�.����~}���;F~b�v�F�6S'G;f���n٨Zb�YPޙ�>i+�+�c����C(��ȍ�^��q�c�X�X�?�ݚI�q�e���M�S7���3�FO�ɬn��<��������� A`V��>$i�T9���ܝ�1�q������'N?�C?4�p�\�H/��$��y�!yV>����J��$~6�:�|$��n���ݠl��	�����{� ��7����v��{���x4n;����;�䑲=7�8i�A�9)�ٛ����{����)�3;�7ikU8N鯺$��?Ԥ�DH�f])�_D�-W������3�Sq��Y�蠛j��T��̲�']�����	��}�3�;"k_�����ta�+�"�G��Ͱx�-ʑ�<̼5Kx?j���G�d���^	�c�z�v�ጏ�q�({��d��[���Kl��kzԉΤ���
+�ˑٜ���ql��N�뢿�R��X���R[#��1~��Λ�K�n���g��p\�;�m^1S������]�"�hj?x��Y���>�,nGF����L�<���K��Ŏc}��g��;z��*{*�z�^��:���&<���xw�x།�Q��pA�kN��Hn�|А���������\XΙa<Q�Ck-ġ(�z�0k�q;԰0��b*��&!�4k6���#��x|i�G�t�-�s���$�ο�`��K��Z�K~���+�l5��c�NDD���A$=q�(��A)�+J̇x^>_0&�����:y�QO������A^9 V�p��9���G�(�jgظ`�5�VQ�T�'���9s�����vP���l��%9>_�Wn/�f�_<��d��O���*�Mj��/R�'+��7��8���M|�<y<:Α�4z��$|�D�&/��a�!��ن4��^�ł=`���='V����|RS�eis��^U�p'����N�w)�~|+�q!��lD�lw�0l�hȏT��`#w,�dGt���|p�?��NƼ�c�Ck�.�-m�j��h �2yW0�#���`�;y�P� H�O���Kq1cc�OR�]�:_g���Z�!|칀K&я����c��S�%㒓?~��WV�]�g����^��1`Q2/�|��J��u6G�w6m����up�c9�����M��sѫ����x�o��T�!Ų��D:=\��T�0v4U�h䦼�`�h�kы��7?\ʼ�����u��%z\4�����N?�K��o$��ΏΗK���?��v���}�G�9&��9��X�P����<�?Ɗy��QV���}�&��CcQ�#=й1���kru PZ���VTv0=��Fi�Kn.;o���5�-�U�X�c�58c���	4c�?��r3X�4�.mQ�n1�� f
+2���LZ����U�_ͪZN�e�C��w�e<#�}�?��O���)�4������D+�~�?=ٷ�d�A\0�e�k���σ^;=~���=7����R����s�|�)����w+8q�zO��0
+�I�:�2P�����u��#LWv,�&_f�<�rV�D�I���v�0�4Z/��+�j�_%��K��e��݅�m���_n������۷Ŏ�նC}N.��lV���W��>��� kIڳ�E���$HwG`���}�h���㬷d���2�#-��bG��#��T#������P$���ʁ�Ġ{��2`��c72F���L��<��w|����c޻�C4\ψc	�ql�j���գ��C�ڳV���^G7qF��R�����G�sj4�b$����7��
+T蛽�G����t̬��,��+�W��a����;��s�~0�U�hݍ�����o���n�����o��?_�w���s�}��FD���3�K~�9�"�lz���!s�7l�E�+~kJ׿�/�Ջ��5��6��U�Sv���Gl�z_/�Q��������~����$Q����w�;�����=�`�.�����|���뮹�%�qH
+��9���"�:㊎KW�:{�Z�~Mq��g����)[[��K��y�S�8f&��~�'��A�v˥�s�+�j��1��u�c����h5�*���|�?�ʒ#�i|��,	�(cat��	�pT�9�r���#4R�j�?L3���#>p��C������.���g���_�ݿ�+E��G`��=�{�?�������~�h�#ra^�@�Gr��x�@~�('�lP�6P	��
+^��muկ�9٣ey�uc�����후,#��|� G�b����tԥ�gr��؈tQ�Ei���/Cum��-�h�e�'��GxW{��{��c0(���vJ=��ca�퀍�����n_QY�=j���F�i6�C*���eW��'t�}���>oWmYZ���/o������jXH�Z�������N��[��3+I����[k�)?Ya����[[w��c?�c|�i��F�%��.qm�k���+��X?��{�;�p'��ƺI+>I��w}S�ցްw|�6#:pT*0[����"���nc�?�!��9h���յ:�ꞻ%��"�&�fLL<�o��F+��BVG�!��X���[�����FVu�Mu��/&J�%y���i���)�Gs(��M����>��y��i�9푶V�À�;H�02�+�-�,0[�
+S�+g��!��c�¶8�E[�������;h�<�w����r<�"O�WkP�KX�)�䈋�@q�+���dPR9,��#��0/m�����Ѹ���j�՞\t��p{�x+5:��D�N�5��6(���@;��5�6�6�*��=��Λ����}q��a�b;������.0��������o>pz�Aru��x[_%���nmȵ�s�6r��˽���}��5(���!�_�_�+�w����3O�`���Ա�QD���_I���e�b��z��4#x�Q��c�?>��E��4-�x*���O+©9�<��g�t�2�2籬�Զ={��>>���(�3V��ߘHM�����s^�xX#o�h�V�����
+��W!ejb��t�h0���==��������}J�?93�JL�)5��yx�ĳ��3ǢH�����_��;1�T{Y�\fa:&D.~���|e���xR�,^��H�+Y�����Ib�hN���G#~�V�=N��v�55�����l:؋��y���p\����e�=�'(�@G|0�V}�=	�x�-0�u��n��h�䠮'��=
+���Q���ݫ��BiM��RB]���|�K_�0nr��f-'�{��N1L�����z�G��pA��0���@�>���3o����~[�@rF]E�rnt{�l�1�58q�?���yM����Lk���/���������%=0�r4�ιg��4Bi}�6�8`��|��7>��N���.�p��n�6�o�u�L�x�]�x��K�[)Z�pb	\2V�P9N4�-�=�Ae6�����%12fN��_���R�� 0��ν�(-HL����!j܀?2��΅*|h��\PR��-����tV�)ַK�C�u>�P��f������?�S+���V�F�Y�&꩑���'���l�$qPt\�����o�Z:⯔Q���q��}�V���xdNѮ^�K�"^"��;�}>A͗��J~P O.m���[#��1��7�y���]�����e����6�����&�E|�>%�fGb����v��^L$,��:�3����t2�����p��R=<�`d���@M>7׾]}J��bG>�F�����4���Y{H��Ek�:�-}9#_��w�`21{?��͚�6�^�h�\$�\+خ}C��D�SJbH��׈˷�p��C��F�ǃ�|���ExcQ���#���.���Tg�O�G����R�l�_i��!G�|�]��0x�'"6h����h�.��Q��X�[��U�e�+>1~V�����R�9�\�'��7r�&�أ����8V���/}ˍK�[��T��������U�s��|���9ڝ�ʶF�{�������+�-�)�S4jJ�f�:�÷����W��H��G�{�����}��\�xN,�񞦱I��T.�@Z�c�ȁƈs���ɱ��4����K�xG+�������R�����`!>ۚ�%�4V(�K̹T�\��wțS`�jL��e���v�(�[x�,�U�(B�\/�؅��s�-�uo{�����|nG�)tl	��>d��?���������\D�c��;㟑��1��jo��L��E���$O���?�V{'�r"}�8���B��$�=֚�I+�Z�P��!���̅؆��*��Σ�>����9z��W[�r,$@Fx����'?����tܚ���.�3L+� �sD�E��У��R�y�0�0�m*�^���F�0���ѵ�C��\�v�}�ۡ�XA���{?�Uo�E��h8O���g�3+�_~����cD�ӢY��y-@�������wWF'h9&~f�Ĭ�4G���\?�������qC�d����|sޤ�pG�\#e�}�T<�j�nJ,�=�9�#�*�<,�$�#���O��r��Б������0W#��$O�8&y�ڜ;�������ɑ~�朦�|���=,c�ҩ�GM�E���!���{�
+�2�OĆx@`%oJ�S|u�m�>/���.�x�j���j�e|@��)��?xf�^՗+|�G�}��2'yHl��/U��+{	��X�A�i�X��-3%��$�v]�<����e�C<��b�q��{��lܤwt��]c�oS�����R#�=���x߁߅�����df���w��>��ӝd0��'ٮpٮ\�bT�۝��yIWNj��9���&�E��"�d��D�A��0?ѥj�Řz[�,fD)�V����K�� K;��O��P���]���)m�0kvE��#�0=y!]�8ۜm��s�ʆ�s�����|QK�&9�&6!���emM'8D�1��}F/�v�������5��Y�D�#W��h��t�3t�D����<�wڭͫ��]�	����`:���^uN�b�G�""i�~:�_L1&${O=���_�O�ہ��so�45w�z��z+ŮH�}du�K&�:j%z�P��n<�>�z����V,C��������2ƥ�C<!Vc������z�Ѭ�5��9B5�0�kl��7�50m|+HELi`+;ғ .��\���#���`���в�,�9�Xpɑ=6����ǚ��K �C�}RADt�'��W������=+%6L6I��͡�h�L^���Y'��@ָ@�O���u�O���=?��/�����ӫ���eb�����T@��N���S}A��d����3��՟�<�\ /����zZ��|�'j^��G����A9'�kǣ5�<����-Kj����3dD�BNe����~�'�)��[.M1��̛H-ًy�n��S	���cp�}p�V7�\ ��b�ZwOT.�L"�hF[�-��n����W��].�$�R�<���
+���l͏|�b�K��++>S�j�����w�����a��QhikCSY���:^������GO��N׮_�����z�/���2����t�p�B^�À."8�#KZ0D$h��|%�#	�<��Ge���*DPy&'���������k�W�V��|���w��[G��g��FIǞe��v-X����w��m��#��_�x��#�Jo��n����|v7���ĉ���#Ȯ���7w�b�F������7��;���l6_�2�5_5��?ftD*G�����^��}y�׌�.E���Q�1h��j(��kd�}n��@�8�Ѵ���CO1�)��\�9k*�kK*�ޫ�ӭ�jۯ!ƈu�aO��x�މ<���C����`=�O5���?���M})c�/�;���j��d����+�� �X�vV�����x��K�.����������?��?��b�"R��K��Ks[���zP���O����|�t�'+]�	`�Se�h&J�����j.L#�1c�v�K�D;x4:�Eu�!���'1��`lA�� Sݘ�.��=m�E�ʚ��@�����i���v���6)9������N+ߏv$�H�����N��g�� �(8����V�	����� ��� ����?�����NM^��޴�V����_���zn�m��M�ǅv�Oc9��l۩������ш{"�k=��՗�֗�s�S�(���q}��`����H��8�������,�(��/��X��M>��i����C�Nӎ��Du�P�
+Y~�s���M�O4
+��k�D�,��K�ky���)_����q��+�]����oն���p�Qd�nM�x��ߛ�N�+�y꺾 J�������x������/�~��cr0`�P��v�M\W�v��!݁[mh��{}����G����?�1�5���E?Uw>�}`o��b�nj�r�H�ִ���i�˜Iӌ�np���'���Z^˘��������΂n����\�K����h��)j�Xԇ�)~���%A����;b�MPtg��g�kK��w���~�k���)�9/�EEʑ��eе?0�~��w��]���ء�^�!U��@��#̜�8�<J[�4��ok�@�oth�C��i��Q���7�����T=���u}r<x�W����o���U������o���~59��ғ$s��R�m�����eB��~�?��d^I_�O�ؿ��#\�4�Y�4mW�iOm��3�����`~��q��8K8�Ȃ�M�rmb�M�f�{W�ǟ���G�����Ԇ�;�pӗ<>�$Up��*�~������;c%Z�Hn����������{�
+�~�\��]�S�9��@Pժ{Mb��Ǎ�>��23�꒜ڌ�./���+,5�?�^c��z��6X��"lW�2_dùKM{��l<r�u����W/]���v��Y@�"�ᒖWz�8Ж\�>�Irô=��9���w.��a�.�GW���Ğ���>�����+BS�%�M��ǘ�?��Q����>J��,��S�%V�X;���h�`PVhw,��2�F|s�ƴ���2�J�E���+:�P�]�V?�O+��^q컑]<0�����s!����ƨ���`�Suƶ-Y�x�w�_�V���"uE�����6��6����g��\���@���]���������2�5A[4	��o�{�|HȋbJJ�)�(el2P��l���D�+�^�]&,E��
+�<��������=yr�֋1�3(P�����m�u׷����Z/�zK�lY��@l B0ƀ1��B%���M��U��JR	��6�-���#~�%Y�nY�~>�1�^��9}[��f��s<�c�9�k�}�=��x`)%ls��~����!��J,�=�s����X���y5���?��4��>{�i�����:〓�P�y"��+��������+c��w�;�mD��oFK�aS��r�g��W���p�a��]��0�@2NXiI4a0Z�FFz�1���$����T�ĩ)XdDoq�&���M>�t�=n}s�\��:n�|0�3xSNդ�ƚ��3��c�� ㈋�
+9�E�\��;�V�}$�T�Q6�@h�|�5'�F�<�Y�3���+�eB���t��a�\	q{h�����Em��y�ο�Ĉ�N+��=
+�甆?m)<�4�O�s���
+�,��V|6>����;���~�6�9�_�&!v��tL4&ּ�=��@��� ����6"uku/�����&<����OD���^�ͷ�Ȕ?�s?�S�������y2����͑�����ظ���%VR�����S3kl�#7Ϧ�o|v����O�g�G��9끡G̽t���4{�1�m�&���8��k*���\��t��)ώ�E��"9�o�j?~T�2�SY*�>��[7��S��c�c=��uП΃�y�$ADL�ȍ+�2pj�1��+̦Mu�
+T̈���{z��&�r/�����_�����}8�mLX�}�������>vy饗지���pڱ=V��X���8����V����{����ſxy�������8�o�D3#=A X�|��$�X�;��8��x�j�E0�8O6��7|�kj��ۚ�h��Ƈ���u*���9�>��8N��Kmb�릚�׎Y1��U��{x��B�?[��v�K�=���D��2|��s=W������1������Wv�F:���Z��<����
+]ǥV���1�Q��`�^�q�����n��Y*��O\��1�������Fk��P�����������/P���ʜN��5)�`�h9�MH��e$���o��z�'�+<\5};��k[bbu�����:������
+��E�i�$�_l����������4����P�����������<;��ع����pޔ1N�K&�Y�ۻ�Dj2>����~���sz����!2�]_��;6[:c���e{�Ì�ZY3W��+9�M?��6t�q�:.Az�C�m���1���-K_"� �7�+�\qqi����`�E=���1?4��ף�r�=�Iɟۛ�a"o�P��^�lS8\ڄ
+�J�8ԧj04��&X�aǁ�������:���	����u���,�b-�vC������o+)/�����нy#�u��^/�^%Q7-�w4ބ��<��+�|��J�@@9-ߘf4cj�>A�d)�+Cq�J�m�+�=���}M���z�&�-�}���;?�
+�m��I���+�tqc���;�3ex灮>�8��kp�.0'�f�P:}N����:R7AB3�4���ǯ�n.�#D��aH'c@�+f5����Ql��Y�07����L���G�Ɗ��Y@�a-��eސ弜]q���4����\�M�$m�򊮧�'�f����F{�l����k@vn�C����׺���Ա���7���j��?�f<cPK�ح'F���~��la��<MYY�/����*_�,~�@�.��2���f!Dfl0�����[c�*�X�sۉ2Nc�)�	�%��^���G��������O<8~*���0����g��o��4ϡ�2<qn�J�69��a�Q���G��]��_����?y�����Ʃݍ������������k쫌��C�:m��N���x�A稀<
+pM�sݸ���P��	B��3���,z�xy������M�a9���*�'���E�0�vt[��_YT�lW;�H��\�D���~}��۞�˘#��l-62۶�[u��h��GN��1=��f��Č�=/6ʐ�������V�ʨ�=6����P����=2MZ}Q5��K+��&�Z�f�<�3���v�{��+:|&�+���?��҈��_	���UGj�Oz����Ew`�
+�9���灮�LN[>������_}��g�c2�;�塯�+�<�dO��5R;�W<��lNx"{dx�-,\ԍ�������܄�g������e8����P�0޴W��5���4�e�������-:/�Ѝ�lۤ�_����(z��D���*�1�,〟@���̒����\�7�^�և,�>������n�d"&g�+/�-gdi�}�+_���/���x7&�\؞y9�E�=��!c�ԓO���4���6p�'���+k��s�R�0�����}���H���*�
+�=mu��:?��xo���m)9�G�up�8���-��f���c�M�ccC}�G���<_���c����`|��9�GN舙�+yP������t"�ֿ�*�g�[��\���9I�l���Mo�|���[����Iw�:�M7T���ϘK3�;T^�;7�}�S�A���MAr���"�{.�]�A0�L�Zᱪ��}��	n}�n��{ePƞA)�|,td��b�]��2�l&�؈=��CU��\���ʼ��X��9�^rΗ+1��iS@�G�J�^��������3��7�{,��4�L�+��'7��h�Hh��������ս2��zw6Or5��ʘj=�bkPq�=��O�H����1+�b%7��P�x���#�g�P�r�_O+.{�k���E�s�`V���o�M��r�3?��(���.���t� ���_ģ֩�(4�̝��<Uo@�	�M���{���i]b��q� ��/�0ю�t����Z�,|0���L�Mѡ�'
+��z��c�8n����X(�ʉ[P2��b�����%͡��D*.��A����N�+�w�G-/m�`����T��0�!f�w�HZ�\�,u*f�&P;>�����z�Z��;�	y�����u�u�{���bh���59Ę�l���ć���+r"π���/Q���5<6�ǯ�ڑ�$���ұ�9� ܱ�]�4���?(.Q��g��a�ǖ�;�,���������鳉� ӥ��A�F��]�~��^� Z�y�!(��w��ݗ'��6t���Ѩ�֚����W��.���_U����2@��6�1��2h�?�ub:���Pqe�l����$^md�=8�l*؃��}����)�U�"�_������������7'�i���G.Ç�ٚ���G��~����K��<���YP�"�uŸ��&9A�yX}d�C�r��:ӧ��"#Gε��^��Z��9�����J�	9���+�&���Y�8Lsx�_E!����Ѝ#jG7bvmC:���!>�FdG����ȳk4�Al�t��o��s3�+c	Ny�rJ�Mۜc�'6z�B3�ȟ������җ����m�6�WÕj�����+Z��x`�np��7�z�c���*����.<#���,F���"�l@x�O��u��ec���=���;>���b���kc����Td�I(?I��$�o@p"tCk��qG'w�#�-�ּU�3@9��	j���)@�ֈA"_�4=}ӏO?��S������c�8��ȆJ��)�Z�����(>1�XZ�I7r:��+<���O���{6o���wϩ=&���V�>:�`0#V��o���8vl:'�Qg.Xc�|
+�t~�����cظ[]S�����{�_��_W�v-����yu��O5Vu��u��O�w_�����$W���Y�k�k�8�,e,��N�>�e�c|~��%����Uֽa�N�Εe��0����9F'�dN�h��B��H;��5�zP�@ܨ_(]w܄	k�tFN8���Z]O��P$@ǻZW,K����n��e����\����7}��5}���8������9^������E�t�Czw�$�������Y��\�?����1�Y��'?��}t�/���\��������1��X��X=H�\�"���ܩq���u�v���Z�=��3�v[��c�2�E)��+Î�FN�qc��}����X�2�ο�S��h1�)^;+�Ů���)B)��cN�h�}�;�-���l#�oi�����>e�x.=��������$�^+ݺ���{W�z�ˌb7~k��駟����Z�����Mnk�r<����!��]?H(��_[�l{^Y(�Z)������y?��@M(�!Z�o$��]��Dq�����<�o�CY󱊌|�G��҈�����'��|J���O�y��3~�_���"7���}��O�\�^��Os'��ǎ�QC�%<cs��ƅV��FsDƑ}yb��e���<<�󊿪ژ��S8R�Ƞ����p����L�㱢Z���}�76���4��n�c{$��t9A��BF0G}���uW�Sq�����&����1
+�����w�1"�$�<��H�tc�<�o
+0Ti�@��Sje!���F�8t���6�MlNMǬ+�����?���3����̿{���a�+V s�����X�:�}��4ړ?�fK&y�פ鍁��rs�+��Աm|���q� |mkq���2�:ޑ���rJ�)���,4%�ż�p�c0ZC-���]zz�&��!Gϋx�	v$;�܄�S��X�w�1��L�&H=&^�����aK��Ə䨃��̾�BY��{��s&�� 3�ft���<B�>0����'���q��1�W�S�K���w�����MB��܃~��Q�����hr̄P�?i��Pc�i7
++T�wɅݎ��2Y��5�o~�3�_�������8/EW��K����+�������7���ϋ�̯�Yv�W�>l�~�7L\�]\@m�l���ؚ�5.��Xc��5s<�s��	�MÛnxs������3��m_ժ���7�X�.99c�o��bSI7�t"��'�`�'*�b�e;6�1ƥ�����;cMM~��ox��e�X��f��6��D�^�RL�A�8�&cp.+����5�'�)�Aa��{Rr��)��~`�!y+.�u|��g���Y(�ű�7&>��޴���u��Um�؄ǽdS����$�VK,����.�}���7WX��%+>�X�C+���I}`��Gq��#��ʘ3��	M>��s^�w��fAڤ�^�~�4�+x$�R��x7/�^Nnu����D�?^���!*�rk"�V����c�@p� @��Ln�A�,�M�|]���zX�ވ�w#M9͟�o��:h�[/ƀt9�s6bnf ���i�]u+������MG�G\��-Ū�U�/�Q[?,��^����fد.6�CP'�����o��o�W��Z^�����c�o��/���Ì�)���])����X�N�����;x[����n�B�O�擻��f���>����$e�ud/�_��g.�����o��r� 'fc@��a���g~��������������/O>���ʼ���㈅*#g �S��/���r��H��Q�y?(X��[?{k͟��C^\�	,1�(�m��_z��O���n�*<�WNx-��y�f;+g-��}�q��x��ulc�C�5f���yp�nu�7F%�ӑ;ی�"N�bsJt���F|H���g��y9b�(m���lf�`�n�?��V�ೣ5.���:���ڀ_|j����ZԃĊD�+���Ÿȵ�\�}�Ә\z�ۘ���n�S㗿���K/���X��:��//z��������̓xg��S�N�7����7?4�䖇�]3��_���%�9i4�o.��A�j��(��~�./��m{�xo�P�8t@^�o�}Ӈ�5=��S�9�u�{������wZ38lR�ڠˏHRY���Y?Z�=��uO������xN�^�:?�����t�[�8ƘxF%f���[3:,�cX�y�˱�(N/�mb2�
+��;��\4��)
+�O�`e�y�_;l�n�́�<+���C��-��D�j��d����ͪ�TƼ+;���?R��a9!k�!,"��T�u��=�YU�Bnq�����wލ�U�,6�EȪm)��*Fpp��ܖ��koM�k{N�?ވx�3�A7Z��~}�q�mՌ��w039��u>��,�8s�q���Ѝ+@�\��x�)���@�a�V�,�V�|�������	R76��f���(E
+O����=��7qSs4��D+�\��g,�Ќ5���?����oP��!��w\��V߱�6Y�k���H��*��\���	G�2�o���8��u�u��9������lsz�.?�~\=k�O�8_S�}��?�t^�I^
+����T*K�v���9�|]7�o{���%�}�����ӗ��C?�O��}�^j����ץ�<����w��]��~��P�-=�]P�ML��cܽŁI��@~���g|]�ٱ��އ��-l��1E��Q�7�^���?��
+��Xq7�>8��RZ�����s5q+3�c?h>��YeN̅b�c-�*�(S�^��)Q��;]�F,|/����՟SS얧~bi'-�S�Ƽ�m�]��Gzm�O�k��Y����ԡ["���(m8닠�6/x9_y�4b?����=�{1����E���?5���ic�4�Fb�?�f}��H=�g��Y
+�_��X.=�Ȕ���'����O����@�C����qO]È��&L���7T�s_���ݗ�W���)@���:~?X/���Z��ö�Ǔ\�kg��`��CL������州�\z��#�<���-�1�A��<��з}���,>��Cs!�j�%��a�v�h'ڎсyǯ�;[��|��X�_2r�պ<��0�R4�;֥��?�0�m�#����µ�s�D�
+b7ze3��9u<3JYK����k\��(�Kn�K�c\�GL�&�xօ���t�7QDN�[�!J^��?-��Բ��u@,4�cuԑ��K����wLW�gm��Ƞ�;^�G:��4�����+��Ӽ�o+8��S* D�u�N�Ө���l��G�,^�����u�I^>(F.�����B#K�!]��2�̆�򜑑�#�h�]o�5���v�1C��Q�O����uZ,vM<Z3g+���'��t=�y��@N�xh������������ɷ�uL��j�t��k��P���6g2���m�ёW��3��t�"5���U�c�|�0�N�����;+*^��0�k���^��e-TP9�x�s[�u�/J�-ޕA=,�o�/2�!�6y�)�D$h�A9(�Ήz�Q��'���{^�<�wd��z����������H-�fJ�+��1`�nƴ�Sd��Q�ɠ����T�k+;��ю���1#����Xl�ro:��﨟q�8�3]�-�qMK���"��V{C�|�A\r���]+���2F�t8�h�4r�d��	M��3�yѿ�@P��h�q��:�	����H9�XLk1�cQU���Y����������kr�qB2y��4h�7�F4�w�􄌍��b���$1�!���LPdf�����0`ę��ۻ7����㲵B;��, Ok��I#b^��5_s�sX��Wɍ�~���.��G���'����I�_�m�6����^~��?Oǀ��?���z����
+5b�M���'����\a�<_�����z�,Z������������J�n�~o�>�o��_��{������K���C�<��t��V�a��tY�����/�Ӵ�a3 c�cO
+��P̩*�|BY��PF��d�p��g��t}���e)n[�<ތdr�+Ĉ1���"�5#yNږRG ���9�f?)�}o��;��Y����Zi|"�8�ёR�sS8�f6����d���>�`dcJ>ٰ���4��/0�7@m��+���8P��!c)��&�W��?�ծ�Q�V
+������@��R���u����[�����qT;�έ�����2����w�����OyX���O��cq�9�>�d���Ad���kr�$�w�����K�0@�t���~�2�3ǘ��k8�վ�|�9�/��\����˟�sߕZ/�v��0����	�G͓�AM��P�E5^Ue<����Pq�@�]���,o��x�H��A��y�+ZQ���f��Q/���x�S��x���j�A��넗�i�
+���r�+��w��=��;������y����u��-��H	���}p�O�kl�@��#���/ƆV?�$f�n(9`e"X��G�(4f�2��х�k�~e�7�Q?�/��hp�7pS?�8���'<�����l�Y��!�+���y⟦�|���F�����?�u\q@o��H��������[Z=��+yR��� $+���WjZ�M�mȱ+�~n��a�o�1��i���͘\3���sc.�@<��/�����q%�x�+�c�>*�9P3/�����83*�/t�<,+���L�`�oߊ���l<�;�q����g��:�Ë���!5;[?��m�R�y��R�Ng�j��-9O��$S��`��6�D���C�i��G�ks0_�ӎ|c�ɍM��/�N�~8�C7I���i����5�X��_=y�C9�[*�/}��
+=
+kwd3b�j3��1���8��i(8ހ���o�n��I�\�"8F�#d^̹�.&cɫ��j9�͎��3����0�ж�����7ǰ���}Wv�ޱH>�(�������H��y�Qw�'r�Z3qs�َƸt䵪��i��X�)694��8T�f/�^�o!���~)�֔a�g�����A{����(��IMԩoriYt���9G@������<�ޔ��]��=�������'�1([��}��֟��u�ި?��0�p�	�5�Q���5<�4��m�6��>D8W�-��u�!~��>gCHIp�aNQO5�7b� ���k�q+10�Mc�؎�΋�ȿ����8��,�`&bX8�!1#a	��ԭ���<{�{��~�?96K÷ꜽ����w:�޺U��+��+�q��1��CF}!�}�׼�ˣ+�������o~��aR��l�4Jl��o"�tǿB��A�;�|�!�N��h�|Q)�4M��?�VA*���=g_�6��Ï9��>+�'G"�ֽ�������G��x m�c�X����ɛ��1g�o��-�[��89N��?�����!�?����4-J�A'_���+����^�N��v�8�����<��B�j��Y�����z��p�(��Oٹ���+��ҴFo�g~�.֎���o^���c�r���:�Mk,S�O��/L�LN+��߽����B�v����4��1�h�>@?�&�����wuQ&�g���w����M�y��8xM��37�_{����h�ۋ����R�HdG�/�`�v��x��;���ֿ����+�M��͍jn�v�^9#��q��mbu�����������39���-�Z��ws�s'шuTG�۶O���OU���;94��".G�sI��|���<z��a�C�}	���A٦����2�|��+;Ā�U� ��\����	M`����{��/�z��/�G��n,>+�	����8�a3����9�t��D�㦙�t�-c:��L�����+�v�f��@�~�¯��kV|�Чu�����2�>�>_���l@�'�m �+b�͑W�v���܍�ی����Ms�#Zl�^h�Gx)��S���o̧�%��<k�8��\�+u��r�Ǳ��1�����g���
+`�K�L��kC���Ri��_����z~���h���囻�[�+��fWEn�X��_�?Գg�0,���9�k{��_kN�I����t�m��_�OY�O��O�">����N�#뷓�^h��EoO0�V�b�k}&K�?�Q��YD���Xi�/C�Z����.7K(.@��ݫ>H�PgJd�7�Y���C��E�81:8JxG�7)|�X#sN�|�K�C>��g��~�/T�yW���B\r���Z}��ǟ�i�6CI	�R759x��d��F�0��{��#���yx/c��1����:�����[?���m��(7��BЧE�ښ��u�|{ZJ��Ў�Ò�fJ��"nИ:��|q]�U�]d�+��+�r���";:+����I�Pk��=#J{�y���m,�'z���/��p�a�-����4����D�3֟�QW?t�|����t�c�0w4�E]����w�+�2rݺ�#��3�j�:�S�6=U��F�>��	�u@�'��(Z.����n�;A�<X����<s��BRaI��r*���/�h{�k�>�^��P�����u^"�Z�Z�-�m���ҵ�~,�b[���c<}w�������)�B���Pߠ�q~�J;^�Qzt=5�1�T�ĉ.��k���
+n��ߗ��M����O�5�~Ŋfe�щ)�5�yE��7����W>U��0�3?��< �����>kՈ�c�wN�!]��UcP��@�vq@�jF����j�}/��������#�)^�4�B�O�wd�>���c����(	��C�A}׽�hX���<`ӐS�}6��4��-ŇX3����p�=X0��+�
+��f�3T��m��#v�b�f����X�Xۗ&���I�q|gB��]�m(��+-�y6��d�>�_��h�����Wb-=� ���!#����?pa�Q��`&gE�%���Ҵ�������ۨ^l��9�)�C�m�@
+�_՚�?>���]��ǉ�g��E�ܵ�X;g:v~|�q��~�?li����x���.��df'P#�4$����suūl�u�'Ӹ��^M��T<��m��V0��Q
+ؼ��5tl����<���dM����~������#t0�O�?��)�E��|�[��j�죱��ZF4j�u�`%zZ��~�?�	�`b��q�ב�}6���.�64}k�����O߰���ͯq6юO�y����7W`t+�{���&ZYtc���%&�U+v�������V��m��$���S)���\^������+��D������x�_�عQ�I%���d���_�i�}�*6]�ʈ끳+w�ၾ}��~�{<x����m5���KB4����H���5�����Qy�X����r�o(��]���N�Ι�qCx���	;tPZ���{��2��(�F�i�j1���h������u�����C�)���'���c_^��o�ws�ſ}W����#s�����O�!�v��\�)��|�O�ͥ����/�>e|�S7��gb�s�otw�?i�����,��g�Ex�����v��1X����wdF��J�.}��s���+�۰-�m�m�O�+����3. �^m�����02���|L8�"�hL�����/T+�.��ט�>��>i^�|1w�O��=��L���#�f���V�	�a��/�P{�o������yϵ�ԟ�~B�ɳI�G��J�A�W�x�I�֯æ�S#�E���}��8��S��kA�R�Jy�E��\������_�+���H#G>�x���Ww9,�*��9��<�� 9{��\�� #Ǖ�n�kh�0��f,ƕ�:x�d��+Ŷ/��}���.O������M����EQ]��$|��{������Xk��9����%����=���:�����X�>�a�E�6���e�|tGN��O����d�'t�x��X��>e/�N�ܦ�ۍ�v 1i�W(�+C�v�4�!怠���m��/�'���}8����˃���؉��S�6�
+���t���x�c]������)��ۣ�C���u��q3'�O��O��	B9N���P瞕~�.�qs�~<��d����cC��;mea�!rk���Sl8�I;�z�:��5cΡ;~�q�=
+K��������,���+8��QI/�CXD\��E�G�P�֋=?��z����Z�����G���ɖ�g��C�O�R���$O�$�*�~�9���x�*?E��ϚƬ������`�>��}`R����]��ۍ!� ������z�A�8��Y@ބ]3�Hc�<d�pL�:d��$��>t�;�yU��[+0m��n�Dl���X�|����w�'�O�v��[+��&�Pk���� .�d�=��<�J��1wd�'}?v��5���'6
+%0��Q��4�\:�5�b��6A����|2��2����V��1ѡs��G���	ps�әg ��`��)>R��g����8�13#:iҐOƃ�Y�O}d:��q��{+�8K���p1�{j-!i��Y�E�/,�`�a��C���M�����c������T�Kd���A�]�jK�?��_���mm<5�85���6�C�q��ފ*2��#|�c��ӵ��b/`+!�`�>0V|s0��C,�79
+�� }Þ��<�ߐ�.ט�]`-���a���p�:�>�{��͙��yR �$҉�_{^���M����>���?�
+y�����}����#�11i��5�Γp��5�β3�>�t*��5t������4��-y�?�r����	J;hl�5C��`���v�f;�>�jȂ�3VYs3��"�VA�b�j����%�~}`n���57I�8���Fϵ���
+`���������On�uW�+=&[o)�Z�@�׾�&�o� �A�ID�T18�f{Q+0��u�%Mh��Z��^�*}������L�F���y��g��}^�+�kU��s�u~����
+�q�Dw?��u`�6g~m�7������c�k�؝:/���ӹ��r��ݶ����t�7�ۉwu�]��?��o+"�6���b���)�<��рݱ>xpsp�o�l��%'Zl|��>]�P�)���F���<�߼����v��#��}�7^~�g~�����ri�k�f4�EM��I��~�c�\ȿ�ø��8�'=/l�ڝu��������m�g��j�*����'�7{}���'qÿ�/�����������8�+ܬ��%km
+;F��]G�J-�P�5�L�	M^`����.L(i�.u$�3�^ǌ8Lk���
+k�<+͗�xir�ު-.ϫ���h#�н�a�k^�y��`:D�Xھ��m9�u��ۜ�"&j�X�H�a��ҷ�@'��b]cБ+�w�nχ�?��b�C����0ge�`��I�ؐgX�8��?D����Z;����'{��^��+?3��S��\O_���%BmCXo���';�O�1:|6@�sެ�6�y]\���Ia`h��$�k0�+L,�A���ٟ}��K���_��_�w���k�r�k��.O<��v����򉄧>����ͣބ��r�����-N۶#�1u�~�Kj���+��3�;�Q�7���/]�fjF�>�y˼񬹽���v�{olvo<�9+�|���V�]�ڃ�Mr�]z+FZ{b4��Z{h=��F�1>���w�'�l���4�KK�c]�p���Ļݐ�׏��>����B�DH������q/����_z��W������7c�+��O1��zey@|���e~�]�s����:���?�����ˁ~R��l�7���+�%��y}�����o�[����8��\lM|/��~21&E�So����yD|��4���/0	�7�q����a
+>XԨ�B���˼��W��ͬ��uݒܬCs+����ݟ`�}E�0~��������˻��k�� �9q��Epu�Y�i�8��y�[��˦���!�թ��������j?kH?
+��6њ˵����,�0%�1�h�Ή�3u���X�@db�L�z�A�z�k�gHL�5hr$�&����}Qu���8`��:�����66��{�V8Oß췬vy�ǌ+x\�#��G�˽����ď��/ў�ƣs�m?���m��׉�!�{������B��������?�p��0;�v�=�������:&<7W�Y�ȷ<r��d��:G]It�\4`�34�Ƚ�^Pd��W*��B<bu�2��'�$�4s$�ɝ��sI~u�őp�|1��`��5��up�#�i���&h��
+m��E
+��ﬃ_0���,�/00W y�iBܠ��Q������ip#�A���8�G������~�@c'f��>���|�Ć6��r8#7���	�zkS���vCxS�n����8����I�����M��^~�mߛ�]�F��s�_��M_F+,�
+���׈�mz9ä�$�����مQ�&>z�j/кB�yE�+wI���~d~�)Q���coC��2�0W�g�j���9`�x4�q�ſ��ķ���V�1*�y"�ƱFMLD<����;�Uy�	�3��vNx�Ӗ����:<�����{�.��E_9�d5�/�_qG��ǟx��E_���N=�]^���_ɓ���������s�f����|鍾��*s��ii�����[���/o��/HM��ߘy}a� ��0jGe�hr�k�e���`V4c��7���J�B��0+������|L�����c?�a�q"+2���`~�Q:�+{��ID;���v���x�c����w{.W�cC��yh)i�?x�ƶ��pP�
+6�r?�
+�o��#s���kj�II�c�w2��#��u��}o)H�k�G
+=p���2�x�I�������Q�u��+���J㧖���k{����~�G�����Ux���#����؋A����~�_��/��/s�k+^�'�0s��9�K>rTn�a����"#��~�^� �!��9-����x/)��g�Mp��s�0��sR��f�S�q?�N��B�GNQ���n�^�+�P+��?8��4v�B_-
+��/�撟�?<�fs���>x���=��KDA�/�4;/�&�yGϧ�|((sR9{�����}�PB��5N�X�M���0�?� 5�9j��>��n8��mly���I�y K����+0�;,�\�>�Z&��ȱ�8n�
+��<�SH�}��~����V���8���=c\l�'3�� �`l;�y"p�Ɵ�?4���^�	}�8�Ϝ7:��l&>)S�!�8�#������`E�|'V$��y�O�Խ�1D�up���-+�n����̩�0S��2���"�Y���\d�7���\�U�O	0�iҰ��s���yO���W�"�+�c��?�����:L'n���|ŕ�Ԗ�$ל�@��.�O<"�F -�jK�MĮ�H����BT<�Ay�\Y.mͬ�q�;_�D�	�g�����>~�G�����_��ȰD�a�C�#^�ً6��Asl���������?��������"Ӡ�+�'�6�s�\��i��퇄a<�PƔ�)%ק�����Σ�3)g�]�΅�H�B��������f�85RjK���T1$~�ݽ��J+���!�@l8e� �4�2�\-����y��{���o�\��}a�>���WoE�0������؋
+d
+ʈs��4�=��7��M���s�X���Y+�J|Q����_d��8X��'�#���A7��^�����O�%����+�˗��qg�7[�4��R�"D>���a��oݰ�}|�_����m��u�ѷ��1������Y��\�GE��G�-�J����?�Xl����ڠ!��&�\lߢnk-�1�Y]zh��۱�$
+�������U++��$ێ�?��6��':��`{L.����_
+��$�9V��n}���c��ׂ
+�°���}FH�U�gDq�"��}�p2+��e'ҕ=����	�����.|���Nu�<�u���X�Q����YeN����\ׄ�~n\C��כx���ԈJ�;�\lM�i���n�f�O���K���i	h87��G��q����YMD�d\;���y7�70����0�J��"ر;�X����g9���������b'�\́���tF4ƹ��(u@���E!�k?4�џ�&�J�؂�>��	�]��	EO�a��9�z���V0�̍�֟�G���m������6���1�'uYyQ���W._��o4��)z�j�=�O����`^���ͫ�+o���c��`��3b7���3���ݪ�+4<��)�2Qs�����v����␌��5׋��}@�k���Uכ�c�A���Lq+�K���@q��'QP�r��)��x����x���x@��Ly�i���x<Y����?���[���~��P�^ֆ�Y~cB�?��p��C����_����]��?�g�F��H�������:?���ɡy��3"w�����vs�5��s����7�/;�:O��J%��!ڭ��
+�2ԏ���vc�"�F� ����!��H!������y߽����K�H�P�:���;<ﰆ=�s�=�����-����L�ç�Mm*撾��r=d��|G߸ch|�˽0]�=�����ƭy�m�XgZ������I�4�l��#MN�șMr1m)��X��r=F�o=l��i�cM�h�	��s�_"͚�UR��zA���#�}�6n�]��s?���7p��(~�˴ud�Z�_�M�����V?O���(V��ᘷ�i_t���i��ʡ������.F����kS�x�6WPaK#��Ss��s=���2��r��eSǀ�:d�3 `3��M�9��m����A���P��_����W��l�8�Ok�������C�k����3�zt�sOLX�V݇
+��d"ӈ
+7��q�^;h��b�c�H�����5i�`�5?G��=q���Ў���x!*��~3�H����B����A��gb4o���sD���9�~�+���自�� �+�C{�3��?�-ԯ}fi���8���[����a�՝#�L
+���l\�tw�g��,��#�9�����U�"�E���3��@���L��j�P.�Di�i��׼�Kn��m|�l|�LM��j��'8kZH�*U����H��虠j��y=q�A�7$r?����[&��=N�j`���ѩ6��D�kk��P�u�F��0S�F �W���q�G��B��(�z��G�J�y®����~aX��`��=e��[�R؟�ک�)
+8���\�{g�F��|( �d�P�N�\/�,���1�5"��N�^��e����;�_b�B˱n���q��-sR��[�Ee[�I�ao�����Wm������!d��\����ϯ+u|"ؓ�=mNW����>:��|@2ԯ�r�Xkis2���s�̉��Á��w�O[�\�W:���X�h0���%��ګC{���r���ȍ~�X֟���0 nhw}��}�wr��(G;�:�k'y�U����o���N]�ֳ���/��b~�zs[������~271��l��V�+
+GZZ�R�1��0��׽�M����Ú^�TҜ4;����47p���c`8�UEj�K#������sr$���/�������90�&�S�]J��@���iP�̉&I���v8L^��}H.+�z8}*3����BN<�yK�L��V��c'x�UY
+�9�{+�h��\�{vjf?�+Z��%�����)&������c��}1���yQ��4|��2{.;9�z��2#��8uڜ����fa�O쌸!��L�����dDZŲ&yQFoj0yu�C���d��oK�:`�ǤZ�1+ŋ���t�~mmN�[z16�?����S�C�2O|+�����6k'��2��1G�O&��{膇_ME��hxs����Y�r0n6Qo�+�~���(h��"k|����/�R䧖�ގ#�b��2���C�r��+��DfD�J[��|��lraA�:�(7zp8)ir��
+�̱���ƞ��?��bB�яP�ںRpy��ޘ��O)��>�����~|�x7�r�.��=ؘ6��E����:�����;��Oul!�����A��b"��΂�Oa;&Gv����έ�j��'��]Q�������E~lG���Ca�W?�=�Wݥ�*,�&�������(�癁��	�EH0�m��7�GN�N5&9��N�Wt@���cɴ�*��2/ʦv�>��A珚����䯘ⓟ+����_��x�-�/���:q� 8�+�c�u�G`쨔��!T��x.mh���b!�p4�����>S[����ٴiZ��QgM�YĤ6~tֶ��g�]�QLs�h��y�r�Ok��r�.�������w���/�������'�|҆�h�Լ���_}�3��K��C;�?���Q�}�h۩��$�����%�f"����r땵9պ��(��ՀN�V�qhE�.a����?�8��0�3��S��#8sB����,����R�9G�|�И1��
+�(�a�1%���7U�'�G�֪��TՖh*ׇv�2@b�>�ڤ6M0�&'{��2IE6<�����خ�kE��+�ޚ��zU���wΗ�?�A�D�ܷh�3[؊hAd�c|*.\J/���7��鮿�.Z�3�;�v���q��Ԟ�����37�����k}���ݖ�X�Y���g(�%l��N��Y�#��%/���n��g?{�m�RtM�8�)�V;�}����l��G���������G�X]��#+m3����+4'X$.|gs(/Jmu�a밓��G�X����?���#Kc3�K�K���;2z�����G��׻߭~��K*�'dh�:��ܗGX�+sV��7"[+���0���?���L��!@rB���|�&�&�`�%v<��9��6}��ѿ7~�?>�����>1�'D^{sz�/��;�@~�e��:?��`�?��{3�ؙ_y��!pv���T���y����$&PY-�p��Zn�:���k!�чN̴���Y�i�ks��_�5R|X�'h����۫;*���]������*�x}���FXkA*��R�_�+�/}�k	l8�/�_����,��#�HF�9���D0�x2!�ka�?����3'*	z���9��X �M1{��u|�\}dQ���:�c'?d+ �z�Q�C�#E�9�������"��<+>�P�N�5>���������Æ�g���G{˶�v��7�g���s!-2C����gi��M��#��"�2Ҕ]��S����&�mtk#(�?h"��w��r��O}�P�i����1��!C,����A��Q3�E>���g��׹^���U�ھ��&ƭ7ޭ�z�^5���<��*�H�W�/� �)|<�y`B���B��N:���_i��e��+����;2��Ă��U��bo`�Z!W��+�]{�E/ti���N�!��x�!�7�M9������v����Gomc�y�e ��k��̓�Ƈg�m�[�+���|��w��n��ԧ���8^_IG{y[78إ4�z��?�go��׾�b�E;��͹�r�Z�X���i3�8Ϛ���vJ_.�&K�����Fup���&�?������?�RY?)Oۿ���=l�
+�
+�ӞJ�m.6��o�So4[�;�M�W��ٲ4�������;tQ5&4(R���q��-:�Ͽ���Ûu������E��Vv�+^����'��^mW���:S�\�6�q��D.��W�9/W�C:;׫U$ڎ�� BiN��X�D��������&k�� +12+L���lG�4�}�����4~���k�u|Y��yt���|�������ߗ�<;>��{��_�+Ǉ�Y�����t���YR�JdQ��F�GM��iB�X�t���T> �l�ܬ-�����'�����!{ޭ��C>�A��C��P�{l�/g#'�����nX��	j��P�:��X��䗸r���c��
+*�����_t)]���!�75:��g.D�ο]۫��1���p86�6�����=�+�e��|Y�p��Ob*�9$;�<�M\45�Q��I�����rl���c�ѣ��t��6]N� �/�W�U��(h��n^?��r{��+�6�ڔ�A�&G07��2�g�]�~���&?]C���?������Wu!�v��`�e[[���L��N�=�[m\��S�SS6w�y����k�Vz���n�ݘ;/6���⌫c�	cC�����!�s\I�ЯkG,Ue��ч5�9�ߛ��g��c���&/5����O�|>>�]�n��l��O����S����̙'^>d�P�*pP^��?���ͥ�?y��67\�bg��7Ƶ}��:�㊑�r�%�Ϙ�.V���˟�!~�����?K,"5����Y���{��lsh����ď�}�׾���o���6�jsm#o9�z�7%�+r��ZNZ �뽁���0�k��n#�� 4{o���+�8,b���M��N�ژ�M��
+�yh���g'k�ݨX�oڂ�T�����Mnf�l��R*���z��QX�El�n�����ƴ1�'��(e/<��8ʢ���m��̐�cwg3�?/�^�����Ios��q踟Y��o����X��	.m���Χέ�db���ܴ4�����5mn�����C|͘2�<�c��_g*/A���𷜭��9�lB�hZ5_�;���MO�/���|�����w�S��ͼƃ��:�z�[��6h��^��?�7�����9";+lG|}��
+��e�W�kgL�C��%�;'�]�+�%5��+UPje�+za����iK��L�m3�<�����bΪr�i5p)��`��z�;R�m�u|�.��V�K��U<���R�^�#׃��&���۩�,q"��9���֮?hb�ED��9���{�6�#_�zqCO��o���^���mE�k�O���+���΁ӂ0nڵ�Z�6���sL�89!D3o"��y���&r�H�z[����#y)�M,�Sx���M�
+5�v�Tp`�Us�]DK�52�4�	�ܤ���!�������]o��䢱_��_�����d~�����b��|)�*�����W<��1�o��������Q����+w�xS�y���k|�5v�A�57ŏ��!2���/-�5r)���wF�Y4?>K��~��+��5�R`e^S��N7r;N�z^ͷ�.���k 7�{� �í��o+Ҏ�%u���E�J蓭�P��~�48�ƁR�;��N��װ�k\$c��6J��w���}��|�����G/�Q���<bC�P��#C,�ho�~p��2�-S��!H��X�Ǉ�;���?�;s��W��A�m{��x�T��$�3�����G��t��t�O�t���?�ġ��?W�v�R?�s'���{R�.��L���f�Eě/�l{��������9�Y��ܽ���{�~��CN��k<Nt��8����F�F5��3M�7��و"c?��5>ԟ�I��k��_i��+��g<G�q+^���_���o>���7~��A�~���#߰�xf&A8���fSH^*�A�9��#�0̉��G�8`�ot�J覡��fk��x�&�����xaF�1�\���7�%�ic���}��b����HUWtxÝ�O�`�8��a����rA$8��T���?�i#h�i0���N�bd=Z����Y�K��{���j ���0�9��u(c��WAO͈~�׽���u�������� >B(�lt''�;~q��2B�_��jH�<�b���f:�w��J_������1K�uLj��a��+p�w(��ӥ��W�J����Bk� <�^�ދA�%�++�q� ,}���Y�-1o�r�>e0�������m��Y�]�����gbBDo��;o�\������d��<p��+M���+�	����7�!٦+�шΦ�1"�	lO���']}Vc��x�phc+2�z�p�;�5��9}�@흵������1�`��K�H+��1cK�Bs�M�*Y�cl��˕�ѩ�^���#�ސSg_Â��f���6��b���~ɾ:�d|w��o۵�9�|����}�b��Ǚ��ޙ�d0jEƯ�B�����#}�Ŏi��f�����X���
+���Mx�ò�-eNQ�Et�P�98��)�: 4t�Ni�Y��%5V恒1�XwlA�*�a�C~����"u���K��mj
+6���k}�M����$ė\y)?+�������>Q� �0PYus�n��ͦ����D'�ګ�1�����C����S����7)��Qx��#Ӗ!�&$��'��q�O���@i��P�?td.c���qu}�Sl�&��H�9�5Bl|�u'�(�7���s�7<�/+�ǿP+�cc�/��a��ĝ|:��3�yiK]D�^��ڜܭ4�-�A�A�h�ti]�>$���p(Ed�q<���S�}�]�,e�����or�-��ȋ6v�%����7H����/��41�֫�P�?�����g�y�����?�}8���?y	���G���~��`�L�&�����f�K�eF'��_�� �܏�O~���bse�FNC�G'YS���S���9��f�\�?�� �A�{�����5�2�g��詀��Y���_��Ո���ٿg����Ip+Q���@x	���7&�&N��P}�lq�O>������QA"v+�!,���E.����x���.9�:��F+��B�0�|[�FfrS������FBCF8*���>����w��)ꨚ�h�ǡ���!�6�ೇ8�'(�b�F��.H����:j˞ 'ѧ�ze~�SqXߨ
+��#�5y_�bo��M�PY]jJ��i��g�˿gO����_��:;�v!��ȴc�N}���PF��F��@����h|���w�3��I++U�Tf��:������n�ѯﳿEt}ѿ�4Wա��X�?~�Er4¶���Ù��������CZ�����I^y�����=��"��X+>���Y�>�ߩ�ǜ\�d�y���M���n�A!�c���H�4�����	�6F%��ϸK���8K	?&,��.�Ȍ�=d�*xx��]�ޠ��5��{@�c�$cgD\f~pq�|����|��������3&�=����z��)���k_���_���o.�1��G��	����~m��yN;��r[/�֤��*:d`ۓ��<��n+��)?-��+'(ֈ�R��x;��P+G;��Wo�K�����/>���:���g��;����Q��C���>h����!%�af�qa�b�h��N�"�֔�#�N;�qk��X�)�t⛛Z��<��_z�/�����cb�\��꿐��������O��ٜn�q�qE<���K_���8罾k�s�5�(��
+�͜��M+�M�>?����ǿ��Sz�W�kT((0�@m�
+i�i{������ ��Ԕ�C!0T���7
+��g��+#�?�3�HK-Hz���k?R�b�"h���״#o�nmT�0���w��b?q���U�(��>q������@�(l�@|�PЄ�1���o|��C��6��ߦ}���u�!�G�1t-���l�y2�����)��J���ظ�z�ON7>�^x��<��`;�t���e9&�#3�e��ԇ=�`k㪃�o��ˋ�*�7i��L��~ȄR���1&���3~S�\����ȕ]B��s�����;և-c�+�n�z̰�����aN�H&IA���r=`k¢? �)1�����[y�/Ӈ��n����˿���B�G�{~�o�|�i�,xi(���W�aȻƷ��������m-\⟼�ffvBi�&����(>8֑t o�g��oh���������-j�����.��o���Tص](�bz@ć����!H���Cob[7~�p��.+dn*��ʃl;5�'�!��'N�����$g�է�e�ǁ�h��������^� �|/h������qӈ|�{S�a�:���o,�3d��^�1v�t!L��[K�ߓqZ�ѣ4'�rpH���MRR�>켐l����h����E�p��hf����g��\���܌7V�n��Go?���1�X��z�����R�B6̱��w|���^��7��O�1�b{e���+��'�9�gB�L�>����_���Ւ������)dvZ�cYi,�m%�V�<(-��޹����3���[(��X0��9	�c�/��(���9���و�u�������x�⬟
+�M�ԉ��1
+���5�՚.��h����J�պ`D��+�Nx�l��������|hzIy?������~�7�?�)�ݢl:�V��x��&�)�:�/���@7�^���_������+�_O;�PH�	����+3yBg�*�SC7Ƣ#��&�|����������F~E��SHq���@�0��{}����GnX�O!��~9142B�����3��>�ώ��+j�4�~̛�����6��2C:�'���0f�/ܠd����yݖ$���oEb�X
+0?M�$)�3#���~�+�8p�7����������1�g�����_��o����_�+{����?1�zmlϡ%ES��_���Bk�+��/'��ohV��?����]������،�
+/b�K���+���c���$��n^⏾sH�p�k�D�*n����1�W<ߣ������,�q�)1ks}h}�KJ�?k���8�6���ڸ�.>�	sXI��{�Y��{����:��7��s>&wr���c4đ��>�h���Y��=ח���Sw�G0���4s�?tlF�VS������ԫ��y�ϥ����\��1���������̬ή���>���j��k���+G�	0+|/r�e��`��\l]��d���ݔ�u&u��R��{�8�w���ʏ>�qH�ˆЬ�����SC7Z��A]�D���2>� �?�֜�JO�{�Ď�x���$�~��s&q����z������1�u��p)�n<���G�1E(}����M��!@��+����'�8���<E�~k|�7iS�x��Դ'*x�-�:������62�+�D��X����W�!Q>�я�~�g~vbAd��m���ƴqm����6<�W�?|�;��퉧�{�8���ix�7�#e*ۋo1r������$ǆ\���E��--6����������H�.�+�akh��|m)�$�q"u��>�O֎9)���bI�\H�,�?��hީ6�{�}`<��T�ց�k���\���!E\���bD���Lt�I���g�z��q�����1Bc�m�M��/5y�܏��/����v��؋�e���u�L�?���94|�a8i/�g�N��!���-�s����+浽�s/�n.���g�ݿ�˪�η�+��
+
+P���� (� "Qcb�aw�����������&m�$t�W"T��x��E�	E}���|�g>k����oUMU�:g�9׼<sε�^{��9�=Ȯ��6Oh�9�fl_��v��}JY��γ�r�dm��mv�ǲ��6�[�D.0u��&�P��p�B���S}�O6����ι��S�`���צ�k����1C0ׯu�1k;��M>w@Z��u�cxo1��b������^�f�;�����}*6Va٨�P���~o��.�?]6N��|�ͷ/T�5�M~ɾ�OBnL��<�'7RS��W���nT��r�mX�&���!�=�P;3��auLg,Y_��/�ȏ��C������w^T�5?s
+7յ�~t�+�q]+�h�A�0�2nk����m��d@f��͈��;���I�y���=j��5Ռ�}�6���!I�̠�ȶ�P˘s}���M�S���NǬg^+����g�ѿ���o��ILת�Z1�W���ɟ�ڍ�\�s��n�`�L-��YL-��獝#�eN)�c�\���ʞO���?h�Y+2�YE�:r�ȷ��3>X
+1��`�ٿi�C��V�YZ��N��!c�&µ�9�0q�37S��i�?Y��C���į)y�-cR�Bձ��9��k��m�@+R���M�C�lpK}h�s���S��L��?m�I�2�{3:�������	f>�����عD.��	,�H�6K)�]8b�*�����a:&t�"eǳyǷt�����ł־��wz��k�G��5-�o�ֵ��/����.�U#T�.D(��ڕb�X����Xĺ�z����^������VJeRzo�h�lK>0��ảS
+�Վl6.��EW4�̘�<�;R�A!�c7��r����~ג��3�"��$ʍ|d��`�(!83q�PO�Ɨd�Q���{�v1��C��1��9ϛ��:q��4T�ߕW]�K��O�}�ঽ���H�/��m��`+���Z絼ͻ������e�qt�8tk��f���A��Fx^w����'6��~|�$���l�X�����Juem6Լ���i,��q�>h���(��'13;G��Z>ڤO����x�mv��ġ56�P�g�s��%z�B;�2�Y���[��c e�C�gд^Ϲ�����'�'_��\*�W̿�6m-l[���VZ���ӈ؝�o�%�p_v�`��(}����̿��hc��+���|��:��k��՟Qb�v�P��Z��/�4y+9�=�HM�Em�끲�̼�4(���cQN���=}�����U�CwmԦ;�ÚU�>_����x���b0I�n���]�� k���*/�LN]?��d�h`w;b{���� ��fy��f����w��:�Z��φ w����~��v�W�כ�kF����Eu�tDh�{�Dq��d:V���H5ǩ_��1b|�E�j�]/R&Eǒ��Y��2��c�A�A���)�^���<&\�(iN|�+
+5c�o=�t�.�co��׽�d+k+�Ŷ��a�qr��!��8��H.>���i�X�PiKm��p|�7�xm�f@Y8�lL��{�~ؗ�o­��L��E=�����r���qw���y��#������j;����'"�O�Uo�� �Ɍ��yhD{�Bi�aY%�8�ΰ
+��K+��.��<���c��v4���`���G���J@����q��lg�r �~S	�s��(��Z��,��P�ئN���������'d�X���x0L��</��o<�&|�¹������\���8�JoD��"箎�)M��t7�ʤ�I�ZS����}�1So�}mH��/1�����+��1�2Yv�@iL��$�qr����<��{�a|Ro�Gy�v::�˞�6��������f��Zi4���x�>���7i��k}�;i?�=�ĥ�����=k|��|䳟���lX�j�)_�� w��Kz��+A����#T2>�Y��ir���
+Y߮	�n�Y�;�S���.3��8��+V1�%f�H%���L���x2gz/䤰R��|�y�����^��f�<���AZ?T�5P1�?�s��C=*��b��"z4�~i'ֈ�;���><�w?������3D��α���?t痿�ɶ��?��@�E+)��9�9��e/�C�!c�!�'��5Ɛ1����K�q`ĳa0���`�dV��l�'��.�U��Z�[xhߴ�?��AD��B[��Z)cUL,i�[8j�9G:�/�]�hT�1u���+2,J�[g����C�u������ص��V�J3&��	Ϙ��<����f�k���/�ƪ=��$���fM���lO��+��כ�D�QgL(���1��
+����W���[���ʋ�xD>�L�{�!��a^3Sdr��c�/~���wֆę����f�$Z�/�^d�E��06j��gŵ�%��7���b���A+��"|�?��+^2�=_��F��m��j��'.*sgV'׿�k(\���7���;��D�����}��z�A����&9�@ܻ�W�S0��m@��ye�W�|�$�O{�3Oo���y~�Ooؑ�E���O���c��>�a$�a�_��q����ӷ>O(x�ͳ�g����T��\��r�.��e�!�����M�|>�cQl�X�;NmO�ce.<8)(�}���y�k��l�dc��j�Bd�=��(����f�Q����T�Ysy�'��II�3��=��'��ϣ0��})X��?��Y��;�w�u��Mo{�����/��ז��ќ�P����J�v�7��^}H����	�z�'y*t���+堕�Z��h�[1��@�E/п��a���Ts��{N������;���ǅP�#*{�ο����~�e�w�"S����_��P_c�:&�c���}��z�~��*X2��vGL(�\g8c�����t�Dn���܀�t��&�Y�ɕ��4�$�hӜ��ץ��	a#�,~��wR���|�R9M�G�hb3X�)*�Ёէٜ	m
+Ր.��#{�^d���d��yȾ��[i	��ٯ���[�1��̀�=cͧ���G~T���%̛��-�k^ʵ�K�b�Nys�acfX�W�J<�(B�`�[TT�pb�V�X>��`���`:¹D(�jU"�y���-��Smv�b�Uvp��HYup=X5O9]�7+8.x��D�j��ݘ�r��}u�͇�܄���Ϻ��*|�z�����\a��yz�������������S(������p��:Ԇ��[�H�5������N�$��m@>����˥y���&��}_�/`��q��A����=�+a��<���%�e�!�b�Tȩ|��D1+��%���� �
+�k�Y{�;�,x�����W���|��y���[�k�kA�/�+���Ax�ᰄ"$wS��K�`㑻Mi����oh�̯kY��[?�����\�>I���u�V1k���s+K��P�PژdԬԟ	��]����̱�A�:���Ĝ�^ƲE���ߖ��~�s�#�k(�d��wCk�Ѝ�������t�w&=Љ�@��TC}$��R<��o�j�}֍&xʤ�Ym8]�7d�@���H���9��ƍĹ��d��qTq�o_�6s<�������ol"��3/��958�$8lh������S����fm���� ����UGj�`D��81`�O�4��n�0�?U���@$|9�p@�����Hص������ֹYȒ�Iu�o���+Q�����쒐�#�����0��uJ��pѾ��1�])��vԐ�ql�֯�K{������˼���'_�����}2���L�n����׿t�4>�b�a��+����1/�ݡM�Vi|��h��ֹ6s-)>9�Ҵ��֥�[/����T.��ܢ��9hld̖��䘳�B9l�O��K��XS�ݐ�>�����Eb���C����8y0�8c���&��6X���Wt!�׵���%��86+Ѵ�E�������[�����Qv�%g%�����j��F��y싗z,��5�ԍ��w��M��[�z���Y=�4��S��ǻ<t���B�˦��4�,c�h�����d�*=#���7��HC����x�R�x��e~ ��10"�i�I<Լt������#�g�w��%f�t����@Ǳ5�$c쨟��<�Y�1���J���Kda�����$*?fS���!׸a�4s6;�c^y)����mG0#�F`����	_[C�j�s&&@^�(��8R��!���~�9�����ϜRߠ�fY�klB�gQl�v�B���~�ߌ�d>��I��3�+��b��s�!{��S?��EMb__Lc1q=}�|꟡���@~�׹�D�m��(�Ŋ��|����]N���y��ƶ0ȧxC������"�m�/�j3��7+B0so������BK#D�2<�e6�ԋ\��I�%��y<�M��q�a���~�9�>����l�cM�۫YU}G�\|(v"7����;&�a�b�O�#4<����3��AT�,m 렍�LNFh��R��о�5�<�e�Sr�>>Yǭ���S�^d�|l��6�a;�/H����&�ē�޵1?2��ֿƋ������ߞ���_w�p҆�YpK�
+D��J'ӗ�ꕧ���M.V�vш���r}�o���`+��߶���2�>)�.|� ��L������*�O|�-�k͌�ﯲ�G������\�F�����4|F�s��l��t"k]���cV!�-
+�'��3'�g,Tab��j��*��h��4��2��>z�d6��HC�ߢϣx��;_�R��X�����h��XS���>�Q��ȁ|{����d�!���.��0Xm�=�n���+�j_��gO�֧��Ֆ�>����`��Ѝ�����ӯ�?4�,��F����+�1����:Ai�����ҧ��k��WA��U�tj�����ؕ�9-v)��g�:~��HL|�:�\�Y_Ŀ��@m}8������y��f�o�]O�/�X�
+m��q��yQ*��Z�������k�<"��[N�|�kO�=���G:w�Ώ�e����E�׽�M�!�FB�2�:�^��ʠF7��aw�Br�A;��U��?���T$�� �~�8N�4�U:�{*e�E=��e(�i��t��]����ܿ�T�8Mb&EM�X�_fbl���_=ek�=�M���	^��־�n�a��,ն��F�u-��ǋo)o�ֱ�V�8q�Q��z�< �a��^��vhGT	�,Β��،�ƣ����y 9�U�@��m�MІ�(6��p3�&���>F��ղƕ����:ﲝ��yyn���jS:���+�i�ݙD�]l�oM�3��v��)�nڎ-�o`(t�f�C�~3&�d,�|3"�2�f���`F��#��D��b�n�s�e����&��=��;}+�A��y�ԏI�����qq���㙘��+�}�a�9Z9&Ldξ��
+�k2X��9�}����?>���8=M�_����EA��=���D��>�q뭷�^��o8�w��҇���=~��x2Y5�u��>ǩ?cT�}�H���d���۵﨏��)ߘ�i�q�����a�ws�}��42�u��1�5��t��`�v%^���5R�cU�)�V�g��r��C�u��Q�u���w�Ϟ��xFo=�m�)G9'����9���?�&{
+�P����;=���p��uj���Hi�sԩz�8�a��Pr�r�/�r�"��$Nv�Iz�~�ql�@ƋL�=���~'��3���Mľ)St�&�>�>���h~����8���R� ���{�w���s4��Y#��L���T;�q�0��S!)@�h�F		t�Hx�u<l�+)-��M�.9Ũ�.to"��D�|��A�ٜ��h5�#UE�31nu���n⎛A��E��"lcܤ�0zLil`�%����}͝�p���y�ȗZg��J`�E��;[��eNt�i�K +���kr�z����b�'��6܄Zgp��G|��Y� L��[?0�X��o��t�J��<C�~�|`�
+��$6�5ʙ�"H���j��F�fv��u���+h���+�q�uơ0�gs�}����	n��J��"լ�
+y�c�z�q�5�T��5G�:E~E�UoH|�[ު�{�����O���'��+��7�nӿ����������O�����(�#�&��6� �6Ev��#O7I�ni�cZ䋷X2}��ι}�ڠn���j�l�,B�K�!Ǒ�{I@���x ��&��Y�2w���Gs��]�'�����q���q<�߾��ڳ����e�֘��j4h⒁Y3sڀmwC=q����LIqݰ��c��r=��8^��5ϧ��go��?mo�&�tbr��>"�T�i���[��c�����ˢ.���3&�Z��CV.�|��=���͟+�m���n&�!X\�����Q�8���]z�ζk�}��OJ7��x�l���>v]w�"&9@iss����EZ+?b�
+,���)��<�F��%=L�(���}�s�k�d�=��E_,ы�>bN�s=2�;����;�t~�� ��<]����g��av����Q���+��<��CJ��:,f��z\dV�T&�2��6%}�ޠzū_}z���io��+���������0VZ#:��ă������$��	,�+�=�҉}�~��5iC��A9h���C�˶t��??��?��/����8�Ɓ$D��g<����p�ׄ>-�r����4v�I!�X����z�^V:/o�+AJ�6~��p�A#�e,��Ht����B�s�P?{��tꛇx�������'�dh+_�R��v�+��yt�,���Mv����>�o?�OO���O���\
+�7_�R"�|�&�J�r��]e�G�NzhPr�gP�ԨGl���]�y�WOfj�%fy"�5��Wr��zLN�%��u؀���:�"k>P�ZY֟�\C}	N-�%ċ
+�����6cX?h���])v�{�]eՇ:E�@�C�]s�)�!G��K���0���\�C���1����m�+��;��=p�L�ot_�����'����x@\#7�c����M��Y�ysI�0_��z�:���'>�c]9_/,�H��̢��rHn����X^��֮?�?_f��� -��ݡ�IZ����tF`�}E.ʽ׏������H8I\b�m��]f��un#����G_���Rf�2_U2R
+��FYi�}w��ϼa-;�{���}�{�;�_�IЁ�/�
+Η���4sl>g'�n��+��ё���o�n������'���u2���Rb�Jݱ!�8������R��w��5�n��N��z��>�)�9Q�qhG�C&q��;��UM6>t����?{�����i��ry��x��H���`��;�f��R��y(A�{�r���; u�R����܊�ct�������N	��������u����m�L�ǧGcq���B���ְ�ρA}8���#���L��A3��,n)v�Oh�.��Z:�d��+#��i�?�y���p�b�1�o���R�ꗸuO�8�aK��Qs����s�����a��5^�A{�f��K'4�\���7���|�O���Km����W^�����jB'���c��O���^�_I�8$o�͐9�_5ε�+�1�/垪Z�M�����v�VJ�`���h�����\��O�f�5�~ѝk�"�:�������Zc��k�o��|��̯:Fn�5�K�lk_J*�A�o�wR����a�%�}_�`%����m]���O,ƺc�����V�����k�xg��p#?�E��>�~��l��qHs~�1�1���YH�#ޛ!�^4�:W��ώ��o�H�߀c�|�;9�i�Zme<�R\��^��f����������>o�b�������m�Y�������|!w�~��(�Gݞ�4OqO��nZT'���>��@��������/"����_6.��u�E��;dm����Nܖ�e.tK6���w��Ů��!�HޡlI�A�l��3���%�ܡy`��M��O��A�����C��!N?��0ƀ�~(���7���]6�l��N.˃\�)�7^�>4dܨ�#y8�ɗlz�[5H��OG6��hdJ�T��2k0t��2>�r�'�+��=��g�����w��j��b����:r��r�y.��w�)'�`[V��X��0�h:6�Û_Ib��XA�W����N�!�����O6���}����A6znN��������!�@�%�'7�����.����)Oir@9h�+j�g�.>2�Jv��C1�v�I�4knd�_�2N����8����Xp+����(�y��$s��H�f���s�9g�%*i��aMNؓ����2|��'G��O�:�[��ڦɘQ�^0�e���VL��1�"Q;���J�;����bos���}� <S�P�.�8���
+Oj�L�7���;�����<0�W���mv���l竿����Ut���v�f�O(��fO��-�NP�٢{D�Z�9�r���堕�|��t�����=��as������#ir����A�{��8	����ؤ)˕���X�����*w����Ō}�[j��G��[6����nJ�Nbj&ּ�����bq4�H�sX� j)���C�^��ruY+���ݼ��f3��o �&7pM�&�p��L�'��Mm�<����QT�T��U}j{6|wu
+Nz�
+�z|бHX�c�J�i��r�qw\�*y�m�f����-j�F��Ϙ���(s��}��g�c��!?��WN�����dZ)��E��z�y�@��uz���׹�Y	�8%�g}R#�2��ł262~���qz�K_�|q&_�I��R�����[c�$��ׯ_?���`��ٟo�(q�[�	p�<��\�q{��?c���ZYk�e�:e�(⥃�ٙڰ�9'��9kŞ��f��Ka��j��@��|�ȅ��2#`M�G�>���2����<��5�yꆉ޼���%#�~�|�=�C�BA���E����g�=b5���(k�=��GKKT�ϼ��*��!~�]��ń�'Ns�?���na�./ǌ��dR���{ϱ8P�a�/	���2|���_�_�]������������#�s��������G�{�Z���81������T���s�>���^��O�bK���q�1e��#�ޮ�?�J������\|(�h׆�!�Q��/�`���n�q�����`��0'	�B�q_v|�h��r!���ju^�o�[��˚�_ř�U?�s�+v�U#��G��z��<���Ѽ"v��`�D^*����fa��o���MU?��䧘�`�0�
+d߼d̷u��#!ףe����4��}܌1�Iji�yc%c��L�տ�oH짢���3>����,{��>��xL��`�5���S:s.�(����[��+#��4���"4O���Pl���h|
+����`�m����0ύ3Gd�2UAG<^\Ғ3�Z�n�S?6���g��t�I��#?E���'��4���ǟD�|�D���M��U���?��Y���u���@�%�p�����&�����Yv EV�fH^���:��QA�N�hs����|y�YiI�g���]?���׺�3�P��J�Y[��k˴���;vB�^ya&-�� �������Z������5�k� +�{���G��?p�ę/����>T��ڔ�����ncH��T��&Vx��?\�pB�8����o"q)����яy��Sp�3y�	r��@�R*)�}��l��į��Y<��7��<�^�Ă�o��ɍ�S�Ao^��CIp�K֥X�G�[���"%�r������I���Ԭ�.����Fr�ԃ]it?�A��G�@
+�	&�3o5�ֹ}փQ��1�]b$�y�'�9D��?��~֙Ƹ��^㑳�P4�s��ח��53��wlp�2�v�g�[���`(�o_Y��u���~c(��7��z\I_���d����0v����b�4���0�-z-�=_|��]��Wo�$k�����X��������|�A�+E��"|�n�<A$,�'C��]�v9a=����b�����d��<�t�U^�����e�4�5��8P��\H��#1�)��`�w$b��:qf��6���H	^b�c����G��X<��m�	���x!�7~y���YC[��6�{��cT���A��U9��O���vn�xcn��h��Bw��U_	?~��Z� 7�`F�2�f����oW��%��Ȳ�����l����i��%�9����������܌1���!45��'A�)?���#�Qz��O����+�Q`�y�Ĵ̋�5V`>�?��-�z�ۿ�O�WN9pڜˎڵ����u��6��7���~��$�h%#��?.�U�tVK���C�r����������"2p����*c�ށ{�È�����G޻8ۖ]g}[���V˲,ɲd0`b0	�ȃ�T�a)c̟R��!1��Cc��#����`�H�zv�$$����1�Z�����n�k�1��c�9�\k��9���g~�g}8�P�R`���GOde0wH�c���߇lF/5\�>�V[ NYs�X�[���c�E@N9���t�na�ԍ 9b�����O��,>�"qRCp	ĵ�s��l��m� ��o�����C�^�¥?�d%z$�D@F��,p!愖̈=��������S��	���k���y9E��|���7H�����+�ԓ��]t���'}�̲9�5X����92i���x��:F�W�`a��-����ݛI�c۽����6����f���$�����&q'1@��_k6�Ċ��*c	dNx�1��1��48վ�Q?�qj��6yĕ�޵bn�6t��$$���]���|ې�����>��I�~6B̎ִ�Rz�5����`9:&���KƗ&���:F&�zM�P�-v��~�~j�?v�Ah��c��䚴�~r��0iƍB,eUg�
+�+�k��v��o���蔅���I8�M'�_i��z�:��g�^no�q��wf�[�b]kF��ֺ!��/�b��}���O_|����+.W���5]D�Y�K�n�����b�����2nk망^�q#��8<��?�������A���b�&��lZ^�x��03#;�E;�{���7��%R�E�ʇ�&.D��]�f�1�ԓ17�1�T�{�0�/2?h`��u6c�N�U(�+�Cc2Ms���v㇯�v�.m��k�;�'�s:�s]^|��97��Q<x����!Þ<�+�Bd%�/����A�������C�_|�~e��v���|�dfRx2�����}�����Ӑ����_��\��z}cu���+�5w.cW�S`�G���?�������P�-�t���#}��A������=x�(I*t�w��y���~��ӹ����0>�`JR{F���y������*�c��8>`��(��$��|�£\��A'O����J��3l�?8��
+�Pk1[m]�ް��K�69TaZ(,�PNn�� '~�s��tLͱc�]+�l���vh��<��\`�����>�a��13ɸ��&J��y�� Kpz�1�~�x�#��������P��<�+qiX���pWffzM����?�k*}x����X�+��Z5&��y��jM9��x"�ض~��7�?�����o�&ej��u��I��S4�1+�X#3�`�]}�ClG��~��i������4�(/?�e즮0L5��&=�.��l�DDg��W>>O��+/��~��K+0��y�`v�!��߇��L[NiA���K�Ȉu��r��/�����q���Υ��oZ3�l��ז���&	mLd��aH�c3�G��ft�O��}y��N��L���F#B��K���}�Jj�|ވ"B�>��ۿ�W�ww�ׂ�?ys"�Q7/�������o{��{���b�Vߌ/����(����@t�-
+���C��H#{�ܳ����?p{�����9�3.Ȉ}�洑�W~�������O�~���Xs"��&�;y�+�����(D�Vh��% ����db>ԭ4T�>yq����y�
++�o���y������&?�G6��`�B����P]�ģf�H�f�_����]�h�:�7y��T_�d��|F`�؇@&-S3�>ho�K{�����Cj���ku��{)��^�f��TrY��6S���\a8��?h� oWX;2Ͼ1��3� 46;�z�����P׆1�q:�K}#��8o�����TO�xuvP�;�_	�_6�f��Py���ٰKqB���^o��o���$��������i�3�P^�����=z�?�?�UaQ�����ͻ$J�}3u���LN,JS
+�4�h:
+��3������7s5>�!�s���b�Q:[l��!�ʴ�����0�i���a��@��A5��P�^�Qw�5k�1ش��ϸ����u���-������Bd��N'�^5�+V�6�X��m�}++ml"����m|�O�a�>�tm�84���=#i��?��}�8}�>g�jmb�[t!,��=���8�Gh�m�햬$����;��v����RC��C#H�'�x�z��р�A˷��+�h����~��+�k�+�J>��y�?���N��r�F5���5��;�W���|�c{��_��g��H�+2��/�9w�Eȸw��(��
+,�����\1G�p�7��b�(�r�R��g��v�(������:h�&&<�shk}y�l�8m;�8����+:_����ȡi��k;t�R6����ù��;�K��&ǵ������T���.��J0�	ƹ�|�=�y�G�mDA<〃�3J���d�m�?�����3���zj����OyGZ;�ك��B���/�tx�'�4�,�3/��������<׿Ϲ�3�܇��(��k�[�T�����m����.=��#H�o[:�i��������e�������A��k���,��K/�j��O+��\mf�w`ضЌ�����ޟ������!�ި�)��6���oK� ���~:-����-�Y��N��ES�bl���Qgޜ�&%<�o��#S��3�T�a�ԗ�D�}��SӋ��сg��	�7��D:
+����ֶ̓M����i�偑z�1�'����dp�=zF�\���k�}������(7c�;��7��݇�8Il�In}�z6+���{y�|��6��9��J��D�$��`��Z�!�ըX[- ����,��a���<��^�i\;~c ������x�37N9ȍ�P��۹�/����0�^����3��2.� ��
+�Q?E�m�.sޘ��$�HdA�eO���'S�Ჱ.��8]#^Z�;��u{���?c&K��'����|�`�����m��?ׂ�t���F��q"?����0&
+Ŧ�s�Y�Ԇf�t�K�u0ƍ-1kʷӢK��o/5��R
+����/�/+�*kl}�q/^pg�!eM�;����2W�E���P%94�Q�;��(�����IG��0bG��W�NƎ�ʿWM�>˿�⋟�r��㠚��o9�՛�1i{��ھ���~��W��"��k��ʁ�҇�����x��/����s��^�ڬ-�#:��.������
+=���c�H`p�2��_+
+� ���3?�f tg$z�!�8'0�d{^�k�W����z�{�!���=�ot�Vr���O�_s�������O��?w�7���
+(�ZJ�N���)��A��'c�M���q�b04�t�+��tԌK�:�E+���u�����\��L��1ّ��Y�Z���3�������g�baT̪��4;����Y�>�#x���2Z�)2�,�FǾFh�2(2��ä�S;�l]�v,�抌���ǎ5�N���
+M���࿐�@t^�[��s�9j4c$rׅ<���sYȩ�@��$��7b��&�>d�殔����ysJ�䔨"2�h�Ʌ:��ء��Ƈ�)(���2�LbP��!�Yw@�����1� O�b���qDM��ǒ@B����5��RѺ75��t����x^Ǻ� o�*="L�;G������;����8�+H��v��B~�,l�>}�x�R�c/��bLe���k�Z�ID�P��0#+w������@s�ٲ�?��7���FY+�SN�[n�ُ䁓Y�rZc����"+�n)��?���@�\
+�v��zK9wn5����ԒVlS�u?���@2}�7��&ƙ+���\�	Sm���k�����<�~�sm�Մ �A���v�P�M~�����Mm�?h�2~g�2'
+)�󜒜R��-M�N���Đ���[S�� ���Yz�z%�<��>�B;�h)h]*���j�1�t�c�=�����]��'�������&<ة�Zɧ
+\�1Ŝ�k���X}x�v���8�m���ti�c���QL���Q��ԱA�I(K��������4˖O>�h��n0S���0�5�]��z�Iʱ*tSdt��	БA-������	Y����R�A[=hQ���T�����ɑ9�a�ɥ���ν�Z�z�cA�詗�t��u�0����c<�E�/���Ad�
+�]۰6d�h�s�Y3h��i���9x악g.@��F-#���,�.�+_���	�Oõ���mi{�|��1g�X2�w��N�t��>��]�Ž�������1>+?857��Ư3�H�PA��r�����&��xS�>@?7_�G����)�M9@[Z�����;�|��ı���;����a[,���c��D�u��&$��`�a��v�����y+��A��"-�2�7v�d�hv���&O���"#�0l���'-���n7�+^���s�B������+Q2Z�6���k��{��uCi��7|��7��0���	��]o>"�y�q�Ï�"�=��8�{�1HN�x[��9�ʯ���_�/��4��=p�g.\��&.���w}��	�1�xF�!���o�N��'&�9hR@q�ȅg� =U���w�_������0�?���x��=�Q#�vC��+�O�fy��Q��#��G>|�s?��o_�������5xk����C�w�`�T��Vm�1+5�J��Qjw8����%�=�$��k0}(�+x�)����xA��B/럇��4��U?��]�ū}1'x�#��n^���'�Q|���+�m˯����iK�<��/��u��y���� 4r�Ch
+�ii+;�?��V�uľ����&�����66�[r�:�w��7pxH}�I�ʰ1��M�(C���f�Sk���Dd�+�v��d�&q�񘘑j��v���6rh�Y���	�7r>�����բ�+D>�ʟ�J[�[n������;�K�w�-]���A���*��W�{��!�	e�4����w2g:�)VM�����)�!�F��ȡ^���_�70�}<�Jtchޱ _s+ߣ�®{d3CY�V'�r�n��v)�ڔrƼ�3��G
+N����{�,��� �J��E����9��Rq��\�)z����!�4���dU�3�f�4�	�7v9�p�����y��i�w�U�~&�FGBa2�o�?�'0�����څ8�"&�P�#�C�TX�R@{�č���G���.����e��R<^o[_(GǾ������-�^������Po���͛��N��2����O|�_�W[@��+���r�E��cc����7:Zy��|�2z����U�pL�����*3~��q���,����8�
+P�G=�$u�/ݚ�?ʮ��ON��>$���g�#&6m�_)�]0��d^C���Q�zc�Q���?�o�����/B���?����Ȩ������~���轉���<z��t�:�	_�v��fN��[����	����â'+���rPy|����P5��E�^K:��u��|��^�q��T��Ԙ�d'P���B+��Y�nn�F��������D�Uڛ����~�M��;�憂4�T��+��9sMd���S=�!�N��r�����w+��8��&N�����?��ӷ���}�����!p[�R��_��n��Wv���W�/���Go?�+��B������g���㩌�<����r3�ɮ���\s,[m�����h+����/���uz�c�m�$.w���{�6���J��u�X+S������`7��FRa"Xg���G��f��Nr�-�"��k����������ݽ�yx�����,"�W84����xM�;Fu�7�+TU}�1�j9��K��H�<h{��K�d;s���)`���*���}͖&���	F�ҭ���QZ���]ե�� ޻tl{Y����mu����_����N��~���z!/]"S4�>_������֛e������$޷x%9�/��O��'vἋ�>�C�]\�+���C��ϕ_[��G��O
+O�K�o/�]��4�a�t�r""+2��"�C�Px�gi���E+��I/Hʠ�-������V�L�}}��NTd�l��y(�ı��ks+6rb!��\��6ͯhɒ�!�;�O���'���'^ʂS,jB2o�͑������{��LBd�OP�4���������	i�ɠ��N=	����[b̿����̈�z֟���־Q��@9�6�Z��snZ|� �X��W]_�}��~���CiT@�^y��L=�����5��G�Ub�U���u���Oǯ���<(&@�b�3T�A��,,L4˨���+����"��S���z����������]u���ɘ�����(�	�zߞ���>��o�����/����n)kX�W�{�z{�'��x�N�/b>��$�)$ �!�n�Cl�O!Qձy�Ϛ�Nq���&�9�h���l�d��$ώÙ���!^x��R!�2Qɭ���e�C���ё#~J�tL)t���W��㚄ן\ҁ?ө,k�x�����M�l|�.����*���B �~��p��[��E���)��X?��t���?o�����¸&��Wi��9�,��;�[����q�P�%�Ll�u��]�*�B��C�͈4wF��7�#�?��k�ݦ��1.�Ld���O}�3��6S`���/5VL��u�����=1�:}���t<��F�O�{e��e�^S�)��`1~�tw�k~D8�k~����p���)��9��Vx�q��qѲN����_懟n��
+gd�Ð��Ѐ�8l��~h�x�����F{5�=B����b�WW��|�@[�����l�&+��H��Q~8@�7��D��`���Y�D���-k�n�<4B�@l����@09W����ڂ{�S�?4 �E,v�'N[vtH#(��<������q�xp�l����U�XKYz�/(k1FԵ��GX}���jd+��2�jK��uy����u�`W�q��&��v�׏�z��7Oҫ<i<��=N��7eWz���3!�^���K��>����
+��(���\ٕ_��ѫϕ_������˫Et�aC�k��"�a�;%�׾g��n%l���i=(b�r,�G$/Si+�c\�'�1e8�&Td&��l̡�I��W%cGd�Vnk-%v�N`q���#7���Ӹ��S�O�Ey��g�BC�FFf�84go`w��~ā[m`����[�R��Ǔ�������H����.w�a�����Go�WX�n�o��k��l�T�'�X!��B7������ߝ_�G4_����)�j�oP���ҜZm,��\=T���8�l��N;�g�]S�tE:���_L����{o��{~�+�!�9D2 ��2�;���>�����۟����'mN<�5���	x���Qr���<z�5�yf�?��S�hxb�:�%�$2��X�*j��5O��B8����y_�%���^,d�7�j�Y�+W6�NW��9��D�6���3��(����4Or�+��8�ơ�y9k�m�W�٬�+���+����F�C{�350m�c\�fqp_�^+����7�ݳ�Wp�0Љ 6���nyd~B����!��C��2/�B��c��E�X����'��Bi�&�Ę�!�Q�A�Pg:���2:D�C+ױ@��+��@!y����Ud{+f�I��v���|������</��A9P-]��������e���3������ģ~�������5��}�>����W���!?�f����Ed��������������H;T�-���:D�o��+KRe�]^������<�G<�¯6�Th�����x����Z�o��w=��͠�y�@�M�o��t�
+��++�5�ZcC�R�&l�[���q]��N��������9n��mV~����q�����?Q��y~�ӟ��@���?���C����s�eCp�����Jr/k���7x��u�b�W�+�bCy����si3�����Zs��32� �nF~U,<d��Dc�O�W�o���:2���~~b�U��cNp�|+k���Wy.�L�\i̽K:���������������+I�.�$�<GV��튧uj���I�G�{�����Ǿ���B�o`��|V�a���m�ۮ_}�/���b��m,�.m���v.��\�<^���������g�y�����=����9Gb?c��^r�ݧ{����_>}�š��2�T����lgM-Y���ua�����������r�EGV�e���O���1�`G�Lf��d$*����]%4���$�'��bC������6�K�E��ʃ�����Aq��l��XdEn�!�}=�PH�r�u}���b/|;��^©����C-��.(���Ќ�S�d��M���6fؠ�������ǡ6�kv�`�%��fK��b�oG���$V�wҰg�(���e��g ���8��D_+�L����$�U��G�N�(p�K�dU,����Al��/�����G>�[��u(RY:��f���o����i������jP���,�u���kW�H^07����g<���ޙ���������~Ǖ�
+�W��/�a�}������O+65�����U����lj�xxlc�qƂ��B�Sw3�~��o�&G�88O?�����=�G��%u�;m<Nq��(�I��"94�E��˯3@A~P��#`�.<~952�S�L������çʿ�J�~�W_hxGIx�co�+W�Q��#���<��?�N��sN� ��ɿ|�}��'|oyZljA��I�G͖�@��Qyq�Ɵ�Ǧͼ�q?F�1l�X�j�>sØ$��b�5'�%�Hh2�I�U�T^S,0 r�`}ı;|Wx���G�C�Y�b�Z�G"WN1���o3�$��?��b�Y��y9'ۣ����%�0�W��PZB�.�Xq�6�v;��pj����7T@��!q���PCJ���o�O>�;Y'`���x�1�����C�**��;"��^��7������|�>���M;j�slrɋ����C+g��5i]��4������|SI!�ֲ~/�Am�����㡚zbN{�:�8�R9���{|�+��T��2�fD�W���3t�GTϝv\��C�<æ�9�lc@|cs��s�C�c� �d��V*o Ln3Dʚ�"$}�;�΋:7u�a?�He�d�:ا^Ieg���|�I'�c
+�(K�2m"�V�����F��3���������I�4)+�����q�Yvrv&�';���V~�G�~�����>� ����d�z�׋�y���?2�#�!-���Q+������������[���K+n���U�ohY���%�%�OVy�%_Y值�/���ڿ�NN�:X|��aR�U!������=�D9q�l/����]>'��\[�5�5��}}��^�L+�k#�/�s��>>�3m��+�����MX�������9�'�g�ֱL�D��97���&��>�+�]��8q8�z���6;���ͫ�=�@�ބS��|�7+�)�Sz�uu�_|�{�˿|��B��|w��W+����������� ��SI���:XK��d��Pwn����.'�]I�7Ћ���d}��%�x��7y�M]�=G��r��"2�'W�����z���h6�-�Z�|�$�푨Xx� �D��7��}M��o����t�r�C}��uŜ��t������o��S�]���Hp���o�r�H�ȧ��I;�>�fl��_+�^��-b��M0V���R(���W�L�Hvt�|����"��S欍��o��X����w�&�:럴/J�(���sP��n���o���=/�2C��мy~���+.�����lƎ(C���X�y+�s�q��*��S�������?(lԲ��]=~�k)���_��R���������k�)��h�`�<�����B���:T5ߣ�x �ɫY�"?�r��ys
+?�!�@b���ʭ�?��ΐ����٥rJ������sF�\g��l�b�3�Ayƶ~��9���9�ʙ�$2my�_�`g�~���bo�ȄJ�����IO<��q�L���'�����7��|.
+ֱ�n";���a�n0]��'�̌��1s��Ď�ukjR�ɢY��CA�����@G}ǚO.H�Bzca'�|�{��1��㟞�[ެ�g���/���G��Qslu�*T�
+����ɥ��_���������ɓ��r�����%]��lX5� �O���ӱ�"Y,�t��v@�Zu��v��G3W�u�»桫��S����,׾	z��_�Nx;�+��.��O>�3ޤy�% ��K�;��+����	kڍ*��wً����b؃�N^�Y�]�;�mv�6`��@����Z<t�?$���C��`S�R��$aJN��_��m/�y'�]�4��[��Р�~H�B�؈�bY�>�+lK�K�IE\�W�-rj;���o��z�������{�;��&�Xn�Ն$����.z���ۼ��2A�	I���t}�:Z�0����+ߤ�C����sC�H��Jn�r�q��C��q�%U��*��P�
+^h�����;X2ڥ��Jӻ�W�X���}�Hld��F�;ګ+�F�B��4�~ș#x��k<���&x��˔y���8�I.TC����c��xS�q���ĳ1�2��8&(�m��5�М�m7+��'>VⱸҟsZ����+� 9��A��CG�=]����D��L�Ć�,�r��
+˧�D�~�{5����/�V��!3x(-��G�e���p�S'�]�kà��v�E�h�I���@�=����TL�'22�N]$���hlr��
+^��x<8��6�d�t����c�|<��`셐T��RklĚd�Ύ	Wk&�JpGbp��J>X�F�5��]��b22�`�o]���;v����yp��dFPNX
+�bR���GQ�]s�e�*âxyN�{��<d��;�6���A�*>��7�Y�.���:Y;���7	|>�4o"DO�?1ĥn��Frd�N2q�lvj����<c< c�A��|��tr�e_��3x�1$���g#��������y0̥~D�!�ϳ�"1/ڲ6B�/7�9\�J���e;_�]���g���p��j�rd;�M��^��uo��ʝ�:q��_y)�?��O���.`�i]��-�\Z��[x��#�B�4�(Qo< ��i��sn��'B�N�#t����g�A@�����z*����6c�@Ps<����3Ə9A���	�DWsNf�h����B��%��֞��4�mT��a0�'��l��[���Ź��ὧF�;���r;@y_��&������sa�<��s�`�G�1#�i�ݽ�8���'�ؒ�8l;��W/�A�'�~�����>	;�T��;�8mF�b�h�E�CZ]L�#@��W�d�G���r�9����A�
+e+�C��|��ۿ��zs2i|�+{u��:A�P��z0������?}��?���1�Y ��Cz��]���~1$��ث������Y���(�ؽQ�۳��q��4s�Zb�,�x��9��<)b�i�7�Q.�.�C��+�s���f���n�͝p�m������P:$|p�s�`A�jk��ݛt����X�p�Jơ��j79��G�󩭡�^�����<|��X��O���W��5/�����Y~ǘ�i7�|����'��P�x�Gal"���������_ی�5g�{rq�+v$�[��DZ�H���P,�)/ɚ�j��N�7:ܱ9c�������*�r\������1P(S����<J�!`����1��<?Su�e��f{���x���m�u�D�qj���1��[9��������h@��[7u��5߅fj7��]��ǵ�o������!V#��]�tw����nri�GF���>:s�|�O	�����o"�1w��l�?��|B6��V�Kz���_ڿa�]�o�^G�L�UP/���_�.�e�-�k�X��@w�8���5{�k�M~rLZ���O+NNh<j��搐��8�a��1�����G������g�&�3��Z�X�r!�oJ�;ճ�u5�\�<����
++R'�H�>!�ԏ=���u,�	�[p��e����3F�Ɨ-��.J���>����/��o;���4�=w����^�s���w�e�=y�ǆM�x�Y~����/��_=��?��ӗ��QH�_�)�����}"��:��<eH��Q���&sI�mSj��iߜE���,z��a��x9&�M�S��ɛ��d�+�|�@Z՛h�i�k	�U��R���R$ˠjY����u>�
+�)��#�N��o�zr��N�kW
+�	$��?������8�+���#����<��x��~�	��䎨������g�8��+�?u��n��h���0���a���d �g��e���4\�gL�y1�4�����+l�6{׌����n�X��]������W<.ވȅ�>;5޵�\]��8�-v�Ï^������bb��N�X��^}����7W(v��c�#'a�����>}W��1�����愉S�ʆR��C�-a:~貭�W�h���0v"8p�MAr	��wcN�fA����Y��Q�6����Lݫ~������}������:�+Qr���A+Mr�+���V2�:�`	��>{����~�w7.��O`��M�)Pp���{�V7/��2'b!D&�Ъ5�c��Q��Ή_<Ԗk�ݰc�6v�E�#?��i�#7�$��-�v����\�2��rCLf��'�����a@��+��Pm���+�q��qJ�Xۂ�_����7�V���8��@����A���l������h�;���%@%�u�cG�7�|� kAbb��w���8#ߵ�]T�|����ǲ�}\7v�a�@X.MLE�r�F:���M<��~{�'+a�o���F���<TI!P�ͧh���42�%��P9'���V�X�Y9I�k�M�r`����$��������7���/����b����żv�N	�g�^~���/��}�_����^�V��F��j}˽��@�	�!V�rr<ѩ?wW�ׯ<w��9��>j��-�yb�o[n�	?����5�H���O�R]ƧJ˰�teNT׽d��lZ�����Toy��#�&ᚒ_������	B����:�b����R��&���+BRr�D��SѮ�9O.���0%�7�XB�5勩���]3���+�B�|�[1'>F��l6�ӵ�7��k����+�mԟ<go������p�>��R��R>��=�W���q�j<EkW��e��f�`����җ��2r$��/�^��F�7��W�7Pʷ�����������O?�Tծ(�`�W��Ȯ��F�j�8Ņ>쏁)mN� �;_��-�M+Cc���n<����3Ϝ���U���/>(�h��c(�n����vz�}״�����h��v<qL�~G�s���8�p�+���hkGγ���&�Q�;Ɗ�j��$h)��'�m�e�6c���bL���F��_9)��8����ɕ1�w4��~0�{L&Ne��p`H��(�拟Ǜ���1f�D��v��@�a�,���ס�|��׏��#��xhqJ����+1�R1	j5�n�E}������#FģA�s���E������(9�7&M����"������w4�:��+}����j�7cW�O~)�Gwd�&��y����]��}/��>=���+�+Siܕ���O���/V�{_�A�>5_��1���(�B�{�9cQ�3�u?�M2�7(��9����1�"�U�֞k�+�0��(��P ��F���f�q�̱�jS���C�m���7��Ͻ�c��q+hPv�9��0�E��5&��R�u��+�.���0D �#��i�Nڸ+>� =$6V�03�æpCw-�b&Me��c�;J�����[���&9��(T��L�c+&��X `��^}��_�/�s�w��?�_�8\���?����_��9���ϟ|���������~z��9�����ǯ�}z�>p?)h��.������ܛV��wu�(r���I�Iw�C�Ӡ�o��M�k>PZ�ب<�@���2�O����|��ĭ�Zb�D�������P!��l������ulWx��ڮ�?�z�Ǳt-�mԏ�����Df��a^���V���U8�e�5+_�R��Cw�|#���Ol��IW\�-֊�O�+ӹf�&f���R�8��@�w�ӷ�
+uAWC@��|�%�Ki��!��X�sRM �dkyP��A|F�����<�ikv�q�v��,]���cc;uK�J�:���7�7W�<7c�e�Ǐl�|�
+�<�c35�xH�?ЩRE���������Z����L0d�i8c�y�oI=�j#CܼGT�M+�2�f�����Y���M��
+J��ۿ�;O��W����{�v�`��q���{��d�<��}�~C�.��)�IDC�F+�����޼x�{5�9v��_�0�/���C���G��b>����̰���l�P�YܡlأC��c�z��u��6��~��Gf`}�@�l�ȁ�����&�HQx���Z��7�qY��^���~��`����14u����Z���O��`�����c�Զ�S�]�#2�5]�+	����{�mԹ���_�oj��m�k���Fƶ��c)
+D���T��j��l��窭أth�ЦQj��
+����%˳�b���|<*f�2Ʌ7��<�]~����y�����F�7�������	�o��U��xᓟ��G��^�p?�Б��u;�u�Z�ɀ�Vz։�OR2��m�3���N��������/�m����޴[���sm#�M��p٤�`Տ$�E�R���u;(F�K'8�,���Y�J=Q�����5�/�q��f(���Vӕ�qr���-̎'�R���R�"�Fg�v���;	������K��s����j�8zx��g�}f�/���+�M��O�+�WΫ~�x�e���ubࡐ4�Am~����L�cb��t�&�g���6�r|���F�
+~��Ӿ6�Jn�����8_++��\���0�hO4���j�N��dq�	�&g��7���3a�ns�I���#+?7�gc�N[M��P��Z�)7(S����t���W��Y��+j_49R���>��87Z�3&��s�M]�\Y�@�ЀMcp#�mM��4ٚ�����K@0,���\~�s_0�md���Px�K�5؂��O)��v5"�O}n�|�N.4Q��6Jr�Z��R�FZ|��	8`�WnJ�5��<�Η�M勀���g�07����'���qH��WѰ3p���'O���9=��w��C�nC"�.���6;_�/{��D�+z�{��������;}�9>�7m�w�8�|7���������w,�al<�]�
+,��z�7O�ıL�����Z�Ǎ��ؿ��̉�����+��H�{�n	]��
+r�;X�$����s��Jr�rJ`Aa�İ�z��T�@|gY�I��jEh���j���{,C=��Ϣg<���yR�Hք�*a��q��ր����Ч����Rxmc*۩n�P�f��^r�ӯo����5"��m���DU~��g�_T\�j�M�|?&d���FZ�?�7+����~����:������7:<������D�zQ��k8;Hh^OZ�?�On�������1��s�h�jN�)��eC��ΐ�~?*Z���!��"�C2�{~umc�P���C�|3&8�Q+5��5�6]��f��]�P󄩍��)����Aw��+v��Ώij�t�	�!��>팁��Mw�
+FqJ1;�y�JϿ������r>%7���i��n�����vT��_�ް}n]��5&��	��>������]@6�J��Ue�b�����g�o���?zW�^�)�A����3�P{��R�VL@��5�M���P�Eu�:dP�]q����'(�����/��O�ғ3�}eą�qEaݝ:��p��~��Y0��x2Qb��;��v@[������4v���B��#�ל�3���T����DI�LQ^)X}�+�&[�����W�	E�&�6׭�K�G�Y=Vǈ>����m�����8��؜7	��YK]z�v�8.F��>���D��ˊ�+?)V��OJ�u~V�3�p~��X�uB0��P�g��>�*C�M;h:0b%(}�&T���Ak�mi�v��$p�Ӳ�����=��j��Н��(LF��Ziz�{li�W������
+t����n��7ZF�y����/��'��O+���L� �̥S�٩#E>f.!?:���������F\$|�L��N	>u�2 ����O�����O-���c����Ι�'�d��.���J��W	.�!̓g��lA4��2u�.�j#������cHr�Ș�q�*�56Ƌ�Ǘ���#iŠ�|M��@ ��Nj,�3�?���\��Fކ+^b������}���7 �+��F��+�xJ��+Q���g\	���x����O_��2$�I��sS)@�58Hh罴�\��$1���|���������G-�j�:9���������T �Y�$�Z�j���q�t|b�f�Ğz�h�5���^�΃D��A\,���|+�y��܌h=���d��`����A��]e��R�b��?>��j������^���|�sɽ�0P�W����\��׸bf��R8�f,��cMpb�3��_s.�ŏ���Ė���]�]��>Op�i���I����J\d�q5���(���	��?���渣B��/��	�����M�Hx���ȵ{6�Pα~����7��[+0[>��,u��=bc0
+2����S���b�������0]���ÿ�~�1~�|���X��k�-��1}��������Z"�('�+��VWMx'��/�������GT_N�U���E	x�.��J�Z|k[ʁ��u��]�r�Oe-���:s��D�h����p���u����{��ON,n�WY�o�;lFÉв
+.<���[cbڴK��Y�>�:V<�(��l�,�&f�8���xǾ��\t�OsXc�B���i +�ˡ��H86���4J���ho\NH�;���+����q�+eabDP1^C�r3#�U��6X��/FL(��U�8��".�߹W��$p��\�Lr^�5���R
+vN' ~���8�-��e����!m`m9�3����m�S7�S;VN~K�3�����+��xvE�?t�y���O2���nvt?5���XX�bW=�Lʼ@1�'��s#��xW�Ι�,r���ȹ�I����㔱S��a�&�K3	���SI�IxѮ=�	�@��^xF�M����0@㳆`�WA�Sxİi�V�t���x�����_��	*�7��:v0�)��3�"��ӟ��Wx��q��uu��b'!׽��W��v�ε	Z����̷a�sx�gY�d,����볽���2(M�ǩ�Ch�W��썋�_���c����>��"&�����F�w���&95�]j�~�A�����ލ{8����C%�<�S�f����3��X�k'~�0������ַ�d�۸`}P(�u�:�ˁ����d��>ttv��T����+ő*wh��e�]�5�w��]�&�z��X��'��!T��j:��,'(�~c�~�9���ݑl��X��[�:7�����i��
+;�t�?��-��1E���� ����*u������'b7ٵ����b��W-�UE�n���ㆶ�z'G��@��_���k�S^��i�h���11��ݧ;{���kv�ܱ�����왮ԯ�_}`�t>�p�^[��"C�:��8��׼l<J�<��|�1)aR�<�Y�Y��=X K�9�X.$�{��m�-�ϻΣ��9s�Z����>�C�������m��_M{�9��W����z�md�W/ɝj�c�Z��?y��'�������\W�\��.8g�t������+�Ԁ��I^Q�|@�Zw&�!Ϊ)�}��~Z��z��]��`W��[(��鼫(��(6]���[�=Ne*1�ck�Ce��UD�a�$+��:�8���ad2�d����)-{L��$�׶(�φb��d>�Gf�
+R��p��SٻV���~��X�CSwhℎ�+'X���F�ޖ}�f�a�ڰ;��{��G�+֨���2�4���.�O�jɁg���`}�i`Y�yި�~��=S;����'���e����s�����<���yd���bU(9�8�uJ+8�Z(༴u�	���U��/~q����ߟ��e���<z�����]�o�t�.��X�kμۊ��"6~'q^���:��h{%5�bɲK��SC���_ �=�1�7�Ѿ�W��E����!+�N�c��y�`���(�3�N8����ev�B�?Q �����W,Ͽt��l+�!;|���?L7���-_�ȃwf���~�my<{����?�����^�[��ԃ���e,�b�ݧ"/?���2�~Ћ�����'�s�7�,�q�Q�Q�����!��!��'��l��:���Q!&9��ti>�x%\�3�̕��$��I�?�[zI-��RzlEtU��l��/��%�5��.�?�d��?#T�L�Kq���Y�}A/Y��3Ҡr<`�>0l�\�0�5�\��k8�Q!v�-�Eg��M��M��H�[�0�Թ��lJ\m~��|�#4��?0ǦO!�`�`Z蕡^=���j,���L���E�:���
+=%� �'��w^�"Qu�+ی+	�V#�+2F�Z��pՓ:�C���mA�V��I��mĮ�M�i3���WN5᥃W��W�y�"� ���ِ�_c<`�g|������� �ѷ�z�>m_/��i�K�	%�I80~@���v��~7��c��>9�7��q ��y>�76��i�6>��?�8g*L�4bY}Sk�+�`4�ڒ�V�့�|Ͽ;�
+3�T�T|�Z��:�{�j��|����8�X�jc��i\���C��.�����575�](c�q�q�7�H�P�%�ЗZ?� ��Z���T��ɉ�?�.���X�K�#��W��@F����ueU��G�=���}!gP�zӇnڀ<�����A-���P_�}F>9g�BG�tz����9)��a_�K'�g��#_Z��#}�f|��?띛��6�L:Rph���	j^�P16-g���
+����y�.NR� ǩ�3�'T��9�w�b�n��S�w����fÔ�j��ݜ���9']��gK*˜뉡���u��%��t�����?��n_L
+�.d�ÿn[=j&`�)��ײ�z�>�^��?�C�����eim�t|����#����Tf��08dne�g<������mb��re�Γ��-���Ƞ&��)�/�}���K���Ը�W�����G_���V�`K9"�Zը���G�~�vz���7Ӿ}�����侦��������ֆ�,�g�Ff��|�=����c��;�p�ؤ�Fa"�z�>p�~� �
+Qs����b��W�k￦S%0�^˨�M�6�.N)
+�Ǩ��x���Ԋ���m�h��o�0�;��gw��P�?4sM�n΍>�OϷ�NTI�W���P�㾖H�>9�'.%��Km���/8�cL�5-4���Wl+�Ɣ�E/xv�b�A������|∧�r�&IXtkWs�<2��z�/@���c1W�_���0bj�*�Ό͚z���P%ӧ_.��<؎�洚�;	�P�ZW�\�V2,��p#g����Ž�<��Ɠ��r����s���~~�0�&@#_Rϻv�h|�ѾL��w�d,�;6��<V蔻k�>��I\(チ6�F��Zd\����"��zq�hW=���H=���P:��˚�Y��2�N������h��s������ȋIk]����T㘯��w�S?8���N^�I�E��M�
+�2�Խ跮��a�3X3�\-b�g�s�����=8��۩����1�R��P�s>��K�?�+~>a	�!>��ƿLm�1@����kN:� m�N�K*�����W�IO��zp|t���k�~���X�i=�*7�3���~��X������&�o���¾���D�/��F_�c�.���^��{�Cz�^+\��(H�N�� ˺�u^������z`�!��r�ͷ��qݒ�M��*C�`��5Ѽ3��G�ԏs�l*�S�z#�jYG�W����~闦+��Zq���M�i���4/b�ɦ��7���cӟ~���;�菧Ǟx|>6<U
+g��UwQ�_���:�a���:Rr|x��E2c+ٍc�rG���G\���'o���<�β�-,��<C-20e�4��U}���N~���m��E=l�"4�>x��I6�j�KV:�h`��}�m�[F��
+�܎8W�X���-4�Ӧ�znJ�w{����\	����I<�z����x�Ak���5u��˹����H_kęʛ�&
+18���B?j�+Q���O�Լ��3�x~�����U_�Q�%� u�xB�@Hb;��N�Ų�?@��x�Q�np����+�n���90 ;����%���t䣯��_.;�s��u{�����ɉ{�5��2;�]�c���~^�y����ܳq�֘K2ۃ�J���,���+r��tZ|@�����$bI���Y}��#��Pe7c�s�Pr�On����~Uy��!�񄇯�쌧��w��g}�$����<��a7��o�q�m�n��~�<�eL��R?O�ȹ*���_�xr�'{��K\k���"�`�C��0V�l��u)���ݚ7�6u���ɗwTy���(��J�1*ek]��\�k���t���i������A�C�M��W�/=rd�D�T?N眀��2v��:�O�����DO@�ɹZIS}ZS��G��;χ5���Ʃ	X#����Xօ6ȸ(�
+�Z�ʑ�FCV�L}U&���l�T�~q����.�oj\��|d��IZ�=���_���v���N��̧�ݏ��)����`&�SͿ1� ������������~�mo���[�ԙ0��� P�G\y�n�׈Ǟ{>�b)=nb;Y�C�v�k$4G���l׻�h�y+�dM�+?)Hi{N��:�_rFe� |�Plw�7����?�w�3�(����igv7�;�{9��	�� �<Y�>'���M���Mc�ǎ�ˆ�Q��c��v�Yz�\�x.��W�ɯr h+������f�;$��_`ׅT�}�
+�4�����ۡ}����s�+��Q���M}��1��l��S8X���'�C�#�+�����M�UW\1]��k��z�����=��Ur>^�O�� lu.���OLO<υV���a{�_�	+�H�"��cQ�d���\�&|����^s+v��!���b��y��?���g���:�9�m���A�
+&�l"�+�:��bc��\��I�Xƫn���#��Ж�&���u!��R�^�a�j��۶���������O�����o�
+#k�c�����&��nh
+ǰ*N)�Ci��x�맟}�ۧ.8�[�	�p��ﺧG������.����ρ�~1T>���o�)9.����8�2�ّ�l�	O�.?���uV�v5Pv,��������S�g�}Z$m�HʆO(���$�/t����=���u�2&�9��FM��L��HG�l�mBHr�?��wܖ�"q�]^+U��N����<���kKS���;��Y5�(�d��u��12H���(�|��c'�y@a�Kn4�S	?����?W��B��o��V�_rn�*k���#����2Ǐ>�U3[c(��}����B��;�vs����eW��B��X�W5�'��j��r�"ml��m��%�%b�3T����z��{�ε����?���+>���NG�>�iM�H�q�oWu�@E�N�����kA��>�_~�S���ڿ����tݵ��qk>���Xb��\��i}Jm.�\8�61	��>ߕ\�ˢ챭�\#�w߀�Hz���/d�NK�\��񂟚�ؗ,hE������x�@c�Y	�9����\��qc�>|�O�_cn�W�������o���m�e�zF]�bC?�K��\���y3#�s�:�?F�{5����"ŝ6�K	�u��g�>{���8�6mT�y$:��Ï��������/�+�H��vQ��-�2�.�S�O�M+��F���|R���Xn�~�$�<-<T��_YY*<jd�JCt�ڷw�7M\x�t��n��z��	}��H'N���G������f��Ǹ��|�s�W�;�.ӋB*?q(�+�1������b�$�u!�8�W%V+�N�y���|��������L���?���+����h�o�[U(���J��K�b{���/|a��+�O:8]�sR��Ķ8�U�cz��Č%�zA�^�c�|�
+��2	�n�Q�~֡.�J����#{R����1tK�+h|����u��G2�&�%�h��Z�~���MZ�Mt���c����K����wk?����@6��~E6>.כ����/���r���s���oy׻��ɟ��R��\��y�l}E�W�+N2n`n���:�w4���et#�Z
+.X|!ZW.%���P8�r
+o�n��sS���L?km��D>���kʽ��e�I���ڢ�%;S�cP2�Z+|^?��_��}�9{��o�q:_?���7�����諹���#�}���@юPm�j
+�:=��^��wL�>������ǻp�1��+>2bYfo�ԫ���T�����7֯�8b��/:xj�Zl��߁����H>c�� 2���+g��Z���'�FCXΣ��2qf�$(�r>�$��8��7X�A�פO>���OsK�.�t��<��%vr���ox�[���x���U�-Ol��cG�yA�"�*g��a���n�gu:	d����ui{�qN,Ӥ��lq��]�k�Z��ڥ��?�W������f��ɖ���?�w����A�t��Z����`�/N�J-�c�y�G_�ډ8O<�������C�<�߯�rڿ[H�<`��q>/��H܆U�u��-�I�<�:a��qr�*��Q4���Q�����f�s�Fi;vYK|b͏!2�G�m�^�+	[���;�ڔ,G��~
+S�ZHnk�b��uT�r�v�X���ֲ�?���o�~�����Ki�7��>�;a�X�|����[� <>�C�����M�ۺ�YE_)/+�ݖ5��2]�\4�x�V�\���K��#y�_�"2�G�?ȯ�����o{z橧d�5����b��_���o?�����>?�էX���Dpl g��Q<��&��c�|�{^ *4���oL͕?�a�;��ZTv�����y����y�5(�����R�8�qC<�zF� �	?#`لɍ��t>Z�)/�߲9���u�����s���zG��X��)��Y�ƒn��9z~]����s1�\���l�����ƻ���C�:�S��&���O?:��;�4�˵���O�Ĵ��71v�	�&�c�I[��_u�>�c�@Ƚ�u�,����l�E.o�9�����d��QZ�uϯ�!}��B��gMF��:N�N�Ћ+��}�>���_�mwةm^�\i��������T|��e�� ���L����G�k��JR)9�|�z�����o�ڂ8���/�-�ܝ�l�D"���3=5���Ԫ�N����!^��� ��%�D�z,�s�9V��̏�(��|�Ci�bY�~�>�9Rc�&�N�Q;���G���C��6���h3������]ǵ�q>m}⸃�F�؝��Tz�:�ۿ����c�=v�B��Xn�7Q
+Xo���;����+R9��	���=��E��n;�y1�7�3�K��(�B�R�M3�T����;���ӝ��k����(�#md���f{��m/?��~����l��^�׀�KQލ��|��_��Z��(*i]ݸ�ʳ<[�^8K�$l�d,Kա(��1@�_���Q�~��r�;�|�Յk�v�Ȭ�,��V�d��;O�6��!��7{2b���ߧ�����������Bl{^���Σ��۾mbZ�(g�X�A�z~��}��λ�.�WC�
+��`?0zƹ:��0��O�075N�ģb�[���[���P��yQ�9�d���)��y N^�$���#��Rպ��������]���9��2�ĩ��6�_�w+~'{�su���-E���6쎗���i���N.��q�}���r'Dy�BşZ��Ż���"��Om�]�~�ȟ���m��~�¿U>��K���x2N|_(s� ő�|��G�Ë��]F>V��3z�wIǘ;�H���s��Y���Cm�`w*��B�}��t�_�w/�{�G�X7�<o�]y��}����Gd���g]A+��m	)�:ud�Q�kn��e8Ef��d^�˘5���s���T�I�y'@�#���(�#�*��zY���i�=�����V�.���_���N�<����g�?� ws-�0�4���$�h��'N
+︢G��kw�k��k�N.��y��#B5|��s�>pBy滹Us�P|��80믩�����}��s}m��|�Ƿ$��N�_�&�ܰ��/sNSz�'�����Z�������8_�~,Z�}ӈ�M�/�`@�S�l�����z�C��I�f�5����x$/Ƌ_,��Gr1�l,��c�^^[���+����F�m���+���,�����ٶ��x���G�;�I�k�����+�M�>N��en:�Y�˟z�V�N�;6�r567�Z��s��y��;ٹ���:����Q=���*��B]k;������^ye���P�󍾱��ٺf���c!Ӷ�+���zAN'�?��?�W�c� �ð�@f�Z�вOz��\J�����?�*��~����/�t����t�yZ_Sc.+�F]jƲf��ɼ�״@���y�|����(�g>�]������z`�,���K~(���h���!�+���x`�]w���5���>-<t���)>����~b$n��;�o��1ٵ�����u-���/c@��=���jm�i���F
+��Q��}����?/��ڸ��icX�A��}e�W�+��0	�Y�Cmx��YhX�G	u���/��U�%�{�:�_�~�u�.,�h���G���0iW��!e2ϗ����hj��J�<�����-�>	�+l���l2G5>2�;mX�2o4>�u��F�e<;���������3^r�2��++����<2��pˤ*	�s�e �Z�X#>�f���wN�h��R��t\�^���y�W����Z˵�ߓ���I>5Fr���X0�r��ǧ���on���8�Q�>P�+�{r��kڧb�]InN�Z��g���Ijl��c�j��w��i|�7��Y�Ε\԰E��ņhi�W�o[��%QO$=n�k��;Z���b2�5�Կ�#na��M���o�m{b��wù�=.@If=������\
+�}Vز�|�����y��[�?{�T?c����%kٕ.���-����S���2��%�t�]�e����]+�ib� +[�v_��\|��^����we�1Rլu��3��)�M��z�9t��b�)u������h�ļ!�y�Bw�MےA�w��C���L�$8�?'A2��е?����q�k�qC�Fd�~Pwj�/<����������&-t�On%æ�.�3إ���e��,��Z���Ϋ]�6�G��3�������.�oi�2%Þm��G.�<�Ӹ�:��nkY�Y;�'�����>�9Y��я�Ƃ���t���%Ƒ�}����vS���9H:��^��`�[`<�y �����zCI����|�·�OZ�#=���|���I^�?(�k��+T9����O�̑�\�Yt4�L[��	����tc�~�f��B��T��t+;�ĉ�E���u��_���'ݩ0�4�n��F�,� ���L�^�Rj,kh5ٚ�j��++,��@�N�1`1k��%�[�[|���2�b~��x�y)B7��n��}�� ���E�?� #�׭xh^d��<��z��;"a��Xl(��+����u���@��sl��A(�6�/�^c��!Z��xɸi=r���'�lz߇>��xj��i��f~��o��$��o�G�5�����jA�5�]hc:f�y�=wO�y�u��.���+G��Q���9�'�@AS�+�2qx(��eS��'��<�͊q��w�6�F�+�Tuwɭ���󘐋�s2��s~2.�h��t.��!m�G�x�j��~��+��m�s�1��ֳ롶���&�����YK7��)��Qm��4�2��/t��|�k�>�}�{߻?�O�NԳژ-6.6�-���Ķ�WT{%�+�p���ۦ��ch���9����u�a~�^�a�����=�3O�+���xt�b�C�|�j
+�Z��1��(m�-�¤T�;P�Oh��M���cB}�A�m\���?8=~H�4_8���i]W��� #��<C�]7?��Cx�<�b��(�踉�^��W��B��;>����7=�wf=���M>6C�z0i~����s�1�~�r�������/�qO<�����K��Z�;�D<w���yL�L\���`����C�L=G���qз!W05'�U�T��\NBԻi8�F-Լ%����.=?�c�+,���N�z����O���M�����t��k+Oyd���x�N`nP�N$�m�)+����s�M|����������+-��]�dօ@�w:��k��7]�w0�ؑ��s̙~��|�N�1ؑ��|�0ף�
+������P�?6���w�2����
+�m_d�W��7���w\��.����w<'Ċ�]~gS�Rn�f}���g�k���LA��ա�ʖ��~j9u�UB���&��
+�?�u�w�;�e4��L�t#�����}�6��l/�iK�Z��f]��y��W꿚x�w�kP(��.�y�`���0�Ė
+m�ԧC�3�,E�K��M	�"D5��5�1n�y�脊��`:��t��[�~P���K���Z����iP6�BG���[z����w�V���F~�M����i/>�'�|rz�_��S%
+�tNṚ��?8=4f��α�0=@��co�5�^~6k,}<��4�7����F��P�V�)��Ʀ#�����G�E&=��u��M��/�N�}p[|ʯ0B��(��,3�!����ǚ���(�8��Q��P6Z(<6�#o���➌{3��?�ף��)����J���^)/+�2�����Tд��E��PlZ|=��~�/��&Y���Z&v[{�ǧ|��IG�����ϒ��7|2u�.�rv�`���<bn���N!�EVъ"�kR(J�sjؒ��O3/E~|�c�`Բ��Ip.��@\�YD �LI�N^:2��*�ޑ�3��
+���~�\����]����K�<�����'	������1�Y<{r��i��O����?��2e�4�.U���O����k��5.ݿo�?��UU��WcQ�0X��9��gT��h;<�5�C˸`�94|�?tV�q��Ç�j�Y̇o���w��`�:��y�@'/O�ˆNI�ܸX^cA<u}ރ%C,6[��w3~�Jf��5
+tF�7&�h]f�	��]���\��1��_j�t�9�_���T㼕G�8,�t����{��/�D0�c�f���!Lء9����{�8�P_���~]��u�˨�2�	��+��T.�C��3�+���LdZ��>F����w�s����w��L/��\�8���)�?с�?���/_��Q8��,u���i���\J�0��qn�q�p��6ŷҙ�H�2d�l+/�3Eܱ��Ԥ��g�S��{�A��>z{��_���#nߘ.�M�!}?�&r6)S\�A��.0�h�՘<'L��ʤh���.+� ��gM��k�*�.�AY���|W%tb������pܦ�Cc)���g1��t�:쁎��{���n�V�_�x�7.�Sl�^��S�G{�7D�HJ���1���E;y���v�����>z5x�?��w�ݱhΗ����Њ�=�8���*�/he�c��}�����q��ȶ22v�2j������57�ܱ�W�k<�I�D���93n�����q��$"w�({c���o����@��&�GO�L�5?���A��|o�����{Jk��f�m��|�Y��6���Q���/Z<c�56}t��������xo~��C���
+_x����v��!	�)c����&��\Yl��Ħ#���:^|�����z�����g�:K̑�x������]�l����f+j��)�P�V����0�������[W^��e���q��ߙ�q�F~'_l������������e� IF��3ܸE6�eb[�+���^+��@T�OP*T����N���tS���E��f���8ͱuhBG��OR�Іn؜�y��b�[��x_X���Ǯ?On����\P*OM=�JW��nޥ��`~H`je��Y�"\��*׿��M�sǧw��O���qx�r�l&�d�=|�x#�~���N�n(��xd���V��R^��o���ɏ�Y�ũ@_6��q�@�]}ӎ�ja2�l�wI3���;4�[�5��6�`����sh%+ʔv6�fZ����o��8X�GlQ!P�p�ġx[����%U��ݦ���S��L,�������iW	�j�Ԫ�Q�>���)W��S��o~�_�Zʠ����Mr��$<�%��Me��菲�O�:&:��[h��_�Z=������K+����j������xp��<�Ge�Qe~5���=tƦ������
+E7:�·>�\��c�[/#�F��^M�ߴ�Ĵ��>c�W�='������'+<%�U��������ϥ+�p-Ç��m��?�|pG��$��RR@�~�<2
+�n'�ҧ��E�G�����0������w�1��wL/�C�5�Q|�:;�}���1��q���؛R��K'ONw~V7>�������~�t�e�@�1�s�ͼQ��Ef�J̉���g�3�O�g|/�m��'�s�g��0vh��炒9$U�F1���z��b��2FCL�\��G�Ia]=_�n`n�"��Y�A.+��9���D
+mX������w|�mӍ7�2�;x�.<��M��;�� �?��t��0�󅻔f�
+/��I��W���5�9���4�����<8�t���9]1I�v��v�+u�-8�P��j������o��|\�˜p;�RÑo���\t`<���?�T��Tjs�Ȍ��P\��?m�O��%�$��s-޽{��׾^��f��~���\A�+��aS�%���S;�?��Ǧ�}t�T����6~bA�\��VM����=:6]}�u����7��8�e��W٣���u��O2���}z"(+����M+V�
+^�D��K�j���#��Y�̆8�a�����іx��?��#���E�5�Ѧ����u��#���?�������:��>H�K���~�R0�̂eu�>���?�>}�R?�Fo}�lV>84��?{��}����gy?�z�b�b�7;cw%�ʛ7/�E���T�~���F2N�7ٖ��6#�V,�V��̬�&��/Le@[:�m�w�aBS��@�,�Z���G*�@�T�s��WRJ������֍��*�E�g٩�_w�:hZZ`2�v�55�;$n}�[�u#�q]$�w�i�t�m�U��deP�7g�3'�WX>q�_艀�u#��i�ދ*5��?�ϝ��S��SQ^ȵ�IF�y��SЕ��2��sN��X�Ƨ�|?�s��|��vW[}�K`; )�Z���ϼ�"�����E˵�c�
+˙�橖!�F��6�1�U�b��Y�N({�V
+y8��=�$�Rp$A��e�0�}���|�]y^�/�c�~�1+�q~�7����N����k?4��"w����QO��5o�j@�ۣF~�%t��ROq�*�3d�I[ǣ�4^l�0�"n"��҄@���,/�:9����!=��>�l�?}b��UA��<(я���mo�~@���IO͗U��M��m��7�㠹�/��2���-�	0�`ոb���mO�Oڢ�_ǿ�n�޿ r܍��'�E���Zq���6�xuLk�Rl	���O?��8��Zl0�ⶦ#o�Q�M�İ	O�+��0h[���"���o�����o���Ӧx�J_m	��}���{ӎ�}+��m߈~�#��CT����y�zV��P�y����j�W�6�nL?��D���x���?�:��H�Bͫ�B݁Ƣ����UY�����n?�,��5��*?��	n���g�n@Q���1��+����Lܳ�����l��l�&�F�u��`�����+m���ξC�z$r�;+s/����dolS�U�C��
+F�zbc+�b�MX^|�#N(��VJ�쉥*|p�+�����eE����U�Ooxӛ�7�W��E2�ܚb����e�gJ�uo��1:�f��$@w	:`��*�jp��"2�J�s����f���%?��)�Ȭ��W-��Z������o�����33���"�X�若^����ݢ���ׯ>�)��˕��V�VX[%W(?	�=o�?��š�o���ҋ|�
+�ZL��I�J���_c�>hj�s\�?xb�����Ao��D;���g?�8��߮�aV�v���r���/>���?����Ko�E�(c4�o+e'�*6�@G�zV��y��*��x}�E��('�� �����F�_�}����6���2��xW��M���z|�������_V�j��hVlg�'��@J�e�C�����K/-\��*�b,�)��m[��h���w�Ń]�#+�}�m�z��ӧ�X��<�mtP�)Lˊä�J�i���k���e,���
+�hڼ�(�ڷ��mK�LʩC�+k�X�2x6ux�JL��,����[��ݽ����e��n~1��5�l9�Ǆڿ�,��+�#z�_[��1+�x��<m*O<ydzL����V�Er�FV��Ű�+o_MG�6��.�����m�6�_=����(Ju��s^}/�=n��B�z��W@B�kz[5OY������7����`�1G�>M,;�4��^;��R�����Tv��3��{rڹg�&[�e�Р#�vǦ
+�|������A��@ȶ��/�ttRK!���H�S�;��y�CV����${olV�o�2���"�Ե�T�T�����'��EՈÂ����΋�8��Q�)z�i3��;�EK��~1Ob�?P5���.�ul*�%��g�ʯu|퍯������t��˟āL�R�,��x����P��!�4@�vh3���o��>�39��/���[���t£�9k�ώg��謤G0zF�r]dܸo�t��^�Faj,���)�"�v���ǵ�CާԄ�}���B��H�/�X�h���2G��O�랁mGP�#� �2X�TXH5���8�vfi��� YyW�1��,X���2��gՑ���w�8<5�����}�=�b7]+����>>f���5g!�{+#�Y��:(�8�J��	���V��\��j�3i��r�@_����o�~�o���[�����bS�Oq��W5T���q`�i�/�AG~�m���t����r�����O�(PB�f{X��	�r@�B8�w�t������f�hd~1������c�$@6ۉ��&|�.�t��;�"��͖\F��8�E���h���y}���λni��\W��N���xZ���A	�.!`JLLI~e�r�=����NP�+Fx�� Z�1�e���W��.`Da��G��ݭrP�V=��[u|�jſ'N�s#�ǟ��+!�k��!�Լ����{\������/:p�nl�����C�������O^��e��
+�e��u�����珨���d�E�<���w�M�L7�����=~�/�覄���_~����c���l*������T��nZiKú~�C(s�+R���-|���n����M�ڿ�Ե�_	�+oզ�����.i�*��l�"��v�A@?��{�<�)�_?2���{�����y�	�@��#[[跔o��F�)�raʙ`�1�=�0<�O-��}ևNn��Q�N�M�\ ���M�K%���@�j�.�g�nz��'���������O4.i�vZT�!?��#9W\i^�I��]���C0��+��ȼ�~��n��^��T]�ei�u1����������-�N�U_6���b+���1�Iu�.Ujt^��~$P������"�JF�m�d��qq��~��3��n��tVu��?�Gnm��mjA�t������ȌC��t	�'�����9�}=�S������	��T�0�X���v��ۭ9t��pþ��{�K<�n'R����9#ރ�n�B%^��n��|(��7vS�U�,�g��z�K�C�v�p����⚔�+-��g `NY�I]�1A�b��?��6߬K��ˡc�a�Xn`��1u�h�z������<��_�pRh�����E���O���q�D,ZlC_8���H��ٿx��>U�2Te[�*S�X�<�-�S�d�}��˂2�+���t:
+?I%�ھ�_��ĸrt�n���z�*�L۫�^r��z̡k��<$#nv��<�E�N D�VRR�(�CAO�`���{o��ᭋ��fv��-
+��ʚ���~�-(�yd��i��2l�h5S�MG~��Q%�2[�7���q�$;���txg��+E��Pڠ�W��~����.2-�l
+�X�z\Z�-�ݼ]�R�R��6��'��^\���m�|�7��+j�ŗ_��~�Ɵ��?�����o�m��j],�v�[t���e����h/2���}������݁�ժ�V���ڹ*`'Q�Бo�1���5L0hi:������J�;����+�s�Np��bl����נ,����O*�7�H�d�9����h�Kd|�?���l����m�D�����lR㄀�����O���o?;n�#��G�����*K��)/t�F
+���0j�f^z�+;�61������A7RB��	-p5�I)؇�#o#H�eБ���P��a�*�����TΫ��.L�5��\N�=e��O=Dw^�s��[
+DkN�O�%�l��F��z��EA�kN#��	��XԠ���n֛��}��ǟ�f��q�«�2S��n����{���/{Vl]B�u�0P��S5��Bʉ6~@�P��¾����U�ٰ�X��O���0`Їt,'��9�M�k3�	d�8k�ܱs��^�KOՙ�B����T=3�C=+���c�	�:�si��>?��~t�����郿���#GdH �V�f�w��%�w١��@Oh��K����x$���uh)��u�N�կ2��/��r��b�� Y'C�yﱖ�(���m��v�c�9kJ��mƽimO���GV)(:�D�Ү�.}���O7�+���s#�u��t���I�^�N�BX��U==�r��JS��n�Qk,��wFk�����a�ZH-5HVW��~��x�`lu�ì��!L�
+,����->�OBV�]��zi���w%Nޡ�(�+�ַ�I�qٕW�;��Ϙ�[��'��ƨ��S�*��[F��t�R+�;A�i���:6	8��
+����j����*_;�D��������g64`�K/�B�ň�M��U�t���J�f72-p)�Ia�����Ƌ��+�mD�N+[͵��I50Ȥ������f�	�t}56�]��ӆ�9�Q�����ť��~�+o���|�w~Z/���_�ֿ���'%����ęē'7Z�g���t�鉀��.��+�b5�=+M�׽���u|Q�Kb�F/t	}�{���|�*�R+QB����1����K����a4��X�i��j���h���l�,1dX��#]��7�q����������.~�K*^��ŸMͣF<)�QZ�):��������]N�pϗ��}�g���N���.Z��w+����/�.����+3�&4�yv�b:�:Kl��G����M�B�G�/b��vr��N�=Ɖ��!�}����'�P��"�:X�nLV��D_{�>��܏ֱ^_d��bxh/Bk`ss5zND�8�憃�GVY�+PXsQ�F����^炬�+<�D��E{�L��m������Mz�$�O��
+o����p���1�V�r��X���PT�
+ydO?���;����O���>�~DR�`������O��=:��z�~F��8^/�/un��Լ�R��BJ:E��*�}�ʫ�%��+�-=y��S��w��n�����b�m�i���b�e�e:�8�CW@dq6��>@��o:۳�L	_���ԴC�I����Ҷ�/��b1ҴA)�U��Q�+|R9�r>�I�X�����7�]r�J��ձ�jUa��?���ۣ���j����/c��yN89��p����j~��U�\�ǙO�&�$��Oҕ�,�؊wv��b�&����MMl!;�+�ʑF-��?~+�j���o�<�k�[_=Q�����E�+�9������`4M��<�?0��f̩���ꫧ=�/�@����{��}!���5>#o0o+���	�J�䅮�Ӿ��\릉4z���$�����F\Tj.D96��X�RvVs�������<W�ל���x/s���^`G�BҰ�X���+<�*=�]����/I��R���
+*[����T�Gu��ğ)���ȃb<|V��k�b3�7�l�خ�/�̠���Z��'�-�j���W�i����	��]r�pV�6�����F�Z��ϒ9J,���Z�Y,6]�Cv�t��P)"{�ԡg3��9�}�Sߌ+Y�8�����l-Ce��-�� ~�����Q�e�R�������@�15_�(��ziT��~������N�8m�\MQ�<2���x��k	t/����QO߯FE���km>9t���+��~SL�����r\���C��N��8�������n+���պ��p�C[x�̱�m�^p᤹<�k�,	!sڞ�,�>���ϫ�n����x��~=p�~n쑣|r��!�/|B`�4��}>���ČN�;N􀯕~�O:��۳G-�'��Ƭ.�B*jN��)��:i��	�����+��7M��KR�S�����6��_c�_�������n�~�3��A��ٜc⥙��+�Þ'=��1��	�heٙz	CU��[�m�+�e����bk��z���r@����X�+T�9F�LĻ��������_wӍ����@Զ��K��P=<s%S�u�z�X��
+=��HDЄ��g*�����r\s��mL@t�F�p��wi�A�)�E�|!����
+ZC<�,/�r�T�O�x��%]2���(�+��eY)KT�Vk.�/�O��gF���dc��Q�`U�=-m=u�SǦ��Q�+7����u�m��{l�Aϳ`X6ct��[��f�;ƚd]�^�+�C~
+��H��B�����*5����1]uѮ���QǦҫ�VZ�;��W��Ӟ_����������C�[}-�Ӷ>��[�k�ɪ�aK�$>�ڿ|ɹ������]��Z��y�Z��Ci��o��A��*�V���⟝0��r��|�lڮ��-?�o+#�F�o���tW��ҏU(�ʼ}���`��_�+�XV-h9�l�v>����S?}v�n����O�W�B)9��I�z{ͅizꙧ�k��4�p�>�x��8� �m� iϸ�2x:X�.��Z�pl:���:/��G���O�SbY��
+�8?��П��]b,Tl%�*�8�b�li��DB��Z:���6R#K���/S4�ݔ�C����_����<�(�f��չ��m08\�_�Z}��@q��ͬ���1��9����S� �Ց�_vK�yq�ss�Vj����ɶ=G��h}������?+�B2��>��?�ǀ1�1���B�ܹHs� _e��v9�����hP)�^�¨.�{A"7�W��+���k�������~�gn�V_+J��V�N존���BG~�� �fq�̓��[���߶+�`ڼDI����*y���d�P�F���mS�-t��Q
+bi��˟���S/z�b�6��*��¿��%����5�g����پ+��#�gڠFx�CG���1��N����k�Y;�ډ&[V�t���_x-/�EYI*����%��c��ֲ���ò�'v(��#_:�W#�`�U���C"_bGRҴ���1�K.��9V��*��D�>@��f:�|�5������z�83����Kz1r�o���P,^�o���2V�����1�.^�	Z�+�QFQ��٩&NU�_�y���y���V�PT�ؾ����o�0��v��'�OT��3���	Y�]Ъ�"�=���,�ZK_9�{�N����lЩ�}:&+hE����e�.�nb�$�C�8��+N�������L:u�ROT;#�}#B��SAY�ZH�oy�@�U��8�?������3?7���W�-}"�m��nؾ�0������Ҿ`�Y�E�C���b������w~f���������4��|tz��'�G����A�tb��x�O���^�7W���t3�:�����E�8B����{�E�yS�2�h7
+z����fl��4s�m�uژ�gNV{�
+=�S�ɿ.�gl���bئeOLKl�_�m��P����o4�B�Y��'��>oO�����	��k���J��>�]h���O�W���&u�҈���J����+�p�܀f�G�c��4.�d��V��)>�E^%�[����/}�m�Q���~�r��c�l:�¨��WKb��/�$`�rv��K��ĉ�O��x�I��C���r��6#V���]*�DD�C����QV:R�.t�����K/<ȋ$��ő4-��q�.h��x+��y�t{����?�x�?��zbuԻ3J�q���J��h����ȧ�|�ϸ�����t�I��VЃ@�&٪ƫ�v���+︚�SBWkH��F�dZx�fm1֞�m=���O�M�������_L��ǧ��]S��.F����#�k�e�Z/.S�_����f��vO�k�ৄ<����l"g�z[@�x˵$N�jK2+�>,�)e�yNI(�ʦ��<�_����$���h�&ux�2Pm�5�}�R�D�>�	�S��^��甬w��uzܛ���<��ei�dV�]�B󆲍��S k?���s�/��{�`�8�����0�L�)������}:1�l�ʏ��Ɨ]Q{=���G%}+=d������	Z|a�l���h�-l;o��7ߊ��N����ݎ?m�c��;���ыm�у?]�J�/��������Q���^�|�-�~Xf��#c���t�_o��;���w��������5������7m诗3���R�����N��i�op+�^�?=T#�me�����.`zr�JMXj[������1��b���3߳j�7_D8��D�k9��?J�j-��+쀾�Oq�O�ѯjs��3��I!���ƹ�)�����x��Q��JVm~k��b�a�?��o��>�y�p�ZɊA�8�M,��ƫ��8t��?���q}��3������\ΦTT�I}.��}����hj
+�;��8�+�9ߤ��ȰI�~�_����?������|�ko�v��@��/��w�y��vga�ެ�_�v��|�w�BLM/(��#�/�o�f.hB0���y���8?�4��S��$_J��B뜪E��C�s����
+ck�9*�_s�t��?�҆�ٔd
+�׿n���Go�#�Ȓ_m�s.©�X����yk�r���D�+8\T��o��	ץ��OOxt��i�x4�����E�����VY��Q�����3K���ւMB�5|�[S��vbd�_;��o�\��iղ�,����M�qΗ��K��^��\@y��)�\�Bke9V�^֪hƜ����{�&[d�Ew�*��0��G��~�{��?�������'[�I�*�p<�̳����7}����.֧�t�J�'b�u��"o韱���8*E�T*��8�E�Wɧ�Ԓ�;��!-mf�y�~����b��FY|Dc5�Xk��;0ݬ'n��ӉNLO��>!���8���%<�%�-��xhŽИ�7�@��d��P0kU��-�x�����7���S1=y�I��}�t�%+�
+i
+�ܛ>9�)y�/qQ��{tE�M�K4�h��F[_PQ5'�y����c�V�Nl�Gg��ka��/���zp�ْ���yy�>�Y@����eĂ���#�Q�}rz���k����'�147CSE*.��!{:���_�����<2�h%�%���{��Ɗ-�&���0.�����/�>��O���	�qWHe_|��\�ɓ/N'��4���5R$nF���/2n���㸤E��_�x�+�x�,�&nb��?Ǧ��<h�����O��?8�(�d�iHNTUwUt�;�Ew���[ߨ��nl0�ТŃ�l�B[����#�,�Э��RV���K�v�� �w!�1��X[ڹ�ϟ�M���q:�7��3�Ν��Ҷ�z"2��C)��ȧ�J�Y�ʯ�ʯ~��`GyT���8/�������汚םX��^���fs�7��HI�$J��hy< �<p'c{g�A��F�	�e�@��F2�Dc9�,ɔ,Y%�I���\D6�l�����[~�sίnݺ�{�{�-����{��S��^u��%^.��J_F'+��� ��*�W�b��F�����v��˃��� >IdQ���r-B��Qe]x4�6t��6����7�J_�9f��YJZi�m�|�����j-L���C�G��ھ���v|#�Y�Ey����@��29���]+i*���w[�v��h�0�
+uFi�w&�J�9�	��|�B�3q��K�?��`\\I��,�Vߙp�"�+�_K�V�H�q+�k��fa�s�h�f�z�Ɋ��N��4���w�߅��|X�.�ƆU��`�v��H|��
+����0k�B��e�X����ݚ[�q!��x��8��0�AN������bN(�Y��|���:�����h�' �0
+8�����Way5��}�?��{�3�)�S�^a�|�����l��o3�+g���~����·1�ǃ;�h���L#�H3<��.K�]�񉇕��G6-�$�uxn���u������8�/��Oo	�gƩ��,�>�Û�q"���nHc���D�Q<+nl�q�+����Y1g��)�gu�[@��`#f�V+�+��d�`�@�����x*�wlݶݜ^��g�Ɲ>n�QD�Y+C@5�fvE c�+����Ӣ%K�����`a�9��6L8`��9IA9�� ���"⨔���x��D+��>0�X@�Gq���;�S����?���<|�HZ�p~�I�K��I	�����9����w����z�cu!N��9q���P�	�	u:�~b�y�&K��N���S:"�'�.���������]�R�Y$Ϋ����t�5ׁ�4A����N5V(�.{��H}����'�Ǩ}ـG��BCD݊��E�a�x�ƹ���/�������#Od��+��c�:�a�Q(�1h� �W���m:�A���H�f	�%m�?V̵ �ϵن���U֌�F*��0tE+�T�eߌ�X���,�֌�W�^ye���?���]��Ĝ��goy˭�#_NW�n�.����Ν%]�?5����pg_4Sh�)c�a��9Ɯ�k��������=k��V�^��e(��~��[�'>�QS������1�R��r��szi�����O�:Y�4/��d<��p��g�E�3g\�t��b`%;�哌xi��b�Ã�L�m���{�<�xz��~���(ՍMfŝ;~��)i�*���%��b���5y�*u�?i�C�����_�.�袴l)^pF��p�vQ�ފ+����ϓ�.�	|U���qT�3�|�+0�~5v�8��'���n��;��<�n8��+��|9-����쑓ؙ�N<�6|ط,���1�;0�h���8T�NF+5�d���x�W���q��J�����v�ϟ�����r8��r+��z��8�D��X���D�x�rQFc'q�5���͘n@��}&�~�#��q��&���P��KZ����\��@��sPwG
+a�t�=p��ʟV�7��,��'�}&�衇�Q>:L�m�0�%�cl9�hn��(����	����KpBj	�ư/�|��I;�g�8�s�mڹ{Oc������oK|��c���?�g�9|�3T��[��*Gps�2̧��V�\��m��/�"M��?	Yj���3%����o�Y�j����!T�Z���z�lf���և�KW��){��}��[o����	,:�ׁ��N�]�I�YBNCӨ0��L�|�@9p4��V/���.f�m�C=���o�	+�����e8�7[a��f�Lm�pR�� lF
+��f�k���v�AN�A�� M]d=Dk.�-
+@:� ���1q�����P/}�5XtX#���D�ɒ��]��+'��w�ț���G��#��˃�<��Ⳓ,�-�����⳥Ͽ�-f+ޭƓ�������U�/H�r}&����0nn����<��t�>��E+`i�N��vkן?�ܝ�6B�7s��˿�Y\m\j銚s5^�Pmm����xb�Vl�i S8#�N���(�	Y�>��>۹�	+��@��l1�ﴇL�M}(����=ۗ!��r��16y9�9Y`3����>>t��^Q���g;o+ڋ�y��+�qn���\�bk������އ%a@y������OO=�l�8:aqN��ޡ���x�|:����5��<[����0���e������:-Z�~峿�?�W����[`Ū�aT�_!:%�������g����ƿ/���ds�����c�<��O~��_~������+�<���A]�$n(}ȣ���+@�?��V`���#��|)Y�yʤS����P��0C��dz��/�jځ�������q��Й�j?OJxR(�*Fx)�r�Q�Y�$;02�����	���# މA�m�4Dz��O$��nz�|�-E�[�"��F!s3����_<�Ν����z|=�z|����<����ۑ��|t��4��~�)�8��K�_c�b+�-(9D���H�r2��~��j-��+���o۾=m�	K~Y�~��xw������5i1���F��j��F߂�yM��}.،�sDh����1a����s��y`��d�mO;d˾����s��>�_��x�7D�V��+�7]���K�؛����B�x�+�C���|�"��;��2ן>�Dچ��M�k|�����Qw���<�ν���;?��yv��,�HJ�7���'��sı�Z�t��!|��<�C���/�����O��m���P��ET܂��������)J�;57i[������?G����^Com��6�EF'+ڙ㵚���}��e�
+;��Q;`�N�?�I�����k��>�췜�j#=p�F��ν?���c��%˖�[���p&���D?��S��n7���6���$`\������V�#��`ۏ~��,�P�'�r�|r#�I^��S���7a$����A<�IGa��`$��� ����Q���Iks�����"�lH�5@C�ϱ�r����5�<؝��M��ŁO���äs^�	�k[,i��k���]X�lG��'��>"�_ٲu+ݵ���x����k��#+U�_��(��,����j�b,���V�\NFਹ��/�O�i#�F����+�W�.÷���+�@��+�����{��S�%�YQ�Ӓ�~o�ׄ,����N�4�|8��?���'~)�_��8!K�*%�qcj�(�ȩ�s�����j��>��0N�(�B�_��h�Ԝ0̿ھ�0UV�v�x8�_��|*�}�P��\��y��$.Z��tў~����X	*8m�C��3��ɫRʉ6�UF'+_�����i5��nǭ��.D�_6�XUɑY�B�d��~�ē�B�+6e���������g9�G��C�Z˛onKol�e+�؆O�u
+riiU�J�W	����������H��x3��k���B.���㭷��6��<lwH�������bd[����`=�{|N����:$2��X/�r'Hf�K�&h�[&ʁv��?�[�_��5��o��[��A<���I5Pm����C�I#ַ��˥>9�o�J�����+o�G.8�i��vY�m�.��+qA�%�_�~r���6_�D`^h0�H�T�b�Hz
+/{�י�E�g�}�+�x<�T�b��SЫ�$*$P�K��DD�����S�/e���D�����C�8\e��!��&uR�H�P��a���,��M�W^z!����i+��./��$�BXi�7�P�4/�wARK���Rn�seP�-0����ϡ�4	���tx������W*���W����[�-�W-�E���r�"�Ǘ.�/�2�YO�;�Q�-B6Fn��V{��d*���
+]o��Q/S~'��8�`ٿ�@ڇ���w�J[q�ρ��V��P���ׂ�(�F.d�%���q��g>�6^����=���/[�?Lz�b[7�кx����E1tS�F��?KVQ2�� �\{E�����uh.�y��<q��X���Wa�~�'��m���oo��E|��w.l��.;����+�9<{K��5���\����������?o�H�.�s�&Ќ?����p���r|�<V��'GL��0+�n�n� �q���_/����k龿���8�������w�uWZ�u��ߦ59���c"�2'\g�܍@�t��rb�7�Q3�\�����\��ߤQu�XkJ�p��V��-+��qܕp�<�Ք��3]���ىM7����b����ӝ�|2�Rؔ[��u��vh�V@�y�1*)�t�i�8���[E�C|���,*]y���G.������3��'���$ݙ��N��7��%��h�Q�'�iӦ��ӟ�s���E���`�Nv�o�xt-�Q��@w��:�i>�}�+3Az�p����O�S�������D��������������P҈�-�����̭�)/Yץ��g����gB:�tג%�&�:$^/�^3������K��������t-�X��A�E�*�^���>�F�:v�����控���2m۲��w�c�T�6�Ĉ��ħ"�ɻ:+�������I����b�.����'`�4���-�e����9&�����+�8�@��#�W�!�1�?�r-��ƃE�-��/=�l��<��t%�pL�Ͱ+��^u��0g���j�hۥ�§�������;N<W��W�2ϊ���K�R�~�plL�A����L6Da��T����B]X���/'	�al�P�Kh��dO��ظ�)%����q��=k��1� [{����oL/�,���K�LG�]%v�0����Q����M�Bu��Z�m���x�z���\QO��k��;�>����?�{���x��U΁��������ރ�<���r��؇=y{��`Hۿ`�~pa����Q�V_L�R�s�@A�u쬏��1aۺ����������ī	��X�=���ZS�N�雊��>���_+1����"��O����z�w�\���^�q�~��贈�|y�ſ+1��̗���p>;�ܞkg����+,���uk���7��c;Kț]�K~�j5V[����K�k��/u��vr��@+�!�2c.s�4��S�L��7P���I��m�u�"����l��<y�E�	��������E�v~�v����g���KK۹N���_���\��ݛ�sby80�(���i�說j�ډ2PA[�~}��]K7��:�~�R�[	�����ܪ�8�32��hv�ϣ{$�o	W\�^t�f*����OYN�[g�EK���z"�8��p���Sm��nT�D3V ��%�妛�8�.���B�3S�K<��&��
+�� ?� ��'��?�h�����Z�0Y�$7�	�Aso�7��b���<�C�F&��OD�_�C�G�C��q���d"-d����'��˒���"C�2^_5�Ϛ=+�k|���7ݜV�[�������#�>5�����U���o��%A8'YB����V�K<@�7��h4ي�4ɔx�I7!JU5�I�-�g*�s5��s��n�%}�S�d���[�=��q��Z�paڅ����i	,Ve~���-��0%hR��˯H�����7�'��T���C�!�s��~a;���p��䌳����ƚ�p�'h��6�uI�$<����8��o���6,�w�?J_�V�{��g蚓��1�v�����NV���?�����_|^�����A�jjEu�Q�b��L���fS�4{r[�[xre�B~�]����+V���Y[6���$+*k܊�ٻi���F^��X^M[�l�Eyg�4K�Zv���w�������]��o�Lq��7��Y���P%�}+<�+{�~7�ge�Ν�|��_��SXx��	-}'H�@*T�N8*�d`�$m��v4[�Z����`���x�����g?{V�+X���~k�_`/!���L��3Z��q#�Xϵ����쥱�nd���fDQK��G��q���h�[��+_uዌ���9���^G��o�ؖ	|��MϥW^|1���f::q��@]���i/��w��~_vC����jP�)�u���=�@��D��a�m{���WJ7r��5�����ݥiQ�o��E���>���w}������w�r�YngP�B�!M8�Y���ۆ�.k���@�[!�J��6�=��r{G$ˀ�EX.�+y��-���[��?H��/]~O�T9�]V��e�k���k(��%d�f��W�W�Z�V�Z����G��7^�9z�o��i/�:�̝�+<<�����]�۽ǚ1��{�t4�;�����wxyӱ���iɷ���C��/����9N�¹����vfƔ1�2��J���Ǎ8n,�3+��]+OJ��>o|r�����^&��yϭ��eS���G)�r���%W���G����T{��݌64�o�+W[�2*������p��2g�!��E#Υ�@u�	P�yW]u����կ�o�+7t�T��h�����9#n�yT�PL(��b(���.T4	��=v�۫���4�Un��qȦ*���pa_�(�hD��'��o2.�����Q�����QZ��r���_���`k�h�Z4�	Y�M��x���ۿ�/�N?�$����]+���Iy&d�G�+r�)����*2�m�j{�]'>�-Y��h�S�Ϟ���\v>-yMZ�/�x�������1��MG�ks�I$���N��(�hD��E��<��Q�����b����ā<�u=���z���|��8���g>��=��OP=����_�<	�w+�94��R��eXp�'m��Ryl6��ٰ���ɡ�*��6NA��xv����d��#���?�η��Ė78��s4=v,=𓟤O}죦ov��Ν�v��\����<���o��η4���=i��9 ��P1*n=�Ua�ե7��+5UY��Bl��5C �p�M��~7;���c�$�mwU��B��}#�����_�,�|}�Xۧ��a
+�`����"���q�4�F<;���.�s�8g��0�2����-U���#M�E���� ̚���c�5�SK@K;p��:h>������!���%��Y ��l��W���y�㠹�n��y��0������,��W�Ge��+�֞#��~��������wU�zA��E�70�E�l]�F�2U��'&�8>	x�\7Ad:��&5���D������.�dv�Q}0ݘo�l��Do�N�N\��w�+˟iϴ��g�9��F������Aus��?��M׏<�#���2�J}wl�?�ճ�6����c��;o�=-X0߆��93Ӿ����57'ʹT4�XE���Dr��|���1�t���vY��0$��X���>a����V�����a�E\��%l���Is,�M���}�{pϾ�0�B7����-�h�O�@�#_�C4�:��ֈVҧ��a�K>tD�e}��͟(�i~.n�^�q#^��R�Gv�ؑvnۖvl߆�R��ł;q#�%aH��̈́[+rE���Vj.�����s��i��+��F��J�ٿ�MP��Aь���҅�\�6^rYZ�+�39~#�����P�9���x����Qg�a�n'��2��5(���=��
+���!��2��\��q�a���z����km��,��D�L��A����S*D'�r�O��O�m[�ЁS]���PI�f�S��L?���'�R?
+�.l�`���}�{�rݺuwon8�� |����t�mIsӦcfb���W���I|�v���׏kLTYT�:�Z�ϼ�l5L��>���������Q�csANΑ���H�?��u��m�	M��bl|��Lw}�&6O6��{+��Wp���G�_��;mSx��S�>lW[�م�ؖ�3�"X�A�6L��o�f��}4}����1�t�e�ٸ�x:���vJ~N%�Y���pׁ$�+�'y���+t�-_��/1�z�w�i��NS���V����E�+=n���S��,��h��&K�����K_��Ќ!g�5kfZ�f��!=#��>��w�����ܙv�ޙ��K#��X�+H �d�t��=�1�=_������sqru�7ý�o'Əh�9�ʝ�q�ī�@2���P�O���/~����&�ƾ�>���!mT�@�Qp��g*�;叐�Z��;+y������EK6��2K����ߴ������ɀ��!��b���0�n֡����1C�z���7>;�3��6Z`����#G쑁��$�^|�t����)���#|�ߧ9�i�Py�h�G�:���C�Y���v;�E߹�CU-����/���Z�r|�u՚u8�_�V�]�/Y��K�R�T��bf�f���@O�}����t�;�W���*�Q�H�����m��a�C�_�.�}u}��F��{���#σ�w
+���j���_�{��y_;�W����Z8�royr@8��#O-8J��et��u�fj�+�g+=7�)�39��6C5�	7h16F�Z}K�G�O=�2�mlx�?����%K��%˗�e˖��+V�����.-�Yց��)"
+��L�yPUвρ7Iq}�ڭ��X�	Z�c�y`�����*�Ϊ	|}��Ҿ���G2rB����+�"�V�*��;�(!|P�����q�����|��o�M���6eX{��tI�ާ�涊��6 Mv��=ѷ���.�zO��FmI�Pq^�2}��Ky��me]�l|?�=?���@��7��n���eg��o+^�\�-�ń����~Ѧ�� ',�X��BU��3�+�v@F�A��nM�+:�3�p�"0�)��r�W���:�/�+�A�̻����b�<x�\ePºaM�<f�F�o΀�p�afO%�l��Lb�@bQ�惭���w�\�T�|V-u����g�xI��zΙ�̞��2O��M@��1�3+��p��$d�8t��ye����;~�gϚ�f͞��f�ڝ3���9��E|s��Mc���8�����γ8�9}�׀p8�vK,���7%�+갪��AS����
+�)g���i���Q��0���.��ٖ�Q�H
+s��0OJ�S~s[����U��y8>^��iK���~K�c��Zf5&�!�tL��O�]p�>���6��Ɏ�[�C�G���Q9�hK<U��]N�#�^�/^�g]W�k����+W����s�f�Z��.S�@5	Иpm���L�ӳ3�ABi�vJ��z8�8d]8aoi�7�N�_�HAm�׋�8L~��Q�M�3���o��b�5h=<���p:6��VP�
+��0���'�_�����SK�R���9�����;�Hw�y��p5���[�w߻V2�+��&u��h�(��ҹ�Һ�+~B��C�T���<H���ݒ�[�`˲$����L�K.�!í����P�P�_�^U*ëJQ/�T�B��1�6�Cld��ccl�%Y�,K�������[{��Yg��}_�Ԓ�彺�Yk�i�������cmCA>�vbOKN;ِ���s�M�T�T���:Q�m���ڑh1�'��'��U[R�J���h8�@i����Ka�h�ո�����\����0��_�k㮋�1��x^/������t�����B<ҏ=��7p��O�y�"�va/z2��^We���#�O�[�b�U�s�����9��SO�}�Cz'����&17?Ꮽk���1_��+��N�*����Z�G��=���^� �u�m�Ϥ�_�ⴰi�z���o~N��[��N�qܐ�W�/����
+��3�=��l彰)���`�@�ic����A[1�$��5�UC�C�Lߪp�����ޔ�N2��[+K��U?�����%<������>�,����������W��y]ٛ��y�S��~V%�F��9mń���_�_��b��t���HK��?��#��y���%���b\G����� �8�~�7��پ}�!�+����3`.�I�/�μ%��_@m�_{��N.�� Kͽ>�&�4�~�Ѱ�hS�P�OqX�dA��j�p�7y���9o���V�+�����9V77B�H�m���N{2���u	k����$"ҩx<�Ϛb�	�X������_:�rF�F���ϟXΛ���3�[���B�w���#8�,��D��.a��p��������s	{ڄ��<��p�`���2`��/�I�6��A��Tg��O1���G]IJ%�����^������]�����5���������t_�>����C�t���<��e�ԇ
+�m�	��pE8F����y�O�	��*62�.P�ډ#]�$2d��� L2�U{P6��X��5$��N�x=����*�/c��B��hȄ���+ӿ��L�hT �a�rg�ì0�:���P6�L��L�΍ 2W�X<ҕsV���J�h����!�A�.\���;EZ�"��I��c�c̍vCd����5yh�mT"� W'[<S񕀎�Gl4|	��l48\{�����b��1�7��#+1'�O=����UDGp�r�P����=	���+��l��������^����F�!0cnqwCdm��+�m������֣�V{�S�R�b�v���<����)�o�Że߿�2��Jb���
++�Z7���9+u����p���*+h��D<*�&&d]���?.��¨�=��y��pĒ��d�d'���ڠ����{�^]�R-eA;Y�����+c|��;_�_}�p)~����^/Zl���9=�io:a��~�����ǿ����%�c&3����ߧ�u�y�i՛y4�v������_����6^�c��0�|�:����o`���1D��V�18|����e�D�´�]p�s����7U'⾆ZzĞ�P����tn<���7�s��\�� �����T��/���0^�/��WN���ւ����?b�ϲA��b{Zz��q����A�('R&5��!�!��hb��6��#��æ�x�gJ��X�2�����éCŹ�h4�kOF�Au�)g�۷�7��v��1'�m� ��%��2�_����#�a��G����s�}8|����?��S�A$�Rp��}��͛�~�a�X<�sc�"-�
+ĝ��T������e��,�&6;a�[!��m�P�Ot���2��=L�������2<���&q̺����]���y��g�����]w��t�`cXuA/��T&��@eb�p,��QG��+Sc&�#�)�j�Hc��q�薯��{�A{���g�]�s������?6=�9\y�ea7����G�~���+�-Y�gŒ�.�����zY��z�X"8��q�[���_p�<�	Z����x�:th�/��/�����ԯO��8]�{,�Ǳ#1;lwu��!��y�鋀�I�,Z�����'���瞯B�@��OfNxMza��>�n�-.(�忟��X���h���&��ۂ� (($�'�H's�L���j�����*�g:����23b]�R�1;w�-���S�_��rB	��!��缧+���¦#_=�Ǻ���t/�4v�$�	�\yuX~�J��s]#;akT��ʹ������u~}⚵�����{�4���}�3��u$�N��~��p5�d��sOWr�Q�ђ7|ʯ��W=�J�̔�@��亢��������h�mM�>{Z�}�4��D�W���{�	KI��i�m-O8U�j¦��7n	��6+��B�i��x����a�Ġ*�d����J.=���#_=�Ǻ�|kk���;j�-���C�xbЌt2�}�t%�p����P���R��J1K)da#&0�)�*ڈ�]�uة9<�&�s��X��~���{޷U��|s��nݺ/��|R���i�#_�� ��I(/0M(�+&O��.o����H�%K��g�y����lm�T#9�<Q>s��C�(�i��p!�{��p�W���vs��	�g�PDhT�yT濍��~�b�bB�\a��+F��i����?�����Y��W�"�=�R�&v������Ug����ܖ�ʾ�l/UQ��:�^��l��L�j��	����|ϤI�x��@�/�ǁ(��N��/ebJe+Y^�|<��祇��qĞV2��z�u�{i�w����=|���_��_���>��n+���ףp����N�v�Ť%*���@���Dm��V�\S+����W������;�˿���/��ƉGZQ4���&O|akL��<�/��ԓ������>������e�4�E��my<���Ĥ��lz}���H�ąmML�����h��-{}�V�_�9�w�i��e�cL^=���߯'Z�p�Ƥ�ds
+|aNJˡ�=m�>�(�����x �<~;�ro",ķ+�M֖�}��	�T�UA�l:1��ΰ��6�����2�L���i�4sc!.����v��r����LC�U�BA]-��=}�?p+�)�6u�#�	��_��g��1?���������b>�?���aӦp��wW�'�,�j�6̴c�"6=�1���ҫ��|k�Ȓ8��v�-|�J�g-��/��\cP���t�`_��{Vtc'�9L��Q5M���Fg1LjB��0uJ�?�i|7aɈ�&��#6������!����Q���AZ[���� ܋�|2��C�|�O����n��aԷ�.��žh6��,��'"���r��m��wm���9�+q�Q��]������*�?3��|��%~Josǒ"�|Y��J��'������}���#G��G�O������x��NS��4G�<`�:	w]��I!�&��Q��<\c˭��j�P]��Ğ���A}ʅ=-��}ɿ�����kK�O�ٶD�G�%lt���g����'L[DL��Ia;f���>����U+L�0u��j���xf���ʱ-<�����C�G��1�����)^�N�J*�����b����qH�<��%���^kc���BA:."H����&f\�Hk͊�J����l_���+w�:t0|���C���? ����<U��|����ql�������e+�\�/�`���-[blv��7+��d���"���vV�gtM�&ʇ/�.x�#Pn+z�-��#��=-y>6�P�+��Cx���E#�k˶��^��9#m�L�Ӧ�u��k�9ႋ/��C��J�9b;	���K.EK>��{[�&VU7;oLj�oO^}��6y̾�N��j���3c���BP�h�WY���k���s�b��3�6�Һ�s�ɜ�G/�>�G�x�VM�:<M|�3�V��s��]�P�o�ؠw�H��c�@�p�!��'�_F*wa��������O�ܹ�I:;�	�����M��^6~�}Q8_e��^���벺�nT4���cD�X'7�%L:�GL�@8=20�#]cs�9�:�>[C1��V�+���cc��㟰�5��Ɯ�-�oYv*����_ο��9q����Xs6a��F��ɌLz��u���"�گ�+��<��y�E*�}-�QJ��\'g�����*�}��\�V-���p<��O�7�xLúb9Fl�0K�{ȕz>��Xλ�2�)c������{a����u��BD��2�4W�Y�/��������鿅8����\�S�ˢ�u:/���W}�v�z�/��/�}��k&��z�:�ʒ|"Pn+�O����e�O����m7��4�Ƞc�q`a&<A8lo�Գ+��Aۚ<zx4�|뭕���p&
+�A2bO{�~4�&�樣��x���4��O��0�J���'�m��A��+Z��=X_v¬�`mt��p^������3𺿅�xj݌�������/�\`��3�5Q�qH����\���V'��e�6�$vG��W����{5��x��~��}�t�׫��$���_��n���&w�A2bOw�v��F��+ژ���:Iӏp�?"p
+�?_�7��d)1)�GĞ�e<��������&{��	�uY���8(<ANU�3��>_�cj�<�	�x�x��,Xm���.�i��l��Z�Ks���_������}��&�Ar�%ԍk��VE����>�����-lGxOK��H���7H^�_Ɵ9u������04<^��l״�<�IĞ�mQIv���p�x�9�ؚ��?���M&��m�W�r��4��W�	�$/�=����IG�>�|���o��u�琧k��Թ^^��7��|��C�.<h|����ǿ� 1��r�G���Z�D�/Ͽ<�^��%�����	��oΌ/Ǔ�ӑ,�I++��;v�x��~��nA�6bcuaO�o��em �ʒ|�"P�p���-�\�^4��H�wM(ɶ|�ӟ�D<n�	O����Z!����=ٔ�u� �t�z���W�>)����ꡛ��ɯ�/��x�ﳧ{�U�_Ɵ��+�s>sj�����\V�yf�����r���Hs2'�5�M���s�}a��������pI����4����t�j���㝗g��M��������}��?��կU:��l����2H�E�|	o��]ZS��>{���2�e�gn�\�G���_�)�i���L� �:����g^sl����^�)]�4�'�>�bYt��9�+rZr���ˢ�?��C}���p�k�����f9��=�r]�%��~��a�؅_c�C�l�7i)�B���@�=���/�L?�_EGW��o��z�ό��6x�<��yZ��R���q���\�8su���0�����n�ƍᵯ�&�5_�phn8<>���15�9�i�o���e�#�n������f�p<������|Kغ���� %bO{���׽��s�+�?"�\g���cQ�:�q���_X��?�,�h@�̓=??V�W^y�_��_�*ں1�����	��m���*�&�\�D`&�p:�>�U����/��k��X/|�S��2O������$��_��{_�՗-��Ռ��,+�n+hF:���ES1��L�ի���.��HuEq�0��?��&i��ޣ?����V*�-tb�,ڄ(��3*c� Q�W�Y��Uƿ�8��s��C�S�z�����Ё����ޤL#]�47l��$*1_�۲u+~0?�w�ٖ#�'�8�ߚ/�o���R��bp��_����_�7�9��7���w��Lr��n��ʗ�V�
+7��=�9[��{�U�y�C��7']Ɵ�4ō�m��,Ğ��AҫƋL�,��L^�gs��7q8���R����y*�s�2��;�C��q�?���ccc�|���={�<��G��b�+�h�2y�@6h�����+�mK�U����t�Y1՛�S^�h�|��8��؛k�E�T�墓~�?��(��C.f��G��+��B�C�ox9e�V�#M�N���r�$�U��r[DK̲��W��]��w�}���]=22���8�uQ��@�z���I�x: �ϓ�s'��9è�^Ds�2!l�H�z%M�#�A�Ӓ�;��-����
+�F;L;;YH���|a����71��$Z���4U�\L_Ś�Ӕ<�t6&��I��?��#�t��4ٶU��|���/��ob�&���󺵂�I���Ы�\nΡ_U��gu��F;�:|�=ݳ��>�'��k��󺾽s�͡Ukֆ�O����%_��:;�:D���?�Q����˪���������ĳ�1�P�q�Z�Au{Z�<�Y{�F<�H��F;L]���Ӕ��zI��ǔ���\<�KE~�ϋ��f�]��φ]{v۸�w���c�58ٮ7��ᜋ.������O[��bY|�]X|a�eKL�<�-��S�����'�mα���cJ��	���)���pW��G:k��U<��΄���0u}�=m~|]lA���O�M����y���������y�6�G��b��F;L]?�6?�O&m��������k�_�������t/^�4A����۷�G?��?�Y<���{7]�7��=�t�"����+[7?���}�FeZW��9w��F;L}���(..�����+�Y�iB�С!�-`1n��k�x��#������>���+sW�œΉĬ��G��_��_���,^�w]�{��6�+����@�0!5A˴o�_�%�<�z�h����o� ^�f�0�x�W1����)��9xC*"����:���*pY�D��0m�U7����y�t<���v��O���h׻2�1�R���'�>|8���EKM/Nr�6��]�P���iC=���r��]������O�Ɯ��"|C������-7}��V�C�qY�W-������nÑ���q��[<�_���
+��� Ŝ�J!��@�.��_{ι��|WT��ӗ���Y{�:U��l�>�Z��8.Q���ůk�<�r	�i�O'j���xZ%^N�I������?�I|��>�t+��S��&{zʎz�����>��ػw�SP9���/�I���I��VY<�'1��I~V5H������eK�8&���?��W\q��d̤ƚ�c��A�+�w-��\�m�Űg�.�If���3ۣ���6�9ҵ�؄�\͛+�+0C"`��iKiF\�5&���Hm���e�I�*���^{�}�����˯ԉ1�q�d��n��M�/}o��k����|F�ZRr������b��K
+S�A�+���J����F�(�dd	Q��Ɵǣ3q�7O����-\�d��7^]���a{����5x�4ֽ�� y� d}h��U�ҧ���Ȝd�X��WC�E.[[<j�&&/UF<�Հ�i־�X�����p�ľ,��[l�u��j������w���$~2�ccc�A�O�y����i�U�NuS��em 4�Nbx�X`�D@+?���B��hϓ��\��={n��ƛ�4'���]�9H$�{��-0�.˽�y�t�\�`B]ɬ���B{Tc2<O:ӝ�+�¼�F�p,5�vbd:�$)њ�M�x`���+s�2�¹�GvĞ��~���-�W�3��U(��(�0�KE�V�&�t�E�¬�h���Xd:`�JA[1�H�v��A���'�ڐڥf
+��hbOWn�+\����QP�3ك����tU7�_5p��6�v���d'��ӕ�
+��
+x�Z-쯭CX+z�I
+A�0����7�8mx�Jx��g�%_�;�)тd�a�ŧ�Kq����0jm�/�klN_%�ϧ��Y�78�7�CЬ�GF���n�r�^������}��Y�Ɠ��>&Q�Yg����}��O�!;�,nY{�V�Af�Vo�S��Me��`�+B�"6��{��"��u�~�#�ahhh	�B��AVn��ӗ.O�����I��o����!  �v/.����ae�M�
+�hb۰�0	����"Uij�	������Mq46��^�x����B(��*Z�I�hW���)~��`LmKr�'���c���H!75�AD�2���o�� ���ǈ�sο lZ��0z�P�j�V���0K��r�����=r$<��a���a�gF%3����|C���x�g0��0_���j=Iгd�/ķ V�S<�O��b��Ǯ]�}�3a����(T�Rd*y�k�,��>�C#�����K��xE��"��Ȑ�LY{�iQ�9xu��gO��#e��	�p؜�I�i?k�������W��;��ϱ�]�x���'zML�r����>������x����8Jl�.��E�t��7̆�+�؍��+ĞNr��$c'\�_ǂ1��8l!T�z�����+S�v������k�ƍ|��~l\M�.�s������L����1(7+~�Yk��܊l�"����EظR��F�,�������[�`~X+w	r�Ɲ��?�p���^]pA������YM�w�s��g�R�0�����6�����h�*���4~�m��G�׳��͍u��v���[�~�,�8���V���e����*w��W����D?�|E+���1�䁭/�1/�_̏fv0M�G�̟��.ߘ��fEWy���̌�A/�����ƫ�4~�X�_����gN:���Nu[���i=������97�&���]�s?�s���W��G���D�+o{�{,���(�c�t���h�%be�0���o�P#����[3L!#]�G[��p2Ɵ��퉔5�����ocmCZ��x�4�ʤ'�b�9�2�'��.�M��Z�;.@���ߴ�M����x_������?��O<�裏�f76&*��\�˦Õefp��<8�i<ҡ���K/��V2�<��sn��ƑիW��Q|��%O�Ƕ��U��U�3�)���t:	���>��5)�GN����֍�,��QO]������aj�;`u��J܎��*ԖNR�K�cl��f�ȫǺ�k�bG�Y���迭Q���]���bG���;��[��y4��z��x+��}��ju��5NĞN��B�7��=M=����*�O=v���;��0��6����#�"{.������+��+�˗-�������&&xy��u$� �?X��䯘�O�����,�'�q�a�|2?�A�m1��+oV��x�.�mE������}�������O�L�<{�8ԫ�����=d�Y�������{)i^=��x�@X;~(v{��7l�p��������>6}�ϋ��O�%���(`�o(Z����+�k����x���p��أal�H�A�yK��<�-�D0_����=�/��!�V�S�W庲���f����ۓs���I���js�9����v{��j�'?��g�~���f��kM�1������g�fDUZ11jO�ϵgr����3?�3�~����ν�t?���v�0inOGN����b���+�����l|4V��^w}xݛ�\��e� �a�Q~w�73��yN75���6�"�5[�nO�����t<��A��>��5�Sk��T�ߌ��(�55��یw[^�|r�T_W�w���#Y;gvq۶m�5��7Z������ק��@^�:�9@�d&�dZ(H�`��}и���?ˤ���y��+O>�4����b����}�g��������馟�^uu���y���+�_Y�uS�	�̎6��N���Yx����|p��B;opc�'σ	��	���1{������+��=��Be6]����,�|c#��OPY�1�nvD f��hkie3;�|��?��E�ʺ��o���O|�?��w��6����t,X^wW��G(Z_ȥ� :���1���%j7�H���G�}�_�!Z�3jO�W~5��a�u	#':W[�)��[3C��S7�w��#܍�+Zy�=���/��k-�_��[24�/���W���2B�'�<��Ꜭ�A�����?��?���@�~�-��t@���|�ƞ���*0�"�t��ɥ�Y4����/�=���_7t#��O�����~�:1r'�Y[�8h���&�������E� ����N1Dq�j�j������y�%Wu7�]�ݒzU�մ�hARk��8��,�b�?#a��Y�0^�v؄����`9�,�ƀ�Q�Ӱ	[ k�/HH�V��Kms~��_�ɓ�/��nuU�ӝy�=۽��=߫|}u��#s����(P��Y�T�f��fR��]?���G���!H��q��M���m���1y�S�S֭_/a�u�m�o=^��������6���R�m�v߸V��������t�9ܙ���k����]R��җ��X�+Q�25s����?�J���,�_�k��*ʗ
+R��?xa�-_Կ���v���������/ӃSo^8��3ۊ�o�����O�7��c��n�ԟ���hLN"'�#�c�Yq +�fj��$�� g]���`c}X��3NeGժ3�f~U���^�?���$�P�Ӑ#��-?�w����۶;�o���MX�nCh�D+q(n)�2�4HF�+E��'���Gp�7���M��_z�)6��\�wb�C?K�'w=�%Mys>�ք6}�SZ;��U�~���7��?�D�b�gR_�1��u�������N�ob��&�6
+��W��������˟{M˟�~����>~�o�\�y��iO3m1h^B6h�h��m8Wl]z�Gl�������{�z?���K/��8���7�0�H�]�������6��g}��������œ��O��܄�Ik-pS:1�"TmN`@hҔ�3�B�H|df
+A��W�}�m����$R��N%O���Oβ��Gr�OI��x�6�F��G;���cc��ig�U�^�����o�;A;L�h+Ƞ�A#����r�k�Z���1��K�Vɾ�}%���cSN��(�0+`1+?�����M��ũ3{M��$��=(h+垦��ˑƲ���[ny��o~�%��㫡|$&H+/���m-���+;�'��@`��b�A����Mp��`�x#��"��Yc�|�|�-}�g�o��=��O��5���������h��uُK���'�V�l'�I��"m4xm��'��grL_m�m��?(q��t��蚸��6�A��+ib˳4�mW��}^�m�����2�_b���U�=:�(��������=x���>{�C�����?��?��{�/��O��"�.�����T+Ò1���Hd�9�Gz��س�xX^��C�˻���'V���xWg�������i_�-b�ƍ~���3�*�oH_�ǿj8��S�P�V�WI�K^V���o�a��g�/^6������ۧn���U���!�����ƙ�b������?��z�UW�ן��'�!%�)�8���:�S>�����y�*`QF���e�R�p��1s�2`^Y>�m<�l۶mj���[_򒗼B�Q�
+��J3Q��1,H[�~��m��l�?���R�T��܊�մ��0�pr���XL0+w�����+�*�߼Y?5?����o�[�\��طw��<0Y>�@Ys��]ˣ�*��+X����4"���4.�+`�H�2O�/`�G���y5�z.X+A���ny����7�X~��>�ۀ��/>Y��e}��Kż�>�^�/]/O*7y�%���Ǿ�9Q�h�+(�����?��Uޗ�12Ϣ��h�Y]`̧�m�BH6i�N�KS��G�ɾ_N����d�����]Q���u��L��mn�*�>��#�����R�/�x�i(�6^Ү�/�*˓��;�&�fyR�*��+���<Kw�S>���/��>B M~^�ž��H���l��1�?c���㉸�gi���R�m;�w�2�&���n�%�J��*˓��;�&�fyRɪ2���;�,�%O��_3��Q��f&�M�s�}���ʇ~fff������o��6����Р�x���bqS�+PNp�}(*�����Ҷ}nN8<[
+v�o�=4k��}q�/����|�V����O�жݿ�u�Zq�y��7J��ŉ��6��銯�I-��84z�0l� ��nS�vKA~������kdg]��eX�˿� N����C��ڱ)�l���V�ʎ1m�78>�4M�5ǪM�0ڿKe�1��mVr� u���-����ڧ�u���a�.�V4�8��w����?Y~��$�ɿ��������@���?r��~_�?*W�aA��Š�E��U�X��+a8X�����)�� �,*�����]C�u�[B�~�pd��+͢2;����5DY��u ��gGV���+�[�lBԫ߳Ŧ����{ʽ͉��Ҕ������i`��+s�v���O^}����'��ST���|���2dL�<^B�`y�"e�@� L�,n�u:�����0e�~��;w�|�����R���ȉ��&uB�0�A�V���ذ�7;YL�C����K�f�Xm.��+;TT�Ӷ�'b�%��S��k>Y��h�3��p���(*y�p7�J}�?��8�śm�K�1B-d-��/J�W(Hg��'|��ʣ2����n���ƿ�U��m���d=��} +!k���(Q_u�D �qß��k+���0+�e��}/��e^ɟ�[�xN�7�T���(���]�jy��4Q�=�^��]}����XB���]�t�%��`~���Wot0���G��w���z@b����{t���u�������b�_3;]�7����嬾������Y�ӟ���5��?u��k_���M�����;�S>���K���t@D��"�"�]�8��w��E�Q>y���޿�^�Y��_���_,/\��Y��5&�6�v������<K3?��/<�8^�	�}|E19+���7H1$�%�^��:��qRZe����z���<�|�̊��,$�l��:��:��-�k�mr�,���ς+��W�@����a��&O���ӟ���֭[}ի^�R��O�'`(��V:���k���6L;�6{��U��3�g�VSx'�T3-�	CE.P-�܈A�n��	n��"�-�ȳ�r���+w>�5�9�:Q�h��_�~�=��#&H�
+�ayԱ8�+bǘ���k��&��7�%�(E�kR|;�!L��=���>o��-����}B�����&/w#A������sԑ1�-g�������d�=���<y�g������C�a�>{�S��:��O}�ß��'�/~��z��2�Vt�%l�+�(�Q�s��R������O��Oo�{�j;ГG�VMl���K�%�耈@o�@o�B�D�K�a5H��Qh�H{=�i���_���)���͛�5.�J�ۨ�-��Y4��ڱ�!�ʟ�g Ԇ���$����p�T�
+������F��}���yȭ�9ò0�]�}�|���꜋S�PWa����=�W���lw�!��_�@.�h����M������l��-���� w���i
+}�O>�x-Ǻ��\��,�@rG?#���/�`�h|$N���HkG�@�D�%���eϼ��ô�r1��U��?!�{���U.޼!�1�7l�,}�w~�k��������a����^��|��( "0|�(� 4�|�g,�+��{�W���A��@�bŊ���/�։'��2I������ɻ�o���/$󛐟�c��s+�����吙g�K�:	Sˏ<���<�Ã6�PlL�n�xЃP�tiox�`�+��l����ِk#T����c�����_1�IH$&1������Sc>j��;����,Ξ�#��t,`�B}��>��˨�}��?���?���G���n^�����O�C?h�����08��
+�"����㑵�-t�g��:�Y���?x�Moz��+W�<�
+=]n2�,���~�h��l�}��4�,4}SzLj�w�Z6^���FU���N\���ȍ~�V\) ���vj%t6V;)�P�S�x�I����{����Bs�4}'a��d=V�?�X�i`�
+7�-I�=��@��J|dcŰ����/�!�5�8g���f���;�=�Ot�0��4{!�:�JA�?���4�FLc[�O�}��H���5��ƺ���,�4z+������a�M�yh&\�X�%��s���C\t-��|��e�h�1t�́;v��;{��^w�L��X'�������0�-��SoX������$�0!��w,=`�aXiS6���)7d����L�UE���8hF�d�|D�3�����O��el.�ȋuլ`ǂ���RAq*+xQ��)�+�:ڿ�����x�8"N+����x�f�<���߹ޔq҈��<Lɸ������az�efO��%6&�qB���%��!��i�����oy�Ė&orrrۻ�����뮻�S��ȅ���H�A+��S�����H��̣"'mU�x�[ib�X齏>��~�:֣�zի^<66����(O얦�_@�'��]��m@`K+�+�?�K��$^���+&�0a�����/�kSD�#Ն�J{`�����Xj���d�q+�)��<�U����w��2`�K�b,kS��G,���?A~��i�����b������o����S���C���?(p�u��&���:̏��td/I�@>�"��x+ly�R3��O�������ߖ�p�o;�{�=�#^��-q�dU�����F +n.�2Ah�-�֩�=4ź���HXi�aD�)V�n��_m�����m#KG��o�ϧ�D��B|�`������1�c�K�@�B��iL �gg�[9;]�=��X73�����Xz��϶�߿�ۿ������|S���\���>d����^�#ML����T�#� �lz��ˈ��+�+�+Y	s(�����b�)�n�2�4�%:n��2���Cy,�w%������@d_ۼT�}1?�r����:[�,����)2[&eK9�������6�mRƞq%���|�\]��yP�/`�l�[�,����)2�Xْw������ �}@��H9��X�7�b~�?���mn��tЧ�l��-�����=|�$�Yn�2��+��o�3�ꚾ�tȃ}�e���e��6�O��,�ʖ�e�/�ʝ5���,?l�����C	�C�4��Yr�C>W�/������|��鉉	�wɅ��b{���?|u]"R�Š"GL���Q��p�$nS����x�M[�6�MNMMm���>��W���+7nܨ�@���~��,ͅ��@���N�hy+p`?����~������[����|G�8������.x#˄E�&x�������<��+����O����FuaV�4p����ys͗JȏtW�me2<o����*���9�{w>����AB�Ix�F��O���Q߻��E�K�$Ě4�A�7o����
+����;�]���AB�Ix�F��O���Q߻�����{�N�ڭ�0Lz������2�����ۯ����%����g����o�=�[�:�y[���%,�Y: "p�E �p�5I�#\���Լ̯���z���)��������K.9p�I'�A`A+m兮�[_������Q�ؗ��.ܪ��Qi���Wƈ�C߾��gi�g��A��lm���_ϳiK������?ƿ�E2'��
+������?��A��W�������oJ�O:��}��,"#�+oLl�=PLK�� ���+M�ҟ�)�$�\��f��K�Ҙ�2_W.$�H%�x�d%��2�e}8�@�ęP�BӶ������i��L�>c��3�yB��P�t#)��1�(���
++����Ҿ4&�9�E��kpӍ1AJ�1c\b�#�����<aZ[�+�P~-�Z~I�y�.1��*��E!������̨�=��J����9��;H��v�5�T�����	ݘ��������̩=�J=�V�˵��\����K�hli�Y��)����ҴO���?�������\�<�[��G9�Ï��U�@�Xp�+k�+�H`F��p+�l,�4d]<L�]2듴����w߽G����.;c�ʕ�rqn��:�S݈�em�A&��jˏ�����G��3���X6^���!�C�	n���)p��,muM�BWs@NY��|�'�`9YWy�*L�W���}��@>Q�*�x��0�H��h����l�2�(��) 1��9
+c*��=�������3��X���Rwa��������<KS����#݆'&&�����~�߸]����=�����+e��׈�d]�����r��2z�)�@e`#��Fu�zC�d$�����O�[?i?��i`�o��5w��*�}���/��}=�?E�ǫ� �r��[!ڿ X�%ݹO�0Hn˻o�R�����������M\s�
+�B.���'o��A��:�5��+��O��s�TL� ȕӯ�s�/x.;	[�<^�O���˖?w�5��$||�/׃?:Ǡ+�����>��"Ż%㾂��� �˩�~J�/+���_}���|�|����jx�<�1���]u~��y�U�딞2�T�O���A���r�d�;�����;D�N26�8|q�O>��O���ѓ#@�!�"����B@�q�,�'���Qֿ�O�p��[c�v��3.��?�?�Z}ҹ$l�R��U�]�����͕?8=�pW�7?�;�z-�pah$�h����n����o��k��\6�����i+��O�uCT�I���-�{�#~Ŵ���9�yDf���#+>�?J���|�;���?��kd�����7������>�}Ƀ�H,�"Y���L2��$p�n)<���e�0�#�M��6C���w��c۶m�����M�6mn*p�lO�AY�x�#ձ ���}��*0�EH�瀻佈_�	��������{Ră)|�)���_t��� �(��-�H�>�I
+=7g�kЫ(���oa�9�al0R`�ǃXr�����pǉ� �'�q!l������O��9TL�0�C��?�C�A���#�����l��&��?vx�]��B�ű��<)�G��_~���?���}�#�E��Ƀ����_��?��MQ�"�2��Q꟎�$D�uԙ���.;~4��xԟ2��f\t����t�ڵkO���?��%K���;�}[����m��oM��H��ko��e�w�00��i+gɃ"u�7��71�+��T�A�X�A�X&�)xO���F�0���;_�+�'G`�#�����@@7��L^S>�i���u������.7�OgϞ�2w�=�I�>БM���էbh����?c�<0mN��3�jB���KI7∡�@�|�m��1�!�:P}�%O��>���[U����'[_�%+��Gh8��xWf���),X��/�W�0A��I.���
+��h+���0flP�l}��>�^x.l/��Ok�p�Vy΃�<�h�=��b��r�9{����۷o�����3�]w�_'�{ �����)�X(�,��<l<9��B`tG �YG`#���Y&�)7쐥6��w��+8+A������0$0����?�+LCb��'�A��|�Ο������T�B�����~����ێ/��)C٤l�u{�;��?kd�q����l�gL��^��+�<������ �=y���_No���׶U�e����7���W��W���Qɘz����U=�O{��~��eQ(�<9�@�+�M{��
+�$x��j��~�Fd��H��Pa}��!}F����ǿ�������xBLlA��>�'��\r0/h�7��Fd�!���&�/}��HE���/���DBG�E2z�g�ӼٶB0���k�j,�sN+�ɷ��'+4��(eT�L�)R�>E���*?R�C��������m/���v�+ڃ?f޼yk>��O�����ߕ2d�k�;Đ�IX�0�ȃ��d�;xhJ��s�L�!�����<(R�z5�)�c?�G{��'�o��щ����[}�TH�X�-6�R�}x��Ɯ�c�	��}�#�"N@b�d��G��g���CQ��ޚ|�������?焞�K���]�aO�:O�G[3z|p���ʋ��y�W��o������D2�����;������5o���2�H���85�'+�_듕�����"����m���r�d���i�I�I4�|��0>�x��[
+Ӗ,��^݄9�͗G�q���C�5�'"�q�����o�B^����H�f_Dn�5O�p�_�)[�@-/� ��eP$�=9��(�'+ۮ�3�Hb���ܜs��a�Z�����"�m��^0#D{u������pS��	�9��(�G����O��f>�/8�����?��^^�<�ǿ���+�����nۯ��8��w{u�;v����翾����J�|�d�3{K���k?��8(����<E!��8= P�{�எ�#`��+�,k�u�X�|71hgy���O�����{�/��>�����*��5�W�\|��:C.�i�	����Ek���{��zZ��&F��`�����[�`P󣣽Re�������͒у�ؕB�a����I��sL�=>��G���%++���M[���ĤʖxRd�[�������7޷oߺs�9gʹi�概����&IS��O����ZFM�?t�i;�6>�e��?8��1kd��O^84�H+�}#�S���L^�Ԧ��U:��zϞ={�G?����'�H\T�A6Q�du�6~��r��>[��Z/K����f56M���+l]{�_���FdQ�}`Vc����󀘰n�\���T]l������N�+�R	�L�E���>��~�'���̍G���������|�}?�=.��շ�#����*�����=��^u饗�(�o��}�dn�q+f��En<;+5o̚�2��I4%c�2��@[ׯ_����~�z��'�t�Y�4�R+x�S�)Ӷe2�pسmlo]�6��G6��E*�{���T\Ċ��&P�7+�Ц���I��cHI��I�Cg�������){-CH���(���R��`�e�ٖ��j?k�ch�*c���E����R(
+.E��Z�m�j����:���1F�^��\���(���R��`�e�ٖ��j?k�ch�*c���E����R(
+.E��Z�m�j����:���1F�^��\���(���Zt��i����y�����ƴ�ǦC`z=_ c�G���?(����w��|���M��_��W]�n�:���~�x\��M�ez�O�~,k{�@-O���e$R��8���A�G��S���8)������SY�чe-cYSmgm��u���9眓�n�-[�D)�Jz�܂�V�>�U�Fdȶ�O엋�'�N�H乞j�c�ͻ��Z
+�kp�����n�ٞ�
+z��k�{�}�}�cs�v��n��O�}?���˿L6�K��	�Ƿ%�<&�"�q*	T"����M�6��]�zוw�qǽ"_/����7�O�!c������STB4z&�S��p�X���z5���G�X�5wx,����iu)mO=hJN)�Pʏn޼y����{��+/�L)2m��+,�0
+�H�A��ݠ��Jb5��5�3�2cZRl�?6�2��E��?c��7x����&L��Ĥv���2ޜ�>�#0�>Δ��1���c�3{��o �h��:�
+�M����wSG��֭[�����k7�tӽb�<(�v���G9E!әvږz��6,�"��Qu�:��8E��#�8m�7�����,yP�S�ij3�e��Ç<)eU�u-���Wu�^�̜9s)M/�e�܂+�G�3�ړ�۶��Gd��c@� A`���a�չ���C�5yP$����?{�׫�mi.^No��ʽ���߶//���r�^���oۗ����x�r��z�������m�\�<4�������#�P/�!b�xFY�F�@���"�O�KY�=9�m��%����<U�S�Y'y�d����y��^�P�8���u���5�@	��G�@+tF����}�<ޏG�����j�z�t��\��[ko��?g���xRϡ����������;��>)#���S�u�@-��aЭ�2в,���<(|<9���+p�<�x�^��3cƌŹ��K���ZPi����M�u�[{[�z�FBp������w�����E"�HVmݍ��0@��`�v�x���1���@{}�VmݍC��ڀ�֏g�Q���ü�9��e귷�=��u���0��˦�`c���?Z����#�~����Ʒ�[{���[{[���������[���+�grwȣ��I�K�̳�zȹ�/�i[e���eYS����H���8G08#zr�����>��|U��6�@�ZW�S�)x�i�W.Y���|�Oғ�t��gba�T�`
+�#g�ӛpE�o���P��o�����eq!`��D`�Ty2@�m��I)�a�v��՟q����Ғ|�JI�q�.v�������7��&�n��8T���#���E��1�h��H~ӏ��t��o�G�֧>޴�-�������׍�jy䬿����>�/���n��w��]7mٲ�~�� yH2f#37礐Wm�i����1XG��Gc�1i�2���#p�!�\Za���:�@��&���QF�Fߖs�Y;�v������'>�$����\��R�Hv��ZPi����7��x�&�ko����e�?#�'�M���=�`�S����C��u"��^��a�Sn֫��+�����t�`_���#e�ϓM��C�æ߾����������k{�>[��[}��������������}�C�/_�Svʪ6�)�җu�2�Hԓ���({r�#�T���{�G���&jy�,�v����[9cӏe�Үկx�+ּ����?�~����J��:P$�@�z������\��>��m�F�L�3+w�k�)��ONo��Vߏ�c 6y��$�^��]�v���ˮ����k��^�;$�R���<�hyħ��K�Ŭ��H���8,�<9���D@��kjy�u�=E���qi���Q^:}��U�X乿�;��b��ǰp�T�@�>��\�9�^����O�N���*/܋_gD�z�Vp��+:�'����r�ϑ;������G6f��s|G�_&Y���T|��W��E���W}��CCC�^s�5W���~|��������_o�S<d�w��P�}PNe7��5�<ʞG` �<M��xG ������|.s���Zޖ[�Xe,�����;���H�<��G�ӹH]6��.h��A.^No�u��5��~����)�g;�ɀ]��jL%n�A���
+�����E�x��ʵo|���= �A��Ng��j�	�n�-�ϧ�7���Gɋ�J>zh�1���|��;���ڬ���s����W��֟�W�?�����;�|�;��y���H�$�������)Km��t)�rYL��9�2i�2���#0A�+�	��#��"����5�<�:s�N
+x�������g�t��^�ԧ>u��ŀ��/_~����b�����no���a�k;�]��b��i3�Pat�,$�9e(�/�\�R�����g�k*K��O�)K������{}�l(��n� �ގx��	1�3��4�<�X w��'��S��������ƍ(������K<�}�񍴙�y��kZ�OŰ���D9yM-��'G��``��p&�;O^S�l7��e�#NNF�k�B���/|�K.�䷗.]�����#������h�핟
+l��
+�����#��d���JP��Mf���q4�bߊ^��H�4�X7(�mO�z�?Ǡ@XHk�,�Ѧ��㟙?mh�����<y������9ţ�-��9��7���n�X����~���<���?��'>q��i�u"�O�v��R�27�ЁgYSͧ쨧Nףu��,kjy�=9��E �r����n9�@@@�ɧ(deYo�a�*kY�O��>�#��D����p����^$B�����a��r!���6�6�ͽ"��Hi��$���/�o�xq4$�S_���J���Ls������1%�xL��Ǜ����:��@��	�S~w~�3�����/�W��_�ɘ���z3ˤ��Z��6E!+ˢj�6H��J�p���@�K����������?yM-�227�L��e���mlL�I�����+_��U�z�E�-:c�����>yw���T�΁�����{��n}ن��y�3׾��kUL��f�������wē�
+7��ml:��{�-S��}a2�?f�|y��}��3���I�}E`۶mw}�s�������$�ɏHNm�����|�:ͧ�Y�XEb����Gٓ#�L���$�w�pR�c��Y����Æ����6e:m���X����/�x��_��.\xj�s�A�M(Rn�:��KFd�쐋����򓁃SB8�C�R��\�)�4���Y�m��8�%�#�0v�>S]��[�PI�#����ąP���?cd8��ǝ~<�?5L��|;R8;�'��o�����|��Y��e�r��$�P��zcN^S��_�5�u�O�u��)�2���#0	�ɓ#�8�X@^Sˣ�37򐑯�ZG���L���<��7��M���%/�������g���T�w{{�7(O���;奂��\=u�L�+aL���(A.~ӶXV��>(R�O�T}���&������퀷�r#��;��?]~��@��%w��?s�w����/S�w�Lu=���^o�Ν뮸⊫?����Rʍ?7�8�l�(k�.[qhk����ȋk��5�<ʞG`�!�S�'G�p��=�Z��;l)��)e:��Q�>˦N���-oy��^����ܹsOٸHz���յ��h��.+4$+��ꣴ�i��TL~�0���p!�d�׍��>;�c��֘6�O����1�.���1�o��ǟ�;J��c�?O6�3����v��m�x+��O]����={����+���G>򑟏��<(un�̍9�y6k��Y�T�UV���F����e�L���p&9�Re����w��>.����(ۜ��S��)bRny[��I�o{���|��9s�Y[����k�V�a(�m�X���2n�)a`�\�-O�|(�$F��U��n���~�����}��x�7�����K�����&1��`�еۛ�L��>b�NĶ+TR�|�_i����(yАj�g/p�w��TԡIΠv{���~��h������//�+w��~�l��r�1�/������?럳��w<[����h�l�7]{����?x��� 7�C�6|k������2R�XNє,S�ȣ��	zO��#��!PrJj��#�L^�1�|�BF�޸S���S4%+�g|�`�(Å��g�^��w����>��ϟ5k��@e�Lkl�Vo�6^]/W�>�o��~��?�?(fO���b�^�80,2ƆyИ0��"��>J�i�e��;��vϚ"�[���tG{Ā2D$�Z}�AL
+E���xv�W|"d@�|s�?��ˆ�l�����e<�-��A�"�yP�>�o��k�����\ٶ�N}�������?��?�d߾}���q�����v�L]��de��M
+_$�A�ʨ�C�pG����ѝ:��DA@+�kjy�S�u��WQ��u=���B�Jy/��w��]Oxֳ����t�R �b�dξ����֧mK9[��[ko��?g�o=�? +=4�1$rL��9�r��~tF�Ѹ�o��������b(Rn��������h/@�V�����Ь��i���h̐��̰��F_�/�8�=�C���)�F��W��J���W}���9�^����;o���>����_�
+w��b��1���6y���^��ץ�X�Y��C^S�H���8�@m��Am?wpG@#��%�gYS�7�гL��Qg���u�}к�R^�hѢe�^z���x�3��?!��,7c�A������{����ӫ�$Y�o��c��L���<9�x��@q�+Kv���8�4&:�y����}���jKH�������=SGF�ɲ�ǟ׋}�(�K�$.q��Xҡq.^N_�)��ME��y`���m�\y���m{������~�n���>��d۶m�$.6�{%��,l๙��T���(|�M*e��=��1���;uG�k�J�ks7tG�}L!��Z�fn�)g�R�̖��i
+{$-��+�?�b|!&�!�$�lذ�/|�߿����9��?$�j�+{b9E�|Y��w]N�Z���rY����i��,���x��_��SN9�sa���3(/6�ݡk�~���Xcݟ��is?m�o���ٷnb�u�������۾���o���{�瞛?����"���w����m�C�����S��v�^V��2�.UdHԑOQȐ�K��8��aB+�1)�CFy��L�Ԧ]���:v�GWi3]����w�q�'r����K�@��(�mu���L
+��g��r��������x�r����߶���l|[^���/W�������œ7�?t�w������w�z뭛�䃒Sjʺ�zS_�g|�G����d;)E���)s�8��aG+l]k_7���ū�����Y��o����[�����[o�۾����?g�o����_�W,�9��}]|���'��o~�[���o����~���^�G�w�*�`k��Su-+��Jg�aM�⋮�Ɵ@8u��+=9��#0Y��<�I�x�5�<�,e�n6������2�N��k:S
+x�࢙3g.z�K^����~��SN9��s箄�'G��8�ٳg�=���믿����b��<X�_M-�*C6���&�6hb�mC���fYS�H�&J��p�	�+�t�Yg�]�|�����0��8Gr��ƍ~�w���o|�;���������c�\�'�r��A���˶�ZF>E�<�c�?G���p!8����sG ��=�2�*
+�ֳl)*����H�׾�1��)=e�����
+,�	.�����<�dy���xw�Ȧ�O����m�_1��p�捵��o��cݟ��Ǻ�6~�����m�X��yY��-[��-/������u���D��!���}����[Dm2����ZN^�pCy�娶�1S~V�r�:�H���p�I�+.;��N��z���'�OrS� �&�EoO�u��:����յ����c��_��n퇇�woݺu��տ��[o����o�<ҏ;�CR憶�m,�*C�ʀ���������2�ck�,�h�L��{rG�0p�h�^tG�H `���L�R��L˻-Ӯ��=. U���<�S���� 0O^ x�ӟ����|�3W�~��',[�l��y�N�M�+��E{��\�z��K�.=y��鋱QJ�����:s��7{�^۾܆���x9�����o��k����r�)�������u�~s��o��k���x��}d�{$#ٍ�-�F˻�agm)����*;��~Ue�RT�,�*C��pG���
+���Ŏ�#�8��.��A �rʴ<'��׶���k�OY7�6xJ+,�<9��#��@�x�e�-E͐iy���LSW���2{+/+k9�n��!?S�y��+,�.�xZ`��t$����#`MA��9���6/g���xu�u���sz۾�}BP~��i۶m�7���1�����-?��ݷo�^���>7����č*i�2���~V_Vf�ԧ(c�C�c�x�RT�,�*C��pG`����(C��#�8�@�8���I�|�j��Q�#�����xl3}t�<��GY��d�#�ɸ 0�����偅�s��9.�hѢ��3��fq�/���CV'���e]��d��}N��Y%�x�n��ϵ'���r�x������f�m��͛7o�����;����}l���IƝ}��8�d�0 _ES:-oˌM��k9��O�.e�e)�2M5�vjx$���tG��\��%�qG�(E�o�ʔ�" yP�S�e֦�<Zy�.�&kK]�}J��Y=.��+�J��9���ݞn꓋�CCC;ds�S��!��J���;6lذ�{����`���+���
+�r
+��~�\/�墖�:����v]��뉧�����\��w�gc���Z[���Á���x����|��7���o��}H��/�ꫯ�o��m�����߿�ۻw�޿}���o޼y�mM�%�ұrü��6m����?����������q��������������_��q����w�}�����a[7�������z��7���m��7��1�9�����g�s�6_�5��5��+��{V���X�e.�8�Z͵q���5��� pu�����'wB�
+�~6�\/��c���m������߮��^<�e�7���5q�5�f��ޚ�}�@`��?(�?o���������lQ�n����Âx����/��jo���f�� ��3�7��1������x�=�l��8ן���}P�ǌ��q��bDK����X�/��-����q�)���x����7��Ǉ������v���e����=���?���?o����=~�n��~c�a��>n���o���xč}����o�ǣw#��̳7�8I�9�rY�{�Zo�v��|[ۛ׵�x��Z�q�s�2��j=k�\��	 @�훝+�ک @`A��s������^��f�j-�j���{�,����׳��z��N���{=��^>n��C�����[�xþ�q��xS��q]��G?�����ǘ�-�כ����<"W�l��M{�����<y�7�9�=�ԯ�#�^o��ͳ�c\H�9�rY[{=5��u��\ͷq;��z�,���Xs�8jq�u�f� @���䛃�� B�+����>I� @�+
++�
+)QH7$�@$䲻��y�=�ٓ�@�or�{~��{.g�dۭu�|
+/k'�z�*,�*���Lj`܁��,����8�S�ԗM9On{'�KlX���MA�o(�GH�h�����S9�t�u8m�_�L�x�*�oH������J�,%�@[�[����eɬ9i��w;��/:�UR�>�����^�D��r��b�e�TD��^/�{��f&:j��☮��D��au�;���(�w<��ҹn����\P���4�;
+�~Y��f�v�R9O'�ߐ%��cJ�::+�����s
+����f�y����!�.��_�i��`f�{{QRT���6$*!{�(�`��!Ĳ��}z�ˋ"�y|���Dy���AG�b�#L�X2�X$���N��pq`�\/*,BՒ�H��Ȣ�+w�O���r�XX����cav���~���Zas^UV�$ca2KE����k��L.�H���Nߞ�"sB�p�G09����+0�hX�ãq��̢���>�Sd ��A;�vua�����:��%t�3+h��M;��O�����/}��A�{�.�Ete��O�����+>yM0��c1D��W¶����7lX�7�ǃL)V9	^*@:�6s;`q5,N-��Y&O�}����寧����	�i�sg�B/�^�/�䰈�X\R���F��}��}���`qe��SMțd���ƒ�&X���كc'O����..6��˿�
+�D���OɆ����{q`���#��l����[;v`�Sm8�so����%N5!?��Cmm*��c��=��i���%�.1�TB�J�)��w*����;]��^-����V\��2~p�u����`lݼ��#�nb`��zzPBÑ�y�=؍x<�z@���̹��8��%h�.��u��t�*�q�Q��{-�d���w�6����޿��?�!f�{@�b?�_��Lv8�2�Cum"���M�&�D��J��V�Υ��fGL�]�+��5��-l�p�k�p��!DIy�������?D��+Wa?Pa"iJ�`�湘�S��w_��a�!�ӟ�����>I���<�tb�֮C*���3��z����¯�P�7"O�<�ȥ>gjU��m+Ԝ��W@&�l&s�1X'�G��p�J�ܼ��C#s>ZU=�b&5yR�͍W��;�޳^V?��,�1x�U��!^��L��'�7�^����r�XWUw&�:�����U����d]��K��%�ӆ��)�^�	�ޚ���ޚ:��^h��K{��!11��%��s2i"�a�y��3l�y�de�A���W�{�����*�6���״���;�3/�����u�¡�<��7����}�ڞ�����9/*�Z��~�j\8q~����нȩ?�٢���'���/��Q��+
++V�U��K��vlg\kg���v:������ng��n��(���V-X."�
+A"�bBB�		�~�n��=�}×�vwf������v����E����m8��Ŀ��_��+1r-� �8+{Q��=�N+�����(Cȣ�#V�U�_JΏ�������OV�x�s����'$$�x��\�ә�~��!�Hd "����t��ų555y������1!SQ��g6����|Ϟ=���l	�B}�Qf8V�֯������-�E�čL�,]+ S���_|�kEEE��̦�\��E:BQ�C9��}�*Q˸a�³�>��gT��IA��V��Bcc�3�֭{�����+��*8fs�(!���R������3�A%�N[l���D#Q��Z�Ğ��2�cY���/�@��Ä�4I��H5yɒ%���Ϳ�:u��`�f8"���	ᣔ��Y���hFAB*)g���ڣ���8b�+?�kF3�0�CB����,_��C�hʪ��	��g�T��_/�}U�G���40O�i2TzG$*K�H��Qw]�Fr�x���Ðb䏕��:���^xa"�o�#y?�����t�(���#��1���3�Q����������\�<]_/�l�*	QLa��*V�h-��M\l5��Cy�,���l
+��8&7k�oʔ)U0���x<�G�ݦ��3I�6�����
+���d{s5[m5��x���+/K�����%+;[�(/O��򗥏RPdL����F]I�O���t�M��\���UE�����;ÕvZF᫯�������L�QΚ���t@:5!��k�p*����N+������������X.^"��$0�3uu224(ӊ���U.�0����4�_5%�"�����v��y�����Bpi�Tc	eee7�۷�%ly��.�s/g¯�PU:l�7��f�����3���̌њt�+����Vimn�t��s`��WV�F�ozU��|K���u8Gp��xEa��	*�#���ͧl��1�:�Nz��f�C'B�+GǗ
+ȟ�m�����4B	�K���u�ˊ�VK&�� I8U�p�[P��[�#Px΁��O|A!�ۻ:�"b
+�8���j���Q�$�dy���LY5�.U+���R*��*��|w�{�������ϒD�뭫���@�+j�u�Ic��:'��G g+ ��o���N�y�j���"@S##�}P�~.'[�s��9"^o����.)�^� ��f�F�8#������:�vk�kV2�f\`����������v�T�G�����4&[*�_��,,)����4�^�G7A�?��ZDD�֨Ǩ����伸��jl���Fi�Q&ES�Q'v�bXFjZ�4�\_{����gV�T�����GO��Gƹ�Tp+jsaJ��Z,7/WJ�+Tʚ���݃��r��I�OO/�A,�K���s.��+��<���I��_Q���0��̬l�"P,P�ݽG�kj���v��˯�h?.|mǥ�@Y �!ʆ�cГ�ζ]�v�!�,����.=�F �]�������U֩�gԢ�#��$�nΔ$Y~�Z�y�j=
+p���gd��-�� y>����ۊkni%I��5��:��ӧ$eJ������f���a�:���W*��YfE� d�+.)�3vrhT�7~$ND�#س���)�Ԃ�5��T�8��fρO�.�%%zn8��!9�e����)�3*�tZ�ffhޞ���-E�M�ǅ�[����F��hm����+BbK��KZJ�L��ʻD��p����$C�\53M�qՅ��5�܋��[�����8������۰a��h孰�+O4�JY�R�2�]Z^,�x�'�	�`)��S�$�	���0Mh�A(\�c�� �el�,'&�}Eh@�x��^|���{���W���&y�XW��0�JKhjj
+���6b_-�ΐ�+c�຾̚5�c�fE��D�/�I����%3�^�|�+���?�^�+ ذ�ec�*|�P���x�y�n�!j�����N\�SFP�2᧶���p��p^xr��\�ţn'D�q�{�G?��>\n6����u!s���:?u�<
+ 1��5؊�'"R�����ַf�r�-s������<�����v����"���e����z�$b�f�q�c�_��Nh��
+���lE�}���_���呁e>�(���φ���tXH<���V�Ƌ������j������uz̜G>����Dg���YǸ�t�`#�"��pˤU0S!��*�~�m���8{�uf^V0x��FfkL3�w'��84]k�ⵕA!�m�Y��٦O%P(f
+�ٵK�ξ�l�{�d3p��k�Hv���K�>��[��׈��hl&��e[�D��U�~N��~�N�+
++�WW됶�����c�.�Q��[�5��}�	K�,9aʔ)�Ə�D���Ç�:�jp79�M^e�����w�޽F�Ī͛7?�������#���e������k$�	����r&��M�p��W��������OG���w�����y���7�7�7O;��cO�>}��cƌY��:����.-�J�/�)���j�p����o}��o��?}�W�����ϊ�	��B��.ҡ�Jy����.����)W�#��O��O������s�:�7O�4�L-�OЀbRx���8}��7z��ޱc�}6l�����S����_�����&D"���ws�C�e�@��(�^T���S�:~�����<����?��3f�E�3YGQ�X�8h�Ĥ�b�V��Y��n���?��?��[Ԗ�ژH5�lӟ���%y���%	b�ʗ5ػu���_��N;�s~d�̙�6���H�29��Ǜ��{��;�-�~�2<�v��+4\��?�ӷ�M݁_��>�-C��@�QQ�{����)�q[n��	����|�\�^�D�洿]t��+܃���-�k��*�Wy���g�����/^��Q�F-�i�`�_�����?Xy��/��?�t��ޕ+W��'>�}�+_����	5`B�P:@M+WhU�����oVK���I[�nNC���@���P������,�\s�5�u�Y�����f���7`�7����"�v���qX�Q7��D��a�p��Y��R�0^�S�ɇk�\e���uc�wy��=�DL���x��!"��X7��wq������롤�����}梋.�N,L�
+hJ�&P�D�Ci��Ci�(��w7n�M�`�|�UW����O���mw�p�`*GNL���{����4vi�+�0�S�	7%��`CB����RD3L<���ʄ�(���e�=�8E��#�d�e�=&���G��k"��;������m��E�$���-�����PJ=@?�{��B��������+���GN:餏�������P+a����FZx�Q9&��}�{M�������K�H�:���`��+�כs�.�+%����ХboN��DYPP!ش�扲p�fJ�I���f���*�Yp����iӦ�����'?�䓷�y��Ck��;$��ö�zm���8{���@����(K����+����]
+��
+>F�U)W�2�T�`|�SA��Q�/����]�=�%�!ԃ=P�&踷^�x��T���@��9����j��6�"�ٝi7���1���ҨL�����=a�w��D�mE|R!~8����'�٣<0F�N��9%��?�)�3�4�[<*�����th�:��O�j��N�%���o��%�oh�?�ʧ`]���<�G�Z�C���@G2�+���킰j�S,Ȅۈ�aA!�m�U������#�6+��tJ�%��~�g�z�pJ����Ut���M��Gldx����fce3���ƻ��Q��A��t������#�9�D��¬24��sY�qԂ�#U�ڭAQO�AC
+f%:��`��-/aW��򸚮�X�	y�͵��5^H}EM<�+v�D�T+���&��ԄV?���Y���fX3U}t�|��R�9�=�@_�lҭB�
+����/������+p5͋�+Xu�+SW #�KT��<FN])�Bu����d��O�Ɗ.Hkz1lm�		����_+�!�|e}j�~���x�F}��������;����Y[��:��[}����?�&D`�,N}o3���Op-Wi_  #�"8\@���'Xk ��H���`�99�#y,%J�_,�[y�\���CH��H9ac��QE��݁	}ѡ'9��5�K^d$�?a�ʅ���~h����S��#x)���u�F0�j��e�}�z�u-������f�������}��u��Z	��X��A��x�&w��k�-���j�]�p�[o��/&N�x��O�ܬ���.�9*�*83+oe��6��]h�ǋ �A��^*�I>h!"�z_�b�B}�ud�`nQ1���r��:�և^Ӥ����U-`�>��������u���a�Qq�������㏯	36$צ����9a_m5���pŊ��v���#��{͍[��%$��D%
++�0��%K���~���u��T�k��j���}�}��U�q��j����z�����]�v��q�@�`�CP�!�A2I��
+��K%�r�}ю"W��	;<D�Q	���͓�6c���d!�r�ן,O@��v��+炦���z�%��:7����/��Kȫ�P��)[`@�%���ې��]����ޓ��JS�ԫ*��
+�=�|
+"U���=��׵�͊x�t]�U��?FL
+�@1Z���T<���:TW��ȹ`9OOe������<I������6��Y?��C�$���%��G��PTU�Iv�����$�`R�m@4	�r�a�b/�8��L0�R0^wxX��ۡ
++
+<�YH�V̀6E��&	�H1"�H�6�D9�[mVY�f�J7P)�6X>vH>܁��)_`n�
+n�r?Ԥ}ݩ�y7����:��~:"��
+%�Ԟe�Ą炵B�J���F����Z-��; ��Vt�=m���Ħ��i#VU��.�V�q��Y6����8t�u�]���K����PQ�[Z�}7��>y_�D��f��2�q,P�_$�鎯2ylH��Do��-����^��6e������[Xې6���<�-@4ŊӲ%�L�]�6�Ϊ�b��P��"��Q6�jV��CU�.��fUm3��mG��^&9\�g���(?~��6Q�ʩ�Ի�fΰ*Hʼv�bGL���+�hZ���ͺ;�\�Eo��ܱl�er��̜2�I�
+4W1KQ�vX���ʶr����9_����}�g~�@-��߮�  %��qG�/X��'{��E@LE�D�-���a�*C�I�c��΄YW�-AxOD:��䍀��K+=���P*��D"���	,��I����8	�&>�t�
+i�-eW�T��S��S��f�M�|���%��.3�J{���d�]4&�4�Ī�y��&��0K��%a���I5��g����ͅ�u��TǍv e0�^�����o�+���Y9�l:���c@��>�F �L��KYm_
+ֆ_
+*�!G{t��� !�ʶ�P��C	��(2����;��g�3��ik�'I�#�P��J"��o*kQ)��BY�����j�eR��S�3*�h����D��q�{�˼R(X���,��)R?Е~�1X;�U,_���j�?V2Z�!/U9�i��'�ޡ�6M�F̝��6N+�+����lg\5���+/�mF��"DY��\�����F���n'3�$�!��o���_m���."��a���	g��s�i�~��-J�J�2�P����cP��I��k�.���������WXBtX�2!!��!�/E�\ � 7�e�)t9�\�A�2���p�BV��ٗ�P/I���xx<\�'��&i��5����y,�Y��Y����/4;v�jƏ+�>��I+:��Coa�;�cX�P/�6VEk;%�ʶ7uQֶZ���W��f��S)�(�8o�U�UM��WUe����9�������+W��I�&]X��7���O���v�]��#��M����e`�`�:��q�E�	F`x�n�$�!Lf���d^�%��j�LL�₴Y��卶�]�r '�}�v�b���S4\w��ͷn�ٓIj���Z٪r��mo:���3��5ļ'�7ӻUҕ�_���S*
+��Ͷ7�ø��9�������D��8A�7X)�k�,Q�8z1�A �!���Qې�V�EX&:�ҷ�e�F�2v�u�;]�n��ſڹ�$Н+�j���+�ز�\��S�� ����2��DLۂs=+)
+с��U�܂Ԋ	G@ЗO�:��Q����F�ӛ�]��,�dokA!"H5D̢n�7�IX�kY%;�G����p�-����nv�#s��/�J\9bD�d�<����_�fq��ρ�C=�y�X�v����k ��T<!�*L�]���TP���`FQp���'�b�>*JF��dh��չ�B=��%O��I>���Ն�3g����]v�e|a��	����Zd�W;���c�=�ܣt���u�W|ˉ�cd�ɿ�m��+�v�aNG�(��8�eR��OzÂΰ�7�#0Eo����Ad^լ7��|�z����m���ҟ���r�/;	��74�j�o�Ab�#F�hf͙�̙;�eLh̀@��7��lۼ1�aH:r��	G1�+�+�!�l��+�O�h("�jB�ǁ��}��s2`��y|��?�nʔ)'�v߹�kxT������^A�'�WP~W4>�n����f�ʯ��o�<�V�&�[� �..�����;Kg�~�D�^��G��m���#r"�T0@� 
+J%ٷ�5LP
+
+��"�JІTl%LL�r�\U�������+�Ԑ�0t9�5m�%}��ٸi�m���s�=7�m+�%�ݬ4,5�V���4*v*ӷ~����$��S�����	(�n,	�a��M��5���r��я~�G�5[U�S������'��+���@#�����W\�>}��rN�©3�l����S�'�.{��@t�Ν%���QڛPt�l�Q{�+N�EE-,��ҏȓ�ΰ�j>���ڶ�d����}�g;ms0��X���r�'�"�U�?l��	�h����/�؎�Aq;2�0�<�n�2,�~�v�ߦ���w�(W�F��p=C�������X�qD��m�+��Fu7�袋�q����#+��+�J�a;�a�~t���|�3Wj���0��ʳ寐t��[��F�xι��?�s��R���k���#S�Yx+��h=z�f���W}ޫ�>���SO��)���-W�@�1\ņ��3����+G&�l�Sb�|�a_I+�IzD�����<,����)ؗ����Ǭ�֡F.[w�'�X��#F�Xԡm� Ϭ�o�C�����%��"<�6&-�-"�Ò*�Z^��T� ��(��S�C�� ��6��$�C9��.�cY�y����鰛�2�]Xea�����|�$o������ov��9�WH�J�9��.��9�ef�?H�tq�7��y��U�N7��؇~�1~R�^��W�En{r�EE��5ZzXYԩ��@��]Aih�L�p�]�cJܖg�8)�����P�����j�=l]z��.�,="|�ng�b���)��G�1�nذ�>����ze�bA�0�^��J�+II��e�𠆲w0�V�o�a�����-mDD�c�~���f!tSV�cC^/�
+J:0Nյ�G>���?�ꫲ
+p�����!����9�.��:N?��y=���]� �k����,I����<`< "���,�?�'@!�=��ʷ�U��@��4h�'p(����P�!i�'�;8�a�)��Z�,70���Ö�W��O,]}U.��#)�Q��r^�s��=�[Q�/�E�MO%M�i�.(�h�q�ך�z�(RQ�5O>�y�[.lV�
+Hށ"��OE�P~S!�)��Qe+��:z�Ȟ��")�L�cdt��K�d��������"����+�ۮذ�Ƙ�K�"~�	H�ǌ�\�w5#G�K�{������UW7#�J�>�^��oL��N�埍�S��N)�N���萖��C�����+%�`��yeI="������m�_���
+(D�֕��B�r��yf����
+���t��"4BZ��'�i?	t�e%3�q��7V۪GW��K�qئo�x�b���Op�ު��
+��[�p�m�+H�w��0�C���ΤȠ`�8��r"P�uj�j����<g(��T+���#U���&ѝ���d�.�-C�h�b1L��uW�^�U'��-3���J�#���V+*����#�RO�+���/[d
+d��؛�	B�m2`�Ñ~]+p�D03ا���$�	
+r΋�*�|��s\�.+J��Q>V�8�x'*�,9$�����ov`�یi��	�=-4����Oj���r+����xXZ�<E���j�,ѳyLF�^MJ*�|�ް�����z4J�#U�C���KM��65�e&�z�q��V9����l�p\��8���P��I���E�EkϘOݕ<v,r��S"�2�$%>>j�������*+�2�l{����4�=�9��[�^�ŷ�٤o��a�f��m�b�U��];�Q��>Z�ոŦ���董�Θf��O�:����uFjP0��2�D�X�����Dh�ʞ��TF���؍�i���<�;�GI �Uh'��~��E��y�4��|2�*S������f�v�����4�m�O�ݬG����X��v���&襣�z�`�6~�̓!B�٬�����Gb��-ػ�m9���꾢OMG��Ob�8������p�
+a�^�;[߁T=09�����X���	Ж���"��r��`|�U!My�9�A��I/��>���L��'?�L5�+F���춶B ���@�+Y�'����y�z��W�T��������nuk
+:0Z�e	�`�CD����&�ΆT�r��H+�Hvh�z��JGA���أ���n����7�Ѭz�I�H*,��i��)w�*�JU��`�u�q˗��g��h⬽%�8�=SG��J.<��_�o��t��e�Lط��^s�C+��u�M�2l(�Y�<}�~fl��0�y��t}Co
+G[!������S��:��F}h�	~R�{+^9o2)�v�|�d�l]h�)o!�B����6�;e��~V�E�@0���� ��I��.��Ip$#4'�OuvN+ѭt��gΕx��?�z��͆
+b�J�%�9n��f�>�5u�.p�E����H]���+��)�x�v��=J�C_�ݪ���74^X�l���"�|���w�GO�-Q���I�ZA�L#wR�N��vp�
+�|��n������}�nZv �I-�SH�%?�>_Ę;o���Y��&�.��|��uZ���꧞h^���j��;�}��f�V6�o6>/��zsFR�,c�I�q�ys�������I���Z	l������,K;��?�{P�b�ܮ Զ��g!"�w;�?��ڀAjOa�a�6�k���1vgK\/ޯZ��s��~��Jov��^̼H�s${E��VG~�J�G���~��w��0�<[*�O<��~�ˉ�H@��T���q��d�YtZ����ѥ���C��g�Hl��!�Z�(&<���G#0S5P��ͥ��7-�e�4Ȼ��&5��,i�Z���>m��8S摙��Mј�J|��N����7<���`�=w����R��̤F
+&�UD\ț�e�X|���<�Ps��kՅ����<X�ǎ;�9�3��-���[t����]{~�'~�3���q��z��'��ʌ��e��uu��'�']e�aO���|���.��9A��ݶ˟���Oa��<-^u�P$��UBy|���;bF8�A�l�h"A+��MG��T��K���:}Ԯf^�-�ֶ,�c!O�T��;w��`�5a�;q
+�A���m��ȑ�6���ę�w��v{t���d��ҽ{�Q�d��@�3��(&�<���Zt+�#����7,�gΜՌ�-Bpn2%�'S�X̝�8������������{"����XB��0"sԁi�0bd3w����z�y��͛��f/� �:��r��g���!��h��\�{�1Z��0�}�~јW1�����6�t�X���D�x�l��1���H|P����50t��f�N1��;�٢ۣ<'�8��µ�o�F4#)��p��
+�AE\�������>X	N+���K4�'^3D4�7�"���\�dX���'\G��^lE����O}�Fk�Q[O<��u�zʩ��-Z��]���ij��������S��a	?��iq�L��H$�8�ۃ)�|��atytH�����F`��x��S����>��ͧϘټC_Ν�2��TIr�a%&A���7�Q�-ܓ`
+�n�%2?��f��H�a�ϓ��w�Z:�g��`XiC�h�ծ���*���o�Yz\3~�x�F
+cÇ��~���l,<��6v��q%�S�����8q��l��������d�����Dj�j�d=u��������uߺ��J>����o6ճSf��7
+���.�eo0��~m���7)w+���iw�f�Yu!C�V;��V�4 =�lش�y�N�8�Y��vFXao�������S����Y�[�֯CRڧǆ�F����"�D��+,a�Cau��zWJ�*�-��AcC���L*Vn�;�1��8ަI�-T
+x��P'��_�G��o����-�@*l_���q�#�a��r|t�J��̿MDВpz]��O�)*x�I��6��\`(:2K�+JC�n?��Mw�����ν,�E��EE���ӫu"���cF5������M�Q�S��l���xb��l���B�Zw�_ա�h�K6uy�
+�*n7��~�Ĉ~P�cc�A6 a)���-J�e%A�M9�c��+�v��?�q�po��}��w�+��u�kꩧ.�A�c��#��(��p�z�^���p�Nȅ-���E����+:ē��
+3yt�O$Ϸd���a�#+W�4f~���t<\�j�
+�3��-th���ng�bH��D����h��X��j��x&��#N5��]>�oՕ�A�h�d��挳��+���
+u�2�q�OM�R�?����WP
+(WI�%�l'm�H�h�6��%|*���I��o<ʌ���v4�tKr���g􇝉<q¬����v��m�x�+��l�~	<��^��v�- ��uai�=�%�H��T�1�Hǰf=̾ŏ��S��x�Ē����=�	��u�1zDq��sȉF�N9����?�ci|��1{
+�A�,i����NG����`0�hT!��<O&.Z�	S����+�O�O��Z��l�@���`wj��� �S4�r�q`�C�~�Wk}=��˯����þ	I��VY�Þu��=�
+�h���3+�=p9ܮhq�5�0�Z:DP�$��C�9���%u?����Ӽ���^�	�v��P�h���f�*(����˥Kʰ�!�2�Fmv�GKY��@A�p7�L��A���p���)9�q�SG	���-4�9WA՘��q�d'�`��J��ξQh�>��Y'hC�����m1���4��,���U��[��9a��2wڴ����]o��;$��I���g�MlZ��l�۟�
+~`ş<T�SɅ8�Y��z8�Gީ�y�s��Mp�5O?�L�TkcȮL���O/�xc)��{�L�Bv�x�``�r'��O��h3�\FH� �L�q�1%Z����Zl'��a�m��z���o���sCz;�Fb�)��+6\}�4n�B�<��g�A�rk�>��«R���G(E�JSYϱG��H?[�"9�7����\$X+H��(�F���&�t������SUo}��i�X������~��]�>p+6����|��ؔ�ݻ#��a"��x-D�g�v��X�p��I�T,���h�D*�6�d��x�4أXJ,�DG�QԵm�"/
+S&�Dm�}���*-�J��>�SM��d#N3+�t��u�u��7}u�����;?��x����b��baB�@�2J�r�ᄐ���<�B"��u�a��m��Ї/8up��[tU�+ M����vg����i#X���a�^�~ yF��ɑ�ul�E�#���6O��&����{^�F76⠼8�~� �!�M%���4I� �"��%������>G�[�v-�kb}� �$��<|j,�6)Rpµ�^�k��)�ة���n�T�+Sx�NZ*ƶ��&5e�4�v���Ѓ\��)��%�6�E��٫��M瓜�J� gh����p��uԑ��A�2\� W���� ٛ�i�s��z$�����G���=���3sU��|������o?�/�t����Sch�M� �VZ$؝XvԝY��-ˬ6T\�]z��[�qL��W��j|ūǮ+b���;wU{v�h���2?�O�[y�B�\��G�⢁�	F0 �M�+�B���4$Y��|YU�"OՈg>�G��?G�1~�ϣ6I���c�"'�������>.%
+��>�re�&�q)M�|�a��y��c��w�����{n=XS�k������C��F��A"m\L�A�Նg4���G�L߹�j��G��ư��A��?�0r��l��N�WMkI۵11�M�eѡ�t��H~}v,r�"����УDu��h�*��gt��Æ���(�b��ތ_T�WQ�K&��5�����%�lQ�0��&�=X���qр-��>%`w�v�����(6R�8dߴ�AZ�m��h��ŋ�f`���v���V;)j%ٕC~8�<w�:�Mp�A!T�$��j���6.��y�D)��[p��B*6A>�1a���\��R�@E�D��܈S�&�(��ۣUz�y���q��Mg���:uZ���}�Z���B`1��
+�ʙ>m�I���&��̌�knȰ,�N��gZp��Wq ��g�X:� ��j�iS�"����J�[��'EA�Xm���;��!'|(6�(h��~ff��=�y��>ƅ�⁍A���k�3r�=ae\i�Ú����Pa��9�2Of{�,t��v��?J�&k鿣賓� 	�g.���-l�4-qF���z�@G`w0��(��oY�TF.J3�̜,ZI���3�+�|�!'�!��(��)�R�+(p>��"��������,(�����Лe3����Õ�0DD�E��{W>���p�j����{��[�YE�N,�qɕWk5.�%WD��&�3%var��ִd��&�X���M]���E��W�ǻTG�I�>Q����D`ۋ.��=�O�R�NM�x����40�r�+	�6�y$�u��|h�ŏv����'���+{K,%ı�ei�-Я2��! �ٟ������z0h�M����\t��pF`h�Xl�K�q�)�+�a'?m��-��bM��=��9�9ITp�d��]���V�����o�k����aI�3?q^u��|��裡D�hly008�geE@$�;#��]V(N������gW���C�S���_$`�7y�)ŔX^�/�:�V3+2훘���Cz�e�>�G�J�^'Z%�Pv<�p��sд.�+eY�e�H�J<Ef���%d�	���x1&�f�@*J8VvX��	�Hi`�<�&0���8E8�>�x�l�s���ubt'������
+�:6{Bm��0��K�!-5ɢ+FU�,�]�b� ��k�T{�����q4��i��L�8�{�����������y
+���s�U�Tg�s�t�Gz(̄i~X�(1�r�_JL��Ϟ���-�\!��J�����ɼpR���"[vj'=:()�9�u�M�Y�H<��!?:�O،��N����7�����N^���{5������6b��K�b�h(�
+����T~��K]���bR�m[�'�2��Dt�,���+�=�IyC˳�`��?q"}/^���HkL2�.[���"(n��qň!����-v��8����0+�Q��4.�Le��K^����G��4����Ͻ����*�Z�ga[�_:0?4���%��7�!�l��զ'�{%=�45{�~͑޾�	I�H��U~�o�he�����O��g�z��\��mAW��ȃ���y�H�))�wy����3��0�؏t+�c�`5����J!��M�jS�E[�}�����"�<\::a�g�h=r⬣s��zȐ		>ɦѺs���.��ɡ�ʨu�z"4'��߂�����%`��O�V�6��6_��--{�M��w�g�v,�w��)z���j�^/.F�?l�fti��٠]n<@m����(3�b�B{�OбS>N��)�H^��A��·]����"/p6�1��!���v��f��+���q��$���/��/�8��D���/�ӾA+n�̪Y�ZR��V���~����z� �a�6�����������t�Z���S]w�� ��$ծ����@<��]ІN�a(v³��!�F��MF�+md������d���eĎ>f�B	u=��P8����i�q���<l~l�ba�姝��=C���7Df�����JV��H�]����]w�� y`���l2��F[���Z��.�����86��
+ +���B������Lɂ��!h#[�7�Ff*�[T[HVf5Q�N��H���ް��jpc���n�E_��\t�Kd�5��_��d��AMB�O�����dKI�ˀ�S�FI>F��\A7p��c�G�*e����׌���x�X��������j�5Qk�'#�,�;��ȵl� �t�&�K��
+S,R�U�t��ӡ��cz=�/����q��LZ�{[�c��8��]y}����c��$O��<���F$}l�Ύ��8���	fDG.��+�l�B^����#y���Kh{%X�~}Q)�H�+�ltm���m~]� U���@J��9.H�)'r���Y$�B�u~`Xx\y%HQ�(�?��0aV�SD�B6���V�qv���+=�U�Gȗ�/��:M˞�QG�Y֣p�Jk�d+�iQ�XY\ٹ�e
+����rA����TcMbI�� 1)* ��ɤ�ľ��;�b2���)��n�)�Mu���b�3�I�n;)L�MӀ>n�d�eb���"��1��XG�A������>8�'����3�l���/�^�a�Yd�eX��u��
+G���j�|�Ym4W�?
+�c@�h��=S+�8�V�**ԡ����	�^�������S��껚�{�}T/�����hԕ�z]{�g5F?���߈9b�x&�<g��$���')'�+R��|'OF�����?�G~xǝ�n��z���ҷ�n���'��f�}7J廎t�x����}�a�T��x4�}�xS��Ɣ�n\?�k�%
+ʹ�\W�S7��g���e�Nokf���O�_^:��N���԰�S��d&����`����¢<�����_��Y�f��a5EX��Z`џh�O{��P
+�g�>�")Ms���r�8�Ai1���bEU�2�H�e��r74��p-'C$�ϲ�9j�>�[Hџ:�ܥ%D�bP�me4V�G�2 -���tTG-^\}��HN�&N�����TϽ�b��.��x���1�׽�ӟ��͘�ƁMh��N��``�٘��*0�Gvc�}5TT,���+�����3u�߲eS�c}=;�(!q�5W�;n�]�L�D�IBU�ã��?����@�	���$t�E,��Ȉ�E�&�,�"�+�:�1S�03	
+��ˈ�p�J��똳
+�7��F�w5#�z�B�q�����;���p*y����uv5K/�p�C�,�j�g�m�	�a�@�q%}I��ho&+W6�qz�E7\�
+�++�c,$�C'�$HF*��K�Z�W��M3fQ]|��v"��링 =���U�
+��>L�A�q�+J&�1L�m\�""Rhg%�+?��j�&�KU�?س�ڢY�.Ya�t�W��B��a�s9{B1�-��-�>>�# 
+���)r��IՎ�X��.=�w@�z8U���%�G�:�1�G}1*$yE.�Ь�=�/��E��r��(s�O�,�ƧѠ�VW�����#�t�/��=�c�ϸ�@,Գ��!�%���ZI���K��7օd�M�jS�2��J��D�r��
+{���J̓��9�K�ٿ�ߤ{GT��.jm��]J���7>���4Ȗ��؇@��S�/��2�@)&>k*� �	qTJ�D�ۣ2�V�_*���ų�؆��!i�o����BE3K?������9H|�c�Uu����̬�h�/>�5N�L=�>R�@H�t\����DM����A���|�����h@=�sfE ٢'�;괝�y񑍊L����$}fۉ�g!~W���Nt@Ǿ؋-
+j�ao����W���1c0�ͱx������އV̵n���V�N<yy�T���{'�r�UF�b'u�������c�R�p(��G8�!��Ǜ��#�&!M�И��8y��W����EDn7r9�K}�w�kQ!���#�L��]�vm��t�%�m/Z�fM�d�ڹE�2��}Tv���j!uP�,��V�>�#���g�,y!���)/ϰ��;�+at���yw�/~���wT�������5�N��쎆o^l-���D%[@�
+�h��Y3�O���3[�Ag+��� �S�<�z��7�5���Jǀ��p���D-A��~B��B�����D���)T,JJ���'�W�{�n���a���$���~�Zn�C3���O\ri]h�?l+�؈I���u>�-��!߾J��U��5�����E"�N��3i�ep�3�v"�>V���+��h�[�ɣ賓�$��<bևI�e����2���w��S�)�$X\*�݊��	�Q�K����K��c��8��ƙ(�d@k]ʯ��*�p���ߟ�A���l|4�v��@O�o���	o&�p���m�{�J�`��>����f�ǭ����@D��ai\� ��#D�۸����ox���k��]}�O��Si�����?�?�wBqȩm��4xt��F��R�lJ{����?��6�)�J��נ�N����}����}�"t5�Į�l��T�/�P��6���v�Xy��8sA:�8+��`���"�<��uc��sew�9��v����֬�Ī�t�2U1G��B��\lE�����u܋��WY7Yt܋��+ dx���x�+�M��Cg���P�,{�+�Ϡ�U����(v7"jL�U���+Ec��G��ӲSW�W�j�f�q6��V#	0���#��ہv1���^j�P�ĄȰN$��@�bo5�н�rL���ט��[��ڎN"/8���ȶ�x�l'�;�9�)s`�L����-�YA�X�J�VH��^�'B�r-�v�e�U�]zi�^���f��	�MS�����)���uY	fc�\� l'�6�={���lE����@��'��&'�h�fI,)��P���}��۷���+8e����Y
+;��)3�1
+��bJ[m�v~x*�i�+L<d�d>�
+m�$~�n�Fk��(6�r�E�l������/�b?����%;y��o��/�O{A1q�-��`0�[��ɯS8t�_��~��a$~#�j�?�BX�O}�n$lA�������.mmC�L���4#+N��"�fA��I�>�8W��,$;�x�9�Y"�dg������z묓�8�\ZJI���'-?�:W_�q$�P��I�d��mw�!�n�J�NAy�|d�G`ц�d�;�NЗ,A��������QC�����Pl�>�x��A����gȑK�}:�|����P�H�wx@i�ȂA)y�+���e����m6䚟x����/(Y
+m�~��g��C�5��&6b����(L��<I�]Q!D��K����@�&!������"#�`S��ȹlz!�}�=��@lo<�È�.�r��L�p+l�%A˹+���#(!8@o�X_!��+���}]@��s;!�Q^+|Vf s�4p�'P�+lCp�l�Cd��(J��yS%J��&�!��\%�I<�,�.2��Q�)��	,)(����~:m������F��/��(Gܴi3�.�+�jp]�/��b�	?��ӫO\|���`$>v�|�z]?/��L-t6�:W�LơH�E�����&!�+$�}��ܖ4 �'(~���U�ȡS�8�(����װ�m�.&!�����Q��4Y˭����w����På#내��[��:d+��B���!W1m����U����i�i�'ݧ�����w���?��M[�ҪCy�� �b�p�uJ.�^	GA�Sy4b
+�sB8��y�ļ�*��(�V�!D��`�O\+J�L��z`��m4
+����!W����O���+��H�1�S�_���J}�\d����B�E
+_��?�&�Z��S�����f�f�	̉����|�+˫���+Zz9.��z���~�:F��IP�I�<�}T�{�ƨ�2L�B[̐�<��Ф��=�D����(�e_��P��G���+��Q����@���U�r��"���:^�q�EA�H6Mu��ne��m+B�:C�_̳�h�3+$��q��5A�H6��6�B-5_���N�b-÷�>��|�Ń(��p�@�3���=�x�~'���9g�`:�r�$^�
+�ƣ��YM9���S�Ez���h�PdH��D���s檰��ۋ�r���r�p���Q�y��|�w�/����t�L�L��F*��@�ڷ�Smқ�����<�L�{�n�F������^m~te�z��A���_/l0e�m)�����ɳoԆ�	�!F��l����2���:m��OO�9��2�f"BI!;bW(�u��Y�p)O����Y�Q�T�gp�% vi�E��2��ό-�!����a��.�b�I	�8y�fr�i��[��׺gkN����#��*�c�6MK|!� q ی|�rѕ?��Ң�4�2V%>�p�vT�O��0+=Nġ���-�)���"�)��V-@n�\/��f��n���Z5��`�h�����8�\?��5"/hT���������M#���N_��Tb�J�}.��$���=zܨ���1�VCw'}\��d��xB�̃�B�:8��+�����@�����sEO�T�+]	���o�e�"�A�%q�5Jc�`D�3�]��ESq�
+	-@߭N�+g4�X�$��{�ԉ�bu�9Z�g�:�����Z$l�'r6�_i�������.�~�?}�Z���_#b��7���j�^J��9�&��>���d�wXⓜ�����5�s��}F�v���!d9��Q�G[1(��3?A�����#;��ED#��^L��F�5���J���rdW��}D E�L�����؜���o.�2�Z�:AR��M�u*�az��:/�o�D��Tq@���P��B�f���� �	ב�}�h�rT��R�k�
+�{�p�=�2+P�rX1aҀ�̧�Mқ�W���9^�%�Ҩ���%�V�����_�zu�~-�c�j��	Zrl��H[�A#4�5�qQ�b�\@�ܔ���!1�/#���l*Z���sw�@��ԟ�U��
+����N�}��0H�()0��\� 9vB��<� 8C`��j@�0����"��mÝ�� �3H�[��z�2	;�(
+C$F�+��"���\�}	��0�H&��p�k�+� 6��wm}#�J%���gժUZIzۚ)S�,J�����&B�"e��38�~��$�M)*G���E]$� �KN7j��
+�W�ч�J�Y|��n���W�����5�]rLu���w��c��t�ywǮj�/_%�ʒ\[�6�#c�|��N�ɑK#�(,?�L���~Zm�}sJ�,����كj���g���Z�h�n�U[���V�@L-���	ڬ�Π/�fC�Bo�M�AD��+Ԗh�x(�Q6�ǫ�z�I�S�G΁�uG�<���E�D��J=��=I==�IT|�i��<ۥ��Ў�F�PͲ���\qj5W���]{�-{���S�����xY�r�N��b��iӋ���Gqdt)�)�Y#�������@.	���!|ĉ_&a5an�`�������3g�,KT;�9zeſ�W��l4���f��j@^�P>�Ԙ�A��2A�Lf�����u^yuMOy�Ê6��[_�T|Eg�%�Us���6�u�P4��"�Fj]u!�2[�#B&M�\�)�:��ڴA�ZQ��痂��}N�*ޯ�,^XM�YP_��ƂZl��XD�`lx��A��]�^�Tv�g�|��1X4�v���ub�s.�8�5�bUS�b EN�޶o����ԡ��Ln��f/Ѿq��j�W�.M����[�V�ּ����܋��ͩ��vf�I�������0(h
+�
+:���K\GtR;F�5���}�Ց��z���ַ�u�r6jc�0��"p�I:�+�7~�N�~m[�N��U	��n���6�$u�x��k{��N;��^|�e}������Iv� �c��k�n	~��K��c�T�*���~��\ɮc�M[�NY�C���n����a���#�!��X�-�QZ+A�~�x�}�}_�n��+�x)|�f��"#+|u���<t����}/g:�\&N�P�׫ʬc8I��{8;����-$cd�bQ�|��5�v ��c�&Tc���V|n,����s�c,+���U��@*�ѩm�~
+ݤ�;Z|�ˋ�V��&4d����̙�Z;j��j�^b"^�����!($A�#��Ѓ /UR�8�OB�9jo5o��{��O��F��D�+M���􊙙�� �u���p��E��Ԍ5���D(?�++����Ez�yk������9�S�'�λ��Գ���Y�m�Z������'M�s�O�֨��(�G�ݼb��+��<q ۍ7�����zJ��gf�f�Gi*!�����RI�}�[��r��IN�Raۡy8�`IL`g��ҒI�6��,f]Bba��)KXԱ>>��T(*�ӦM�,��,
+B!�&hR�'.�	v�J�����Gh�9L�+�N莅(��Ӵc�e����������i�ZhUW�\u�o�뗈��-�@�%ɯ�Ŧo~�_uk�u}]��j��1,��o�c��zh�pct���D�7�!��1�_��5�(�+�48�[F(aQ42p(@[r*� ^TX�f�e`�9uā=�غ�Ř�]��%�q�&t%C��Q���>Z�y��l���ʑRݒŋ�z�nJ��{���N*݂�������#���e�	�}��V��_�E�I�r�A��(��pͨp�~�j���?s}5K��ʪՃ�
+|GݭZ��o���;~o�E~O�,:�1X��s3���i��YT+�+�;Ta����GŃ����+Yț2y�s�D-k�۷GW/�8KdN�1[��
+�\�n�#.��(PT`�-a?��	0�SX�����(�w �w���{]��K�R���y����'w��K���"JD����@'�}5'��e˖}�`^IӴL�d�δ]��%����&�+�J��"fQ��t�Z3��0�>
+�[��5s�Ω�1����85��
+|���I7��Q�?Y��f�R���)r]��Ŋ
+,���Z����t���.3��Z��کEJS�;tX��G�+��T>����EGk����}��Ӱ��^l�v��\�����)�O�}��j�:N�<Ek��mɘj���f�6�r�5.�l)����5�mz��{���$���as]d��n�����2���8�k.�&i�� ��M�,;V6���\5��Ǌ�9�\�����!�3�\{�� �^��Rٕym|���ڵe��q�E�9���K:�]O��k+�z�q�]x���rl��Ty���D�e"/��4�3�� )+HJچ?�l}�ߢءW�v�i��|պ��F�UT'�~��xit���ː�O?�a����������/�g��K��vӘ�߼�D]�s�i�!���2�u��ꪗ�-z��׿�tu
+���Aa��ĳ4�32�Lg��a�nx<�'Qq�<�q�fM��b'6n�6j	��hJw�O�dHdp{g�哟���i�ᭈF�+|�#��&�F���fu���ռ��l1�@����O}�S����>,2e���
+�A�[��CBG����w)���q�c��[��w�}��}��W2=3jr��g�������+<({ˇ0x��;n�ֿW�miSG5#�Y�_X-׌�&���8TF����*68���{��3���c/�>��/Vvu~3�G�AR�M8?+��� ����!�DE��Z�k�2l��C�߶��û��o��Ӣc��.��:�P�/>C�80RW^W_�%�~`�L]��~�����^���ꫯ�;Q��v�/��~���D���p@��=��󯂸{���ƫ�;JcGVD�l���"-H�,r�~`�;<I�S�t;0y�4-ȱI�=�eg��u&[|�q���}�Z|�q��L�l�r�`r�f�1�Pr�.�I3Άg-?����+.妓�Q�nRoi�c�б�
+온����Nת�'h�N�S��١��>35.��	jHÕU��зۄ����3Sqg�~��ʫ�PQ?9W[u��.�vt�~�8Oӹ�8��2o�Wa���l��5�&k��U�]�5��L�W�g]I_���n�m�SB?Ж����?���=�4��#�?��$�+�R�����N+A���o�����s�?�?Ғ<>(���@bd�%^0���++�(S)�t	���)Z��<�:�c�/�s�9���8�3U�3?�+�N���R��[;q��|)�b0 ����*&��gV�/zP3�x;���kٙL��&��9�Nx����~˫^�����6i��X_~X��w�T�qȄ�&�o�8X�OփT��p�>B_?C��8�fO�Z��p�lc@����qf������B��}^-���v=�(���āN�P�鑩?R��#���m���>��:�럍��;Y�� S���b�����E�ِ�ơ�a
+���b�[��f)0R����eK�j͂�e9�R��������{��_��׿Q=���գO<�@��Z��O����F	�0�C��R�'T;u]K�mR���m�}]�~>**f4u/�s@��݈:d�p\�<��in����Gw��QI8;?0=�H�=��#��o7pwriK�c��K9�+?��ӫ),3�J����;��0/&���4;a�'Ѯ?���:�L]���L��-������;4����C�VͧH9	-����;��4��?Smy����Έu�ܞ��v���&}Dn��V���G@*&+'��=�+y?�ӆ��^3�+���i�@J�+Jh���!蔧}�����<�Y��0�8
+i����ˎ���w�z��]m�L�@s��	�֗��Hm�uzg[�΄����e���i����3�W^}�y�+)/]vr��p�_� \i���z���?��_���S���ځIY����/}�Z��%�����(������ ͡�r#/;��8��>��l��ˮPpH#�qrX5e�^���$K��du+��g�C5 $�����Xӵ���*O[R���Jx�f��6WO�_[��F��|�+�+�-	ƪ<LD�ɝw֜YWc5q��o�z���XԄ��m+Pv��, �������΄��`����3�mrpRB��l��2�k��0�[;`�m@dA��~����ްZΖ�^��9L�?񘣽H�^���i\'�
+�4)�ZH��#Z_o��	����~�h�c���')���Ϭ��H�`!��m}���zS�+�P�Ƒ���nnid��Y�q�����C�O�k�@��!��O�{�	�+k%��hƊSN��ꜥO����;+��t�_�G��)+O�~������!v���'m�ٍIWT����������;L.;�ԫo���:�����Q�t���7\�p�t��Q,4������%��o��~��{��+=��{���b�Nȓ��������=��K�H?Δ:�I��cU�v�"���>��s5L��gJ��o�했m=w��Ѐ�!c�@Rz��4Ѹ����F)㋪����"��>����5��#3|M��������i��?Q߿�s�|G��r�kv`�-llۑxĖI=�^z���4��H�-e�{���TL��p��|��z���<�%��MX�7��kQܯ�[���( ?;=�O��7~���+��Sk7�٘g+��G���Бbf
+y��h t��6i0��+=y{�Gn3Xp���^���]�6�e#)R�!c���L�|�q��Ügy�D}s��G��|N��~��=tr~V<��OT�]~Eu�)�V�g����dF�����DJX���?#��8q������v}$�79�}��_���>y׿������3��>�ԍ�G�}l��
+p[�BK>������H�w���Nя�<��(\K���d�$��A�쇣�7����Ǯ����ݾ^}�_~׿^�:3�ז8�2 ������3��}��n7��P�Gy�&=ܾE4L�����ĥ�L�~�	�9+I��ml�B)��7P^G|�J�{�,?��s��@{[��K��{gcWu��
+l����C<0ARGj!B�@J�tDw$�� ���D�R����nAaJ:�J(�&RC���0����v�y�UN��>翵��ֹ�\vMgU���{���u����O�F���bT���wh����IC/Ll[����w�'��nx>����Ξ����|+��jc�V.|N�(L��
+c$�
+e�{<�Qv~�6��
+��2�̥�$u����X!O��sy�����\����e�������n��̄��=&����d�wӦMϟ?ۅ^�9m+I������~&��L=PY�L���%���4�X$����~�>��<�_�Ð��r�_6��&��!���4�ʩ�!�ԣ��
+�l4����7�lYZ*'0�����A9�K�h�Ɇ��[�#�S]������wZa/��2���L�G?3Wr��.*VF�+�8t�%x���{�k���_��}���}�χ��{�oMwy��+Z6�i���2�z<)�exAE����J�ˤ	*=�@s?�x�F�����S�������Z)�ڧ=�Ǿ���9�m۶�^�֕*.�E�{`����
+ګ;.���+���i:$��{�齆G9��؊��ioQnkˉW��*���v*V�6S��`��V�=��~�g�#���X�u�7p�^�q����&�y��W��k_���u���T�����V��M�H�Ld=�h�e�fY������?�}�ƍt��2"�2�F%�2|ᑡ^.�ۆ�w�m2�+I_?��!�r+B�3̓v�Y����^���ģ��vk�i���_(�J�gɿN���.�u�]�w�^I�u'�z��#��K="�����	?F�sݶ+�44!�����c���P_��^��zv n�V!&}I�u^��A^.�/�ښ#<�+
+O�̙K`�1�
+N1�p���S9?(;�@��2-�$f�$B
+)�(y���H��n8����X
+�����m�9I��P�?�����.D��R�5���;���o��y�W~��^�û9eM.����3?,Ӟ������v��|�[�/�F�|A-1�|��s#�<LT`���+@�2|P_$�\uX@KҌ-MZn!�=?W/K������@G�v�.قC�Er�_��%��T�~�����(mT׾9:��zh~[�>"<�s��7���믳�߬`�Wq������>-�G$C�<�!�ޱc��}����y睷_wn��!A��!x�I��K��u��)�����*J�4��P��j�u�A���WaN�R�#�z�ˊ���B�\gQ�e>ؒR�h��/d�~QοǪ���g���g醞9���.;m����%������7�abݒ�{~+��*��V[���1¤��/�M�ܶ����|�����	��h�#�^�%�G�:�J�?��O����%?��ys�A���Iw+��_�]��Fv+���I���)ݢ�bS�TW�-Ж�.92��S���k��_��iJ����y����P͏�����O>��d���+��*܌��|<����������O�6�����#G���$�z��1��� U��t�b��{/��G��+V\{��	�׭[�9.#z���6�D��m����;Z��|����i��^{�?�㯛~��_m��'�2N���|;�G�{oo.�3�<�g^�;{챰#+N˹�Yw�ʟ.gp��W_��+�X���y:y�V+�[+�]�y����U��H���ϕ#����}
+m��ի���yzzq��W�/1O_HZ���<�w81����������Y�!œ�s���=����G�~���+��v�6mڴ[/����A8O�9�f F��<��u�v�,���^�I�P�#�q3H�`٠'n�ஊ�iy9��Ʃ�;q�!��z �yn�X�@�+
++�]�3�_g`ޱ�#��δMҦ�E�J�T����^n����k��T>�f9�^zz����0�q��=�L���j�+鶲�&1m����rPC��y��1�k�m��)z��y��	�����vaO��v�7��H�^zz��@а:�3�3�L���ڭl���	}�j��Â��'<�	�?��#Uu�'n>�c�:���7r�!�7m�tԆ6�[�n�ڵk7�Y��]�'썒�g�ֲ�}��-����_�}�۶msY-�x�[�l�r���{��w�}�w�q�M7�t�u�]w��_~˻����T�'N��ȅ�|P��<zOf�С����V꫞�9�`t ���g`z,���Х;��0<&^&���zԣ����O|�S�z�&�S�>��>��S4���I�xM�GI�P-s�&�%M�L�MMY$��
+�U�ߥ��[t�p�N�t�=�\{��7Y'	�~���k_�����/r���+xɻ���Qj��֭̊�n�{�3�_d����3�=��t�n�E�T�2hn�o�¤��IOz�a�zի��TM�g�����5��ě)�	s�?����Hg�S��j����-�/��>>���/��?��/������_��.�rR���È�D�ҸZ��ʠ)����؇3P��>܅z����~�C/�.Y�L�,_����?�O~�}�G�TM�gi2�0��m�e&�~ho�T���j�W��������K���'����^���_�׽�F�8��	�]��Д�G+��/޼v+�t��^��v@����L2��E�H��@��=����?�5�y�S�U�g�kv����O|�m��9t���B(��xvԟ����[n�僗^z�_��_��(r��N�uU�N�-�>.�neн��3��p�	�z�g��g�����-�n�,�Mz������<餓�����~/�_�ѻ>���|�Coy�[>�5��.r2pOּ��R'�&�)��m��E��g`��@�{u�=�>�~:�n'���j���U�!���p�o��o}���y�QG}��������+� wV�+P���C��g`we F�݅�q���W��S�xU�y������7��=�q߳iӦ�c�D~ ��cۛ�/�_�o��>���|毞���G�� �
+�k�5�Ok�_���)�N}��=��������+�6-;��@M�U�햦�K��Ne����=��v�I�<�x���<���������O��t��Q�p-;\M���OO'�ExS�]վ_S��Z�l۾�E�J-��[ugd�5K�D7J����&1aB�hU�G.U?���mi#7jk�Z�����H\�v��:魗|�ڵ�}��K�{8ʢ�Z���`�ߡ���կ~�~��~���#����f"����K��C���s�>�P��^��v?*��B/��I�������������o޼�����	+'!ڋptV*;k�6�)�T��>�=ZݩY���k�hb�l�U5�*����	��@|r<�ׄ�5�7rAzr��#�l�
+�+�M���O>���������%/yɿJ�9 q��ƨ՜ۆO�d��=��@��6�=�@��M]I*�&}��6n�x�>��ӟ���x��t+.8�;j6�e�X �y�*��8F��˳M�@6���	>2r���	�jP$����?�l�Q'G������N˾��ۘW��������_����-��^��@� }�D�Md�wib\إ�l?�@��M]]/zf�����8�iO{�Oh�"�;SVPwwg�>��]��o�U����׬�l��6$g(̺ҙ�i����}W��h�,���t�t)-JL��J�6�,V�1U=+�����᥇�	o�� �8��8�1��\�g#�+9kh�&�wG�����y'�O9���uJ��z"q���z.�,�ݞ��/?��n��.�%�Ї^s������9�]$���SeJ�¾�X.�������G���ڥ&~^ջ��xǿ;��~���ƕ<Y;`b_W�5Y<̕la����7��8�c$�瑔�Й�*�����<�Ĩ�$l�x4ml��M���ē�1�2/���JL���`�Z8�fO�k�f%��d�P�i��	ܺ�.1�}�e���h��X6����!`!r�d��X��o_ҍ?hx��'8v�	��Z��{�Yw���;��;�I�/: ����u�@���^z�e��7��]�f��|����7?U���	=�wNM��	{�ý�w����3/wh��
+ߗ���Z�'!�ZO�L��cb���L���Ĥ�WY�t���ú&�]k���ᾞ H}9�/'1l�%N�d���<�%�Љm5�ґ�b�V��{:�]�3�g��F��s�ę5h�M-J�Q}`_�/=痳 ��ݖ��9KK�u�p��~��!��=S9��\��������=�y�^�O	�V-�}}�9KY�����g�x���} �_�5��_�;ꕯ|����=��C��ˢrg�+:�p>��ߨ��o�U�]�=�Mq&&����3��JV�H�Iʏ�����k&�B�I\�,DX����K{Y[��a�vS�%�~�s;[)�ɩ�G\&����{���crԳ�@�L�XZ�c����S4���	~�#�Ρ��:��]:
+�
+�ԏ�݁G�݁�a�8�t��Z�}�j�<��w��^�����G�>'�[��+��Hts�E"�������(���`4���S��w^7?���=�����^v�'���qN��eހW�V�҅E��c���w�ަ����W��ҫI3&fq�O��4���Ә�BW�^���zN2j�>��n�2�L϶i�@���eo��>��O�Z�$@��I5��IA�Y.=+�W�=��-�(��Ƨ��S���g�F�`�ªnճ���
+
+���;+Z<p�G�԰a4�$a�(e�oP㘵ۖN��ݚ�L�7���}#虘V���AM��i{��7]~�����;��$�
+�{�k3T��R�hE��^����+�Xc/R>���:AX,�1���f�@��"�"�~��>p��)�W�9�"��N��s�z����G�#���i�����j����P�E�S�i{��N���җ���n��.��d����B�m-��m����<$���.����m]�v҇��R���у~��nݺG��Gʼ�x�p�����g��j��)s��0��cL�B�0X��4�¤�A�z�~1| �?�s�����d<9�E?/��9���89���h~H�9�!��HC6����
+�������PE�A{�����e�$脞��O�p �O$�U�F@�=�s���?"���=�Ģf�� �m߸l��&���;a�7��j��}1�I��by�������>*E~��;�	+!��oM5b:L�"}�>��`�?��$@�8�k�)s�X���2��Ex�礅���&�蕱DJ%���+s��~�@f�*��>u����b�5����Տ����o��SP��%Bdf���J괖I/�[��ͬ�-e�Tr�b�w��.]�,��؏�ؙzw������&�C��j��Zz*1��)��{��%���>����[����������c���0}��FWC�����B��Q%���\�=q`SF�C��O�O�^���;� ���Q����c̔�hAϖ0B�R�h�8��Pވaĉ�7J"k~e:�g�?h����-�N�o
+!�
+-��/��흣ֲ�׸�8�W?�7��|1��Q�����#p���c'Ҋ��D�:�M<7i_�^r�*��S�xpf�%[��_�;�_�ds���9��/�����+���|p��!M�;�K^�Dܛ�C�������nW�喺�?D��w��������K��)d>Ԕ]=���Ǔ�_�H�5���:�Q�@��̔�ԕ0b:��c]��[��tD0M����c{�B*�T���@{����IM�â��o�C�r��F�;p���v$��
+O-u�!�`.>	I�YZ��������:ɀ*9T��5�*/q:h�I����\�J�p��KbvJ���mEH���A7d1Yc���" m���D�L�G8\Rs}��J�H�hH/�J�7J��P��ߡw��������A�܍k-+�@^�����}8��>��	��������������O>�E�6�T5~����tɗ��S:UO��c�������&��4�3��4c4
+S�X� ^#U�)[YL�!��,#���b"ń:cԴeT������>q��o+EoK��@�'e�6�xR��N���c}��_�DlD�S�=Q
+k���s,�m�$�=B�:M��C|��d�eW�l�Uj�KMY����n{�^���_���x�p{PnkñR���>���;����kt��ٮ�0JCS�m~ozӛ����=�7����ۡ����M���0rՖ5zq�X�[c��a2���`��801�i��,��Y�6�l*��K��<|3��j\��+�үl6�D`i�o�h�S��&��޼�֭[������^���:�i��ƕN��.V��},���������^na�g9���?�#��?��!�-�g�+��ej}5��Ol��7s�%�-���hW�YQx��4|%>?x#z8�p��K%��� �}�"�NĜ�P��@ceC7�D0y�;|�vd��k�w�N�Hw8`�T����#��F}����ez��B�r������:/�@�h{�FYRm�����q��6��}���.���Bчhy�
+��4�_�I��$"d+zp.�|�YA���J�ɰ�}�P�iēh�f��ٵ�iD<.3��A�;�Lu�?�b?�D���U�}�\+Mh�Ϻ�E4���$o��BB���V��ێp��ʴV��J��ȑ��i�1��j��
+��6��y��Ό@�,�TqEl�0�َ��\ا]��^}�E�,I>��	�ၯ�k�F�a ������.�6����@����h�Z�E��������8;{_h����-5�S�����3�_8��c�;��4H1��@a +ԋ.�E����rxs�Ń-�?b@���̱d�%�q]���j�pO���إ��~����,L���aO�X��+��[,�����A�b_���Օ����D�cB�0`P��r��@��Al��h*?Շ�[�ͬ�$�"�qB�s0��E�)fvK4X��(d>i�|$����G��B�8�K�|�]�42f*�fe�,r.��;��~��nЋDo߾U8����	A|d o%A�>�/�<���^'�i:	x���l�+u�L��O�C���?��n�W	�{y�W�*Ỵ�B�z���l����e`���E��P��a�z����6=F��}�_��_�V������%ρ0D���t�[]J�k鐎�;�}�K}���=�y���-]������  �h�n�1�Z(�����/6Jy�f��!5��LIC0�؇j�aʽ��@�Ii�C��k 7P*9�a��ã�����n�_�������&�(�'�$z�;�)�\g���2��8!A^��*�S=����ɶC��X���Į��k��1�i�i5`�r�vg�poP��7(eO\��;�B����!�S�����mV�1�`ݰ�o�P#�jK�O�f��t�&{�����t)+�~��O��k?�~ +^�r�!Ox�K_��{���E�w ^T�Ë��a�@�P��������Vڼs丷��-���o�����>�V{n��u�/7 �V�kz?������P���L��f,5mdT1R�b�Zu�M�5X`���gp��Y������&fᖯ�N<Ǜ�U��;�����C]����I>EQ�E�;��#��J�!��T[�HB�CG��Wɍ��فЄ��sAND��Dl��XGRN�J�8
+;�8���F��r�������O�)����۩c�}:�tX#�Jt�5_x�g�)��Gt���5A2p�+-$�@[K��1q��VS����ȿ�tVt�v�3��������!��펗��rx�\�'p�^���u��rx���]�t���{��20�{Y\=��@m���f�I�N+C���W��k�r[�0EB������N��!���d�F�U���e�F�]	]��嬶JvՎ:KVG��8R	2�oӌ�|���`Lf���B�}�ׁ�i��S�7,Ї�d�T�t�H��X�x�A��L��l	�F���,�Q�;�+�9�N�fe��@W��ux��+ӯ
+§8��@`��6��7��"+Z�̓���ś+�N��Сi�Ǜ����@�({8�;ஶ	�ta��G���	�|�;���[�Ӳ��Mz��s�]��|j����Ū���n�W�DD���\��-0�[w9>ZoF�1��J�X��?�Ive�RNƴB�n�T���U>�+q�f1@2ao|�sek��}	���.u�Us�3fڌ��05�
+mӥ\�;�S�7�M�"���f]M������8��������֧i_H�y��?�AO
+�����721��n���fa�ϊW¢�Աg:H���#ܡ�7�#�?��NU��;&lO��Gx��+���3�l��$��)w������.��r����w�+�%"���^���^���=j�M�a^54��=�K.�^}&�
+�{|�)��ܫ��u8q\e��+�:��ΰPZ:8}��e�����?����y�j�M�v�	�]v�O�p�	/V{na@����k���F�z��W�P�Z��g�4\-!{䍁̓�x��viMF#?ԫ��א;��&�k�Lk@��Fq��2ǩ�ʲF(��K7Σ���(�(#V����g�+8�%c�Xç�]����w�� }��0Cw�OX�����w;�CF"Fz"&:P��-v���Z����%�#�1J��PW,U׶�z�~˃����O|1cc���(���Ƭv��U�z
+��{(�!�=��eܴt,�m�f=|s����'z+F��9�t;ps^����}d\-[��rL��l��bDQ��{�%����8�=�Siڃ�%�G\�J����v�K�j�W�m@$��="��3��ewp>L��w]�E��T^1W�iӦӾ�����]s�5�����4��O�ai˴��:��3�O+�p��1�٤ѕI�A�@�H�v�o�|�^�@P*��VOy8�Ffl��.���+}ϸ̏�Ǿ��w����y��ھt�\M�7ž��y�d�Y�|�c{�y��?�n�&HrXh��eu/{ �������y�.5�S3���я~�{�>��_��o���u�_~�AK��^3�p�rp{�f0`P��Ճ�4��Ҥl�������	''A+,�W$��d��A�(��9��#���."b�1T7Ŝ[��=�X7��Z��b4ɪ+Ur��_���Fؓ"���X{�����#ΚV���8��A;J��6l�o
+�ĵ:��}�S���s�9��rs��zW@?	؍y_�w��t݇���5u�0�Ѧf��I:p�_����{�ܦ��]�ɟ��T�8&�x԰��E�`�hݢ�0���Jf��L��N^�'��rM̳wXxθr����K&S��1mk"1�W�q��h�4`�����.qp��*�+�r��xEX�-��f�+����=C�S��g�G���:>YH�j��^� O~����D��د��S�
+�NV�q
+�Ր؊皶�C+���?�A�H?T3?�#<�Y;:F�p�ִo�0�/~i�5�����RO���w%�r]+��^��!��my�&r�V���'se�����?�Y���N��K��O�����V¬|�đx�f�_~B�#���z.��x��
+���}K��DMY$�R����+_�w��X�	���B�UC�"�4u/�)���&�K*����xO��e��?�����)����'�n+��g{�ʃ~:�<�@0�x�σ�gB�Q񈞂]NP1�#��gV�`Y�� ���q���#E���r�:>�\~�
+��T�G�J+N��c뤾c��y,Tq�*��x(z�o7�0W��X��#�\��*�=U�}�׾�3��C��$@��'����&�ZDfg�z���=h��v��@嗺]a�e��I������>Xu�RS(�G���[M�����^ ��'@���kd��DCOv��c�l������U�N�c�#Ҝ�l3Z7N"�+?M�����l)���V�ۖiy�6�e���9W'�*�����^�Q-�;�������b�'΀+>� �-��!U��,�/[�������)����ӎ`�}*=����q������
+�U�?mئ_�8Z좩)�Y<�E/'G�-��կ~�:	��-[��q@{'�=��(�E�!r�^vab��B�5d�rK�.��Q/�9I���ұ����Y�+��i��M7���3�<����.N�;�$�M��ǽd8;�\T^�ۥ���7w�q�~�ӟ��#�<����,:��`k����~���z����Ee����J퀓r��[��[����%���5`����1�3��jl�ً��aʭ(y����h��%�F`���([�A?���m�w�ez�+K@�3��[�,��{��|!��MM61�'':���7&���1&���"&U26�	�z(b�az�%�q�e�m���$�*Y�����42~�
+n�Fܯ*b�C	���N��6D8d�G�.5�o��;
+u���U2���U�-���@�>�����`#�ҳzB�!�AV����ɾ�y(�G陀G�˓.�(�_6mV%s��������=�IO�?n���/ɼ�4�ݓ�w�=��+���S�ʲ:v�/����X㕏�콂�V��c�1���]:f���'m$\e��W��3x��rxm��2h�o�喿=������|Y��q�4I{�[w8:@\T>�ۅ#�]���UW]���s�����Zt+��u������d�͝�c�M|��rb��.��>Z>a`ES��J&|���\�H]#�&����LN������I��Fn���9g�>��?L��!��%�r���6��(����K���~�F%Ut���TlO��/N+{hQ�d�"���=�aR�uim|Fq:%&1����A��6���A���W�����a{�g2b�1�K"����p�^��D�c �)�^1�G@���1�`�K$T<O�Z��P5�	�ra���[���s2�����?F0��Zy['��&�Y��Fk/�%K���N�6D��v|��p���҅����+G0"e^��b���йt<��U�8m�I��蹀C��W��]E?'�}����ϝ+E�G��&��&현Q�(U�t��v��³?�p�j8!t��a�D�H��p�u���o��'0,f�t�a�C��z`�1���E�;O@	�Bl?7n5�(g6��J��y�������,�2��J	�����+EY9`�J�emSX�jT5P��.�O�Y�i�~���^�؃�䆉]��I!�̊<AOq''X-/Bþrd���������ZY೎��]�u��"�C��ʷ-��>�qse�{b^@�&l16/q�O�Z�J���]���?&��9�Z��F`*&T��Ɔ�m�*9�b����Ψ�ë]����ᘏ�F�Ɩ�a�;�$�U��'WYI�/�)Nc%�H��R�v���#Ӧ�_��=Aj��/+�%56>⤎X�t��Y�T��]cƚ�O魠�!{�0&26���Z+9h�1�RS��,T/)92>$�n4SV=�q١O�袋��7�1pP�vc�*�����E����3�xcY�3th`��±�O�*5��@W݉!�Z��QEÌ3�Y2��9�(Xp�B�@�6V��)�7��3��ٓ��=�Z�-�B"�L	���JUWj����*l�W���T�sYG�ox�߁�Jclɓ�Qje�a�6Ns�ψ(1�'0���Ƕ�/�o����V�Q�N�����k "�uX\c�Y>D�q���x�e�D�w�@��ur����!C�bh���/�" k��8��n(cSx�Զ�g��1�tPtD�+�؞�6�L [�6y����.��{;�҃���ҟXÏ;t!E�������3Fܹ��J�a	�(�	v��1�&�
+m�%Ɛ/�-��_��@�:aW�Jw%{=�#�X�����]'�'+q��P�a��BFLD��o��V�'�3LR�pN��b�O��������5�Ķ���Ylf`�bXQ26/�Tn��������2?�O��<��,�	n�]�F�q˪��Oc�~��v+	H?��Xn��"kH`I;m1�-��/y����u͋U،`��.�X����?�~٨�2{g�Ɖ��P�.Y+�2��=�1�]�@�v�!�P�~j7�OI������훵N��p(�v�V5�kc�8�i�~�Oܙ�#�v�k��}��
+G:j�!�h�9�WGT;�����+�@�5�M��A�8���}��UN��s]�&��+��Qذ�OVt�5�x[�j�mP+���'M�7����'���v��ߢԞ�;���G�b�z��<��7>�iO{���]v�ewH�w,*˅���d��f�\Q�R�M��l��^����?ݴiӓv~���1����k~���������l8�}+��G�)��R�\��毂���M�]_dB���.��O]U.�=�g[b](��ڞ�vx؞�ibđ���pɓ��ց��1�8Nh��?}`�o���r6$߿˓�bȭ�Qd���	��tŗ}��x�d{4�lH�0�����<������ںt�N ���}A���{｟>��~H��r��q+\)f�ɏH|�C2��hT�p=0�7�G�1`�����D|�?C|jLr``7VL�L�T,暀���F_��_0�CqH��Mz�8��'6CѶ|"�O(8֨�[�5N�	6c]�U�'�0��n
+[?�6�P�Q���v�I<��Uy���t;V�\[�ۚy`�9���zd����\���x�҈�dɎ_ 
+�:9�������>�6�a�t2��נ)��#:ވ�r�+vL�'z�dۘ�r�#�:ג�?l�]w |�`X�2�Wa�H9_Z:\�߰i�_�˯o���>�1������iq'�=	 !��]�t���e2�����.�B�.�]88�K.�)&�:��[�H;�jmZS&�Oh�K�Dp-�����48�#x���Z�<�[d5D���"��,4"Fa"��Pz��f8���B�]�G�e>�2��Qz�"�(�3��=��YQ�=K�� /(YZ�d���{������Y.M��~`��\����uDby���B��H��>�B?�l��&�>~Y�3,SC0�UM���P�G�Il�G��K����3���"fPv;>@T�)�SM�O�\Lyf�:�26'Sja���L�4���DN2'L�ď��>Y?0@��@��sDE��(w��X+�ӭa[�`�2[�KktS|��X��:Ь��c��U��^��Vl7���,\sB���g�%?��{bLc��́��Э�J�Ԟ1��/~�lx[ cm;�Bg�C-V�����^g`�s�W;!;���ǿ���N�/�q�T��f�YMw�:Ш[��:�>��tޭ�	n8�Ep�>���f���`z8�c��S�1`�W1�eWMt_mPr�p�E�=^�� ��&d	Y|��^��F�ɻ�����'����g��ô3ū���'�1�n`���]�+��^K���+.�֤YZQ�++5�n7����s�cl�kL�1�>�D�?\i��.%rzP�dNh"���!��Q���ܦ��P���
+��52�UG
+��5�f��S�����g���"G���6 {� I��E�5v��60��ؘ�!L�a�M�B�V؈1	��͕V���a�Ghl�!Pp�~� o'aڇd��=D�\M\�l_�{�:�:X'ޡ$S�����C�൷��6�_c�)���X����=	�s�q#y��������^��@�#]u�p�ǽ��o��}��E?��k�v�:pЧp^���ʟ�%+�>x��Ղ~OtC�c·ˑ�A,��I@P�EM�M�S35`YY)3�g���`P�$yԬ1��k�W���v��%�CF��aJ	i`9�g�ҍ�@��y��@e��Xx��=H���,]���TA�ٕ��new��,en#Z��v�+(�b-���"���a�}�Hp�K��1:%����u�Lc�����S�Gt1Y�\N�����}`Ё�NC�]�5t8�����3su�ƃO޿��ÜX��R}*~Վ�\�?єa�p+V����j���1j��˜p����^8�D���B�����������Do�2�y;p	=84;|���AR��ğԏ�ܪ��g$�G'lO`KȒ�쉿�g^����jQ�b��X�b2�I�̮;+���a����kۃC	ϸ�/�i�Z�gv['?���2�$�c(Ī%,�iQ����mL�=�;�ڥxC-"|F��.^�v�{i|EڊPs���v؆���X��0�-����e�_��p���"G�R���$>����ab"B�b=�b	~�Yhl�JF��q�|\E��l��e�a��$}�����B 2������7��+�ŗGj9�Q�P����>��j��	#�v��H��ȑ�p�_���2vM�2�N_���A��Mr�_�l\���1	w��X�t���KO�o
+{|��Rtē؊-rZ�c�H˖-W=������������w=��Á��m�ZD���%3[����@儺]j�$��a}ݵ�^�ۛ7o���wi��%z��F��q+��RzH�%�+/�L��n��IM�i��gϞ?������k;��{���<��׊'(���8V�]������|�3o�T�e��2��Y�[����%?��)L��2M�̋Ls3� �d�	�
+ü��|�cè�3��[�l��K]������[��.mp�2�����l����*^V�K���C�d�<��k�j!��X����:�j�c��r��@�K�"�Q��6)r�čۖ�e����:h#n�#��+|�Ͳ�Q[���,�J��ص�U}��U��ji��
+ڠ9��F�#�eb19I��4�JO����Y%c�CZڔ���r�;Ռ�x<c��``H�3�e�&VZ�Bâcy9��I�T��ؑ'zY���؉.�b���i`�#g8~y߀-�	U���@�W�Ť�,5������1Ck{�t�rp�����
+��붉�emJM��[w�Ν?z��W���M���3}{����^Yf�;��9=`�,�~�O}�{��޿����/9UO~�Q����Gu�,�X}�t�1&)�SU}\����M��K�,��S��B�f��%g�Ɖ��l���+�v��ʚ��@j�6J-F�,$Wڕw��Vݱ!��<	p/~3C^�wn:?UG^b^p#���"F��F#|�C����H�	w����z�~������N+F�R��;e��Zƾ�����>��74�RƑk�|�1����3��`���CE�6<>Ӳ>!��Z4��A��@I�i���Z0N��E�qm�+��_�c_0������WR|���>rAd�,�A���-!��Ґ�,��!m�n��m��6���V��ht��(�NЖ'+J��x-�������œ��*k��V[�Gc�[×\��:�#*�d;�����a�qn �E���_k�Э�	��Q3/Na����{E�z��YB��L`W�jq��1`���c���X�9n6Զ���;,�}����!�?);������<��+���ͷ�z�-2��+�晇��-�����]i��۔�����1���Q�RG�=%LZ� ���5 !)��5�F�-ѽ*ⶋw�U����E�X��X�Y+C,�V��������}o��Xѩ��C��fN-��QF鲇��|F.�ogAd���#VS�ZQ��z�7�UP��i9Y��+��z^��&�giD�oq��k��`����m\���o�΋}i��&�e���*���3��A�+��S�yY�8�-,��uQ�T�&=m�A�W�vh��:���{`��麛�2�|ǝ�}{��������<�����Ν���X��t�Vr^ ��Q�.А���0�n𺽶A���l���L�6g��)C�)�:��I�}�[���*�Œ
+~��{N�Ča�Fb9a{֥E�$Bk��>�Sb�s/� U�i_El8��ذU6g��8���\�$Fs5	�}!�Z�방Z��+x�+-��&J��w���FD��M��>�u��g|ڛA~�zN��u�L+q�b���e��1�+�Xᄫ�Ĵ�ь{D�+h���d1��{��vD��+�l�G� Z�J,��ز�E���ڼ��)��|�p���F����P�yjE;�@R��H��jHp(�aHY�{��Ńm@�cc�����C�����G�Za�a��q�u8���V���"1��/l�vi��4�� ���xX�k����������K�r�9�k7Ԡ饀��Z�M��c�AkC˶��������p� �,7��������������k r�:JL��z-�����ߣYڣ-�H�:�fA�i8��'!3-�jz�{����Ԧ��D:�آ��B/^E&d���bۍ^&u"b�qWe��J��z�M��z���X	�A	N�Qn<Ǽ����E���d98*n��$�b+���f����M�,�*����ٿY�ݍ��>�ش�)Z��˲�z�ȡÏN�|���~Îc��K��656Z��d�������@���[���t��;m:��v�e3iC'�<a2i>��J�~�<U�˻�{BOv�f5�O��l�!�G������}4?'tc�w��Zܟ3��;>Vi�	U��F���m�6b�y��Nt���%�/RhX�f=k�k�<!�&]�(�C�/���E%���kH�fc��B�u�b�n8��15[%7�J�;w֍M�����{��s����q+�E�>چ���/�XO>�o�O]�*�R������Ey���I�˭/+ƶ<$P�d�?��E�u
+��4۵��䟥}t�_:�{Ƙ�$	>��Z�Ѱ�=]ya{F3�yB�~K��Ц������m�g�4\�Wb�_�Fa�ٷo��5��ʶW��E�&�jS���aY�k�[�jګ�>.ۻ�7m"y�b �V۸�TDBW�*A�<Aq�#�� �,n���Xe[\#�vsD96=OZ�;�n���d���l�/'�+ƬJ�xj�D�mDK�M�w-ر�������Y��Y����A�ŇE��/�E��1qH�>�⳨��d��{�&+~u�Es�k��Z>t��"���,�O��3��B�W��s����OLw�}����X���,�g�s��+��~��?8��_6���/�.����SO�U����=Bc/�+����.�p: F�@+ǱC�1X�(
+�r���R'��p�۶����_��QzLF�3������v��-_x��#�@�+k<k��Oӆ6\욶]VMY�C9��}��>p}@�ux�-�|�+�{ի^�Ͽ��ToԻ�1�|���S.3.ٓ�N4�B���ڽ"!�-OR$t��H�-q��q�Ն��;���e��D�QN�֗�$����O���HG�Ɍ
+�}���U�֧k�q���J��k�eՒ<6	��}�Ӽ�0/��~?�%{����"��1!��v.�s��v��+F�䒢QC�]5�d�p�f�@�������Q�6~*��y��HzAs�J�
+k^���_</�+z�H�b!<�#�>���'��r٥�M����ظ�8�`h��2�M���z�Z���x]��EL1�LH+>@�_�?n#!e�u�n�=��l��^)!�8����;D�8�F�[��%d���LQr*����v"Nò}_�)N�3|*�X���}������J������<�e�E�4ڬ������v�sƖ��=���h>�cY`y+kY28�0~!c��!���H�>�i���A.zj^�9�8��_����mƱǾsdG�P/X���������m"ڻ��g[m-�5��٧��F���W�	�9f>��wD������;��SM�xNHG��<�ި�T]l�?b�S��,y+��w,q~�R���+�3����-����,�u�e���D��(�p��,9�W��c����*�QM��1�-a7��w���Sq�n��ܭm�g�H�����*_rA)�Ԋ�e�Jy?�q���M[�����/�DL���S]��e�)�|�{����b��8������r2�Rr_lL@p+��������k�4DkS�W�c:Y����������ST�6h��ua�k������>�8Q%@�S�$ _�a2�h&(�|�6�i������N
+.�����Y�`Qw��M;o�1,~^���qA���
+j.8+i�Xc�x�Յ\��]"K?�#-d)�R�k�?;�q2D�эj#����� �9�+&�=�j7t�g	�iB�d��ˡ�@"�u��
+k���$rDY]�hڪ0��	���s$�h��.�B��S9�A#��6lݺ�4���-�i�=����gW�^5�t͕.�4���հO6�0-.^[���X�B?�ߙ(�.hȨḮ��l��HC����
+<�<��h߃��s�
+�w;�TWӾ�A\ꀈ�(`�6j�B���u��a}�Њ.����w.D�ج�_����b�>8נ��ھ�#5�K��]��g_��[�cEm�װ@��Z#U9�E,:-?��&?� �����x,�9�e����kw��>����i�N�>��BnU�v�٢��S'�����,w�n�Hq���;������>�ן>�:|.*����d�aK�c����n�!��K��e?ё��9��߻hmĠbp���w[;�K��Dr�H��h)�Y5j�f���,�:���Q��J5�0����u�pW�p�.㟦���;�T��]�Sh�"$�s5'pa%����;���a87��%�2��W}�K֊�tޏ�1�~t�/⓳�J��Ǩ��C�ᆇ�G2�V��w�㜠s�3�3�Q�n"� ��r�������|�?�iӦK��@��a~��'N��ƏL�L��2ϪИ������I��C4|&�'��B�����A<%_�i=iU��Q��v�r��ŉf.D:.�i�ĴK�]��B���5�D�3��g���ϴ�N8����|��;=+f��4m�7:���+���p"��^���ߺi�����_�Xeí�]�#�C�O��?~j��|x:�p�����$làJǞ�ĊO��l���;�����&>�e����ed��<�آWX���8�]++��k�����&�\��=LXj��:mC���7�!-��kcnh��^���ή��N��E�H2YF������vԕ��Ǿ�����%~�Ņ:h���ۆ�nb"K�Y��_!����u�WuU�Z�Zz�g,E�i�v����7o����OI��+4���&>i/<�ǵD#��y��"�z�����{V|��s�ai�NGe���j�s����y��W��T����b�}�:f�1���ˍ�'��.���������_�ܓKf^<$�M
+z��X�?�����G���@�՞��� /w��t��$�ؼ)�y�b��45��X�`�Jٴ�@nl��hY�#&�9K�4����'�`�\C�Z��'�}(/>�H�,�YY����/$�|�i�hy��3m�R�
+|k �����k�8ZQH<M�lu�۹�c�p0&L�%C�Բ�?Ӵ�v��E�%eU��x��vZ=J��M��c�>w��&��	eh���t�gNW\v�t�y�N��t���߷��Fw�w|�G�kl�'I��\1�����������W���~l�ǘs/dr��l��yC�|]i�,(��TS���1�ο/.
+��u�F]T�eM/31v0�"�<MrG}�D���?n�/�A��걩>��AJ��C��cBq��j/���?I��EĹ*�f�w�Rq����=v����"��v��$����?���B}�L6�U�;W�̙�o�=6���U��o9�l���Q4�={���]����[�a�7\�����^�{�3V�B{�1z����/�?�˲݃��ֿM�S}�>�jG�uu�<�3=;y����IäfL�/�H2m}w.C5}ds^b��A�\숆s��m�i�հ�,d���!�K_B��]E٠����Q<��f#ix�V��J�^ę���(�5U��y���\�45�=f0#�<qB�/G�PV�>�X�,���'��R�,�͞:o���s��[�'���'K ��9������cVQM/{�K�n����|OZiй�]$�w~�nomu��K6D�n@��]�gZ�s�j������#/�"����/zR��$VץXٓ=��U�h,@��.�ql�Lg���ü���pd-��9F����)[��s��p��M:ֳÓW�d���u%!�Fw�_V��6:"�&=��F���1(!���B
+]��	2���'+�
+���+��S��Q_l86��6���I��ΏÏW��D�}�'�e��w��ݿ�wy�]S��z9X�`=��Z���t���{R��1G=Q�J��>�~��I��ѭLȌ��G(�Y.�;4\�LY�1�]���XOɤ�+��.'R����5F�ば*o��bէY��z�~�]�5>�H4B��E/���@,t�|9��2����	�������?�o+��z�q�9g��U�J��R�/��7�~�F8V�Y{r97�͉�z�/Fp��\І����>��x%!z�	80�x��%�E�y�jt��'�Ɖ�����f�'K���|��>���\I�x�^�����4��"��a����Jo���ܱ��c5���2�Q�|����k�?�G��R?I;�N�ٿ����1��)���'���0���r1��S/O��w�����+_����Oj�N?L�ޅ��+��˶�N[�/�v�t�. N�/2F��yX��YV;j��8בc�Xs�R�!(ݐ<E����t�k;«:ɀY�F͌�%��
+�:cl��	N?�K�Q%�؊R��n�s1�b���c�n��R-x�ֽ�+�~J�|�/'f����&Ǖ�͛��$)Axm���y��ia�3�VE=<ǣ�JH�5n��g#j���Ǵ�S��|��Ѧ�����}�C�Н2x��=���F�:N�vL�9��U|�U�65+��W<�v��o:��Z�[�w��Q��k��z��g�}��տYW���+�Ac�0�����|�|�y�dJz���b���x�VFb���D���~����)�0&L�1`#Jua:����g%c�D�jZ��Ҳ�:�膺h����R蔌�����/�X��H�D��n�K��@O\}A�Rʑ�t,E��&<�
+�6�Ǿ�+[�����\�/$[��MQ�l�2]��K���"����G|ĀǆDG���n�?K7�Ͼ�����k��O>Y�ܹ����']�<��O<�w�[~��J|h_"��7x�K�;mڰqڤG4UXYS��I��:�9�׎��E�q~C�X�G�]P�!*��,'��˜��k�Slb�6f��ΑM�ɘ��� ����/�2zN�c�b��w�1*��r`7ϊha[�%G[Hȏ������
+�p�5�K.�$��s��+A�`�>QKI�mA&'Y�8(�?�T�D�K�_������n�������Vf?�pd�<w�z���K/��}����+/��5r>���0�6y�����DU�j-v݋'V1�䥟�Ͱ�X^�m,�C�t�^��8������9+�(E�_�S���+875�u���E����˻z�ki�Sض�Ā]@�cQ!6��&K�kj+����t�S�/�f��${� ���*?����7X���9�c��Q�n�����F�����Q�)�py��&�ԕ|ٖ�����[��ݼe��K.�;�/�(r�X������49��1���Kߒu!�NJ�}�"�����A����v�u�������4M���.8���d���v}�p7߼��qR�o��Y��,���=��/z���?�K?m���4����������ǂ��;�!�8t׹ұ3�e����[�2��Xx��u�*��&Ϭ����:}�����W�D �L؎]�4#��yW�>�g�Q�sR1�f9Tw�R�7���?ց�S�Ce�濟��~�.1ٸ���vj�k���f8 ���~��"��y=D�cd�`8΢IiZzk�z9�9�[���7�#��`�v���\�4h����g�S���c�����>�կ~�ϡ��zنw���z�F�&=�g����h�`�FcB�B\\�0kb[��*�8��?�.�Oߌtb����"�����B���ݶ�c[�A߶��M1�/�U���*��ؖ����%Z�Fb�G���6-�j�	�Mpݞ86�r��IV"o��1-���}��G�:�.?A��k#���>>�_S�Q��"��5���x����p���68Σ��3�8�/(�2r#_��b���!J�aO3��$�r�K��׸
+%������3δ����M�fۯo��?��{�4̶Y@Iu��Q�޲S�q��`Ǿ������p�P��R��9	wٞ���<�����n_��)]�r!�\�~��b�jjȇ����EM��>|�8�&#v.���9T��p�@؞|W�g�n[�����Lg�L��'�����J���2_�+K�_�#Bh�m��-��sAH��˚M1W�ģ�r��f�����r���cm����S��/<7z��:�G$���I����z�+^����V�<�u��߬�q�Z#ѣ��1�౛������0�K-�l	���y|#�	�R�Z�ݕ��+�_r +ݏm�Ee��逸�q_i��4��`s�LhB�ņ��k�/Yc��e��m���5?�c�n+�P���S�ᛰZ_)��m��E��Q�Y$�5+���I��,�,[��F�cY[u�X�#e��M�h�2���M�%�s��������Y|*J�
+Q�4V*w,a���`��|���SSD��bI�Ƀ�W�ɏ�y��<vҏ��zY�3���+1�O�?��3�{v�;�ޝ/+;���/�{�CG'n�2�{��Z�uan�J4�}J�j�b���H,�+�J��$����j�b8
+:�S�8>���>N�&�U�\c�� g�W��C�rr80G~ැc�h�V��+��v�<���;σ�	�	0�9G�"ERjK�[j�A�-���ø�.�����n��6O���eσ��e%S�TjI�D1�Y �L$�����u��.A��(+'��R��bUs�o�>�� �q�WL�o��K�X�G��\p�^=x������9+9r\�43�%.�	��O[�g�۾X	��A��b�j�_��,(�̸� 9��U:���#l����}8��8@��P��8(�X8�g6[nY����Gp�=�Rh�W�A���4������'���PK�m+="7����i���ͩ�����s^��o���<�G���������n���������?��N�ܴ�|�	�=:��R�B�	`
+�i�QJB�V�5++���G���B�=1�ck��g�n	�t�	Ýw�m��\d4��������sO?M��]z7+.�O���&���P[z��e@@G�/¢��g�~2<���,��roR#a�o>+L4+/m#V��7�j�]�X����,����9P��%�U*���&K�3(���`�P��D����6���Zv19��
+�y��U$��Lg�����dD�n��v�2>5O�5=���u�c�DC\�M�5���������=��0��M?�٥cw�Y9�i@�ml_�7�7���ǁ��0��ў/��~p_.�A�e�3ۚ������t\�������E�S;kq��S�I��Gj8�7�j#[���ZÁ-m�e��x�31#3;�LÊ�ư�}��m.M��Q�)��m��{5-}��GM��j��(�h,O�����͋���ώ�W�RF���E3\Uz���"\!S�)�gڇ���өW{ߠ[��f2k�C3��Gj}N�i��~ӘA�"�zQm�}���Lz��	y�A%��vL��D��W_��a���LI�7m��`����o��+�w�Q`y���7�#le�����e#d�?2f1�ي�9��/f�!!�d�ʖ�bh���	^x�K���(�A4+6�d���mE�s3�̀!���ޜ}�PF0�����͒)A�@MjB���t'##?;"��Cʸ7?Z��Ȏ�����>rPl�j��h�l�}'�t�_QS��ǜUO�o����{����+�8!Uߓ�0������e:L��QJ��3}@[v�m�'��B;=h�RH�ɿAȇ&�/�)��ً{-CJm�b?���n1"Zׂ��l�	߲��+@�ֽ������F,�.�Z��a�'8Ö��A���V��F��dJ����Wv7�v��X�Z]������VȞ��|�6	�i���/����~�O��eY�!@`�&_������O8���ԑX��/X������1G/�!.���Z�d?�0��N�P.���H$��X��q�Zj�PIF�ϡѸ�W1�#�T����hZ��饍n�x�����2.�t�S��X9t�%�m��o&�Ac�ԟVz��5��˲�q ���o��ij9�g�!W�H�|@�y�M�6�r�)��V:d�\�=��E����W�.�LƓi@q�L�'+Oѷ���j-0꾲��u��BL��Y����K���U�lɰN���և6g�<X�v��t�F���u����ͫ�Y�0�n���u4�P|��A�)1�]�@����_�18ǁ4�/�Ç,U^�<���i�N��5�y���i�	��m��7K��C�U�}���xPL�:�$t���U77<�������r�����mj��E_\�_8<����'��F�Ѩm�^%���~]��^��*��*�3���J}�)��ɾ%(bGԱPm���;Q����5<^�9Lأ4%�2a0c�m�"jy���1*���s?�g��Pˌ��#�u%�5�v�S���@6��6Z�5��w�J�4(�0'/U0�j��0��g�<�^���b}�)��9�t"+e���Ώ��6	�gg�rv���
+�}½���M��9����U�Α�CD���2��>�'~�u�g~�T3�EO�Xd;� <��ahB�����)o�Y���4��DO��GRߗu��V��1\s����}����ݙ�-ߺ���K.�A��a�~�����MG-[D�Q������P�`Q<�8
+q����.9�Ǉ_��{�q�-8�B��ͼ5��HǞZ��UQiue}�B�5�x�Ѽ����3h	6��(r���|�I���3y�	�o[8�7��g8s�A��FKGbF�+g�GJ!Xjf��>ػ�~����������P��J`1V-���Vxh��ח��?�P�$Hڂɲ$>�I1�U�$�=��$WEJ��Ik �L/ܤ��L+�o����?K�b��3��V�:顇���w���H���g��oWg���:�+P}$��_�\�ڐ'!k9�����/�R-��A�/�p[�y�΋>��6��i�^�'��MX���䨁o�Vգ�j��]uhr�E|�\v�,�K��%�[�r��.G_�����_���ȯ�ݭ��{��ٽ�߿_������?;%aU#J���������`�/4�V��q�zV�f(��d�|wY�o�� �E�t覥��A+ի��+W+u�yݚ5��uk�G�߭_�zݰF��d�(1�����ȣ��ؿw��I6Fq��]���q�p�U/g��\�IE�5��l�+4WhV(�����-�Th��wo<���ry���g�y���S�W�b\yC�uz��r]�GH�mC����k���?�|�9M�7���Y�z��W�_�_-\5�~�i��Gi:c���hb���z��>N�K�zݖxm���U9��m?1�l�?�&V2�m'1m�{(�*���t����ׅ%ÇR@N�X�=w�c9��.�zLi@�r�Fx3���
+Zd���W�<p.p �B`#'�g���v�S��7�dA���)��X[+ME�u��/�kJ�+�$��Ú�R_3B���2�0�m:��%�+n��ϥ��kq}����Gb����3Ͻ0<��~@,� A�= �t�q��P���k!ߩ�>]�ԑ�J,˵S٨�M��;���X�[Ts��a�n4r8kܣ/(�g{�MF%R�,T�@�4��7L�FތFUB׋\$���yX�B~˔b��f��/��<L��3���}�<>s��h�S{%C���r0�e��"�o���K�EË|�����kp�ϟ����h:v��+��AU�����ׯ_7�a�p�6����-���6W3�hg���C�Q��zUW�^�=�hs�	�����C4�gb�<���%�ܷ>�K���v�!r����42�.Ά���>��`+�b�ґ��q���񏢄H���VR�xf-,�<�͓י\�CGQCpb���O�>������SO�k�
+鵼0a9���vM��CMy3}�ZB�z�<�R���{������S�������Y�a8k�)Õ]4�tܱ�\<��H�Ɍ'h���V*�i�l"����Ѕ�(���݅0kn��EeM���J	�~�u������$����+e6�BsIՌQ/PURur�&��o�N$���Ar���	~��Df�s6�I|v�͍���P�(�:��m�諆,�Z`KjM2�p�a���J&Hdz�0�°��<_��C�?q�'�c�RX��II\���8rLP����{x�p�C�~dxmw}ӦE�!<�*� �Fh�!��V�\b�nSS~Z>��Y]#㹗^��������1��/h���'>^РFc���ew���2���Щ=*�bo��#���E&Qi��9��E2�|��K�+tG�L�b����{��lxDWm^}�U,�>������|�>�t����P�ڱ�d���P����z�p��gk���}ڽ� �/]!+�Dn�as�0h�xب�>�h��K���x�iݳ�s���}V��E������]�;�[�eӲ�����|]��v�hڦ?)�M���Ak��_�����N:e��*Hmc�iFm��)�g
+[�ݶGoū,��&��mP$�����j`'�sʙO3ymy�w��5<��q���xlx��g�#�a�?���ñ�E�~�?�׬5k7{�p�'�[�ɲ��u�u���Ǟ���6mv�Tv(	���~�ž�&J�a�+6�v�+�x�az��-4�$�D�vº�ǎ[�:0������H6�
+;�d����.�ۺV�����h���mO�Ll�OzPF�˟}��A6��ڏn�������e�L�D(s��$yvz����7�u���5�l5V�7o�.��M��\�Q���w�9+EXС�1q��q�=�d��H��t�G��kk�D�h���Z��+�Nך���<S\:��n��rh�˾JC��G��m�-�<��>Ʉ�����A�Q�ne�n�|d���l�G���j�Ŋ�եנ`��Oa)��W�3�8j��3GSl��[+�;�ݦ�2m;wB�|{�V�m��e�,��VN?-��o-������,Ӏp�D��?�G{�_��_}X_��(�?��`&��,��_4l?���� Gۘn�n~��d$�T���J(lxU|�L{��8!s��Q0�a�O� g9�0[���*����)�趥�8��z��<p�٨�g� x�^��h�Y����K
+�t?���K�]z�k��Z��#G�)ݦ�+���;�{|��_q��x>�����i���S.�����32(�5h&ٓ�Eд$�)����df���¶'l_�Dg�.Щ�	�F��D
+��<У)E�k�},/��r}�Qr�#9i�Ȑ�?((�ۭ��G�)������w����ؼC_���_�xzᙝ���Mɶ؀P�����\��M��f�l�MTL�.�Y�g��MԌ�9v�ۦMǨ�IBjR]������_0F�@��f�]#���YUa#Opd㬍���t��m�_f�R/-һ�y�Ο�Dd><�ѥ��Y\�rh�����ؼ����2;Tc��: ���^���ciAU��_�x�{.�������5�fxꩧ������c��n��ǧ�u����ޫW��+�5z�!E��+�/�7�_�g�2�䃐�������?�9y�������<�>ޱ����Fm�"�)�R8�c�њ"���UPђ�b��F��)W4K�(ݒ�dQ:�Z�8_)�d#������ηƐU�;�5�c���Y���bkÚj�_��Q�6���+�[��c8j���(��W��uG����.]v]��
+���Ϫ:F��Q�Iܿ��a�n�*X/{t9Yo��k�_��ʰS;�Wv�^捃z�hNz�~	,��>���B�+��",>��E�����5����ⱟj#��~���<2ܢW�ޭ�%O�7-�x�'�j
+U�G�շb6*ݮn+�ݷǷ�Ǘ��/���k�;~�b�M����}~�FW.>rݵ�&?`�_��<}�o��3�1��y��J�(�Xp
+���8;r��X�T���D�؛J�ȅ\X�6�f��O���<ا+��2�X�,֬��K�Vk,�D�<�}Y�J�0ȡD�t��̛�o��iLg+��>G]v�e2�dà'5�*ݦ���q��C�3-S��b�E5G�}��䚜ĳ��p`�]}'�+t�Q�	c�-U�{�/(YI׻��G�����;2�Ͳ�m	l�3m��4_�qQ��;���o�+Y����)"�
+hg\�d]=v{�q�qz+�q���q�m6�+eu�%7��x!|ed��|g4�	��K��\����^�����\jC�1T���+;w�1���^��Ͽ8����d.��Gm.�eߋ��� )g��@�R���  �1g�H�	U�_0�R4t��^�ǜ�c5eZ����dv���}�fJ�e��<�b6)=v���d�Hy���h�p���w�~��m~�_vG�튧�~��a�"9�@�Uߥ����ԯ������ޕ[�%J���ի���l���$�	���:�۩��^|qx�'��������-�Ii!���.�����|��2���tظa��zcب{<}���D'{��2ׄ$V�ȵ���b�Z�������c4�@N]�"2>�F''�>�1�%��6����>�D[^}h<3A�M/�02+F��z�B��|85������[�^t�M7����\ ���w�6RêU�H�20	��̘NX�e��AiS��|��J1��+�oT���N�C�����P��*_%m'Yۈ��6�δ2$����R�|m�-��:1�O�m��EY$g+"�{e+��#���/�����@�0����m�UOw��}ƨ�Q�u�(��	��uk�SN٪�޾v�I�2=H�Kz"�ڹ�[������+Rd�ܱ(EV��@���C|+J�ZsO�㪧��OC���\AxR��󸾦��~��cb���q���
+��'��9{�s{虀XԔPL����e\bké]���hk��� R�>d�@��HM�:ƌ�Y�G��z�J�R��P��j��䀗��	ImM��
+ӈ����-������_��s�3����Z�x�;E����+?�o�Az`Ʒ��FP9Ҡ�[�G$�C�=�W+�ƴ�+���$Vm3�xh�Z�g��t��{�+.���L���o�GW�|u��!�c�����P��\l_�1���+ ��8����=��Sf�I�xJ��R?<��s������"Yɾ��������>��Z�v�j�K�����y+�z%�����b�Z��ႁ6S=��o]L&A8"��J��Z�� B�����Φ[Wm�zė&~�q�o)����_��d�����3m�|à��sY����*v��h��R5s� P���e��a��"n��\	 8>X	�/���dh���.�:R�}A�f8�ͅ���qV9ؗ�8BM^hkS9H�0�+,+�{�d�A�c�~X~;}�w��c\8�����^˻0��1������Ȫȉ�q��.�ܗ����7�m��C=�5v���q��I�8`�XXV���-�෕�aى5�'�?��96�oo��h�1�Vnu��S�)��v���Ȃ�ڢ#�re��5��~-�!�N�Q�3/��w-�ݻ�i����_���l#Rv����Y���m멧��Ǐ6빌���y��8����B�k��1��>+�nƧ+G�"�[N�i1�G,ȃ��U�xP��+lAձ"X�[+aH��U3�v�����2��&�H͐��_�$�t��l��^��ϗ6MiQe��H�& .2!��t�c�4XN���ߠLj�8syx��%�Vc�O�{�����7��V���:]^=5�BțhAő=���Ft,R��5>�.8�T�x@��S��5�H��^��/튯,Ԃ�B��,?g,x�C�j�_I�B�Jx���#�"G-�E���e��zO/V�[؂��~�o��������}+t�M`X�������_�oWlՓ����z����+7�ٙ J���{�38��G����7��M��՛��9n̵�w��pե�+�+�co����#���FOf�M��-�K��uC������uŊ��UW]3\|��m��:�u׏��k���1	��bZ�F" �b�ٯ~�k�^�+=�5�^�W}P%�l!F���8Y�[����:ziS�9�
+I0�&贱Ps0����]Z�4��A@�{��.+o�{m�w�@����f��:�񁱚��j�^|��@�{`$���X����6v#��}�U������51<P���1��>��ܱI-��l�op+g���|x���|�m�@��ʹ�N1\mj�8c��_�Ȱ�o�*�q��:b�no��KH��׭j��{8|����y	��p+N�3�d���>Ƨǟ(E�H>Z���5�,Q���6�ib,���C��m�bxy�S�@�������b��ѽqvx�1��Rr��K�N�E6V��u#�:ޙg�5����/���Jh.�c��TW�8����7Q�a�+)�9��b(�e�8R�2��`�$�p/<ؑcp���*2�N�Ȫ���+�j&��#?6��%���
+,2��(~�L�6hV8R}ZiS7��JǣűSҙ?��_��R>���ٵP/�Z[�X+X�ӽ���b�"���1@��q�(:����?!&a���6v�Jrk]�{�:,�m�H��m��/��TAtر�?g�������>��?S�}fF����7nK�}N��ѶC��&��m�g��c�g䫢����a�˞|�I-�+ �ː7�?��w̻�7���M���!�?��?��?�V/L������G��ח/Y��K�6�%2��ַ��2'X�T��	/��!s��,`�g[Ŷ0��ŗ� ��8��e+|B�Ejc'���j���(o�C�͉�������LP���9^�+��s���%W����� �>,tW]���*����`+^�W[j���k��=<�[;�l�8l�޻��ms�uْX�I���a��]���U7Pdi8xM+z*)�x�SN�>���x�&�K����O\�>�mݑa�`9g�>6�G)Ŭ��+
+����@m )�/�r�7�s+I��TP�!D��r�pQ�D��^*'<R�	~d�m0晁$(r�Q�Erl��iI�"�&$4�*��+t�c�k�`E0���t[��4�[�+t�#���6�=�J���#s0����������6r���v��m_Љ	j��j����'����3u��\�����N��F~�te�[��}�3�p�AA����9��*܂3v��6�nC|�{����s���G�S���_��1����V�)mwz�-���/�I�Q�����p�e:K�s/���G?���+���9�����Mr+��Q�ᢺa��F��^(�LM��E򏝣�a[}����X��-��Ǉ/}���z�pX
+o> Db&��n;�����2,�+�k{��T?R�7)��X!�^�^�1��hiͦ���s5)�3��S���)�IH�-�n�6���wy��T��>�cT�6(D`��������A��'����/_<e	�l���W�Lmj��x��i�|���%����Fꘒ>�_x����
+�����}���y�.��>��M�K:�lJ+��K\��:�9H�P`1�K�2=Qj��d�4��}�,��d�n����U���;ÑR��O=xQ�qFj8�x%�Iӱ� ���x�Э�9��.|<sBkY:vR��|f%m~C~��.�m}�}��յ�
+(�N���k�C���6�
+�K�V�@��,+0���M�K�[����E�����8�k��`�7~ߤ���;�Z!%��u�y��o����'���#��Mc,�M���]A!|��5��BFr#ɱ|@��z~����̒�ȺN� �LCM�Xf�m`�[�/��	:�o���ɂ����(]�NN�5}���@:�1;��Q���/#�0�:0�/�������=]�G��zI���lT���ߥ�5�蒜$���� ������n�F�t� ���3Hz�}��� 	�k�ч&��ia~+����k���#lQ��bE[A��c��o�ҳ?��{zx�F�*�]��9�_PĬ��+��lf�́>ݚ�p�n9>�^�G��@��4���?X��.dO�OP˳l|@�[�0�	4��xhq�J�G�-��`�@"
+J��gt�����̖�Nk�t�m�c߶c��+h�l-�GM�alO"�/��6�2�t�W����Y
+K��;���T���N�i��B�K��^;d��'D�#k��g�j�Z59
+Dl)51|~��c�8���W�PB��=�)�8��Z�0ɜ���>�4x�o��}&�qtL/95�mrT�e��>P<�7t��?&+g���]_��"ӈ|,�l�Q_r�sbZ�D;ٱ���L5��(=�P�&|6�b`[������0���9Տ�ȧ����C�^,����=V��D��@'��F��7/_2��Ɗ�e}?�~�+�����!;����2���b�����۪��YzKާ>�����z'�I���.���z�)x���I����g��8�&��u$��t��CW��1E��P�H���J:<��=g=��s���q)9m��x|X+�a#��Ϭߺ�vV�1V�Y+���,�l�ʃ�>7]�G�ͣ51�X�h��5=7���y��G�`���q��y���>|���W�-�v]0TT+V�v��,�N�0Y4�s�SI�LeDќV��8�1ެ���\�'_�`�E�������;�@�j�^��1BD(m�������ՖSC���)o�{�7}�)p�r�9-IR�IZ�1�J�>����I�XT��&���#�Ё���78@��n�NC�cl\�Y��GG?{a�cf/���R����cy�S?�sy���Q�ʊ�D��b�8̐��Mo<|G.�w�q�6>����~D߹S�Sl�$^V�v�B˟����M5���\WCGߋ?҈�9n2�g^��x@04a�q��NQ>J�GB֓�=�(�\G.��O�������|����k	LAb��a1 k	6?V�����0'��L��E(G���`�+�DK��f��~�$��6�^[�\����g,���uC�v�9���
+�F,������ȃ�b'�c�1����f"�h�1�ȧ��)��U��&c%��D
+Pp����u�G7���M��P���rBb���ה"f>�'7"�Ad���/}@e'��l{����w���q�>�,�W:Po���U+��UC�2�w��7���^��&��J��+ ���H_B|�Ļ)C�<�0r��Fc	�ė;c�|��GK����_����?�����x�/>8vs�������1��7������|����ˇ�{�ߢ�#c�GwU���L��1x�İ���&~�ȋ�L��8b4ul�P�w��i{ ,�BH� ��Sr��x@\>Z�S��|�������x�C�́����b��G���u�9�RS��~����c��?c#F�A���̟����𠐂�.���M|��y�
+��<�÷������|�����Vo�h����?���?��P���y+�c��R�?��'(��-!2Q����u(>�c<r�#�Ӿ�G�����[�#��*�4�G�x�F4z���.Js�yl���&�v�#����v��K�7�ɯ�M���T~��o�[˭�S�c'6	?�����3֟NF�����iC;��l%���k6�@wD¥���9�t�?:�H��ųA�L6+G�B�ß{���3<1���
+�T���λб?��x�@�S��ݐi�On�ȺR�廅%gKĸk.J���5�	��荿z(��W9�j�u�ׯ�M��{g.���3����G�~*����|I2��}�W��+�O �1q!�'ҽ������o�*�s�K��'@??���]���yP˦�G�Ƽ�Or�De��Cy톡ދY�v27��X�°oJr��@y�r*�9��(��hSe�U��q"Ϥ�~�	v�6NPa�+E0:f��3�����t�W�~�:�ށ^u����嗱�b�iN-=�:���id^ϕ��UO�ؔ	����rC1%�C�>B��J�W��T;mC�R�(����O<��;�1�M̨W�G3�}��2�����L����r
+�&�����UN�qn�Q;�Ξ^8+2���@����<�\>R;��{�Д����l�1_�}W+yX�/�
+q0���J}0�_��@��X�k)9;*@ם:���!Oޠ�mj1����c.�C�7��i�D�h�.��-ǧvŌo|�Z�U�k9�5�����=���3Z�s�K�*�_	z���������X?��1�yᯤp� {�Ȅ�lu�p��a"1���I�^$��"Ս1��G�6�r*��ģ�R���Ɗcb"�368�saS|e"L�r]*��>"���!��L�TE&m�HN��ª���l�C^c��*�Q6��5md�u�7�'f��(�*Ϲi�J��q삋�,��y![��"�(>!�6��A�D��"0
+9@~��&
+V���ܽy�٭^\�Q�ߚ�_��?��"0���!�����5nMʷ�Gz������?���q���\���w�m]p�aa��oD��S7=v7�7qOX��h�R��h����}�׾��z�ضe��yxe)^mhlDKc�!O},�vQ�s5]�r����&�-�i@m�Aޗ��Y�I~��(�jԸ��s���������3J�3&6������R����p�r������UZ�h?�G�c���f���Kj���z���q˚ϛ�����n�\N�P��M��Cȡ�a*��:��X��g"����v�Bε��+�OYE���;N����o﮻�t9�覝�0M˧��y��}�J�Wc��G�>�	IG�I��5xMX(==���dC�ylã�z3��.N6�+1��e���L�uj�Jų�OW�M��g��Z0#;�y{i�ܒ���B��}A��X�͆N���d�\�Y����.q���\B��?�c�`��[#H	�wpW~��y��g��b~��g���(������������w���nɗ%�ܬ�c����xn��#jF7�2����γLőq.�ۓ^��fd&�_�Rֆ���YO!X�X$`8=p�皵���|D��i�,.��O��W��B�OL�B?�+v͋N)��C���� ��z�o�s�����n&F������kb?�&z��o@`�	+�����/��p���ͷ�EҸ�-�J��<=���Muw���Ł��X:�e��Ʌ���4��=-�9sz�R��xED�\sQa�����䣉⩞������g�����9g�t^�O�[c��r"���|�s1G��OmC�7�Exd�ó��Ȱ����~��>6QJYڔ$����C��l_�G+�[�4�<Q ,>�ӻg|�@��,����.�I��Oo�G�x
+�M���A�۫�f���p~L�}�yv����&��:)_my�8�u]�w��c�y=�����O�������\������uyG�w~�;oͻ�����?p���g(ɑ~������[��$d:y�f,����8�n��;"F6m�#����b��d`'p���L?���h�߱�u�V����ikG+���S�"B�`�|��#�v��k."w�uO�8�¡��$vT���'?}xun+���5�=����|�\��;��^HI �zP;�Z�F�������F����Z�2�0��Ķ�+��\�����Q�x{�2�X8L;���
+���ԕ�A{��ㇼд����/
+l�N�u:�b� ��]:��#v'���N��`s�1�"E"KB���,�q�9��'O�3���\.�_�=o#�Eb�>�ý+q�`R��]�bQA�E+��Z(��{�H+S��͂���]>}b����?���O����Xdu0�8e�\фч�6���_C��dD���o�[��^��vev�}��G�~,�^P+�պ8h[����������PSv��x��L�o+&��v#�,?�N����e�>���("��>�R|6Ј;���s�M/!L)�y�����c�'�<��O�;?淘Ԕ��Ӱ�ˮ�!^�/���w��Û��_�Ƌ��u��Φ���~r�g�.E&R��8�~|v@:��@1�e�D��`��5Z��L/V�����O�������)�O�q�9��|o.�!%s&.`���:(��G���s�Y//�w��y��������XCu���'{�o�*}ƹ�>C���rX�k���}*N����k�h4gA�촭A@Kα]Z>*�:���T��[5y@0�JG
+��������S�b��͈���6+7to�(m��z�!3���4��f�J�};����P];Ÿ�_쾱ua�p�q�5/��ee�[Aj��q�2���s�n+�q*oػ�z:�cjәi���7MA��=ruS}p�U~'GbP�����)6s9����0�B���Zt�H]���Z���Z/��Y{]a|@!�N:��9��/�:UFmIW+�O^(+��6T�0t&��`(�F\�BCoqF+��魞K+c�ϑ3��DC+5��SӾ1k�u�L0��J�۽sR��o�g��]O`x�\p�嵭5�f7�}�¶w�D��=�Hak �����G�Q����0�)I�&{.o3��y���r�p� ��)1v���|�2>��R���ď+�m�y\��<+}*:�\�e��S[������͆���@JlS�<�-�0�}�3�9�o��>�яF���j�|p,�ơ���{�J^������վ�r�"��í&qKs�&L��+)]�E/%?�v���Bm?!-d���{+n0+T�g���	��ʀ욏�����t�r��5��piD�c���=8}V|b���˜	ޔ�鈪W��2�5<�}��F@�8�v���W�%�+�l�!\��׽�+%t����Ґ��+�ۦ~��$%Kz�VL��ɗk#�f��a��	*B��=0���n&�Q+t���A�%Ït:4��"�x�� ��b��S��le���`�Ɵ,C��,PzDt��z^�3������|��{V��#���i�|����|��9f���n���*G���f"���^��U(:f�ް�wx�?���W߈:������ޟ���Qo�h��ɠ?b[��������w���p��kt�5v�X*ԎsX�q���pV������W��]�T�_h]Z۽�ן�IU�S�l��ι��yA<����vD�1���8CF�|Ɣ+�yY�A3�[g\DJw(1�x�_�,����b��K,)�M7��S�O��գ(�֨E�hy���wߕ��x�,Ԍi���r�N�V企�	�~��M��:7Z�7�:~h���g
+�L�=���T�e�BZ��)���>�b���u����#r�-��f�b�'?|rm�SB��5��R�fl�>6��}m�n��9@|��D�����{����-��m<��@(GL2V,0w���|A+��udË0k����ok����?��\zΑ���WԖ�l�����G�e��g�ͧ�x�3A��;Tk�6x�b����WYސE��u�lf��������Ə�ǟ>�7o�S�>�W.8EI}C���_������������\4����B��'��&>���K�3ȋ���|ܑ�`7��;MD����M������#f������t�S���s����E G|���g~�i�ɉ�`��U�G�B�6������e ���r���e_��mR���\>.�����ؾN� D9H��5�E���#�M7'��#�
+�k�:�����'>�)�OC�/sz�+��R���+k��p�qQ�7��H�g��i�@��Z]����>��v>R�79'�ƯXx��m�k('��)��³�w�Cs�ǖ�f9����D��z���~x�G�i�d>���>��KT��w���B~�l��K�Y8�7 S2���<��Ћh\D3K�I��&2<=��S���MF���C�������#�d�M���`�Ӈ6xX�̘�et ����[iia�.�.Z�q��i[e����\�6&h���Q����F\�X,�t|3R�>�	8~sㄬ��ć�.&pr|Ͻ�>�|~��a5���w��í�}�v���z�`���6ct�j�Y�tJń�#���)ݗ��- ��S�?�?v��_�O�"�G���F�b-_�}��o�ݿ{x탯����n7�&&9r�O)�5L���~/��!X�D���aM+�V����H�_9kC�R���?s������y�<�R��FD9�0`���3}���MA�b�Z�0ʅH�'���ȩU}]�i�xk�'V�Ũ��t���8`g�^�3���`]4M:Z[:�����:X���&��5*���	��|�.�)1�H9^"p`G~>'���}��?z�_�蟷pۭ�n��V}�����1�q|vO{�!�Vy������6^�#�`^f���)/��46�J�a��X��H������&������)��}�$4�H���fJ� �i���_�(���Q�<k��NW���曹���	�� �
+�|_dƷe�+�ɷWް_�t��"B�;x[�'s��=�%$�2;.^kF��S��g��c`�vBxÀ2�E�j�9��4Gf��l$�v8�hhk�S�jB���]=��b��;��4�e/6��,��eR�8ĭ=�����X�Q�"uʼ�5�=��65%�o~�w�m{yT�v7Њ�qtI.�SV�]��x�Xܙ�W�#��m+�c||o��;.�>3����ܣ�&��gB`��}B��9��em1��||)��*
+p�}��+��i/m�#Y��L�94�j}{>/Q
+9��l���b���nn6�������FI⍈�d��Q�Ѥ�˝Z��f��*0�CX+��y��b����>Rγ@̓{�`c9h���|��nz߀'�d�x�0��in#������nU�!�b�uB�h �Z{A2�y�ڝ�!vP6w�k�<0��AwJ�Q�����58h|m�����Ô|�j���h`�^�|j�kߋ��U������/!�@���K�]wݝ�����65�����˧~:�g�6]��vq��b`[3{:a��ER&���>��P�F�ڽԔTʥُ���߰�O�j�i�pёiÅ, &�(<���Ơ�` .{W]���+�����G�Њo�/�H��W?�`�+��٩q$%8#�vd:F�v�P�$T��Q�j��<��b���<E�YeƟ3,���-:��9U���N�� @C[<r�r�����"z.O�b}i�P��a�A.^sp�:	���4��~�_v�飀Y���e���M��"����@N���sȺO�g���z�yی����<c��ß;|2k�Q��AK���<��R8����E�c�{ؗ\w�eh@r��i��Y���4o�k��5���+� 9���i�@����-�ʌݧ@-h�W����29WW����k�#�gIU�v�S�7���F���/(lQ��3+�ym���8�U&>� -�>ȁ���E�u�}��Q�/F�%*Y�7s܋���k�d���t�����o}�[ogts�A֧l{����[��c����C<�.��R6�}�9��Fy�<1�$P/�i�q��@�cl���4-�m�.i&Swe<���Y�Ҝ���6��Z��O��u�t�󂃈���A��Y$�}�`����u�W�w�1�&������2/��y�[�4�ܒp"���0�~�z�zՆ�߷&λ}ڿ���~���G��/����'���۶&�y>_!{��o�}xͫ�]}�Ǽ�$F}�l^�k~�W_;���S�8�rN�0E�T���O.H����<v';i1B}�f#)��s��,��-��2�ۆ�T�U`��S�[��-��Γ��p�)��t!_#�������j0�c�W8�(�F%�+%�{e�L��/�������c�0��:�
+��i���=~�Eb%�0V�Է�I�p��+vZ��_�_���F�!�Q|��M%g;s���DT����m�5�&���*6�tèO�I9��.��0)��&K����_�Zc��"Fl��\b��\���ԓ8�U�|�������,@�Ɂ7�ቋ������C��T_�;�)2�חm/�b�4������+z�p���lh�c�)d��+c���>��[�N�g��=���#�����5�g+E�E:%|X-h4&���z�&2�����<Ҭ�����cY+�������>o��u�g/(AU<r­1�������W	h�18ˉ��n�pԏ�Qj���ح�cFj��/�'��Bg��z>���3�^d�w���y����'��m$f
+ސk���6yb�8v�B8"`�g�?�L+22�̘���@p��_9׃s{���7�����Q�v�m[D8)�}��l#gǗ_��?�{QG��
+2�z3�<B���H�؎+�`F��d#g�,�}cf�{��d�p�P3����3ѹ+��62����rz)���!��GЅ��o�LZ-�;���S{a�.w�N�.����U-]�ʙ����r�p	�����1>#��u���޾�����t��غ��n�)�o���y��of�6�Iч�'�����.b~v7t����Qݙ���X�����_��O�4C�Aٚve[�F���{�w��_���:�
+?N�f@F!d��lƭ[l)d4�9�r�+����Ν�_�9����̻�'8���r����^�Z�I�i��6�i#�Bɇ�|"O�w���{B0�����q+uۇ�7��-R����3v���d��̏�Y+�y��A�H�X��8��s��jSW�9�c�ύ }�؈����;F���v�e�@�~�����ѯ0;�������{Cd�\T,f���Κ�=��M�7���ƿ~wů~�7�,VnFO�#f�������&�`�����,��5s�A�����u����8_��R�S,���8�����[�D�h8,��O_��-��:#��ϧ*BEǽO|Nke��yl	"�7:Ka�t�k1p���dt�ڄD�`�s�M\hm�˜v|�F�+�:�/��ճ������563�{\�X���a�ܯ���&��L&��ňL̥޻v	R�LN��֬��p{�f�L[Ӣp�\����rw�4�H��l��X�7z�Iw�	��d�(ƪ��+�Ֆk����H?�-+��P�PS��c+Gq�s�$G�����P�wZ۳���q�_�4$��4�O+5v�����[�I���F@�Ն���9��ۘY��%)�.ќ/��qbG2�N �B��N���onlY�����S��Ԟ�6_���_��
+�xJ�nuF�"�.�-���	\*1�W?����@��NN%��Y������3�� ��>`B�XC�ph�cpY�!(d��z��s�c��J��O{l�:�zא>�X-+��j0�근��������\�����a��v�+"�?��u�TS`1C/����-�E63�#��%qx���3� �/%c*���t˭ϡQ֪�>���=�l���G�IT����m�.#$:_��׷���)%��=���C_�5���E�����K3��tf��� ;n��C2GX�|��#�y
+�h657;�WN"Y5xEI7tJ*�����;��i�p2��7(�)O�C��Y�����Ps�������s¿9B��\dy�S��'fބ�v�͹�9w^.�ë��'l� �9s����eWt���U���m����C��윘̳
+(�C�aҊ�o�-��k���|�����	q.�|IL�U	9u�5��{�s���ڽݙ������������o����H�����*�w��^az�F)9y��#b�����ʟ��9�6�98�UXx���I�k�����e}N����f'�"`�g�	ڻN(e���z�f;�o-��F|�Ih/�K�����W��M�`j�?le����(s��9OKY!?e�'����.\�?����M��H�g�|`ױ� 3ib�1K�bH��I�p�>��/��^v���.s��3a����"�)�|a�]�x�I�I�Si�}e�O���*�Y����o��"����S��&9}�a���G@���!^�f�CA�y�X�a��e�կ}-��(��P���@�x�h+W��5�bO�Fn����Ǎ����J}[�;�~��Y��Ĵj(~d�<d�i[pho����/�P4pGA��Y�WD��}6/����L㫷7�%s��aW]���D��~wi|A$O]���<xU����.�hb5�^䥙��D��M��W�+�?���=A%�a�9R�*f��c�!�+l� ��I�_)H����a�[/�����[P�jm�+�|���dJ�6N��mc����8�\��J��z���C����Kr�Ҵ�V�����Q|��c+tf~@g0X(L@�ƻu@�b�;	2)�IC��C/BN�5q�BI=�]�:Q{3��_�R��c��6�rv��ф�JZ�����쌐����O�@y�h�%N�v�'Ej]�K���>u��l_QD?�W��u����och�*U�g�r�������7���㝹���st}*M��O(7��7��[��O�u8��+nb�Y��WQ�� �7}�3ƣ�n��{��r�iAL��æ����-���!���v�j?�y���W2O��R|"�3�7���7����m���=�믻n{��o/{ɋ�����hU�ʌ˃٢�y�eO}��5�G��qcS&��?���'�,z����B�ӎ<��a�\R3�j���K/�̯�-G0,������9�|k+7����@�TuMq6m�'{ճ�q���Z�\0.2n����y�EǼ�Ț�����2��$4*�v��
+}��.m�9�b��d1�.�e	��&��~�����+�گ�n������.�g�ǧ����7����yW�7؏n�~��`{����ӟ�l�w�NPR�з�n����Mo}�vi>���-}���#KtyЖ�62����o\ -�0��@�;&����b�]�;+y���_���{˕��ܨ#����<��
+��%�������󗏡�y,��{_d/"���_�W���̙��	~��-�}fN�|���\L��=�_�5���b�c�����2��J.�	ǹ^��2�D�l����W-�R�� `��h�
+q�c7���a!�Ղ3���8бAm�3��'�G��bw�f�Jx�c�p�����t��rQ��D1���a��������iHu���Mm.��Z���;��?�68^S�n�Gxz���p��гK�ctK�т=lg�>��Q��K3v�2f'�N�x��X�Xm癞Ϋ��5�9�g��`��FD'�C�3���Б�	���Q����g�y7b��:O����D��R�d�k���.����ݓx��'(<Bď�)�{��+F7��4�R~�1��3c	V~�X|�&1�o���7@�)h����`(�-8(9�s��O�7���\�G��.8�`�<��O��Z?���,��3+���y����|-�ґv�]3��(>�H���Nf��Б$��JXDϼ�!m�X���4���������=�eU��e)����K-d�T�����ox�bKTzB�)�e��{������g>���]��?��sjLD��<�3��o~ۯl�\���.^�!G,���N�k��n '(����SfH'�iߌ�sʟx�$�6ɑM��_��litoq�����7-�.>@3���k���������;�?z�j_�O��M}�G&��A~��?��?{����u��\D7B�4����qMІ�?��*���v�(��T��<4�+�H��[o���+��������Ď.�8|*7�Y�����a����gd�'���|�o�]����ʙՁG��bЉĚ��?��}�JK��q�:��aF9��-��`2����0�Fc�\�vZ�5��s#�5�]_q�yF;t}��|����13��؎�6��sq�=K�&q@������1Gq�-����&��e��F�ʎ����i)O��D{�=V�0�#=z~
+�[�F��b�m��7XL���+���O�/ya+k��*�HN"k�a�56z�YG:y�A3�skdǦ-F�r�.������G��*_zb�z�;3�#E�?��0�E4z����y.�X.kQ��Ms�����W���l��w�5Wo���Wm��]���w]^Y���o~c��9�8������L���_q���/��ݦ]��K	�X�}(�>cΘb�QR�#`�ȍ}�"��'@�M���Od0�.�i�p�Rw�5���kT��n
+�u: �<���z=�џ`]�����������T:�<�S�𵇝E�, ��"���?�C�/�Cν�Q�
+�c%��{0�+-���'��7��R%��d���^��-MK8D����]/�a����%'�̃�_S�C�s3�K�aH�!B�&�8AWu�єp7k�24�x�ȄmK����C��Gz}@o��|?�O�g+ee#�.넚���'����F"~sa���4��p�i%gؠ�j	�O��#�ɲ�Lj�b|�G�DuU�k�cqN�9Ni�H���O�W���K��F}�'���@@q��^2�O[I�?���R�>��}ޝt��
+fF݉�$;��$���f�jC����_���=��xtx@���Lz
+4k8�m��Nl{���H/
+w"���MoC�o�'�=��F�E�F��ԉ
+���b�x�Ł�BUn�<<�P���?�HUM����0&���G��6hL��pH�ħ�/Z��������O�-�5rR��'�Щ_�?���/��M=T���M��a���1��mG81r�C��n@���A�9$]c�b0���tԉ.����E�1h���I`�/¸������>����m̮n�4��>��-���	��?���bޖ�o��'�|D�|�*������x_�1F�I�1&�\�.5�m�1�_hĎ�V1���y�+�(0��Z]�	#���TO�4��Z�{�b���N��=�(ΚcJ*�\Zp��\)ޓ���{m��Kt0���l�>�U���:���ѿ��C��4x��[++R�K��X*Wft����&�=�U>�m�|ѣ}`��W��DTl�z��9�O��{���-�<��ɿ?�|���_�J���?�_����I'k����'��Z,d�r�Վñ�m+�n����\�N�ݻ��pȓ��R�{��䀺��0�b��~N�#��X~�2����>�5i|�Ӯ_m�|���`�T�6N�{�)p�0���n�`r�?i��������c��{0�+�S�q�rܸ=�Ů�t�;ء�{�ko���`j�X��	�C�߾`3����bd٨��]{a��+c-�����k�bS��[�ɗW���md�U��iXz���gRB�o��I+4���Ob��������"?P�`���|����w~P����|�o/|�K���M!#���}[E"g$�� )�c̏�"�f$ �@e����$W�15ҝ?����ً��-�&w[𴋻&*�8�W@���Tv>�1EM��q�UW��ڝ9!����7�ԏ6W^}U��v�
+��@q���[<9��8�VɃ����Jb�9"���i�����FMO�\���?|t;�ׇ-<S&Vق�om�k!�̝�6(`�+:Lƿ%���e������~��(�k���9V,�W��Hiju��A_��UDr5/���e*B���4��Zq?��{"���t�q<]+�1Y��~T���'��X'��mP�y1�B�䆈-�_����i��ˈ4�X4�̯�a�2ӏ><"�+sr~�3��}�[�:c;h�j�8Tf�K�&���W��:����N���Jt�N��k/p�����$@y����n<hw;쯀ˊrQiF���'
+T��z?���ۍI�4+��#�ڼ�RDȣxb�OC��G��`��'X��a9/8�6ǵ5]�:6�s'td&}�a���`�q~��6ۡs`��w<{���;:�o�[�?͢�`Ę���綤�s��X�G�G��n�����O���s���H�n.P�K;������@s���}��I�>��s<�(=����������恍�L��z��Z��B�_�N���Y�Н/ӍIx�lL@m���Ձ�}x̿���U{��^����ի!�k�c�x�3��M�#�˦+�����.�2�����#l����ӘV.w�q%h��W��	<^,�s�}ۯ��o�{��=��4�Ց��
+�����^���x�u��$����tڍ�/DL�5�"�91������{1�t�� ���\��u�;����cr	Wc�0�u.�KK�]o�ľ7����Z����llY{�N."��������%�\ G/����-{`2��sNa��������m����G�(S�������OK��{��O�v�����$��HOx}�yI�q��Rh����Z�i�g�sbq����'�5�+�_s��/�j7��7��pM/lx�5�xR�ѷ�e��+�b$k�5�n����u�+Z�����?8Q�#Y��B,^ P��{a����.���88��g�>�+�	�)�r~�����O�-$�r6Q�>&�254�/B��������5�֬c�Y>�(	���چ�+��4K�N����N1��䏳mH&�,ޣ,K>L<����6U|�*v�c":a+��<�0u�H�K+zpR�}�q0@�a��V
+ݵ���u�8�k�*&u�}�Ef�v��O�B��_���BW][S��x��(�[�G���:��?w�{m?�o�u�]�0��$8g��Ę�}��.vXB�ݠeeĜ���q�+����2ٙ��&�E�Lg��Y���ɓJ?���P���ذ�����][���e�9iĄ��Z˽:��+֓}�;z�FaG�~{�����U��c<���;�u��nѫ�i��e+|��o~��]��}��Fz"��2�G�)p٣~��~>��.����ԍ���c�����x����x�/���go?��n�?�yj_��B��[�l��V"̴��|�Ɓ~jt� �)�ԕ�a�Gs'+9Y��װL����6�k��8	�	���?��R	�D��	�����?�}�����|m�p]Z9��z�e�kr�����I���rz��kڎ��z��F���^}F���,<�,؋�Hm��\O�&k��b
+�{P3���@05��m.~�!9@�V�v��w-;E���������������jUs"c؛�~�?�'���C�� b�?�!⤑�">��� ���D�ck��������t��y�?z�,`��!��y1�Llchp��~�7�#�H:�7'8];ծrM�@���"5�b��_�~^4~������n�N�"�xd:�:��Q둇c������_���?�y�a�[+)<�;����
+t7)�+�O�!Jm���31�;����	��k���i���e�����&��^��d�!F����#��7޸���^>H����G���ԧ�:�.:~������^���M�+�+]�pS[>4�xb��;_ɧ��D��+8�|T(k���L;��5}4*�me�H������J�ku��FP�G̩9�k��M��p����j�t (
+u��o�a���᪣ӵ�8a�Ԧ.x+O��o]����~�m|��Fy�%|�qM>��@nѿ�;"�˷���K�^�?��x��N���Z��H�6���|e����<������vi>;�W�p��1~|5�����M��e߰�-bj!�Rn!�Y>]�!t2��y�Zl��щ�*U���1�BC�[0y�P@�� +���������f0��As��}�Wl���H_�8K�҅���Ѓ�4�[,^�My����vI.^���ʺ)o|5�pW>x�C<4�wꨬ\��@�+v��R�]yͯq'%�k>`����n�D_>,��;wR+���Hd,�[�Ӷ�p8�M���=�9������a�o���~���0�w��NP���lW_{mnc��+a4(��:b>���s=��I2�Ǳ�"?yMg�>�&2r�%G���ө�\��/�Z-(���|
+ؽ���pf̝_r"�x���?�����6���!��F&���_��m�߾�������&X�v�3�Ù��~�s�۞w{>#з�*:�XF�����Ux�R�DerH[r!�9��g���,Nm���X��+�p]��T7!��|I�\4�\�5_˜q��<�4nx��@�(���iY�B�f�����Ӈ�ۯ}��ѩ��k��ʈ��v3Wv�گ,y����Ѝ�$7�y���?�i>7oL7u�=�Ǿ'�~�/+�u#����m�P�\L*�ȵR����԰�hЙ'mj�u�2O�0���Wj;]�Se�j�Yp>jL�v�+�՗����i]�[�4�s	t�W��>j����_���i>mw+�@|��.��i���T���o���#�{�ڞE��e��� ���ƛo=���)��4'����x����`@�Ҫ�4<�|n���?o��O"e�"��
+��޺��T���q7�֓}��Lg�^T�cU�ݫ�'��\T�8�G����6�]>�Sq�L/>�����I_::��3��+<h6��׵1F�Q�'�R���ښ��}8d�3��e^���!���4w���D��G��+aj��ԧ
+H_ct=ɷ4�V��!H�3���?8bj��u����9I�\2�5'R����f,"�`��v��#>΂rYc`��uc�<4�x}�9`@-��v?+�>���貉jnё^k�#�<���|�R4���G=Z|�r��ۯ��O�+$|�,���N�p5/8�<�K'�Z�yu�:��TH��ݾ�{�F�v� ���{[`)Kl}���X^s1�����tq@�UK��ä�������q���T�7����[+6����A(�Y*�1nN�Aoh��I���N�`N�MW�&��=�jhV��G.��D�v:<0�Q��v^������}�)p�0�,��7w+��������5�Ӯ�8�g�Xl1g��C0����XD��D�� +�0ե�	25n�t����]�
+z�e.A+�T������O^�Ћ��1ǠAS�4f��Ǉ���7���-+�r�Gp�C��t�']9l��#9�je�[��YgU�+O+�Čr�ӝ�+���9M�"3�ƻ�0�ࡌRh�ٚ�,&�
+WC�d���o�aU#D\K��_����Y(bu�c��|�������?Lj����ض���F����O}�`\��Kz-Q�4�����+���[�
+ U7��w��'OX���}a�W��׼�=c��o�,�ٳ�8[s-�9P{��7h�-�i����j�3@@�M}�ALt�ϷYiN���]�[�����Av#�^r�Ʒ�"��d�/��Z�৳.����!��a.ԄQ�ތ"qi�X��	*<�s�(Ȫ��2�%|�?e�[�Gi�������m���'�N}e�_Bˊ~�"����C���Zs�G���A<ȃx�+�5�Cb欯��X�z!M&����Z��+�c��f=��9�Hs΋(�+��BBU��'���ꢻn.x�������.袠�HH���JB��L�c;�m�s<�lI�d�����u����>9&�����Y�y���gzϱZ�R�+�'���6uG��E��Af�o���b_����m���w.";r�_>��ι`�;���Qϓ�y%��YֶT=�Od���F.-k�$&z:][�EU���3�6e�,tH|T%�;��{�q�.��p��$԰��+l|�/���i�D�9�j+Mp��=î_	�3 ��ߦ��0=���Yl���v\��#��a�=���|�U��%�j�{&�1���`EGF�n��%�/����s�LB�$���L�ASG7�z[b ��Ŗ�C��^;��A��Jb.�Ǡ��*^��k�^�	�h@
+���'�o�ɟ�^��WC��8����RH�������}�o5���=zW+�s:�kk�!�q'3d	��۲Z�"��?��+<O�ٿ����ݗ/-n��i��cSɠIP��wo_Ԡs��'���td�կ{���w��|p��e�-�t�|�������6����W��K���=��G ��'@\��u�@"eB�N��?��2|�k0�M�BY7�`�țB�叁��Wҋ�����W��	�Y#��aZ�W�j���Aj��~S�"�r�vm��g����b�F�61��3v��tH?O�8�"���W��޶Mv�)]O���-�Hw���R��Μ�F6+f�L���6�'��S�įĹ�G!��Z��KAW4Z�!L��K+�0��$�%b�f<��	��b��s�!۩8�d^J����^�l�&i�m�F�_T���v0���@+(����c5��?B�^���T�g�+�������L�b���:O���S9++��>�+Vg��Oq�vgKr����;��i�h���f$f|F�_�%�/������o������k�cl�x����`������>= x�Y�d�g���Ǘ駂1�RO�o��^�r�������m����X��b��4k�\�Hi�0:Fj=�f�3r�v�'�Љ���׃	��"k�{��:%���ק��>@T�'��F6)9�ī�9LO�
+@�5xjDx�ݺe�s�_�;Bd�?���=Ƿ��Q-�:���Jց���l�~��`��*��:1��J��� @�Z��#dh\��\��~�ʄ��'��+�����#0ܢY?�ێ�\��}�ةz�x�g	�T6||d=��#�M(�t<�丰J|�w�mh�Q�֋���/�Y�RN�0�^yYZeA���6Ra���<N2�I��Y^�+^I��j("�#R k�H��p�E�X3$[�4���}��`�uP��0�`�ї���|�?l30��/y��G�#Gx~�T8Ql���h����+%}�R������ΕM��m�-��.�I.]ư�?tv]�g����7Ӯ={‵c,8�-�8�!x�mߞ����� ߭" ����/ټ~ڡ� ��������Zy��Y׷��ْc7�0E]) 6��y�mR���8���}0A�&��Z�ƀ}n��QZ�+Q�0�I��vD,?��ʏe1ɇV�l�`��e��c�Z���9W�dA�t=��/ғ���J�N[wl��愙hؤt��٭��G��J�j�gO�b�`nS�/:Bˮ7H�4sM����+��ء�"B�*E����3SMb��mT��%6�/��((���Ùm;vN?������qǬm�$��lc��I�9�+߸I��SI�v�v+���^+�oĕ
+���;ԙ��E/1�O��l(rǆ^���DA��j�hK��)�ne�FP�M��-��l�uC�!R�y�)+>x�%b��a���S�X��`"�℀Y<�����ߦ�������R�%r�m·�Q)(ܼ��+Z�bp+��J���0�-���A���oq��+�5�ªa�f�\�؁����Z���zכ�2��/�-װ�2�I��+�)G�%-�����2�F�U->��q�������1m�B�(Pfv�����0F!�* �WJ�gZ����%8kZ��dX�0�k��,���+�5�m���Eu>��H��ƿ�4��7�7W���@�D1�">��>\r��nI,�D�+�de�}_���3ghE��c�����G?�48f�W<�<�(FG���BG0���}�����Gf�L=`ӡ��7fu�,<_㓂�Z��2���!W�mJ�:�_����}̀"�H{�U�%ne�2ˠ����3�*Z͓��!\���,��a������о�����<�@q�ܓ��6o��W��GX�i�z�����cj�=n(�y��\2�II��Һz�z���?6�+I2���u�	]DU�����[��U(�Y�{KJ���y�O��=�u�y]� )�_С`\4;n^��������N_�Y_F��MM��¤K6�?m�Ci(�jD&r&��Ad�[���!�V���T�yY�;�j�`n�L�aB ~+	G6+>��+fAT�/ݞE�.�땝�8�h�e�y�Ah\��F��+�
+�I�<�mv��=�� a+��`�b/�K�_v�*��Ä�%�e�s�E�t�@@��6ʝ�U�4.�l�s�����e��&>P�٥�Vh[��b�]/�Յ�:bmr�g�����=��n��V���*���>�Bt�E�SJgs
+�� �����I��t���_��CǏ?@�u�G�+v��S6������謴0���h��YƄ�q1�cƶ삕�\E_\�]�҃�c�=�l�e��G��"�?����Ut�ө�mC�.��'�����d"�R�蜯�3���v+������M��f��}�8��2�4�aZ�:������V���G+:?.
+Py����cGO�u+MǑ�~�`4�˙�I�p��s<غy㴃W���<���󦧏�������	�p��a���J��G����\�A�vd�� ��B���}&ڪ��C���K���m�|SRc�x�(�c΍?��3z{�G�����Οxǔ���S�F�?o�~���g�OG\������nrqe���ϕ��j�u�0Q�3PO�x���E���m���0)SL�Υ:����Vl��R����/QГ}ګ届K1L3d;���,9��do�V��N�8��?���؛�)���%�e������ǒd|�:L�9��}$�r�q/���L3�8
+h��UoE��N��^��uۈ����!�6�E�:�������Za�к��VU8�un�y����?��~ze[��x�۷��(9p�v�M춄5��hY�}Ɯ���@
+�
+z{o�"�����v�F���m{��XC��2�eǳܿ��U�?[h�������D&�q$�5��zq����FOcmL��D��O��m&T�S��-c�S6��9�;�;���΍��v(ݨsE�-ê�hc�g�Rn�i8�Wac�����`�]猪�tZ�ء%#2��;�uP.;�Q�%�9P�8��"\g+��C1$r����;bՁ��q���K_r��Ϣ�3t����%���_�����u�}R��C��'��]�ї����AR-���f�Rr�>H����C:�q�:��
+]�A�F�Z.�E�>��ȋ����E�x
+G�b�}���p	n��Ƅa�('��M�z�]J]��/��Jv~��hk�Jip�[��jn�+Ѝ�"} �d�g��������Ж��B��ֆm��%�V�8�U0�(���G܊A��\��	9$p�do�J�E�&�e�)��1D7Y���p�ݦJ�Bv¶�nܴQ�����=�m�.߼aک˚�_�5(��u׃�۲1��	�c�a?F&����%98,�ZJ+Bo�i0��6m�d!��Ǆ^1��/���B��q鏘�ul˰y�uI�g�����5��t��r])٦<r��8�M��'r^gۮa	�1��%~pA�z2F����2iY�,zǓm�pH;Xh�a�p��v���+�2n7>B�3R^�Y�?#z@���90ea{�M���w��.��Ӯ�lPߧ�1Ltqg�pl��ô`�Q�r�#���[M~����Qqt��r���cU�2Àe���M1=V�r���[�vh!k��}��?d�*���4o6?,�:x�д__���}U�ҋ/�֯��m�J`ݴQ�tvC��< y�U2����l�3��YOL��ɛ�ꏢ �R�ć�}��v	�+��IЭۦk��^��>4=��c�6��"��:�"6��Wo�IgsONW\z�� ��n��
+��`���l@�aO�S��iL{-X�US�/��$����6���0����(��E��/��SciټE{�6*s؋M�'Z��� ��$���|���7��m�X��9.��O��7�y����u�}�D�J�^�����2�����X\5E����P.��/�m�>�����O�?�~������������R\@S��>���C�{���;�ݻvL���[k�J�v��ο�����6���wc!W+�G�҅���u�f�/�Uo���K_6�ؽ{z��&�l�T��4\h������������?]z�ų?|oХܭʉ+ .�9��T�!�kڗ/�5�V���ر�1`϶+�r��d�|i£�+�9`�D9[�H_���qi�����k����ַ�
+�^A�典�{�ĴO�:~���ګ_��h̲0?mb`����4ۢ����ϕ����	��]-��v}Y�W�×�G��%%�M�B!�S+ �K���+_�C����}�Β=�n{�)t��iZՈ��Y�q�vǏ]6�_�5��L���7��~ܗV����7��=2����秿��ǧ�(�Gc�9:̊G�)R��N�?���z�p���k^�7�1P��Z2��YDҧ8C�,\����ڿDе��`��H�'ӹ��}������K��VO��|��鄯`�O��i�G����7�9=���%_8mܸ�]*.=�	����:m�],��U�=����Ш��Hh-��%-�����J������)2��V�}��=�َ��G�ϢTH�Up	��j7�|t���`%�G�������-�M;��׾NWpx+d�.��)ȥV��x�-{����&}�r����X�^a��m�Gu�98�s1��&��?��1�?ن���+���Э���!+۰�V�7+�ic��R��`�%[�kY�*�0��G<�Fy�/�+�]���%&k�\1Nڶ`�1��Ӱs5��f�;���G?��_���k+m�!l�f�S�!���~fگ˷�y���-��K�^t2_n\��9��1!j��V�5�P�ƈ�:�����K}G�qZZ����`WzHr���̡��'��ـvZ�E��/3�	�tk���g����$��
+�bޢ�2��v�q)ך`��$SQ����glןs�X"-��mV�R�iK�ʓ�����!ly�x��!��n�.+֊��R��zw0[X�<_`�s���pT����-?2��t�C}q=��U�:��-cy�dĂ�<��?D&\n7iR喔(L�+�����j�2-��e�7^�u�,�]�����]:�ԋ��>�A=[��cU<@J��;��jAT��p����	�F���(�1<T�PvpTv�7g�m�d�Y��2�/��l��J����x�9����Z�s2sX��֐߷o�'t��sb����ׂ�U��ˋ���+��x7zA���U�i��A
+�w��"����@�i�N��g�hS���bCc����l�NkM�n�g���W5�IQ���M1��Wn����|V����1��){5�ǂ�k���Sx8�O���+_�˥��>�\��{9��b������������V>K�0�&~T��<A	z�"���\gH6b;�O��K� �W�|����/��Հcz�e!�X	������嗿~#I���w�r���7g���+O!0U����"]&����<Y�����T=��eW� ��{��{�NG�>H����U�"}�CÅ�\��o�F�N�HgV�;�[U�ܵ_�?�F���YxE��o|��u;����xőJ">E���b�t�et�m�k�M���e=����k9|T��{}�Kk�^�#c?T��۱���q`���w쟮{�˧-��}�%6ۉ��(�-o�L �6I;�/�*d(BG���6��|�Ŵm`Ʀl�b��b��"+�Hs݊��g��:����}������1��!ʍ��Gl:G:3�&��u�J���.R�D$	�dV[Q?��"$��E3Px�9��R���q��>-![�֩>|,�M����W�A�#�c�����\�E�����)�=����Ӗ͛��tp��N��ت	f�/?������J��%�Ρgo}N��f�����6�@ǉ�(X���`�6��d�X
+��-S &�M��Do���䀩mzF�Ư�O�g|�SdT�"�eW�ķm�c��O��0M�ֶR�n��� YL(�>D��'%de�8�Ưh8�~�_��&�!�R:3^���-ö���c�'�;�w	�5��_�_���Y�����R��Lۆ�]7xCĩ��R�+�p��P��~���V8m���l�FDo�e�R��?�~���=�K�/`�u�#����'��w�6����"nZl����~f]�L'4¦�O��GyD�@)��0�^�ڂT�Dc�z�ꞟ��I��
+�3��P�;HAp��G���En�ҝ�M��/s��D���`
+��ĥ?��m3qyB+܄ae{��f��� �:ڱ)��Xw\�3�����������r"�6�Lj�e��D�^��Co�Q������=�����<��Gq��[L&,e�u=�׿aڠ7��8���E1�-�	�9H�F&}MN
+��o=:o}��<���@s1�ۊ,+m0�	�ݔ�*3�%|�*���:O|��^�K�W�g�_�����ZW�r-/�e�Nx�X�X��+���}�.����?�#�5�	NI;6�q�y�~v���S�5Q��֝�`{��
+j?�S��f�Ҝ8�,Գo}`���^��d�:@[N���"��ݳBB���Lڷl�#�Wx.d��xܽ���9 1)(b/NE89�߸qڭ+2efE�'t�V�r0�+=�L���d�I<�L����Q��7n�Y?M|<�UHXY����uٯ}��W���ӹ\ͩ�'���}�w����~�s�Ӈ���S)k�D�����8���Q��/Nwv5a���lZ�b��:ȯU�m8SiۧӉd�c��תi�\�m��u��Z��IlB䂓�ծ
+:u�Ɓ�e��ê������"2W+R�zb���n�'�lH��N�kL��S��]��8�è'A��A!u?Od��+w�~���.��%���R�c�'�җ_�=�7r>}���bقƳ	��ԁӛ����)�@���]��R{l����<� �Ω��/���G��[�g$�+g�ڣ#<���K=ěZ�4�+%؃���+����S?�e�{L
+��q�^�\�r�~�CCWU��Dq�lM�Hހ}\�/�י����9z2��!}m������mi�a1��f+�?����g�5if��r��	��e�Ο�����"&��.��IO:L�R�)��q�Qg ��ٝ�O#����Y�v�E�|��1n�P�w�چ���B{��DX2>�O[z+��k�r�-`1�%�p�-�\�qW��� <�p �.�{��
+�}��ܷ]��ZF�ƙ�$���9݂A����:��}+��}ޮ��i�ٷ�-��q68h�*;��kUW/2��+�>�+J�	�c����s�&S~R�Kr��<R�A�7ڟ:�	x�AO������	�Z�����z?�x��G՗��.��P1�D+����u���|��_�?�)i����r�;����p[�ek�^bu�?,C�<�+<;t+��@'����������ܬ�}��6�����!�{�<�+^ف�3u8����j�"�vgY��tu0:s 8�gg5�[��Nv������M�}5`E"�����q>��ӓO���M�y���|@�3pm������l'����}��W�H|����x�.ggr &���48�7��g�F���%쐓����-�����c�\��f�Ro����e�[��y>p�ȓ���D-$��a-�>��t�#�w�'o�p�q�u�O����}z��u �ߋ���P�CÖX@��$��O�'u��a����~oz��?2}K_�;������&�:��X?������h�����+Xp �4ma�9`������h�Р��w}�u��Jp��jT9OY�̂�}+rv+�C���׾�ǅ�E�������m��Ұ�,`p�m~(T����-٦�h箷���ڈc!%������=h��#^�^�&�Ĵ�瀞#ܶI8}$����?s����O�Uр�ݒ7��]��%ݺ�.���~˟{�UWmy�k^�4
+���	lP��߬��)���ٷ)�qκ!8r�m�
+yK��6Ef�o�=�b�X��[|Şc)Yt���e9�Qw��œ|��c�>2=����}8��^@��y���կ�~ڨ���`t���{&{^�ܡ���р��c&�6ɗ�xB�ǀ�]���7�������2��Y+ՔΌ��o�K�s�Y��+�\�M��y�������p\�c��x��1}p�s����W�4h�K_�{���^1��w"�9�g51`��H��PG]�81�1.���}�L��S)v	��8ǿ�;;v��O�L�<=��vT>�+�0��|[D�E��m^��{ǎ醯�O�[N+��ƁZ���2}�i���ꇉ����:�sy��G��������ҪDV@Ӥ���ʗ����ɸ�pn7�ȟ┓nE��h闊��[����߯�����\S�#�1px�W���5z��aP�+�E�@��������N2)�^��e������}f;X��'q%N��E�sο�TYS��e��E�B� ��@���A?�&c]�ʫ���3ߡx"��]7�<ٟCپ�؋����6q�N��n����goC�7ٻ�E*a��)D��N�����A8�3������˧�]���wT�d��k�� p�m�w����é�E����q�G�<JW?��)?�&_�c۶b3&t�t��� A?�Ļ��o����y~��o�c>{5�|��q|������n^uw��\�-)��/�����+H�Rؼys1y��Y�x{��ko�a��	|AL�(�y8��G��8�
+X�����2���n�����$�ʐd�]�a%��/����W;?s%?�3��wg�N��{0��^�&M����/�5\}2x9���+M>Ea顫,�$���y+�t����0SY��2�c3̯j���v�+ij_�S�!��d��@�T<��`��b��ك�O7m��>b��Q�Y6Z8�Ϟ3�x�@)]yQ+0���&U-%��������U]\���u��[�Է�о⤰��ڵO&�%�o߾��?��?��ӂod�O+�A�������9d��I�� D��!�w�J���@&M�a>�XEd�}|��_�{���I# u����M��V��|4���0M#�~x7=�u?��s��4��?'f{�i]�d���L��yH��}ȃ�aK
+��!��4Yeh��'?�Lq)�A�$wޚ5��{l��+ht�x,ߩ�Ӈ�W,�[0��`�$�m!�dH89���{���zOGC��h�<��%Mb	/��2�Mr��A3ēD�n�M��#S�ɗ�ү��^峏�޲v��,�~$�@6�b��I_lk��󨲂�VqUm�^R�&qm�ŝ��VZ)kI;n�Dm+'v+��g��&�KP���
+.7Z��<��9�����7@���,'�~�Iw�7+�;�m�������yU�"OeSE3���B݈Vy��OI�p���s�l���|lgϞ�K��hե4��A4]@��`|	2-��G?�I��ۅ��7�7��^�x��W�uϿ�'#�2�!D-ɦd�[�LD��*!�'��X�����c3�7U"��cNȠz+ߩ��ɃM���m����W4�쬿.�*ۮ~����+0h��n=��+�oܸ��.����?G��������ۉ���*���Um������?��Ԁ�L��H�Ԁ�g��=�`���|@�,v,1���Ò9�4c�(F:�	��꘮/�/�R*�k����P�Fxe?���V{|͜=����T����$w�ϲ�B�عN�%H	�}.o��gb�_�Dʓl���oVᄅ�[S$�M_���_H�����̼v����1��ƽ[7U��mW>/���/��l㋍�
+�P���6��S[(�j�	/����FC;�g��x�b7���`;��\�3N�H@9^�p&�#��o�X��f�_zYq�%���1�u�y���W�uH)H�I*�LSa����A�M$G�b��"+y��!����z~��2�7��F��s�3�ʌiӊx��tA�瀵�4ʎ8Ӓh.��8�߆�Om��;���v����)���+���,?��{�D�[��W��]X�}�w_��)�6#^�]U�����1i�ȡ�$Fܘ�C����;���ۛ�O)����[����
+"S��[���O��w=͆+���kD�����[�>v�k��w�L����++��"l������Sq��:�1t�ԙ��8��Dc���P��^"/�Ae9J���o��Zt�nB�)�K:�l!l
+��U��9�kŪS�/�X��E3�"N��u��d�^���7_d��S��$�\��j��ΣzW���򪩼�\,��/,�d�aI0��)7~&�4L��"�a�9�`��'���+xyo�mI ��~��S'����X�K��;z��+&�bH�?h��AyvB����yI��n�c�dld���\>B����{���|�T}XA	i�luaP�h��y�!~ⶸcA�3�\�w�~^Z�7���<�g;��"x�s_���J�@�E3�`Ǧ�+V�,���늩�*R*�����m�oYaB��	�GG6�Sۨ�d�]nI�Wg����EG�&tܤ)��?g��c��1�``4���n����c��A.�y�/�4�]� ����`-����.!g����-[ƾ���~G(���7�E�(�*�9U��/�G\�Q���t'y���1@�tY�IX�NM�z.S1���P8��#x.������u�vIͅ�A�P�o����w�e.'� ����hן��)��]�{(�ɩf���m�[��m�k���V,2��y�93��p�iR)P�3!���>_�L�ʷ��i ���E��S��%撊<fc&�HcL��K+Px��f�Uj����L![�D�#|FnNu�?B杋��lΜ9��1Gx�v���x�'H�����W#u��م��)V���*W%�Cw	��>@�#�_��z���6ј���=w��a��4|G�`�B4X�ols�����V��d�ܚ&�1����GΟ�s���_y������[�����������}�-����t�MY�*
+y,/5
+��ҟ�MELvY��)��)e��l-�a��B�ٴk%Ȱ�6y(��o�q��>Q��ul�Ҏ�O���a��pP$dP$�`u��"�%�J�%����}Y���?�'}|��o�<�L�6?���,=��k�Ɔ�]hW��؈��s־?wpzl
+�+�10g��u��y����ViM�z��i�s����Gq�]XXds�3�4N@����%�ȅ_7�Eش!�1"yb�P�k�����i��Fa��Փ�:�ˢ�&\��!�*C�|?���}+�'�mr�G�T����ON���+=ɮ��RI�_���V���}&��/x��A�Xi��4�#�O���S�1���1�j�J���k�uk�M\��ROu��)����"�[�i�`t22�����r��|����ʻU<�]�lYq��p~�`�{���.n
+���I���y��>R�.�ETL�r�j^.�^��(��>�\�)�m�/��E��'�Y�s�*��]��+�,.����w�=�bqc�"<�E|��E��2�8��/��D��󳾫N?��ѥW]U,[q�����Z]�\�JPy���tMyi�7��W�t^�J����wKݮX��=��_q����5������,��o���/�فz�Mg��1�pE#���9�P��iB] �g��'N�6�|\�����2�1`E��Z؏���b���g�NG
+�N4��6�:?�s�L�k�m�W/ߚߤ3���1�xn�?�|~�}7�ރ3��xM��ɷ���v72�R��?�'~�pq�?�	?�ᄪ�UW^Q��n��+���F��<����n��x��|~z��D0y��'���zg�r�SB� ����5r����
+����M��ׯ^��-Z��5�oi^��=�O����y��Ǜ��A{��K/�8m��?�~� nh�b�����]3:�Fd��&�H�+!�V�T;X��+�0*(i-̉_F1_8!͆��VM��&箪Vjd���Pw�~μ�'ȼ��w�}7q��}�.��vYC'��C�"���yO���inT�+���ߤ#�d[�'KZ�E�b��Q^��p�q\	�!�O�{��W�c��l�O!�e�p_����>�+������o�}�z��m�.nvn/��s�{q��>�xio�{4��Y{�!�i��L>%��T3i�b¤���댙����Yv�*߅1_��G��1S���5���Y0�ek�m
+���h.�~�~R��!Xc�F�O��� Y��F�eE��|͖��0�?vL��o�L�;��Y���Z�DV�kP��*-q҆LhӛO�}tL�!5�ɑt���I��w�}��/���Kw�瀫���	[� �,#��󦑥���������z�es���z	��C���s��b p�y�n�"��]�c1�N�+D��R����U~)�卄��{�E�+���E8��*H��
+����yf�C�C0eՀ�#>WH��I{���3};�4��w��C6�0+Y�INּ��)vS�|�7�M���R�nS��(���I�'�m���vI���)RK�_6lje��@����JÔG�R��52�����G��<�=��=�������o���{�������o���	�Ւ@�V��9���%��tt�pA�m��W��ܦM��X�Q�vKq�M�ͣm 1j��r���L�L�T��%��|fP~b0~R��f6Pw�4!�1'��F�e�zZ>��J�����K0�*�3+��.ߘQ� ��?A�3y�]�F�cQ��.�U�?38��dUr����ܞb26+�'�F~����&M�
+!A��Z���Gg���>�7x����s�|i?!��$hx�=�%D���[��ɵ�Pg�[�Y��>BD�/a�ŲM�#-�eH�|BD�I�p�DVɏ�R�|˹�h�-\c ���p�?�Tq�e�p��u��P�+<��,t/?ğ�����O	,��o~��������FqE�����jA6r�$�A�P�WyI#>�ݮ�3��^�
+鶁��u�$��)��{I��O�`떜�E68����K�,!U����3�%4�L��ŞJ����I7��� �����1?'��������;߸�j��Ħ��g�����������}�M�澬=r����_�/�������}���}����jU��_��b:.ῴ�OR�OV�ɜ��_Z��e|g��%�e�F��{['z��������N��F�3њ���u]t���M=�|~盃���	�3+0���M�:,;�*��ѐ�n0�!n����)�I��V�I���I���ouEiM#��+O=�Xv��V�𔗁0��?�]�Of�E7|~�0\�6>�3�C��O>�L�Ӈ	UU�l�'�rjq��ӌ��4�6����K:?�:ـQl��ځ:�Wǌ��H��X�DSzH���������(Mp��>��%H0�DHM<*�����*v<Xd>A�-^�/�+�%��w05�\-������G}A������|���;x�����b�N��o}&UL>��-.��m��%K�.7��ׇ��6�z�p����S��?�����s�sr~���Q�K��k������u����P�����+!�M�m���#�&Ǎ�ɔ-ǋ�z����>���hq��K/�w񫡭A}��a'�v��]��z�o�h��;o�&�����p�֒)�������y��_�����/�9�͗]��F����������3�y�����dO�b�"�G�G����'?�ɿ��gy��D-�Z���&�=Q�+���H�[�@kz��A�yP!Ո&���ݲ$��CcQ4�l�J�>�n��)��8���whŘ-�Q�p�I_�'� q�-+A�+!�*��~��O�,Z��xo��лi�Q��P���^+��ӵK�,6���[AV�� q�u(՟�?����I���磏w�{Ѳα��1�0a����|�}��h�l���P��7�j ���h�	#��-����_��U*�B�W��nx�O}G�)�Z��昋1�����?����C�x�_��{-��Z�	X3���6��p�+\��w�nD�Y^ef��l�^t����ɲ�@�@�*���
+�uj�*�vX
+Qْ�I&p[���f���)RR�^�"l
+(g!��,q!d.�������M��ϯ+��&���Y~|�u�⅋����7�)���{�s+~��'�SO9��>u*���8��.vnT�	�x������M_��ˌR�������U���?X}Y�T��O����˿RL�>ݫh���I���6��-A���q]I�#G�u����o��ӧܹS0��qp7�/�D��>$�Á���g��=���0�nG�Bߴ�3OQF��F��݆�A8a�Հ=����������X�I�:P�K��);P!?��� S�H<���`�	�&�@!��ĳ�M^2�,�c�2S6�I��DZ�����) >ew�wԟ���2mZ�~�s���	�l����>�>�M+�q@k���Ig��O\���[�n�{��ޫ���u.S`SP��{����+�, ˬ�&7Bf�&FAc�Ae	-�`"M�T˜��(&�"�M~d'� h�N��(hyPYBDK&�H'����/,���]l|�uS//�yni�������a�|ٲb��Y����́��ﳫ�bHD��-� �<�5g�������M�Kz�y����p���=�O�>S��8���0���g��*1���U�ђ	&�фːè��EA�*�$�-!^)���(hyPYBDK&�Hí�K����|�:7��ƀ�\#t9�9<�(�����g^x������Q�1Ǚ�q��Vׇ�uo����6J�C��{�[�2q�kR߼é�5u���l3_��Y�-Ә7+q$"��)���Y@�k�j����c�r/_O�/��rZK�d��L��$��H4}�&y1I�t����[䛒� �à�Kqs�k�]|Wx�lm� +F7�����G�żY3��-�z3�w}��u��AKHa%�Sd|�O�#~���lDXZ��?-n���q����`�.;���kގ4�=� �Q�	I6���%XS���s_g�&����IW2"&��� �Mq��*N�y�o����\�4��	:��1������hz���;]�g�#��0\7+���[����A�ŇNU]I�~�vbR� C��i7K{	w��t��� ���X���u{T�Sn�h�ǁ�w�x��(i�a8��ڗ���y��s�T��!��Z�	݇�Y1�?	�=�8y�s����Sӥy>�B/��rI�ks��e>�z�����τbb���Z����?�i�,���ic��~�=M��&\:�b֜�ŵ����)S�}����5�����C��i#m���O��q��p���}q�z���G�G�E�Y�ng���!%qL�06+�N̜8־J8W��>������^cc��x�G�B̏�^��vd�����̘5g�(��n�F�4�����_�sĕ?��O���~?�)�E=�M�9m����?�я�>���x	n +�v�	j�ۺm[��C�cB;���q�����wn�B!�3��˟�8i�y�����_%l
+[�6����Q��[n�'���~��J��MP��\���ޏ���#P���ʾ��e\F%���}܍����7î�{�8�ǯ}�k�x�7�27!v��_�:�h��!҆�<ʇ��f��@Ȩ���1�U}|]��"\����w/^ܸ	h]������g�N-^���f?�t^@)@��{������5�V��uk�,��j����k���?�s���{߸�؎��T8U�h��.0���-�=���/*-\���2��`��7l(~|�=œxC�=qP�r$�Y�w�gƬ��;�{_1}����k�jL�+V��^��N�ۯ�?��t����%d���S�c���8�`9�IA%*au��q��w�v�)��Ն�s�T��Tw_s�5����
+7+']1n��"�� H�/��++R������ua5Yi3C��r����Q�9ɣ���9`婧p�ߞ���0]Ð {���7�F���
+����z�x ���WL�>7NrY�B�)����(��G-��m8뿳xc�F�Kj�RVBj�&���/Y����_~�����������k�O��ҳp�_W�Hgd�x�|+�c��~��~�3�4|ӧ~���+�ӈ҂��1��{�g6��]���姀Rf+Mʱs��)L�-���1�<h�lМ(e2�O����OΤ�f�v@/�z�"9�0�q^ח�'3]��"�Z\[�E$=Ⴙ|�/�j\� �e��j
+�E3^;��p�C���� ~@�_(p�rUׁb��W��k9�o��oa�N3����2���/_W�Xy�����D
+*&�kw)��0���C}Œ�>�kS��i�{�ͷ�~ۅG�>�������N���7Az>?�O������"#q�z)h��5/	��5��˗/�y�g^T
+J�;����v��Ve����}�i�b['��֔/���*�C	#����$g�����A M��u��	S0�D����t˗X�?�f��0��L�-�Yg�p)~�&ް��0�F<��֜]\��w3g��v��������W�e���Yx_�����@t:Q��sD3�|Ѿ��o�ӿ�˿܇�+�\��@���j�$M��	�:FN��)�uS���'��Ӽ]�<�f�;˖-{˱p�<[������ t-M
+�%��)t�0ȟ��2r���TE� ��zg
+�\_��.��V>�2����o��3y������s�]�ߊw[u�ޗ�W"odkm1u�uW}fUQ̞;���k��K�Z?&9o��w�It	+�,�������#�_�������y��T��wm��b|�W���3=�++�;uP�R�<\	؊�� R��w.�|>i�
+A�SA`(�I�M�΂�O:�*�"V�V�'_eO�{>�#�_B�����:�s[*}��wn��c��.*�8�<;+�9{�5�n<=����D%��=�o\c���U.]V�����%o��8����2!~���[�����?���נ����O�/j.$��Nm�'y"����|�����~�韁�����*?.��|��':b#,ذauʫc}DA]	�v ^ ��o��oށ�����c'd:�+���GJ��n���_g]o㪾U/8��`�}�c�/�����!t�g�7+�iཬj��4i��O�{_~������_t�E��'���������@7����4��执�e��e+}.�/�;N���L��W�ڍ)�"�e�i�W�#�x��r*#2�W��=�k�*��^���9�o��������?��?|��o|+�"Ph�YdǱ)b9R����O��l�'��ԫ�������_Bw��"2S74�~-H	�	#�҃�Q��g��3�ſ�� M�i�&����?�h^����v�+���P8a�pʯ�(0S�%K�����|�i�.�[0[�Y�f?�����K��/��t�0K���ş���>t����1���(ƛ�ف�Mx�Ǿ�;��;7C��u�_ӂiq����GKڨ�zF{���z�4a��(Ũ��7y	��t�M��dɒKQ���'�O��@�$�9�;gь�eEU�\XSZ�6�hD�s.(Ԅ��d!C��F���<���Z�n����տ������:�3\�?�g�6l�/_���0_���ǩP�Am+�F��xr<>#��k�&�ezX���=_�*f�`�{�q��"��!�7��O�����di{�A���֚��D$s�[��B�K��W��¼~��{_�s�-��3p��X�Dڸst	'<Ұm۶�����}��7�x��#r��}���o+P��GU��;IN��)��!}��A�A��K�Qq���~;��O���}����u�|��i�M��9� �pT�����Z#H�^]�+�p�+M���w���W.���KСǩcW"+Ly&0���|������;m@�&qRH��U~F��P�0KRG	�u���.�p�a�"Iqr����0���l!�@�P�Z*�'�k�G�^�S���c{ʿ�|nM����z��~P�J^�g�WL~��1�S����A�~a�ӆ��X#O���������կ~����G�b�E^g�1-��EęfT��h��6+�1�Dk�4<N�ϟ��'ړ�\䵨j�i�Ҹ���� z��Ӱ��D�e�D���������u�Y;W�\�&�j0F�I�@h��A9cf�$��>�h����f�MW4��G\��S�*)�m���)-��?L$'�ze�싥��vBY-����7�_�I>���V��KY�E����k����Px-����y��j�޿_��ӭ��'8~�'K_��?�� �8b����	�v(n+����O>y����]�"r����t\��ňd�&��m+���Y�ׯ��u�]��ߟg�T��=.�M7��P��ň��	{��8����< _*r!'��+����9�1ظ	�x�W��A��GJ�l��c!&~Vx;��bA��ȉ�4�0^���c�i�M��N&�hbp�j�F����n��`���)|�k��|Ѿ���-�s6A��)���)�ᡛ<�/����q�>PҲ��r�+�m�2�3�a�KB^��1��xH����Sz�zI�Ab2�꟩T	"O��O!��2�3�!��??��Cӂ=��#�i��u�]_����훐��t��z-�JG�<���[�ጣz������o�Gz��ν������3�<s�U������2���m�� ��-^p�&C�֔|ɴ�����ĥ�F���l&�i�K<��/\�YekQ7}`d9�%L�p�(�!�#�� �P{����^��w?X�a�P���?����ۋ���rS}��n��_?����<�ϟ�����E_P+����M7}����mЩ��6��k��b!o���������+��7-�
+�6T�đ��h�7.B=��#Iu�a�e!�7.��D[l���'�����>��@�Y�Ḇ$J���=�����?��v��bn`����b�����>$/��W��0r[�Fe��?z�|J;���4��}�ȑ��_�W�&��SRlrG�Gr��8���"+�-ڞU�Q�4p��S$$�	�.zi�� ��?�V�ŶaC*�8��N�"����?u)�Fϱ��E���8`[L��?K��9S���e��{��r���O���ӟ���%$�#R��u҇L�ik1�"]��=4�s� �+v��E��	�E_�=���Q�"a�	渉Qu�8��Z��g&��H5z�)�aP�l 
+v��q��+�2tc�8$]V>1�g2İp�Aa�l���pJ/^6����'N�����&��4F����|G�8����_�L����3��Ư9>��S����f�$�V/�#�e����W���f�{���m۶��E)L��L������Ab�,B�a�"���pb"��`[˓[�xdZi��߿��í�{����Yr+_f�!�Ct�m3���4ٛV���x���r<�j��Ǐ�}�k~��\���vJa�g�6�[�u��10��e�s��`d�k�Ǚ�J��xԧ���رq�����ܦ.��ys�t{0�d�Hb�.�m�#��3䆤%�ژ�:�$(=�I9��5�	�)�7�#FD�Q+��Jyu�Y_�򗯘;w�z4����2𤩇LC��G'��l���3��=�i�0CT��,R@��W̡��0ߋ`+�+q���!�`C=hU�ICbH�)bɺb�5	ՖnGġV����U������4���Y5x�Ǌ��}4�<���`x�kژV~B<��_���|�����r&�T��+q��h��?���;w��o��E]�"�:<xf�?+H���>�81a"�}���7�Ǻ���>�����Y���xL���7�����k�W����c�{��o�������G�"�y�w.��x�_^w�u�G^7��x�!E'p&~b��)'�N	4y`��Q��Oh�
+�	wnc1�ę8eă�:�C��AN߇w���!/�xꕯ|����ޙ�X�+�t��6�m��t�[	��g��W<O�7�@�FZ�'��a]om&��C���?��1�fD����c��G��Ǆ�D�� w������7��>N�[] ��e������[��9��������)Ә4�1�c�XT'#�0:�{�&v�#�\	�}�Z�%�뭐w��������O�Xl�&�4`b�$9i`����Wf��<1����=/�U|y�h|6o`r�<���Ŗ���+kð��P�tf^k;{�A���R�ݗ�S�暡l�R�m�l���?���\��=0��?����+m�#��߾}�6}�����[n����$e��L�3�3�[;��_^U�;�������A���rj�sh���넟G�V�Z:eʔU���'��Moz������v3�v����V��)�=���욌+S{��Kx��5�b�x�	���M���N���*���o�q;~��o>�>�*�oRLR����Zٿ�]]S����О���w�}�S��_����x~Q
+�66�Nޤ���Ӗ���u6��vc�2ƺ��5�v��.:y�N�(�k|�� �8m��I��>���0y�~@���N'Բ	�]��Lk/���Ԟ�}�g�z�K��'tӢ�o�M	:L��J��3��&��]���?�?�C�+�Kw�4p�k�Ԟ��p�/g���??$}�r�1*۟��2{���پȇ}���-o�S^���[��g�1\&p��5�i���-"�UÐ9���rcp$�eD��X��+�	�&�2}�/1.�+��(!~*xY�&ث���0X��.+��Ft�.ȣ|�ot�Fn�ó����}��R��T�O�l}��+�
+���d�����d�o���?��Ơua�t
+�ğ���~��H9�}�{ߙrU�y��m���$"�#	�'ْ�(�=(�;쓟	� �+x�o"��1U�'���+#�����<x�/J�y�����S�}�C:�-oy�es��Y���'}�e�գ��O�@��ݶG�a�	ヲ 849bи�+@�cg@��zL����q	w��f��zO딍w]S�����*�o�[�2�m�;w�|��n���%�?/6�R�N�L�:q��o���i�~���X���F�sʸ�,nw�A���Y^�*����͂+�j��W\q����	y�g|��
+�M��W�}���?��E��B�����O
+�e�
+>*�3��WֶM��.�}����;��aS�IrxXpL��O��v2sI�,�Z�;tY̬�2�2=��8�7o�|��7�|���o9�����T�GB։��IuIk,bO��D�3zۇ9Y�@y��5�4����b;x|�T��Њ뮻�s�9��{{{�n��`'`[�,���־Lo�+�����9$�!I�C�F:Ӊ�v��0��5ȓdA1,�8�\���}�g2lB��1{��,&ac]OO���;��� ���^I蠃L�#�
+�;�<�֟�����m}k_���,?<<|P^��7�p�==��>���8���1�V
+�h��+#��d�d��;m�,Ek;��ii�!�C ������d����~�1�T�@cKW]�z��9��R�*��k�� _ �hɒ%�uZ��Nֿ�>c�:��O��2뿬?�n���u��봾m���Yl}�R��a�2�=��ַ���}$|$��R����@'w�h��ZOZcЩ"�Z��#P�+C�B�<;��yqQK���-���#��+.�t�%�2d�'�q���&����+6����.KXR�:�_�\�ֿ�/[���־Lo۳|;�������zO<�����w�}�%�o���7�퓢߿/ln·ɘ�M�[�嵍���b�7��+���㏿(�x�ᇑ�d����D�$Kyb+O%j+�|��2�cy�M��@ZcK�w��H0�9xNt�~GZcK�/+�.+X�	��B�,��U�Y6l�'O̗�͓�,���@�'�@�#?+T~<��-����\�d�W��n��^N�w��v���/��˒���3�G��CR�؏H9�
+n��%K&W���a���x��6y��?b�HS��#p�"�I��#0"��E�[:�C�b�|�r�+�e4�+�����ϐ�?k.0̜%Wf���N�҇"�)�x�3O2�~� 8$I{P
+p�B'�eP��Jb�/p`��݇��3�����!y��aI�%��wx$v$y$|ʘ�EԔ譌I����*�K���_��y�[��G�G@O@'�qo�#����'-M^cж�-ey�ꁫ�h{K�����b赬*;,�FC$n�S9�{��hr`�+m���C1u�[�[Q=mS�u��Iȣ�w�8)�dtR�F=%��'��2к�	�3�A����i�����a��t�ϓAnc+��Z��u5��)+��i}Oy;�I�%M?���X�I����v����M���ޑ	���h�(טrb�t�qʷ��h�R8O��K
+��)�"_
+�<��r�EX�,>OF]�cM���X�2+M[��*2�h�"�����(��?���be�/��'�_��)u�ڦ*m��;x&\�=IL�+:X>�	{����j��l�k�"%��h�������k��QO�yt���U�a�����M ��I��G �ԱSEfm,�����g�����:ik�V^ƣn��է��� w�xr"p�&���]�W�;�R�NdZ�u�ezm[D����/ҧt���n�����@�tk��Д�x&l���<]�A,�1�Ulh[WI�E6y�<9�T���g��x
+"��I��)Wy<&U��n٘���VI�ݲ�J�݉G�#P�@�ɥn�G�#p�#��1�n���UI䩺��K�r�G�#���vї��x�o<���m�#�x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��x<��G�#��B�?��p;OH��
\ No newline at end of file
added in remote
  their  100644 84970c7172887f460750705de8fc06ca7eea4a5b electron/browser/resources/win/atom.manifest
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
+<assembly xmlns="urn:schemas-microsoft-com:asm.v1" manifestVersion="1.0">
+
+  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
+    <application>
+      <!-- Windows 10 -->
+      <supportedOS Id="{8e0f7a12-bfb3-4fe8-b9a5-48fd50a15a9a}"/>
+      <!-- Windows 8.1 -->
+      <supportedOS Id="{1f676c76-80e1-4239-95bb-83d0f6d0da78}"/>
+      <!-- Windows 8 -->
+      <supportedOS Id="{4a2f28e3-53b9-4441-ba9c-d69d4a4a6e38}"/>
+      <!-- Windows 7 -->
+      <supportedOS Id="{35138b9a-5d96-4fbd-8e2d-a2440225f93a}"/>
+      <!-- Windows Vista -->
+      <supportedOS Id="{e2011457-1546-43c5-a5fe-008deee3d3f0}"/>
+    </application>
+  </compatibility>
+
+  <dependency>
+    <dependentAssembly>
+      <assemblyIdentity type="Win32" name="Microsoft.Windows.Common-Controls" version="6.0.0.0" processorArchitecture="*" publicKeyToken="6595b64144ccf1df" language="*"></assemblyIdentity>
+    </dependentAssembly>
+  </dependency>
+
+  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v3">
+    <security>
+      <requestedPrivileges>
+        <requestedExecutionLevel level="asInvoker" />
+      </requestedPrivileges>
+    </security>
+  </trustInfo>
+
+</assembly>
added in remote
  their  100644 ada12bf324ad1dc48e8a040da0f7309841f55f59 electron/browser/resources/win/atom.rc
@@ -0,0 +1,139 @@
+// Microsoft Visual C++ generated resource script.
+//
+#include "grit\\ui_unscaled_resources.h"
+#include "resource.h"
+#include <winresrc.h>
+#ifdef IDC_STATIC
+#undef IDC_STATIC
+#endif
+#define IDC_STATIC (-1)
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "windows.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// English (United States) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_ENU)
+LANGUAGE LANG_ENGLISH, SUBLANG_ENGLISH_US
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE
+BEGIN
+    "#include ""windows.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 0,37,3,0
+ PRODUCTVERSION 0,37,3,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x1L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "040904b0"
+        BEGIN
+            VALUE "CompanyName", "GitHub, Inc."
+            VALUE "FileDescription", "Electron"
+            VALUE "FileVersion", "0.37.3"
+            VALUE "InternalName", "electron.exe"
+            VALUE "LegalCopyright", "Copyright (C) 2015 GitHub, Inc. All rights reserved."
+            VALUE "OriginalFilename", "electron.exe"
+            VALUE "ProductName", "Electron"
+            VALUE "ProductVersion", "0.37.3"
+            VALUE "SquirrelAwareVersion", "1"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x409, 1200
+    END
+END
+
+#endif    // English (United States) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Icon
+//
+
+IDR_MAINFRAME           ICON                    "electron.ico"
+/////////////////////////////////////////////////////////////////////////////
+
+/////////////////////////////////////////////////////////////////////////////
+//
+// Cursors
+//
+IDC_ALIAS          CURSOR             "ui\\resources\\cursors\\aliasb.cur"
+IDC_CELL           CURSOR             "ui\\resources\\cursors\\cell.cur"
+IDC_COLRESIZE      CURSOR             "ui\\resources\\cursors\\col_resize.cur"
+IDC_COPYCUR        CURSOR             "ui\\resources\\cursors\\copy.cur"
+IDC_CURSOR_NONE    CURSOR             "ui\\resources\\cursors\\none.cur"
+IDC_HAND_GRAB      CURSOR             "ui\\resources\\cursors\\hand_grab.cur"
+IDC_HAND_GRABBING  CURSOR             "ui\\resources\\cursors\\hand_grabbing.cur"
+IDC_PAN_EAST       CURSOR             "ui\\resources\\cursors\\pan_east.cur"
+IDC_PAN_MIDDLE     CURSOR             "ui\\resources\\cursors\\pan_middle.cur"
+IDC_PAN_NORTH      CURSOR             "ui\\resources\\cursors\\pan_north.cur"
+IDC_PAN_NORTH_EAST CURSOR             "ui\\resources\\cursors\\pan_north_east.cur"
+IDC_PAN_NORTH_WEST CURSOR             "ui\\resources\\cursors\\pan_north_west.cur"
+IDC_PAN_SOUTH      CURSOR             "ui\\resources\\cursors\\pan_south.cur"
+IDC_PAN_SOUTH_EAST CURSOR             "ui\\resources\\cursors\\pan_south_east.cur"
+IDC_PAN_SOUTH_WEST CURSOR             "ui\\resources\\cursors\\pan_south_west.cur"
+IDC_PAN_WEST       CURSOR             "ui\\resources\\cursors\\pan_west.cur"
+IDC_ROWRESIZE      CURSOR             "ui\\resources\\cursors\\row_resize.cur"
+IDC_VERTICALTEXT   CURSOR             "ui\\resources\\cursors\\vertical_text.cur"
+IDC_ZOOMIN         CURSOR             "ui\\resources\\cursors\\zoom_in.cur"
+IDC_ZOOMOUT        CURSOR             "ui\\resources\\cursors\\zoom_out.cur"
+/////////////////////////////////////////////////////////////////////////////
added in remote
  their  100644 aa09177554651fb38078881c4dd73f7d1d17ae7f electron/browser/resources/win/electron.ico
@@ -0,0 +1,250 @@
++�֘|�֘��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��՗��֘��՗��י��ؘ|��
++�ܛ��ڛ��ۛ��ۛ��ڛ��ۛ��ˎ�Ƚ���ԕ��ڛ��ڛ��ڛ��ښ��ڛ���[��|I��ܧ��ښ��ښ��ښ��ڛ��ښ��ؙ�������n���b���O��yD��xD��|F���U���k��ˍ��ʌ�̿���ؗ��ښ��ښ��ښ��ښ��ڛ��ښ���
++
++�WW됶�����c�.�Q��[�5��}�	K�,9aʔ)�Ə�D���Ç�:�jp79�M^e�����w�޽F�Ī͛7?�������#���e������k$�	����r&��M�p��W��������OG���w�����y���7�7�7O;��cO�>}��cƌY��:����.-�J�/�)���j�p����o}��o��?}�W�����ϊ�	��B��.ҡ�Jy����.����)W�#��O��O������s�:�7O�4�L-�OЀbRx���8}��7z��ޱc�}6l�����S����_�����&D"���ws�C�e�@��(�^T���S�:~�����<����?��3f�E�3YGQ�X�8h�Ĥ�b�V��Y��n���?��?��[Ԗ�ژH5�lӟ���%y���%	b�ʗ5ػu���_��N;�s~d�̙�6���H�29��Ǜ��{��;�-�~�2<�v��+4\��?�ӷ�M݁_��>�-C��@�QQ�{����)�q[n��	����|�\�^�D�洿]t��+܃���-�k��*�Wy���g�����/^��Q�F-�i�`�_�����?Xy��/��?�t��ޕ+W��'>�}�+_����	5`B�P:@M+WhU�����oVK���I[�nNC���@���P������,�\s�5�u�Y�����f���7`�7����"�v���qX�Q7��D��a�p��Y��R�0^�S�ɇk�\e���uc�wy��=�DL���x��!"��X7��wq������롤�����}梋.�N,L�
+hJ�&P�D�Ci��Ci�(��w7n�M�`�|�UW����O���mw�p�`*GNL���{����4vi�+�0�S�	7%��`CB����RD3L<���ʄ�(���e�=�8E��#�d�e�=&���G��k"��;������m��E�$���-�����PJ=@?�{��B��������+���GN:餏�������P+a����FZx�Q9&��}�{M�������K�H�:���`��+�כs�.�+%����ХboN��DYPP!ش�扲p�fJ�I���f���*�Yp����iӦ�����'?�䓷�y��Ck��;$��ö�zm���8{���@����(K����+����]
+��
+>F�U)W�2�T�`|�SA��Q�/����]�=�%�!ԃ=P�&踷^�x��T���@��9����j��6�"�ٝi7���1���ҨL�����=a�w��D�mE|R!~8����'�٣<0F�N��9%��?�)�3�4�[<*�����th�:��O�j��N�%���o��%�oh�?�ʧ`]���<�G�Z�C���@G2�+���킰j�S,Ȅۈ�aA!�m�U������#�6+��tJ�%��~�g�z�pJ����Ut���M��Gldx����fce3���ƻ��Q��A��t������#�9�D��¬24��sY�qԂ�#U�ڭAQO�AC
+f%:��`��-/aW��򸚮�X�	y�͵��5^H}EM<�+v�D�T+���&��ԄV?���Y���fX3U}t�|��R�9�=�@_�lҭB�
+����/������+p5͋�+Xu�+SW #�KT��<FN])�Bu����d��O�Ɗ.Hkz1lm�		����_+�!�|e}j�~���x�F}��������;����Y[��:��[}����?�&D`�,N}o3���Op-Wi_  #�"8\@���'Xk ��H���`�99�#y,%J�_,�[y�\���CH��H9ac��QE��݁	}ѡ'9��5�K^d$�?a�ʅ���~h����S��#x)���u�F0�j��e�}�z�u-������f�������}��u��Z	��X��A��x�&w��k�-���j�]�p�[o��/&N�x��O�ܬ���.�9*�*83+oe��6��]h�ǋ �A��^*�I>h!"�z_�b�B}�ud�`nQ1���r��:�և^Ӥ����U-`�>��������u���a�Qq�������㏯	36$צ����9a_m5���pŊ��v���#��{͍[��%$��D%
++�0��%K���~���u��T�k��j���}�}��U�q��j����z�����]�v��q�@�`�CP�!�A2I��
+��K%�r�}ю"W��	;<D�Q	���͓�6c���d!�r�ן,O@��v��+炦���z�%��:7����/��Kȫ�P��)[`@�%���ې��]����ޓ��JS�ԫ*��
+�=�|
+"U���=��׵�͊x�t]�U��?FL
+�@1Z���T<���:TW��ȹ`9OOe������<I������6��Y?��C�$���%��G��PTU�Iv�����$�`R�m@4	�r�a�b/�8��L0�R0^wxX��ۡ
++
+<�YH�V̀6E��&	�H1"�H�6�D9�[mVY�f�J7P)�6X>vH>܁��)_`n�
+n�r?Ԥ}ݩ�y7����:��~:"��
+%�Ԟe�Ą炵B�J���F����Z-��; ��Vt�=m���Ħ��i#VU��.�V�q��Y6����8t�u�]���K����PQ�[Z�}7��>y_�D��f��2�q,P�_$�鎯2ylH��Do��-����^��6e������[Xې6���<�-@4ŊӲ%�L�]�6�Ϊ�b��P��"��Q6�jV��CU�.��fUm3��mG��^&9\�g���(?~��6Q�ʩ�Ի�fΰ*Hʼv�bGL���+�hZ���ͺ;�\�Eo��ܱl�er��̜2�I�
+4W1KQ�vX���ʶr����9_����}�g~�@-��߮�  %��qG�/X��'{��E@LE�D�-���a�*C�I�c��΄YW�-AxOD:��䍀��K+=���P*��D"���	,��I����8	�&>�t�
+i�-eW�T��S��S��f�M�|���%��.3�J{���d�]4&�4�Ī�y��&��0K��%a���I5��g����ͅ�u��TǍv e0�^�����o�+���Y9�l:���c@��>�F �L��KYm_
+ֆ_
+*�!G{t��� !�ʶ�P��C	��(2����;��g�3��ik�'I�#�P��J"��o*kQ)��BY�����j�eR��S�3*�h����D��q�{�˼R(X���,��)R?Е~�1X;�U,_���j�?V2Z�!/U9�i��'�ޡ�6M�F̝��6N+�+����lg\5���+/�mF��"DY��\�����F���n'3�$�!��o���_m���."��a���	g��s�i�~��-J�J�2�P����cP��I��k�.���������WXBtX�2!!��!�/E�\ � 7�e�)t9�\�A�2���p�BV��ٗ�P/I���xx<\�'��&i��5����y,�Y��Y����/4;v�jƏ+�>��I+:��Coa�;�cX�P/�6VEk;%�ʶ7uQֶZ���W��f��S)�(�8o�U�UM��WUe����9�������+W��I�&]X��7���O���v�]��#��M����e`�`�:��q�E�	F`x�n�$�!Lf���d^�%��j�LL�₴Y��卶�]�r '�}�v�b���S4\w��ͷn�ٓIj���Z٪r��mo:���3��5ļ'�7ӻUҕ�_���S*
+��Ͷ7�ø��9�������D��8A�7X)�k�,Q�8z1�A �!���Qې�V�EX&:�ҷ�e�F�2v�u�;]�n��ſڹ�$Н+�j���+�ز�\��S�� ����2��DLۂs=+)
+с��U�܂Ԋ	G@ЗO�:��Q����F�ӛ�]��,�dokA!"H5D̢n�7�IX�kY%;�G����p�-����nv�#s��/�J\9bD�d�<����_�fq��ρ�C=�y�X�v����k ��T<!�*L�]���TP���`FQp���'�b�>*JF��dh��չ�B=��%O��I>���Ն�3g����]v�e|a��	����Zd�W;���c�=�ܣt���u�W|ˉ�cd�ɿ�m��+�v�aNG�(��8�eR��OzÂΰ�7�#0Eo����Ad^լ7��|�z����m���ҟ���r�/;	��74�j�o�Ab�#F�hf͙�̙;�eLh̀@��7��lۼ1�aH:r��	G1�+�+�!�l��+�O�h("�jB�ǁ��}��s2`��y|��?�nʔ)'�v߹�kxT������^A�'�WP~W4>�n����f�ʯ��o�<�V�&�[� �..�����;Kg�~�D�^��G��m���#r"�T0@� 
+J%ٷ�5LP
+
+��"�JІTl%LL�r�\U�������+�Ԑ�0t9�5m�%}��ٸi�m���s�=7�m+�%�ݬ4,5�V���4*v*ӷ~����$��S�����	(�n,	�a��M��5���r��я~�G�5[U�S������'��+���@#�����W\�>}��rN�©3�l����S�'�.{��@t�Ν%���QڛPt�l�Q{�+N�EE-,��ҏȓ�ΰ�j>���ڶ�d����}�g;ms0��X���r�'�"�U�?l��	�h����/�؎�Aq;2�0�<�n�2,�~�v�ߦ���w�(W�F��p=C�������X�qD��m�+��Fu7�袋�q����#+��+�J�a;�a�~t���|�3Wj���0��ʳ寐t��[��F�xι��?�s��R���k���#S�Yx+��h=z�f���W}ޫ�>���SO��)���-W�@�1\ņ��3����+G&�l�Sb�|�a_I+�IzD�����<,����)ؗ����Ǭ�֡F.[w�'�X��#F�Xԡm� Ϭ�o�C�����%��"<�6&-�-"�Ò*�Z^��T� ��(��S�C�� ��6��$�C9��.�cY�y����鰛�2�]Xea�����|�$o������ov��9�WH�J�9��.��9�ef�?H�tq�7��y��U�N7��؇~�1~R�^��W�En{r�EE��5ZzXYԩ��@��]Aih�L�p�]�cJܖg�8)�����P�����j�=l]z��.�,="|�ng�b���)��G�1�nذ�>����ze�bA�0�^��J�+II��e�𠆲w0�V�o�a�����-mDD�c�~���f!tSV�cC^/�
+J:0Nյ�G>���?�ꫲ
+p�����!����9�.��:N?��y=���]� �k����,I����<`< "���,�?�'@!�=��ʷ�U��@��4h�'p(����P�!i�'�;8�a�)��Z�,70���Ö�W��O,]}U.��#)�Q��r^�s��=�[Q�/�E�MO%M�i�.(�h�q�ך�z�(RQ�5O>�y�[.lV�
+Hށ"��OE�P~S!�)��Qe+��:z�Ȟ��")�L�cdt��K�d��������"����+�ۮذ�Ƙ�K�"~�	H�ǌ�\�w5#G�K�{������UW7#�J�>�^��oL��N�埍�S��N)�N���萖��C�����+%�`��yeI="������m�_���
+(D�֕��B�r��yf����
+���t��"4BZ��'�i?	t�e%3�q��7V۪GW��K�qئo�x�b���Op�ު��
+��[�p�m�+H�w��0�C���ΤȠ`�8��r"P�uj�j����<g(��T+���#U���&ѝ���d�.�-C�h�b1L��uW�^�U'��-3���J�#���V+*����#�RO�+���/[d
+d��؛�	B�m2`�Ñ~]+p�D03ا���$�	
+r΋�*�|��s\�.+J��Q>V�8�x'*�,9$�����ov`�یi��	�=-4����Oj���r+����xXZ�<E���j�,ѳyLF�^MJ*�|�ް�����z4J�#U�C���KM��65�e&�z�q��V9����l�p\��8���P��I���E�EkϘOݕ<v,r��S"�2�$%>>j�������*+�2�l{����4�=�9��[�^�ŷ�٤o��a�f��m�b�U��];�Q��>Z�ոŦ���董�Θf��O�:����uFjP0��2�D�X�����Dh�ʞ��TF���؍�i���<�;�GI �Uh'��~��E��y�4��|2�*S������f�v�����4�m�O�ݬG����X��v���&襣�z�`�6~�̓!B�٬�����Gb��-ػ�m9���꾢OMG��Ob�8������p�
+a�^�;[߁T=09�����X���	Ж���"��r��`|�U!My�9�A��I/��>���L��'?�L5�+F���춶B ���@�+Y�'����y�z��W�T��������nuk
+:0Z�e	�`�CD����&�ΆT�r��H+�Hvh�z��JGA���أ���n����7�Ѭz�I�H*,��i��)w�*�JU��`�u�q˗��g��h⬽%�8�=SG��J.<��_�o��t��e�Lط��^s�C+��u�M�2l(�Y�<}�~fl��0�y��t}Co
+G[!������S��:��F}h�	~R�{+^9o2)�v�|�d�l]h�)o!�B����6�;e��~V�E�@0���� ��I��.��Ip$#4'�OuvN+ѭt��gΕx��?�z��͆
+b�J�%�9n��f�>�5u�.p�E����H]���+��)�x�v��=J�C_�ݪ���74^X�l���"�|���w�GO�-Q���I�ZA�L#wR�N��vp�
+�|��n������}�nZv �I-�SH�%?�>_Ę;o���Y��&�.��|��uZ���꧞h^���j��;�}��f�V6�o6>/��zsFR�,c�I�q�ys�������I���Z	l������,K;��?�{P�b�ܮ Զ��g!"�w;�?��ڀAjOa�a�6�k���1vgK\/ޯZ��s��~��Jov��^̼H�s${E��VG~�J�G���~��w��0�<[*�O<��~�ˉ�H@��T���q��d�YtZ����ѥ���C��g�Hl��!�Z�(&<���G#0S5P��ͥ��7-�e�4Ȼ��&5��,i�Z���>m��8S摙��Mј�J|��N����7<���`�=w����R��̤F
+&�UD\ț�e�X|���<�Ps��kՅ����<X�ǎ;�9�3��-���[t����]{~�'~�3���q��z��'��ʌ��e��uu��'�']e�aO���|���.��9A��ݶ˟���Oa��<-^u�P$��UBy|���;bF8�A�l�h"A+��MG��T��K���:}Ԯf^�-�ֶ,�c!O�T��;w��`�5a�;q
+�A���m��ȑ�6���ę�w��v{t���d��ҽ{�Q�d��@�3��(&�<���Zt+�#����7,�gΜՌ�-Bpn2%�'S�X̝�8������������{"����XB��0"sԁi�0bd3w����z�y��͛��f/� �:��r��g���!��h��\�{�1Z��0�}�~јW1�����6�t�X���D�x�l��1���H|P����50t��f�N1��;�٢ۣ<'�8��µ�o�F4#)��p��
+�AE\�������>X	N+���K4�'^3D4�7�"���\�dX���'\G��^lE����O}�Fk�Q[O<��u�zʩ��-Z��]���ij��������S��a	?��iq�L��H$�8�ۃ)�|��atytH�����F`��x��S����>��ͧϘټC_Ν�2��TIr�a%&A���7�Q�-ܓ`
+�n�%2?��f��H�a�ϓ��w�Z:�g��`XiC�h�ծ���*���o�Yz\3~�x�F
+cÇ��~���l,<��6v��q%�S�����8q��l��������d�����Dj�j�d=u��������uߺ��J>����o6ճSf��7
+���.�eo0��~m���7)w+���iw�f�Yu!C�V;��V�4 =�lش�y�N�8�Y��vFXao�������S����Y�[�֯CRڧǆ�F����"�D��+,a�Cau��zWJ�*�-��AcC���L*Vn�;�1��8ަI�-T
+x��P'��_�G��o����-�@*l_���q�#�a��r|t�J��̿MDВpz]��O�)*x�I��6��\`(:2K�+JC�n?��Mw�����ν,�E��EE���ӫu"���cF5������M�Q�S��l���xb��l���B�Zw�_ա�h�K6uy�
+�*n7��~�Ĉ~P�cc�A6 a)���-J�e%A�M9�c��+�v��?�q�po��}��w�+��u�kꩧ.�A�c��#��(��p�z�^���p�Nȅ-���E����+:ē��
+3yt�O$Ϸd���a�#+W�4f~���t<\�j�
+�3��-th���ng�bH��D����h��X��j��x&��#N5��]>�oՕ�A�h�d��挳��+���
+u�2�q�OM�R�?����WP
+(WI�%�l'm�H�h�6��%|*���I��o<ʌ���v4�tKr���g􇝉<q¬����v��m�x�+��l�~	<��^��v�- ��uai�=�%�H��T�1�Hǰf=̾ŏ��S��x�Ē����=�	��u�1zDq��sȉF�N9����?�ci|��1{
+�A�,i����NG����`0�hT!��<O&.Z�	S����+�O�O��Z��l�@���`wj��� �S4�r�q`�C�~�Wk}=��˯����þ	I��VY�Þu��=�
+�h���3+�=p9ܮhq�5�0�Z:DP�$��C�9���%u?����Ӽ���^�	�v��P�h���f�*(����˥Kʰ�!�2�Fmv�GKY��@A�p7�L��A���p���)9�q�SG	���-4�9WA՘��q�d'�`��J��ξQh�>��Y'hC�����m1���4��,���U��[��9a��2wڴ����]o��;$��I���g�MlZ��l�۟�
+~`ş<T�SɅ8�Y��z8�Gީ�y�s��Mp�5O?�L�TkcȮL���O/�xc)��{�L�Bv�x�``�r'��O��h3�\FH� �L�q�1%Z����Zl'��a�m��z���o���sCz;�Fb�)��+6\}�4n�B�<��g�A�rk�>��«R���G(E�JSYϱG��H?[�"9�7����\$X+H��(�F���&�t������SUo}��i�X������~��]�>p+6����|��ؔ�ݻ#��a"��x-D�g�v��X�p��I�T,���h�D*�6�d��x�4أXJ,�DG�QԵm�"/
+S&�Dm�}���*-�J��>�SM��d#N3+�t��u�u��7}u�����;?��x����b��baB�@�2J�r�ᄐ���<�B"��u�a��m��Ї/8up��[tU�+ M����vg����i#X���a�^�~ yF��ɑ�ul�E�#���6O��&����{^�F76⠼8�~� �!�M%���4I� �"��%������>G�[�v-�kb}� �$��<|j,�6)Rpµ�^�k��)�ة���n�T�+Sx�NZ*ƶ��&5e�4�v���Ѓ\��)��%�6�E��٫��M瓜�J� gh����p��uԑ��A�2\� W���� ٛ�i�s��z$�����G���=���3sU��|������o?�/�t����Sch�M� �VZ$؝XvԝY��-ˬ6T\�]z��[�qL��W��j|ūǮ+b���;wU{v�h���2?�O�[y�B�\��G�⢁�	F0 �M�+�B���4$Y��|YU�"OՈg>�G��?G�1~�ϣ6I���c�"'�������>.%
+��>�re�&�q)M�|�a��y��c��w�����{n=XS�k������C��F��A"m\L�A�Նg4���G�L߹�j��G��ư��A��?�0r��l��N�WMkI۵11�M�eѡ�t��H~}v,r�"����УDu��h�*��gt��Æ���(�b��ތ_T�WQ�K&��5�����%�lQ�0��&�=X���qр-��>%`w�v�����(6R�8dߴ�AZ�m��h��ŋ�f`���v���V;)j%ٕC~8�<w�:�Mp�A!T�$��j���6.��y�D)��[p��B*6A>�1a���\��R�@E�D��܈S�&�(��ۣUz�y���q��Mg���:uZ���}�Z���B`1��
+�ʙ>m�I���&��̌�knȰ,�N��gZp��Wq ��g�X:� ��j�iS�"����J�[��'EA�Xm���;��!'|(6�(h��~ff��=�y��>ƅ�⁍A���k�3r�=ae\i�Ú����Pa��9�2Of{�,t��v��?J�&k鿣賓� 	�g.���-l�4-qF���z�@G`w0��(��oY�TF.J3�̜,ZI���3�+�|�!'�!��(��)�R�+(p>��"��������,(�����Лe3����Õ�0DD�E��{W>���p�j����{��[�YE�N,�qɕWk5.�%WD��&�3%var��ִd��&�X���M]���E��W�ǻTG�I�>Q����D`ۋ.��=�O�R�NM�x����40�r�+	�6�y$�u��|h�ŏv����'���+{K,%ı�ei�-Я2��! �ٟ������z0h�M����\t��pF`h�Xl�K�q�)�+�a'?m��-��bM��=��9�9ITp�d��]���V�����o�k����aI�3?q^u��|��裡D�hly008�geE@$�;#��]V(N������gW���C�S���_$`�7y�)ŔX^�/�:�V3+2훘���Cz�e�>�G�J�^'Z%�Pv<�p��sд.�+eY�e�H�J<Ef���%d�	���x1&�f�@*J8VvX��	�Hi`�<�&0���8E8�>�x�l�s���ubt'������
+�:6{Bm��0��K�!-5ɢ+FU�,�]�b� ��k�T{�����q4��i��L�8�{�����������y
+���s�U�Tg�s�t�Gz(̄i~X�(1�r�_JL��Ϟ���-�\!��J�����ɼpR���"[vj'=:()�9�u�M�Y�H<��!?:�O،��N����7�����N^���{5������6b��K�b�h(�
+����T~��K]���bR�m[�'�2��Dt�,���+�=�IyC˳�`��?q"}/^���HkL2�.[���"(n��qň!����-v��8����0+�Q��4.�Le��K^����G��4����Ͻ����*�Z�ga[�_:0?4���%��7�!�l��զ'�{%=�45{�~͑޾�	I�H��U~�o�he�����O��g�z��\��mAW��ȃ���y�H�))�wy����3��0�؏t+�c�`5����J!��M�jS�E[�}�����"�<\::a�g�h=r⬣s��zȐ		>ɦѺs���.��ɡ�ʨu�z"4'��߂�����%`��O�V�6��6_��--{�M��w�g�v,�w��)z���j�^/.F�?l�fti��٠]n<@m����(3�b�B{�OбS>N��)�H^��A��·]����"/p6�1��!���v��f��+���q��$���/��/�8��D���/�ӾA+n�̪Y�ZR��V���~����z� �a�6�����������t�Z���S]w�� ��$ծ����@<��]ІN�a(v³��!�F��MF�+md������d���eĎ>f�B	u=��P8����i�q���<l~l�ba�姝��=C���7Df�����JV��H�]����]w�� y`���l2��F[���Z��.�����86��
+ +���B������Lɂ��!h#[�7�Ff*�[T[HVf5Q�N��H���ް��jpc���n�E_��\t�Kd�5��_��d��AMB�O�����dKI�ˀ�S�FI>F��\A7p��c�G�*e����׌���x�X��������j�5Qk�'#�,�;��ȵl� �t�&�K��
+S,R�U�t��ӡ��cz=�/����q��LZ�{[�c��8��]y}����c��$O��<���F$}l�Ύ��8���	fDG.��+�l�B^����#y���Kh{%X�~}Q)�H�+�ltm���m~]� U���@J��9.H�)'r���Y$�B�u~`Xx\y%HQ�(�?��0aV�SD�B6���V�qv���+=�U�Gȗ�/��:M˞�QG�Y֣p�Jk�d+�iQ�XY\ٹ�e
+����rA����TcMbI�� 1)* ��ɤ�ľ��;�b2���)��n�)�Mu���b�3�I�n;)L�MӀ>n�d�eb���"��1��XG�A������>8�'����3�l���/�^�a�Yd�eX��u��
+G���j�|�Ym4W�?
+�c@�h��=S+�8�V�**ԡ����	�^�������S��껚�{�}T/�����hԕ�z]{�g5F?���߈9b�x&�<g��$���')'�+R��|'OF�����?�G~xǝ�n��z���ҷ�n���'��f�}7J廎t�x����}�a�T��x4�}�xS��Ɣ�n\?�k�%
+ʹ�\W�S7��g���e�Nokf���O�_^:��N���԰�S��d&����`����¢<�����_��Y�f��a5EX��Z`џh�O{��P
+�g�>�")Ms���r�8�Ai1���bEU�2�H�e��r74��p-'C$�ϲ�9j�>�[Hџ:�ܥ%D�bP�me4V�G�2 -���tTG-^\}��HN�&N�����TϽ�b��.��x���1�׽�ӟ��͘�ƁMh��N��``�٘��*0�Gvc�}5TT,���+�����3u�߲eS�c}=;�(!q�5W�;n�]�L�D�IBU�ã��?����@�	���$t�E,��Ȉ�E�&�,�"�+�:�1S�03	
+��ˈ�p�J��똳
+�7��F�w5#�z�B�q�����;���p*y����uv5K/�p�C�,�j�g�m�	�a�@�q%}I��ho&+W6�qz�E7\�
+�++�c,$�C'�$HF*��K�Z�W��M3fQ]|��v"��링 =���U�
+��>L�A�q�+J&�1L�m\�""Rhg%�+?��j�&�KU�?س�ڢY�.Ya�t�W��B��a�s9{B1�-��-�>>�# 
+���)r��IՎ�X��.=�w@�z8U���%�G�:�1�G}1*$yE.�Ь�=�/��E��r��(s�O�,�ƧѠ�VW�����#�t�/��=�c�ϸ�@,Գ��!�%���ZI���K��7օd�M�jS�2��J��D�r��
+{���J̓��9�K�ٿ�ߤ{GT��.jm��]J���7>���4Ȗ��؇@��S�/��2�@)&>k*� �	qTJ�D�ۣ2�V�_*���ų�؆��!i�o����BE3K?������9H|�c�Uu����̬�h�/>�5N�L=�>R�@H�t\����DM����A���|�����h@=�sfE ٢'�;괝�y񑍊L����$}fۉ�g!~W���Nt@Ǿ؋-
+j�ao����W���1c0�ͱx������އV̵n���V�N<yy�T���{'�r�UF�b'u�������c�R�p(��G8�!��Ǜ��#�&!M�И��8y��W����EDn7r9�K}�w�kQ!���#�L��]�vm��t�%�m/Z�fM�d�ڹE�2��}Tv���j!uP�,��V�>�#���g�,y!���)/ϰ��;�+at���yw�/~���wT�������5�N��쎆o^l-���D%[@�
+�h��Y3�O���3[�Ag+��� �S�<�z��7�5���Jǀ��p���D-A��~B��B�����D���)T,JJ���'�W�{�n���a���$���~�Zn�C3���O\ri]h�?l+�؈I���u>�-��!߾J��U��5�����E"�N��3i�ep�3�v"�>V���+��h�[�ɣ賓�$��<bևI�e����2���w��S�)�$X\*�݊��	�Q�K����K��c��8��ƙ(�d@k]ʯ��*�p���ߟ�A���l|4�v��@O�o���	o&�p���m�{�J�`��>����f�ǭ����@D��ai\� ��#D�۸����ox���k��]}�O��Si�����?�?�wBqȩm��4xt��F��R�lJ{����?��6�)�J��נ�N����}����}�"t5�Į�l��T�/�P��6���v�Xy��8sA:�8+��`���"�<��uc��sew�9��v����֬�Ī�t�2U1G��B��\lE�����u܋��WY7Yt܋��+ dx���x�+�M��Cg���P�,{�+�Ϡ�U����(v7"jL�U���+Ec��G��ӲSW�W�j�f�q6��V#	0���#��ہv1���^j�P�ĄȰN$��@�bo5�н�rL���ט��[��ڎN"/8���ȶ�x�l'�;�9�)s`�L����-�YA�X�J�VH��^�'B�r-�v�e�U�]zi�^���f��	�MS�����)���uY	fc�\� l'�6�={���lE����@��'��&'�h�fI,)��P���}��۷���+8e����Y
+;��)3�1
+��bJ[m�v~x*�i�+L<d�d>�
+m�$~�n�Fk��(6�r�E�l������/�b?����%;y��o��/�O{A1q�-��`0�[��ɯS8t�_��~��a$~#�j�?�BX�O}�n$lA�������.mmC�L���4#+N��"�fA��I�>�8W��,$;�x�9�Y"�dg������z묓�8�\ZJI���'-?�:W_�q$�P��I�d��mw�!�n�J�NAy�|d�G`ц�d�;�NЗ,A��������QC�����Pl�>�x��A����gȑK�}:�|����P�H�wx@i�ȂA)y�+���e����m6䚟x����/(Y
+m�~��g��C�5��&6b����(L��<I�]Q!D��K����@�&!������"#�`S��ȹlz!�}�=��@lo<�È�.�r��L�p+l�%A˹+���#(!8@o�X_!��+���}]@��s;!�Q^+|Vf s�4p�'P�+lCp�l�Cd��(J��yS%J��&�!��\%�I<�,�.2��Q�)��	,)(����~:m������F��/��(Gܴi3�.�+�jp]�/��b�	?��ӫO\|���`$>v�|�z]?/��L-t6�:W�LơH�E�����&!�+$�}��ܖ4 �'(~���U�ȡS�8�(����װ�m�.&!�����Q��4Y˭����w����På#내��[��:d+��B���!W1m����U����i�i�'ݧ�����w���?��M[�ҪCy�� �b�p�uJ.�^	GA�Sy4b
+�sB8��y�ļ�*��(�V�!D��`�O\+J�L��z`��m4
+����!W����O���+��H�1�S�_���J}�\d����B�E
+_��?�&�Z��S�����f�f�	̉����|�+˫���+Zz9.��z���~�:F��IP�I�<�}T�{�ƨ�2L�B[̐�<��Ф��=�D����(�e_��P��G���+��Q����@���U�r��"���:^�q�EA�H6Mu��ne��m+B�:C�_̳�h�3+$��q��5A�H6��6�B-5_���N�b-÷�>��|�Ń(��p�@�3���=�x�~'���9g�`:�r�$^�
+�ƣ��YM9���S�Ez���h�PdH��D���s檰��ۋ�r���r�p���Q�y��|�w�/����t�L�L��F*��@�ڷ�Smқ�����<�L�{�n�F������^m~te�z��A���_/l0e�m)�����ɳoԆ�	�!F��l����2���:m��OO�9��2�f"BI!;bW(�u��Y�p)O����Y�Q�T�gp�% vi�E��2��ό-�!����a��.�b�I	�8y�fr�i��[��׺gkN����#��*�c�6MK|!� q ی|�rѕ?��Ң�4�2V%>�p�vT�O��0+=Nġ���-�)���"�)��V-@n�\/��f��n���Z5��`�h�����8�\?��5"/hT���������M#���N_��Tb�J�}.��$���=zܨ���1�VCw'}\��d��xB�̃�B�:8��+�����@�����sEO�T�+]	���o�e�"�A�%q�5Jc�`D�3�]��ESq�
+	-@߭N�+g4�X�$��{�ԉ�bu�9Z�g�:�����Z$l�'r6�_i�������.�~�?}�Z���_#b��7���j�^J��9�&��>���d�wXⓜ�����5�s��}F�v���!d9��Q�G[1(��3?A�����#;��ED#��^L��F�5���J���rdW��}D E�L�����؜���o.�2�Z�:AR��M�u*�az��:/�o�D��Tq@���P��B�f���� �	ב�}�h�rT��R�k�
+�{�p�=�2+P�rX1aҀ�̧�Mқ�W���9^�%�Ҩ���%�V�����_�zu�~-�c�j��	Zrl��H[�A#4�5�qQ�b�\@�ܔ���!1�/#���l*Z���sw�@��ԟ�U��
+����N�}��0H�()0��\� 9vB��<� 8C`��j@�0����"��mÝ�� �3H�[��z�2	;�(
+C$F�+��"���\�}	��0�H&��p�k�+� 6��wm}#�J%���gժUZIzۚ)S�,J�����&B�"e��38�~��$�M)*G���E]$� �KN7j��
+�W�ч�J�Y|��n���W�����5�]rLu���w��c��t�ywǮj�/_%�ʒ\[�6�#c�|��N�ɑK#�(,?�L���~Zm�}sJ�,����كj���g���Z�h�n�U[���V�@L-���	ڬ�Π/�fC�Bo�M�AD��+Ԗh�x(�Q6�ǫ�z�I�S�G΁�uG�<���E�D��J=��=I==�IT|�i��<ۥ��Ў�F�PͲ���\qj5W���]{�-{���S�����xY�r�N��b��iӋ���Gqdt)�)�Y#�������@.	���!|ĉ_&a5an�`�������3g�,KT;�9zeſ�W��l4���f��j@^�P>�Ԙ�A��2A�Lf�����u^yuMOy�Ê6��[_�T|Eg�%�Us���6�u�P4��"�Fj]u!�2[�#B&M�\�)�:��ڴA�ZQ��痂��}N�*ޯ�,^XM�YP_��ƂZl��XD�`lx��A��]�^�Tv�g�|��1X4�v���ub�s.�8�5�bUS�b EN�޶o����ԡ��Ln��f/Ѿq��j�W�.M����[�V�ּ����܋��ͩ��vf�I�������0(h
+�
+:���K\GtR;F�5���}�Ց��z���ַ�u�r6jc�0��"p�I:�+�7~�N�~m[�N��U	��n���6�$u�x��k{��N;��^|�e}������Iv� �c��k�n	~��K��c�T�*���~��\ɮc�M[�NY�C���n����a���#�!��X�-�QZ+A�~�x�}�}_�n��+�x)|�f��"#+|u���<t����}/g:�\&N�P�׫ʬc8I��{8;����-$cd�bQ�|��5�v ��c�&Tc���V|n,����s�c,+���U��@*�ѩm�~
+ݤ�;Z|�ˋ�V��&4d����̙�Z;j��j�^b"^�����!($A�#��Ѓ /UR�8�OB�9jo5o��{��O��F��D�+M���􊙙�� �u���p��E��Ԍ5���D(?�++����Ez�yk������9�S�'�λ��Գ���Y�m�Z������'M�s�O�֨��(�G�ݼb��+��<q ۍ7�����zJ��gf�f�Gi*!�����RI�}�[��r��IN�Raۡy8�`IL`g��ҒI�6��,f]Bba��)KXԱ>>��T(*�ӦM�,��,
+B!�&hR�'.�	v�J�����Gh�9L�+�N莅(��Ӵc�e����������i�ZhUW�\u�o�뗈��-�@�%ɯ�Ŧo~�_uk�u}]��j��1,��o�c��zh�pct���D�7�!��1�_��5�(�+�48�[F(aQ42p(@[r*� ^TX�f�e`�9uā=�غ�Ř�]��%�q�&t%C��Q���>Z�y��l���ʑRݒŋ�z�nJ��{���N*݂�������#���e�	�}��V��_�E�I�r�A��(��pͨp�~�j���?s}5K��ʪՃ�
+|GݭZ��o���;~o�E~O�,:�1X��s3���i��YT+�+�;Ta����GŃ����+Yț2y�s�D-k�۷GW/�8KdN�1[��
+�\�n�#.��(PT`�-a?��	0�SX�����(�w �w���{]��K�R���y����'w��K���"JD����@'�}5'��e˖}�`^IӴL�d�δ]��%����&�+�J��"fQ��t�Z3��0�>
+�[��5s�Ω�1����85��
+|���I7��Q�?Y��f�R���)r]��Ŋ
+,���Z����t���.3��Z��کEJS�;tX��G�+��T>����EGk����}��Ӱ��^l�v��\�����)�O�}��j�:N�<Ek��mɘj���f�6�r�5.�l)����5�mz��{���$���as]d��n�����2���8�k.�&i�� ��M�,;V6���\5��Ǌ�9�\�����!�3�\{�� �^��Rٕym|���ڵe��q�E�9���K:�]O��k+�z�q�]x���rl��Ty���D�e"/��4�3�� )+HJچ?�l}�ߢءW�v�i��|պ��F�UT'�~��xit���ː�O?�a����������/�g��K��vӘ�߼�D]�s�i�!���2�u��ꪗ�-z��׿�tu
+���Aa��ĳ4�32�Lg��a�nx<�'Qq�<�q�fM��b'6n�6j	��hJw�O�dHdp{g�哟���i�ᭈF�+|�#��&�F���fu���ռ��l1�@����O}�S����>,2e���
+�A�[��CBG����w)���q�c��[��w�}��}��W2=3jr��g�������+<({ˇ0x��;n�ֿW�miSG5#�Y�_X-׌�&���8TF����*68���{��3���c/�>��/Vvu~3�G�AR�M8?+��� ����!�DE��Z�k�2l��C�߶��û��o��Ӣc��.��:�P�/>C�80RW^W_�%�~`�L]��~�����^���ꫯ�;Q��v�/��~���D���p@��=��󯂸{���ƫ�;JcGVD�l���"-H�,r�~`�;<I�S�t;0y�4-ȱI�=�eg��u&[|�q���}�Z|�q��L�l�r�`r�f�1�Pr�.�I3Άg-?����+.妓�Q�nRoi�c�б�
+온����Nת�'h�N�S��١��>35.��	jHÕU��зۄ����3Sqg�~��ʫ�PQ?9W[u��.�vt�~�8Oӹ�8��2o�Wa���l��5�&k��U�]�5��L�W�g]I_���n�m�SB?Ж����?���=�4��#�?��$�+�R�����N+A���o�����s�?�?Ғ<>(���@bd�%^0���++�(S)�t	���)Z��<�:�c�/�s�9���8�3U�3?�+�N���R��[;q��|)�b0 ����*&��gV�/zP3�x;���kٙL��&��9�Nx����~˫^�����6i��X_~X��w�T�qȄ�&�o�8X�OփT��p�>B_?C��8�fO�Z��p�lc@����qf������B��}^-���v=�(���āN�P�鑩?R��#���m���>��:�럍��;Y�� S���b�����E�ِ�ơ�a
+���b�[��f)0R����eK�j͂�e9�R��������{��_��׿Q=���գO<�@��Z��O����F	�0�C��R�'T;u]K�mR���m�}]�~>**f4u/�s@��݈:d�p\�<��in����Gw��QI8;?0=�H�=��#��o7pwriK�c��K9�+?��ӫ),3�J����;��0/&���4;a�'Ѯ?���:�L]���L��-������;4����C�VͧH9	-����;��4��?Smy����Έu�ܞ��v���&}Dn��V���G@*&+'��=�+y?�ӆ��^3�+���i�@J�+Jh���!蔧}�����<�Y��0�8
+i����ˎ���w�z��]m�L�@s��	�֗��Hm�uzg[�΄����e���i����3�W^}�y�+)/]vr��p�_� \i���z���?��_���S���ځIY����/}�Z��%�����(������ ͡�r#/;��8��>��l��ˮPpH#�qrX5e�^���$K��du+��g�C5 $�����Xӵ���*O[R���Jx�f��6WO�_[��F��|�+�+�-	ƪ<LD�ɝw֜YWc5q��o�z���XԄ��m+Pv��, �������΄��`����3�mrpRB��l��2�k��0�[;`�m@dA��~����ްZΖ�^��9L�?񘣽H�^���i\'�
+�4)�ZH��#Z_o��	����~�h�c���')���Ϭ��H�`!��m}���zS�+�P�Ƒ���nnid��Y�q�����C�O�k�@��!��O�{�	�+k%��hƊSN��ꜥO����;+��t�_�G��)+O�~������!v���'m�ٍIWT����������;L.;�ԫo���:�����Q�t���7\�p�t��Q,4������%��o��~��{��+=��{���b�Nȓ��������=��K�H?Δ:�I��cU�v�"���>��s5L��gJ��o�했m=w��Ѐ�!c�@Rz��4Ѹ����F)㋪����"��>����5��#3|M��������i��?Q߿�s�|G��r�kv`�-llۑxĖI=�^z���4��H�-e�{���TL��p��|��z���<�%��MX�7��kQܯ�[���( ?;=�O��7~���+��Sk7�٘g+��G���Бbf
+y��h t��6i0��+=y{�Gn3Xp���^���]�6�e#)R�!c���L�|�q��Ügy�D}s��G��|N��~��=tr~V<��OT�]~Eu�)�V�g����dF�����DJX���?#��8q������v}$�79�}��_���>y׿������3��>�ԍ�G�}l��
+p[�BK>������H�w���Nя�<��(\K���d�$��A�쇣�7����Ǯ����ݾ^}�_~׿^�:3�ז8�2 ������3��}��n7��P�Gy�&=ܾE4L�����ĥ�L�~�	�9+I��ml�B)��7P^G|�J�{�,?��s��@{[��K��{gcWu��
+l����C<0ARGj!B�@J�tDw$�� ���D�R����nAaJ:�J(�&RC���0����v�y�UN��>翵��ֹ�\vMgU���{���u����O�F���bT���wh����IC/Ll[����w�'��nx>����Ξ����|+��jc�V.|N�(L��
+c$�
+e�{<�Qv~�6��
+��2�̥�$u����X!O��sy�����\����e�������n��̄��=&����d�wӦMϟ?ۅ^�9m+I������~&��L=PY�L���%���4�X$����~�>��<�_�Ð��r�_6��&��!���4�ʩ�!�ԣ��
+�l4����7�lYZ*'0�����A9�K�h�Ɇ��[�#�S]������wZa/��2���L�G?3Wr��.*VF�+�8t�%x���{�k���_��}���}�χ��{�oMwy��+Z6�i���2�z<)�exAE����J�ˤ	*=�@s?�x�F�����S�������Z)�ڧ=�Ǿ���9�m۶�^�֕*.�E�{`����
+ګ;.���+���i:$��{�齆G9��؊��ioQnkˉW��*���v*V�6S��`��V�=��~�g�#���X�u�7p�^�q����&�y��W��k_���u���T�����V��M�H�Ld=�h�e�fY������?�}�ƍt��2"�2�F%�2|ᑡ^.�ۆ�w�m2�+I_?��!�r+B�3̓v�Y����^���ģ��vk�i���_(�J�gɿN���.�u�]�w�^I�u'�z��#��K="�����	?F�sݶ+�44!�����c���P_��^��zv n�V!&}I�u^��A^.�/�ښ#<�+
+O�̙K`�1�
+N1�p���S9?(;�@��2-�$f�$B
+)�(y���H��n8����X
+�����m�9I��P�?�����.D��R�5���;���o��y�W~��^�û9eM.����3?,Ӟ������v��|�[�/�F�|A-1�|��s#�<LT`���+@�2|P_$�\uX@KҌ-MZn!�=?W/K������@G�v�.قC�Er�_��%��T�~�����(mT׾9:��zh~[�>"<�s��7���믳�߬`�Wq������>-�G$C�<�!�ޱc��}����y睷_wn��!A��!x�I��K��u��)�����*J�4��P��j�u�A���WaN�R�#�z�ˊ���B�\gQ�e>ؒR�h��/d�~QοǪ���g���g醞9���.;m����%������7�abݒ�{~+��*��V[���1¤��/�M�ܶ����|�����	��h�#�^�%�G�:�J�?��O����%?��ys�A���Iw+��_�]��Fv+���I���)ݢ�bS�TW�-Ж�.92��S���k��_��iJ����y����P͏�����O>��d���+��*܌��|<����������O�6�����#G���$�z��1��� U��t�b��{/��G��+V\{��	�׭[�9.#z���6�D��m����;Z��|����i��^{�?�㯛~��_m��'�2N���|;�G�{oo.�3�<�g^�;{챰#+N˹�Yw�ʟ.gp��W_��+�X���y:y�V+�[+�]�y����U��H���ϕ#����}
+m��ի���yzzq��W�/1O_HZ���<�w81����������Y�!œ�s���=����G�~���+��v�6mڴ[/����A8O�9�f F��<��u�v�,���^�I�P�#�q3H�`٠'n�ஊ�iy9��Ʃ�;q�!��z �yn�X�@�
\ No newline at end of file
added in remote
  their  100644 d35e16d082e6dcaf15a9b58126f2770d5274bd70 electron/browser/resources/win/resource.h
@@ -0,0 +1,15 @@
+//{{NO_DEPENDENCIES}}
+// Microsoft Visual C++ generated include file.
+
+#define IDR_MAINFRAME 1
+
+// Next default values for new objects
+//
+#ifdef APSTUDIO_INVOKED
+#ifndef APSTUDIO_READONLY_SYMBOLS
+#define _APS_NEXT_RESOURCE_VALUE        101
+#define _APS_NEXT_COMMAND_VALUE         40001
+#define _APS_NEXT_CONTROL_VALUE         1001
+#define _APS_NEXT_SYMED_VALUE           101
+#endif
+#endif
added in remote
  their  100644 fda3f10fa6cb481d4d2909d145737a9cd27c2027 electron/browser/ui/accelerator_util.cc
@@ -0,0 +1,100 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include <stdio.h>
+
+#include <string>
+#include <vector>
+
+#include "electron/common/keyboard_util.h"
+#include "base/stl_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "ui/base/models/simple_menu_model.h"
+
+namespace accelerator_util {
+
+bool StringToAccelerator(const std::string& shortcut,
+                         ui::Accelerator* accelerator) {
+  if (!base::IsStringASCII(shortcut)) {
+    LOG(ERROR) << "The accelerator string can only contain ASCII characters";
+    return false;
+  }
+
+  std::vector<std::string> tokens = base::SplitString(
+     shortcut, "+", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+
+  // Now, parse it into an accelerator.
+  int modifiers = ui::EF_NONE;
+  ui::KeyboardCode key = ui::VKEY_UNKNOWN;
+  for (size_t i = 0; i < tokens.size(); i++) {
+    bool shifted = false;
+    ui::KeyboardCode code = electron::KeyboardCodeFromStr(tokens[i], &shifted);
+    if (shifted)
+      modifiers |= ui::EF_SHIFT_DOWN;
+    switch (code) {
+      // The token can be a modifier.
+      case ui::VKEY_SHIFT:
+        modifiers |= ui::EF_SHIFT_DOWN;
+        break;
+      case ui::VKEY_CONTROL:
+        modifiers |= ui::EF_CONTROL_DOWN;
+        break;
+      case ui::VKEY_MENU:
+        modifiers |= ui::EF_ALT_DOWN;
+        break;
+      case ui::VKEY_COMMAND:
+        modifiers |= ui::EF_COMMAND_DOWN;
+        break;
+      case ui::VKEY_ALTGR:
+        modifiers |= ui::EF_ALTGR_DOWN;
+        break;
+      // Or it is a normal key.
+      default:
+        key = code;
+    }
+  }
+
+  if (key == ui::VKEY_UNKNOWN) {
+    LOG(WARNING) << shortcut << " doesn't contain a valid key";
+    return false;
+  }
+
+  *accelerator = ui::Accelerator(key, modifiers);
+  SetPlatformAccelerator(accelerator);
+  return true;
+}
+
+void GenerateAcceleratorTable(AcceleratorTable* table, ui::MenuModel* model) {
+  int count = model->GetItemCount();
+  for (int i = 0; i < count; ++i) {
+    ui::MenuModel::ItemType type = model->GetTypeAt(i);
+    if (type == ui::MenuModel::TYPE_SUBMENU) {
+      ui::MenuModel* submodel = model->GetSubmenuModelAt(i);
+      GenerateAcceleratorTable(table, submodel);
+    } else {
+      ui::Accelerator accelerator;
+      if (model->GetAcceleratorAt(i, &accelerator)) {
+        MenuItem item = { i, model };
+        (*table)[accelerator] = item;
+      }
+    }
+  }
+}
+
+bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
+                                    const ui::Accelerator& accelerator) {
+  if (ContainsKey(*table, accelerator)) {
+    const accelerator_util::MenuItem& item = (*table)[accelerator];
+    item.model->ActivatedAt(item.position);
+    return true;
+  } else {
+    return false;
+  }
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 8f9ff638dae03e61d762a31715c01d317a1c0498 electron/browser/ui/accelerator_util.h
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
+#define ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
+
+#include <map>
+#include <string>
+
+#include "ui/base/accelerators/accelerator.h"
+
+namespace ui {
+class MenuModel;
+}
+
+namespace accelerator_util {
+
+typedef struct { int position; ui::MenuModel* model; } MenuItem;
+typedef std::map<ui::Accelerator, MenuItem> AcceleratorTable;
+
+// Parse a string as an accelerator.
+bool StringToAccelerator(const std::string& description,
+                         ui::Accelerator* accelerator);
+
+// Set platform accelerator for the Accelerator.
+void SetPlatformAccelerator(ui::Accelerator* accelerator);
+
+// Generate a table that contains memu model's accelerators and command ids.
+void GenerateAcceleratorTable(AcceleratorTable* table, ui::MenuModel* model);
+
+// Trigger command from the accelerators table.
+bool TriggerAcceleratorTableCommand(AcceleratorTable* table,
+                                    const ui::Accelerator& accelerator);
+
+}  // namespace accelerator_util
+
+#endif  // ELECTRON_BROWSER_UI_ACCELERATOR_UTIL_H_
added in remote
  their  100644 5f97c127bc59d7e1d1d0c7874d55d8fe517216ce electron/browser/ui/accelerator_util_mac.mm
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include "ui/base/accelerators/accelerator.h"
+#import "ui/base/accelerators/platform_accelerator_cocoa.h"
+#import "ui/events/keycodes/keyboard_code_conversion_mac.h"
+
+namespace accelerator_util {
+
+void SetPlatformAccelerator(ui::Accelerator* accelerator) {
+  unichar character;
+  unichar characterIgnoringModifiers;
+  ui::MacKeyCodeForWindowsKeyCode(accelerator->key_code(),
+                                  0,
+                                  &character,
+                                  &characterIgnoringModifiers);
+  NSString* characters =
+      [[[NSString alloc] initWithCharacters:&character length:1] autorelease];
+
+  NSUInteger modifiers =
+      (accelerator->IsCtrlDown() ? NSControlKeyMask : 0) |
+      (accelerator->IsCmdDown() ? NSCommandKeyMask : 0) |
+      (accelerator->IsAltDown() ? NSAlternateKeyMask : 0) |
+      (accelerator->IsShiftDown() ? NSShiftKeyMask : 0);
+
+  scoped_ptr<ui::PlatformAccelerator> platform_accelerator(
+      new ui::PlatformAcceleratorCocoa(characters, modifiers));
+  accelerator->set_platform_accelerator(std::move(platform_accelerator));
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 7336cbf7a046880e7f590dc7830b66d93708917b electron/browser/ui/accelerator_util_views.cc
@@ -0,0 +1,14 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/accelerator_util.h"
+
+#include "ui/base/accelerators/accelerator.h"
+
+namespace accelerator_util {
+
+void SetPlatformAccelerator(ui::Accelerator* accelerator) {
+}
+
+}  // namespace accelerator_util
added in remote
  their  100644 a339bf14dedcbb54455329cd092f47a13149ffe3 electron/browser/ui/cocoa/electron_menu_controller.h
@@ -0,0 +1,62 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
+#define ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include "base/mac/scoped_nsobject.h"
+#include "base/strings/string16.h"
+
+namespace ui {
+class MenuModel;
+}
+
+// A controller for the cross-platform menu model. The menu that's created
+// has the tag and represented object set for each menu item. The object is a
+// NSValue holding a pointer to the model for that level of the menu (to
+// allow for hierarchical menus). The tag is the index into that model for
+// that particular item. It is important that the model outlives this object
+// as it only maintains weak references.
+@interface ElectronMenuController : NSObject<NSMenuDelegate> {
+ @protected
+  ui::MenuModel* model_;  // weak
+  base::scoped_nsobject<NSMenu> menu_;
+  BOOL isMenuOpen_;
+}
+
+@property(nonatomic, assign) ui::MenuModel* model;
+
+// NIB-based initializer. This does not create a menu. Clients can set the
+// properties of the object and the menu will be created upon the first call to
+// |-menu|. Note that the menu will be immutable after creation.
+- (id)init;
+
+// Builds a NSMenu from the pre-built model (must not be nil). Changes made
+// to the contents of the model after calling this will not be noticed.
+- (id)initWithModel:(ui::MenuModel*)model;
+
+// Populate current NSMenu with |model|.
+- (void)populateWithModel:(ui::MenuModel*)model;
+
+// Programmatically close the constructed menu.
+- (void)cancel;
+
+// Access to the constructed menu if the complex initializer was used. If the
+// default initializer was used, then this will create the menu on first call.
+- (NSMenu*)menu;
+
+// Whether the menu is currently open.
+- (BOOL)isMenuOpen;
+
+// NSMenuDelegate methods this class implements. Subclasses should call super
+// if extending the behavior.
+- (void)menuWillOpen:(NSMenu*)menu;
+- (void)menuDidClose:(NSMenu*)menu;
+
+@end
+
+#endif  // ELECTRON_BROWSER_UI_COCOA_ELECTRON_MENU_CONTROLLER_H_
added in remote
  their  100644 eb3578dd4b2728cbb20aa7e531620f7bed9f0625 electron/browser/ui/cocoa/electron_menu_controller.mm
@@ -0,0 +1,273 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#import "electron/browser/ui/cocoa/electron_menu_controller.h"
+
+#include "electron/browser/ui/electron_menu_model.h"
+#include "base/logging.h"
+#include "base/strings/sys_string_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/accelerators/accelerator.h"
+#include "ui/base/accelerators/platform_accelerator_cocoa.h"
+#include "ui/base/l10n/l10n_util_mac.h"
+#include "ui/events/cocoa/cocoa_event_utils.h"
+#include "ui/gfx/image/image.h"
+
+namespace {
+
+struct Role {
+  SEL selector;
+  const char* role;
+};
+Role kRolesMap[] = {
+  { @selector(orderFrontStandardAboutPanel:), "about" },
+  { @selector(hide:), "hide" },
+  { @selector(hideOtherApplications:), "hideothers" },
+  { @selector(unhideAllApplications:), "unhide" },
+  { @selector(arrangeInFront:), "front" },
+  { @selector(undo:), "undo" },
+  { @selector(redo:), "redo" },
+  { @selector(cut:), "cut" },
+  { @selector(copy:), "copy" },
+  { @selector(paste:), "paste" },
+  { @selector(delete:), "delete" },
+  { @selector(pasteAndMatchStyle:), "paste-and-match-style" },
+  { @selector(selectAll:), "selectall" },
+  { @selector(performMiniaturize:), "minimize" },
+  { @selector(performClose:), "close" },
+  { @selector(performZoom:), "zoom" },
+};
+
+}  // namespace
+
+@implementation ElectronMenuController
+
+@synthesize model = model_;
+
+- (id)init {
+  if ((self = [super init]))
+    [self menu];
+  return self;
+}
+
+- (id)initWithModel:(ui::MenuModel*)model {
+  if ((self = [super init])) {
+    model_ = model;
+    [self menu];
+  }
+  return self;
+}
+
+- (void)dealloc {
+  [menu_ setDelegate:nil];
+
+  // Close the menu if it is still open. This could happen if a tab gets closed
+  // while its context menu is still open.
+  [self cancel];
+
+  model_ = NULL;
+  [super dealloc];
+}
+
+- (void)populateWithModel:(ui::MenuModel*)model {
+  if (!menu_)
+    return;
+
+  model_ = model;
+  [menu_ removeAllItems];
+
+  const int count = model->GetItemCount();
+  for (int index = 0; index < count; index++) {
+    if (model->GetTypeAt(index) == ui::MenuModel::TYPE_SEPARATOR)
+      [self addSeparatorToMenu:menu_ atIndex:index];
+    else
+      [self addItemToMenu:menu_ atIndex:index fromModel:model];
+  }
+}
+
+- (void)cancel {
+  if (isMenuOpen_) {
+    [menu_ cancelTracking];
+    model_->MenuClosed();
+    isMenuOpen_ = NO;
+  }
+}
+
+// Creates a NSMenu from the given model. If the model has submenus, this can
+// be invoked recursively.
+- (NSMenu*)menuFromModel:(ui::MenuModel*)model {
+  NSMenu* menu = [[[NSMenu alloc] initWithTitle:@""] autorelease];
+
+  const int count = model->GetItemCount();
+  for (int index = 0; index < count; index++) {
+    if (model->GetTypeAt(index) == ui::MenuModel::TYPE_SEPARATOR)
+      [self addSeparatorToMenu:menu atIndex:index];
+    else
+      [self addItemToMenu:menu atIndex:index fromModel:model];
+  }
+
+  return menu;
+}
+
+// Adds a separator item at the given index. As the separator doesn't need
+// anything from the model, this method doesn't need the model index as the
+// other method below does.
+- (void)addSeparatorToMenu:(NSMenu*)menu
+                   atIndex:(int)index {
+  NSMenuItem* separator = [NSMenuItem separatorItem];
+  [menu insertItem:separator atIndex:index];
+}
+
+// Adds an item or a hierarchical menu to the item at the |index|,
+// associated with the entry in the model identified by |modelIndex|.
+- (void)addItemToMenu:(NSMenu*)menu
+              atIndex:(NSInteger)index
+            fromModel:(ui::MenuModel*)ui_model {
+  electron::ElectronMenuModel* model = static_cast<electron::ElectronMenuModel*>(ui_model);
+
+  base::string16 label16 = model->GetLabelAt(index);
+  NSString* label = l10n_util::FixUpWindowsStyleLabel(label16);
+  base::scoped_nsobject<NSMenuItem> item(
+      [[NSMenuItem alloc] initWithTitle:label
+                                 action:@selector(itemSelected:)
+                          keyEquivalent:@""]);
+
+  // If the menu item has an icon, set it.
+  gfx::Image icon;
+  if (model->GetIconAt(index, &icon) && !icon.IsEmpty())
+    [item setImage:icon.ToNSImage()];
+
+  ui::MenuModel::ItemType type = model->GetTypeAt(index);
+  if (type == ui::MenuModel::TYPE_SUBMENU) {
+    // Recursively build a submenu from the sub-model at this index.
+    [item setTarget:nil];
+    [item setAction:nil];
+    ui::MenuModel* submenuModel = model->GetSubmenuModelAt(index);
+    NSMenu* submenu = [self menuFromModel:submenuModel];
+    [submenu setTitle:[item title]];
+    [item setSubmenu:submenu];
+
+    // Set submenu's role.
+    base::string16 role = model->GetRoleAt(index);
+    if (role == base::ASCIIToUTF16("window") && [submenu numberOfItems])
+      [NSApp setWindowsMenu:submenu];
+    else if (role == base::ASCIIToUTF16("help"))
+      [NSApp setHelpMenu:submenu];
+
+    if (role == base::ASCIIToUTF16("services"))
+      [NSApp setServicesMenu:submenu];
+  } else {
+    // The MenuModel works on indexes so we can't just set the command id as the
+    // tag like we do in other menus. Also set the represented object to be
+    // the model so hierarchical menus check the correct index in the correct
+    // model. Setting the target to |self| allows this class to participate
+    // in validation of the menu items.
+    [item setTag:index];
+    NSValue* modelObject = [NSValue valueWithPointer:model];
+    [item setRepresentedObject:modelObject];  // Retains |modelObject|.
+    ui::Accelerator accelerator;
+    if (model->GetAcceleratorAt(index, &accelerator)) {
+      const ui::PlatformAcceleratorCocoa* platformAccelerator =
+          static_cast<const ui::PlatformAcceleratorCocoa*>(
+              accelerator.platform_accelerator());
+      if (platformAccelerator) {
+        [item setKeyEquivalent:platformAccelerator->characters()];
+        [item setKeyEquivalentModifierMask:
+            platformAccelerator->modifier_mask()];
+      }
+    }
+
+    // Set menu item's role.
+    base::string16 role = model->GetRoleAt(index);
+    if (role.empty()) {
+      [item setTarget:self];
+    } else {
+      for (const Role& pair : kRolesMap) {
+        if (role == base::ASCIIToUTF16(pair.role)) {
+          [item setAction:pair.selector];
+          break;
+        }
+      }
+    }
+  }
+  [menu insertItem:item atIndex:index];
+}
+
+// Called before the menu is to be displayed to update the state (enabled,
+// radio, etc) of each item in the menu. Also will update the title if
+// the item is marked as "dynamic".
+- (BOOL)validateUserInterfaceItem:(id<NSValidatedUserInterfaceItem>)item {
+  SEL action = [item action];
+  if (action != @selector(itemSelected:))
+    return NO;
+
+  NSInteger modelIndex = [item tag];
+  ui::MenuModel* model =
+      static_cast<ui::MenuModel*>(
+          [[(id)item representedObject] pointerValue]);
+  DCHECK(model);
+  if (model) {
+    BOOL checked = model->IsItemCheckedAt(modelIndex);
+    DCHECK([(id)item isKindOfClass:[NSMenuItem class]]);
+    [(id)item setState:(checked ? NSOnState : NSOffState)];
+    [(id)item setHidden:(!model->IsVisibleAt(modelIndex))];
+    if (model->IsItemDynamicAt(modelIndex)) {
+      // Update the label and the icon.
+      NSString* label =
+          l10n_util::FixUpWindowsStyleLabel(model->GetLabelAt(modelIndex));
+      [(id)item setTitle:label];
+
+      gfx::Image icon;
+      model->GetIconAt(modelIndex, &icon);
+      [(id)item setImage:icon.IsEmpty() ? nil : icon.ToNSImage()];
+    }
+    return model->IsEnabledAt(modelIndex);
+  }
+  return NO;
+}
+
+// Called when the user chooses a particular menu item. |sender| is the menu
+// item chosen.
+- (void)itemSelected:(id)sender {
+  NSInteger modelIndex = [sender tag];
+  ui::MenuModel* model =
+      static_cast<ui::MenuModel*>(
+          [[sender representedObject] pointerValue]);
+  DCHECK(model);
+  if (model) {
+    NSEvent* event = [NSApp currentEvent];
+    model->ActivatedAt(modelIndex,
+                       ui::EventFlagsFromModifiers([event modifierFlags]));
+  }
+}
+
+- (NSMenu*)menu {
+  if (menu_)
+    return menu_.get();
+
+  menu_.reset([[NSMenu alloc] initWithTitle:@""]);
+  [menu_ setDelegate:self];
+  if (model_)
+    [self populateWithModel:model_];
+  return menu_.get();
+}
+
+- (BOOL)isMenuOpen {
+  return isMenuOpen_;
+}
+
+- (void)menuWillOpen:(NSMenu*)menu {
+  isMenuOpen_ = YES;
+  model_->MenuWillShow();
+}
+
+- (void)menuDidClose:(NSMenu*)menu {
+  if (isMenuOpen_) {
+    model_->MenuClosed();
+    isMenuOpen_ = NO;
+  }
+}
+
+@end
added in remote
  their  100644 681fef1a11504d815d2d2a0311d9bbfc7598e612 electron/browser/ui/electron_menu_model.cc
@@ -0,0 +1,35 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/electron_menu_model.h"
+
+#include "base/stl_util.h"
+
+namespace electron {
+
+ElectronMenuModel::ElectronMenuModel(Delegate* delegate)
+    : ui::SimpleMenuModel(delegate),
+      delegate_(delegate) {
+}
+
+ElectronMenuModel::~ElectronMenuModel() {
+}
+
+void ElectronMenuModel::SetRole(int index, const base::string16& role) {
+  roles_[index] = role;
+}
+
+base::string16 ElectronMenuModel::GetRoleAt(int index) {
+  if (ContainsKey(roles_, index))
+    return roles_[index];
+  else
+    return base::string16();
+}
+
+void ElectronMenuModel::MenuClosed() {
+  ui::SimpleMenuModel::MenuClosed();
+  FOR_EACH_OBSERVER(Observer, observers_, MenuClosed());
+}
+
+}  // namespace electron
added in remote
  their  100644 3c8bd467c3254a43b3be409d0849c29f156cf30f electron/browser/ui/electron_menu_model.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
+#define ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
+
+#include <map>
+
+#include "base/observer_list.h"
+#include "ui/base/models/simple_menu_model.h"
+
+namespace electron {
+
+class ElectronMenuModel : public ui::SimpleMenuModel {
+ public:
+  class Delegate : public ui::SimpleMenuModel::Delegate {
+   public:
+    virtual ~Delegate() {}
+  };
+
+  class Observer {
+   public:
+    virtual ~Observer() {}
+
+    // Notifies the menu has been closed.
+    virtual void MenuClosed() {}
+  };
+
+  explicit ElectronMenuModel(Delegate* delegate);
+  virtual ~ElectronMenuModel();
+
+  void AddObserver(Observer* obs) { observers_.AddObserver(obs); }
+  void RemoveObserver(Observer* obs) { observers_.RemoveObserver(obs); }
+
+  void SetRole(int index, const base::string16& role);
+  base::string16 GetRoleAt(int index);
+
+  // ui::SimpleMenuModel:
+  void MenuClosed() override;
+
+ private:
+  Delegate* delegate_;  // weak ref.
+
+  std::map<int, base::string16> roles_;
+  base::ObserverList<Observer> observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronMenuModel);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_ELECTRON_MENU_MODEL_H_
added in remote
  their  100644 6020d8c76ff0e089c52f2273d41672a5ae973f4b electron/browser/ui/file_dialog.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_FILE_DIALOG_H_
+#define ELECTRON_BROWSER_UI_FILE_DIALOG_H_
+
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/files/file_path.h"
+
+namespace electron {
+class NativeWindow;
+}
+
+namespace file_dialog {
+
+// <description, extensions>
+typedef std::pair<std::string, std::vector<std::string> > Filter;
+typedef std::vector<Filter> Filters;
+
+enum FileDialogProperty {
+  FILE_DIALOG_OPEN_FILE        = 1 << 0,
+  FILE_DIALOG_OPEN_DIRECTORY   = 1 << 1,
+  FILE_DIALOG_MULTI_SELECTIONS = 1 << 2,
+  FILE_DIALOG_CREATE_DIRECTORY = 1 << 3,
+};
+
+typedef base::Callback<void(
+    bool result, const std::vector<base::FilePath>& paths)> OpenDialogCallback;
+
+typedef base::Callback<void(
+    bool result, const base::FilePath& path)> SaveDialogCallback;
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths);
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback);
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path);
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback);
+
+}  // namespace file_dialog
+
+#endif  // ELECTRON_BROWSER_UI_FILE_DIALOG_H_
added in remote
  their  100644 d27386e0b9df8e777a2af8a62fdc3298c7de35ac electron/browser/ui/file_dialog_gtk.cc
@@ -0,0 +1,288 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_signal.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
+
+namespace file_dialog {
+
+namespace {
+
+// Makes sure that .jpg also shows .JPG.
+gboolean FileFilterCaseInsensitive(const GtkFileFilterInfo* file_info,
+                                   std::string* file_extension) {
+  // Makes .* file extension matches all file types.
+  if (*file_extension == ".*")
+    return true;
+  return base::EndsWith(
+    file_info->filename,
+    *file_extension, base::CompareCase::INSENSITIVE_ASCII);
+}
+
+// Deletes |data| when gtk_file_filter_add_custom() is done with it.
+void OnFileFilterDataDestroyed(std::string* file_extension) {
+  delete file_extension;
+}
+
+class FileChooserDialog {
+ public:
+  FileChooserDialog(GtkFileChooserAction action,
+                    electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters)
+      : dialog_scope_(parent_window),
+        filters_(filters) {
+    const char* confirm_text = GTK_STOCK_OK;
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      confirm_text = GTK_STOCK_SAVE;
+    else if (action == GTK_FILE_CHOOSER_ACTION_OPEN)
+      confirm_text = GTK_STOCK_OPEN;
+
+    dialog_ = gtk_file_chooser_dialog_new(
+        title.c_str(),
+        NULL,
+        action,
+        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+        confirm_text, GTK_RESPONSE_ACCEPT,
+        NULL);
+    if (parent_window) {
+      gfx::NativeWindow window = parent_window->GetNativeWindow();
+      libgtk2ui::SetGtkTransientForAura(dialog_, window);
+    }
+
+    if (action == GTK_FILE_CHOOSER_ACTION_SAVE)
+      gtk_file_chooser_set_do_overwrite_confirmation(GTK_FILE_CHOOSER(dialog_),
+                                                     TRUE);
+    if (action != GTK_FILE_CHOOSER_ACTION_OPEN)
+      gtk_file_chooser_set_create_folders(GTK_FILE_CHOOSER(dialog_), TRUE);
+
+    gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
+
+    if (!default_path.empty()) {
+      if (base::DirectoryExists(default_path)) {
+        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog_),
+                                            default_path.value().c_str());
+      } else {
+        gtk_file_chooser_set_current_folder(GTK_FILE_CHOOSER(dialog_),
+            default_path.DirName().value().c_str());
+        gtk_file_chooser_set_current_name(GTK_FILE_CHOOSER(dialog_),
+            default_path.BaseName().value().c_str());
+      }
+    }
+
+    if (!filters.empty())
+      AddFilters(filters);
+  }
+
+  virtual ~FileChooserDialog() {
+    gtk_widget_destroy(dialog_);
+  }
+
+  void RunAsynchronous() {
+    g_signal_connect(dialog_, "delete-event",
+                     G_CALLBACK(gtk_widget_hide_on_delete), NULL);
+    g_signal_connect(dialog_, "response",
+                     G_CALLBACK(OnFileDialogResponseThunk), this);
+    gtk_widget_show_all(dialog_);
+
+    // We need to call gtk_window_present after making the widgets visible to
+    // make sure window gets correctly raised and gets focus.
+    int time = views::X11DesktopHandler::get()->wm_user_time_ms();
+    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
+  }
+
+  void RunSaveAsynchronous(const SaveDialogCallback& callback) {
+    save_callback_ = callback;
+    RunAsynchronous();
+  }
+
+  void RunOpenAsynchronous(const OpenDialogCallback& callback) {
+    open_callback_ = callback;
+    RunAsynchronous();
+  }
+
+  base::FilePath GetFileName() const {
+    gchar* filename = gtk_file_chooser_get_filename(GTK_FILE_CHOOSER(dialog_));
+    base::FilePath path = AddExtensionForFilename(filename);
+    g_free(filename);
+    return path;
+  }
+
+  std::vector<base::FilePath> GetFileNames() const {
+    std::vector<base::FilePath> paths;
+    GSList* filenames = gtk_file_chooser_get_filenames(
+        GTK_FILE_CHOOSER(dialog_));
+    for (GSList* iter = filenames; iter != NULL; iter = g_slist_next(iter)) {
+      base::FilePath path = AddExtensionForFilename(
+          static_cast<char*>(iter->data));
+      g_free(iter->data);
+      paths.push_back(path);
+    }
+    g_slist_free(filenames);
+    return paths;
+  }
+
+  CHROMEGTK_CALLBACK_1(FileChooserDialog, void, OnFileDialogResponse, int);
+
+  GtkWidget* dialog() const { return dialog_; }
+
+ private:
+  void AddFilters(const Filters& filters);
+  base::FilePath AddExtensionForFilename(const gchar* filename) const;
+
+  electron::NativeWindow::DialogScope dialog_scope_;
+
+  GtkWidget* dialog_;
+
+  Filters filters_;
+  SaveDialogCallback save_callback_;
+  OpenDialogCallback open_callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileChooserDialog);
+};
+
+void FileChooserDialog::OnFileDialogResponse(GtkWidget* widget, int response) {
+  gtk_widget_hide_all(dialog_);
+
+  if (!save_callback_.is_null()) {
+    if (response == GTK_RESPONSE_ACCEPT)
+      save_callback_.Run(true, GetFileName());
+    else
+      save_callback_.Run(false, base::FilePath());
+  } else if (!open_callback_.is_null()) {
+    if (response == GTK_RESPONSE_ACCEPT)
+      open_callback_.Run(true, GetFileNames());
+    else
+      open_callback_.Run(false, std::vector<base::FilePath>());
+  }
+  delete this;
+}
+
+void FileChooserDialog::AddFilters(const Filters& filters) {
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+    GtkFileFilter* gtk_filter = gtk_file_filter_new();
+
+    for (size_t j = 0; j < filter.second.size(); ++j) {
+      scoped_ptr<std::string> file_extension(
+          new std::string("." + filter.second[j]));
+      gtk_file_filter_add_custom(
+          gtk_filter,
+          GTK_FILE_FILTER_FILENAME,
+          reinterpret_cast<GtkFileFilterFunc>(FileFilterCaseInsensitive),
+          file_extension.release(),
+          reinterpret_cast<GDestroyNotify>(OnFileFilterDataDestroyed));
+    }
+
+    gtk_file_filter_set_name(gtk_filter, filter.first.c_str());
+    gtk_file_chooser_add_filter(GTK_FILE_CHOOSER(dialog_), gtk_filter);
+  }
+}
+
+base::FilePath FileChooserDialog::AddExtensionForFilename(
+    const gchar* filename) const {
+  base::FilePath path(filename);
+  GtkFileFilter* selected_filter =
+      gtk_file_chooser_get_filter(GTK_FILE_CHOOSER(dialog_));
+  if (!selected_filter)
+    return path;
+
+  GSList* filters = gtk_file_chooser_list_filters(GTK_FILE_CHOOSER(dialog_));
+  int i = g_slist_index(filters, selected_filter);
+  g_slist_free(filters);
+  if (i >= filters_.size())
+    return path;
+
+  const auto& extensions = filters_[i].second;
+  for (const auto& extension : extensions) {
+    if (extension == "*" || path.MatchesExtension("." + extension))
+      return path;
+  }
+
+  return path.ReplaceExtension(extensions[0]);
+}
+
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
+  FileChooserDialog open_dialog(action, parent_window, title, default_path,
+                                filters);
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    gtk_file_chooser_set_select_multiple(GTK_FILE_CHOOSER(open_dialog.dialog()),
+                                         TRUE);
+
+  gtk_widget_show_all(open_dialog.dialog());
+  int response = gtk_dialog_run(GTK_DIALOG(open_dialog.dialog()));
+  if (response == GTK_RESPONSE_ACCEPT) {
+    *paths = open_dialog.GetFileNames();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback) {
+  GtkFileChooserAction action = GTK_FILE_CHOOSER_ACTION_OPEN;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    action = GTK_FILE_CHOOSER_ACTION_SELECT_FOLDER;
+  FileChooserDialog* open_dialog = new FileChooserDialog(
+      action, parent_window, title, default_path, filters);
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    gtk_file_chooser_set_select_multiple(
+        GTK_FILE_CHOOSER(open_dialog->dialog()), TRUE);
+
+  open_dialog->RunOpenAsynchronous(callback);
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  FileChooserDialog save_dialog(GTK_FILE_CHOOSER_ACTION_SAVE, parent_window,
+                                title, default_path, filters);
+  gtk_widget_show_all(save_dialog.dialog());
+  int response = gtk_dialog_run(GTK_DIALOG(save_dialog.dialog()));
+  if (response == GTK_RESPONSE_ACCEPT) {
+    *path = save_dialog.GetFileName();
+    return true;
+  } else {
+    return false;
+  }
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback) {
+  FileChooserDialog* save_dialog = new FileChooserDialog(
+      GTK_FILE_CHOOSER_ACTION_SAVE, parent_window, title, default_path,
+      filters);
+  save_dialog->RunSaveAsynchronous(callback);
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 53bbb2594c97367e7604399a547b0b846cad4d78 electron/browser/ui/file_dialog_mac.mm
@@ -0,0 +1,204 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#import <Cocoa/Cocoa.h>
+#import <CoreServices/CoreServices.h>
+
+#include "electron/browser/native_window.h"
+#include "base/files/file_util.h"
+#include "base/mac/foundation_util.h"
+#include "base/mac/mac_util.h"
+#include "base/mac/scoped_cftyperef.h"
+#include "base/strings/sys_string_conversions.h"
+
+namespace file_dialog {
+
+namespace {
+
+void SetAllowedFileTypes(NSSavePanel* dialog, const Filters& filters) {
+  NSMutableSet* file_type_set = [NSMutableSet set];
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+    for (size_t j = 0; j < filter.second.size(); ++j) {
+      // If we meet a '*' file extension, we allow all the file types and no
+      // need to set the specified file types.
+      if (filter.second[j] == "*") {
+        [dialog setAllowsOtherFileTypes:YES];
+        return;
+      }
+      base::ScopedCFTypeRef<CFStringRef> ext_cf(
+          base::SysUTF8ToCFStringRef(filter.second[j]));
+      [file_type_set addObject:base::mac::CFToNSCast(ext_cf.get())];
+    }
+  }
+
+  // Passing empty array to setAllowedFileTypes will cause exception.
+  NSArray* file_types = nil;
+  if ([file_type_set count])
+    file_types = [file_type_set allObjects];
+
+  [dialog setAllowedFileTypes:file_types];
+}
+
+void SetupDialog(NSSavePanel* dialog,
+                 const std::string& title,
+                 const base::FilePath& default_path,
+                 const Filters& filters) {
+  if (!title.empty())
+    [dialog setTitle:base::SysUTF8ToNSString(title)];
+
+  NSString* default_dir = nil;
+  NSString* default_filename = nil;
+  if (!default_path.empty()) {
+    if (base::DirectoryExists(default_path)) {
+      default_dir = base::SysUTF8ToNSString(default_path.value());
+    } else {
+      default_dir = base::SysUTF8ToNSString(default_path.DirName().value());
+      default_filename =
+          base::SysUTF8ToNSString(default_path.BaseName().value());
+    }
+  }
+
+  if (default_dir)
+    [dialog setDirectoryURL:[NSURL fileURLWithPath:default_dir]];
+  if (default_filename)
+    [dialog setNameFieldStringValue:default_filename];
+
+  [dialog setCanSelectHiddenExtension:YES];
+  if (filters.empty())
+    [dialog setAllowsOtherFileTypes:YES];
+  else
+    SetAllowedFileTypes(dialog, filters);
+}
+
+void SetupDialogForProperties(NSOpenPanel* dialog, int properties) {
+  [dialog setCanChooseFiles:(properties & FILE_DIALOG_OPEN_FILE)];
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    [dialog setCanChooseDirectories:YES];
+  if (properties & FILE_DIALOG_CREATE_DIRECTORY)
+    [dialog setCanCreateDirectories:YES];
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    [dialog setAllowsMultipleSelection:YES];
+}
+
+// Run modal dialog with parent window and return user's choice.
+int RunModalDialog(NSSavePanel* dialog, electron::NativeWindow* parent_window) {
+  __block int chosen = NSFileHandlingPanelCancelButton;
+  if (!parent_window || !parent_window->GetNativeWindow()) {
+    chosen = [dialog runModal];
+  } else {
+    NSWindow* window = parent_window->GetNativeWindow();
+
+    [dialog beginSheetModalForWindow:window
+                   completionHandler:^(NSInteger c) {
+      chosen = c;
+      [NSApp stopModal];
+    }];
+    [NSApp runModalForWindow:window];
+  }
+
+  return chosen;
+}
+
+void ReadDialogPaths(NSOpenPanel* dialog, std::vector<base::FilePath>* paths) {
+  NSArray* urls = [dialog URLs];
+  for (NSURL* url in urls)
+    if ([url isFileURL])
+      paths->push_back(base::FilePath(base::SysNSStringToUTF8([url path])));
+}
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  DCHECK(paths);
+  NSOpenPanel* dialog = [NSOpenPanel openPanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+  SetupDialogForProperties(dialog, properties);
+
+  int chosen = RunModalDialog(dialog, parent_window);
+  if (chosen == NSFileHandlingPanelCancelButton)
+    return false;
+
+  ReadDialogPaths(dialog, paths);
+  return true;
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& c) {
+  NSOpenPanel* dialog = [NSOpenPanel openPanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+  SetupDialogForProperties(dialog, properties);
+
+  // Duplicate the callback object here since c is a reference and gcd would
+  // only store the pointer, by duplication we can force gcd to store a copy.
+  __block OpenDialogCallback callback = c;
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : NULL;
+  [dialog beginSheetModalForWindow:window
+                 completionHandler:^(NSInteger chosen) {
+    if (chosen == NSFileHandlingPanelCancelButton) {
+      callback.Run(false, std::vector<base::FilePath>());
+    } else {
+      std::vector<base::FilePath> paths;
+      ReadDialogPaths(dialog, &paths);
+      callback.Run(true, paths);
+    }
+  }];
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  DCHECK(path);
+  NSSavePanel* dialog = [NSSavePanel savePanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+
+  int chosen = RunModalDialog(dialog, parent_window);
+  if (chosen == NSFileHandlingPanelCancelButton || ![[dialog URL] isFileURL])
+    return false;
+
+  *path = base::FilePath(base::SysNSStringToUTF8([[dialog URL] path]));
+  return true;
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& c) {
+  NSSavePanel* dialog = [NSSavePanel savePanel];
+
+  SetupDialog(dialog, title, default_path, filters);
+
+  __block SaveDialogCallback callback = c;
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : NULL;
+  [dialog beginSheetModalForWindow:window
+                 completionHandler:^(NSInteger chosen) {
+    if (chosen == NSFileHandlingPanelCancelButton) {
+      callback.Run(false, base::FilePath());
+    } else {
+      std::string path = base::SysNSStringToUTF8([[dialog URL] path]);
+      callback.Run(true, base::FilePath(path));
+    }
+  }];
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 3f3698c42653b47c193e9e025613487a55ada851 electron/browser/ui/file_dialog_win.cc
@@ -0,0 +1,286 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/file_dialog.h"
+
+#include <atlbase.h>
+#include <windows.h>
+#include <commdlg.h>
+#include <shlobj.h>
+
+#include "electron/browser/native_window_views.h"
+#include "base/files/file_util.h"
+#include "base/i18n/case_conversion.h"
+#include "base/strings/string_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread.h"
+#include "base/win/registry.h"
+#include "third_party/wtl/include/atlapp.h"
+#include "third_party/wtl/include/atldlgs.h"
+
+namespace file_dialog {
+
+namespace {
+
+// Distinguish directories from regular files.
+bool IsDirectory(const base::FilePath& path) {
+  base::File::Info file_info;
+  return base::GetFileInfo(path, &file_info) ?
+      file_info.is_directory : path.EndsWithSeparator();
+}
+
+void ConvertFilters(const Filters& filters,
+                    std::vector<std::wstring>* buffer,
+                    std::vector<COMDLG_FILTERSPEC>* filterspec) {
+  if (filters.empty()) {
+    COMDLG_FILTERSPEC spec = { L"All Files (*.*)", L"*.*" };
+    filterspec->push_back(spec);
+    return;
+  }
+
+  buffer->reserve(filters.size() * 2);
+  for (size_t i = 0; i < filters.size(); ++i) {
+    const Filter& filter = filters[i];
+
+    COMDLG_FILTERSPEC spec;
+    buffer->push_back(base::UTF8ToWide(filter.first));
+    spec.pszName = buffer->back().c_str();
+
+    std::vector<std::string> extensions(filter.second);
+    for (size_t j = 0; j < extensions.size(); ++j)
+      extensions[j].insert(0, "*.");
+    buffer->push_back(base::UTF8ToWide(base::JoinString(extensions, ";")));
+    spec.pszSpec = buffer->back().c_str();
+
+    filterspec->push_back(spec);
+  }
+}
+
+// Generic class to delegate common open/save dialog's behaviours, users need to
+// call interface methods via GetPtr().
+template <typename T>
+class FileDialog {
+ public:
+  FileDialog(const base::FilePath& default_path, const std::string& title,
+             const Filters& filters, int options) {
+    std::wstring file_part;
+    if (!IsDirectory(default_path))
+      file_part = default_path.BaseName().value();
+
+    std::vector<std::wstring> buffer;
+    std::vector<COMDLG_FILTERSPEC> filterspec;
+    ConvertFilters(filters, &buffer, &filterspec);
+
+    dialog_.reset(new T(file_part.c_str(), options, NULL,
+                        filterspec.data(), filterspec.size()));
+
+    if (!title.empty())
+      GetPtr()->SetTitle(base::UTF8ToUTF16(title).c_str());
+
+    // By default, *.* will be added to the file name if file type is "*.*". In
+    // Electron, we disable it to make a better experience.
+    //
+    // From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/
+    // bb775970(v=vs.85).aspx
+    //
+    // If SetDefaultExtension is not called, the dialog will not update
+    // automatically when user choose a new file type in the file dialog.
+    //
+    // We set file extension to the first none-wildcard extension to make
+    // sure the dialog will update file extension automatically.
+    for (size_t i = 0; i < filterspec.size(); ++i) {
+      if (std::wstring(filterspec[i].pszSpec) != L"*.*") {
+        // SetFileTypeIndex is regarded as one-based index.
+        GetPtr()->SetFileTypeIndex(i+1);
+        GetPtr()->SetDefaultExtension(filterspec[i].pszSpec);
+        break;
+      }
+    }
+
+    SetDefaultFolder(default_path);
+  }
+
+  bool Show(electron::NativeWindow* parent_window) {
+    electron::NativeWindow::DialogScope dialog_scope(parent_window);
+    HWND window = parent_window ? static_cast<electron::NativeWindowViews*>(
+        parent_window)->GetAcceleratedWidget() :
+        NULL;
+    return dialog_->DoModal(window) == IDOK;
+  }
+
+  T* GetDialog() { return dialog_.get(); }
+
+  IFileDialog* GetPtr() const { return dialog_->GetPtr(); }
+
+ private:
+  // Set up the initial directory for the dialog.
+  void SetDefaultFolder(const base::FilePath file_path) {
+    std::wstring directory = IsDirectory(file_path) ?
+        file_path.value() :
+        file_path.DirName().value();
+
+    ATL::CComPtr<IShellItem> folder_item;
+    HRESULT hr = SHCreateItemFromParsingName(directory.c_str(),
+                                             NULL,
+                                             IID_PPV_ARGS(&folder_item));
+    if (SUCCEEDED(hr))
+      GetPtr()->SetFolder(folder_item);
+  }
+
+  scoped_ptr<T> dialog_;
+
+  DISALLOW_COPY_AND_ASSIGN(FileDialog);
+};
+
+struct RunState {
+  base::Thread* dialog_thread;
+  base::MessageLoop* ui_message_loop;
+};
+
+bool CreateDialogThread(RunState* run_state) {
+  scoped_ptr<base::Thread> thread(
+      new base::Thread(ELECTRON_PRODUCT_NAME "FileDialogThread"));
+  thread->init_com_with_mta(false);
+  if (!thread->Start())
+    return false;
+
+  run_state->dialog_thread = thread.release();
+  run_state->ui_message_loop = base::MessageLoop::current();
+  return true;
+}
+
+void RunOpenDialogInNewThread(const RunState& run_state,
+                              electron::NativeWindow* parent,
+                              const std::string& title,
+                              const base::FilePath& default_path,
+                              const Filters& filters,
+                              int properties,
+                              const OpenDialogCallback& callback) {
+  std::vector<base::FilePath> paths;
+  bool result = ShowOpenDialog(parent, title, default_path, filters, properties,
+                               &paths);
+  run_state.ui_message_loop->PostTask(FROM_HERE,
+                                      base::Bind(callback, result, paths));
+  run_state.ui_message_loop->DeleteSoon(FROM_HERE, run_state.dialog_thread);
+}
+
+void RunSaveDialogInNewThread(const RunState& run_state,
+                              electron::NativeWindow* parent,
+                              const std::string& title,
+                              const base::FilePath& default_path,
+                              const Filters& filters,
+                              const SaveDialogCallback& callback) {
+  base::FilePath path;
+  bool result = ShowSaveDialog(parent, title, default_path, filters, &path);
+  run_state.ui_message_loop->PostTask(FROM_HERE,
+                                      base::Bind(callback, result, path));
+  run_state.ui_message_loop->DeleteSoon(FROM_HERE, run_state.dialog_thread);
+}
+
+}  // namespace
+
+bool ShowOpenDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    std::vector<base::FilePath>* paths) {
+  int options = FOS_FORCEFILESYSTEM | FOS_FILEMUSTEXIST;
+  if (properties & FILE_DIALOG_OPEN_DIRECTORY)
+    options |= FOS_PICKFOLDERS;
+  if (properties & FILE_DIALOG_MULTI_SELECTIONS)
+    options |= FOS_ALLOWMULTISELECT;
+
+  FileDialog<CShellFileOpenDialog> open_dialog(
+      default_path, title, filters, options);
+  if (!open_dialog.Show(parent_window))
+    return false;
+
+  ATL::CComPtr<IShellItemArray> items;
+  HRESULT hr = static_cast<IFileOpenDialog*>(open_dialog.GetPtr())->GetResults(
+      &items);
+  if (FAILED(hr))
+    return false;
+
+  ATL::CComPtr<IShellItem> item;
+  DWORD count = 0;
+  hr = items->GetCount(&count);
+  if (FAILED(hr))
+    return false;
+
+  paths->reserve(count);
+  for (DWORD i = 0; i < count; ++i) {
+    hr = items->GetItemAt(i, &item);
+    if (FAILED(hr))
+      return false;
+
+    wchar_t file_name[MAX_PATH];
+    hr = CShellFileOpenDialog::GetFileNameFromShellItem(
+        item, SIGDN_FILESYSPATH, file_name, MAX_PATH);
+    if (FAILED(hr))
+      return false;
+
+    paths->push_back(base::FilePath(file_name));
+  }
+
+  return true;
+}
+
+void ShowOpenDialog(electron::NativeWindow* parent,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    int properties,
+                    const OpenDialogCallback& callback) {
+  RunState run_state;
+  if (!CreateDialogThread(&run_state)) {
+    callback.Run(false, std::vector<base::FilePath>());
+    return;
+  }
+
+  run_state.dialog_thread->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunOpenDialogInNewThread, run_state, parent, title,
+                 default_path, filters, properties, callback));
+}
+
+bool ShowSaveDialog(electron::NativeWindow* parent_window,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    base::FilePath* path) {
+  FileDialog<CShellFileSaveDialog> save_dialog(
+      default_path, title, filters,
+      FOS_FORCEFILESYSTEM | FOS_PATHMUSTEXIST | FOS_OVERWRITEPROMPT);
+  if (!save_dialog.Show(parent_window))
+    return false;
+
+  wchar_t buffer[MAX_PATH];
+  HRESULT hr = save_dialog.GetDialog()->GetFilePath(buffer, MAX_PATH);
+  if (FAILED(hr))
+    return false;
+
+  *path = base::FilePath(buffer);
+  return true;
+}
+
+void ShowSaveDialog(electron::NativeWindow* parent,
+                    const std::string& title,
+                    const base::FilePath& default_path,
+                    const Filters& filters,
+                    const SaveDialogCallback& callback) {
+  RunState run_state;
+  if (!CreateDialogThread(&run_state)) {
+    callback.Run(false, base::FilePath());
+    return;
+  }
+
+  run_state.dialog_thread->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunSaveDialogInNewThread, run_state, parent, title,
+                 default_path, filters, callback));
+}
+
+}  // namespace file_dialog
added in remote
  their  100644 03c1228023f9c025fed69e3724af7080a2508d04 electron/browser/ui/message_box.h
@@ -0,0 +1,66 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
+#define ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback_forward.h"
+#include "base/strings/string16.h"
+
+namespace gfx {
+class ImageSkia;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+enum MessageBoxType {
+  MESSAGE_BOX_TYPE_NONE = 0,
+  MESSAGE_BOX_TYPE_INFORMATION,
+  MESSAGE_BOX_TYPE_WARNING,
+  MESSAGE_BOX_TYPE_ERROR,
+  MESSAGE_BOX_TYPE_QUESTION,
+};
+
+enum MessageBoxOptions {
+  MESSAGE_BOX_NONE    = 0,
+  MESSAGE_BOX_NO_LINK = 1 << 0,
+};
+
+typedef base::Callback<void(int code)> MessageBoxCallback;
+
+int ShowMessageBox(NativeWindow* parent_window,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int cancel_id,
+                   int default_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon);
+
+void ShowMessageBox(NativeWindow* parent_window,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback);
+
+// Like ShowMessageBox with simplest settings, but safe to call at very early
+// stage of application.
+void ShowErrorBox(const base::string16& title, const base::string16& content);
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_MESSAGE_BOX_H_
added in remote
  their  100644 d1f1187dc14a1ab2d71fecc2e5cf206a7d1b07c0 electron/browser/ui/message_box_gtk.cc
@@ -0,0 +1,209 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_signal.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_util.h"
+#include "chrome/browser/ui/libgtk2ui/skia_utils_gtk2.h"
+#include "ui/views/widget/desktop_aura/x11_desktop_handler.h"
+
+#define ANSI_FOREGROUND_RED   "\x1b[31m"
+#define ANSI_FOREGROUND_BLACK "\x1b[30m"
+#define ANSI_TEXT_BOLD        "\x1b[1m"
+#define ANSI_BACKGROUND_GRAY  "\x1b[47m"
+#define ANSI_RESET            "\x1b[0m"
+
+namespace electron {
+
+namespace {
+
+class GtkMessageBox {
+ public:
+  GtkMessageBox(NativeWindow* parent_window,
+                MessageBoxType type,
+                const std::vector<std::string>& buttons,
+                int default_id,
+                int cancel_id,
+                const std::string& title,
+                const std::string& message,
+                const std::string& detail,
+                const gfx::ImageSkia& icon)
+      : dialog_scope_(parent_window),
+        cancel_id_(cancel_id) {
+    // Create dialog.
+    dialog_ = gtk_message_dialog_new(
+        nullptr,  // parent
+        static_cast<GtkDialogFlags>(0),  // no flags
+        GetMessageType(type),  // type
+        GTK_BUTTONS_NONE,  // no buttons
+        "%s", message.c_str());
+    if (!detail.empty())
+      gtk_message_dialog_format_secondary_text(
+          GTK_MESSAGE_DIALOG(dialog_), "%s", detail.c_str());
+    if (!title.empty())
+      gtk_window_set_title(GTK_WINDOW(dialog_), title.c_str());
+
+    // Set dialog's icon.
+    if (!icon.isNull()) {
+      GdkPixbuf* pixbuf = libgtk2ui::GdkPixbufFromSkBitmap(*icon.bitmap());
+      GtkWidget* image = gtk_image_new_from_pixbuf(pixbuf);
+      gtk_message_dialog_set_image(GTK_MESSAGE_DIALOG(dialog_), image);
+      gtk_widget_show(image);
+      g_object_unref(pixbuf);
+    }
+
+    // Add buttons.
+    for (size_t i = 0; i < buttons.size(); ++i) {
+      GtkWidget* button = gtk_dialog_add_button(
+          GTK_DIALOG(dialog_), TranslateToStock(i, buttons[i]), i);
+      if (static_cast<int>(i) == default_id)
+        gtk_widget_grab_focus(button);
+    }
+
+    // Parent window.
+    if (parent_window) {
+      gfx::NativeWindow window = parent_window->GetNativeWindow();
+      libgtk2ui::SetGtkTransientForAura(dialog_, window);
+    }
+  }
+
+  ~GtkMessageBox() {
+    gtk_widget_destroy(dialog_);
+  }
+
+  GtkMessageType GetMessageType(MessageBoxType type) {
+    switch (type) {
+      case MESSAGE_BOX_TYPE_INFORMATION:
+        return GTK_MESSAGE_INFO;
+      case MESSAGE_BOX_TYPE_WARNING:
+        return GTK_MESSAGE_WARNING;
+      case MESSAGE_BOX_TYPE_QUESTION:
+        return GTK_MESSAGE_QUESTION;
+      case MESSAGE_BOX_TYPE_ERROR:
+        return GTK_MESSAGE_ERROR;
+      default:
+        return GTK_MESSAGE_OTHER;
+    }
+  }
+
+  const char* TranslateToStock(int id, const std::string& text) {
+    std::string lower = base::ToLowerASCII(text);
+    if (lower == "cancel")
+      return GTK_STOCK_CANCEL;
+    else if (lower == "no")
+      return GTK_STOCK_NO;
+    else if (lower == "ok")
+      return GTK_STOCK_OK;
+    else if (lower == "yes")
+      return GTK_STOCK_YES;
+    else
+      return text.c_str();
+  }
+
+  void Show() {
+    gtk_widget_show_all(dialog_);
+    // We need to call gtk_window_present after making the widgets visible to
+    // make sure window gets correctly raised and gets focus.
+    int time = views::X11DesktopHandler::get()->wm_user_time_ms();
+    gtk_window_present_with_time(GTK_WINDOW(dialog_), time);
+  }
+
+  int RunSynchronous() {
+    gtk_window_set_modal(GTK_WINDOW(dialog_), TRUE);
+    Show();
+    int response = gtk_dialog_run(GTK_DIALOG(dialog_));
+    if (response < 0)
+      return cancel_id_;
+    else
+      return response;
+  }
+
+  void RunAsynchronous(const MessageBoxCallback& callback) {
+    callback_ = callback;
+    g_signal_connect(dialog_, "delete-event",
+                     G_CALLBACK(gtk_widget_hide_on_delete), nullptr);
+    g_signal_connect(dialog_, "response",
+                     G_CALLBACK(OnResponseDialogThunk), this);
+    Show();
+  }
+
+  CHROMEGTK_CALLBACK_1(GtkMessageBox, void, OnResponseDialog, int);
+
+ private:
+  electron::NativeWindow::DialogScope dialog_scope_;
+
+  // The id to return when the dialog is closed without pressing buttons.
+  int cancel_id_;
+
+  GtkWidget* dialog_;
+  MessageBoxCallback callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(GtkMessageBox);
+};
+
+void GtkMessageBox::OnResponseDialog(GtkWidget* widget, int response) {
+  gtk_widget_hide_all(dialog_);
+
+  if (response < 0)
+    callback_.Run(cancel_id_);
+  else
+    callback_.Run(response);
+  delete this;
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  return GtkMessageBox(parent, type, buttons, default_id, cancel_id,
+                       title, message, detail, icon).RunSynchronous();
+}
+
+void ShowMessageBox(NativeWindow* parent,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  (new GtkMessageBox(parent, type, buttons, default_id, cancel_id,
+                     title, message, detail, icon))->RunAsynchronous(callback);
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  if (Browser::Get()->is_ready()) {
+    GtkMessageBox(nullptr, MESSAGE_BOX_TYPE_ERROR, { "OK" }, -1, 0, "Error",
+                  base::UTF16ToUTF8(title).c_str(),
+                  base::UTF16ToUTF8(content).c_str(),
+                  gfx::ImageSkia()).RunSynchronous();
+  } else {
+    fprintf(stderr,
+            ANSI_TEXT_BOLD ANSI_BACKGROUND_GRAY
+            ANSI_FOREGROUND_RED  "%s\n"
+            ANSI_FOREGROUND_BLACK "%s"
+            ANSI_RESET "\n",
+            base::UTF16ToUTF8(title).c_str(),
+            base::UTF16ToUTF8(content).c_str());
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 34455d42dabd42312ad8fec114d08d832a996a8f electron/browser/ui/message_box_mac.mm
@@ -0,0 +1,182 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#import <Cocoa/Cocoa.h>
+
+#include "electron/browser/native_window.h"
+#include "base/callback.h"
+#include "base/mac/mac_util.h"
+#include "base/strings/sys_string_conversions.h"
+#include "skia/ext/skia_utils_mac.h"
+
+@interface ModalDelegate : NSObject {
+ @private
+  electron::MessageBoxCallback callback_;
+  NSAlert* alert_;
+  bool callEndModal_;
+}
+- (id)initWithCallback:(const electron::MessageBoxCallback&)callback
+              andAlert:(NSAlert*)alert
+          callEndModal:(bool)flag;
+@end
+
+@implementation ModalDelegate
+
+- (id)initWithCallback:(const electron::MessageBoxCallback&)callback
+              andAlert:(NSAlert*)alert
+          callEndModal:(bool)flag {
+  if ((self = [super init])) {
+    callback_ = callback;
+    alert_ = alert;
+    callEndModal_ = flag;
+  }
+  return self;
+}
+
+- (void)alertDidEnd:(NSAlert*)alert
+         returnCode:(NSInteger)returnCode
+        contextInfo:(void*)contextInfo {
+  callback_.Run(returnCode);
+  [alert_ release];
+  [self release];
+
+  if (callEndModal_)
+    [NSApp stopModal];
+}
+
+@end
+
+namespace electron {
+
+namespace {
+
+NSAlert* CreateNSAlert(NativeWindow* parent_window,
+                       MessageBoxType type,
+                       const std::vector<std::string>& buttons,
+                       int default_id,
+                       const std::string& title,
+                       const std::string& message,
+                       const std::string& detail,
+                       const gfx::ImageSkia& icon) {
+  // Ignore the title; it's the window title on other platforms and ignorable.
+  NSAlert* alert = [[NSAlert alloc] init];
+  [alert setMessageText:base::SysUTF8ToNSString(message)];
+  [alert setInformativeText:base::SysUTF8ToNSString(detail)];
+
+  switch (type) {
+    case MESSAGE_BOX_TYPE_INFORMATION:
+      [alert setAlertStyle:NSInformationalAlertStyle];
+      break;
+    case MESSAGE_BOX_TYPE_WARNING:
+      [alert setAlertStyle:NSWarningAlertStyle];
+      break;
+    default:
+      break;
+  }
+
+  for (size_t i = 0; i < buttons.size(); ++i) {
+    NSString* title = base::SysUTF8ToNSString(buttons[i]);
+    // An empty title causes crash on OS X.
+    if (buttons[i].empty())
+      title = @"(empty)";
+    NSButton* button = [alert addButtonWithTitle:title];
+    [button setTag:i];
+  }
+
+  NSArray* ns_buttons = [alert buttons];
+  if (default_id >= 0 && default_id < static_cast<int>([ns_buttons count])) {
+    // Focus the button at default_id if the user opted to do so.
+    // The first button added gets set as the default selected.
+    // So remove that default, and make the requested button the default.
+    [[ns_buttons objectAtIndex:0] setKeyEquivalent:@""];
+    [[ns_buttons objectAtIndex:default_id] setKeyEquivalent:@"\r"];
+  }
+
+  if (!icon.isNull()) {
+    NSImage* image = skia::SkBitmapToNSImageWithColorSpace(
+        *icon.bitmap(), base::mac::GetGenericRGBColorSpace());
+    [alert setIcon:image];
+  }
+
+  return alert;
+}
+
+void SetReturnCode(int* ret_code, int result) {
+  *ret_code = result;
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent_window,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  NSAlert* alert = CreateNSAlert(
+      parent_window, type, buttons, default_id, title, message,
+      detail, icon);
+
+  // Use runModal for synchronous alert without parent, since we don't have a
+  // window to wait for.
+  if (!parent_window || !parent_window->GetNativeWindow())
+    return [[alert autorelease] runModal];
+
+  int ret_code = -1;
+  ModalDelegate* delegate = [[ModalDelegate alloc]
+      initWithCallback:base::Bind(&SetReturnCode, &ret_code)
+              andAlert:alert
+          callEndModal:true];
+
+  NSWindow* window = parent_window->GetNativeWindow();
+  [alert beginSheetModalForWindow:window
+                    modalDelegate:delegate
+                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
+                      contextInfo:nil];
+
+  [NSApp runModalForWindow:window];
+  return ret_code;
+}
+
+void ShowMessageBox(NativeWindow* parent_window,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  NSAlert* alert = CreateNSAlert(
+      parent_window, type, buttons, default_id, title, message,
+      detail, icon);
+  ModalDelegate* delegate = [[ModalDelegate alloc] initWithCallback:callback
+                                                           andAlert:alert
+                                                       callEndModal:false];
+
+  NSWindow* window = parent_window ? parent_window->GetNativeWindow() : nil;
+  [alert beginSheetModalForWindow:window
+                    modalDelegate:delegate
+                   didEndSelector:@selector(alertDidEnd:returnCode:contextInfo:)
+                      contextInfo:nil];
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  NSAlert* alert = [[NSAlert alloc] init];
+  [alert setMessageText:base::SysUTF16ToNSString(title)];
+  [alert setInformativeText:base::SysUTF16ToNSString(content)];
+  [alert setAlertStyle:NSWarningAlertStyle];
+  [alert runModal];
+  [alert release];
+}
+
+}  // namespace electron
added in remote
  their  100644 23588526adb24381e4b76704ebaa7a6b550d5be0 electron/browser/ui/message_box_win.cc
@@ -0,0 +1,244 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/message_box.h"
+
+#include <windows.h>
+#include <commctrl.h>
+
+#include <map>
+#include <vector>
+
+#include "electron/browser/browser.h"
+#include "electron/browser/native_window_views.h"
+#include "base/callback.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/threading/thread.h"
+#include "base/win/scoped_gdi_object.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/gfx/icon_util.h"
+
+namespace electron {
+
+namespace {
+
+// Small command ID values are already taken by Windows, we have to start from
+// a large number to avoid conflicts with Windows.
+const int kIDStart = 100;
+
+// Get the common ID from button's name.
+struct CommonButtonID {
+  int button;
+  int id;
+};
+CommonButtonID GetCommonID(const base::string16& button) {
+  base::string16 lower = base::ToLowerASCII(button);
+  if (lower == L"ok")
+    return { TDCBF_OK_BUTTON, IDOK };
+  else if (lower == L"yes")
+    return { TDCBF_YES_BUTTON, IDYES };
+  else if (lower == L"no")
+    return { TDCBF_NO_BUTTON, IDNO };
+  else if (lower == L"cancel")
+    return { TDCBF_CANCEL_BUTTON, IDCANCEL };
+  else if (lower == L"retry")
+    return { TDCBF_RETRY_BUTTON, IDRETRY };
+  else if (lower == L"close")
+    return { TDCBF_CLOSE_BUTTON, IDCLOSE };
+  return { -1, -1 };
+}
+
+// Determine whether the buttons are common buttons, if so map common ID
+// to button ID.
+void MapToCommonID(const std::vector<base::string16>& buttons,
+                   std::map<int, int>* id_map,
+                   TASKDIALOG_COMMON_BUTTON_FLAGS* button_flags,
+                   std::vector<TASKDIALOG_BUTTON>* dialog_buttons) {
+  for (size_t i = 0; i < buttons.size(); ++i) {
+    auto common = GetCommonID(buttons[i]);
+    if (common.button != -1) {
+      // It is a common button.
+      (*id_map)[common.id] = i;
+      (*button_flags) |= common.button;
+    } else {
+      // It is a custom button.
+      dialog_buttons->push_back({i + kIDStart, buttons[i].c_str()});
+    }
+  }
+}
+
+int ShowMessageBoxUTF16(HWND parent,
+                        MessageBoxType type,
+                        const std::vector<base::string16>& buttons,
+                        int default_id,
+                        int cancel_id,
+                        int options,
+                        const base::string16& title,
+                        const base::string16& message,
+                        const base::string16& detail,
+                        const gfx::ImageSkia& icon) {
+  TASKDIALOG_FLAGS flags =
+      TDF_SIZE_TO_CONTENT |  // Show all content.
+      TDF_ALLOW_DIALOG_CANCELLATION;  // Allow canceling the dialog.
+
+  TASKDIALOGCONFIG config = { 0 };
+  config.cbSize     = sizeof(config);
+  config.hwndParent = parent;
+  config.hInstance  = GetModuleHandle(NULL);
+  config.dwFlags    = flags;
+
+  if (default_id > 0)
+    config.nDefaultButton = kIDStart + default_id;
+
+  // TaskDialogIndirect doesn't allow empty name, if we set empty title it
+  // will show "electron.exe" in title.
+  base::string16 app_name = base::UTF8ToUTF16(Browser::Get()->GetName());
+  if (title.empty())
+    config.pszWindowTitle = app_name.c_str();
+  else
+    config.pszWindowTitle = title.c_str();
+
+  base::win::ScopedHICON hicon;
+  if (!icon.isNull()) {
+    hicon = IconUtil::CreateHICONFromSkBitmap(*icon.bitmap());
+    config.dwFlags |= TDF_USE_HICON_MAIN;
+    config.hMainIcon = hicon.get();
+  } else {
+    // Show icon according to dialog's type.
+    switch (type) {
+      case MESSAGE_BOX_TYPE_INFORMATION:
+      case MESSAGE_BOX_TYPE_QUESTION:
+        config.pszMainIcon = TD_INFORMATION_ICON;
+        break;
+      case MESSAGE_BOX_TYPE_WARNING:
+        config.pszMainIcon = TD_WARNING_ICON;
+        break;
+      case MESSAGE_BOX_TYPE_ERROR:
+        config.pszMainIcon = TD_ERROR_ICON;
+        break;
+    }
+  }
+
+  // If "detail" is empty then don't make message hilighted.
+  if (detail.empty()) {
+    config.pszContent = message.c_str();
+  } else {
+    config.pszMainInstruction = message.c_str();
+    config.pszContent = detail.c_str();
+  }
+
+  // Iterate through the buttons, put common buttons in dwCommonButtons
+  // and custom buttons in pButtons.
+  std::map<int, int> id_map;
+  std::vector<TASKDIALOG_BUTTON> dialog_buttons;
+  if (options & MESSAGE_BOX_NO_LINK) {
+    for (size_t i = 0; i < buttons.size(); ++i)
+      dialog_buttons.push_back({i + kIDStart, buttons[i].c_str()});
+  } else {
+    MapToCommonID(buttons, &id_map, &config.dwCommonButtons, &dialog_buttons);
+  }
+  if (dialog_buttons.size() > 0) {
+    config.pButtons = &dialog_buttons.front();
+    config.cButtons = dialog_buttons.size();
+    if (!(options & MESSAGE_BOX_NO_LINK))
+      config.dwFlags |= TDF_USE_COMMAND_LINKS;  // custom buttons as links.
+  }
+
+  int id = 0;
+  TaskDialogIndirect(&config, &id, NULL, NULL);
+  if (id_map.find(id) != id_map.end())  // common button.
+    return id_map[id];
+  else if (id >= kIDStart)  // custom button.
+    return id - kIDStart;
+  else
+    return cancel_id;
+}
+
+void RunMessageBoxInNewThread(base::Thread* thread,
+                              NativeWindow* parent,
+                              MessageBoxType type,
+                              const std::vector<std::string>& buttons,
+                              int default_id,
+                              int cancel_id,
+                              int options,
+                              const std::string& title,
+                              const std::string& message,
+                              const std::string& detail,
+                              const gfx::ImageSkia& icon,
+                              const MessageBoxCallback& callback) {
+  int result = ShowMessageBox(parent, type, buttons, default_id,
+                              cancel_id, options, title, message, detail, icon);
+  content::BrowserThread::PostTask(
+      content::BrowserThread::UI, FROM_HERE, base::Bind(callback, result));
+  content::BrowserThread::DeleteSoon(
+      content::BrowserThread::UI, FROM_HERE, thread);
+}
+
+}  // namespace
+
+int ShowMessageBox(NativeWindow* parent,
+                   MessageBoxType type,
+                   const std::vector<std::string>& buttons,
+                   int default_id,
+                   int cancel_id,
+                   int options,
+                   const std::string& title,
+                   const std::string& message,
+                   const std::string& detail,
+                   const gfx::ImageSkia& icon) {
+  std::vector<base::string16> utf16_buttons;
+  for (const auto& button : buttons)
+    utf16_buttons.push_back(base::UTF8ToUTF16(button));
+
+  HWND hwnd_parent = parent ?
+      static_cast<electron::NativeWindowViews*>(parent)->GetAcceleratedWidget() :
+      NULL;
+
+  NativeWindow::DialogScope dialog_scope(parent);
+  return ShowMessageBoxUTF16(hwnd_parent,
+                             type,
+                             utf16_buttons,
+                             default_id,
+                             cancel_id,
+                             options,
+                             base::UTF8ToUTF16(title),
+                             base::UTF8ToUTF16(message),
+                             base::UTF8ToUTF16(detail),
+                             icon);
+}
+
+void ShowMessageBox(NativeWindow* parent,
+                    MessageBoxType type,
+                    const std::vector<std::string>& buttons,
+                    int default_id,
+                    int cancel_id,
+                    int options,
+                    const std::string& title,
+                    const std::string& message,
+                    const std::string& detail,
+                    const gfx::ImageSkia& icon,
+                    const MessageBoxCallback& callback) {
+  scoped_ptr<base::Thread> thread(
+      new base::Thread(ELECTRON_PRODUCT_NAME "MessageBoxThread"));
+  thread->init_com_with_mta(false);
+  if (!thread->Start()) {
+    callback.Run(cancel_id);
+    return;
+  }
+
+  base::Thread* unretained = thread.release();
+  unretained->message_loop()->PostTask(
+      FROM_HERE,
+      base::Bind(&RunMessageBoxInNewThread, base::Unretained(unretained),
+                 parent, type, buttons, default_id, cancel_id, options, title,
+                 message, detail, icon, callback));
+}
+
+void ShowErrorBox(const base::string16& title, const base::string16& content) {
+  ShowMessageBoxUTF16(NULL, MESSAGE_BOX_TYPE_ERROR, {}, -1, 0, 0, L"Error",
+                      title, content, gfx::ImageSkia());
+}
+
+}  // namespace electron
added in remote
  their  100644 8000863912f27027b709548508e752cab218f859 electron/browser/ui/tray_icon.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon.h"
+
+namespace electron {
+
+TrayIcon::TrayIcon() {
+}
+
+TrayIcon::~TrayIcon() {
+}
+
+void TrayIcon::SetPressedImage(const gfx::Image& image) {
+}
+
+void TrayIcon::SetTitle(const std::string& title) {
+}
+
+void TrayIcon::SetHighlightMode(bool highlight) {
+}
+
+void TrayIcon::DisplayBalloon(const gfx::Image& icon,
+                              const base::string16& title,
+                              const base::string16& contents) {
+}
+
+void TrayIcon::PopUpContextMenu(const gfx::Point& pos,
+                                ui::SimpleMenuModel* menu_model) {
+}
+
+void TrayIcon::NotifyClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyDoubleClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_,
+                    OnDoubleClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyBalloonShow() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonShow());
+}
+
+void TrayIcon::NotifyBalloonClicked() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonClicked());
+}
+
+void TrayIcon::NotifyBalloonClosed() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnBalloonClosed());
+}
+
+void TrayIcon::NotifyRightClicked(const gfx::Rect& bounds, int modifiers) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_,
+                    OnRightClicked(bounds, modifiers));
+}
+
+void TrayIcon::NotifyDrop() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDrop());
+}
+
+void TrayIcon::NotifyDropFiles(const std::vector<std::string>& files) {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDropFiles(files));
+}
+
+void TrayIcon::NotifyDragEntered() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragEntered());
+}
+
+void TrayIcon::NotifyDragExited() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragExited());
+}
+
+void TrayIcon::NotifyDragEnded() {
+  FOR_EACH_OBSERVER(TrayIconObserver, observers_, OnDragEnded());
+}
+
+}  // namespace electron
added in remote
  their  100644 c5f3595ffe3f3983fa54935d2a42340bfb699128 electron/browser/ui/tray_icon.h
@@ -0,0 +1,83 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/ui/tray_icon_observer.h"
+#include "base/observer_list.h"
+#include "ui/base/models/simple_menu_model.h"
+#include "ui/gfx/geometry/rect.h"
+
+namespace electron {
+
+class TrayIcon {
+ public:
+  static TrayIcon* Create();
+
+  virtual ~TrayIcon();
+
+  // Sets the image associated with this status icon.
+  virtual void SetImage(const gfx::Image& image) = 0;
+
+  // Sets the image associated with this status icon when pressed.
+  virtual void SetPressedImage(const gfx::Image& image);
+
+  // Sets the hover text for this status icon. This is also used as the label
+  // for the menu item which is created as a replacement for the status icon
+  // click action on platforms that do not support custom click actions for the
+  // status icon (e.g. Ubuntu Unity).
+  virtual void SetToolTip(const std::string& tool_tip) = 0;
+
+  // Sets the title displayed aside of the status icon in the status bar. This
+  // only works on OS X.
+  virtual void SetTitle(const std::string& title);
+
+  // Sets whether the status icon is highlighted when it is clicked. This only
+  // works on OS X.
+  virtual void SetHighlightMode(bool highlight);
+
+  // Displays a notification balloon with the specified contents.
+  // Depending on the platform it might not appear by the icon tray.
+  virtual void DisplayBalloon(const gfx::Image& icon,
+                              const base::string16& title,
+                              const base::string16& contents);
+
+  // Popups the menu.
+  virtual void PopUpContextMenu(const gfx::Point& pos,
+                                ui::SimpleMenuModel* menu_model);
+
+  // Set the context menu for this icon.
+  virtual void SetContextMenu(ui::SimpleMenuModel* menu_model) = 0;
+
+  void AddObserver(TrayIconObserver* obs) { observers_.AddObserver(obs); }
+  void RemoveObserver(TrayIconObserver* obs) { observers_.RemoveObserver(obs); }
+  void NotifyClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
+  void NotifyDoubleClicked(const gfx::Rect& = gfx::Rect(), int modifiers = 0);
+  void NotifyBalloonShow();
+  void NotifyBalloonClicked();
+  void NotifyBalloonClosed();
+  void NotifyRightClicked(const gfx::Rect& bounds = gfx::Rect(),
+                          int modifiers = 0);
+  void NotifyDrop();
+  void NotifyDropFiles(const std::vector<std::string>& files);
+  void NotifyDragEntered();
+  void NotifyDragExited();
+  void NotifyDragEnded();
+
+ protected:
+  TrayIcon();
+
+ private:
+  base::ObserverList<TrayIconObserver> observers_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIcon);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_H_
added in remote
  their  100644 b7e893c18054c5dc094412942497861d8539efd7 electron/browser/ui/tray_icon_cocoa.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
+
+#import <Cocoa/Cocoa.h>
+
+#include <string>
+
+#include "electron/browser/ui/electron_menu_model.h"
+#include "electron/browser/ui/tray_icon.h"
+#include "base/mac/scoped_nsobject.h"
+
+@class ElectronMenuController;
+@class StatusItemView;
+
+namespace electron {
+
+class TrayIconCocoa : public TrayIcon,
+                      public ElectronMenuModel::Observer {
+ public:
+  TrayIconCocoa();
+  virtual ~TrayIconCocoa();
+
+  void SetImage(const gfx::Image& image) override;
+  void SetPressedImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void SetTitle(const std::string& title) override;
+  void SetHighlightMode(bool highlight) override;
+  void PopUpContextMenu(const gfx::Point& pos,
+                        ui::SimpleMenuModel* menu_model) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ protected:
+  // ElectronMenuModel::Observer:
+  void MenuClosed() override;
+
+ private:
+  // Atom custom view for NSStatusItem.
+  base::scoped_nsobject<StatusItemView> status_item_view_;
+
+  // Status menu shown when right-clicking the system icon.
+  base::scoped_nsobject<ElectronMenuController> menu_;
+
+  // Used for unregistering observer.
+  ElectronMenuModel* menu_model_;  // weak ref.
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIconCocoa);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_COCOA_H_
added in remote
  their  100644 b191951c1214f2057fd00afe38148cb561913b2a electron/browser/ui/tray_icon_cocoa.mm
@@ -0,0 +1,391 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon_cocoa.h"
+
+#include "electron/browser/ui/cocoa/electron_menu_controller.h"
+#include "base/strings/sys_string_conversions.h"
+#include "ui/events/cocoa/cocoa_event_utils.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/screen.h"
+
+namespace {
+
+// By default, OS X sets 4px to tray image as left and right padding margin.
+const CGFloat kHorizontalMargin = 4;
+// OS X tends to make the title 2px lower.
+const CGFloat kVerticalTitleMargin = 2;
+
+}  //  namespace
+
+@interface StatusItemView : NSView {
+  electron::TrayIconCocoa* trayIcon_; // weak
+  ElectronMenuController* menuController_; // weak
+  BOOL isHighlightEnable_;
+  BOOL forceHighlight_;
+  BOOL inMouseEventSequence_;
+  base::scoped_nsobject<NSImage> image_;
+  base::scoped_nsobject<NSImage> alternateImage_;
+  base::scoped_nsobject<NSImageView> image_view_;
+  base::scoped_nsobject<NSString> title_;
+  base::scoped_nsobject<NSStatusItem> statusItem_;
+}
+
+@end  // @interface StatusItemView
+
+@implementation StatusItemView
+
+- (id)initWithImage:(NSImage*)image icon:(electron::TrayIconCocoa*)icon {
+  image_.reset([image copy]);
+  trayIcon_ = icon;
+  isHighlightEnable_ = YES;
+  forceHighlight_ = NO;
+  inMouseEventSequence_ = NO;
+
+  if ((self = [super initWithFrame: CGRectZero])) {
+    // Setup the image view.
+    image_view_.reset([[NSImageView alloc] initWithFrame: CGRectZero]);
+    [image_view_ setImageScaling:NSImageScaleNone];
+    [image_view_ setImageAlignment:NSImageAlignCenter];
+    [self addSubview:image_view_];
+
+    // Unregister image_view_ as a dragged destination, allows its parent view
+    // (StatusItemView) handle dragging events.
+    [image_view_ unregisterDraggedTypes];
+    [self registerForDraggedTypes: @[NSFilenamesPboardType]];
+
+    // Create the status item.
+    NSStatusItem * item = [[NSStatusBar systemStatusBar]
+                            statusItemWithLength:NSVariableStatusItemLength];
+    statusItem_.reset([item retain]);
+    [statusItem_ setView:self];
+
+    // Finalize setup by sizing our views
+    [self updateDimensions];
+  }
+  return self;
+}
+
+- (void)updateDimensions {
+  NSStatusBar * bar = [NSStatusBar systemStatusBar];
+  [image_view_ setFrame: NSMakeRect(0, 0, [self iconWidth], [bar thickness])];
+  [self setFrame: NSMakeRect(0, 0, [self fullWidth], [bar thickness])];
+  [self setNeedsDisplay:YES];
+}
+
+- (void)removeItem {
+  [[NSStatusBar systemStatusBar] removeStatusItem:statusItem_];
+  statusItem_.reset();
+}
+
+- (void)drawRect:(NSRect)dirtyRect {
+  // Draw the tray icon and title that align with NSStatusItem, layout:
+  //   ----------------
+  //   | icon | title |
+  ///  ----------------
+
+  // Draw background.
+  BOOL highlight = [self shouldHighlight];
+  CGFloat thickness = [[statusItem_ statusBar] thickness];
+  [statusItem_ drawStatusBarBackgroundInRect:self.bounds withHighlight:highlight];
+
+  // Make use of NSImageView to draw the image, which can correctly draw
+  // template image under dark menu bar.
+  if (inMouseEventSequence_ && alternateImage_ &&
+      [image_view_ image] != alternateImage_.get()) {
+    [image_view_ setImage:alternateImage_];
+  } else if ([image_view_ image] != image_.get()) {
+    [image_view_ setImage:image_];
+  }
+
+  if (title_) {
+    // Highlight the text when icon is highlighted or in dark mode.
+    highlight |= [self isDarkMode];
+    // Draw title.
+    NSRect titleDrawRect = NSMakeRect(
+        [self iconWidth], -kVerticalTitleMargin, [self titleWidth], thickness);
+    [title_ drawInRect:titleDrawRect
+        withAttributes:[self titleAttributesWithHighlight:highlight]];
+  }
+}
+
+- (BOOL)isDarkMode {
+  NSUserDefaults* defaults = [NSUserDefaults standardUserDefaults];
+  NSString* mode = [defaults stringForKey:@"AppleInterfaceStyle"];
+  return mode && [mode isEqualToString:@"Dark"];
+}
+
+// The width of the full status item.
+- (CGFloat)fullWidth {
+  if (title_)
+    return [self iconWidth] + [self titleWidth] + kHorizontalMargin;
+  else
+    return [self iconWidth];
+}
+
+// The width of the icon.
+- (CGFloat)iconWidth {
+  CGFloat thickness = [[NSStatusBar systemStatusBar] thickness];
+  CGFloat imageHeight = [image_ size].height;
+  CGFloat imageWidth = [image_ size].width;
+  CGFloat iconWidth = imageWidth;
+  if (imageWidth < thickness) {
+    // Image's width must be larger than menu bar's height.
+    iconWidth = thickness;
+  } else {
+    CGFloat verticalMargin = thickness - imageHeight;
+    // Image must have same horizontal vertical margin.
+    if (verticalMargin > 0 && imageWidth != imageHeight)
+      iconWidth = imageWidth + verticalMargin;
+    CGFloat horizontalMargin = thickness - imageWidth;
+    // Image must have at least kHorizontalMargin horizontal margin on each
+    // side.
+    if (horizontalMargin < 2 * kHorizontalMargin)
+      iconWidth = imageWidth + 2 * kHorizontalMargin;
+  }
+  return iconWidth;
+}
+
+// The width of the title.
+- (CGFloat)titleWidth {
+  if (!title_)
+     return 0;
+  base::scoped_nsobject<NSAttributedString> attributes(
+      [[NSAttributedString alloc] initWithString:title_
+                                      attributes:[self titleAttributes]]);
+  return [attributes size].width;
+}
+
+- (NSDictionary*)titleAttributesWithHighlight:(BOOL)highlight {
+  NSFont* font = [NSFont menuBarFontOfSize:0];
+  NSColor* foregroundColor = highlight ?
+      [NSColor whiteColor] :
+      [NSColor colorWithRed:0.265625 green:0.25390625 blue:0.234375 alpha:1.0];
+  return @{
+    NSFontAttributeName: font,
+    NSForegroundColorAttributeName: foregroundColor
+  };
+}
+
+- (NSDictionary*)titleAttributes {
+  return [self titleAttributesWithHighlight:[self isDarkMode]];
+}
+
+- (void)setImage:(NSImage*)image {
+  image_.reset([image copy]);
+  [self updateDimensions];
+}
+
+- (void)setAlternateImage:(NSImage*)image {
+  alternateImage_.reset([image copy]);
+}
+
+- (void)setHighlight:(BOOL)highlight {
+  isHighlightEnable_ = highlight;
+}
+
+- (void)setTitle:(NSString*)title {
+  if (title.length > 0) {
+    title_.reset([title copy]);
+  } else {
+    title_.reset();
+  }
+  [self updateDimensions];
+}
+
+- (void)setMenuController:(ElectronMenuController*)menu {
+  menuController_ = menu;
+}
+
+- (void)mouseDown:(NSEvent*)event {
+  inMouseEventSequence_ = YES;
+  [self setNeedsDisplay:YES];
+}
+
+- (void)mouseUp:(NSEvent*)event {
+  if (!inMouseEventSequence_) {
+     // If the menu is showing, when user clicked the tray icon, the `mouseDown`
+     // event will be dissmissed, we need to close the menu at this time.
+     [self setNeedsDisplay:YES];
+     return;
+  }
+  inMouseEventSequence_ = NO;
+
+  // Show menu when there is a context menu.
+  // NB(hokein): Make tray's behavior more like official one's.
+  // When the tray icon gets clicked quickly multiple times, the
+  // event.clickCount doesn't always return 1. Instead, it returns a value that
+  // counts the clicked times.
+  // So we don't check the clickCount here, just pop up the menu for each click
+  // event.
+  if (menuController_)
+    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
+
+  // Don't emit click events when menu is showing.
+  if (menuController_)
+    return;
+
+  // Single click event.
+  if (event.clickCount == 1)
+    trayIcon_->NotifyClicked(
+        [self getBoundsFromEvent:event],
+        ui::EventFlagsFromModifiers([event modifierFlags]));
+
+  // Double click event.
+  if (event.clickCount == 2)
+    trayIcon_->NotifyDoubleClicked(
+        [self getBoundsFromEvent:event],
+        ui::EventFlagsFromModifiers([event modifierFlags]));
+
+  [self setNeedsDisplay:YES];
+}
+
+- (void)popUpContextMenu:(ui::SimpleMenuModel*)menu_model {
+  // Show a custom menu.
+  if (menu_model) {
+    base::scoped_nsobject<ElectronMenuController> menuController(
+        [[ElectronMenuController alloc] initWithModel:menu_model]);
+    forceHighlight_ = YES;  // Should highlight when showing menu.
+    [self setNeedsDisplay:YES];
+    [statusItem_ popUpStatusItemMenu:[menuController menu]];
+    forceHighlight_ = NO;
+    [self setNeedsDisplay:YES];
+    return;
+  }
+
+  if (menuController_ && ![menuController_ isMenuOpen]) {
+    // Redraw the dray icon to show highlight if it is enabled.
+    [self setNeedsDisplay:YES];
+    [statusItem_ popUpStatusItemMenu:[menuController_ menu]];
+    // The popUpStatusItemMenu returns only after the showing menu is closed.
+    // When it returns, we need to redraw the tray icon to not show highlight.
+    [self setNeedsDisplay:YES];
+  }
+}
+
+- (void)rightMouseUp:(NSEvent*)event {
+  trayIcon_->NotifyRightClicked(
+      [self getBoundsFromEvent:event],
+      ui::EventFlagsFromModifiers([event modifierFlags]));
+}
+
+- (NSDragOperation)draggingEntered:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragEntered();
+  return NSDragOperationCopy;
+}
+
+- (void)draggingExited:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragExited();
+}
+
+- (void)draggingEnded:(id <NSDraggingInfo>)sender {
+  trayIcon_->NotifyDragEnded();
+
+  if (NSPointInRect([sender draggingLocation], self.frame)) {
+    trayIcon_->NotifyDrop();
+    [self handleDrop:sender];
+  }
+}
+
+- (BOOL)handleDrop:(id <NSDraggingInfo>)sender {
+  NSPasteboard* pboard = [sender draggingPasteboard];
+
+  if ([[pboard types] containsObject:NSFilenamesPboardType]) {
+    std::vector<std::string> dropFiles;
+    NSArray* files = [pboard propertyListForType:NSFilenamesPboardType];
+    for (NSString* file in files)
+      dropFiles.push_back(base::SysNSStringToUTF8(file));
+    trayIcon_->NotifyDropFiles(dropFiles);
+    return YES;
+  }
+  return NO;
+}
+
+- (BOOL)prepareForDragOperation:(id <NSDraggingInfo>)sender {
+  return YES;
+}
+
+- (BOOL)performDragOperation:(id <NSDraggingInfo>)sender {
+  return YES;
+}
+
+- (BOOL)shouldHighlight {
+  if (isHighlightEnable_ && forceHighlight_)
+    return true;
+  BOOL isMenuOpen = menuController_ && [menuController_ isMenuOpen];
+  return isHighlightEnable_ && (inMouseEventSequence_ || isMenuOpen);
+}
+
+- (gfx::Rect)getBoundsFromEvent:(NSEvent*)event {
+  NSRect frame = event.window.frame;
+  gfx::Rect bounds(frame.origin.x, 0, NSWidth(frame), NSHeight(frame));
+  NSScreen* screen = [[NSScreen screens] objectAtIndex:0];
+  bounds.set_y(NSHeight([screen frame]) - NSMaxY(frame));
+  return bounds;
+}
+@end
+
+namespace electron {
+
+TrayIconCocoa::TrayIconCocoa() : menu_model_(nullptr) {
+}
+
+TrayIconCocoa::~TrayIconCocoa() {
+  [status_item_view_ removeItem];
+  if (menu_model_)
+    menu_model_->RemoveObserver(this);
+}
+
+void TrayIconCocoa::SetImage(const gfx::Image& image) {
+  if (status_item_view_) {
+    [status_item_view_ setImage:image.AsNSImage()];
+  } else {
+    status_item_view_.reset(
+        [[StatusItemView alloc] initWithImage:image.AsNSImage()
+                                         icon:this]);
+  }
+}
+
+void TrayIconCocoa::SetPressedImage(const gfx::Image& image) {
+  [status_item_view_ setAlternateImage:image.AsNSImage()];
+}
+
+void TrayIconCocoa::SetToolTip(const std::string& tool_tip) {
+  [status_item_view_ setToolTip:base::SysUTF8ToNSString(tool_tip)];
+}
+
+void TrayIconCocoa::SetTitle(const std::string& title) {
+  [status_item_view_ setTitle:base::SysUTF8ToNSString(title)];
+}
+
+void TrayIconCocoa::SetHighlightMode(bool highlight) {
+  [status_item_view_ setHighlight:highlight];
+}
+
+void TrayIconCocoa::PopUpContextMenu(const gfx::Point& pos,
+                                     ui::SimpleMenuModel* menu_model) {
+  [status_item_view_ popUpContextMenu:menu_model];
+}
+
+void TrayIconCocoa::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  // Substribe to MenuClosed event.
+  if (menu_model_)
+    menu_model_->RemoveObserver(this);
+  static_cast<ElectronMenuModel*>(menu_model)->AddObserver(this);
+
+  // Create native menu.
+  menu_.reset([[ElectronMenuController alloc] initWithModel:menu_model]);
+  [status_item_view_ setMenuController:menu_.get()];
+}
+
+void TrayIconCocoa::MenuClosed() {
+  [status_item_view_ setNeedsDisplay:YES];
+}
+
+// static
+TrayIcon* TrayIcon::Create() {
+  return new TrayIconCocoa;
+}
+
+}  // namespace electron
added in remote
  their  100644 65ca76a62ffa000cc8d1cbe24b24e4cac4768de6 electron/browser/ui/tray_icon_gtk.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/tray_icon_gtk.h"
+
+#include "base/guid.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/libgtk2ui/app_indicator_icon.h"
+#include "chrome/browser/ui/libgtk2ui/gtk2_status_icon.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+TrayIconGtk::TrayIconGtk() {
+}
+
+TrayIconGtk::~TrayIconGtk() {
+}
+
+void TrayIconGtk::SetImage(const gfx::Image& image) {
+  if (icon_) {
+    icon_->SetImage(image.AsImageSkia());
+    return;
+  }
+
+  base::string16 empty;
+  if (libgtk2ui::AppIndicatorIcon::CouldOpen())
+    icon_.reset(new libgtk2ui::AppIndicatorIcon(
+        base::GenerateGUID(), image.AsImageSkia(), empty));
+  else
+    icon_.reset(new libgtk2ui::Gtk2StatusIcon(image.AsImageSkia(), empty));
+  icon_->set_delegate(this);
+}
+
+void TrayIconGtk::SetToolTip(const std::string& tool_tip) {
+  icon_->SetToolTip(base::UTF8ToUTF16(tool_tip));
+}
+
+void TrayIconGtk::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  icon_->UpdatePlatformContextMenu(menu_model);
+}
+
+void TrayIconGtk::OnClick() {
+  NotifyClicked();
+}
+
+bool TrayIconGtk::HasClickAction() {
+  return false;
+}
+
+// static
+TrayIcon* TrayIcon::Create() {
+  return new TrayIconGtk;
+}
+
+}  // namespace electron
added in remote
  their  100644 1f1b807c229e6d7d122f26f745da5313e2892bd3 electron/browser/ui/tray_icon_gtk.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
+
+#include <string>
+
+#include "electron/browser/ui/tray_icon.h"
+#include "ui/views/linux_ui/status_icon_linux.h"
+
+namespace views {
+class StatusIconLinux;
+}
+
+namespace electron {
+
+class TrayIconGtk : public TrayIcon,
+                    public views::StatusIconLinux::Delegate {
+ public:
+  TrayIconGtk();
+  virtual ~TrayIconGtk();
+
+  // TrayIcon:
+  void SetImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ private:
+  // views::StatusIconLinux::Delegate:
+  void OnClick() override;
+  bool HasClickAction() override;
+
+  scoped_ptr<views::StatusIconLinux> icon_;
+
+  DISALLOW_COPY_AND_ASSIGN(TrayIconGtk);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_GTK_H_
added in remote
  their  100644 cb9c8ff63d0f0eaf77713dc2e034027d19d36772 electron/browser/ui/tray_icon_observer.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
+#define ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
+
+#include <string>
+#include <vector>
+
+namespace gfx {
+class Rect;
+}
+
+namespace electron {
+
+class TrayIconObserver {
+ public:
+  virtual void OnClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnDoubleClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnBalloonShow() {}
+  virtual void OnBalloonClicked() {}
+  virtual void OnBalloonClosed() {}
+  virtual void OnRightClicked(const gfx::Rect& bounds, int modifiers) {}
+  virtual void OnDrop() {}
+  virtual void OnDropFiles(const std::vector<std::string>& files) {}
+  virtual void OnDragEntered() {}
+  virtual void OnDragExited() {}
+  virtual void OnDragEnded() {}
+
+ protected:
+  virtual ~TrayIconObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_TRAY_ICON_OBSERVER_H_
added in remote
  their  100644 18aac4ca4afbf5bfe3e140b5565ddaea03882706 electron/browser/ui/tray_icon_win.cc
@@ -0,0 +1,16 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon.h"
+#include "electron/browser/ui/win/notify_icon_host.h"
+
+namespace electron {
+
+// static
+TrayIcon* TrayIcon::Create() {
+  static NotifyIconHost host;
+  return host.CreateNotifyIcon();
+}
+
+}  // namespace electron
added in remote
  their  100644 71b045fc76937348c7059b27670bd2709d57438a electron/browser/ui/views/frameless_view.cc
@@ -0,0 +1,118 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/frameless_view.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/aura/window.h"
+#include "ui/base/hit_test.h"
+#include "ui/views/widget/widget.h"
+#include "ui/views/widget/widget_delegate.h"
+
+namespace electron {
+
+namespace {
+
+const int kResizeInsideBoundsSize = 5;
+const int kResizeAreaCornerSize = 16;
+
+const char kViewClassName[] = "FramelessView";
+
+}  // namespace
+
+FramelessView::FramelessView() : window_(NULL), frame_(NULL) {
+}
+
+FramelessView::~FramelessView() {
+}
+
+void FramelessView::Init(NativeWindowViews* window, views::Widget* frame) {
+  window_ = window;
+  frame_ = frame;
+}
+
+int FramelessView::ResizingBorderHitTest(const gfx::Point& point) {
+  // Check the frame first, as we allow a small area overlapping the contents
+  // to be used for resize handles.
+  bool can_ever_resize = frame_->widget_delegate() ?
+      frame_->widget_delegate()->CanResize() :
+      false;
+  // Don't allow overlapping resize handles when the window is maximized or
+  // fullscreen, as it can't be resized in those states.
+  int resize_border =
+      frame_->IsMaximized() || frame_->IsFullscreen() ? 0 :
+      kResizeInsideBoundsSize;
+  return GetHTComponentForFrame(point, resize_border, resize_border,
+      kResizeAreaCornerSize, kResizeAreaCornerSize, can_ever_resize);
+}
+
+gfx::Rect FramelessView::GetBoundsForClientView() const {
+  return bounds();
+}
+
+gfx::Rect FramelessView::GetWindowBoundsForClientBounds(
+    const gfx::Rect& client_bounds) const {
+  gfx::Rect window_bounds = client_bounds;
+  // Enforce minimum size (1, 1) in case that client_bounds is passed with
+  // empty size. This could occur when the frameless window is being
+  // initialized.
+  if (window_bounds.IsEmpty()) {
+    window_bounds.set_width(1);
+    window_bounds.set_height(1);
+  }
+  return window_bounds;
+}
+
+int FramelessView::NonClientHitTest(const gfx::Point& cursor) {
+  if (frame_->IsFullscreen())
+    return HTCLIENT;
+
+  // Check for possible draggable region in the client area for the frameless
+  // window.
+  SkRegion* draggable_region = window_->draggable_region();
+  if (draggable_region && draggable_region->contains(cursor.x(), cursor.y()))
+    return HTCAPTION;
+
+  // Support resizing frameless window by dragging the border.
+  int frame_component = ResizingBorderHitTest(cursor);
+  if (frame_component != HTNOWHERE)
+    return frame_component;
+
+  return HTCLIENT;
+}
+
+void FramelessView::GetWindowMask(const gfx::Size& size,
+                                  gfx::Path* window_mask) {
+}
+
+void FramelessView::ResetWindowControls() {
+}
+
+void FramelessView::UpdateWindowIcon() {
+}
+
+void FramelessView::UpdateWindowTitle() {
+}
+
+void FramelessView::SizeConstraintsChanged() {
+}
+
+gfx::Size FramelessView::GetPreferredSize() const {
+  return frame_->non_client_view()->GetWindowBoundsForClientBounds(
+      gfx::Rect(frame_->client_view()->GetPreferredSize())).size();
+}
+
+gfx::Size FramelessView::GetMinimumSize() const {
+  return window_->GetContentSizeConstraints().GetMinimumSize();
+}
+
+gfx::Size FramelessView::GetMaximumSize() const {
+  return window_->GetContentSizeConstraints().GetMaximumSize();
+}
+
+const char* FramelessView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 050b2e2bb49e28cfd24e51c139847a3b60ffb71f electron/browser/ui/views/frameless_view.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
+
+#include "ui/views/window/non_client_view.h"
+
+namespace views {
+class Widget;
+}
+
+namespace electron {
+
+class NativeWindowViews;
+
+class FramelessView : public views::NonClientFrameView {
+ public:
+  FramelessView();
+  virtual ~FramelessView();
+
+  virtual void Init(NativeWindowViews* window, views::Widget* frame);
+
+  // Returns whether the |point| is on frameless window's resizing border.
+  int ResizingBorderHitTest(const gfx::Point& point);
+
+ protected:
+  // views::NonClientFrameView:
+  gfx::Rect GetBoundsForClientView() const override;
+  gfx::Rect GetWindowBoundsForClientBounds(
+      const gfx::Rect& client_bounds) const override;
+  int NonClientHitTest(const gfx::Point& point) override;
+  void GetWindowMask(const gfx::Size& size,
+                     gfx::Path* window_mask) override;
+  void ResetWindowControls() override;
+  void UpdateWindowIcon() override;
+  void UpdateWindowTitle() override;
+  void SizeConstraintsChanged() override;
+
+  // Overridden from View:
+  gfx::Size GetPreferredSize() const override;
+  gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
+  const char* GetClassName() const override;
+
+  // Not owned.
+  NativeWindowViews* window_;
+  views::Widget* frame_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(FramelessView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_FRAMELESS_VIEW_H_
added in remote
  their  100644 71307107d11d262d7900e340bc72c69219991d69 electron/browser/ui/views/global_menu_bar_x11.cc
@@ -0,0 +1,319 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/global_menu_bar_x11.h"
+
+#include <X11/Xlib.h>
+
+// This conflicts with mate::Converter,
+#undef True
+#undef False
+// and V8.
+#undef None
+
+#include <dlfcn.h>
+#include <glib-object.h>
+
+#include "electron/browser/native_window_views.h"
+#include "base/logging.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/browser/ui/views/frame/global_menu_bar_registrar_x11.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/accelerators/menu_label_accelerator_util_linux.h"
+#include "ui/base/models/menu_model.h"
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+
+// libdbusmenu-glib types
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_func)();
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_new_with_id_func)(int id);
+
+typedef int (*dbusmenu_menuitem_get_id_func)(DbusmenuMenuitem* item);
+typedef GList* (*dbusmenu_menuitem_get_children_func)(DbusmenuMenuitem* item);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_child_append_func)(
+    DbusmenuMenuitem* parent,
+    DbusmenuMenuitem* child);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    const char* value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_variant_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    GVariant* value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_bool_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    bool value);
+typedef DbusmenuMenuitem* (*dbusmenu_menuitem_property_set_int_func)(
+    DbusmenuMenuitem* item,
+    const char* property,
+    int value);
+
+typedef struct _DbusmenuServer      DbusmenuServer;
+typedef DbusmenuServer* (*dbusmenu_server_new_func)(const char* object);
+typedef void (*dbusmenu_server_set_root_func)(DbusmenuServer* self,
+                                              DbusmenuMenuitem* root);
+
+namespace electron {
+
+namespace {
+
+// Retrieved functions from libdbusmenu-glib.
+
+// DbusmenuMenuItem methods:
+dbusmenu_menuitem_new_func menuitem_new = NULL;
+dbusmenu_menuitem_new_with_id_func menuitem_new_with_id = NULL;
+dbusmenu_menuitem_get_id_func menuitem_get_id = NULL;
+dbusmenu_menuitem_get_children_func menuitem_get_children = NULL;
+dbusmenu_menuitem_get_children_func menuitem_take_children = NULL;
+dbusmenu_menuitem_child_append_func menuitem_child_append = NULL;
+dbusmenu_menuitem_property_set_func menuitem_property_set = NULL;
+dbusmenu_menuitem_property_set_variant_func menuitem_property_set_variant =
+    NULL;
+dbusmenu_menuitem_property_set_bool_func menuitem_property_set_bool = NULL;
+dbusmenu_menuitem_property_set_int_func menuitem_property_set_int = NULL;
+
+// DbusmenuServer methods:
+dbusmenu_server_new_func server_new = NULL;
+dbusmenu_server_set_root_func server_set_root = NULL;
+
+// Properties that we set on menu items:
+const char kPropertyEnabled[] = "enabled";
+const char kPropertyLabel[] = "label";
+const char kPropertyShortcut[] = "shortcut";
+const char kPropertyType[] = "type";
+const char kPropertyToggleType[] = "toggle-type";
+const char kPropertyToggleState[] = "toggle-state";
+const char kPropertyVisible[] = "visible";
+const char kPropertyChildrenDisplay[] = "children-display";
+
+const char kToggleCheck[] = "checkmark";
+const char kToggleRadio[] = "radio";
+const char kTypeSeparator[] = "separator";
+const char kDisplaySubmenu[] = "submenu";
+
+void EnsureMethodsLoaded() {
+  static bool attempted_load = false;
+  if (attempted_load)
+    return;
+  attempted_load = true;
+
+  void* dbusmenu_lib = dlopen("libdbusmenu-glib.so", RTLD_LAZY);
+  if (!dbusmenu_lib)
+    dbusmenu_lib = dlopen("libdbusmenu-glib.so.4", RTLD_LAZY);
+  if (!dbusmenu_lib)
+    return;
+
+  // DbusmenuMenuItem methods.
+  menuitem_new = reinterpret_cast<dbusmenu_menuitem_new_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new"));
+  menuitem_new_with_id = reinterpret_cast<dbusmenu_menuitem_new_with_id_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_new_with_id"));
+  menuitem_get_id = reinterpret_cast<dbusmenu_menuitem_get_id_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_id"));
+  menuitem_get_children = reinterpret_cast<dbusmenu_menuitem_get_children_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_get_children"));
+  menuitem_take_children =
+      reinterpret_cast<dbusmenu_menuitem_get_children_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_take_children"));
+  menuitem_child_append = reinterpret_cast<dbusmenu_menuitem_child_append_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_child_append"));
+  menuitem_property_set = reinterpret_cast<dbusmenu_menuitem_property_set_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set"));
+  menuitem_property_set_variant =
+      reinterpret_cast<dbusmenu_menuitem_property_set_variant_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_variant"));
+  menuitem_property_set_bool =
+      reinterpret_cast<dbusmenu_menuitem_property_set_bool_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_bool"));
+  menuitem_property_set_int =
+      reinterpret_cast<dbusmenu_menuitem_property_set_int_func>(
+          dlsym(dbusmenu_lib, "dbusmenu_menuitem_property_set_int"));
+
+  // DbusmenuServer methods.
+  server_new = reinterpret_cast<dbusmenu_server_new_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_server_new"));
+  server_set_root = reinterpret_cast<dbusmenu_server_set_root_func>(
+      dlsym(dbusmenu_lib, "dbusmenu_server_set_root"));
+}
+
+ui::MenuModel* ModelForMenuItem(DbusmenuMenuitem* item) {
+  return reinterpret_cast<ui::MenuModel*>(
+      g_object_get_data(G_OBJECT(item), "model"));
+}
+
+bool GetMenuItemID(DbusmenuMenuitem* item, int *id) {
+  gpointer id_ptr = g_object_get_data(G_OBJECT(item), "menu-id");
+  if (id_ptr != NULL) {
+    *id = GPOINTER_TO_INT(id_ptr) - 1;
+    return true;
+  }
+
+  return false;
+}
+
+void SetMenuItemID(DbusmenuMenuitem* item, int id) {
+  DCHECK_GE(id, 0);
+
+  // Add 1 to the menu_id to avoid setting zero (null) to "menu-id".
+  g_object_set_data(G_OBJECT(item), "menu-id", GINT_TO_POINTER(id + 1));
+}
+
+}  // namespace
+
+GlobalMenuBarX11::GlobalMenuBarX11(NativeWindowViews* window)
+    : window_(window),
+      xid_(window_->GetNativeWindow()->GetHost()->GetAcceleratedWidget()),
+      server_(NULL) {
+  EnsureMethodsLoaded();
+  if (server_new)
+    InitServer(xid_);
+
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
+}
+
+GlobalMenuBarX11::~GlobalMenuBarX11() {
+  if (IsServerStarted())
+    g_object_unref(server_);
+
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
+}
+
+// static
+std::string GlobalMenuBarX11::GetPathForWindow(gfx::AcceleratedWidget xid) {
+  return base::StringPrintf("/com/canonical/menu/%lX", xid);
+}
+
+void GlobalMenuBarX11::SetMenu(ui::MenuModel* menu_model) {
+  if (!IsServerStarted())
+    return;
+
+  DbusmenuMenuitem* root_item = menuitem_new();
+  menuitem_property_set(root_item, kPropertyLabel, "Root");
+  menuitem_property_set_bool(root_item, kPropertyVisible, true);
+  BuildMenuFromModel(menu_model, root_item);
+
+  server_set_root(server_, root_item);
+  g_object_unref(root_item);
+}
+
+bool GlobalMenuBarX11::IsServerStarted() const {
+  return server_;
+}
+
+void GlobalMenuBarX11::InitServer(gfx::AcceleratedWidget xid) {
+  std::string path = GetPathForWindow(xid);
+  server_ = server_new(path.c_str());
+}
+
+void GlobalMenuBarX11::OnWindowMapped() {
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowMapped(xid_);
+}
+
+void GlobalMenuBarX11::OnWindowUnmapped() {
+  GlobalMenuBarRegistrarX11::GetInstance()->OnWindowUnmapped(xid_);
+}
+
+void GlobalMenuBarX11::BuildMenuFromModel(ui::MenuModel* model,
+                                          DbusmenuMenuitem* parent) {
+  for (int i = 0; i < model->GetItemCount(); ++i) {
+    DbusmenuMenuitem* item = menuitem_new();
+    menuitem_property_set_bool(item, kPropertyVisible, model->IsVisibleAt(i));
+
+    ui::MenuModel::ItemType type = model->GetTypeAt(i);
+    if (type == ui::MenuModel::TYPE_SEPARATOR) {
+      menuitem_property_set(item, kPropertyType, kTypeSeparator);
+    } else {
+      std::string label = ui::ConvertAcceleratorsFromWindowsStyle(
+          base::UTF16ToUTF8(model->GetLabelAt(i)));
+      menuitem_property_set(item, kPropertyLabel, label.c_str());
+      menuitem_property_set_bool(item, kPropertyEnabled, model->IsEnabledAt(i));
+
+      g_object_set_data(G_OBJECT(item), "model", model);
+      SetMenuItemID(item, i);
+
+      if (type == ui::MenuModel::TYPE_SUBMENU) {
+        menuitem_property_set(item, kPropertyChildrenDisplay, kDisplaySubmenu);
+        g_signal_connect(item, "about-to-show",
+                         G_CALLBACK(OnSubMenuShowThunk), this);
+      } else {
+        ui::Accelerator accelerator;
+        if (model->GetAcceleratorAt(i, &accelerator))
+          RegisterAccelerator(item, accelerator);
+
+        g_signal_connect(item, "item-activated",
+                         G_CALLBACK(OnItemActivatedThunk), this);
+
+        if (type == ui::MenuModel::TYPE_CHECK ||
+            type == ui::MenuModel::TYPE_RADIO) {
+          menuitem_property_set(item, kPropertyToggleType,
+              type == ui::MenuModel::TYPE_CHECK ? kToggleCheck : kToggleRadio);
+          menuitem_property_set_int(item, kPropertyToggleState,
+              model->IsItemCheckedAt(i));
+        }
+      }
+    }
+
+    menuitem_child_append(parent, item);
+    g_object_unref(item);
+  }
+}
+
+void GlobalMenuBarX11::RegisterAccelerator(DbusmenuMenuitem* item,
+                                           const ui::Accelerator& accelerator) {
+  // A translation of libdbusmenu-gtk's menuitem_property_set_shortcut()
+  // translated from GDK types to ui::Accelerator types.
+  GVariantBuilder builder;
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
+
+  if (accelerator.IsCtrlDown())
+    g_variant_builder_add(&builder, "s", "Control");
+  if (accelerator.IsAltDown())
+    g_variant_builder_add(&builder, "s", "Alt");
+  if (accelerator.IsShiftDown())
+    g_variant_builder_add(&builder, "s", "Shift");
+
+  char* name = XKeysymToString(XKeysymForWindowsKeyCode(
+      accelerator.key_code(), false));
+  if (!name) {
+    NOTIMPLEMENTED();
+    return;
+  }
+  g_variant_builder_add(&builder, "s", name);
+
+  GVariant* inside_array = g_variant_builder_end(&builder);
+  g_variant_builder_init(&builder, G_VARIANT_TYPE_ARRAY);
+  g_variant_builder_add_value(&builder, inside_array);
+  GVariant* outside_array = g_variant_builder_end(&builder);
+
+  menuitem_property_set_variant(item, kPropertyShortcut, outside_array);
+}
+
+void GlobalMenuBarX11::OnItemActivated(DbusmenuMenuitem* item,
+                                       unsigned int timestamp) {
+  int id;
+  ui::MenuModel* model = ModelForMenuItem(item);
+  if (model && GetMenuItemID(item, &id))
+    model->ActivatedAt(id, 0);
+}
+
+void GlobalMenuBarX11::OnSubMenuShow(DbusmenuMenuitem* item) {
+  int id;
+  ui::MenuModel* model = ModelForMenuItem(item);
+  if (!model || !GetMenuItemID(item, &id))
+    return;
+
+  // Clear children.
+  GList *children = menuitem_take_children(item);
+  g_list_foreach(children, reinterpret_cast<GFunc>(g_object_unref), NULL);
+  g_list_free(children);
+
+  // Build children.
+  BuildMenuFromModel(model->GetSubmenuModelAt(id), item);
+}
+
+}  // namespace electron
added in remote
  their  100644 a6942f62d0065f000227744ac3212e1cdb05dd91 electron/browser/ui/views/global_menu_bar_x11.h
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
+#define ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "ui/base/glib/glib_signal.h"
+#include "ui/gfx/native_widget_types.h"
+
+typedef struct _DbusmenuMenuitem DbusmenuMenuitem;
+typedef struct _DbusmenuServer   DbusmenuServer;
+
+namespace ui {
+class Accelerator;
+class MenuModel;
+}
+
+namespace electron {
+
+class NativeWindowViews;
+
+// Controls the Mac style menu bar on Unity.
+//
+// Unity has an Apple-like menu bar at the top of the screen that changes
+// depending on the active window. In the GTK port, we had a hidden GtkMenuBar
+// object in each GtkWindow which existed only to be scrapped by the
+// libdbusmenu-gtk code. Since we don't have GtkWindows anymore, we need to
+// interface directly with the lower level libdbusmenu-glib, which we
+// opportunistically dlopen() since not everyone is running Ubuntu.
+//
+// This class is like the chrome's corresponding one, but it generates the menu
+// from menu models instead, and it is also per-window specific.
+class GlobalMenuBarX11 {
+ public:
+  explicit GlobalMenuBarX11(NativeWindowViews* window);
+  virtual ~GlobalMenuBarX11();
+
+  // Creates the object path for DbusmenuServer which is attached to |xid|.
+  static std::string GetPathForWindow(gfx::AcceleratedWidget xid);
+
+  void SetMenu(ui::MenuModel* menu_model);
+  bool IsServerStarted() const;
+
+  // Called by NativeWindow when it show/hides.
+  void OnWindowMapped();
+  void OnWindowUnmapped();
+
+ private:
+  // Creates a DbusmenuServer.
+  void InitServer(gfx::AcceleratedWidget xid);
+
+  // Create a menu from menu model.
+  void BuildMenuFromModel(ui::MenuModel* model, DbusmenuMenuitem* parent);
+
+  // Sets the accelerator for |item|.
+  void RegisterAccelerator(DbusmenuMenuitem* item,
+                           const ui::Accelerator& accelerator);
+
+  CHROMEG_CALLBACK_1(GlobalMenuBarX11, void, OnItemActivated, DbusmenuMenuitem*,
+                     unsigned int);
+  CHROMEG_CALLBACK_0(GlobalMenuBarX11, void, OnSubMenuShow, DbusmenuMenuitem*);
+
+  NativeWindowViews* window_;
+  gfx::AcceleratedWidget xid_;
+
+  DbusmenuServer* server_;
+
+  DISALLOW_COPY_AND_ASSIGN(GlobalMenuBarX11);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_GLOBAL_MENU_BAR_X11_H_
added in remote
  their  100644 33e1755c50596aea4f605c3c5f0cc05ae4779d88 electron/browser/ui/views/menu_bar.cc
@@ -0,0 +1,162 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_bar.h"
+
+#if defined(USE_X11)
+#include "gtk/gtk.h"
+#endif
+
+#include "electron/browser/ui/views/menu_delegate.h"
+#include "electron/browser/ui/views/submenu_button.h"
+#include "ui/base/models/menu_model.h"
+#include "ui/views/background.h"
+#include "ui/views/layout/box_layout.h"
+
+#if defined(OS_WIN)
+#include "ui/gfx/color_utils.h"
+#elif defined(USE_X11)
+#include "chrome/browser/ui/libgtk2ui/skia_utils_gtk2.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "ElectronMenuBar";
+
+// Default color of the menu bar.
+const SkColor kDefaultColor = SkColorSetARGB(255, 233, 233, 233);
+
+#if defined(USE_X11)
+void GetMenuBarColor(SkColor* enabled, SkColor* disabled, SkColor* highlight,
+                     SkColor* hover, SkColor* background) {
+  GtkWidget* menu_bar = gtk_menu_bar_new();
+
+  GtkStyle* style = gtk_rc_get_style(menu_bar);
+  *enabled = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_NORMAL]);
+  *disabled = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_INSENSITIVE]);
+  *highlight = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_SELECTED]);
+  *hover = libgtk2ui::GdkColorToSkColor(style->fg[GTK_STATE_PRELIGHT]);
+  *background = libgtk2ui::GdkColorToSkColor(style->bg[GTK_STATE_NORMAL]);
+
+  gtk_widget_destroy(menu_bar);
+}
+#endif
+
+}  // namespace
+
+MenuBar::MenuBar()
+    : background_color_(kDefaultColor),
+      menu_model_(NULL) {
+#if defined(OS_WIN)
+  background_color_ = color_utils::GetSysSkColor(COLOR_MENUBAR);
+#elif defined(USE_X11)
+  GetMenuBarColor(&enabled_color_, &disabled_color_, &highlight_color_,
+                  &hover_color_, &background_color_);
+#endif
+
+  set_background(views::Background::CreateSolidBackground(background_color_));
+  SetLayoutManager(new views::BoxLayout(
+      views::BoxLayout::kHorizontal, 0, 0, 0));
+}
+
+MenuBar::~MenuBar() {
+}
+
+void MenuBar::SetMenu(ui::MenuModel* model) {
+  menu_model_ = model;
+  RemoveAllChildViews(true);
+
+  for (int i = 0; i < model->GetItemCount(); ++i) {
+    SubmenuButton* button = new SubmenuButton(this, model->GetLabelAt(i), this);
+    button->set_tag(i);
+
+#if defined(USE_X11)
+    button->SetTextColor(views::Button::STATE_NORMAL, enabled_color_);
+    button->SetTextColor(views::Button::STATE_DISABLED, disabled_color_);
+    button->SetTextColor(views::Button::STATE_PRESSED, highlight_color_);
+    button->SetTextColor(views::Button::STATE_HOVERED, hover_color_);
+    button->SetUnderlineColor(enabled_color_);
+#elif defined(OS_WIN)
+    button->SetUnderlineColor(color_utils::GetSysSkColor(COLOR_GRAYTEXT));
+#endif
+
+    AddChildView(button);
+  }
+}
+
+void MenuBar::SetAcceleratorVisibility(bool visible) {
+  for (int i = 0; i < child_count(); ++i)
+    static_cast<SubmenuButton*>(child_at(i))->SetAcceleratorVisibility(visible);
+}
+
+int MenuBar::GetAcceleratorIndex(base::char16 key) {
+  for (int i = 0; i < child_count(); ++i) {
+    SubmenuButton* button = static_cast<SubmenuButton*>(child_at(i));
+    if (button->accelerator() == key)
+      return i;
+  }
+  return -1;
+}
+
+void MenuBar::ActivateAccelerator(base::char16 key) {
+  int i = GetAcceleratorIndex(key);
+  if (i != -1)
+    static_cast<SubmenuButton*>(child_at(i))->Activate();
+}
+
+int MenuBar::GetItemCount() const {
+  return menu_model_->GetItemCount();
+}
+
+bool MenuBar::GetMenuButtonFromScreenPoint(const gfx::Point& point,
+                                           ui::MenuModel** menu_model,
+                                           views::MenuButton** button) {
+  gfx::Point location(point);
+  views::View::ConvertPointFromScreen(this, &location);
+
+  if (location.x() < 0 || location.x() >= width() || location.y() < 0 ||
+      location.y() >= height())
+    return false;
+
+  for (int i = 0; i < child_count(); ++i) {
+    views::View* view = child_at(i);
+    if (view->bounds().Contains(location) &&
+        (menu_model_->GetTypeAt(i) == ui::MenuModel::TYPE_SUBMENU)) {
+      *menu_model = menu_model_->GetSubmenuModelAt(i);
+      *button = static_cast<views::MenuButton*>(view);
+      return true;
+    }
+  }
+
+  return false;
+}
+
+const char* MenuBar::GetClassName() const {
+  return kViewClassName;
+}
+
+void MenuBar::ButtonPressed(views::Button* sender, const ui::Event& event) {
+}
+
+void MenuBar::OnMenuButtonClicked(views::View* source,
+                                  const gfx::Point& point) {
+  // Hide the accelerator when a submenu is activated.
+  SetAcceleratorVisibility(false);
+
+  if (!menu_model_)
+    return;
+
+  views::MenuButton* button = static_cast<views::MenuButton*>(source);
+  int id = button->tag();
+  ui::MenuModel::ItemType type = menu_model_->GetTypeAt(id);
+  if (type != ui::MenuModel::TYPE_SUBMENU)
+    return;
+
+  MenuDelegate menu_delegate(this);
+  menu_delegate.RunMenu(menu_model_->GetSubmenuModelAt(id), button);
+}
+
+}  // namespace electron
added in remote
  their  100644 74fdcd01c915280994c2232bcbcc1f38946edd27 electron/browser/ui/views/menu_bar.h
@@ -0,0 +1,80 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
+
+#include "ui/views/controls/button/button.h"
+#include "ui/views/controls/button/menu_button_listener.h"
+#include "ui/views/view.h"
+
+namespace ui {
+class MenuModel;
+}
+
+namespace views {
+class MenuButton;
+}
+
+namespace electron {
+
+class MenuDelegate;
+
+class MenuBar : public views::View,
+                public views::ButtonListener,
+                public views::MenuButtonListener {
+ public:
+  MenuBar();
+  virtual ~MenuBar();
+
+  // Replaces current menu with a new one.
+  void SetMenu(ui::MenuModel* menu_model);
+
+  // Shows underline under accelerators.
+  void SetAcceleratorVisibility(bool visible);
+
+  // Returns which submenu has accelerator |key|, -1 would be returned when
+  // there is no matching submenu.
+  int GetAcceleratorIndex(base::char16 key);
+
+  // Shows the submenu whose accelerator is |key|.
+  void ActivateAccelerator(base::char16 key);
+
+  // Returns there are how many items in the root menu.
+  int GetItemCount() const;
+
+  // Get the menu under specified screen point.
+  bool GetMenuButtonFromScreenPoint(const gfx::Point& point,
+                                    ui::MenuModel** menu_model,
+                                    views::MenuButton** button);
+
+ protected:
+  // views::View:
+  const char* GetClassName() const override;
+
+  // views::ButtonListener:
+  void ButtonPressed(views::Button* sender, const ui::Event& event) override;
+
+  // views::MenuButtonListener:
+  void OnMenuButtonClicked(views::View* source,
+                                   const gfx::Point& point) override;
+
+ private:
+  SkColor background_color_;
+
+#if defined(USE_X11)
+  SkColor enabled_color_;
+  SkColor disabled_color_;
+  SkColor highlight_color_;
+  SkColor hover_color_;
+#endif
+
+  ui::MenuModel* menu_model_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuBar);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_BAR_H_
added in remote
  their  100644 e315b0a4c78cb260d7c43086b18d6ac4ffd9313b electron/browser/ui/views/menu_delegate.cc
@@ -0,0 +1,121 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_delegate.h"
+
+#include "electron/browser/ui/views/menu_bar.h"
+#include "content/public/browser/browser_thread.h"
+#include "ui/views/controls/button/menu_button.h"
+#include "ui/views/controls/menu/menu_item_view.h"
+#include "ui/views/controls/menu/menu_model_adapter.h"
+#include "ui/views/controls/menu/menu_runner.h"
+#include "ui/views/widget/widget.h"
+
+namespace electron {
+
+MenuDelegate::MenuDelegate(MenuBar* menu_bar)
+    : menu_bar_(menu_bar),
+      id_(-1) {
+}
+
+MenuDelegate::~MenuDelegate() {
+}
+
+void MenuDelegate::RunMenu(ui::MenuModel* model, views::MenuButton* button) {
+  gfx::Point screen_loc;
+  views::View::ConvertPointToScreen(button, &screen_loc);
+  // Subtract 1 from the height to make the popup flush with the button border.
+  gfx::Rect bounds(screen_loc.x(), screen_loc.y(), button->width(),
+                   button->height() - 1);
+
+  id_ = button->tag();
+  adapter_.reset(new views::MenuModelAdapter(model));
+
+  views::MenuItemView* item = new views::MenuItemView(this);
+  static_cast<views::MenuModelAdapter*>(adapter_.get())->BuildMenu(item);
+
+  menu_runner_.reset(new views::MenuRunner(
+      item,
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS));
+  ignore_result(menu_runner_->RunMenuAt(
+      button->GetWidget()->GetTopLevelWidget(),
+      button,
+      bounds,
+      views::MENU_ANCHOR_TOPRIGHT,
+      ui::MENU_SOURCE_MOUSE));
+}
+
+void MenuDelegate::ExecuteCommand(int id) {
+  adapter_->ExecuteCommand(id);
+}
+
+void MenuDelegate::ExecuteCommand(int id, int mouse_event_flags) {
+  adapter_->ExecuteCommand(id, mouse_event_flags);
+}
+
+bool MenuDelegate::IsTriggerableEvent(views::MenuItemView* source,
+                                      const ui::Event& e) {
+  return adapter_->IsTriggerableEvent(source, e);
+}
+
+bool MenuDelegate::GetAccelerator(int id, ui::Accelerator* accelerator) const {
+  return adapter_->GetAccelerator(id, accelerator);
+}
+
+base::string16 MenuDelegate::GetLabel(int id) const {
+  return adapter_->GetLabel(id);
+}
+
+const gfx::FontList* MenuDelegate::GetLabelFontList(int id) const {
+  return adapter_->GetLabelFontList(id);
+}
+
+bool MenuDelegate::IsCommandEnabled(int id) const {
+  return adapter_->IsCommandEnabled(id);
+}
+
+bool MenuDelegate::IsCommandVisible(int id) const {
+  return adapter_->IsCommandVisible(id);
+}
+
+bool MenuDelegate::IsItemChecked(int id) const {
+  return adapter_->IsItemChecked(id);
+}
+
+void MenuDelegate::SelectionChanged(views::MenuItemView* menu) {
+  adapter_->SelectionChanged(menu);
+}
+
+void MenuDelegate::WillShowMenu(views::MenuItemView* menu) {
+  adapter_->WillShowMenu(menu);
+}
+
+void MenuDelegate::WillHideMenu(views::MenuItemView* menu) {
+  adapter_->WillHideMenu(menu);
+}
+
+views::MenuItemView* MenuDelegate::GetSiblingMenu(
+    views::MenuItemView* menu,
+    const gfx::Point& screen_point,
+    views::MenuAnchorPosition* anchor,
+    bool* has_mnemonics,
+    views::MenuButton**) {
+  views::MenuButton* button;
+  ui::MenuModel* model;
+  if (menu_bar_->GetMenuButtonFromScreenPoint(screen_point, &model, &button) &&
+      button->tag() != id_) {
+    DCHECK(menu_runner_->IsRunning());
+    menu_runner_->Cancel();
+    // After canceling the menu, we need to wait until next tick
+    // so we are out of nested message loop.
+    content::BrowserThread::PostTask(
+        content::BrowserThread::UI, FROM_HERE,
+        base::Bind(base::IgnoreResult(&views::MenuButton::Activate),
+                   base::Unretained(button)));
+  }
+
+  return nullptr;
+}
+
+}  // namespace electron
added in remote
  their  100644 e04cdc4de2fae7e19830cd1a2dbbd7ac6b63e516 electron/browser/ui/views/menu_delegate.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "ui/views/controls/menu/menu_delegate.h"
+
+namespace views {
+class MenuRunner;
+}
+
+namespace ui {
+class MenuModel;
+}
+
+namespace electron {
+
+class MenuBar;
+
+class MenuDelegate : public views::MenuDelegate {
+ public:
+  explicit MenuDelegate(MenuBar* menu_bar);
+  virtual ~MenuDelegate();
+
+  void RunMenu(ui::MenuModel* model, views::MenuButton* button);
+
+ protected:
+  // views::MenuDelegate:
+  void ExecuteCommand(int id) override;
+  void ExecuteCommand(int id, int mouse_event_flags) override;
+  bool IsTriggerableEvent(views::MenuItemView* source,
+                          const ui::Event& e) override;
+  bool GetAccelerator(int id, ui::Accelerator* accelerator) const override;
+  base::string16 GetLabel(int id) const override;
+  const gfx::FontList* GetLabelFontList(int id) const override;
+  bool IsCommandEnabled(int id) const override;
+  bool IsCommandVisible(int id) const override;
+  bool IsItemChecked(int id) const override;
+  void SelectionChanged(views::MenuItemView* menu) override;
+  void WillShowMenu(views::MenuItemView* menu) override;
+  void WillHideMenu(views::MenuItemView* menu) override;
+  views::MenuItemView* GetSiblingMenu(
+      views::MenuItemView* menu,
+      const gfx::Point& screen_point,
+      views::MenuAnchorPosition* anchor,
+      bool* has_mnemonics,
+      views::MenuButton** button) override;
+
+ private:
+  MenuBar* menu_bar_;
+  int id_;
+  scoped_ptr<views::MenuDelegate> adapter_;
+  scoped_ptr<views::MenuRunner> menu_runner_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_DELEGATE_H_
added in remote
  their  100644 7b519840d67a7985862e847db12e794ab4368b32 electron/browser/ui/views/menu_layout.cc
@@ -0,0 +1,86 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/menu_layout.h"
+
+#if defined(OS_WIN)
+#include "electron/browser/native_window_views.h"
+#endif
+
+namespace electron {
+
+namespace {
+
+#if defined(OS_WIN)
+gfx::Rect SubstractBorderSize(gfx::Rect bounds) {
+  int border_width = GetSystemMetrics(SM_CXSIZEFRAME) - 1;
+  int border_height = GetSystemMetrics(SM_CYSIZEFRAME) - 1;
+  bounds.set_x(bounds.x() + border_width);
+  bounds.set_y(bounds.y() + border_height);
+  bounds.set_width(bounds.width() - 2 * border_width);
+  bounds.set_height(bounds.height() - 2 * border_height);
+  return bounds;
+}
+#endif
+
+}  // namespace
+
+MenuLayout::MenuLayout(NativeWindowViews* window, int menu_height)
+    : window_(window),
+      menu_height_(menu_height) {
+}
+
+MenuLayout::~MenuLayout() {
+}
+
+void MenuLayout::Layout(views::View* host) {
+#if defined(OS_WIN)
+  // Reserve border space for maximized frameless window so we won't have the
+  // content go outside of screen.
+  if (!window_->has_frame() && window_->IsMaximized()) {
+    gfx::Rect bounds = SubstractBorderSize(host->GetContentsBounds());
+    host->child_at(0)->SetBoundsRect(bounds);
+    return;
+  }
+#endif
+
+  if (!HasMenu(host)) {
+    views::FillLayout::Layout(host);
+    return;
+  }
+
+  gfx::Size size = host->GetContentsBounds().size();
+  gfx::Rect menu_Bar_bounds = gfx::Rect(0, 0, size.width(), menu_height_);
+  gfx::Rect web_view_bounds = gfx::Rect(
+      0, menu_height_, size.width(), size.height() - menu_height_);
+
+  views::View* web_view = host->child_at(0);
+  views::View* menu_bar = host->child_at(1);
+  web_view->SetBoundsRect(web_view_bounds);
+  menu_bar->SetBoundsRect(menu_Bar_bounds);
+}
+
+gfx::Size MenuLayout::GetPreferredSize(const views::View* host) const {
+  gfx::Size size = views::FillLayout::GetPreferredSize(host);
+  if (!HasMenu(host))
+    return size;
+
+  size.set_height(size.height() + menu_height_);
+  return size;
+}
+
+int MenuLayout::GetPreferredHeightForWidth(
+    const views::View* host, int width) const {
+  int height = views::FillLayout::GetPreferredHeightForWidth(host, width);
+  if (!HasMenu(host))
+    return height;
+
+  return height + menu_height_;
+}
+
+bool MenuLayout::HasMenu(const views::View* host) const {
+  return host->child_count() == 2;
+}
+
+}  // namespace electron
added in remote
  their  100644 bd3cd0ce02fdc781f62087e2682bfa566ed080d9 electron/browser/ui/views/menu_layout.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
+#define ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
+
+#include "ui/views/layout/fill_layout.h"
+
+namespace electron {
+
+class NativeWindowViews;
+
+class MenuLayout : public views::FillLayout {
+ public:
+  MenuLayout(NativeWindowViews* window, int menu_height);
+  virtual ~MenuLayout();
+
+  // views::LayoutManager:
+  void Layout(views::View* host) override;
+  gfx::Size GetPreferredSize(const views::View* host) const override;
+  int GetPreferredHeightForWidth(
+      const views::View* host, int width) const override;
+
+ private:
+  bool HasMenu(const views::View* host) const;
+
+  NativeWindowViews* window_;
+  int menu_height_;
+
+  DISALLOW_COPY_AND_ASSIGN(MenuLayout);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_MENU_LAYOUT_H_
added in remote
  their  100644 e03594e14c81fcb3de7bfbadc21998482f1398be electron/browser/ui/views/native_frame_view.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/native_frame_view.h"
+
+#include "electron/browser/native_window.h"
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "ElectronNativeFrameView";
+
+}  // namespace
+
+NativeFrameView::NativeFrameView(NativeWindow* window, views::Widget* widget)
+    : views::NativeFrameView(widget),
+      window_(window) {
+}
+
+gfx::Size NativeFrameView::GetMinimumSize() const {
+  return window_->GetMinimumSize();
+}
+
+gfx::Size NativeFrameView::GetMaximumSize() const {
+  return window_->GetMaximumSize();
+}
+
+const char* NativeFrameView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 62120374283b0d91cc972ee0af0642d71b5df456 electron/browser/ui/views/native_frame_view.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
+
+#include "ui/views/window/native_frame_view.h"
+
+namespace electron {
+
+class NativeWindow;
+
+// Like the views::NativeFrameView, but returns the min/max size from the
+// NativeWindowViews.
+class NativeFrameView : public views::NativeFrameView {
+ public:
+  NativeFrameView(NativeWindow* window, views::Widget* widget);
+
+ protected:
+  // views::View:
+  gfx::Size GetMinimumSize() const override;
+  gfx::Size GetMaximumSize() const override;
+  const char* GetClassName() const override;
+
+ private:
+  NativeWindow* window_;  // weak ref.
+
+  DISALLOW_COPY_AND_ASSIGN(NativeFrameView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_NATIVE_FRAME_VIEW_H_
added in remote
  their  100644 d4eabbbe790294cded2902f879ec939931e9dcd4 electron/browser/ui/views/submenu_button.cc
@@ -0,0 +1,98 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/submenu_button.h"
+
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/gfx/canvas.h"
+#include "ui/gfx/text_utils.h"
+#include "ui/views/controls/button/label_button_border.h"
+
+namespace electron {
+
+namespace {
+
+// Filter out the "&" in menu label.
+base::string16 FilterAccelerator(const base::string16& label) {
+  base::string16 out;
+  base::RemoveChars(label, base::ASCIIToUTF16("&").c_str(), &out);
+  return out;
+}
+
+}  // namespace
+
+SubmenuButton::SubmenuButton(views::ButtonListener* listener,
+                             const base::string16& title,
+                             views::MenuButtonListener* menu_button_listener)
+    : views::MenuButton(listener, FilterAccelerator(title),
+                        menu_button_listener, false),
+      accelerator_(0),
+      show_underline_(false),
+      underline_start_(-1),
+      underline_end_(-1),
+      text_width_(0),
+      text_height_(0),
+      underline_color_(SK_ColorBLACK) {
+#if defined(OS_LINUX)
+  // Dont' use native style border.
+  SetBorder(std::move(CreateDefaultBorder()));
+#endif
+
+  if (GetUnderlinePosition(title, &accelerator_, &underline_start_,
+                           &underline_end_))
+    gfx::Canvas::SizeStringInt(GetText(), GetFontList(), &text_width_,
+                               &text_height_, 0, 0);
+}
+
+SubmenuButton::~SubmenuButton() {
+}
+
+void SubmenuButton::SetAcceleratorVisibility(bool visible) {
+  if (visible == show_underline_)
+    return;
+
+  show_underline_ = visible;
+  SchedulePaint();
+}
+
+void SubmenuButton::SetUnderlineColor(SkColor color) {
+  underline_color_ = color;
+}
+
+void SubmenuButton::OnPaint(gfx::Canvas* canvas) {
+  views::MenuButton::OnPaint(canvas);
+
+  if (show_underline_ && (underline_start_ != underline_end_)) {
+    int padding = (width() - text_width_) / 2;
+    int underline_height = (height() + text_height_) / 2 - 2;
+    canvas->DrawLine(gfx::Point(underline_start_ + padding, underline_height),
+                     gfx::Point(underline_end_ + padding, underline_height),
+                     underline_color_);
+  }
+}
+
+bool SubmenuButton::GetUnderlinePosition(const base::string16& text,
+                                         base::char16* accelerator,
+                                         int* start, int* end) {
+  int pos, span;
+  base::string16 trimmed = gfx::RemoveAcceleratorChar(text, '&', &pos, &span);
+  if (pos > -1 && span != 0) {
+    *accelerator = base::ToUpperASCII(trimmed[pos]);
+    GetCharacterPosition(trimmed, pos, start);
+    GetCharacterPosition(trimmed, pos + span, end);
+    return true;
+  }
+
+  return false;
+}
+
+void SubmenuButton::GetCharacterPosition(
+    const base::string16& text, int index, int* pos) {
+  int height;
+  gfx::Canvas::SizeStringInt(text.substr(0, index), GetFontList(), pos, &height,
+                             0, 0);
+}
+
+}  // namespace electron
added in remote
  their  100644 275c2b1873109c41364d76bb2964baa28b19ff50 electron/browser/ui/views/submenu_button.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
+#define ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
+
+#include "ui/views/controls/button/menu_button.h"
+
+namespace electron {
+
+// Special button that used by menu bar to show submenus.
+class SubmenuButton : public views::MenuButton {
+ public:
+  SubmenuButton(views::ButtonListener* listener,
+                const base::string16& title,
+                views::MenuButtonListener* menu_button_listener);
+  virtual ~SubmenuButton();
+
+  void SetAcceleratorVisibility(bool visible);
+  void SetUnderlineColor(SkColor color);
+
+  void SetEnabledColor(SkColor color);
+  void SetBackgroundColor(SkColor color);
+
+  base::char16 accelerator() const { return accelerator_; }
+
+  // views::MenuButton:
+  void OnPaint(gfx::Canvas* canvas) override;
+
+ private:
+  bool GetUnderlinePosition(const base::string16& text,
+                            base::char16* accelerator,
+                            int* start, int* end);
+  void GetCharacterPosition(
+      const base::string16& text, int index, int* pos);
+
+  base::char16 accelerator_;
+
+  bool show_underline_;
+
+  int underline_start_;
+  int underline_end_;
+  int text_width_;
+  int text_height_;
+  SkColor underline_color_;
+
+  DISALLOW_COPY_AND_ASSIGN(SubmenuButton);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_SUBMENU_BUTTON_H_
added in remote
  their  100644 b2c6bffe4facf4dd1206961cda1aef8347bcbb19 electron/browser/ui/views/win_frame_view.cc
@@ -0,0 +1,45 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/views/win_frame_view.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/views/widget/widget.h"
+#include "ui/views/win/hwnd_util.h"
+
+namespace electron {
+
+namespace {
+
+const char kViewClassName[] = "WinFrameView";
+
+}  // namespace
+
+
+WinFrameView::WinFrameView() {
+}
+
+WinFrameView::~WinFrameView() {
+}
+
+
+gfx::Rect WinFrameView::GetWindowBoundsForClientBounds(
+    const gfx::Rect& client_bounds) const {
+  return views::GetWindowBoundsForClientBounds(
+      static_cast<views::View*>(const_cast<WinFrameView*>(this)),
+      client_bounds);
+}
+
+int WinFrameView::NonClientHitTest(const gfx::Point& point) {
+  if (window_->has_frame())
+    return frame_->client_view()->NonClientHitTest(point);
+  else
+    return FramelessView::NonClientHitTest(point);
+}
+
+const char* WinFrameView::GetClassName() const {
+  return kViewClassName;
+}
+
+}  // namespace electron
added in remote
  their  100644 b1646da0ea4bc8e1f9fd32fa2b3a6b63574d7ad2 electron/browser/ui/views/win_frame_view.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
+#define ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
+
+#include "electron/browser/ui/views/frameless_view.h"
+
+namespace electron {
+
+class WinFrameView : public FramelessView {
+ public:
+  WinFrameView();
+  virtual ~WinFrameView();
+
+  // views::NonClientFrameView:
+  gfx::Rect GetWindowBoundsForClientBounds(
+      const gfx::Rect& client_bounds) const override;
+  int NonClientHitTest(const gfx::Point& point) override;
+
+  // views::View:
+  const char* GetClassName() const override;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(WinFrameView);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_VIEWS_WIN_FRAME_VIEW_H_
added in remote
  their  100644 20343b603c31e6dc24838892e611ec743bd11fa6 electron/browser/ui/win/electron_desktop_window_tree_host_win.cc
@@ -0,0 +1,28 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/electron_desktop_window_tree_host_win.h"
+
+#include "electron/browser/ui/win/message_handler_delegate.h"
+
+namespace electron {
+
+ElectronDesktopWindowTreeHostWin::ElectronDesktopWindowTreeHostWin(
+    MessageHandlerDelegate* delegate,
+    views::internal::NativeWidgetDelegate* native_widget_delegate,
+    views::DesktopNativeWidgetAura* desktop_native_widget_aura)
+        : views::DesktopWindowTreeHostWin(native_widget_delegate,
+                                          desktop_native_widget_aura),
+          delegate_(delegate) {
+}
+
+ElectronDesktopWindowTreeHostWin::~ElectronDesktopWindowTreeHostWin() {
+}
+
+bool ElectronDesktopWindowTreeHostWin::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  return delegate_->PreHandleMSG(message, w_param, l_param, result);
+}
+
+}  // namespace electron
added in remote
  their  100644 496046cb2e888d916ba8c6dd7d9b037c96840e06 electron/browser/ui/win/electron_desktop_window_tree_host_win.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
+#define ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
+
+#include <windows.h>
+
+#include <vector>
+
+#include "electron/browser/native_window.h"
+#include "ui/views/widget/desktop_aura/desktop_window_tree_host_win.h"
+
+namespace electron {
+
+class MessageHandlerDelegate;
+
+class ElectronDesktopWindowTreeHostWin : public views::DesktopWindowTreeHostWin {
+ public:
+  ElectronDesktopWindowTreeHostWin(
+      MessageHandlerDelegate* delegate,
+      views::internal::NativeWidgetDelegate* native_widget_delegate,
+      views::DesktopNativeWidgetAura* desktop_native_widget_aura);
+  ~ElectronDesktopWindowTreeHostWin() override;
+
+ protected:
+  bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) override;
+
+ private:
+  MessageHandlerDelegate* delegate_;  // weak ref
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronDesktopWindowTreeHostWin);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_ELECTRON_DESKTOP_WINDOW_TREE_HOST_WIN_H_
added in remote
  their  100644 42ac2ec021834f6d0f4d79e93eff111ae553eca9 electron/browser/ui/win/message_handler_delegate.cc
@@ -0,0 +1,14 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/message_handler_delegate.h"
+
+namespace electron {
+
+bool MessageHandlerDelegate::PreHandleMSG(
+    UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result) {
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 6afa05169f48bf5c74502237371f7c03fece7c32 electron/browser/ui/win/message_handler_delegate.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
+#define ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
+
+#include <windows.h>
+
+namespace electron {
+
+class MessageHandlerDelegate {
+ public:
+  // Catch-all message handling and filtering. Called before
+  // HWNDMessageHandler's built-in handling, which may pre-empt some
+  // expectations in Views/Aura if messages are consumed. Returns true if the
+  // message was consumed by the delegate and should not be processed further
+  // by the HWNDMessageHandler. In this case, |result| is returned. |result| is
+  // not modified otherwise.
+  virtual bool PreHandleMSG(
+      UINT message, WPARAM w_param, LPARAM l_param, LRESULT* result);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_MESSAGE_HANDLER_DELEGATE_H_
added in remote
  their  100644 7f49d84ec611d1bf202164aa718b95fdd6d4f0d3 electron/browser/ui/win/notify_icon.cc
@@ -0,0 +1,178 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon.h"
+
+#include "electron/browser/ui/win/notify_icon_host.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/windows_version.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/icon_util.h"
+#include "ui/gfx/image/image.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/screen.h"
+#include "ui/views/controls/menu/menu_runner.h"
+
+namespace electron {
+
+NotifyIcon::NotifyIcon(NotifyIconHost* host,
+                       UINT id,
+                       HWND window,
+                       UINT message)
+    : host_(host),
+      icon_id_(id),
+      window_(window),
+      message_id_(message),
+      menu_model_(NULL) {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_MESSAGE;
+  icon_data.uCallbackMessage = message_id_;
+  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
+  // This can happen if the explorer process isn't running when we try to
+  // create the icon for some reason (for example, at startup).
+  if (!result)
+    LOG(WARNING) << "Unable to create status tray icon.";
+}
+
+NotifyIcon::~NotifyIcon() {
+  // Remove our icon.
+  host_->Remove(this);
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  Shell_NotifyIcon(NIM_DELETE, &icon_data);
+}
+
+void NotifyIcon::HandleClickEvent(int modifiers,
+                                  bool left_mouse_click,
+                                  bool double_button_click) {
+  NOTIFYICONIDENTIFIER icon_id;
+  memset(&icon_id, 0, sizeof(NOTIFYICONIDENTIFIER));
+  icon_id.uID = icon_id_;
+  icon_id.hWnd = window_;
+  icon_id.cbSize = sizeof(NOTIFYICONIDENTIFIER);
+
+  RECT rect = { 0 };
+  Shell_NotifyIconGetRect(&icon_id, &rect);
+
+  if (left_mouse_click) {
+    if (double_button_click)  // double left click
+      NotifyDoubleClicked(gfx::Rect(rect), modifiers);
+    else  // single left click
+      NotifyClicked(gfx::Rect(rect), modifiers);
+    return;
+  } else if (!double_button_click) {  // single right click
+    if (menu_model_)
+      PopUpContextMenu(gfx::Point(), menu_model_);
+    else
+      NotifyRightClicked(gfx::Rect(rect), modifiers);
+  }
+}
+
+void NotifyIcon::ResetIcon() {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  // Delete any previously existing icon.
+  Shell_NotifyIcon(NIM_DELETE, &icon_data);
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_MESSAGE;
+  icon_data.uCallbackMessage = message_id_;
+  icon_data.hIcon = icon_.get();
+  // If we have an image, then set the NIF_ICON flag, which tells
+  // Shell_NotifyIcon() to set the image for the status icon it creates.
+  if (icon_data.hIcon)
+    icon_data.uFlags |= NIF_ICON;
+  // Re-add our icon.
+  BOOL result = Shell_NotifyIcon(NIM_ADD, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to re-create status tray icon.";
+}
+
+void NotifyIcon::SetImage(const gfx::Image& image) {
+  // Create the icon.
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_ICON;
+  icon_ = IconUtil::CreateHICONFromSkBitmap(image.AsBitmap());
+  icon_data.hIcon = icon_.get();
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Error setting status tray icon image";
+}
+
+void NotifyIcon::SetPressedImage(const gfx::Image& image) {
+  // Ignore pressed images, since the standard on Windows is to not highlight
+  // pressed status icons.
+}
+
+void NotifyIcon::SetToolTip(const std::string& tool_tip) {
+  // Create the icon.
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_TIP;
+  wcsncpy_s(icon_data.szTip, base::UTF8ToUTF16(tool_tip).c_str(), _TRUNCATE);
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to set tooltip for status tray icon";
+}
+
+void NotifyIcon::DisplayBalloon(const gfx::Image& icon,
+                                const base::string16& title,
+                                const base::string16& contents) {
+  NOTIFYICONDATA icon_data;
+  InitIconData(&icon_data);
+  icon_data.uFlags |= NIF_INFO;
+  icon_data.dwInfoFlags = NIIF_INFO;
+  wcsncpy_s(icon_data.szInfoTitle, title.c_str(), _TRUNCATE);
+  wcsncpy_s(icon_data.szInfo, contents.c_str(), _TRUNCATE);
+  icon_data.uTimeout = 0;
+
+  base::win::Version win_version = base::win::GetVersion();
+  if (!icon.IsEmpty() && win_version != base::win::VERSION_PRE_XP) {
+    balloon_icon_ = IconUtil::CreateHICONFromSkBitmap(icon.AsBitmap());
+    icon_data.hBalloonIcon = balloon_icon_.get();
+    icon_data.dwInfoFlags = NIIF_USER | NIIF_LARGE_ICON;
+  }
+
+  BOOL result = Shell_NotifyIcon(NIM_MODIFY, &icon_data);
+  if (!result)
+    LOG(WARNING) << "Unable to create status tray balloon.";
+}
+
+void NotifyIcon::PopUpContextMenu(const gfx::Point& pos,
+                                  ui::SimpleMenuModel* menu_model) {
+  // Returns if context menu isn't set.
+  if (!menu_model)
+    return;
+  // Set our window as the foreground window, so the context menu closes when
+  // we click away from it.
+  if (!SetForegroundWindow(window_))
+    return;
+
+  // Show menu at mouse's position by default.
+  gfx::Rect rect(pos, gfx::Size());
+  if (pos.IsOrigin())
+    rect.set_origin(gfx::Screen::GetNativeScreen()->GetCursorScreenPoint());
+
+  views::MenuRunner menu_runner(
+      menu_model,
+      views::MenuRunner::CONTEXT_MENU | views::MenuRunner::HAS_MNEMONICS);
+  ignore_result(menu_runner.RunMenuAt(
+      NULL, NULL, rect, views::MENU_ANCHOR_TOPLEFT, ui::MENU_SOURCE_MOUSE));
+}
+
+void NotifyIcon::SetContextMenu(ui::SimpleMenuModel* menu_model) {
+  menu_model_ = menu_model;
+}
+
+void NotifyIcon::InitIconData(NOTIFYICONDATA* icon_data) {
+  memset(icon_data, 0, sizeof(NOTIFYICONDATA));
+  icon_data->cbSize = sizeof(NOTIFYICONDATA);
+  icon_data->hWnd = window_;
+  icon_data->uID = icon_id_;
+}
+
+}  // namespace electron
added in remote
  their  100644 881bc42fac90122b20bb8ed53234f07f1fad0045 electron/browser/ui/win/notify_icon.h
@@ -0,0 +1,87 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
+#define ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
+
+#include <windows.h>
+#include <shellapi.h>
+
+#include <string>
+
+#include "electron/browser/ui/tray_icon.h"
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/win/scoped_gdi_object.h"
+
+namespace gfx {
+class Point;
+}
+
+namespace electron {
+
+class NotifyIconHost;
+
+class NotifyIcon : public TrayIcon {
+ public:
+  // Constructor which provides this icon's unique ID and messaging window.
+  NotifyIcon(NotifyIconHost* host, UINT id, HWND window, UINT message);
+  virtual ~NotifyIcon();
+
+  // Handles a click event from the user - if |left_button_click| is true and
+  // there is a registered observer, passes the click event to the observer,
+  // otherwise displays the context menu if there is one.
+  void HandleClickEvent(int modifiers,
+                        bool left_button_click,
+                        bool double_button_click);
+
+  // Re-creates the status tray icon now after the taskbar has been created.
+  void ResetIcon();
+
+  UINT icon_id() const { return icon_id_; }
+  HWND window() const { return window_; }
+  UINT message_id() const { return message_id_; }
+
+  // Overridden from TrayIcon:
+  void SetImage(const gfx::Image& image) override;
+  void SetPressedImage(const gfx::Image& image) override;
+  void SetToolTip(const std::string& tool_tip) override;
+  void DisplayBalloon(const gfx::Image& icon,
+                      const base::string16& title,
+                      const base::string16& contents) override;
+  void PopUpContextMenu(const gfx::Point& pos,
+                        ui::SimpleMenuModel* menu_model) override;
+  void SetContextMenu(ui::SimpleMenuModel* menu_model) override;
+
+ private:
+  void InitIconData(NOTIFYICONDATA* icon_data);
+
+  // The tray that owns us.  Weak.
+  NotifyIconHost* host_;
+
+  // The unique ID corresponding to this icon.
+  UINT icon_id_;
+
+  // Window used for processing messages from this icon.
+  HWND window_;
+
+  // The message identifier used for status icon messages.
+  UINT message_id_;
+
+  // The currently-displayed icon for the window.
+  base::win::ScopedHICON icon_;
+
+  // The currently-displayed icon for the notification balloon.
+  base::win::ScopedHICON balloon_icon_;
+
+  // The context menu.
+  ui::SimpleMenuModel* menu_model_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotifyIcon);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_H_
added in remote
  their  100644 13766649534a30eae66a1eb89288a24efd5c46c2 electron/browser/ui/win/notify_icon_host.cc
@@ -0,0 +1,190 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/notify_icon_host.h"
+
+#include <commctrl.h>
+#include <winuser.h>
+
+#include "electron/browser/ui/win/notify_icon.h"
+#include "base/bind.h"
+#include "base/stl_util.h"
+#include "base/threading/non_thread_safe.h"
+#include "base/threading/thread.h"
+#include "base/win/win_util.h"
+#include "base/win/wrapped_window_proc.h"
+#include "ui/events/event_constants.h"
+#include "ui/events/win/system_event_state_lookup.h"
+#include "ui/gfx/win/hwnd_util.h"
+
+namespace electron {
+
+namespace {
+
+const UINT kNotifyIconMessage = WM_APP + 1;
+
+// |kBaseIconId| is 2 to avoid conflicts with plugins that hard-code id 1.
+const UINT kBaseIconId = 2;
+
+const wchar_t kNotifyIconHostWindowClass[] = L"Electron_NotifyIconHostWindow";
+
+bool IsWinPressed() {
+  return ((::GetKeyState(VK_LWIN) & 0x8000) == 0x8000) ||
+         ((::GetKeyState(VK_RWIN) & 0x8000) == 0x8000);
+}
+
+int GetKeyboardModifers() {
+  int modifiers = ui::EF_NONE;
+  if (ui::win::IsShiftPressed())
+    modifiers |= ui::EF_SHIFT_DOWN;
+  if (ui::win::IsCtrlPressed())
+    modifiers |= ui::EF_CONTROL_DOWN;
+  if (ui::win::IsAltPressed())
+    modifiers |= ui::EF_ALT_DOWN;
+  if (IsWinPressed())
+    modifiers |= ui::EF_COMMAND_DOWN;
+  return modifiers;
+}
+
+}  // namespace
+
+NotifyIconHost::NotifyIconHost()
+    : next_icon_id_(1),
+      electron_(0),
+      instance_(NULL),
+      window_(NULL) {
+  // Register our window class
+  WNDCLASSEX window_class;
+  base::win::InitializeWindowClass(
+      kNotifyIconHostWindowClass,
+      &base::win::WrappedWindowProc<NotifyIconHost::WndProcStatic>,
+      0, 0, 0, NULL, NULL, NULL, NULL, NULL,
+      &window_class);
+  instance_ = window_class.hInstance;
+  electron_ = RegisterClassEx(&window_class);
+  CHECK(electron_);
+
+  // If the taskbar is re-created after we start up, we have to rebuild all of
+  // our icons.
+  taskbar_created_message_ = RegisterWindowMessage(TEXT("TaskbarCreated"));
+
+  // Create an offscreen window for handling messages for the status icons. We
+  // create a hidden WS_POPUP window instead of an HWND_MESSAGE window, because
+  // only top-level windows such as popups can receive broadcast messages like
+  // "TaskbarCreated".
+  window_ = CreateWindow(MAKEINTATOM(electron_),
+                         0, WS_POPUP, 0, 0, 0, 0, 0, 0, instance_, 0);
+  gfx::CheckWindowCreated(window_);
+  gfx::SetWindowUserData(window_, this);
+}
+
+NotifyIconHost::~NotifyIconHost() {
+  if (window_)
+    DestroyWindow(window_);
+
+  if (electron_)
+    UnregisterClass(MAKEINTATOM(electron_), instance_);
+
+  NotifyIcons copied_container(notify_icons_);
+  STLDeleteContainerPointers(copied_container.begin(), copied_container.end());
+}
+
+NotifyIcon* NotifyIconHost::CreateNotifyIcon() {
+  NotifyIcon* notify_icon =
+      new NotifyIcon(this, NextIconId(), window_, kNotifyIconMessage);
+  notify_icons_.push_back(notify_icon);
+  return notify_icon;
+}
+
+void NotifyIconHost::Remove(NotifyIcon* icon) {
+  NotifyIcons::iterator i(
+      std::find(notify_icons_.begin(), notify_icons_.end(), icon));
+
+  if (i == notify_icons_.end()) {
+    NOTREACHED();
+    return;
+  }
+
+  notify_icons_.erase(i);
+}
+
+LRESULT CALLBACK NotifyIconHost::WndProcStatic(HWND hwnd,
+                                              UINT message,
+                                              WPARAM wparam,
+                                              LPARAM lparam) {
+  NotifyIconHost* msg_wnd = reinterpret_cast<NotifyIconHost*>(
+      GetWindowLongPtr(hwnd, GWLP_USERDATA));
+  if (msg_wnd)
+    return msg_wnd->WndProc(hwnd, message, wparam, lparam);
+  else
+    return ::DefWindowProc(hwnd, message, wparam, lparam);
+}
+
+LRESULT CALLBACK NotifyIconHost::WndProc(HWND hwnd,
+                                        UINT message,
+                                        WPARAM wparam,
+                                        LPARAM lparam) {
+  if (message == taskbar_created_message_) {
+    // We need to reset all of our icons because the taskbar went away.
+    for (NotifyIcons::const_iterator i(notify_icons_.begin());
+         i != notify_icons_.end(); ++i) {
+      NotifyIcon* win_icon = static_cast<NotifyIcon*>(*i);
+      win_icon->ResetIcon();
+    }
+    return TRUE;
+  } else if (message == kNotifyIconMessage) {
+    NotifyIcon* win_icon = NULL;
+
+    // Find the selected status icon.
+    for (NotifyIcons::const_iterator i(notify_icons_.begin());
+         i != notify_icons_.end(); ++i) {
+      NotifyIcon* current_win_icon = static_cast<NotifyIcon*>(*i);
+      if (current_win_icon->icon_id() == wparam) {
+        win_icon = current_win_icon;
+        break;
+      }
+    }
+
+    // It is possible for this procedure to be called with an obsolete icon
+    // id.  In that case we should just return early before handling any
+    // actions.
+    if (!win_icon)
+      return TRUE;
+
+    switch (lparam) {
+      case TB_CHECKBUTTON:
+        win_icon->NotifyBalloonShow();
+        return TRUE;
+
+      case TB_INDETERMINATE:
+        win_icon->NotifyBalloonClicked();
+        return TRUE;
+
+      case TB_HIDEBUTTON:
+        win_icon->NotifyBalloonClosed();
+        return TRUE;
+
+      case WM_LBUTTONDOWN:
+      case WM_RBUTTONDOWN:
+      case WM_LBUTTONDBLCLK:
+      case WM_RBUTTONDBLCLK:
+      case WM_CONTEXTMENU:
+        // Walk our icons, find which one was clicked on, and invoke its
+        // HandleClickEvent() method.
+        win_icon->HandleClickEvent(
+            GetKeyboardModifers(),
+            (lparam == WM_LBUTTONDOWN || lparam == WM_LBUTTONDBLCLK),
+            (lparam == WM_LBUTTONDBLCLK || lparam == WM_RBUTTONDBLCLK));
+        return TRUE;
+    }
+  }
+  return ::DefWindowProc(hwnd, message, wparam, lparam);
+}
+
+UINT NotifyIconHost::NextIconId() {
+  UINT icon_id = next_icon_id_++;
+  return kBaseIconId + icon_id;
+}
+
+}  // namespace electron
added in remote
  their  100644 7a3383ee576ee87b11ea7c62b073f5179c2c2f76 electron/browser/ui/win/notify_icon_host.h
@@ -0,0 +1,63 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
+#define ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
+
+#include <windows.h>
+
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace electron {
+
+class NotifyIcon;
+
+class NotifyIconHost {
+ public:
+  NotifyIconHost();
+  ~NotifyIconHost();
+
+  NotifyIcon* CreateNotifyIcon();
+  void Remove(NotifyIcon* notify_icon);
+
+ private:
+  typedef std::vector<NotifyIcon*> NotifyIcons;
+
+  // Static callback invoked when a message comes in to our messaging window.
+  static LRESULT CALLBACK
+      WndProcStatic(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
+
+  LRESULT CALLBACK
+      WndProc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam);
+
+  UINT NextIconId();
+
+  // The unique icon ID we will assign to the next icon.
+  UINT next_icon_id_;
+
+  // List containing all active NotifyIcons.
+  NotifyIcons notify_icons_;
+
+  // The window class of |window_|.
+  ATOM electron_;
+
+  // The handle of the module that contains the window procedure of |window_|.
+  HMODULE instance_;
+
+  // The window used for processing events.
+  HWND window_;
+
+  // The message ID of the "TaskbarCreated" message, sent to us when we need to
+  // reset our status icons.
+  UINT taskbar_created_message_;
+
+  DISALLOW_COPY_AND_ASSIGN(NotifyIconHost);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_NOTIFY_ICON_HOST_H_
added in remote
  their  100644 282717800b0cc78e81f24df32988a5b57bb604d2 electron/browser/ui/win/taskbar_host.cc
@@ -0,0 +1,166 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/win/taskbar_host.h"
+
+#include <string>
+
+#include "base/stl_util.h"
+#include "base/win/scoped_gdi_object.h"
+#include "base/strings/utf_string_conversions.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/gfx/icon_util.h"
+
+namespace electron {
+
+namespace {
+
+// From MSDN: https://msdn.microsoft.com/en-us/library/windows/desktop/dd378460(v=vs.85).aspx#thumbbars
+// The thumbnail toolbar has a maximum of seven buttons due to the limited room.
+const size_t kMaxButtonsCount = 7;
+
+// The base id of Thumbar button.
+const int kButtonIdBase = 40001;
+
+bool GetThumbarButtonFlags(const std::vector<std::string>& flags,
+                           THUMBBUTTONFLAGS* out) {
+  THUMBBUTTONFLAGS result = THBF_ENABLED;  // THBF_ENABLED == 0
+  for (const auto& flag : flags) {
+    if (flag == "disabled")
+      result |= THBF_DISABLED;
+    else if (flag == "dismissonclick")
+      result |= THBF_DISMISSONCLICK;
+    else if (flag == "nobackground")
+      result |= THBF_NOBACKGROUND;
+    else if (flag == "hidden")
+      result |= THBF_HIDDEN;
+    else if (flag == "noninteractive")
+      result |= THBF_NONINTERACTIVE;
+    else
+      return false;
+  }
+  *out = result;
+  return true;
+}
+
+}  // namespace
+
+TaskbarHost::TaskbarHost() : thumbar_buttons_added_(false) {
+}
+
+TaskbarHost::~TaskbarHost() {
+}
+
+bool TaskbarHost::SetThumbarButtons(
+    HWND window, const std::vector<ThumbarButton>& buttons) {
+  if (buttons.size() > kMaxButtonsCount || !InitailizeTaskbar())
+    return false;
+
+  callback_map_.clear();
+
+  // The number of buttons in thumbar can not be changed once it is created,
+  // so we have to claim kMaxButtonsCount buttons initialy in case users add
+  // more buttons later.
+  base::win::ScopedHICON icons[kMaxButtonsCount] = {};
+  THUMBBUTTON thumb_buttons[kMaxButtonsCount] = {};
+
+  for (size_t i = 0; i < kMaxButtonsCount; ++i) {
+    THUMBBUTTON& thumb_button = thumb_buttons[i];
+
+    // Set ID.
+    thumb_button.iId = kButtonIdBase + i;
+    thumb_button.dwMask = THB_FLAGS;
+
+    if (i >= buttons.size()) {
+      // This button is used to occupy the place in toolbar, and it does not
+      // show.
+      thumb_button.dwFlags = THBF_HIDDEN;
+      continue;
+    }
+
+    // This button is user's button.
+    const ThumbarButton& button = buttons[i];
+
+    // Generate flags.
+    thumb_button.dwFlags = THBF_ENABLED;
+    if (!GetThumbarButtonFlags(button.flags, &thumb_button.dwFlags))
+      return false;
+
+    // Set icon.
+    if (!button.icon.IsEmpty()) {
+      thumb_button.dwMask |= THB_ICON;
+      icons[i] = IconUtil::CreateHICONFromSkBitmap(button.icon.AsBitmap());
+      thumb_button.hIcon = icons[i].get();
+    }
+
+    // Set tooltip.
+    if (!button.tooltip.empty()) {
+      thumb_button.dwMask |= THB_TOOLTIP;
+      wcsncpy_s(thumb_button.szTip, base::UTF8ToUTF16(button.tooltip).c_str(),
+                _TRUNCATE);
+    }
+
+    // Save callback.
+    callback_map_[thumb_button.iId] = button.clicked_callback;
+  }
+
+  // Finally add them to taskbar.
+  HRESULT r;
+  if (thumbar_buttons_added_)
+    r = taskbar_->ThumbBarUpdateButtons(window, kMaxButtonsCount,
+                                        thumb_buttons);
+  else
+    r = taskbar_->ThumbBarAddButtons(window, kMaxButtonsCount, thumb_buttons);
+
+  thumbar_buttons_added_ = true;
+  return SUCCEEDED(r);
+}
+
+bool TaskbarHost::SetProgressBar(HWND window, double value) {
+  if (!InitailizeTaskbar())
+    return false;
+
+  HRESULT r;
+  if (value > 1.0)
+    r = taskbar_->SetProgressState(window, TBPF_INDETERMINATE);
+  else if (value < 0)
+    r = taskbar_->SetProgressState(window, TBPF_NOPROGRESS);
+  else
+    r = taskbar_->SetProgressValue(window, static_cast<int>(value * 100), 100);
+  return SUCCEEDED(r);
+}
+
+bool TaskbarHost::SetOverlayIcon(
+    HWND window, const gfx::Image& overlay, const std::string& text) {
+  if (!InitailizeTaskbar())
+    return false;
+
+  base::win::ScopedHICON icon(
+      IconUtil::CreateHICONFromSkBitmap(overlay.AsBitmap()));
+  return SUCCEEDED(taskbar_->SetOverlayIcon(
+      window, icon.get(), base::UTF8ToUTF16(text).c_str()));
+}
+
+bool TaskbarHost::HandleThumbarButtonEvent(int button_id) {
+  if (ContainsKey(callback_map_, button_id)) {
+    auto callback = callback_map_[button_id];
+    if (!callback.is_null())
+      callback.Run();
+    return true;
+  }
+  return false;
+}
+
+bool TaskbarHost::InitailizeTaskbar() {
+  if (FAILED(taskbar_.CreateInstance(CLSID_TaskbarList,
+                                     nullptr,
+                                     CLSCTX_INPROC_SERVER)) ||
+      FAILED(taskbar_->HrInit())) {
+    return false;
+  } else {
+    return true;
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 bef917602487ee3d60637e9636be87655f5986ed electron/browser/ui/win/taskbar_host.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
+#define ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
+
+#include <shobjidl.h>
+
+#include <map>
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "base/win/scoped_comptr.h"
+#include "ui/gfx/image/image.h"
+
+namespace electron {
+
+class TaskbarHost {
+ public:
+  struct ThumbarButton {
+    std::string tooltip;
+    gfx::Image icon;
+    std::vector<std::string> flags;
+    base::Closure clicked_callback;
+  };
+
+  TaskbarHost();
+  virtual ~TaskbarHost();
+
+  // Add or update the buttons in thumbar.
+  bool SetThumbarButtons(
+      HWND window, const std::vector<ThumbarButton>& buttons);
+
+  // Set the progress state in taskbar.
+  bool SetProgressBar(HWND window, double value);
+
+  // Set the overlay icon in taskbar.
+  bool SetOverlayIcon(
+      HWND window, const gfx::Image& overlay, const std::string& text);
+
+  // Called by the window that there is a button in thumbar clicked.
+  bool HandleThumbarButtonEvent(int button_id);
+
+ private:
+  // Initailize the taskbar object.
+  bool InitailizeTaskbar();
+
+  using CallbackMap = std::map<int, base::Closure>;
+  CallbackMap callback_map_;
+
+  // The COM object of taskbar.
+  base::win::ScopedComPtr<ITaskbarList3> taskbar_;
+
+  // Whether we have already added the buttons to thumbar.
+  bool thumbar_buttons_added_;
+
+  DISALLOW_COPY_AND_ASSIGN(TaskbarHost);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_WIN_TASKBAR_HOST_H_
added in remote
  their  100644 03973bb4a904f59c85780f2351872f2231b89854 electron/browser/ui/x/window_state_watcher.cc
@@ -0,0 +1,78 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/x/window_state_watcher.h"
+
+#include <X11/Xlib.h>
+
+#include "ui/events/platform/platform_event_source.h"
+
+namespace electron {
+
+namespace {
+
+const char* kAtomsToCache[] = {
+  "_NET_WM_STATE",
+  NULL,
+};
+
+}  // namespace
+
+WindowStateWatcher::WindowStateWatcher(NativeWindowViews* window)
+    : window_(window),
+      widget_(window->GetAcceleratedWidget()),
+      electron_cache_(gfx::GetXDisplay(), kAtomsToCache),
+      was_minimized_(false),
+      was_maximized_(false) {
+  ui::PlatformEventSource::GetInstance()->AddPlatformEventObserver(this);
+}
+
+WindowStateWatcher::~WindowStateWatcher() {
+  ui::PlatformEventSource::GetInstance()->RemovePlatformEventObserver(this);
+}
+
+void WindowStateWatcher::WillProcessEvent(const ui::PlatformEvent& event) {
+  if (IsWindowStateEvent(event)) {
+    was_minimized_ = window_->IsMinimized();
+    was_maximized_ = window_->IsMaximized();
+  }
+}
+
+void WindowStateWatcher::DidProcessEvent(const ui::PlatformEvent& event) {
+  if (IsWindowStateEvent(event)) {
+    bool is_minimized = window_->IsMinimized();
+    bool is_maximized = window_->IsMaximized();
+    bool is_fullscreen = window_->IsFullscreen();
+    if (is_minimized != was_minimized_) {
+      if (is_minimized)
+        window_->NotifyWindowMinimize();
+      else
+        window_->NotifyWindowRestore();
+    } else if (is_maximized != was_maximized_) {
+      if (is_maximized)
+        window_->NotifyWindowMaximize();
+      else
+        window_->NotifyWindowUnmaximize();
+    } else {
+      // If this is neither a "maximize" or "minimize" event, then we think it
+      // is a "fullscreen" event.
+      // The "IsFullscreen()" becomes true immediately before "WillProcessEvent"
+      // is called, so we can not handle this like "maximize" and "minimize" by
+      // watching whether they have changed.
+      if (is_fullscreen)
+        window_->NotifyWindowEnterFullScreen();
+      else
+        window_->NotifyWindowLeaveFullScreen();
+    }
+  }
+}
+
+bool WindowStateWatcher::IsWindowStateEvent(const ui::PlatformEvent& event) {
+  ::Atom changed_atom = event->xproperty.atom;
+  return (changed_atom == electron_cache_.GetAtom("_NET_WM_STATE") &&
+          event->type == PropertyNotify &&
+          event->xproperty.window == widget_);
+}
+
+}  // namespace electron
added in remote
  their  100644 74bc431ddeb1fa5de43c51765d168ae21913e9ce electron/browser/ui/x/window_state_watcher.h
@@ -0,0 +1,41 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
+#define ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
+
+#include "ui/events/platform/platform_event_observer.h"
+
+#include "electron/browser/native_window_views.h"
+#include "ui/gfx/x/x11_electron_cache.h"
+
+namespace electron {
+
+class WindowStateWatcher : public ui::PlatformEventObserver {
+ public:
+  explicit WindowStateWatcher(NativeWindowViews* window);
+  virtual ~WindowStateWatcher();
+
+ protected:
+  // ui::PlatformEventObserver:
+  void WillProcessEvent(const ui::PlatformEvent& event) override;
+  void DidProcessEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  bool IsWindowStateEvent(const ui::PlatformEvent& event);
+
+  NativeWindowViews* window_;
+  gfx::AcceleratedWidget widget_;
+
+  ui::X11ElectronCache electron_cache_;
+
+  bool was_minimized_;
+  bool was_maximized_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowStateWatcher);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_X_WINDOW_STATE_WATCHER_H_
added in remote
  their  100644 3ac72fd71d88ccd7227d0d1b1da37108f91bc506 electron/browser/ui/x/x_window_utils.cc
@@ -0,0 +1,90 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/ui/x/x_window_utils.h"
+
+#include <X11/Xatom.h>
+
+#include "base/environment.h"
+#include "base/strings/string_util.h"
+#include "dbus/bus.h"
+#include "dbus/object_proxy.h"
+#include "dbus/message.h"
+#include "ui/base/x/x11_util.h"
+
+namespace electron {
+
+::Atom GetAtom(const char* name) {
+  return XInternAtom(gfx::GetXDisplay(), name, false);
+}
+
+void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state) {
+  XEvent xclient;
+  memset(&xclient, 0, sizeof(xclient));
+  xclient.type = ClientMessage;
+  xclient.xclient.window = xwindow;
+  xclient.xclient.message_type = GetAtom("_NET_WM_STATE");
+  xclient.xclient.format = 32;
+  xclient.xclient.data.l[0] = enabled ? 1 : 0;
+  xclient.xclient.data.l[1] = state;
+  xclient.xclient.data.l[2] = None;
+  xclient.xclient.data.l[3] = 1;
+  xclient.xclient.data.l[4] = 0;
+
+  XDisplay* xdisplay = gfx::GetXDisplay();
+  XSendEvent(xdisplay, DefaultRootWindow(xdisplay), False,
+             SubstructureRedirectMask | SubstructureNotifyMask,
+             &xclient);
+}
+
+void SetWindowType(::Window xwindow, const std::string& type) {
+  XDisplay* xdisplay = gfx::GetXDisplay();
+  std::string type_prefix = "_NET_WM_WINDOW_TYPE_";
+  ::Atom window_type = XInternAtom(
+      xdisplay, (type_prefix + base::ToUpperASCII(type)).c_str(), False);
+  XChangeProperty(xdisplay, xwindow,
+                  XInternAtom(xdisplay, "_NET_WM_WINDOW_TYPE", False),
+                  XA_ATOM,
+                  32, PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&window_type), 1);
+}
+
+bool ShouldUseGlobalMenuBar() {
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (env->HasVar("ELECTRON_FORCE_WINDOW_MENU_BAR"))
+    return false;
+
+  dbus::Bus::Options options;
+  scoped_refptr<dbus::Bus> bus(new dbus::Bus(options));
+
+  dbus::ObjectProxy* object_proxy =
+      bus->GetObjectProxy(DBUS_SERVICE_DBUS, dbus::ObjectPath(DBUS_PATH_DBUS));
+  dbus::MethodCall method_call(DBUS_INTERFACE_DBUS, "ListNames");
+  scoped_ptr<dbus::Response> response(object_proxy->CallMethodAndBlock(
+      &method_call, dbus::ObjectProxy::TIMEOUT_USE_DEFAULT));
+  if (!response) {
+    bus->ShutdownAndBlock();
+    return false;
+  }
+
+  dbus::MessageReader reader(response.get());
+  dbus::MessageReader array_reader(NULL);
+  if (!reader.PopArray(&array_reader)) {
+    bus->ShutdownAndBlock();
+    return false;
+  }
+  while (array_reader.HasMoreData()) {
+    std::string name;
+    if (array_reader.PopString(&name) &&
+        name == "com.canonical.AppMenu.Registrar") {
+      bus->ShutdownAndBlock();
+      return true;
+    }
+  }
+
+  bus->ShutdownAndBlock();
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 d089d1b3a38c87baabc4c0a1d7f4af36f58a510d electron/browser/ui/x/x_window_utils.h
@@ -0,0 +1,30 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
+#define ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
+
+#include <X11/extensions/XInput2.h>
+#include <X11/extensions/Xrandr.h>
+#include <X11/Xlib.h>
+
+#include <string>
+
+namespace electron {
+
+::Atom GetAtom(const char* name);
+
+// Sends a message to the x11 window manager, enabling or disabling the |state|
+// for _NET_WM_STATE.
+void SetWMSpecState(::Window xwindow, bool enabled, ::Atom state);
+
+// Sets the _NET_WM_WINDOW_TYPE of window.
+void SetWindowType(::Window xwindow, const std::string& type);
+
+// Returns true if the bus name "com.canonical.AppMenu.Registrar" is available.
+bool ShouldUseGlobalMenuBar();
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_UI_X_X_WINDOW_UTILS_H_
added in remote
  their  100644 135c54efc88b175de6c922777c263b4a9f85491d electron/browser/web_contents_permission_helper.cc
@@ -0,0 +1,94 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_contents_permission_helper.h"
+
+#include <string>
+
+#include "electron/browser/electron_permission_manager.h"
+#include "brightray/browser/media/media_stream_devices_controller.h"
+#include "content/public/browser/browser_context.h"
+#include "content/public/browser/render_process_host.h"
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::WebContentsPermissionHelper);
+
+namespace electron {
+
+namespace {
+
+void MediaAccessAllowed(
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& callback,
+    bool allowed) {
+  brightray::MediaStreamDevicesController controller(request, callback);
+  if (allowed)
+    controller.TakeAction();
+  else
+    controller.Deny(content::MEDIA_DEVICE_PERMISSION_DENIED);
+}
+
+void OnPointerLockResponse(content::WebContents* web_contents, bool allowed) {
+  if (web_contents)
+    web_contents->GotResponseToLockMouseRequest(allowed);
+}
+
+void OnPermissionResponse(const base::Callback<void(bool)>& callback,
+                          content::PermissionStatus status) {
+  if (status == content::PERMISSION_STATUS_GRANTED)
+    callback.Run(true);
+  else
+    callback.Run(false);
+}
+
+}  // namespace
+
+WebContentsPermissionHelper::WebContentsPermissionHelper(
+    content::WebContents* web_contents)
+    : web_contents_(web_contents) {
+}
+
+WebContentsPermissionHelper::~WebContentsPermissionHelper() {
+}
+
+void WebContentsPermissionHelper::RequestPermission(
+    content::PermissionType permission,
+    const base::Callback<void(bool)>& callback,
+    bool user_gesture) {
+  auto rfh = web_contents_->GetMainFrame();
+  auto permission_manager = static_cast<ElectronPermissionManager*>(
+      web_contents_->GetBrowserContext()->GetPermissionManager());
+  auto origin = web_contents_->GetLastCommittedURL();
+  permission_manager->RequestPermission(
+      permission, rfh, origin, user_gesture,
+      base::Bind(&OnPermissionResponse, callback));
+}
+
+void WebContentsPermissionHelper::RequestFullscreenPermission(
+    const base::Callback<void(bool)>& callback) {
+  RequestPermission((content::PermissionType)(PermissionType::FULLSCREEN),
+                    callback);
+}
+
+void WebContentsPermissionHelper::RequestMediaAccessPermission(
+    const content::MediaStreamRequest& request,
+    const content::MediaResponseCallback& response_callback) {
+  auto callback = base::Bind(&MediaAccessAllowed, request, response_callback);
+  // The permission type doesn't matter here, AUDIO_CAPTURE/VIDEO_CAPTURE
+  // are presented as same type in content_converter.h.
+  RequestPermission(content::PermissionType::AUDIO_CAPTURE, callback);
+}
+
+void WebContentsPermissionHelper::RequestWebNotificationPermission(
+    const base::Callback<void(bool)>& callback) {
+  RequestPermission(content::PermissionType::NOTIFICATIONS, callback);
+}
+
+void WebContentsPermissionHelper::RequestPointerLockPermission(
+    bool user_gesture) {
+  RequestPermission((content::PermissionType)(PermissionType::POINTER_LOCK),
+                    base::Bind(&OnPointerLockResponse, web_contents_),
+                    user_gesture);
+}
+
+}  // namespace electron
added in remote
  their  100644 7eb71959cabd6f3ab628c3b721ff9dcc46e0c609 electron/browser/web_contents_permission_helper.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2016 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
+#define ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
+
+#include "content/public/browser/permission_type.h"
+#include "content/public/browser/web_contents_user_data.h"
+#include "content/public/common/media_stream_request.h"
+
+namespace electron {
+
+// Applies the permission requested for WebContents.
+class WebContentsPermissionHelper
+    : public content::WebContentsUserData<WebContentsPermissionHelper> {
+ public:
+  ~WebContentsPermissionHelper() override;
+
+  enum class PermissionType {
+    POINTER_LOCK = static_cast<int>(content::PermissionType::NUM) + 1,
+    FULLSCREEN
+  };
+
+  void RequestFullscreenPermission(
+      const base::Callback<void(bool)>& callback);
+  void RequestMediaAccessPermission(
+      const content::MediaStreamRequest& request,
+      const content::MediaResponseCallback& callback);
+  void RequestWebNotificationPermission(
+      const base::Callback<void(bool)>& callback);
+  void RequestPointerLockPermission(bool user_gesture);
+
+ private:
+  explicit WebContentsPermissionHelper(content::WebContents* web_contents);
+  friend class content::WebContentsUserData<WebContentsPermissionHelper>;
+
+  void RequestPermission(
+      content::PermissionType permission,
+      const base::Callback<void(bool)>& callback,
+      bool user_gesture = false);
+
+  content::WebContents* web_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsPermissionHelper);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_CONTENTS_PERMISSION_HELPER_H_
added in remote
  their  100644 6ebe09ad537121f811cea6293095108a06d5ecee electron/browser/web_contents_preferences.cc
@@ -0,0 +1,201 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_contents_preferences.h"
+
+#include <algorithm>
+#include <string>
+#include <vector>
+
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/options_switches.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/common/web_preferences.h"
+#include "native_mate/dictionary.h"
+#include "net/base/filename_util.h"
+
+#if defined(OS_WIN)
+#include "ui/gfx/switches.h"
+#endif
+
+DEFINE_WEB_CONTENTS_USER_DATA_KEY(electron::WebContentsPreferences);
+
+namespace electron {
+
+// static
+std::vector<WebContentsPreferences*> WebContentsPreferences::instances_;
+
+WebContentsPreferences::WebContentsPreferences(
+    content::WebContents* web_contents,
+    const mate::Dictionary& web_preferences)
+    : web_contents_(web_contents) {
+  v8::Isolate* isolate = web_preferences.isolate();
+  mate::Dictionary copied(isolate, web_preferences.GetHandle()->Clone());
+  // Following fields should not be stored.
+  copied.Delete("embedder");
+  copied.Delete("isGuest");
+  copied.Delete("session");
+
+  mate::ConvertFromV8(isolate, copied.GetHandle(), &web_preferences_);
+  web_contents->SetUserData(UserDataKey(), this);
+
+  instances_.push_back(this);
+}
+
+WebContentsPreferences::~WebContentsPreferences() {
+  instances_.erase(
+      std::remove(instances_.begin(), instances_.end(), this),
+      instances_.end());
+}
+
+void WebContentsPreferences::Merge(const base::DictionaryValue& extend) {
+  web_preferences_.MergeDictionary(&extend);
+}
+
+// static
+content::WebContents* WebContentsPreferences::GetWebContentsFromProcessID(
+    int process_id) {
+  for (WebContentsPreferences* preferences : instances_) {
+    content::WebContents* web_contents = preferences->web_contents_;
+    if (web_contents->GetRenderProcessHost()->GetID() == process_id)
+      return web_contents;
+  }
+  return nullptr;
+}
+
+// static
+void WebContentsPreferences::AppendExtraCommandLineSwitches(
+    content::WebContents* web_contents, base::CommandLine* command_line) {
+  WebContentsPreferences* self = FromWebContents(web_contents);
+  if (!self)
+    return;
+
+  base::DictionaryValue& web_preferences = self->web_preferences_;
+
+  bool b;
+#if defined(OS_WIN)
+  // Check if DirectWrite is disabled.
+  if (web_preferences.GetBoolean(options::kDirectWrite, &b) && !b)
+    command_line->AppendSwitch(::switches::kDisableDirectWrite);
+#endif
+
+  // Check if plugins are enabled.
+  if (web_preferences.GetBoolean("plugins", &b) && b)
+    command_line->AppendSwitch(switches::kEnablePlugins);
+
+  // Experimental flags.
+  if (web_preferences.GetBoolean(options::kExperimentalFeatures, &b) && b)
+    command_line->AppendSwitch(
+        ::switches::kEnableExperimentalWebPlatformFeatures);
+  if (web_preferences.GetBoolean(options::kExperimentalCanvasFeatures, &b) && b)
+    command_line->AppendSwitch(::switches::kEnableExperimentalCanvasFeatures);
+
+  // Check if we have node integration specified.
+  bool node_integration = true;
+  web_preferences.GetBoolean(options::kNodeIntegration, &node_integration);
+  // Be compatible with old API of "node-integration" option.
+  std::string old_token;
+  if (web_preferences.GetString(options::kNodeIntegration, &old_token) &&
+      old_token != "disable")
+    node_integration = true;
+  command_line->AppendSwitchASCII(switches::kNodeIntegration,
+                                  node_integration ? "true" : "false");
+
+  // The preload script.
+  base::FilePath::StringType preload;
+  if (web_preferences.GetString(options::kPreloadScript, &preload)) {
+    if (base::FilePath(preload).IsAbsolute())
+      command_line->AppendSwitchNative(switches::kPreloadScript, preload);
+    else
+      LOG(ERROR) << "preload script must have absolute path.";
+  } else if (web_preferences.GetString(options::kPreloadURL, &preload)) {
+    // Translate to file path if there is "preload-url" option.
+    base::FilePath preload_path;
+    if (net::FileURLToFilePath(GURL(preload), &preload_path))
+      command_line->AppendSwitchPath(switches::kPreloadScript, preload_path);
+    else
+      LOG(ERROR) << "preload url must be file:// protocol.";
+  }
+
+  // The zoom factor.
+  double zoom_factor = 1.0;
+  if (web_preferences.GetDouble(options::kZoomFactor, &zoom_factor) &&
+      zoom_factor != 1.0)
+    command_line->AppendSwitchASCII(switches::kZoomFactor,
+                                    base::DoubleToString(zoom_factor));
+
+  // --guest-instance-id, which is used to identify guest WebContents.
+  int guest_instance_id;
+  if (web_preferences.GetInteger(options::kGuestInstanceID, &guest_instance_id))
+      command_line->AppendSwitchASCII(switches::kGuestInstanceID,
+                                      base::IntToString(guest_instance_id));
+
+  // Pass the opener's window id.
+  int opener_id;
+  if (web_preferences.GetInteger(options::kOpenerID, &opener_id))
+      command_line->AppendSwitchASCII(switches::kOpenerID,
+                                      base::IntToString(opener_id));
+
+  // Enable blink features.
+  std::string blink_features;
+  if (web_preferences.GetString(options::kBlinkFeatures, &blink_features))
+      command_line->AppendSwitchASCII(::switches::kEnableBlinkFeatures,
+                                      blink_features);
+}
+
+// static
+void WebContentsPreferences::OverrideWebkitPrefs(
+    content::WebContents* web_contents, content::WebPreferences* prefs) {
+  WebContentsPreferences* self = FromWebContents(web_contents);
+  if (!self)
+    return;
+
+  bool b;
+  if (self->web_preferences_.GetBoolean("javascript", &b))
+    prefs->javascript_enabled = b;
+  if (self->web_preferences_.GetBoolean("images", &b))
+    prefs->images_enabled = b;
+  if (self->web_preferences_.GetBoolean("textAreasAreResizable", &b))
+    prefs->text_areas_are_resizable = b;
+  if (self->web_preferences_.GetBoolean("webgl", &b))
+    prefs->experimental_webgl_enabled = b;
+  if (self->web_preferences_.GetBoolean("webaudio", &b))
+    prefs->webaudio_enabled = b;
+  if (self->web_preferences_.GetBoolean("webSecurity", &b)) {
+    prefs->web_security_enabled = b;
+    prefs->allow_displaying_insecure_content = !b;
+    prefs->allow_running_insecure_content = !b;
+  }
+  if (self->web_preferences_.GetBoolean("allowDisplayingInsecureContent", &b))
+    prefs->allow_displaying_insecure_content = b;
+  if (self->web_preferences_.GetBoolean("allowRunningInsecureContent", &b))
+    prefs->allow_running_insecure_content = b;
+  const base::DictionaryValue* fonts = nullptr;
+  if (self->web_preferences_.GetDictionary("defaultFontFamily", &fonts)) {
+    base::string16 font;
+    if (fonts->GetString("standard", &font))
+      prefs->standard_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("serif", &font))
+      prefs->serif_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("sansSerif", &font))
+      prefs->sans_serif_font_family_map[content::kCommonScript] = font;
+    if (fonts->GetString("monospace", &font))
+      prefs->fixed_font_family_map[content::kCommonScript] = font;
+  }
+  int size;
+  if (self->web_preferences_.GetInteger("defaultFontSize", &size))
+    prefs->default_font_size = size;
+  if (self->web_preferences_.GetInteger("defaultMonospaceFontSize", &size))
+    prefs->default_fixed_font_size = size;
+  if (self->web_preferences_.GetInteger("minimumFontSize", &size))
+    prefs->minimum_font_size = size;
+  std::string encoding;
+  if (self->web_preferences_.GetString("defaultEncoding", &encoding))
+    prefs->default_encoding = encoding;
+}
+
+}  // namespace electron
added in remote
  their  100644 50a0a01168755a9a21b81bf7bea13293be66a0a3 electron/browser/web_contents_preferences.h
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
+#define ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
+
+#include <vector>
+
+#include "base/values.h"
+#include "content/public/browser/web_contents_user_data.h"
+
+namespace base {
+class CommandLine;
+}
+
+namespace content {
+struct WebPreferences;
+}
+
+namespace mate {
+class Dictionary;
+}
+
+namespace electron {
+
+// Stores and applies the preferences of WebContents.
+class WebContentsPreferences
+    : public content::WebContentsUserData<WebContentsPreferences> {
+ public:
+  // Get WebContents according to process ID.
+  static content::WebContents* GetWebContentsFromProcessID(int process_id);
+
+  // Append command paramters according to |web_contents|'s preferences.
+  static void AppendExtraCommandLineSwitches(
+      content::WebContents* web_contents, base::CommandLine* command_line);
+
+  // Modify the WebPreferences according to |web_contents|'s preferences.
+  static void OverrideWebkitPrefs(
+      content::WebContents* web_contents, content::WebPreferences* prefs);
+
+  WebContentsPreferences(content::WebContents* web_contents,
+                         const mate::Dictionary& web_preferences);
+  ~WebContentsPreferences() override;
+
+  // $.extend(|web_preferences_|, |new_web_preferences|).
+  void Merge(const base::DictionaryValue& new_web_preferences);
+
+  // Returns the web preferences.
+  base::DictionaryValue* web_preferences() { return &web_preferences_; }
+
+ private:
+  friend class content::WebContentsUserData<WebContentsPreferences>;
+
+  static std::vector<WebContentsPreferences*> instances_;
+
+  content::WebContents* web_contents_;
+  base::DictionaryValue web_preferences_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebContentsPreferences);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_CONTENTS_PREFERENCES_H_
added in remote
  their  100644 50ebe0e1e2e3e18763399bef278e177ecb9e12b1 electron/browser/web_dialog_helper.cc
@@ -0,0 +1,155 @@
+// Copyright (c) 2014 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_dialog_helper.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/electron_browser_context.h"
+#include "electron/browser/native_window.h"
+#include "electron/browser/ui/file_dialog.h"
+#include "base/bind.h"
+#include "base/files/file_enumerator.h"
+#include "base/files/file_path.h"
+#include "base/prefs/pref_service.h"
+#include "base/strings/utf_string_conversions.h"
+#include "chrome/common/pref_names.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/file_chooser_file_info.h"
+#include "net/base/mime_util.h"
+#include "ui/shell_dialogs/selected_file_info.h"
+
+namespace {
+
+file_dialog::Filters GetFileTypesFromAcceptType(
+    const std::vector<base::string16>& accept_types) {
+  file_dialog::Filters filters;
+  if (accept_types.empty())
+    return filters;
+
+  std::vector<base::FilePath::StringType> extensions;
+
+  for (const auto& accept_type : accept_types) {
+    std::string ascii_type = base::UTF16ToASCII(accept_type);
+    if (ascii_type[0] == '.') {
+      // If the type starts with a period it is assumed to be a file extension,
+      // like `.txt`, // so we just have to add it to the list.
+      base::FilePath::StringType extension(
+          ascii_type.begin(), ascii_type.end());
+      // Skip the first character.
+      extensions.push_back(extension.substr(1));
+    } else {
+      // For MIME Type, `audio/*, vidio/*, image/*
+      net::GetExtensionsForMimeType(ascii_type, &extensions);
+    }
+  }
+
+  // If no valid exntesion is added, return empty filters.
+  if (extensions.empty())
+    return filters;
+
+  filters.push_back(file_dialog::Filter());
+  for (const auto& extension : extensions) {
+#if defined(OS_WIN)
+    filters[0].second.push_back(base::UTF16ToASCII(extension));
+#else
+    filters[0].second.push_back(extension);
+#endif
+  }
+  return filters;
+}
+
+}  // namespace
+
+namespace electron {
+
+WebDialogHelper::WebDialogHelper(NativeWindow* window)
+    : window_(window),
+      weak_factory_(this) {
+}
+
+WebDialogHelper::~WebDialogHelper() {
+}
+
+
+void WebDialogHelper::RunFileChooser(content::WebContents* web_contents,
+                                     const content::FileChooserParams& params) {
+  std::vector<content::FileChooserFileInfo> result;
+  file_dialog::Filters filters = GetFileTypesFromAcceptType(
+      params.accept_types);
+  if (params.mode == content::FileChooserParams::Save) {
+    base::FilePath path;
+    if (file_dialog::ShowSaveDialog(window_,
+                                    base::UTF16ToUTF8(params.title),
+                                    params.default_file_name,
+                                    filters,
+                                    &path)) {
+      content::FileChooserFileInfo info;
+      info.file_path = path;
+      info.display_name = path.BaseName().value();
+      result.push_back(info);
+    }
+  } else {
+    int flags = file_dialog::FILE_DIALOG_CREATE_DIRECTORY;
+    switch (params.mode) {
+      case content::FileChooserParams::OpenMultiple:
+        flags |= file_dialog::FILE_DIALOG_MULTI_SELECTIONS;
+      case content::FileChooserParams::Open:
+        flags |= file_dialog::FILE_DIALOG_OPEN_FILE;
+        break;
+      case content::FileChooserParams::UploadFolder:
+        flags |= file_dialog::FILE_DIALOG_OPEN_DIRECTORY;
+        break;
+      default:
+        NOTREACHED();
+    }
+
+    std::vector<base::FilePath> paths;
+    ElectronBrowserContext* browser_context = static_cast<ElectronBrowserContext*>(
+        window_->web_contents()->GetBrowserContext());
+    base::FilePath default_file_path = browser_context->prefs()->GetFilePath(
+        prefs::kSelectFileLastDirectory).Append(params.default_file_name);
+    if (file_dialog::ShowOpenDialog(window_,
+                                    base::UTF16ToUTF8(params.title),
+                                    default_file_path,
+                                    filters,
+                                    flags,
+                                    &paths)) {
+      for (auto& path : paths) {
+        content::FileChooserFileInfo info;
+        info.file_path = path;
+        info.display_name = path.BaseName().value();
+        result.push_back(info);
+      }
+      if (!paths.empty()) {
+        browser_context->prefs()->SetFilePath(prefs::kSelectFileLastDirectory,
+                                              paths[0].DirName());
+      }
+    }
+  }
+
+  web_contents->GetRenderViewHost()->FilesSelectedInChooser(
+      result, params.mode);
+}
+
+void WebDialogHelper::EnumerateDirectory(content::WebContents* web_contents,
+                                         int request_id,
+                                         const base::FilePath& dir) {
+  int types = base::FileEnumerator::FILES |
+              base::FileEnumerator::DIRECTORIES |
+              base::FileEnumerator::INCLUDE_DOT_DOT;
+  base::FileEnumerator file_enum(dir, false, types);
+
+  base::FilePath path;
+  std::vector<base::FilePath> paths;
+  while (!(path = file_enum.Next()).empty())
+    paths.push_back(path);
+
+  web_contents->GetRenderViewHost()->DirectoryEnumerationFinished(
+      request_id, paths);
+}
+
+}  // namespace electron
added in remote
  their  100644 1b9553541f826e1fa451b9ac0b2131b57c382b07 electron/browser/web_dialog_helper.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2014 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
+#define ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
+
+#include "base/memory/weak_ptr.h"
+
+namespace base {
+class FilePath;
+}
+
+namespace content {
+struct FileChooserParams;
+class WebContents;
+}
+
+namespace electron {
+
+class NativeWindow;
+
+class WebDialogHelper {
+ public:
+  explicit WebDialogHelper(NativeWindow* window);
+  ~WebDialogHelper();
+
+  void RunFileChooser(content::WebContents* web_contents,
+                      const content::FileChooserParams& params);
+  void EnumerateDirectory(content::WebContents* web_contents,
+                          int request_id,
+                          const base::FilePath& path);
+
+ private:
+  NativeWindow* window_;
+
+  base::WeakPtrFactory<WebDialogHelper> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebDialogHelper);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_DIALOG_HELPER_H_
added in remote
  their  100644 14f4778359cd08208dbd7d05e1a1a5a10fb523a7 electron/browser/web_view_guest_delegate.cc
@@ -0,0 +1,157 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_view_guest_delegate.h"
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "content/public/browser/guest_host.h"
+#include "content/public/browser/render_frame_host.h"
+#include "content/public/browser/render_view_host.h"
+#include "content/public/browser/render_widget_host.h"
+#include "content/public/browser/render_widget_host_view.h"
+
+namespace electron {
+
+namespace {
+
+const int kDefaultWidth = 300;
+const int kDefaultHeight = 300;
+
+}  // namespace
+
+WebViewGuestDelegate::WebViewGuestDelegate()
+    : guest_host_(nullptr),
+      auto_size_enabled_(false),
+      is_full_page_plugin_(false),
+      api_web_contents_(nullptr) {
+}
+
+WebViewGuestDelegate::~WebViewGuestDelegate() {
+}
+
+void WebViewGuestDelegate::Initialize(api::WebContents* api_web_contents) {
+  api_web_contents_ = api_web_contents;
+  Observe(api_web_contents->GetWebContents());
+}
+
+void WebViewGuestDelegate::Destroy() {
+  // Give the content module an opportunity to perform some cleanup.
+  guest_host_->WillDestroy();
+  guest_host_ = nullptr;
+}
+
+void WebViewGuestDelegate::SetSize(const SetSizeParams& params) {
+  bool enable_auto_size =
+      params.enable_auto_size ? *params.enable_auto_size : auto_size_enabled_;
+  gfx::Size min_size = params.min_size ? *params.min_size : min_auto_size_;
+  gfx::Size max_size = params.max_size ? *params.max_size : max_auto_size_;
+
+  if (params.normal_size)
+    normal_size_ = *params.normal_size;
+
+  min_auto_size_ = min_size;
+  min_auto_size_.SetToMin(max_size);
+  max_auto_size_ = max_size;
+  max_auto_size_.SetToMax(min_size);
+
+  enable_auto_size &= !min_auto_size_.IsEmpty() && !max_auto_size_.IsEmpty();
+
+  auto rvh = web_contents()->GetRenderViewHost();
+  if (enable_auto_size) {
+    // Autosize is being enabled.
+    rvh->EnableAutoResize(min_auto_size_, max_auto_size_);
+    normal_size_.SetSize(0, 0);
+  } else {
+    // Autosize is being disabled.
+    // Use default width/height if missing from partially defined normal size.
+    if (normal_size_.width() && !normal_size_.height())
+      normal_size_.set_height(GetDefaultSize().height());
+    if (!normal_size_.width() && normal_size_.height())
+      normal_size_.set_width(GetDefaultSize().width());
+
+    gfx::Size new_size;
+    if (!normal_size_.IsEmpty()) {
+      new_size = normal_size_;
+    } else if (!guest_size_.IsEmpty()) {
+      new_size = guest_size_;
+    } else {
+      new_size = GetDefaultSize();
+    }
+
+    if (auto_size_enabled_) {
+      // Autosize was previously enabled.
+      rvh->DisableAutoResize(new_size);
+      GuestSizeChangedDueToAutoSize(guest_size_, new_size);
+    } else {
+      // Autosize was already disabled.
+      guest_host_->SizeContents(new_size);
+    }
+
+    guest_size_ = new_size;
+  }
+
+  auto_size_enabled_ = enable_auto_size;
+}
+
+void WebViewGuestDelegate::HandleKeyboardEvent(
+    content::WebContents* source,
+    const content::NativeWebKeyboardEvent& event) {
+  if (embedder_web_contents_)
+    embedder_web_contents_->GetDelegate()->HandleKeyboardEvent(source, event);
+}
+
+void WebViewGuestDelegate::DidCommitProvisionalLoadForFrame(
+    content::RenderFrameHost* render_frame_host,
+    const GURL& url, ui::PageTransition transition_type) {
+  api_web_contents_->Emit("load-commit", url, !render_frame_host->GetParent());
+}
+
+void WebViewGuestDelegate::DidAttach(int guest_proxy_routing_id) {
+  api_web_contents_->Emit("did-attach");
+}
+
+content::WebContents* WebViewGuestDelegate::GetOwnerWebContents() const {
+  return embedder_web_contents_;
+}
+
+void WebViewGuestDelegate::GuestSizeChanged(const gfx::Size& new_size) {
+  if (!auto_size_enabled_)
+    return;
+  GuestSizeChangedDueToAutoSize(guest_size_, new_size);
+  guest_size_ = new_size;
+}
+
+void WebViewGuestDelegate::SetGuestHost(content::GuestHost* guest_host) {
+  guest_host_ = guest_host;
+}
+
+void WebViewGuestDelegate::WillAttach(
+    content::WebContents* embedder_web_contents,
+    int element_instance_id,
+    bool is_full_page_plugin,
+    const base::Closure& completion_callback) {
+  embedder_web_contents_ = embedder_web_contents;
+  is_full_page_plugin_ = is_full_page_plugin;
+  completion_callback.Run();
+}
+
+void WebViewGuestDelegate::GuestSizeChangedDueToAutoSize(
+    const gfx::Size& old_size, const gfx::Size& new_size) {
+  api_web_contents_->Emit("size-changed",
+                          old_size.width(), old_size.height(),
+                          new_size.width(), new_size.height());
+}
+
+gfx::Size WebViewGuestDelegate::GetDefaultSize() const {
+  if (is_full_page_plugin_) {
+    // Full page plugins default to the size of the owner's viewport.
+    return embedder_web_contents_->GetRenderWidgetHostView()
+                                 ->GetVisibleViewportSize();
+  } else {
+    return gfx::Size(kDefaultWidth, kDefaultHeight);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 ead0db7b50c1d913caf2da2f634998af50436014 electron/browser/web_view_guest_delegate.h
@@ -0,0 +1,119 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
+#define ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
+
+#include "content/public/browser/browser_plugin_guest_delegate.h"
+#include "content/public/browser/web_contents_observer.h"
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace electron {
+
+namespace api {
+class WebContents;
+}
+
+// A struct of parameters for SetSize(). The parameters are all declared as
+// scoped pointers since they are all optional. Null pointers indicate that the
+// parameter has not been provided, and the last used value should be used. Note
+// that when |enable_auto_size| is true, providing |normal_size| is not
+// meaningful. This is because the normal size of the guestview is overridden
+// whenever autosizing occurs.
+struct SetSizeParams {
+  SetSizeParams() {}
+  ~SetSizeParams() {}
+
+  scoped_ptr<bool> enable_auto_size;
+  scoped_ptr<gfx::Size> min_size;
+  scoped_ptr<gfx::Size> max_size;
+  scoped_ptr<gfx::Size> normal_size;
+};
+
+class WebViewGuestDelegate : public content::BrowserPluginGuestDelegate,
+                             public content::WebContentsObserver {
+ public:
+  WebViewGuestDelegate();
+  ~WebViewGuestDelegate() override;
+
+  void Initialize(api::WebContents* api_web_contents);
+
+  // Called when the WebContents is going to be destroyed.
+  void Destroy();
+
+  // Used to toggle autosize mode for this GuestView, and set both the automatic
+  // and normal sizes.
+  void SetSize(const SetSizeParams& params);
+
+  // Transfer the keyboard event to embedder.
+  void HandleKeyboardEvent(content::WebContents* source,
+                           const content::NativeWebKeyboardEvent& event);
+
+ protected:
+  // content::WebContentsObserver:
+  void DidCommitProvisionalLoadForFrame(
+      content::RenderFrameHost* render_frame_host,
+      const GURL& url, ui::PageTransition transition_type) override;
+
+  // content::BrowserPluginGuestDelegate:
+  void DidAttach(int guest_proxy_routing_id) final;
+  content::WebContents* GetOwnerWebContents() const final;
+  void GuestSizeChanged(const gfx::Size& new_size) final;
+  void SetGuestHost(content::GuestHost* guest_host) final;
+  void WillAttach(content::WebContents* embedder_web_contents,
+                  int element_instance_id,
+                  bool is_full_page_plugin,
+                  const base::Closure& completion_callback) final;
+
+ private:
+  // This method is invoked when the contents auto-resized to give the container
+  // an opportunity to match it if it wishes.
+  //
+  // This gives the derived class an opportunity to inform its container element
+  // or perform other actions.
+  void GuestSizeChangedDueToAutoSize(const gfx::Size& old_size,
+                                     const gfx::Size& new_size);
+
+  // Returns the default size of the guestview.
+  gfx::Size GetDefaultSize() const;
+
+  // The WebContents that attaches this guest view.
+  content::WebContents* embedder_web_contents_;
+
+  // The size of the container element.
+  gfx::Size element_size_;
+
+  // The size of the guest content. Note: In autosize mode, the container
+  // element may not match the size of the guest.
+  gfx::Size guest_size_;
+
+  // A pointer to the guest_host.
+  content::GuestHost* guest_host_;
+
+  // Indicates whether autosize mode is enabled or not.
+  bool auto_size_enabled_;
+
+  // The maximum size constraints of the container element in autosize mode.
+  gfx::Size max_auto_size_;
+
+  // The minimum size constraints of the container element in autosize mode.
+  gfx::Size min_auto_size_;
+
+  // The size that will be used when autosize mode is disabled.
+  gfx::Size normal_size_;
+
+  // Whether the guest view is inside a plugin document.
+  bool is_full_page_plugin_;
+
+  api::WebContents* api_web_contents_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebViewGuestDelegate);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_VIEW_GUEST_DELEGATE_H_
added in remote
  their  100644 172f2355395c9df73e5d5f7e85a61ca4254ae68f electron/browser/web_view_manager.cc
@@ -0,0 +1,68 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/web_view_manager.h"
+
+#include "electron/browser/electron_browser_context.h"
+#include "content/public/browser/render_process_host.h"
+#include "content/public/browser/web_contents.h"
+
+namespace electron {
+
+WebViewManager::WebViewManager() {
+}
+
+WebViewManager::~WebViewManager() {
+}
+
+void WebViewManager::AddGuest(int guest_instance_id,
+                              int element_instance_id,
+                              content::WebContents* embedder,
+                              content::WebContents* web_contents) {
+  web_contents_embedder_map_[guest_instance_id] = { web_contents, embedder };
+
+  // Map the element in embedder to guest.
+  int owner_process_id = embedder->GetRenderProcessHost()->GetID();
+  ElementInstanceKey key(owner_process_id, element_instance_id);
+  element_instance_id_to_guest_map_[key] = guest_instance_id;
+}
+
+void WebViewManager::RemoveGuest(int guest_instance_id) {
+  if (!ContainsKey(web_contents_embedder_map_, guest_instance_id))
+    return;
+
+  web_contents_embedder_map_.erase(guest_instance_id);
+
+  // Remove the record of element in embedder too.
+  for (const auto& element : element_instance_id_to_guest_map_)
+    if (element.second == guest_instance_id) {
+      element_instance_id_to_guest_map_.erase(element.first);
+      break;
+    }
+}
+
+content::WebContents* WebViewManager::GetGuestByInstanceID(
+    int owner_process_id,
+    int element_instance_id) {
+  ElementInstanceKey key(owner_process_id, element_instance_id);
+  if (!ContainsKey(element_instance_id_to_guest_map_, key))
+    return nullptr;
+
+  int guest_instance_id = element_instance_id_to_guest_map_[key];
+  if (ContainsKey(web_contents_embedder_map_, guest_instance_id))
+    return web_contents_embedder_map_[guest_instance_id].web_contents;
+  else
+    return nullptr;
+}
+
+bool WebViewManager::ForEachGuest(content::WebContents* embedder_web_contents,
+                                  const GuestCallback& callback) {
+  for (auto& item : web_contents_embedder_map_)
+    if (item.second.embedder == embedder_web_contents &&
+        callback.Run(item.second.web_contents))
+      return true;
+  return false;
+}
+
+}  // namespace electron
added in remote
  their  100644 a722674cc26d5134e28e9be69d15f307147c01dc electron/browser/web_view_manager.h
@@ -0,0 +1,67 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
+#define ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
+
+#include <map>
+
+#include "content/public/browser/browser_plugin_guest_manager.h"
+
+namespace electron {
+
+class WebViewManager : public content::BrowserPluginGuestManager {
+ public:
+  WebViewManager();
+  ~WebViewManager() override;
+
+  void AddGuest(int guest_instance_id,
+                int element_instance_id,
+                content::WebContents* embedder,
+                content::WebContents* web_contents);
+  void RemoveGuest(int guest_instance_id);
+
+ protected:
+  // content::BrowserPluginGuestManager:
+  content::WebContents* GetGuestByInstanceID(int owner_process_id,
+                                             int element_instance_id) override;
+  bool ForEachGuest(content::WebContents* embedder,
+                    const GuestCallback& callback) override;
+
+ private:
+  struct WebContentsWithEmbedder {
+    content::WebContents* web_contents;
+    content::WebContents* embedder;
+  };
+  // guest_instance_id => (web_contents, embedder)
+  std::map<int, WebContentsWithEmbedder> web_contents_embedder_map_;
+
+  struct ElementInstanceKey {
+    int embedder_process_id;
+    int element_instance_id;
+
+    ElementInstanceKey(int embedder_process_id, int element_instance_id)
+        : embedder_process_id(embedder_process_id),
+          element_instance_id(element_instance_id) {}
+
+    bool operator<(const ElementInstanceKey& other) const {
+      if (embedder_process_id != other.embedder_process_id)
+        return embedder_process_id < other.embedder_process_id;
+      return element_instance_id < other.element_instance_id;
+    }
+
+    bool operator==(const ElementInstanceKey& other) const {
+      return (embedder_process_id == other.embedder_process_id) &&
+          (element_instance_id == other.element_instance_id);
+    }
+  };
+  // (embedder_process_id, element_instance_id) => guest_instance_id
+  std::map<ElementInstanceKey, int> element_instance_id_to_guest_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebViewManager);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WEB_VIEW_MANAGER_H_
added in remote
  their  100644 17144bbc438be6bac5fe407519dbf78d9c0f1a2f electron/browser/window_list.cc
@@ -0,0 +1,83 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/browser/window_list.h"
+
+#include <algorithm>
+
+#include "electron/browser/native_window.h"
+#include "electron/browser/window_list_observer.h"
+#include "base/logging.h"
+
+namespace electron {
+
+// static
+base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
+    WindowList::observers_ = LAZY_INSTANCE_INITIALIZER;
+
+// static
+WindowList* WindowList::instance_ = NULL;
+
+// static
+WindowList* WindowList::GetInstance() {
+  if (!instance_)
+    instance_ = new WindowList;
+  return instance_;
+}
+
+// static
+void WindowList::AddWindow(NativeWindow* window) {
+  DCHECK(window);
+  // Push |window| on the appropriate list instance.
+  WindowVector& windows = GetInstance()->windows_;
+  windows.push_back(window);
+
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowAdded(window));
+}
+
+// static
+void WindowList::RemoveWindow(NativeWindow* window) {
+  WindowVector& windows = GetInstance()->windows_;
+  windows.erase(std::remove(windows.begin(), windows.end(), window),
+                windows.end());
+
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowRemoved(window));
+
+  if (windows.size() == 0)
+    FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                      OnWindowAllClosed());
+}
+
+// static
+void WindowList::WindowCloseCancelled(NativeWindow* window) {
+  FOR_EACH_OBSERVER(WindowListObserver, observers_.Get(),
+                    OnWindowCloseCancelled(window));
+}
+
+// static
+void WindowList::AddObserver(WindowListObserver* observer) {
+  observers_.Get().AddObserver(observer);
+}
+
+// static
+void WindowList::RemoveObserver(WindowListObserver* observer) {
+  observers_.Get().RemoveObserver(observer);
+}
+
+// static
+void WindowList::CloseAllWindows() {
+  WindowVector windows = GetInstance()->windows_;
+  for (size_t i = 0; i < windows.size(); ++i)
+    windows[i]->Close();
+}
+
+WindowList::WindowList() {
+}
+
+WindowList::~WindowList() {
+}
+
+}  // namespace electron
added in remote
  their  100644 ce25214c7af43af786fd500b1e84aa6098cff507 electron/browser/window_list.h
@@ -0,0 +1,73 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WINDOW_LIST_H_
+#define ELECTRON_BROWSER_WINDOW_LIST_H_
+
+#include <vector>
+
+#include "base/macros.h"
+#include "base/lazy_instance.h"
+#include "base/observer_list.h"
+
+namespace electron {
+
+class NativeWindow;
+class WindowListObserver;
+
+class WindowList {
+ public:
+  typedef std::vector<NativeWindow*> WindowVector;
+  typedef WindowVector::iterator iterator;
+  typedef WindowVector::const_iterator const_iterator;
+
+  // Windows are added to the list before they have constructed windows,
+  // so the |window()| member function may return NULL.
+  const_iterator begin() const { return windows_.begin(); }
+  const_iterator end() const { return windows_.end(); }
+
+  iterator begin() { return windows_.begin(); }
+  iterator end() { return windows_.end(); }
+
+  bool empty() const { return windows_.empty(); }
+  size_t size() const { return windows_.size(); }
+
+  NativeWindow* get(size_t index) const { return windows_[index]; }
+
+  static WindowList* GetInstance();
+
+  // Adds or removes |window| from the list it is associated with.
+  static void AddWindow(NativeWindow* window);
+  static void RemoveWindow(NativeWindow* window);
+
+  // Called by window when a close is cancelled by beforeunload handler.
+  static void WindowCloseCancelled(NativeWindow* window);
+
+  // Adds and removes |observer| from the observer list.
+  static void AddObserver(WindowListObserver* observer);
+  static void RemoveObserver(WindowListObserver* observer);
+
+  // Closes all windows.
+  static void CloseAllWindows();
+
+ private:
+  WindowList();
+  ~WindowList();
+
+  // A vector of the windows in this list, in the order they were added.
+  WindowVector windows_;
+
+  // A list of observers which will be notified of every window addition and
+  // removal across all WindowLists.
+  static base::LazyInstance<base::ObserverList<WindowListObserver>>::Leaky
+      observers_;
+
+  static WindowList* instance_;
+
+  DISALLOW_COPY_AND_ASSIGN(WindowList);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WINDOW_LIST_H_
added in remote
  their  100644 e59cebaeb41225e02fb36cb642ba5609921e4561 electron/browser/window_list_observer.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
+#define ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
+
+namespace electron {
+
+class NativeWindow;
+
+class WindowListObserver {
+ public:
+  // Called immediately after a window is added to the list.
+  virtual void OnWindowAdded(NativeWindow* window) {}
+
+  // Called immediately after a window is removed from the list.
+  virtual void OnWindowRemoved(NativeWindow* window) {}
+
+  // Called when a window close is cancelled by beforeunload handler.
+  virtual void OnWindowCloseCancelled(NativeWindow* window) {}
+
+  // Called immediately after all windows are closed.
+  virtual void OnWindowAllClosed() {}
+
+ protected:
+  virtual ~WindowListObserver() {}
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_BROWSER_WINDOW_LIST_OBSERVER_H_
added in remote
  their  100644 ab6471ec9cc417da3c8ae93ffeed0b57bbaf104e electron/common/api/api_messages.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, no traditional include guard.
+
+#include "electron/common/draggable_region.h"
+#include "base/strings/string16.h"
+#include "base/values.h"
+#include "content/public/common/common_param_traits.h"
+#include "ipc/ipc_message_macros.h"
+#include "ui/gfx/ipc/gfx_param_traits.h"
+
+// The message starter should be declared in ipc/ipc_message_start.h. Since
+// we don't want to patch Chromium, we just pretend to be Content Shell.
+
+#define IPC_MESSAGE_START ShellMsgStart
+
+IPC_STRUCT_TRAITS_BEGIN(electron::DraggableRegion)
+  IPC_STRUCT_TRAITS_MEMBER(draggable)
+  IPC_STRUCT_TRAITS_MEMBER(bounds)
+IPC_STRUCT_TRAITS_END()
+
+IPC_MESSAGE_ROUTED2(ElectronViewHostMsg_Message,
+                    base::string16 /* channel */,
+                    base::ListValue /* arguments */)
+
+IPC_SYNC_MESSAGE_ROUTED2_1(ElectronViewHostMsg_Message_Sync,
+                           base::string16 /* channel */,
+                           base::ListValue /* arguments */,
+                           base::string16 /* result (in JSON) */)
+
+IPC_MESSAGE_ROUTED2(ElectronViewMsg_Message,
+                    base::string16 /* channel */,
+                    base::ListValue /* arguments */)
+
+// Sent by the renderer when the draggable regions are updated.
+IPC_MESSAGE_ROUTED1(ElectronViewHostMsg_UpdateDraggableRegions,
+                    std::vector<electron::DraggableRegion> /* regions */)
added in remote
  their  100644 cb3975c4eb54115c36486a9154c3228fcf544bec electron/common/api/electron_api_asar.cc
@@ -0,0 +1,163 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <stddef.h>
+
+#include <vector>
+
+#include "electron_natives.h"  // NOLINT: This file is generated with coffee2c.
+#include "electron/common/asar/archive.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "native_mate/wrappable.h"
+
+namespace {
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+class Archive : public mate::Wrappable {
+ public:
+  static v8::Local<v8::Value> Create(v8::Isolate* isolate,
+                                      const base::FilePath& path) {
+    scoped_ptr<asar::Archive> archive(new asar::Archive(path));
+    if (!archive->Init())
+      return v8::False(isolate);
+    return (new Archive(std::move(archive)))->GetWrapper(isolate);
+  }
+
+ protected:
+  explicit Archive(scoped_ptr<asar::Archive> archive)
+      : archive_(std::move(archive)) {}
+
+  // Reads the offset and size of file.
+  v8::Local<v8::Value> GetFileInfo(v8::Isolate* isolate,
+                                    const base::FilePath& path) {
+    asar::Archive::FileInfo info;
+    if (!archive_ || !archive_->GetFileInfo(path, &info))
+      return v8::False(isolate);
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("size", info.size);
+    dict.Set("unpacked", info.unpacked);
+    dict.Set("offset", info.offset);
+    return dict.GetHandle();
+  }
+
+  // Returns a fake result of fs.stat(path).
+  v8::Local<v8::Value> Stat(v8::Isolate* isolate,
+                             const base::FilePath& path) {
+    asar::Archive::Stats stats;
+    if (!archive_ || !archive_->Stat(path, &stats))
+      return v8::False(isolate);
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("size", stats.size);
+    dict.Set("offset", stats.offset);
+    dict.Set("isFile", stats.is_file);
+    dict.Set("isDirectory", stats.is_directory);
+    dict.Set("isLink", stats.is_link);
+    return dict.GetHandle();
+  }
+
+  // Returns all files under a directory.
+  v8::Local<v8::Value> Readdir(v8::Isolate* isolate,
+                                const base::FilePath& path) {
+    std::vector<base::FilePath> files;
+    if (!archive_ || !archive_->Readdir(path, &files))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, files);
+  }
+
+  // Returns the path of file with symbol link resolved.
+  v8::Local<v8::Value> Realpath(v8::Isolate* isolate,
+                                 const base::FilePath& path) {
+    base::FilePath realpath;
+    if (!archive_ || !archive_->Realpath(path, &realpath))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, realpath);
+  }
+
+  // Copy the file out into a temporary file and returns the new path.
+  v8::Local<v8::Value> CopyFileOut(v8::Isolate* isolate,
+                                    const base::FilePath& path) {
+    base::FilePath new_path;
+    if (!archive_ || !archive_->CopyFileOut(path, &new_path))
+      return v8::False(isolate);
+    return mate::ConvertToV8(isolate, new_path);
+  }
+
+  // Return the file descriptor.
+  int GetFD() const {
+    if (!archive_)
+      return -1;
+    return archive_->GetFD();
+  }
+
+  // Free the resources used by archive.
+  void Destroy() {
+    archive_.reset();
+  }
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(v8::Isolate* isolate) {
+    if (template_.IsEmpty())
+      template_.Reset(isolate, mate::ObjectTemplateBuilder(isolate)
+          .SetValue("path", archive_->path())
+          .SetMethod("getFileInfo", &Archive::GetFileInfo)
+          .SetMethod("stat", &Archive::Stat)
+          .SetMethod("readdir", &Archive::Readdir)
+          .SetMethod("realpath", &Archive::Realpath)
+          .SetMethod("copyFileOut", &Archive::CopyFileOut)
+          .SetMethod("getFd", &Archive::GetFD)
+          .SetMethod("destroy", &Archive::Destroy)
+          .Build());
+
+    return mate::ObjectTemplateBuilder(
+        isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+  }
+
+ private:
+  scoped_ptr<asar::Archive> archive_;
+
+  DISALLOW_COPY_AND_ASSIGN(Archive);
+};
+
+void InitAsarSupport(v8::Isolate* isolate,
+                     v8::Local<v8::Value> process,
+                     v8::Local<v8::Value> require) {
+  // Evaluate asar_init.js.
+  const char* asar_init_native = reinterpret_cast<const char*>(
+      static_cast<const unsigned char*>(node::asar_init_native));
+  v8::Local<v8::Script> asar_init = v8::Script::Compile(v8::String::NewFromUtf8(
+      isolate,
+      asar_init_native,
+      v8::String::kNormalString,
+      sizeof(node::asar_init_native) -1));
+  v8::Local<v8::Value> result = asar_init->Run();
+
+  // Initialize asar support.
+  base::Callback<void(v8::Local<v8::Value>,
+                      v8::Local<v8::Value>,
+                      std::string)> init;
+  if (mate::ConvertFromV8(isolate, result, &init)) {
+    const char* asar_native = reinterpret_cast<const char*>(
+        static_cast<const unsigned char*>(node::asar_native));
+    init.Run(process,
+             require,
+             std::string(asar_native, sizeof(node::asar_native) - 1));
+  }
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("createArchive", &Archive::Create);
+  dict.SetMethod("initAsarSupport", &InitAsarSupport);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_asar, Initialize)
added in remote
  their  100644 7aadf8a26bc4179206ca6987a1c7be4dc5152b8a electron/common/api/electron_api_clipboard.cc
@@ -0,0 +1,160 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include <vector>
+
+#include "electron/common/native_mate_converters/image_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/strings/utf_string_conversions.h"
+#include "native_mate/arguments.h"
+#include "native_mate/dictionary.h"
+#include "third_party/skia/include/core/SkBitmap.h"
+#include "ui/base/clipboard/clipboard.h"
+#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/gfx/image/image.h"
+
+#include "electron/common/node_includes.h"
+
+namespace {
+
+ui::ClipboardType GetClipboardType(mate::Arguments* args) {
+  std::string type;
+  if (args->GetNext(&type) && type == "selection")
+    return ui::CLIPBOARD_TYPE_SELECTION;
+  else
+    return ui::CLIPBOARD_TYPE_COPY_PASTE;
+}
+
+std::vector<base::string16> AvailableFormats(mate::Arguments* args) {
+  std::vector<base::string16> format_types;
+  bool ignore;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadAvailableTypes(GetClipboardType(args), &format_types, &ignore);
+  return format_types;
+}
+
+bool Has(const std::string& format_string, mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
+  return clipboard->IsFormatAvailable(format, GetClipboardType(args));
+}
+
+std::string Read(const std::string& format_string,
+                 mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  ui::Clipboard::FormatType format(ui::Clipboard::GetFormatType(format_string));
+
+  std::string data;
+  clipboard->ReadData(format, &data);
+  return data;
+}
+
+void Write(const mate::Dictionary& data,
+           mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  base::string16 text, html;
+  gfx::Image image;
+
+  if (data.Get("text", &text))
+    writer.WriteText(text);
+
+  if (data.Get("rtf", &text)) {
+    std::string rtf = base::UTF16ToUTF8(text);
+    writer.WriteRTF(rtf);
+  }
+
+  if (data.Get("html", &html))
+    writer.WriteHTML(html, std::string());
+
+  if (data.Get("image", &image))
+    writer.WriteImage(image.AsBitmap());
+}
+
+base::string16 ReadText(mate::Arguments* args) {
+  base::string16 data;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  auto type = GetClipboardType(args);
+  if (clipboard->IsFormatAvailable(
+      ui::Clipboard::GetPlainTextWFormatType(), type)) {
+    clipboard->ReadText(type, &data);
+  } else if (clipboard->IsFormatAvailable(
+             ui::Clipboard::GetPlainTextFormatType(), type)) {
+    std::string result;
+    clipboard->ReadAsciiText(type, &result);
+    data = base::ASCIIToUTF16(result);
+  }
+  return data;
+}
+
+void WriteText(const base::string16& text, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteText(text);
+}
+
+base::string16 ReadRtf(mate::Arguments* args) {
+  std::string data;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadRTF(GetClipboardType(args), &data);
+  return base::UTF8ToUTF16(data);
+}
+
+void WriteRtf(const std::string& text, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteRTF(text);
+}
+
+base::string16 ReadHtml(mate::Arguments* args) {
+  base::string16 data;
+  base::string16 html;
+  std::string url;
+  uint32_t start;
+  uint32_t end;
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  clipboard->ReadHTML(GetClipboardType(args), &html, &url, &start, &end);
+  data = html.substr(start, end - start);
+  return data;
+}
+
+void WriteHtml(const base::string16& html, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteHTML(html, std::string());
+}
+
+gfx::Image ReadImage(mate::Arguments* args) {
+  ui::Clipboard* clipboard = ui::Clipboard::GetForCurrentThread();
+  SkBitmap bitmap = clipboard->ReadImage(GetClipboardType(args));
+  return gfx::Image::CreateFrom1xBitmap(bitmap);
+}
+
+void WriteImage(const gfx::Image& image, mate::Arguments* args) {
+  ui::ScopedClipboardWriter writer(GetClipboardType(args));
+  writer.WriteImage(image.AsBitmap());
+}
+
+void Clear(mate::Arguments* args) {
+  ui::Clipboard::GetForCurrentThread()->Clear(GetClipboardType(args));
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("availableFormats", &AvailableFormats);
+  dict.SetMethod("has", &Has);
+  dict.SetMethod("read", &Read);
+  dict.SetMethod("write", &Write);
+  dict.SetMethod("readText", &ReadText);
+  dict.SetMethod("writeText", &WriteText);
+  dict.SetMethod("readRtf", &ReadRtf);
+  dict.SetMethod("writeRtf", &WriteRtf);
+  dict.SetMethod("readHtml", &ReadHtml);
+  dict.SetMethod("writeHtml", &WriteHtml);
+  dict.SetMethod("readImage", &ReadImage);
+  dict.SetMethod("writeImage", &WriteImage);
+  dict.SetMethod("clear", &Clear);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_clipboard, Initialize)
added in remote
  their  100644 96997a96246310087fed827727eaaae7407c5fe3 electron/common/api/electron_api_crash_reporter.cc
@@ -0,0 +1,64 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <map>
+#include <string>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/bind.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+using crash_reporter::CrashReporter;
+
+namespace mate {
+
+template<>
+struct Converter<std::map<std::string, std::string> > {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     std::map<std::string, std::string>* out) {
+    if (!val->IsObject())
+      return false;
+
+    v8::Local<v8::Object> dict = val->ToObject();
+    v8::Local<v8::Array> keys = dict->GetOwnPropertyNames();
+    for (uint32_t i = 0; i < keys->Length(); ++i) {
+      v8::Local<v8::Value> key = keys->Get(i);
+      (*out)[V8ToString(key)] = V8ToString(dict->Get(key));
+    }
+    return true;
+  }
+};
+
+template<>
+struct Converter<CrashReporter::UploadReportResult> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+      const CrashReporter::UploadReportResult& reports) {
+    mate::Dictionary dict(isolate, v8::Object::New(isolate));
+    dict.Set("date", v8::Date::New(isolate, reports.first*1000.0));
+    dict.Set("id", reports.second);
+    return dict.GetHandle();
+  }
+};
+
+}  // namespace mate
+
+namespace {
+
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  auto report = base::Unretained(CrashReporter::GetInstance());
+  dict.SetMethod("start",
+                 base::Bind(&CrashReporter::Start, report));
+  dict.SetMethod("_getUploadedReports",
+                 base::Bind(&CrashReporter::GetUploadedReports, report));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_crash_reporter, Initialize)
added in remote
  their  100644 6cc5ea385267dee88b182b610ebe84624d9a1354 electron/common/api/electron_api_id_weak_map.cc
@@ -0,0 +1,79 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_id_weak_map.h"
+
+#include "electron/common/node_includes.h"
+#include "native_mate/constructor.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace api {
+
+IDWeakMap::IDWeakMap() {
+}
+
+IDWeakMap::~IDWeakMap() {
+}
+
+void IDWeakMap::Set(v8::Isolate* isolate,
+                    int32_t id,
+                    v8::Local<v8::Object> object) {
+  id_weak_map_.Set(isolate, id, object);
+}
+
+v8::Local<v8::Object> IDWeakMap::Get(v8::Isolate* isolate, int32_t id) {
+  return id_weak_map_.Get(isolate, id).ToLocalChecked();
+}
+
+bool IDWeakMap::Has(int32_t id) {
+  return id_weak_map_.Has(id);
+}
+
+void IDWeakMap::Remove(int32_t id) {
+  id_weak_map_.Remove(id);
+}
+
+void IDWeakMap::Clear() {
+  id_weak_map_.Clear();
+}
+
+// static
+void IDWeakMap::BuildPrototype(v8::Isolate* isolate,
+                               v8::Local<v8::ObjectTemplate> prototype) {
+  mate::ObjectTemplateBuilder(isolate, prototype)
+      .SetMethod("set", &IDWeakMap::Set)
+      .SetMethod("get", &IDWeakMap::Get)
+      .SetMethod("has", &IDWeakMap::Has)
+      .SetMethod("remove", &IDWeakMap::Remove)
+      .SetMethod("clear", &IDWeakMap::Clear);
+}
+
+// static
+mate::Wrappable* IDWeakMap::Create(v8::Isolate* isolate) {
+  return new IDWeakMap;
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+using electron::api::IDWeakMap;
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor = mate::CreateConstructor<IDWeakMap>(
+      isolate, "IDWeakMap", base::Bind(&IDWeakMap::Create));
+  mate::Dictionary id_weak_map(isolate, constructor);
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("IDWeakMap", id_weak_map);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_id_weak_map, Initialize)
added in remote
  their  100644 c761450a1d7ebc5e483931f0cb173257db82b10a electron/common/api/electron_api_id_weak_map.h
@@ -0,0 +1,44 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
+#define ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
+
+#include "electron/common/id_weak_map.h"
+#include "native_mate/object_template_builder.h"
+#include "native_mate/handle.h"
+
+namespace electron {
+
+namespace api {
+
+class IDWeakMap : public mate::Wrappable {
+ public:
+  static mate::Wrappable* Create(v8::Isolate* isolate);
+
+  static void BuildPrototype(v8::Isolate* isolate,
+                             v8::Local<v8::ObjectTemplate> prototype);
+
+ protected:
+  IDWeakMap();
+  ~IDWeakMap();
+
+ private:
+  // Api for IDWeakMap.
+  void Set(v8::Isolate* isolate, int32_t id, v8::Local<v8::Object> object);
+  v8::Local<v8::Object> Get(v8::Isolate* isolate, int32_t id);
+  bool Has(int32_t id);
+  void Remove(int32_t id);
+  void Clear();
+
+  electron::IDWeakMap id_weak_map_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDWeakMap);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_API_ID_WEAK_MAP_H_
added in remote
  their  100644 a0d9b69ba01d4ec566fc29be37656e2b1c2dcab5 electron/common/api/electron_api_native_image.cc
@@ -0,0 +1,352 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_native_image.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/asar_util.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/base64.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/pattern.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "net/base/data_url.h"
+#include "ui/base/layout.h"
+#include "ui/gfx/codec/jpeg_codec.h"
+#include "ui/gfx/codec/png_codec.h"
+#include "ui/gfx/geometry/size.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/image/image_util.h"
+
+#if defined(OS_WIN)
+#include "electron/common/asar/archive.h"
+#include "base/win/scoped_gdi_object.h"
+#include "ui/gfx/icon_util.h"
+#endif
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+struct ScaleFactorPair {
+  const char* name;
+  float scale;
+};
+
+ScaleFactorPair kScaleFactorPairs[] = {
+  // The "@2x" is put as first one to make scale matching faster.
+  { "@2x"    , 2.0f },
+  { "@3x"    , 3.0f },
+  { "@1x"    , 1.0f },
+  { "@4x"    , 4.0f },
+  { "@5x"    , 5.0f },
+  { "@1.25x" , 1.25f },
+  { "@1.33x" , 1.33f },
+  { "@1.4x"  , 1.4f },
+  { "@1.5x"  , 1.5f },
+  { "@1.8x"  , 1.8f },
+  { "@2.5x"  , 2.5f },
+};
+
+float GetScaleFactorFromPath(const base::FilePath& path) {
+  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
+
+  // We don't try to convert string to float here because it is very very
+  // expensive.
+  for (unsigned i = 0; i < arraysize(kScaleFactorPairs); ++i) {
+    if (base::EndsWith(filename, kScaleFactorPairs[i].name,
+                       base::CompareCase::INSENSITIVE_ASCII))
+      return kScaleFactorPairs[i].scale;
+  }
+
+  return 1.0f;
+}
+
+bool AddImageSkiaRep(gfx::ImageSkia* image,
+                     const unsigned char* data,
+                     size_t size,
+                     double scale_factor) {
+  scoped_ptr<SkBitmap> decoded(new SkBitmap());
+
+  // Try PNG first.
+  if (!gfx::PNGCodec::Decode(data, size, decoded.get()))
+    // Try JPEG.
+    decoded.reset(gfx::JPEGCodec::Decode(data, size));
+
+  if (!decoded)
+    return false;
+
+  image->AddRepresentation(gfx::ImageSkiaRep(*decoded, scale_factor));
+  return true;
+}
+
+bool AddImageSkiaRep(gfx::ImageSkia* image,
+                     const base::FilePath& path,
+                     double scale_factor) {
+  std::string file_contents;
+  if (!asar::ReadFileToString(path, &file_contents))
+    return false;
+
+  const unsigned char* data =
+      reinterpret_cast<const unsigned char*>(file_contents.data());
+  size_t size = file_contents.size();
+  return AddImageSkiaRep(image, data, size, scale_factor);
+}
+
+bool PopulateImageSkiaRepsFromPath(gfx::ImageSkia* image,
+                                   const base::FilePath& path) {
+  bool succeed = false;
+  std::string filename(path.BaseName().RemoveExtension().AsUTF8Unsafe());
+  if (base::MatchPattern(filename, "*@*x"))
+    // Don't search for other representations if the DPI has been specified.
+    return AddImageSkiaRep(image, path, GetScaleFactorFromPath(path));
+  else
+    succeed |= AddImageSkiaRep(image, path, 1.0f);
+
+  for (const ScaleFactorPair& pair : kScaleFactorPairs)
+    succeed |= AddImageSkiaRep(image,
+                               path.InsertBeforeExtensionASCII(pair.name),
+                               pair.scale);
+  return succeed;
+}
+
+base::FilePath NormalizePath(const base::FilePath& path) {
+  if (!path.ReferencesParent()) {
+    return path;
+  }
+
+  base::FilePath absolute_path = MakeAbsoluteFilePath(path);
+  // MakeAbsoluteFilePath returns an empty path on failures so use original path
+  if (absolute_path.empty()) {
+    return path;
+  } else {
+    return absolute_path;
+  }
+}
+
+#if defined(OS_MACOSX)
+bool IsTemplateFilename(const base::FilePath& path) {
+  return (base::MatchPattern(path.value(), "*Template.*") ||
+          base::MatchPattern(path.value(), "*Template@*x.*"));
+}
+#endif
+
+#if defined(OS_WIN)
+bool ReadImageSkiaFromICO(gfx::ImageSkia* image, const base::FilePath& path) {
+  // If file is in asar archive, we extract it to a temp file so LoadImage can
+  // load it.
+  base::FilePath asar_path, relative_path;
+  base::FilePath image_path(path);
+  if (asar::GetAsarArchivePath(image_path, &asar_path, &relative_path)) {
+    std::shared_ptr<asar::Archive> archive =
+        asar::GetOrCreateAsarArchive(asar_path);
+    if (archive)
+      archive->CopyFileOut(relative_path, &image_path);
+  }
+
+  // Load the icon from file.
+  base::win::ScopedHICON icon(static_cast<HICON>(
+      LoadImage(NULL, image_path.value().c_str(), IMAGE_ICON, 0, 0,
+                LR_DEFAULTSIZE | LR_LOADFROMFILE)));
+  if (!icon.get())
+    return false;
+
+  // Convert the icon from the Windows specific HICON to gfx::ImageSkia.
+  scoped_ptr<SkBitmap> bitmap(IconUtil::  CreateSkBitmapFromHICON(icon.get()));
+  image->AddRepresentation(gfx::ImageSkiaRep(*bitmap, 1.0f));
+  return true;
+}
+#endif
+
+v8::Persistent<v8::ObjectTemplate> template_;
+
+}  // namespace
+
+NativeImage::NativeImage() {}
+
+NativeImage::NativeImage(const gfx::Image& image) : image_(image) {}
+
+NativeImage::~NativeImage() {}
+
+mate::ObjectTemplateBuilder NativeImage::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  if (template_.IsEmpty())
+    template_.Reset(isolate, mate::ObjectTemplateBuilder(isolate)
+        .SetMethod("toPng", &NativeImage::ToPNG)
+        .SetMethod("toJpeg", &NativeImage::ToJPEG)
+        .SetMethod("getNativeHandle", &NativeImage::GetNativeHandle)
+        .SetMethod("toDataURL", &NativeImage::ToDataURL)
+        .SetMethod("toDataUrl", &NativeImage::ToDataURL)  // deprecated.
+        .SetMethod("isEmpty", &NativeImage::IsEmpty)
+        .SetMethod("getSize", &NativeImage::GetSize)
+        .SetMethod("setTemplateImage", &NativeImage::SetTemplateImage)
+        .SetMethod("isTemplateImage", &NativeImage::IsTemplateImage)
+        .Build());
+
+  return mate::ObjectTemplateBuilder(
+      isolate, v8::Local<v8::ObjectTemplate>::New(isolate, template_));
+}
+
+v8::Local<v8::Value> NativeImage::ToPNG(v8::Isolate* isolate) {
+  scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
+  return node::Buffer::Copy(isolate,
+                            reinterpret_cast<const char*>(png->front()),
+                            static_cast<size_t>(png->size())).ToLocalChecked();
+}
+
+v8::Local<v8::Value> NativeImage::ToJPEG(v8::Isolate* isolate, int quality) {
+  std::vector<unsigned char> output;
+  gfx::JPEG1xEncodedDataFromImage(image_, quality, &output);
+  return node::Buffer::Copy(
+      isolate,
+      reinterpret_cast<const char*>(&output.front()),
+      static_cast<size_t>(output.size())).ToLocalChecked();
+}
+
+std::string NativeImage::ToDataURL() {
+  scoped_refptr<base::RefCountedMemory> png = image_.As1xPNGBytes();
+  std::string data_url;
+  data_url.insert(data_url.end(), png->front(), png->front() + png->size());
+  base::Base64Encode(data_url, &data_url);
+  data_url.insert(0, "data:image/png;base64,");
+  return data_url;
+}
+
+v8::Local<v8::Value> NativeImage::GetNativeHandle(v8::Isolate* isolate,
+                                                  mate::Arguments* args) {
+#if defined(OS_MACOSX)
+  NSImage* ptr = image_.AsNSImage();
+  return node::Buffer::Copy(
+      isolate,
+      reinterpret_cast<char*>(ptr),
+      sizeof(void*)).ToLocalChecked();
+#else
+  args->ThrowError("Not implemented");
+  return v8::Undefined(isolate);
+#endif
+}
+
+bool NativeImage::IsEmpty() {
+  return image_.IsEmpty();
+}
+
+gfx::Size NativeImage::GetSize() {
+  return image_.Size();
+}
+
+#if !defined(OS_MACOSX)
+void NativeImage::SetTemplateImage(bool setAsTemplate) {
+}
+
+bool NativeImage::IsTemplateImage() {
+  return false;
+}
+#endif
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateEmpty(v8::Isolate* isolate) {
+  return mate::CreateHandle(isolate, new NativeImage);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::Create(
+    v8::Isolate* isolate, const gfx::Image& image) {
+  return mate::CreateHandle(isolate, new NativeImage(image));
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromPNG(
+    v8::Isolate* isolate, const char* buffer, size_t length) {
+  gfx::Image image = gfx::Image::CreateFrom1xPNGBytes(
+      reinterpret_cast<const unsigned char*>(buffer), length);
+  return Create(isolate, image);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromJPEG(
+    v8::Isolate* isolate, const char* buffer, size_t length) {
+  gfx::Image image = gfx::ImageFrom1xJPEGEncodedData(
+      reinterpret_cast<const unsigned char*>(buffer), length);
+  return Create(isolate, image);
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromPath(
+    v8::Isolate* isolate, const base::FilePath& path) {
+  gfx::ImageSkia image_skia;
+  base::FilePath image_path = NormalizePath(path);
+
+  if (image_path.MatchesExtension(FILE_PATH_LITERAL(".ico"))) {
+#if defined(OS_WIN)
+    ReadImageSkiaFromICO(&image_skia, image_path);
+#endif
+  } else {
+    PopulateImageSkiaRepsFromPath(&image_skia, image_path);
+  }
+  gfx::Image image(image_skia);
+  mate::Handle<NativeImage> handle = Create(isolate, image);
+#if defined(OS_MACOSX)
+  if (IsTemplateFilename(image_path))
+    handle->SetTemplateImage(true);
+#endif
+  return handle;
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromBuffer(
+    mate::Arguments* args, v8::Local<v8::Value> buffer) {
+  double scale_factor = 1.;
+  args->GetNext(&scale_factor);
+
+  gfx::ImageSkia image_skia;
+  AddImageSkiaRep(&image_skia,
+                  reinterpret_cast<unsigned char*>(node::Buffer::Data(buffer)),
+                  node::Buffer::Length(buffer),
+                  scale_factor);
+  return Create(args->isolate(), gfx::Image(image_skia));
+}
+
+// static
+mate::Handle<NativeImage> NativeImage::CreateFromDataURL(
+    v8::Isolate* isolate, const GURL& url) {
+  std::string mime_type, charset, data;
+  if (net::DataURL::Parse(url, &mime_type, &charset, &data)) {
+    if (mime_type == "image/png")
+      return CreateFromPNG(isolate, data.c_str(), data.size());
+    else if (mime_type == "image/jpeg")
+      return CreateFromJPEG(isolate, data.c_str(), data.size());
+  }
+
+  return CreateEmpty(isolate);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("createEmpty", &electron::api::NativeImage::CreateEmpty);
+  dict.SetMethod("createFromPath", &electron::api::NativeImage::CreateFromPath);
+  dict.SetMethod("createFromBuffer", &electron::api::NativeImage::CreateFromBuffer);
+  dict.SetMethod("createFromDataURL",
+                 &electron::api::NativeImage::CreateFromDataURL);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_native_image, Initialize)
added in remote
  their  100644 29ccec20538730abb365bec3bbfcf59d23ecd5f5 electron/common/api/electron_api_native_image.h
@@ -0,0 +1,85 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
+#define ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
+
+#include <string>
+
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+#include "ui/gfx/image/image.h"
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace gfx {
+class Size;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class NativeImage : public mate::Wrappable {
+ public:
+  static mate::Handle<NativeImage> CreateEmpty(v8::Isolate* isolate);
+  static mate::Handle<NativeImage> Create(
+      v8::Isolate* isolate, const gfx::Image& image);
+  static mate::Handle<NativeImage> CreateFromPNG(
+      v8::Isolate* isolate, const char* buffer, size_t length);
+  static mate::Handle<NativeImage> CreateFromJPEG(
+      v8::Isolate* isolate, const char* buffer, size_t length);
+  static mate::Handle<NativeImage> CreateFromPath(
+      v8::Isolate* isolate, const base::FilePath& path);
+  static mate::Handle<NativeImage> CreateFromBuffer(
+      mate::Arguments* args, v8::Local<v8::Value> buffer);
+  static mate::Handle<NativeImage> CreateFromDataURL(
+      v8::Isolate* isolate, const GURL& url);
+
+  // The default constructor should only be used by image_converter.cc.
+  NativeImage();
+
+  const gfx::Image& image() const { return image_; }
+
+ protected:
+  explicit NativeImage(const gfx::Image& image);
+  virtual ~NativeImage();
+
+  // mate::Wrappable:
+  mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate) override;
+
+ private:
+  v8::Local<v8::Value> ToPNG(v8::Isolate* isolate);
+  v8::Local<v8::Value> ToJPEG(v8::Isolate* isolate, int quality);
+  v8::Local<v8::Value> GetNativeHandle(
+    v8::Isolate* isolate,
+    mate::Arguments* args);
+  std::string ToDataURL();
+  bool IsEmpty();
+  gfx::Size GetSize();
+
+  // Mark the image as template image.
+  void SetTemplateImage(bool setAsTemplate);
+  // Determine if the image is a template image.
+  bool IsTemplateImage();
+
+  gfx::Image image_;
+
+  DISALLOW_COPY_AND_ASSIGN(NativeImage);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_API_NATIVE_IMAGE_H_
added in remote
  their  100644 4ebdcefa764e1227069ce0c642140d12028122b0 electron/common/api/electron_api_native_image_mac.mm
@@ -0,0 +1,23 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_api_native_image.h"
+
+#import <Cocoa/Cocoa.h>
+
+namespace electron {
+
+namespace api {
+
+void NativeImage::SetTemplateImage(bool setAsTemplate) {
+  [image_.AsNSImage() setTemplate:setAsTemplate];
+}
+
+bool NativeImage::IsTemplateImage() {
+  return [image_.AsNSImage() isTemplate];
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 53ad7c44b0c401460f65faf64c3c1b9355252ab8 electron/common/api/electron_api_shell.cc
@@ -0,0 +1,38 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/platform_util.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+
+namespace {
+
+bool OpenExternal(const GURL& url, mate::Arguments* args) {
+  bool activate = true;
+  if (args->Length() == 2) {
+    mate::Dictionary options;
+    if (args->GetNext(&options)) {
+      options.Get("activate", &activate);
+    }
+  }
+  return platform_util::OpenExternal(url, activate);
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("showItemInFolder", &platform_util::ShowItemInFolder);
+  dict.SetMethod("openItem", &platform_util::OpenItem);
+  dict.SetMethod("openExternal", &OpenExternal);
+  dict.SetMethod("moveItemToTrash", &platform_util::MoveItemToTrash);
+  dict.SetMethod("beep", &platform_util::Beep);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_shell, Initialize)
added in remote
  their  100644 efec51533b73a5814701f28c478fbacfa106261d electron/common/api/electron_api_v8_util.cc
@@ -0,0 +1,77 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/api/object_life_monitor.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/dictionary.h"
+#include "v8/include/v8-profiler.h"
+
+namespace {
+
+v8::Local<v8::Value> GetHiddenValue(v8::Isolate* isolate,
+                                    v8::Local<v8::Object> object,
+                                    v8::Local<v8::String> key) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  v8::Local<v8::Value> value;
+  v8::Maybe<bool> result = object->HasPrivate(context, privateKey);
+  if (!(result.IsJust() && result.FromJust()))
+    return v8::Local<v8::Value>();
+  if (object->GetPrivate(context, privateKey).ToLocal(&value))
+    return value;
+  return v8::Local<v8::Value>();
+}
+
+void SetHiddenValue(v8::Isolate* isolate,
+                    v8::Local<v8::Object> object,
+                    v8::Local<v8::String> key,
+                    v8::Local<v8::Value> value) {
+  if (value.IsEmpty())
+    return;
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  object->SetPrivate(context, privateKey, value);
+}
+
+void DeleteHiddenValue(v8::Isolate* isolate,
+                       v8::Local<v8::Object> object,
+                       v8::Local<v8::String> key) {
+  v8::Local<v8::Context> context = isolate->GetCurrentContext();
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  // Actually deleting the value would make force the object into
+  // dictionary mode which is unnecessarily slow. Instead, we replace
+  // the hidden value with "undefined".
+  object->SetPrivate(context, privateKey, v8::Undefined(isolate));
+}
+
+int32_t GetObjectHash(v8::Local<v8::Object> object) {
+  return object->GetIdentityHash();
+}
+
+void SetDestructor(v8::Isolate* isolate,
+                   v8::Local<v8::Object> object,
+                   v8::Local<v8::Function> callback) {
+  electron::ObjectLifeMonitor::BindTo(isolate, object, callback);
+}
+
+void TakeHeapSnapshot(v8::Isolate* isolate) {
+  isolate->GetHeapProfiler()->TakeHeapSnapshot();
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("getHiddenValue", &GetHiddenValue);
+  dict.SetMethod("setHiddenValue", &SetHiddenValue);
+  dict.SetMethod("deleteHiddenValue", &DeleteHiddenValue);
+  dict.SetMethod("getObjectHash", &GetObjectHash);
+  dict.SetMethod("setDestructor", &SetDestructor);
+  dict.SetMethod("takeHeapSnapshot", &TakeHeapSnapshot);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_common_v8_util, Initialize)
added in remote
  their  100644 9771481bf75a34af826bf588e85b6ed99fb1e616 electron/common/api/electron_bindings.cc
@@ -0,0 +1,108 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/electron_bindings.h"
+
+#include <algorithm>
+#include <string>
+#include <iostream>
+
+#include "electron/common/electron_version.h"
+#include "electron/common/chrome_version.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/logging.h"
+#include "base/process/process_metrics.h"
+#include "native_mate/dictionary.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace {
+
+// Dummy class type that used for crashing the program.
+struct DummyClass { bool crash; };
+
+void Crash() {
+  static_cast<DummyClass*>(NULL)->crash = true;
+}
+
+void Hang() {
+  for (;;)
+    base::PlatformThread::Sleep(base::TimeDelta::FromSeconds(1));
+}
+
+// Called when there is a fatal error in V8, we just crash the process here so
+// we can get the stack trace.
+void FatalErrorCallback(const char* location, const char* message) {
+  LOG(ERROR) << "Fatal error in V8: " << location << " " << message;
+  Crash();
+}
+
+void Log(const base::string16& message) {
+  std::cout << message << std::flush;
+}
+
+}  // namespace
+
+
+ElectronBindings::ElectronBindings() {
+  uv_async_init(uv_default_loop(), &call_next_tick_async_, OnCallNextTick);
+  call_next_tick_async_.data = this;
+}
+
+ElectronBindings::~ElectronBindings() {
+}
+
+void ElectronBindings::BindTo(v8::Isolate* isolate,
+                          v8::Local<v8::Object> process) {
+  v8::V8::SetFatalErrorHandler(FatalErrorCallback);
+
+  mate::Dictionary dict(isolate, process);
+  dict.SetMethod("crash", &Crash);
+  dict.SetMethod("hang", &Hang);
+  dict.SetMethod("log", &Log);
+#if defined(OS_POSIX)
+  dict.SetMethod("setFdLimit", &base::SetFdLimit);
+#endif
+  dict.SetMethod("activateUvLoop",
+      base::Bind(&ElectronBindings::ActivateUVLoop, base::Unretained(this)));
+
+#if defined(MAS_BUILD)
+  dict.Set("mas", true);
+#endif
+
+  mate::Dictionary versions;
+  if (dict.Get("versions", &versions)) {
+    versions.Set(ELECTRON_PROJECT_NAME, ELECTRON_VERSION_STRING);
+    versions.Set("atom-shell", ELECTRON_VERSION_STRING);  // For compatibility.
+    versions.Set("chrome", CHROME_VERSION_STRING);
+  }
+}
+
+void ElectronBindings::ActivateUVLoop(v8::Isolate* isolate) {
+  node::Environment* env = node::Environment::GetCurrent(isolate);
+  if (std::find(pending_next_ticks_.begin(), pending_next_ticks_.end(), env) !=
+      pending_next_ticks_.end())
+    return;
+
+  pending_next_ticks_.push_back(env);
+  uv_async_send(&call_next_tick_async_);
+}
+
+// static
+void ElectronBindings::OnCallNextTick(uv_async_t* handle) {
+  ElectronBindings* self = static_cast<ElectronBindings*>(handle->data);
+  for (std::list<node::Environment*>::const_iterator it =
+           self->pending_next_ticks_.begin();
+       it != self->pending_next_ticks_.end(); ++it) {
+    node::Environment* env = *it;
+    node::Environment::AsyncCallbackScope callback_scope(env);
+    env->KickNextTick(&callback_scope);
+  }
+
+  self->pending_next_ticks_.clear();
+}
+
+}  // namespace electron
added in remote
  their  100644 9febb32a6ff1306fd129c0b82edd330fdd25c4b7 electron/common/api/electron_bindings.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
+#define ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
+
+#include <list>
+
+#include "base/macros.h"
+#include "base/strings/string16.h"
+#include "v8/include/v8.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace node {
+class Environment;
+}
+
+namespace electron {
+
+class ElectronBindings {
+ public:
+  ElectronBindings();
+  virtual ~ElectronBindings();
+
+  // Add process.atomBinding function, which behaves like process.binding but
+  // load native code from Electron instead.
+  void BindTo(v8::Isolate* isolate, v8::Local<v8::Object> process);
+
+ private:
+  void ActivateUVLoop(v8::Isolate* isolate);
+
+  static void OnCallNextTick(uv_async_t* handle);
+
+  uv_async_t call_next_tick_async_;
+  std::list<node::Environment*> pending_next_ticks_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronBindings);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_ELECTRON_BINDINGS_H_
added in remote
  their  100644 e25bb7cb88379ff473911f7fbe964e0d249698c2 electron/common/api/event_emitter_caller.cc
@@ -0,0 +1,31 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/event_emitter_caller.h"
+
+#include "electron/common/api/locker.h"
+#include "electron/common/node_includes.h"
+#include "base/memory/scoped_ptr.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+namespace mate {
+
+namespace internal {
+
+v8::Local<v8::Value> CallEmitWithArgs(v8::Isolate* isolate,
+                                      v8::Local<v8::Object> obj,
+                                      ValueVector* args) {
+  // Perform microtask checkpoint after running JavaScript.
+  scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+      Locker::IsBrowserProcess() ?
+      nullptr : new blink::WebScopedRunV8Script);
+  // Use node::MakeCallback to call the callback, and it will also run pending
+  // tasks in Node.js.
+  return node::MakeCallback(
+      isolate, obj, "emit", args->size(), &args->front());
+}
+
+}  // namespace internal
+
+}  // namespace mate
added in remote
  their  100644 2a40a5b92a2a27cc2100f333213a610c7903a90d electron/common/api/event_emitter_caller.h
@@ -0,0 +1,53 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
+#define ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
+
+#include <vector>
+
+#include "native_mate/converter.h"
+
+namespace mate {
+
+namespace internal {
+
+using ValueVector = std::vector<v8::Local<v8::Value>>;
+
+v8::Local<v8::Value> CallEmitWithArgs(v8::Isolate* isolate,
+                                      v8::Local<v8::Object> obj,
+                                      ValueVector* args);
+
+}  // namespace internal
+
+// obj.emit.apply(obj, name, args...);
+// The caller is responsible of allocating a HandleScope.
+template<typename StringType, typename... Args>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               const internal::ValueVector& args) {
+  internal::ValueVector concatenated_args = { StringToV8(isolate, name) };
+  concatenated_args.reserve(1 + args.size());
+  concatenated_args.insert(concatenated_args.end(), args.begin(), args.end());
+  return internal::CallEmitWithArgs(isolate, obj, &concatenated_args);
+}
+
+// obj.emit(name, args...);
+// The caller is responsible of allocating a HandleScope.
+template<typename StringType, typename... Args>
+v8::Local<v8::Value> EmitEvent(v8::Isolate* isolate,
+                               v8::Local<v8::Object> obj,
+                               const StringType& name,
+                               const Args&... args) {
+  internal::ValueVector converted_args = {
+      StringToV8(isolate, name),
+      ConvertToV8(isolate, args)...,
+  };
+  return internal::CallEmitWithArgs(isolate, obj, &converted_args);
+}
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_API_EVENT_EMITTER_CALLER_H_
added in remote
  their  100644 96b9fa63326c48422d0cf5172682174cdbf4c650 electron/common/api/locker.cc
@@ -0,0 +1,17 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#include "electron/common/api/locker.h"
+
+namespace mate {
+
+Locker::Locker(v8::Isolate* isolate) {
+  if (IsBrowserProcess())
+    locker_.reset(new v8::Locker(isolate));
+}
+
+Locker::~Locker() {
+}
+
+}  // namespace mate
added in remote
  their  100644 80203fb942851db437007821d372fbe8ad1ed9ee electron/common/api/locker.h
@@ -0,0 +1,34 @@
+// Copyright 2014 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE.chromium file.
+
+#ifndef ELECTRON_COMMON_API_LOCKER_H_
+#define ELECTRON_COMMON_API_LOCKER_H_
+
+#include "base/memory/scoped_ptr.h"
+#include "v8/include/v8.h"
+
+namespace mate {
+
+// Only lock when lockers are used in current thread.
+class Locker {
+ public:
+  explicit Locker(v8::Isolate* isolate);
+  ~Locker();
+
+  // Returns whether current process is browser process, currently we detect it
+  // by checking whether current has used V8 Lock, but it might be a bad idea.
+  static inline bool IsBrowserProcess() { return v8::Locker::IsActive(); }
+
+ private:
+  void* operator new(size_t size);
+  void operator delete(void*, size_t);
+
+  scoped_ptr<v8::Locker> locker_;
+
+  DISALLOW_COPY_AND_ASSIGN(Locker);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_API_LOCKER_H_
added in remote
  their  100644 c5d219dfcdbee8480a418ce09ca75b15994747a8 electron/common/api/object_life_monitor.cc
@@ -0,0 +1,55 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Copyright (c) 2012 Intel Corp. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/object_life_monitor.h"
+
+#include "base/bind.h"
+#include "base/message_loop/message_loop.h"
+
+namespace electron {
+
+// static
+void ObjectLifeMonitor::BindTo(v8::Isolate* isolate,
+                               v8::Local<v8::Object> target,
+                               v8::Local<v8::Function> destructor) {
+  new ObjectLifeMonitor(isolate, target, destructor);
+}
+
+ObjectLifeMonitor::ObjectLifeMonitor(v8::Isolate* isolate,
+                                     v8::Local<v8::Object> target,
+                                     v8::Local<v8::Function> destructor)
+    : isolate_(isolate),
+      context_(isolate, isolate->GetCurrentContext()),
+      target_(isolate, target),
+      destructor_(isolate, destructor),
+      weak_ptr_factory_(this) {
+  target_.SetWeak(this, OnObjectGC, v8::WeakCallbackType::kParameter);
+}
+
+// static
+void ObjectLifeMonitor::OnObjectGC(
+    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
+  ObjectLifeMonitor* self = data.GetParameter();
+  self->target_.Reset();
+  self->RunCallback();
+  data.SetSecondPassCallback(Free);
+}
+
+// static
+void ObjectLifeMonitor::Free(
+    const v8::WeakCallbackInfo<ObjectLifeMonitor>& data) {
+  delete data.GetParameter();
+}
+
+void ObjectLifeMonitor::RunCallback() {
+  v8::HandleScope handle_scope(isolate_);
+  v8::Local<v8::Context> context = v8::Local<v8::Context>::New(
+      isolate_, context_);
+  v8::Context::Scope context_scope(context);
+  v8::Local<v8::Function>::New(isolate_, destructor_)->Call(
+      context->Global(), 0, nullptr);
+}
+
+}  // namespace electron
added in remote
  their  100644 487a4b288ccb8571acc7e98bfbaeac1afa6fb141 electron/common/api/object_life_monitor.h
@@ -0,0 +1,42 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
+#define ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+class ObjectLifeMonitor {
+ public:
+  static void BindTo(v8::Isolate* isolate,
+                     v8::Local<v8::Object> target,
+                     v8::Local<v8::Function> destructor);
+
+ private:
+  ObjectLifeMonitor(v8::Isolate* isolate,
+                    v8::Local<v8::Object> target,
+                    v8::Local<v8::Function> destructor);
+
+  static void OnObjectGC(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
+  static void Free(const v8::WeakCallbackInfo<ObjectLifeMonitor>& data);
+
+  void RunCallback();
+
+  v8::Isolate* isolate_;
+  v8::Global<v8::Context> context_;
+  v8::Global<v8::Object> target_;
+  v8::Global<v8::Function> destructor_;
+
+  base::WeakPtrFactory<ObjectLifeMonitor> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(ObjectLifeMonitor);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_API_OBJECT_LIFE_MONITOR_H_
added in remote
  their  100644 34250f9e824a5606d837e1e26b7697f4dec8b126 electron/common/asar/archive.cc
@@ -0,0 +1,307 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/archive.h"
+
+#if defined(OS_WIN)
+#include <io.h>
+#endif
+
+#include <string>
+#include <vector>
+
+#include "electron/common/asar/scoped_temporary_file.h"
+#include "base/files/file.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/pickle.h"
+#include "base/json/json_reader.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/values.h"
+
+namespace asar {
+
+namespace {
+
+#if defined(OS_WIN)
+const char kSeparators[] = "\\/";
+#else
+const char kSeparators[] = "/";
+#endif
+
+bool GetNodeFromPath(std::string path,
+                     const base::DictionaryValue* root,
+                     const base::DictionaryValue** out);
+
+// Gets the "files" from "dir".
+bool GetFilesNode(const base::DictionaryValue* root,
+                  const base::DictionaryValue* dir,
+                  const base::DictionaryValue** out) {
+  // Test for symbol linked directory.
+  std::string link;
+  if (dir->GetStringWithoutPathExpansion("link", &link)) {
+    const base::DictionaryValue* linked_node = NULL;
+    if (!GetNodeFromPath(link, root, &linked_node))
+      return false;
+    dir = linked_node;
+  }
+
+  return dir->GetDictionaryWithoutPathExpansion("files", out);
+}
+
+// Gets sub-file "name" from "dir".
+bool GetChildNode(const base::DictionaryValue* root,
+                  const std::string& name,
+                  const base::DictionaryValue* dir,
+                  const base::DictionaryValue** out) {
+  if (name == "") {
+    *out = root;
+    return true;
+  }
+
+  const base::DictionaryValue* files = NULL;
+  return GetFilesNode(root, dir, &files) &&
+         files->GetDictionaryWithoutPathExpansion(name, out);
+}
+
+// Gets the node of "path" from "root".
+bool GetNodeFromPath(std::string path,
+                     const base::DictionaryValue* root,
+                     const base::DictionaryValue** out) {
+  if (path == "") {
+    *out = root;
+    return true;
+  }
+
+  const base::DictionaryValue* dir = root;
+  for (size_t delimiter_position = path.find_first_of(kSeparators);
+       delimiter_position != std::string::npos;
+       delimiter_position = path.find_first_of(kSeparators)) {
+    const base::DictionaryValue* child = NULL;
+    if (!GetChildNode(root, path.substr(0, delimiter_position), dir, &child))
+      return false;
+
+    dir = child;
+    path.erase(0, delimiter_position + 1);
+  }
+
+  return GetChildNode(root, path, dir, out);
+}
+
+bool FillFileInfoWithNode(Archive::FileInfo* info,
+                          uint32_t header_size,
+                          const base::DictionaryValue* node) {
+  int size;
+  if (!node->GetInteger("size", &size))
+    return false;
+  info->size = static_cast<uint32_t>(size);
+
+  if (node->GetBoolean("unpacked", &info->unpacked) && info->unpacked)
+    return true;
+
+  std::string offset;
+  if (!node->GetString("offset", &offset))
+    return false;
+  if (!base::StringToUint64(offset, &info->offset))
+    return false;
+  info->offset += header_size;
+
+  node->GetBoolean("executable", &info->executable);
+
+  return true;
+}
+
+}  // namespace
+
+Archive::Archive(const base::FilePath& path)
+    : path_(path),
+      file_(path_, base::File::FLAG_OPEN | base::File::FLAG_READ),
+#if defined(OS_WIN)
+      fd_(_open_osfhandle(
+              reinterpret_cast<intptr_t>(file_.GetPlatformFile()), 0)),
+#elif defined(OS_POSIX)
+      fd_(file_.GetPlatformFile()),
+#else
+      fd_(-1),
+#endif
+      header_size_(0) {
+}
+
+Archive::~Archive() {
+#if defined(OS_WIN)
+  if (fd_ != -1) {
+    _close(fd_);
+    // Don't close the handle since we already closed the fd.
+    file_.TakePlatformFile();
+  }
+#endif
+}
+
+bool Archive::Init() {
+  if (!file_.IsValid()) {
+    if (file_.error_details() != base::File::FILE_ERROR_NOT_FOUND) {
+      LOG(WARNING) << "Opening " << path_.value()
+                   << ": " << base::File::ErrorToString(file_.error_details());
+    }
+    return false;
+  }
+
+  std::vector<char> buf;
+  int len;
+
+  buf.resize(8);
+  len = file_.ReadAtCurrentPos(buf.data(), buf.size());
+  if (len != static_cast<int>(buf.size())) {
+    PLOG(ERROR) << "Failed to read header size from " << path_.value();
+    return false;
+  }
+
+  uint32_t size;
+  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size())).ReadUInt32(
+          &size)) {
+    LOG(ERROR) << "Failed to parse header size from " << path_.value();
+    return false;
+  }
+
+  buf.resize(size);
+  len = file_.ReadAtCurrentPos(buf.data(), buf.size());
+  if (len != static_cast<int>(buf.size())) {
+    PLOG(ERROR) << "Failed to read header from " << path_.value();
+    return false;
+  }
+
+  std::string header;
+  if (!base::PickleIterator(base::Pickle(buf.data(), buf.size())).ReadString(
+        &header)) {
+    LOG(ERROR) << "Failed to parse header from " << path_.value();
+    return false;
+  }
+
+  std::string error;
+  base::JSONReader reader;
+  scoped_ptr<base::Value> value(reader.ReadToValue(header));
+  if (!value || !value->IsType(base::Value::TYPE_DICTIONARY)) {
+    LOG(ERROR) << "Failed to parse header: " << error;
+    return false;
+  }
+
+  header_size_ = 8 + size;
+  header_.reset(static_cast<base::DictionaryValue*>(value.release()));
+  return true;
+}
+
+bool Archive::GetFileInfo(const base::FilePath& path, FileInfo* info) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  std::string link;
+  if (node->GetString("link", &link))
+    return GetFileInfo(base::FilePath::FromUTF8Unsafe(link), info);
+
+  return FillFileInfoWithNode(info, header_size_, node);
+}
+
+bool Archive::Stat(const base::FilePath& path, Stats* stats) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  if (node->HasKey("link")) {
+    stats->is_file = false;
+    stats->is_link = true;
+    return true;
+  }
+
+  if (node->HasKey("files")) {
+    stats->is_file = false;
+    stats->is_directory = true;
+    return true;
+  }
+
+  return FillFileInfoWithNode(stats, header_size_, node);
+}
+
+bool Archive::Readdir(const base::FilePath& path,
+                      std::vector<base::FilePath>* list) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  const base::DictionaryValue* files;
+  if (!GetFilesNode(header_.get(), node, &files))
+    return false;
+
+  base::DictionaryValue::Iterator iter(*files);
+  while (!iter.IsAtEnd()) {
+    list->push_back(base::FilePath::FromUTF8Unsafe(iter.key()));
+    iter.Advance();
+  }
+  return true;
+}
+
+bool Archive::Realpath(const base::FilePath& path, base::FilePath* realpath) {
+  if (!header_)
+    return false;
+
+  const base::DictionaryValue* node;
+  if (!GetNodeFromPath(path.AsUTF8Unsafe(), header_.get(), &node))
+    return false;
+
+  std::string link;
+  if (node->GetString("link", &link)) {
+    *realpath = base::FilePath::FromUTF8Unsafe(link);
+    return true;
+  }
+
+  *realpath = path;
+  return true;
+}
+
+bool Archive::CopyFileOut(const base::FilePath& path, base::FilePath* out) {
+  if (external_files_.contains(path)) {
+    *out = external_files_.get(path)->path();
+    return true;
+  }
+
+  FileInfo info;
+  if (!GetFileInfo(path, &info))
+    return false;
+
+  if (info.unpacked) {
+    *out = path_.AddExtension(FILE_PATH_LITERAL("unpacked")).Append(path);
+    return true;
+  }
+
+  scoped_ptr<ScopedTemporaryFile> temp_file(new ScopedTemporaryFile);
+  base::FilePath::StringType ext = path.Extension();
+  if (!temp_file->InitFromFile(&file_, ext, info.offset, info.size))
+    return false;
+
+#if defined(OS_POSIX)
+  if (info.executable) {
+    // chmod a+x temp_file;
+    base::SetPosixFilePermissions(temp_file->path(), 0755);
+  }
+#endif
+
+  *out = temp_file->path();
+  external_files_.set(path, std::move(temp_file));
+  return true;
+}
+
+int Archive::GetFD() const {
+  return fd_;
+}
+
+}  // namespace asar
added in remote
  their  100644 4468f1ccda7b1de4c3ed87a176c9615453075002 electron/common/asar/archive.h
@@ -0,0 +1,86 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_ARCHIVE_H_
+#define ELECTRON_COMMON_ASAR_ARCHIVE_H_
+
+#include <vector>
+
+#include "base/containers/scoped_ptr_hash_map.h"
+#include "base/files/file.h"
+#include "base/files/file_path.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace base {
+class DictionaryValue;
+}
+
+namespace asar {
+
+class ScopedTemporaryFile;
+
+// This class represents an asar package, and provides methods to read
+// information from it.
+class Archive {
+ public:
+  struct FileInfo {
+    FileInfo() : unpacked(false), executable(false), size(0), offset(0) {}
+    bool unpacked;
+    bool executable;
+    uint32_t size;
+    uint64_t offset;
+  };
+
+  struct Stats : public FileInfo {
+    Stats() : is_file(true), is_directory(false), is_link(false) {}
+    bool is_file;
+    bool is_directory;
+    bool is_link;
+  };
+
+  explicit Archive(const base::FilePath& path);
+  virtual ~Archive();
+
+  // Read and parse the header.
+  bool Init();
+
+  // Get the info of a file.
+  bool GetFileInfo(const base::FilePath& path, FileInfo* info);
+
+  // Fs.stat(path).
+  bool Stat(const base::FilePath& path, Stats* stats);
+
+  // Fs.readdir(path).
+  bool Readdir(const base::FilePath& path, std::vector<base::FilePath>* files);
+
+  // Fs.realpath(path).
+  bool Realpath(const base::FilePath& path, base::FilePath* realpath);
+
+  // Copy the file into a temporary file, and return the new path.
+  // For unpacked file, this method will return its real path.
+  bool CopyFileOut(const base::FilePath& path, base::FilePath* out);
+
+  // Returns the file's fd.
+  int GetFD() const;
+
+  base::FilePath path() const { return path_; }
+  base::DictionaryValue* header() const { return header_.get(); }
+
+ private:
+  base::FilePath path_;
+  base::File file_;
+  int fd_;
+  uint32_t header_size_;
+  scoped_ptr<base::DictionaryValue> header_;
+
+  // Cached external temporary files.
+  base::ScopedPtrHashMap<base::FilePath, scoped_ptr<ScopedTemporaryFile>>
+      external_files_;
+
+  DISALLOW_COPY_AND_ASSIGN(Archive);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_ARCHIVE_H_
added in remote
  their  100644 56939ce43e1e3b780523838c21db4ee29f58c501 electron/common/asar/asar_util.cc
@@ -0,0 +1,90 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/asar_util.h"
+
+#include <map>
+#include <string>
+
+#include "electron/common/asar/archive.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/lazy_instance.h"
+#include "base/stl_util.h"
+
+namespace asar {
+
+namespace {
+
+// The global instance of ArchiveMap, will be destroyed on exit.
+typedef std::map<base::FilePath, std::shared_ptr<Archive>> ArchiveMap;
+static base::LazyInstance<ArchiveMap> g_archive_map = LAZY_INSTANCE_INITIALIZER;
+
+const base::FilePath::CharType kAsarExtension[] = FILE_PATH_LITERAL(".asar");
+
+}  // namespace
+
+std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path) {
+  ArchiveMap& archive_map = *g_archive_map.Pointer();
+  if (!ContainsKey(archive_map, path)) {
+    std::shared_ptr<Archive> archive(new Archive(path));
+    if (!archive->Init())
+      return nullptr;
+    archive_map[path] = archive;
+  }
+  return archive_map[path];
+}
+
+bool GetAsarArchivePath(const base::FilePath& full_path,
+                        base::FilePath* asar_path,
+                        base::FilePath* relative_path) {
+  base::FilePath iter = full_path;
+  while (true) {
+    base::FilePath dirname = iter.DirName();
+    if (iter.MatchesExtension(kAsarExtension))
+      break;
+    else if (iter == dirname)
+      return false;
+    iter = dirname;
+  }
+
+  base::FilePath tail;
+  if (!iter.AppendRelativePath(full_path, &tail))
+    return false;
+
+  *asar_path = iter;
+  *relative_path = tail;
+  return true;
+}
+
+bool ReadFileToString(const base::FilePath& path, std::string* contents) {
+  base::FilePath asar_path, relative_path;
+  if (!GetAsarArchivePath(path, &asar_path, &relative_path))
+    return base::ReadFileToString(path, contents);
+
+  std::shared_ptr<Archive> archive = GetOrCreateAsarArchive(asar_path);
+  if (!archive)
+    return false;
+
+  Archive::FileInfo info;
+  if (!archive->GetFileInfo(relative_path, &info))
+    return false;
+
+  if (info.unpacked) {
+    base::FilePath real_path;
+    // For unpacked file it will return the real path instead of doing the copy.
+    archive->CopyFileOut(relative_path, &real_path);
+    return base::ReadFileToString(real_path, contents);
+  }
+
+  base::File src(asar_path, base::File::FLAG_OPEN | base::File::FLAG_READ);
+  if (!src.IsValid())
+    return false;
+
+  contents->resize(info.size);
+  return static_cast<int>(info.size) == src.Read(
+      info.offset, const_cast<char*>(contents->data()), contents->size());
+}
+
+}  // namespace asar
added in remote
  their  100644 062ef848f12694243a7a216f9016a26c9e6c319a electron/common/asar/asar_util.h
@@ -0,0 +1,32 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
+#define ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
+
+#include <memory>
+#include <string>
+
+namespace base {
+class FilePath;
+}
+
+namespace asar {
+
+class Archive;
+
+// Gets or creates a new Archive from the path.
+std::shared_ptr<Archive> GetOrCreateAsarArchive(const base::FilePath& path);
+
+// Separates the path to Archive out.
+bool GetAsarArchivePath(const base::FilePath& full_path,
+                        base::FilePath* asar_path,
+                        base::FilePath* relative_path);
+
+// Same with base::ReadFileToString but supports asar Archive.
+bool ReadFileToString(const base::FilePath& path, std::string* contents);
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_ASAR_UTIL_H_
added in remote
  their  100644 8feea02a4a99ebbf70c39d32a1f7bb3c7572c9b0 electron/common/asar/scoped_temporary_file.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/asar/scoped_temporary_file.h"
+
+#include <vector>
+
+#include "base/files/file_util.h"
+#include "base/threading/thread_restrictions.h"
+
+namespace asar {
+
+ScopedTemporaryFile::ScopedTemporaryFile() {
+}
+
+ScopedTemporaryFile::~ScopedTemporaryFile() {
+  if (!path_.empty()) {
+    base::ThreadRestrictions::ScopedAllowIO allow_io;
+    // On Windows it is very likely the file is already in use (because it is
+    // mostly used for Node native modules), so deleting it now will halt the
+    // program.
+#if defined(OS_WIN)
+    base::DeleteFileAfterReboot(path_);
+#else
+    base::DeleteFile(path_, false);
+#endif
+  }
+}
+
+bool ScopedTemporaryFile::Init(const base::FilePath::StringType& ext) {
+  if (!path_.empty())
+    return true;
+
+  base::ThreadRestrictions::ScopedAllowIO allow_io;
+  if (!base::CreateTemporaryFile(&path_))
+    return false;
+
+#if defined(OS_WIN)
+  // Keep the original extension.
+  if (!ext.empty()) {
+    base::FilePath new_path = path_.AddExtension(ext);
+    if (!base::Move(path_, new_path))
+      return false;
+    path_ = new_path;
+  }
+#endif
+
+  return true;
+}
+
+bool ScopedTemporaryFile::InitFromFile(base::File* src,
+                                       const base::FilePath::StringType& ext,
+                                       uint64_t offset, uint64_t size) {
+  if (!src->IsValid())
+    return false;
+
+  if (!Init(ext))
+    return false;
+
+  std::vector<char> buf(size);
+  int len = src->Read(offset, buf.data(), buf.size());
+  if (len != static_cast<int>(size))
+    return false;
+
+  base::File dest(path_, base::File::FLAG_OPEN | base::File::FLAG_WRITE);
+  if (!dest.IsValid())
+    return false;
+
+  return dest.WriteAtCurrentPos(buf.data(), buf.size()) ==
+      static_cast<int>(size);
+}
+
+}  // namespace asar
added in remote
  their  100644 5200bb7184a29c98fde1fa048449ff8d211c0d7c electron/common/asar/scoped_temporary_file.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
+#define ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
+
+#include "base/files/file_path.h"
+
+namespace base {
+class File;
+}
+
+namespace asar {
+
+// An object representing a temporary file that should be cleaned up when this
+// object goes out of scope.  Note that since deletion occurs during the
+// destructor, no further error handling is possible if the directory fails to
+// be deleted.  As a result, deletion is not guaranteed by this class.
+class ScopedTemporaryFile {
+ public:
+  ScopedTemporaryFile();
+  virtual ~ScopedTemporaryFile();
+
+  // Init an empty temporary file with a certain extension.
+  bool Init(const base::FilePath::StringType& ext);
+
+  // Init an temporary file and fill it with content of |path|.
+  bool InitFromFile(base::File* src,
+                    const base::FilePath::StringType& ext,
+                    uint64_t offset, uint64_t size);
+
+  base::FilePath path() const { return path_; }
+
+ private:
+  base::FilePath path_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScopedTemporaryFile);
+};
+
+}  // namespace asar
+
+#endif  // ELECTRON_COMMON_ASAR_SCOPED_TEMPORARY_FILE_H_
added in remote
  their  100644 1ad11067dcb3f03bd010af7bb5dbc1965b067b59 electron/common/chrome_version.h
@@ -0,0 +1,14 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// This file is generated by script/bootstrap.py, you should never modify it
+// by hand.
+
+#ifndef ELECTRON_COMMON_CHROME_VERSION_H_
+#define ELECTRON_COMMON_CHROME_VERSION_H_
+
+#define CHROME_VERSION_STRING "49.0.2623.75"
+#define CHROME_VERSION "v" CHROME_VERSION_STRING
+
+#endif  // ELECTRON_COMMON_CHROME_VERSION_H_
added in remote
  their  100644 2385f590a98f950df2628a9273a8969c25fa2fd6 electron/common/common_message_generator.cc
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Get basic type definitions.
+#define IPC_MESSAGE_IMPL
+#include "electron/common/common_message_generator.h"
+
+// Generate constructors.
+#include "ipc/struct_constructor_macros.h"
+#include "electron/common/common_message_generator.h"
+
+// Generate destructors.
+#include "ipc/struct_destructor_macros.h"
+#include "electron/common/common_message_generator.h"
+
+// Generate param traits write methods.
+#include "ipc/param_traits_write_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits read methods.
+#include "ipc/param_traits_read_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
+// Generate param traits log methods.
+#include "ipc/param_traits_log_macros.h"
+namespace IPC {
+#include "electron/common/common_message_generator.h"
+}  // namespace IPC
+
added in remote
  their  100644 32dfbe347bfb9d1c7730e9563c99d2a6b5d1839c electron/common/common_message_generator.h
@@ -0,0 +1,10 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// Multiply-included file, no traditional include guard.
+
+#include "electron/common/api/api_messages.h"
+#include "chrome/common/print_messages.h"
+#include "chrome/common/tts_messages.h"
+#include "chrome/common/widevine_cdm_messages.h"
added in remote
  their  100644 96b281887edfa08d9c37fddf8ba9cc55ad957903 electron/common/crash_reporter/crash_reporter.cc
@@ -0,0 +1,86 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+
+#include "electron/browser/browser.h"
+#include "electron/common/electron_version.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/common/content_switches.h"
+
+namespace crash_reporter {
+
+CrashReporter::CrashReporter() {
+  auto cmd = base::CommandLine::ForCurrentProcess();
+  is_browser_ = cmd->GetSwitchValueASCII(switches::kProcessType).empty();
+}
+
+CrashReporter::~CrashReporter() {
+}
+
+void CrashReporter::Start(const std::string& product_name,
+                          const std::string& company_name,
+                          const std::string& submit_url,
+                          bool auto_submit,
+                          bool skip_system_crash_handler,
+                          const StringMap& extra_parameters) {
+  SetUploadParameters(extra_parameters);
+
+  InitBreakpad(product_name, ELECTRON_VERSION_STRING, company_name, submit_url,
+               auto_submit, skip_system_crash_handler);
+}
+
+void CrashReporter::SetUploadParameters(const StringMap& parameters) {
+  upload_parameters_ = parameters;
+  upload_parameters_["process_type"] = is_browser_ ? "browser" : "renderer";
+
+  // Setting platform dependent parameters.
+  SetUploadParameters();
+}
+
+std::vector<CrashReporter::UploadReportResult>
+CrashReporter::GetUploadedReports(const std::string& path) {
+  std::string file_content;
+  std::vector<CrashReporter::UploadReportResult> result;
+  if (base::ReadFileToString(base::FilePath::FromUTF8Unsafe(path),
+        &file_content)) {
+    std::vector<std::string> reports = base::SplitString(
+        file_content, "\n", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+    for (const std::string& report : reports) {
+      std::vector<std::string> report_item = base::SplitString(
+          report, ",", base::TRIM_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+      int report_time = 0;
+      if (report_item.size() >= 2 && base::StringToInt(report_item[0],
+            &report_time)) {
+        result.push_back(CrashReporter::UploadReportResult(report_time,
+            report_item[1]));
+      }
+    }
+  }
+  return result;
+}
+
+void CrashReporter::InitBreakpad(const std::string& product_name,
+                                 const std::string& version,
+                                 const std::string& company_name,
+                                 const std::string& submit_url,
+                                 bool auto_submit,
+                                 bool skip_system_crash_handler) {
+}
+
+void CrashReporter::SetUploadParameters() {
+}
+
+#if defined(OS_MACOSX) && defined(MAS_BUILD)
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  static CrashReporter crash_reporter;
+  return &crash_reporter;
+}
+#endif
+
+}  // namespace crash_reporter
added in remote
  their  100644 2f997fab83f3c1ce2369675c6c75084406e16ae4 electron/common/crash_reporter/crash_reporter.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
+
+#include <map>
+#include <string>
+#include <utility>
+#include <vector>
+
+#include "base/macros.h"
+
+namespace crash_reporter {
+
+class CrashReporter {
+ public:
+  typedef std::map<std::string, std::string> StringMap;
+  typedef std::pair<int, std::string> UploadReportResult;  // upload-date, id
+
+  static CrashReporter* GetInstance();
+
+  void Start(const std::string& product_name,
+             const std::string& company_name,
+             const std::string& submit_url,
+             bool auto_submit,
+             bool skip_system_crash_handler,
+             const StringMap& extra_parameters);
+
+  virtual std::vector<CrashReporter::UploadReportResult> GetUploadedReports(
+      const std::string& path);
+
+ protected:
+  CrashReporter();
+  virtual ~CrashReporter();
+
+  virtual void InitBreakpad(const std::string& product_name,
+                            const std::string& version,
+                            const std::string& company_name,
+                            const std::string& submit_url,
+                            bool auto_submit,
+                            bool skip_system_crash_handler);
+  virtual void SetUploadParameters();
+
+  StringMap upload_parameters_;
+  bool is_browser_;
+
+ private:
+  void SetUploadParameters(const StringMap& parameters);
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporter);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_H_
added in remote
  their  100644 d9a5463a965604dface5a0056d12eb54bdcf0d4d electron/common/crash_reporter/crash_reporter_linux.cc
@@ -0,0 +1,141 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_linux.h"
+
+#include <sys/time.h>
+#include <unistd.h>
+
+#include <string>
+
+#include "base/debug/crash_logging.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/linux_util.h"
+#include "base/logging.h"
+#include "base/process/memory.h"
+#include "base/memory/singleton.h"
+#include "base/strings/stringprintf.h"
+#include "vendor/breakpad/src/client/linux/handler/exception_handler.h"
+#include "vendor/breakpad/src/common/linux/linux_libc_support.h"
+
+using google_breakpad::ExceptionHandler;
+using google_breakpad::MinidumpDescriptor;
+
+namespace crash_reporter {
+
+namespace {
+
+static const size_t kDistroSize = 128;
+
+// Define a preferred limit on minidump sizes, because Crash Server currently
+// throws away any larger than 1.2MB (1.2 * 1024 * 1024).  A value of -1 means
+// no limit.
+static const off_t kMaxMinidumpFileSize = 1258291;
+
+}  // namespace
+
+CrashReporterLinux::CrashReporterLinux()
+    : process_start_time_(0),
+      pid_(getpid()) {
+  // Set the base process start time value.
+  struct timeval tv;
+  if (!gettimeofday(&tv, NULL)) {
+    uint64_t ret = tv.tv_sec;
+    ret *= 1000;
+    ret += tv.tv_usec / 1000;
+    process_start_time_ = ret;
+  }
+
+  // Make base::g_linux_distro work.
+  base::SetLinuxDistro(base::GetLinuxDistro());
+}
+
+CrashReporterLinux::~CrashReporterLinux() {
+}
+
+void CrashReporterLinux::InitBreakpad(const std::string& product_name,
+                                      const std::string& version,
+                                      const std::string& company_name,
+                                      const std::string& submit_url,
+                                      bool auto_submit,
+                                      bool skip_system_crash_handler) {
+  EnableCrashDumping(product_name);
+
+  crash_keys_.SetKeyValue("prod", ELECTRON_PRODUCT_NAME);
+  crash_keys_.SetKeyValue("ver", version.c_str());
+  upload_url_ = submit_url;
+
+  for (StringMap::const_iterator iter = upload_parameters_.begin();
+       iter != upload_parameters_.end(); ++iter)
+    crash_keys_.SetKeyValue(iter->first.c_str(), iter->second.c_str());
+}
+
+void CrashReporterLinux::SetUploadParameters() {
+  upload_parameters_["platform"] = "linux";
+}
+
+void CrashReporterLinux::EnableCrashDumping(const std::string& product_name) {
+  std::string dump_dir = "/tmp/" + product_name + " Crashes";
+  base::FilePath dumps_path(dump_dir);
+  base::CreateDirectory(dumps_path);
+
+  std::string log_file = base::StringPrintf(
+      "%s/%s", dump_dir.c_str(), "uploads.log");
+  strncpy(g_crash_log_path, log_file.c_str(), sizeof(g_crash_log_path));
+
+  MinidumpDescriptor minidump_descriptor(dumps_path.value());
+  minidump_descriptor.set_size_limit(kMaxMinidumpFileSize);
+
+  breakpad_.reset(new ExceptionHandler(
+      minidump_descriptor,
+      NULL,
+      CrashDone,
+      this,
+      true,  // Install handlers.
+      -1));
+}
+
+bool CrashReporterLinux::CrashDone(const MinidumpDescriptor& minidump,
+                                   void* context,
+                                   const bool succeeded) {
+  CrashReporterLinux* self = static_cast<CrashReporterLinux*>(context);
+
+  // WARNING: this code runs in a compromised context. It may not call into
+  // libc nor allocate memory normally.
+  if (!succeeded) {
+    const char msg[] = "Failed to generate minidump.";
+    WriteLog(msg, sizeof(msg) - 1);
+    return false;
+  }
+
+  DCHECK(!minidump.IsFD());
+
+  BreakpadInfo info = {0};
+  info.filename = minidump.path();
+  info.fd = minidump.fd();
+  info.distro = base::g_linux_distro;
+  info.distro_length = my_strlen(base::g_linux_distro);
+  info.upload = true;
+  info.process_start_time = self->process_start_time_;
+  info.oom_size = base::g_oom_size;
+  info.pid = self->pid_;
+  info.upload_url = self->upload_url_.c_str();
+  info.crash_keys = &self->crash_keys_;
+  HandleCrashDump(info);
+  return true;
+}
+
+// static
+CrashReporterLinux* CrashReporterLinux::GetInstance() {
+  return base::Singleton<CrashReporterLinux>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterLinux::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 3378b248088f28978fc91f8a305cf7aa7c5e51ab electron/common/crash_reporter/crash_reporter_linux.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
+
+#include <string>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "electron/common/crash_reporter/linux/crash_dump_handler.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace google_breakpad {
+class ExceptionHandler;
+class MinidumpDescriptor;
+}
+
+namespace crash_reporter {
+
+class CrashReporterLinux : public CrashReporter {
+ public:
+  static CrashReporterLinux* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterLinux>;
+
+  CrashReporterLinux();
+  virtual ~CrashReporterLinux();
+
+  void EnableCrashDumping(const std::string& product_name);
+
+  static bool CrashDone(const google_breakpad::MinidumpDescriptor& minidump,
+                        void* context,
+                        const bool succeeded);
+
+  scoped_ptr<google_breakpad::ExceptionHandler> breakpad_;
+  CrashKeyStorage crash_keys_;
+
+  uint64_t process_start_time_;
+  pid_t pid_;
+  std::string upload_url_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterLinux);
+};
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_LINUX_H_
added in remote
  their  100644 de92f09c9e24cabe515c54227815d225c91ad1fd electron/common/crash_reporter/crash_reporter_mac.h
@@ -0,0 +1,55 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/strings/string_piece.h"
+#include "vendor/crashpad/client/simple_string_dictionary.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace crash_reporter {
+
+class CrashReporterMac : public CrashReporter {
+ public:
+  static CrashReporterMac* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterMac>;
+
+  CrashReporterMac();
+  virtual ~CrashReporterMac();
+
+  void SetUploadsEnabled(bool enable_uploads);
+  void SetCrashKeyValue(const base::StringPiece& key,
+                        const base::StringPiece& value);
+
+  std::vector<UploadReportResult> GetUploadedReports(
+      const std::string& path) override;
+
+  scoped_ptr<crashpad::SimpleStringDictionary> simple_string_dictionary_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterMac);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_MAC_H_
added in remote
  their  100644 4ecbc5472a0397227e8be8f816ded73b41a681e2 electron/common/crash_reporter/crash_reporter_mac.mm
@@ -0,0 +1,138 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_mac.h"
+
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/mac/bundle_locations.h"
+#include "base/mac/mac_util.h"
+#include "base/memory/singleton.h"
+#include "base/strings/string_piece.h"
+#include "base/strings/stringprintf.h"
+#include "base/strings/sys_string_conversions.h"
+#include "vendor/crashpad/client/crash_report_database.h"
+#include "vendor/crashpad/client/crashpad_client.h"
+#include "vendor/crashpad/client/crashpad_info.h"
+#include "vendor/crashpad/client/settings.h"
+
+namespace crash_reporter {
+
+CrashReporterMac::CrashReporterMac() {
+}
+
+CrashReporterMac::~CrashReporterMac() {
+}
+
+void CrashReporterMac::InitBreakpad(const std::string& product_name,
+                                    const std::string& version,
+                                    const std::string& company_name,
+                                    const std::string& submit_url,
+                                    bool auto_submit,
+                                    bool skip_system_crash_handler) {
+  // check whether crashpad has been initilized.
+  // Only need to initilize once.
+  if (simple_string_dictionary_)
+    return;
+
+  std::string dump_dir = "/tmp/" + product_name + " Crashes";
+  base::FilePath database_path(dump_dir);
+  if (is_browser_) {
+    @autoreleasepool {
+      base::FilePath framework_bundle_path = base::mac::FrameworkBundlePath();
+      base::FilePath handler_path =
+          framework_bundle_path.Append("Resources").Append("crashpad_handler");
+
+      crashpad::CrashpadClient crashpad_client;
+      if (crashpad_client.StartHandler(handler_path, database_path,
+                                       submit_url,
+                                       StringMap(),
+                                       std::vector<std::string>(),
+                                       true)) {
+        crashpad_client.UseHandler();
+      }
+    }  // @autoreleasepool
+  }
+
+  crashpad::CrashpadInfo* crashpad_info =
+      crashpad::CrashpadInfo::GetCrashpadInfo();
+  if (skip_system_crash_handler) {
+    crashpad_info->set_system_crash_reporter_forwarding(
+        crashpad::TriState::kDisabled);
+  }
+
+  simple_string_dictionary_.reset(new crashpad::SimpleStringDictionary());
+  crashpad_info->set_simple_annotations(simple_string_dictionary_.get());
+
+  SetCrashKeyValue("prod", ELECTRON_PRODUCT_NAME);
+  SetCrashKeyValue("process_type", is_browser_ ? "browser" : "renderer");
+  SetCrashKeyValue("ver", version);
+
+  for (const auto& upload_parameter: upload_parameters_) {
+    SetCrashKeyValue(upload_parameter.first, upload_parameter.second);
+  }
+  if (is_browser_) {
+    scoped_ptr<crashpad::CrashReportDatabase> database =
+        crashpad::CrashReportDatabase::Initialize(database_path);
+    if (database) {
+      database->GetSettings()->SetUploadsEnabled(auto_submit);
+    }
+  }
+}
+
+void CrashReporterMac::SetUploadParameters() {
+  upload_parameters_["platform"] = "darwin";
+}
+
+void CrashReporterMac::SetCrashKeyValue(const base::StringPiece& key,
+                                        const base::StringPiece& value) {
+  simple_string_dictionary_->SetKeyValue(key.data(), value.data());
+}
+
+std::vector<CrashReporter::UploadReportResult>
+CrashReporterMac::GetUploadedReports(const std::string& path) {
+  std::vector<CrashReporter::UploadReportResult> uploaded_reports;
+
+  base::FilePath file_path(path);
+  if (!base::PathExists(file_path)) {
+    return uploaded_reports;
+  }
+  // Load crashpad database.
+  scoped_ptr<crashpad::CrashReportDatabase> database =
+    crashpad::CrashReportDatabase::Initialize(file_path);
+  DCHECK(database);
+
+  std::vector<crashpad::CrashReportDatabase::Report> completed_reports;
+  crashpad::CrashReportDatabase::OperationStatus status =
+      database->GetCompletedReports(&completed_reports);
+  if (status != crashpad::CrashReportDatabase::kNoError) {
+    return uploaded_reports;
+  }
+
+  for (const crashpad::CrashReportDatabase::Report& completed_report :
+       completed_reports) {
+    if (completed_report.uploaded) {
+      uploaded_reports.push_back(
+          UploadReportResult(static_cast<int>(completed_report.creation_time),
+                             completed_report.id));
+    }
+  }
+
+  auto sort_by_time = [](const UploadReportResult& a,
+      const UploadReportResult& b) {return a.first >= b.first;};
+  std::sort(uploaded_reports.begin(), uploaded_reports.end(), sort_by_time);
+  return uploaded_reports;
+}
+
+// static
+CrashReporterMac* CrashReporterMac::GetInstance() {
+  return base::Singleton<CrashReporterMac>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterMac::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 0fd6ef32731daa9f760980acf673fe94d2eb2e50 electron/common/crash_reporter/crash_reporter_win.cc
@@ -0,0 +1,270 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/crash_reporter_win.h"
+
+#include <string>
+
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/common/result_codes.h"
+#include "gin/public/debug.h"
+#include "sandbox/win/src/nt_internals.h"
+
+#pragma intrinsic(_AddressOfReturnAddress)
+#pragma intrinsic(_ReturnAddress)
+
+#ifdef _WIN64
+// See http://msdn.microsoft.com/en-us/library/ddssxxy8.aspx
+typedef struct _UNWIND_INFO {
+  unsigned char Version : 3;
+  unsigned char Flags : 5;
+  unsigned char SizeOfProlog;
+  unsigned char CountOfCodes;
+  unsigned char FrameRegister : 4;
+  unsigned char FrameOffset : 4;
+  ULONG ExceptionHandler;
+} UNWIND_INFO, *PUNWIND_INFO;
+#endif
+
+namespace crash_reporter {
+
+namespace {
+
+// Minidump with stacks, PEB, TEB, and unloaded module list.
+const MINIDUMP_TYPE kSmallDumpType = static_cast<MINIDUMP_TYPE>(
+    MiniDumpWithProcessThreadData |  // Get PEB and TEB.
+    MiniDumpWithUnloadedModules);  // Get unloaded modules when available.
+
+const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
+const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
+
+typedef NTSTATUS (WINAPI* NtTerminateProcessPtr)(HANDLE ProcessHandle,
+                                                 NTSTATUS ExitStatus);
+char* g_real_terminate_process_stub = NULL;
+
+void TerminateProcessWithoutDump() {
+  // Patched stub exists based on conditions (See InitCrashReporter).
+  // As a side note this function also gets called from
+  // WindowProcExceptionFilter.
+  if (g_real_terminate_process_stub == NULL) {
+    ::TerminateProcess(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
+  } else {
+    NtTerminateProcessPtr real_terminate_proc =
+        reinterpret_cast<NtTerminateProcessPtr>(
+            static_cast<char*>(g_real_terminate_process_stub));
+    real_terminate_proc(::GetCurrentProcess(), content::RESULT_CODE_KILLED);
+  }
+}
+
+#ifdef _WIN64
+int CrashForExceptionInNonABICompliantCodeRange(
+    PEXCEPTION_RECORD ExceptionRecord,
+    ULONG64 EstablisherFrame,
+    PCONTEXT ContextRecord,
+    PDISPATCHER_CONTEXT DispatcherContext) {
+  EXCEPTION_POINTERS info = { ExceptionRecord, ContextRecord };
+  if (!CrashReporter::GetInstance())
+    return EXCEPTION_CONTINUE_SEARCH;
+  return static_cast<CrashReporterWin*>(CrashReporter::GetInstance())->
+      CrashForException(&info);
+}
+
+struct ExceptionHandlerRecord {
+  RUNTIME_FUNCTION runtime_function;
+  UNWIND_INFO unwind_info;
+  unsigned char thunk[12];
+};
+
+bool RegisterNonABICompliantCodeRange(void* start, size_t size_in_bytes) {
+  ExceptionHandlerRecord* record =
+      reinterpret_cast<ExceptionHandlerRecord*>(start);
+
+  // We assume that the first page of the code range is executable and
+  // committed and reserved for breakpad. What could possibly go wrong?
+
+  // All addresses are 32bit relative offsets to start.
+  record->runtime_function.BeginAddress = 0;
+  record->runtime_function.EndAddress =
+      base::checked_cast<DWORD>(size_in_bytes);
+  record->runtime_function.UnwindData =
+      offsetof(ExceptionHandlerRecord, unwind_info);
+
+  // Create unwind info that only specifies an exception handler.
+  record->unwind_info.Version = 1;
+  record->unwind_info.Flags = UNW_FLAG_EHANDLER;
+  record->unwind_info.SizeOfProlog = 0;
+  record->unwind_info.CountOfCodes = 0;
+  record->unwind_info.FrameRegister = 0;
+  record->unwind_info.FrameOffset = 0;
+  record->unwind_info.ExceptionHandler =
+      offsetof(ExceptionHandlerRecord, thunk);
+
+  // Hardcoded thunk.
+  // mov imm64, rax
+  record->thunk[0] = 0x48;
+  record->thunk[1] = 0xb8;
+  void* handler = &CrashForExceptionInNonABICompliantCodeRange;
+  memcpy(&record->thunk[2], &handler, 8);
+
+  // jmp rax
+  record->thunk[10] = 0xff;
+  record->thunk[11] = 0xe0;
+
+  // Protect reserved page against modifications.
+  DWORD old_protect;
+  return VirtualProtect(start, sizeof(ExceptionHandlerRecord),
+                        PAGE_EXECUTE_READ, &old_protect) &&
+         RtlAddFunctionTable(&record->runtime_function, 1,
+                             reinterpret_cast<DWORD64>(start));
+}
+
+void UnregisterNonABICompliantCodeRange(void* start) {
+  ExceptionHandlerRecord* record =
+      reinterpret_cast<ExceptionHandlerRecord*>(start);
+
+  RtlDeleteFunctionTable(&record->runtime_function);
+}
+#endif  // _WIN64
+
+}  // namespace
+
+CrashReporterWin::CrashReporterWin() {
+}
+
+CrashReporterWin::~CrashReporterWin() {
+}
+
+void CrashReporterWin::InitBreakpad(const std::string& product_name,
+                                    const std::string& version,
+                                    const std::string& company_name,
+                                    const std::string& submit_url,
+                                    bool auto_submit,
+                                    bool skip_system_crash_handler) {
+  skip_system_crash_handler_ = skip_system_crash_handler;
+
+  base::FilePath temp_dir;
+  if (!base::GetTempDir(&temp_dir)) {
+    LOG(ERROR) << "Cannot get temp directory";
+    return;
+  }
+
+  base::string16 pipe_name = base::ReplaceStringPlaceholders(
+      kPipeNameFormat, base::UTF8ToUTF16(product_name), NULL);
+  base::string16 wait_name = base::ReplaceStringPlaceholders(
+      kWaitEventFormat, base::UTF8ToUTF16(product_name), NULL);
+
+  // Wait until the crash service is started.
+  HANDLE wait_event = ::CreateEventW(NULL, TRUE, FALSE, wait_name.c_str());
+  if (wait_event != NULL) {
+    WaitForSingleObject(wait_event, 1000);
+    CloseHandle(wait_event);
+  }
+
+  // ExceptionHandler() attaches our handler and ~ExceptionHandler() detaches
+  // it, so we must explicitly reset *before* we instantiate our new handler
+  // to allow any previous handler to detach in the correct order.
+  breakpad_.reset();
+
+  breakpad_.reset(new google_breakpad::ExceptionHandler(
+      temp_dir.value(),
+      FilterCallback,
+      MinidumpCallback,
+      this,
+      google_breakpad::ExceptionHandler::HANDLER_ALL,
+      kSmallDumpType,
+      pipe_name.c_str(),
+      GetCustomInfo(product_name, version, company_name)));
+
+  if (!breakpad_->IsOutOfProcess())
+    LOG(ERROR) << "Cannot initialize out-of-process crash handler";
+
+#ifdef _WIN64
+  bool registered = false;
+  // Hook up V8 to breakpad.
+  {
+    // gin::Debug::SetCodeRangeCreatedCallback only runs the callback when
+    // Isolate is just created, so we have to manually run following code here.
+    void* code_range = nullptr;
+    size_t size = 0;
+    v8::Isolate::GetCurrent()->GetCodeRange(&code_range, &size);
+    if (code_range && size)
+      registered = RegisterNonABICompliantCodeRange(code_range, size);
+  }
+  if (registered)
+    gin::Debug::SetCodeRangeDeletedCallback(UnregisterNonABICompliantCodeRange);
+#endif
+}
+
+void CrashReporterWin::SetUploadParameters() {
+  upload_parameters_["platform"] = "win32";
+}
+
+int CrashReporterWin::CrashForException(EXCEPTION_POINTERS* info) {
+  if (breakpad_) {
+    breakpad_->WriteMinidumpForException(info);
+    TerminateProcessWithoutDump();
+  }
+  return EXCEPTION_CONTINUE_SEARCH;
+}
+
+// static
+bool CrashReporterWin::FilterCallback(void* context,
+                                      EXCEPTION_POINTERS* exinfo,
+                                      MDRawAssertionInfo* assertion) {
+  return true;
+}
+
+// static
+bool CrashReporterWin::MinidumpCallback(const wchar_t* dump_path,
+                                        const wchar_t* minidump_id,
+                                        void* context,
+                                        EXCEPTION_POINTERS* exinfo,
+                                        MDRawAssertionInfo* assertion,
+                                        bool succeeded) {
+  CrashReporterWin* self = static_cast<CrashReporterWin*>(context);
+  if (succeeded && !self->skip_system_crash_handler_)
+    return true;
+  else
+    return false;
+}
+
+google_breakpad::CustomClientInfo* CrashReporterWin::GetCustomInfo(
+    const std::string& product_name,
+    const std::string& version,
+    const std::string& company_name) {
+  custom_info_entries_.clear();
+  custom_info_entries_.reserve(2 + upload_parameters_.size());
+
+  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+      L"prod", L"Electron"));
+  custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+      L"ver", base::UTF8ToWide(version).c_str()));
+
+  for (StringMap::const_iterator iter = upload_parameters_.begin();
+       iter != upload_parameters_.end(); ++iter) {
+    custom_info_entries_.push_back(google_breakpad::CustomInfoEntry(
+        base::UTF8ToWide(iter->first).c_str(),
+        base::UTF8ToWide(iter->second).c_str()));
+  }
+
+  custom_info_.entries = &custom_info_entries_.front();
+  custom_info_.count = custom_info_entries_.size();
+  return &custom_info_;
+}
+
+// static
+CrashReporterWin* CrashReporterWin::GetInstance() {
+  return base::Singleton<CrashReporterWin>::get();
+}
+
+// static
+CrashReporter* CrashReporter::GetInstance() {
+  return CrashReporterWin::GetInstance();
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 c0a00afca62ce8c01149aa66dd8f18ac4ffbac73 electron/common/crash_reporter/crash_reporter_win.h
@@ -0,0 +1,72 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
+
+#include <string>
+#include <vector>
+
+#include "electron/common/crash_reporter/crash_reporter.h"
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_ptr.h"
+#include "vendor/breakpad/src/client/windows/handler/exception_handler.h"
+
+namespace base {
+template <typename T> struct DefaultSingletonTraits;
+}
+
+namespace crash_reporter {
+
+class CrashReporterWin : public CrashReporter {
+ public:
+  static CrashReporterWin* GetInstance();
+
+  void InitBreakpad(const std::string& product_name,
+                    const std::string& version,
+                    const std::string& company_name,
+                    const std::string& submit_url,
+                    bool auto_submit,
+                    bool skip_system_crash_handler) override;
+  void SetUploadParameters() override;
+
+  // Crashes the process after generating a dump for the provided exception.
+  int CrashForException(EXCEPTION_POINTERS* info);
+
+ private:
+  friend struct base::DefaultSingletonTraits<CrashReporterWin>;
+
+  CrashReporterWin();
+  virtual ~CrashReporterWin();
+
+  static bool FilterCallback(void* context,
+                             EXCEPTION_POINTERS* exinfo,
+                             MDRawAssertionInfo* assertion);
+
+  static bool MinidumpCallback(const wchar_t* dump_path,
+                               const wchar_t* minidump_id,
+                               void* context,
+                               EXCEPTION_POINTERS* exinfo,
+                               MDRawAssertionInfo* assertion,
+                               bool succeeded);
+
+  // Returns the custom info structure based on parameters.
+  google_breakpad::CustomClientInfo* GetCustomInfo(
+      const std::string& product_name,
+      const std::string& version,
+      const std::string& company_name);
+
+  // Custom information to be passed to crash handler.
+  std::vector<google_breakpad::CustomInfoEntry> custom_info_entries_;
+  google_breakpad::CustomClientInfo custom_info_;
+
+  bool skip_system_crash_handler_;
+  scoped_ptr<google_breakpad::ExceptionHandler> breakpad_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashReporterWin);
+};
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_CRASH_REPORTER_WIN_H_
added in remote
  their  100644 736ab5e849adbb932a37183a66a396628507cade electron/common/crash_reporter/linux/crash_dump_handler.cc
@@ -0,0 +1,746 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+// For linux_syscall_support.h. This makes it safe to call embedded system
+// calls when in seccomp mode.
+
+#include "electron/common/crash_reporter/linux/crash_dump_handler.h"
+
+#include <poll.h>
+
+#include <algorithm>
+
+#include "base/posix/eintr_wrapper.h"
+#include "vendor/breakpad/src/client/linux/minidump_writer/directory_reader.h"
+#include "vendor/breakpad/src/common/linux/linux_libc_support.h"
+#include "vendor/breakpad/src/common/memory.h"
+
+#include "third_party/lss/linux_syscall_support.h"
+
+// Some versions of gcc are prone to warn about unused return values. In cases
+// where we either a) know the call cannot fail, or b) there is nothing we
+// can do when a call fails, we mark the return code as ignored. This avoids
+// spurious compiler warnings.
+#define IGNORE_RET(x) do { if (x); } while (0)
+
+namespace crash_reporter {
+
+namespace {
+
+// String buffer size to use to convert a uint64_t to string.
+const size_t kUint64StringSize = 21;
+
+// Writes the value |v| as 16 hex characters to the memory pointed at by
+// |output|.
+void write_uint64_hex(char* output, uint64_t v) {
+  static const char hextable[] = "0123456789abcdef";
+
+  for (int i = 15; i >= 0; --i) {
+    output[i] = hextable[v & 15];
+    v >>= 4;
+  }
+}
+
+// uint64_t version of my_int_len() from
+// breakpad/src/common/linux/linux_libc_support.h. Return the length of the
+// given, non-negative integer when expressed in base 10.
+unsigned my_uint64_len(uint64_t i) {
+  if (!i)
+    return 1;
+
+  unsigned len = 0;
+  while (i) {
+    len++;
+    i /= 10;
+  }
+
+  return len;
+}
+
+// uint64_t version of my_uitos() from
+// breakpad/src/common/linux/linux_libc_support.h. Convert a non-negative
+// integer to a string (not null-terminated).
+void my_uint64tos(char* output, uint64_t i, unsigned i_len) {
+  for (unsigned index = i_len; index; --index, i /= 10)
+    output[index - 1] = '0' + (i % 10);
+}
+
+// Converts a struct timeval to milliseconds.
+uint64_t kernel_timeval_to_ms(struct kernel_timeval *tv) {
+  uint64_t ret = tv->tv_sec;  // Avoid overflow by explicitly using a uint64_t.
+  ret *= 1000;
+  ret += tv->tv_usec / 1000;
+  return ret;
+}
+
+bool my_isxdigit(char c) {
+  return (c >= '0' && c <= '9') || ((c | 0x20) >= 'a' && (c | 0x20) <= 'f');
+}
+
+size_t LengthWithoutTrailingSpaces(const char* str, size_t len) {
+  while (len > 0 && str[len - 1] == ' ') {
+    len--;
+  }
+  return len;
+}
+
+// MIME substrings.
+const char g_rn[] = "\r\n";
+const char g_form_data_msg[] = "Content-Disposition: form-data; name=\"";
+const char g_quote_msg[] = "\"";
+const char g_dashdash_msg[] = "--";
+const char g_dump_msg[] = "upload_file_minidump\"; filename=\"dump\"";
+const char g_content_type_msg[] = "Content-Type: application/octet-stream";
+
+// MimeWriter manages an iovec for writing MIMEs to a file.
+class MimeWriter {
+ public:
+  static const int kIovCapacity = 30;
+  static const size_t kMaxCrashChunkSize = 64;
+
+  MimeWriter(int fd, const char* const mime_boundary);
+  ~MimeWriter();
+
+  // Append boundary.
+  virtual void AddBoundary();
+
+  // Append end of file boundary.
+  virtual void AddEnd();
+
+  // Append key/value pair with specified sizes.
+  virtual void AddPairData(const char* msg_type,
+                           size_t msg_type_size,
+                           const char* msg_data,
+                           size_t msg_data_size);
+
+  // Append key/value pair.
+  void AddPairString(const char* msg_type,
+                     const char* msg_data) {
+    AddPairData(msg_type, my_strlen(msg_type), msg_data, my_strlen(msg_data));
+  }
+
+  // Append key/value pair, splitting value into chunks no larger than
+  // |chunk_size|. |chunk_size| cannot be greater than |kMaxCrashChunkSize|.
+  // The msg_type string will have a counter suffix to distinguish each chunk.
+  virtual void AddPairDataInChunks(const char* msg_type,
+                                   size_t msg_type_size,
+                                   const char* msg_data,
+                                   size_t msg_data_size,
+                                   size_t chunk_size,
+                                   bool strip_trailing_spaces);
+
+  // Add binary file contents to be uploaded with the specified filename.
+  virtual void AddFileContents(const char* filename_msg,
+                               uint8_t* file_data,
+                               size_t file_size);
+
+  // Flush any pending iovecs to the output file.
+  void Flush() {
+    IGNORE_RET(sys_writev(fd_, iov_, iov_index_));
+    iov_index_ = 0;
+  }
+
+ protected:
+  void AddItem(const void* base, size_t size);
+  // Minor performance trade-off for easier-to-maintain code.
+  void AddString(const char* str) {
+    AddItem(str, my_strlen(str));
+  }
+  void AddItemWithoutTrailingSpaces(const void* base, size_t size);
+
+  struct kernel_iovec iov_[kIovCapacity];
+  int iov_index_;
+
+  // Output file descriptor.
+  int fd_;
+
+  const char* const mime_boundary_;
+
+ private:
+  DISALLOW_COPY_AND_ASSIGN(MimeWriter);
+};
+
+MimeWriter::MimeWriter(int fd, const char* const mime_boundary)
+    : iov_index_(0),
+      fd_(fd),
+      mime_boundary_(mime_boundary) {
+}
+
+MimeWriter::~MimeWriter() {
+}
+
+void MimeWriter::AddBoundary() {
+  AddString(mime_boundary_);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddEnd() {
+  AddString(mime_boundary_);
+  AddString(g_dashdash_msg);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddPairData(const char* msg_type,
+                             size_t msg_type_size,
+                             const char* msg_data,
+                             size_t msg_data_size) {
+  AddString(g_form_data_msg);
+  AddItem(msg_type, msg_type_size);
+  AddString(g_quote_msg);
+  AddString(g_rn);
+  AddString(g_rn);
+  AddItem(msg_data, msg_data_size);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddPairDataInChunks(const char* msg_type,
+                                     size_t msg_type_size,
+                                     const char* msg_data,
+                                     size_t msg_data_size,
+                                     size_t chunk_size,
+                                     bool strip_trailing_spaces) {
+  if (chunk_size > kMaxCrashChunkSize)
+    return;
+
+  unsigned i = 0;
+  size_t done = 0, msg_length = msg_data_size;
+
+  while (msg_length) {
+    char num[kUint64StringSize];
+    const unsigned num_len = my_uint_len(++i);
+    my_uitos(num, i, num_len);
+
+    size_t chunk_len = std::min(chunk_size, msg_length);
+
+    AddString(g_form_data_msg);
+    AddItem(msg_type, msg_type_size);
+    AddItem(num, num_len);
+    AddString(g_quote_msg);
+    AddString(g_rn);
+    AddString(g_rn);
+    if (strip_trailing_spaces) {
+      AddItemWithoutTrailingSpaces(msg_data + done, chunk_len);
+    } else {
+      AddItem(msg_data + done, chunk_len);
+    }
+    AddString(g_rn);
+    AddBoundary();
+    Flush();
+
+    done += chunk_len;
+    msg_length -= chunk_len;
+  }
+}
+
+void MimeWriter::AddFileContents(const char* filename_msg, uint8_t* file_data,
+                                 size_t file_size) {
+  AddString(g_form_data_msg);
+  AddString(filename_msg);
+  AddString(g_rn);
+  AddString(g_content_type_msg);
+  AddString(g_rn);
+  AddString(g_rn);
+  AddItem(file_data, file_size);
+  AddString(g_rn);
+}
+
+void MimeWriter::AddItem(const void* base, size_t size) {
+  // Check if the iovec is full and needs to be flushed to output file.
+  if (iov_index_ == kIovCapacity) {
+    Flush();
+  }
+  iov_[iov_index_].iov_base = const_cast<void*>(base);
+  iov_[iov_index_].iov_len = size;
+  ++iov_index_;
+}
+
+void MimeWriter::AddItemWithoutTrailingSpaces(const void* base, size_t size) {
+  AddItem(base, LengthWithoutTrailingSpaces(static_cast<const char*>(base),
+                                            size));
+}
+
+void LoadDataFromFD(google_breakpad::PageAllocator* allocator,
+                    int fd, bool close_fd, uint8_t** file_data, size_t* size) {
+  struct kernel_stat st;
+  if (sys_fstat(fd, &st) != 0) {
+    static const char msg[] = "Cannot upload crash dump: stat failed\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+
+  *file_data = reinterpret_cast<uint8_t*>(allocator->Alloc(st.st_size));
+  if (!(*file_data)) {
+    static const char msg[] = "Cannot upload crash dump: cannot alloc\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+  my_memset(*file_data, 0xf, st.st_size);
+
+  *size = st.st_size;
+  int byte_read = sys_read(fd, *file_data, *size);
+  if (byte_read == -1) {
+    static const char msg[] = "Cannot upload crash dump: read failed\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    if (close_fd)
+      IGNORE_RET(sys_close(fd));
+    return;
+  }
+
+  if (close_fd)
+    IGNORE_RET(sys_close(fd));
+}
+
+void LoadDataFromFile(google_breakpad::PageAllocator* allocator,
+                      const char* filename,
+                      int* fd, uint8_t** file_data, size_t* size) {
+  // WARNING: this code runs in a compromised context. It may not call into
+  // libc nor allocate memory normally.
+  *fd = sys_open(filename, O_RDONLY, 0);
+  *size = 0;
+
+  if (*fd < 0) {
+    static const char msg[] = "Cannot upload crash dump: failed to open\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    return;
+  }
+
+  LoadDataFromFD(allocator, *fd, true, file_data, size);
+}
+
+// Spawn the appropriate upload process for the current OS:
+// - generic Linux invokes wget.
+// - ChromeOS invokes crash_reporter.
+// |dumpfile| is the path to the dump data file.
+// |mime_boundary| is only used on Linux.
+// |exe_buf| is only used on CrOS and is the crashing process' name.
+void ExecUploadProcessOrTerminate(const BreakpadInfo& info,
+                                  const char* dumpfile,
+                                  const char* mime_boundary,
+                                  const char* exe_buf,
+                                  google_breakpad::PageAllocator* allocator) {
+  // The --header argument to wget looks like:
+  //   --header=Content-Type: multipart/form-data; boundary=XYZ
+  // where the boundary has two fewer leading '-' chars
+  static const char header_msg[] =
+      "--header=Content-Type: multipart/form-data; boundary=";
+  char* const header = reinterpret_cast<char*>(allocator->Alloc(
+      sizeof(header_msg) - 1 + strlen(mime_boundary) - 2 + 1));
+  memcpy(header, header_msg, sizeof(header_msg) - 1);
+  memcpy(header + sizeof(header_msg) - 1, mime_boundary + 2,
+         strlen(mime_boundary) - 2);
+  // We grab the NUL byte from the end of |mime_boundary|.
+
+  // The --post-file argument to wget looks like:
+  //   --post-file=/tmp/...
+  static const char post_file_msg[] = "--post-file=";
+  char* const post_file = reinterpret_cast<char*>(allocator->Alloc(
+       sizeof(post_file_msg) - 1 + strlen(dumpfile) + 1));
+  memcpy(post_file, post_file_msg, sizeof(post_file_msg) - 1);
+  memcpy(post_file + sizeof(post_file_msg) - 1, dumpfile, strlen(dumpfile));
+
+  static const char kWgetBinary[] = "/usr/bin/wget";
+  const char* args[] = {
+    kWgetBinary,
+    header,
+    post_file,
+    info.upload_url,
+    "--timeout=60",  // Set a timeout so we don't hang forever.
+    "--tries=1",     // Don't retry if the upload fails.
+    "--quiet",       // Be silent.
+    "-O",            // output reply to /dev/null.
+    "/dev/fd/3",
+    NULL,
+  };
+  static const char msg[] = "Cannot upload crash dump: cannot exec "
+                            "/usr/bin/wget\n";
+  execve(args[0], const_cast<char**>(args), environ);
+  WriteLog(msg, sizeof(msg) - 1);
+  sys__exit(1);
+}
+
+// Runs in the helper process to wait for the upload process running
+// ExecUploadProcessOrTerminate() to finish. Returns the number of bytes written
+// to |fd| and save the written contents to |buf|.
+// |buf| needs to be big enough to hold |bytes_to_read| + 1 characters.
+size_t WaitForCrashReportUploadProcess(int fd, size_t bytes_to_read,
+                                       char* buf) {
+  size_t bytes_read = 0;
+
+  // Upload should finish in about 10 seconds. Add a few more 500 ms
+  // internals to account for process startup time.
+  for (size_t wait_count = 0; wait_count < 24; ++wait_count) {
+    struct kernel_pollfd poll_fd;
+    poll_fd.fd = fd;
+    poll_fd.events = POLLIN | POLLPRI | POLLERR;
+    int ret = sys_poll(&poll_fd, 1, 500);
+    if (ret < 0) {
+      // Error
+      break;
+    } else if (ret > 0) {
+      // There is data to read.
+      ssize_t len = HANDLE_EINTR(
+          sys_read(fd, buf + bytes_read, bytes_to_read - bytes_read));
+      if (len < 0)
+        break;
+      bytes_read += len;
+      if (bytes_read == bytes_to_read)
+        break;
+    }
+    // |ret| == 0 -> timed out, continue waiting.
+    // or |bytes_read| < |bytes_to_read| still, keep reading.
+  }
+  buf[bytes_to_read] = 0;  // Always NUL terminate the buffer.
+  return bytes_read;
+}
+
+// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
+bool IsValidCrashReportId(const char* buf, size_t bytes_read,
+                          size_t expected_len) {
+  if (bytes_read != expected_len)
+    return false;
+  for (size_t i = 0; i < bytes_read; ++i) {
+    if (!my_isxdigit(buf[i]) && buf[i] != '-')
+      return false;
+  }
+  return true;
+}
+
+// |buf| should be |expected_len| + 1 characters in size and NULL terminated.
+void HandleCrashReportId(const char* buf, size_t bytes_read,
+                         size_t expected_len) {
+  if (!IsValidCrashReportId(buf, bytes_read, expected_len)) {
+    static const char msg[] = "Failed to get crash dump id.";
+    WriteLog(msg, sizeof(msg) - 1);
+    WriteNewline();
+
+    static const char id_msg[] = "Report Id: ";
+    WriteLog(id_msg, sizeof(id_msg) - 1);
+    WriteLog(buf, bytes_read);
+    WriteNewline();
+    return;
+  }
+
+  // Write crash dump id to stderr.
+  static const char msg[] = "Crash dump id: ";
+  WriteLog(msg, sizeof(msg) - 1);
+  WriteLog(buf, my_strlen(buf));
+  WriteNewline();
+
+  // Write crash dump id to crash log as: seconds_since_epoch,crash_id
+  struct kernel_timeval tv;
+  if (!sys_gettimeofday(&tv, NULL)) {
+    uint64_t time = kernel_timeval_to_ms(&tv) / 1000;
+    char time_str[kUint64StringSize];
+    const unsigned time_len = my_uint64_len(time);
+    my_uint64tos(time_str, time, time_len);
+
+    const int kLogOpenFlags = O_CREAT | O_WRONLY | O_APPEND | O_CLOEXEC;
+    int log_fd = sys_open(g_crash_log_path, kLogOpenFlags, 0600);
+    if (log_fd > 0) {
+      sys_write(log_fd, time_str, time_len);
+      sys_write(log_fd, ",", 1);
+      sys_write(log_fd, buf, my_strlen(buf));
+      sys_write(log_fd, "\n", 1);
+      IGNORE_RET(sys_close(log_fd));
+    }
+  }
+}
+
+}  // namespace
+
+char g_crash_log_path[256];
+
+void HandleCrashDump(const BreakpadInfo& info) {
+  int dumpfd;
+  bool keep_fd = false;
+  size_t dump_size;
+  uint8_t* dump_data;
+  google_breakpad::PageAllocator allocator;
+  const char* exe_buf = NULL;
+
+  if (info.fd != -1) {
+    // Dump is provided with an open FD.
+    keep_fd = true;
+    dumpfd = info.fd;
+
+    // The FD is pointing to the end of the file.
+    // Rewind, we'll read the data next.
+    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
+      static const char msg[] = "Cannot upload crash dump: failed to "
+          "reposition minidump FD\n";
+      WriteLog(msg, sizeof(msg) - 1);
+      IGNORE_RET(sys_close(dumpfd));
+      return;
+    }
+    LoadDataFromFD(&allocator, info.fd, false, &dump_data, &dump_size);
+  } else {
+    // Dump is provided with a path.
+    keep_fd = false;
+    LoadDataFromFile(
+        &allocator, info.filename, &dumpfd, &dump_data, &dump_size);
+  }
+
+  // We need to build a MIME block for uploading to the server. Since we are
+  // going to fork and run wget, it needs to be written to a temp file.
+  const int ufd = sys_open("/dev/urandom", O_RDONLY, 0);
+  if (ufd < 0) {
+    static const char msg[] = "Cannot upload crash dump because /dev/urandom"
+                              " is missing\n";
+    WriteLog(msg, sizeof(msg) - 1);
+    return;
+  }
+
+  static const char temp_file_template[] =
+      "/tmp/chromium-upload-XXXXXXXXXXXXXXXX";
+  char temp_file[sizeof(temp_file_template)];
+  int temp_file_fd = -1;
+  if (keep_fd) {
+    temp_file_fd = dumpfd;
+    // Rewind the destination, we are going to overwrite it.
+    if (lseek(dumpfd, 0, SEEK_SET) == -1) {
+      static const char msg[] = "Cannot upload crash dump: failed to "
+          "reposition minidump FD (2)\n";
+      WriteLog(msg, sizeof(msg) - 1);
+      IGNORE_RET(sys_close(dumpfd));
+      return;
+    }
+  } else {
+    if (info.upload) {
+      memcpy(temp_file, temp_file_template, sizeof(temp_file_template));
+
+      for (unsigned i = 0; i < 10; ++i) {
+        uint64_t t;
+        sys_read(ufd, &t, sizeof(t));
+        write_uint64_hex(temp_file + sizeof(temp_file) - (16 + 1), t);
+
+        temp_file_fd = sys_open(temp_file, O_WRONLY | O_CREAT | O_EXCL, 0600);
+        if (temp_file_fd >= 0)
+          break;
+      }
+
+      if (temp_file_fd < 0) {
+        static const char msg[] = "Failed to create temporary file in /tmp: "
+            "cannot upload crash dump\n";
+        WriteLog(msg, sizeof(msg) - 1);
+        IGNORE_RET(sys_close(ufd));
+        return;
+      }
+    } else {
+      temp_file_fd = sys_open(info.filename, O_WRONLY, 0600);
+      if (temp_file_fd < 0) {
+        static const char msg[] = "Failed to save crash dump: failed to open\n";
+        WriteLog(msg, sizeof(msg) - 1);
+        IGNORE_RET(sys_close(ufd));
+        return;
+      }
+    }
+  }
+
+  // The MIME boundary is 28 hyphens, followed by a 64-bit nonce and a NUL.
+  char mime_boundary[28 + 16 + 1];
+  my_memset(mime_boundary, '-', 28);
+  uint64_t boundary_rand;
+  sys_read(ufd, &boundary_rand, sizeof(boundary_rand));
+  write_uint64_hex(mime_boundary + 28, boundary_rand);
+  mime_boundary[28 + 16] = 0;
+  IGNORE_RET(sys_close(ufd));
+
+  // The MIME block looks like this:
+  //   BOUNDARY \r\n
+  //   Content-Disposition: form-data; name="prod" \r\n \r\n
+  //   Chrome_Linux \r\n
+  //   BOUNDARY \r\n
+  //   Content-Disposition: form-data; name="ver" \r\n \r\n
+  //   1.2.3.4 \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="ptime" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="ptype" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="lsb-release" \r\n \r\n
+  //   abcdef \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or one:
+  //   Content-Disposition: form-data; name="oom-size" \r\n \r\n
+  //   1234567890 \r\n
+  //   BOUNDARY \r\n
+  //
+  //   zero or more (up to CrashKeyStorage::num_entries = 64):
+  //   Content-Disposition: form-data; name=crash-key-name \r\n
+  //   crash-key-value \r\n
+  //   BOUNDARY \r\n
+  //
+  //   Content-Disposition: form-data; name="dump"; filename="dump" \r\n
+  //   Content-Type: application/octet-stream \r\n \r\n
+  //   <dump contents>
+  //   \r\n BOUNDARY -- \r\n
+
+  MimeWriter writer(temp_file_fd, mime_boundary);
+  {
+    writer.AddBoundary();
+    if (info.pid > 0) {
+      char pid_value_buf[kUint64StringSize];
+      uint64_t pid_value_len = my_uint64_len(info.pid);
+      my_uint64tos(pid_value_buf, info.pid, pid_value_len);
+      static const char pid_key_name[] = "pid";
+      writer.AddPairData(pid_key_name, sizeof(pid_key_name) - 1,
+                         pid_value_buf, pid_value_len);
+      writer.AddBoundary();
+    }
+    writer.Flush();
+  }
+
+  if (info.process_start_time > 0) {
+    struct kernel_timeval tv;
+    if (!sys_gettimeofday(&tv, NULL)) {
+      uint64_t time = kernel_timeval_to_ms(&tv);
+      if (time > info.process_start_time) {
+        time -= info.process_start_time;
+        char time_str[kUint64StringSize];
+        const unsigned time_len = my_uint64_len(time);
+        my_uint64tos(time_str, time, time_len);
+
+        static const char process_time_msg[] = "ptime";
+        writer.AddPairData(process_time_msg, sizeof(process_time_msg) - 1,
+                           time_str, time_len);
+        writer.AddBoundary();
+        writer.Flush();
+      }
+    }
+  }
+
+  if (info.distro_length) {
+    static const char distro_msg[] = "lsb-release";
+    writer.AddPairString(distro_msg, info.distro);
+    writer.AddBoundary();
+    writer.Flush();
+  }
+
+  if (info.oom_size) {
+    char oom_size_str[kUint64StringSize];
+    const unsigned oom_size_len = my_uint64_len(info.oom_size);
+    my_uint64tos(oom_size_str, info.oom_size, oom_size_len);
+    static const char oom_size_msg[] = "oom-size";
+    writer.AddPairData(oom_size_msg, sizeof(oom_size_msg) - 1,
+                       oom_size_str, oom_size_len);
+    writer.AddBoundary();
+    writer.Flush();
+  }
+
+  if (info.crash_keys) {
+    CrashKeyStorage::Iterator crash_key_iterator(*info.crash_keys);
+    const CrashKeyStorage::Entry* entry;
+    while ((entry = crash_key_iterator.Next())) {
+      writer.AddPairString(entry->key, entry->value);
+      writer.AddBoundary();
+      writer.Flush();
+    }
+  }
+
+  writer.AddFileContents(g_dump_msg, dump_data, dump_size);
+  writer.AddEnd();
+  writer.Flush();
+
+  IGNORE_RET(sys_close(temp_file_fd));
+
+  if (!info.upload)
+    return;
+
+  const pid_t child = sys_fork();
+  if (!child) {
+    // Spawned helper process.
+    //
+    // This code is called both when a browser is crashing (in which case,
+    // nothing really matters any more) and when a renderer/plugin crashes, in
+    // which case we need to continue.
+    //
+    // Since we are a multithreaded app, if we were just to fork(), we might
+    // grab file descriptors which have just been created in another thread and
+    // hold them open for too long.
+    //
+    // Thus, we have to loop and try and close everything.
+    const int fd = sys_open("/proc/self/fd", O_DIRECTORY | O_RDONLY, 0);
+    if (fd < 0) {
+      for (unsigned i = 3; i < 8192; ++i)
+        IGNORE_RET(sys_close(i));
+    } else {
+      google_breakpad::DirectoryReader reader(fd);
+      const char* name;
+      while (reader.GetNextEntry(&name)) {
+        int i;
+        if (my_strtoui(&i, name) && i > 2 && i != fd)
+          IGNORE_RET(sys_close(i));
+        reader.PopEntry();
+      }
+
+      IGNORE_RET(sys_close(fd));
+    }
+
+    IGNORE_RET(sys_setsid());
+
+    // Leave one end of a pipe in the upload process and watch for it getting
+    // closed by the upload process exiting.
+    int fds[2];
+    if (sys_pipe(fds) >= 0) {
+      const pid_t upload_child = sys_fork();
+      if (!upload_child) {
+        // Upload process.
+        IGNORE_RET(sys_close(fds[0]));
+        IGNORE_RET(sys_dup2(fds[1], 3));
+        ExecUploadProcessOrTerminate(info, temp_file, mime_boundary, exe_buf,
+                                     &allocator);
+      }
+
+      // Helper process.
+      if (upload_child > 0) {
+        IGNORE_RET(sys_close(fds[1]));
+
+        const size_t kCrashIdLength = 36;
+        char id_buf[kCrashIdLength + 1];
+        size_t bytes_read =
+            WaitForCrashReportUploadProcess(fds[0], kCrashIdLength, id_buf);
+        HandleCrashReportId(id_buf, bytes_read, kCrashIdLength);
+
+        if (sys_waitpid(upload_child, NULL, WNOHANG) == 0) {
+          // Upload process is still around, kill it.
+          sys_kill(upload_child, SIGKILL);
+        }
+      }
+    }
+
+    // Helper process.
+    IGNORE_RET(sys_unlink(info.filename));
+    IGNORE_RET(sys_unlink(temp_file));
+    sys__exit(0);
+  }
+
+  // Main browser process.
+  if (child <= 0)
+    return;
+  (void) HANDLE_EINTR(sys_waitpid(child, NULL, 0));
+}
+
+size_t WriteLog(const char* buf, size_t nbytes) {
+  return sys_write(2, buf, nbytes);
+}
+
+size_t WriteNewline() {
+  return WriteLog("\n", 1);
+}
+
+}  // namespace crash_reporter
added in remote
  their  100644 a0ae98704a204fb6d88ee9ee7eb630d5e5d75d80 electron/common/crash_reporter/linux/crash_dump_handler.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Copyright (c) 2013 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
+
+#include <stddef.h>
+#include <stdint.h>
+#include <sys/types.h>
+
+#include "base/macros.h"
+#include "vendor/breakpad/src/common/simple_string_dictionary.h"
+
+namespace crash_reporter {
+
+typedef google_breakpad::NonAllocatingMap<256, 256, 64> CrashKeyStorage;
+
+// BreakpadInfo describes a crash report.
+// The minidump information can either be contained in a file descriptor (fd) or
+// in a file (whose path is in filename).
+struct BreakpadInfo {
+  int fd;                          // File descriptor to the Breakpad dump data.
+  const char* filename;            // Path to the Breakpad dump data.
+  const char* distro;              // Linux distro string.
+  unsigned distro_length;          // Length of |distro|.
+  bool upload;                     // Whether to upload or save crash dump.
+  uint64_t process_start_time;     // Uptime of the crashing process.
+  size_t oom_size;                 // Amount of memory requested if OOM.
+  uint64_t pid;                    // PID where applicable.
+  const char* upload_url;          // URL to upload the minidump.
+  CrashKeyStorage* crash_keys;
+};
+
+void HandleCrashDump(const BreakpadInfo& info);
+
+size_t WriteLog(const char* buf, size_t nbytes);
+size_t WriteNewline();
+
+// Global variable storing the path of upload log.
+extern char g_crash_log_path[256];
+
+}  // namespace crash_reporter
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_LINUX_CRASH_DUMP_HANDLER_H_
added in remote
  their  100644 c8bc9c70f4055b1774a06e91f261f157a5763a47 electron/common/crash_reporter/win/crash_service.cc
@@ -0,0 +1,526 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/win/crash_service.h"
+
+#include <windows.h>
+
+#include <sddl.h>
+#include <fstream>  // NOLINT
+#include <map>
+
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+#include "base/time/time.h"
+#include "base/win/windows_version.h"
+#include "vendor/breakpad/src/client/windows/crash_generation/client_info.h"
+#include "vendor/breakpad/src/client/windows/crash_generation/crash_generation_server.h"
+#include "vendor/breakpad/src/client/windows/sender/crash_report_sender.h"
+
+namespace breakpad {
+
+namespace {
+
+const wchar_t kWaitEventFormat[] = L"$1CrashServiceWaitEvent";
+const wchar_t kClassNameFormat[] = L"$1CrashServiceWindow";
+
+const wchar_t kTestPipeName[] = L"\\\\.\\pipe\\ChromeCrashServices";
+
+const wchar_t kGoogleReportURL[] = L"https://clients2.google.com/cr/report";
+const wchar_t kCheckPointFile[] = L"crash_checkpoint.txt";
+
+typedef std::map<std::wstring, std::wstring> CrashMap;
+
+bool CustomInfoToMap(const google_breakpad::ClientInfo* client_info,
+                     const std::wstring& reporter_tag, CrashMap* map) {
+  google_breakpad::CustomClientInfo info = client_info->GetCustomInfo();
+
+  for (uintptr_t i = 0; i < info.count; ++i) {
+    (*map)[info.entries[i].name] = info.entries[i].value;
+  }
+
+  (*map)[L"rept"] = reporter_tag;
+
+  return !map->empty();
+}
+
+bool WriteCustomInfoToFile(const std::wstring& dump_path, const CrashMap& map) {
+  std::wstring file_path(dump_path);
+  size_t last_dot = file_path.rfind(L'.');
+  if (last_dot == std::wstring::npos)
+    return false;
+  file_path.resize(last_dot);
+  file_path += L".txt";
+
+  std::wofstream file(file_path.c_str(),
+      std::ios_base::out | std::ios_base::app | std::ios::binary);
+  if (!file.is_open())
+    return false;
+
+  CrashMap::const_iterator pos;
+  for (pos = map.begin(); pos != map.end(); ++pos) {
+    std::wstring line = pos->first;
+    line += L':';
+    line += pos->second;
+    line += L'\n';
+    file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
+  }
+  return true;
+}
+
+bool WriteReportIDToFile(const std::wstring& dump_path,
+                         const std::wstring& report_id) {
+  std::wstring file_path(dump_path);
+  size_t last_slash = file_path.rfind(L'\\');
+  if (last_slash == std::wstring::npos)
+    return false;
+  file_path.resize(last_slash);
+  file_path += L"\\uploads.log";
+
+  std::wofstream file(file_path.c_str(),
+      std::ios_base::out | std::ios_base::app | std::ios::binary);
+  if (!file.is_open())
+    return false;
+
+  int64_t seconds_since_epoch =
+      (base::Time::Now() - base::Time::UnixEpoch()).InSeconds();
+  std::wstring line = base::Int64ToString16(seconds_since_epoch);
+  line += L',';
+  line += report_id;
+  line += L'\n';
+  file.write(line.c_str(), static_cast<std::streamsize>(line.length()));
+  return true;
+}
+
+// The window procedure task is to handle when a) the user logs off.
+// b) the system shuts down or c) when the user closes the window.
+LRESULT __stdcall CrashSvcWndProc(HWND hwnd, UINT message,
+                                  WPARAM wparam, LPARAM lparam) {
+  switch (message) {
+    case WM_CLOSE:
+    case WM_ENDSESSION:
+    case WM_DESTROY:
+      PostQuitMessage(0);
+      break;
+    default:
+      return DefWindowProc(hwnd, message, wparam, lparam);
+  }
+  return 0;
+}
+
+// This is the main and only application window.
+HWND g_top_window = NULL;
+
+bool CreateTopWindow(HINSTANCE instance,
+                     const base::string16& application_name,
+                     bool visible) {
+  base::string16 class_name = base::ReplaceStringPlaceholders(
+      kClassNameFormat, application_name, NULL);
+
+  WNDCLASSEXW wcx = {0};
+  wcx.cbSize = sizeof(wcx);
+  wcx.style = CS_HREDRAW | CS_VREDRAW;
+  wcx.lpfnWndProc = CrashSvcWndProc;
+  wcx.hInstance = instance;
+  wcx.lpszClassName = class_name.c_str();
+  ATOM atom = ::RegisterClassExW(&wcx);
+  DWORD style = visible ? WS_POPUPWINDOW | WS_VISIBLE : WS_OVERLAPPED;
+
+  // The window size is zero but being a popup window still shows in the
+  // task bar and can be closed using the system menu or using task manager.
+  HWND window = CreateWindowExW(0, wcx.lpszClassName, L"crash service", style,
+                                CW_USEDEFAULT, CW_USEDEFAULT, 0, 0,
+                                NULL, NULL, instance, NULL);
+  if (!window)
+    return false;
+
+  ::UpdateWindow(window);
+  VLOG(1) << "window handle is " << window;
+  g_top_window = window;
+  return true;
+}
+
+// Simple helper class to keep the process alive until the current request
+// finishes.
+class ProcessingLock {
+ public:
+  ProcessingLock() {
+    ::InterlockedIncrement(&op_count_);
+  }
+  ~ProcessingLock() {
+    ::InterlockedDecrement(&op_count_);
+  }
+  static bool IsWorking() {
+    return (op_count_ != 0);
+  }
+ private:
+  static volatile LONG op_count_;
+};
+
+volatile LONG ProcessingLock::op_count_ = 0;
+
+// This structure contains the information that the worker thread needs to
+// send a crash dump to the server.
+struct DumpJobInfo {
+  DWORD pid;
+  CrashService* self;
+  CrashMap map;
+  std::wstring dump_path;
+
+  DumpJobInfo(DWORD process_id, CrashService* service,
+              const CrashMap& crash_map, const std::wstring& path)
+      : pid(process_id), self(service), map(crash_map), dump_path(path) {
+  }
+};
+
+}  // namespace
+
+// Command line switches:
+const char CrashService::kMaxReports[]        = "max-reports";
+const char CrashService::kNoWindow[]          = "no-window";
+const char CrashService::kReporterTag[]       = "reporter";
+const char CrashService::kDumpsDir[]          = "dumps-dir";
+const char CrashService::kPipeName[]          = "pipe-name";
+const char CrashService::kReporterURL[]       = "reporter-url";
+
+CrashService::CrashService()
+    : sender_(NULL),
+      dumper_(NULL),
+      requests_handled_(0),
+      requests_sent_(0),
+      clients_connected_(0),
+      clients_terminated_(0) {
+}
+
+CrashService::~CrashService() {
+  base::AutoLock lock(sending_);
+  delete dumper_;
+  delete sender_;
+}
+
+bool CrashService::Initialize(const base::string16& application_name,
+                              const base::FilePath& operating_dir,
+                              const base::FilePath& dumps_path) {
+  using google_breakpad::CrashReportSender;
+  using google_breakpad::CrashGenerationServer;
+
+  std::wstring pipe_name = kTestPipeName;
+  int max_reports = -1;
+
+  // The checkpoint file allows CrashReportSender to enforce the maximum
+  // reports per day quota. Does not seem to serve any other purpose.
+  base::FilePath checkpoint_path = operating_dir.Append(kCheckPointFile);
+
+  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
+
+  base::FilePath dumps_path_to_use = dumps_path;
+
+  if (cmd_line.HasSwitch(kDumpsDir)) {
+    dumps_path_to_use =
+        base::FilePath(cmd_line.GetSwitchValueNative(kDumpsDir));
+  }
+
+  // We can override the send reports quota with a command line switch.
+  if (cmd_line.HasSwitch(kMaxReports))
+    max_reports = _wtoi(cmd_line.GetSwitchValueNative(kMaxReports).c_str());
+
+  // Allow the global pipe name to be overridden for better testability.
+  if (cmd_line.HasSwitch(kPipeName))
+    pipe_name = cmd_line.GetSwitchValueNative(kPipeName);
+
+  if (max_reports > 0) {
+    // Create the http sender object.
+    sender_ = new CrashReportSender(checkpoint_path.value());
+    sender_->set_max_reports_per_day(max_reports);
+  }
+
+  SECURITY_ATTRIBUTES security_attributes = {0};
+  SECURITY_ATTRIBUTES* security_attributes_actual = NULL;
+
+  if (base::win::GetVersion() >= base::win::VERSION_VISTA) {
+    SECURITY_DESCRIPTOR* security_descriptor =
+        reinterpret_cast<SECURITY_DESCRIPTOR*>(
+            GetSecurityDescriptorForLowIntegrity());
+    DCHECK(security_descriptor != NULL);
+
+    security_attributes.nLength = sizeof(security_attributes);
+    security_attributes.lpSecurityDescriptor = security_descriptor;
+    security_attributes.bInheritHandle = FALSE;
+
+    security_attributes_actual = &security_attributes;
+  }
+
+  // Create the OOP crash generator object.
+  dumper_ = new CrashGenerationServer(pipe_name, security_attributes_actual,
+                                      &CrashService::OnClientConnected, this,
+                                      &CrashService::OnClientDumpRequest, this,
+                                      &CrashService::OnClientExited, this,
+                                      NULL, NULL,
+                                      true, &dumps_path_to_use.value());
+
+  if (!dumper_) {
+    LOG(ERROR) << "could not create dumper";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  if (!CreateTopWindow(::GetModuleHandleW(NULL),
+                       application_name,
+                       !cmd_line.HasSwitch(kNoWindow))) {
+    LOG(ERROR) << "could not create window";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  reporter_tag_ = L"crash svc";
+  if (cmd_line.HasSwitch(kReporterTag))
+    reporter_tag_ = cmd_line.GetSwitchValueNative(kReporterTag);
+
+  reporter_url_ = kGoogleReportURL;
+  if (cmd_line.HasSwitch(kReporterURL))
+    reporter_url_ = cmd_line.GetSwitchValueNative(kReporterURL);
+
+  // Log basic information.
+  VLOG(1) << "pipe name is " << pipe_name
+          << "\ndumps at " << dumps_path_to_use.value();
+
+  if (sender_) {
+    VLOG(1) << "checkpoint is " << checkpoint_path.value()
+            << "\nserver is " << reporter_url_
+            << "\nmaximum " << sender_->max_reports_per_day() << " reports/day"
+            << "\nreporter is " << reporter_tag_;
+  }
+  // Start servicing clients.
+  if (!dumper_->Start()) {
+    LOG(ERROR) << "could not start dumper";
+    if (security_attributes.lpSecurityDescriptor)
+      LocalFree(security_attributes.lpSecurityDescriptor);
+    return false;
+  }
+
+  if (security_attributes.lpSecurityDescriptor)
+    LocalFree(security_attributes.lpSecurityDescriptor);
+
+  // Create or open an event to signal the browser process that the crash
+  // service is initialized.
+  base::string16 wait_name = base::ReplaceStringPlaceholders(
+      kWaitEventFormat, application_name, NULL);
+  HANDLE wait_event = ::CreateEventW(NULL, TRUE, TRUE, wait_name.c_str());
+  ::SetEvent(wait_event);
+
+  return true;
+}
+
+void CrashService::OnClientConnected(void* context,
+    const google_breakpad::ClientInfo* client_info) {
+  ProcessingLock lock;
+  VLOG(1) << "client start. pid = " << client_info->pid();
+  CrashService* self = static_cast<CrashService*>(context);
+  ::InterlockedIncrement(&self->clients_connected_);
+}
+
+void CrashService::OnClientExited(void* context,
+    const google_breakpad::ClientInfo* client_info) {
+  ProcessingLock lock;
+  VLOG(1) << "client end. pid = " << client_info->pid();
+  CrashService* self = static_cast<CrashService*>(context);
+  ::InterlockedIncrement(&self->clients_terminated_);
+
+  if (!self->sender_)
+    return;
+
+  // When we are instructed to send reports we need to exit if there are
+  // no more clients to service. The next client that runs will start us.
+  // Only chrome.exe starts crash_service with a non-zero max_reports.
+  if (self->clients_connected_ > self->clients_terminated_)
+    return;
+  if (self->sender_->max_reports_per_day() > 0) {
+    // Wait for the other thread to send crashes, if applicable. The sender
+    // thread takes the sending_ lock, so the sleep is just to give it a
+    // chance to start.
+    ::Sleep(1000);
+    base::AutoLock lock(self->sending_);
+    // Some people can restart chrome very fast, check again if we have
+    // a new client before exiting for real.
+    if (self->clients_connected_ == self->clients_terminated_) {
+      VLOG(1) << "zero clients. exiting";
+      ::PostMessage(g_top_window, WM_CLOSE, 0, 0);
+    }
+  }
+}
+
+void CrashService::OnClientDumpRequest(void* context,
+    const google_breakpad::ClientInfo* client_info,
+    const std::wstring* file_path) {
+  ProcessingLock lock;
+
+  if (!file_path) {
+    LOG(ERROR) << "dump with no file path";
+    return;
+  }
+  if (!client_info) {
+    LOG(ERROR) << "dump with no client info";
+    return;
+  }
+
+  CrashService* self = static_cast<CrashService*>(context);
+  if (!self) {
+    LOG(ERROR) << "dump with no context";
+    return;
+  }
+
+  CrashMap map;
+  CustomInfoToMap(client_info, self->reporter_tag_, &map);
+
+  // Move dump file to the directory under client breakpad dump location.
+  base::FilePath dump_location = base::FilePath(*file_path);
+  CrashMap::const_iterator it = map.find(L"breakpad-dump-location");
+  if (it != map.end()) {
+    base::FilePath alternate_dump_location = base::FilePath(it->second);
+    base::CreateDirectoryW(alternate_dump_location);
+    alternate_dump_location = alternate_dump_location.Append(
+        dump_location.BaseName());
+    base::Move(dump_location, alternate_dump_location);
+    dump_location = alternate_dump_location;
+  }
+
+  DWORD pid = client_info->pid();
+  VLOG(1) << "dump for pid = " << pid << " is " << dump_location.value();
+
+  if (!WriteCustomInfoToFile(dump_location.value(), map)) {
+    LOG(ERROR) << "could not write custom info file";
+  }
+
+  if (!self->sender_)
+    return;
+
+  // Send the crash dump using a worker thread. This operation has retry
+  // logic in case there is no internet connection at the time.
+  DumpJobInfo* dump_job = new DumpJobInfo(pid, self, map,
+                                          dump_location.value());
+  if (!::QueueUserWorkItem(&CrashService::AsyncSendDump,
+                           dump_job, WT_EXECUTELONGFUNCTION)) {
+    LOG(ERROR) << "could not queue job";
+  }
+}
+
+// We are going to try sending the report several times. If we can't send,
+// we sleep from one minute to several hours depending on the retry round.
+DWORD CrashService::AsyncSendDump(void* context) {
+  if (!context)
+    return 0;
+
+  DumpJobInfo* info = static_cast<DumpJobInfo*>(context);
+
+  std::wstring report_id = L"<unsent>";
+
+  const DWORD kOneMinute = 60*1000;
+  const DWORD kOneHour = 60*kOneMinute;
+
+  const DWORD kSleepSchedule[] = {
+      24*kOneHour,
+      8*kOneHour,
+      4*kOneHour,
+      kOneHour,
+      15*kOneMinute,
+      0};
+
+  int retry_round = arraysize(kSleepSchedule) - 1;
+
+  do {
+    ::Sleep(kSleepSchedule[retry_round]);
+    {
+      // Take the server lock while sending. This also prevent early
+      // termination of the service object.
+      base::AutoLock lock(info->self->sending_);
+      VLOG(1) << "trying to send report for pid = " << info->pid;
+      google_breakpad::ReportResult send_result
+          = info->self->sender_->SendCrashReport(info->self->reporter_url_,
+                                                 info->map,
+                                                 info->dump_path,
+                                                 &report_id);
+      switch (send_result) {
+        case google_breakpad::RESULT_FAILED:
+          report_id = L"<network issue>";
+          break;
+        case google_breakpad::RESULT_REJECTED:
+          report_id = L"<rejected>";
+          ++info->self->requests_handled_;
+          retry_round = 0;
+          break;
+        case google_breakpad::RESULT_SUCCEEDED:
+          ++info->self->requests_sent_;
+          ++info->self->requests_handled_;
+          retry_round = 0;
+          WriteReportIDToFile(info->dump_path, report_id);
+          break;
+        case google_breakpad::RESULT_THROTTLED:
+          report_id = L"<throttled>";
+          break;
+        default:
+          report_id = L"<unknown>";
+          break;
+      }
+    }
+
+    VLOG(1) << "dump for pid =" << info->pid << " crash2 id =" << report_id;
+    --retry_round;
+  } while (retry_round >= 0);
+
+  if (!::DeleteFileW(info->dump_path.c_str()))
+    LOG(WARNING) << "could not delete " << info->dump_path;
+
+  delete info;
+  return 0;
+}
+
+int CrashService::ProcessingLoop() {
+  MSG msg;
+  while (GetMessage(&msg, NULL, 0, 0)) {
+    TranslateMessage(&msg);
+    DispatchMessage(&msg);
+  }
+
+  VLOG(1) << "session ending..";
+  while (ProcessingLock::IsWorking()) {
+    ::Sleep(50);
+  }
+
+  VLOG(1) << "clients connected :" << clients_connected_
+          << "\nclients terminated :" << clients_terminated_
+          << "\ndumps serviced :" << requests_handled_
+          << "\ndumps reported :" << requests_sent_;
+
+  return static_cast<int>(msg.wParam);
+}
+
+PSECURITY_DESCRIPTOR CrashService::GetSecurityDescriptorForLowIntegrity() {
+  // Build the SDDL string for the label.
+  std::wstring sddl = L"S:(ML;;NW;;;S-1-16-4096)";
+
+  DWORD error = ERROR_SUCCESS;
+  PSECURITY_DESCRIPTOR sec_desc = NULL;
+
+  PACL sacl = NULL;
+  BOOL sacl_present = FALSE;
+  BOOL sacl_defaulted = FALSE;
+
+  if (::ConvertStringSecurityDescriptorToSecurityDescriptorW(sddl.c_str(),
+                                                             SDDL_REVISION,
+                                                             &sec_desc, NULL)) {
+    if (::GetSecurityDescriptorSacl(sec_desc, &sacl_present, &sacl,
+                                    &sacl_defaulted)) {
+      return sec_desc;
+    }
+  }
+
+  return NULL;
+}
+
+}  // namespace breakpad
added in remote
  their  100644 10fde6374b1b58bc4789f5342fbacce75e54fadf electron/common/crash_reporter/win/crash_service.h
@@ -0,0 +1,132 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
+
+#include <string>
+
+#include "base/macros.h"
+#include "base/files/file_path.h"
+#include "base/synchronization/lock.h"
+
+namespace google_breakpad {
+
+class CrashReportSender;
+class CrashGenerationServer;
+class ClientInfo;
+
+}
+
+namespace breakpad {
+
+// This class implements an out-of-process crash server. It uses breakpad's
+// CrashGenerationServer and CrashReportSender to generate and then send the
+// crash dumps. Internally, it uses OS specific pipe to allow applications to
+// register for crash dumps and later on when a registered application crashes
+// it will signal an event that causes this code to wake up and perform a
+// crash dump on the signaling process. The dump is then stored on disk and
+// possibly sent to the crash2 servers.
+class CrashService {
+ public:
+  CrashService();
+  ~CrashService();
+
+  // Starts servicing crash dumps. Returns false if it failed. Do not use
+  // other members in that case. |operating_dir| is where the CrashService
+  // should store breakpad's checkpoint file. |dumps_path| is the directory
+  // where the crash dumps should be stored.
+  bool Initialize(const base::string16& application_name,
+                  const base::FilePath& operating_dir,
+                  const base::FilePath& dumps_path);
+
+  // Command line switches:
+  //
+  // --max-reports=<number>
+  // Allows to override the maximum number for reports per day. Normally
+  // the crash dumps are never sent so if you want to send any you must
+  // specify a positive number here.
+  static const char kMaxReports[];
+  // --no-window
+  // Does not create a visible window on the desktop. The window does not have
+  // any other functionality other than allowing the crash service to be
+  // gracefully closed.
+  static const char kNoWindow[];
+  // --reporter=<string>
+  // Allows to specify a custom string that appears on the detail crash report
+  // page in the crash server. This should be a 25 chars or less string.
+  // The default tag if not specified is 'crash svc'.
+  static const char kReporterTag[];
+  // --dumps-dir=<directory-path>
+  // Override the directory to which crash dump files will be written.
+  static const char kDumpsDir[];
+  // --pipe-name=<string>
+  // Override the name of the Windows named pipe on which we will
+  // listen for crash dump request messages.
+  static const char kPipeName[];
+  // --reporter-url=<string>
+  // Override the URL to which crash reports will be sent to.
+  static const char kReporterURL[];
+
+  // Returns number of crash dumps handled.
+  int requests_handled() const {
+    return requests_handled_;
+  }
+  // Returns number of crash clients registered.
+  int clients_connected() const {
+    return clients_connected_;
+  }
+  // Returns number of crash clients terminated.
+  int clients_terminated() const {
+    return clients_terminated_;
+  }
+
+  // Starts the processing loop. This function does not return unless the
+  // user is logging off or the user closes the crash service window. The
+  // return value is a good number to pass in ExitProcess().
+  int ProcessingLoop();
+
+ private:
+  static void OnClientConnected(void* context,
+                                const google_breakpad::ClientInfo* client_info);
+
+  static void OnClientDumpRequest(
+      void* context,
+      const google_breakpad::ClientInfo* client_info,
+      const std::wstring* file_path);
+
+  static void OnClientExited(void* context,
+                             const google_breakpad::ClientInfo* client_info);
+
+  // This routine sends the crash dump to the server. It takes the sending_
+  // lock when it is performing the send.
+  static DWORD __stdcall AsyncSendDump(void* context);
+
+  // Returns the security descriptor which access to low integrity processes
+  // The caller is supposed to free the security descriptor by calling
+  // LocalFree.
+  PSECURITY_DESCRIPTOR GetSecurityDescriptorForLowIntegrity();
+
+  google_breakpad::CrashGenerationServer* dumper_;
+  google_breakpad::CrashReportSender* sender_;
+
+  // the extra tag sent to the server with each dump.
+  std::wstring reporter_tag_;
+
+  // receiver URL of crash reports.
+  std::wstring reporter_url_;
+
+  // clients serviced statistics:
+  int requests_handled_;
+  int requests_sent_;
+  volatile LONG clients_connected_;
+  volatile LONG clients_terminated_;
+  base::Lock sending_;
+
+  DISALLOW_COPY_AND_ASSIGN(CrashService);
+};
+
+}  // namespace breakpad
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_H_
added in remote
  their  100644 014c230788b605041c1c63821a05bff641071935 electron/common/crash_reporter/win/crash_service_main.cc
@@ -0,0 +1,93 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/crash_reporter/win/crash_service_main.h"
+
+#include "electron/common/crash_reporter/win/crash_service.h"
+#include "base/at_exit.h"
+#include "base/command_line.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+
+namespace crash_service {
+
+namespace {
+
+const char kApplicationName[] = "application-name";
+
+const wchar_t kPipeNameFormat[] = L"\\\\.\\pipe\\$1 Crash Service";
+const wchar_t kStandardLogFile[] = L"operation_log.txt";
+
+bool GetCrashServiceDirectory(const std::wstring& application_name,
+                              base::FilePath* dir) {
+  base::FilePath temp_dir;
+  if (!base::GetTempDir(&temp_dir))
+    return false;
+  temp_dir = temp_dir.Append(application_name + L" Crashes");
+  if (!base::PathExists(temp_dir)) {
+    if (!base::CreateDirectory(temp_dir))
+      return false;
+  }
+  *dir = temp_dir;
+  return true;
+}
+
+}  // namespace.
+
+int Main(const wchar_t* cmd) {
+  // Initialize all Chromium things.
+  base::AtExitManager exit_manager;
+  base::CommandLine::Init(0, NULL);
+  base::CommandLine& cmd_line = *base::CommandLine::ForCurrentProcess();
+
+  // Use the application's name as pipe name and output directory.
+  if (!cmd_line.HasSwitch(kApplicationName)) {
+    LOG(ERROR) << "Application's name must be specified with --"
+               << kApplicationName;
+    return 1;
+  }
+  std::wstring application_name = cmd_line.GetSwitchValueNative(
+      kApplicationName);
+
+  // We use/create a directory under the user's temp folder, for logging.
+  base::FilePath operating_dir;
+  GetCrashServiceDirectory(application_name, &operating_dir);
+  base::FilePath log_file = operating_dir.Append(kStandardLogFile);
+
+  // Logging to stderr (to help with debugging failures on the
+  // buildbots) and to a file.
+  logging::LoggingSettings settings;
+  settings.logging_dest = logging::LOG_TO_ALL;
+  settings.log_file = log_file.value().c_str();
+  logging::InitLogging(settings);
+  // Logging with pid, tid and timestamp.
+  logging::SetLogItems(true, true, true, false);
+
+  VLOG(1) << "Session start. cmdline is [" << cmd << "]";
+
+  // Setting the crash reporter.
+  base::string16 pipe_name = base::ReplaceStringPlaceholders(kPipeNameFormat,
+                                                 application_name,
+                                                 NULL);
+  cmd_line.AppendSwitch("no-window");
+  cmd_line.AppendSwitchASCII("max-reports", "128");
+  cmd_line.AppendSwitchASCII("reporter", ELECTRON_PROJECT_NAME "-crash-service");
+  cmd_line.AppendSwitchNative("pipe-name", pipe_name);
+
+  breakpad::CrashService crash_service;
+  if (!crash_service.Initialize(application_name, operating_dir,
+                                operating_dir))
+    return 2;
+
+  VLOG(1) << "Ready to process crash requests";
+
+  // Enter the message loop.
+  int retv = crash_service.ProcessingLoop();
+  // Time to exit.
+  VLOG(1) << "Session end. return code is " << retv;
+  return retv;
+}
+
+}  // namespace crash_service
added in remote
  their  100644 53aab9ecdd0d7003e78f4168a0a1d5ac23e68941 electron/common/crash_reporter/win/crash_service_main.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
+#define ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
+
+namespace crash_service {
+
+// Program entry, should be called by main();
+int Main(const wchar_t* cmd_line);
+
+}  // namespace crash_service
+
+#endif  // ELECTRON_COMMON_CRASH_REPORTER_WIN_CRASH_SERVICE_MAIN_H_
added in remote
  their  100644 7888c249217dc32e90e0a8ebdf3e20664c406ed3 electron/common/draggable_region.cc
@@ -0,0 +1,13 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/draggable_region.h"
+
+namespace electron {
+
+DraggableRegion::DraggableRegion()
+    : draggable(false) {
+}
+
+}  // namespace electron
added in remote
  their  100644 5ef7ef60c38392701ef0e5850190ada56d3c283e electron/common/draggable_region.h
@@ -0,0 +1,21 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_DRAGGABLE_REGION_H_
+#define ELECTRON_COMMON_DRAGGABLE_REGION_H_
+
+#include "ui/gfx/geometry/rect.h"
+
+namespace electron {
+
+struct DraggableRegion {
+  bool draggable;
+  gfx::Rect bounds;
+
+  DraggableRegion();
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_DRAGGABLE_REGION_H_
added in remote
  their  100644 c4039a67c8ab00f25c3a94dce4733266d5101a54 electron/common/electron_command_line.cc
@@ -0,0 +1,31 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/electron_command_line.h"
+
+#include "base/command_line.h"
+#include "node/deps/uv/include/uv.h"
+
+namespace electron {
+
+// static
+std::vector<std::string> ElectronCommandLine::argv_;
+
+// static
+void ElectronCommandLine::Init(int argc, const char* const* argv) {
+  // Hack around with the argv pointer. Used for process.title = "blah"
+  char** new_argv = uv_setup_args(argc, const_cast<char**>(argv));
+  for (int i = 0; i < argc; ++i) {
+    argv_.push_back(new_argv[i]);
+  }
+}
+
+#if defined(OS_LINUX)
+// static
+void ElectronCommandLine::InitializeFromCommandLine() {
+  argv_ = base::CommandLine::ForCurrentProcess()->argv();
+}
+#endif
+
+}  // namespace electron
added in remote
  their  100644 157dfc7f57838f076e0e281e51b1c2158611bb6a electron/common/electron_command_line.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
+#define ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
+
+#include <string>
+#include <vector>
+
+#include "base/macros.h"
+#include "build/build_config.h"
+
+namespace electron {
+
+// Singleton to remember the original "argc" and "argv".
+class ElectronCommandLine {
+ public:
+  static void Init(int argc, const char* const* argv);
+  static std::vector<std::string> argv() { return argv_; }
+
+#if defined(OS_LINUX)
+  // On Linux the command line has to be read from base::CommandLine since
+  // it is using zygote.
+  static void InitializeFromCommandLine();
+#endif
+
+ private:
+  static std::vector<std::string> argv_;
+
+  DISALLOW_IMPLICIT_CONSTRUCTORS(ElectronCommandLine);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ELECTRON_COMMAND_LINE_H_
added in remote
  their  100644 d32ed92c9e2b7a5636ed2b538720091cff1e414e electron/common/electron_constants.cc
@@ -0,0 +1,11 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/electron_constants.h"
+
+namespace electron {
+
+const char* kCORSHeader = "Access-Control-Allow-Origin: *";
+
+}  // namespace electron
added in remote
  their  100644 277ef6f41e81aba66843f77317c1974817202517 electron/common/electron_constants.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
+#define ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
+
+namespace electron {
+
+// Header to ignore CORS.
+extern const char* kCORSHeader;
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ELECTRON_CONSTANTS_H_
added in remote
  their  100644 adb282d5dfd420fe6c037e7b7e1a25caa5cd7e55 electron/common/electron_version.h
@@ -0,0 +1,43 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_VERSION_H
+#define ELECTRON_VERSION_H
+
+#define ELECTRON_MAJOR_VERSION 0
+#define ELECTRON_MINOR_VERSION 37
+#define ELECTRON_PATCH_VERSION 3
+
+#define ELECTRON_VERSION_IS_RELEASE 1
+
+#ifndef ELECTRON_TAG
+# define ELECTRON_TAG ""
+#endif
+
+#ifndef ELECTRON_STRINGIFY
+#define ELECTRON_STRINGIFY(n) ELECTRON_STRINGIFY_HELPER(n)
+#define ELECTRON_STRINGIFY_HELPER(n) #n
+#endif
+
+#if ELECTRON_VERSION_IS_RELEASE
+# define ELECTRON_VERSION_STRING  ELECTRON_STRINGIFY(ELECTRON_MAJOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_MINOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_PATCH_VERSION)     \
+                              ELECTRON_TAG
+#else
+# define ELECTRON_VERSION_STRING  ELECTRON_STRINGIFY(ELECTRON_MAJOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_MINOR_VERSION) "." \
+                              ELECTRON_STRINGIFY(ELECTRON_PATCH_VERSION)     \
+                              ELECTRON_TAG "-pre"
+#endif
+
+#define ELECTRON_VERSION "v" ELECTRON_VERSION_STRING
+
+
+#define ELECTRON_VERSION_AT_LEAST(major, minor, patch) \
+  (( (major) < ELECTRON_MAJOR_VERSION) \
+  || ((major) == ELECTRON_MAJOR_VERSION && (minor) < ELECTRON_MINOR_VERSION) \
+  || ((major) == ELECTRON_MAJOR_VERSION && (minor) == ELECTRON_MINOR_VERSION && (patch) <= ELECTRON_PATCH_VERSION))
+
+#endif /* ELECTRON_VERSION_H */
added in remote
  their  100644 15b242c336468a263da8a390300e9a36bc6dfee6 electron/common/google_api_key.h
@@ -0,0 +1,12 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_GOOGLE_API_KEY_H_
+#define ELECTRON_COMMON_GOOGLE_API_KEY_H_
+
+#ifndef GOOGLEAPIS_API_KEY
+#define GOOGLEAPIS_API_KEY "AIzaSyAQfxPJiounkhOjODEO5ZieffeBv6yft2Q"
+#endif
+
+#endif  // ELECTRON_COMMON_GOOGLE_API_KEY_H_
added in remote
  their  100644 33456dd68c15d84ef2b1444161f026bd4bc93fac electron/common/id_weak_map.cc
@@ -0,0 +1,94 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/id_weak_map.h"
+
+#include <utility>
+
+#include "native_mate/converter.h"
+
+namespace electron {
+
+namespace {
+
+struct ObjectKey {
+  ObjectKey(int id, IDWeakMap* map) : id(id), map(map) {}
+  int id;
+  IDWeakMap* map;
+};
+
+void OnObjectGC(const v8::WeakCallbackInfo<ObjectKey>& data) {
+  ObjectKey* key = data.GetParameter();
+  key->map->Remove(key->id);
+  delete key;
+}
+
+}  // namespace
+
+IDWeakMap::IDWeakMap() : next_id_(0) {
+}
+
+IDWeakMap::~IDWeakMap() {
+}
+
+void IDWeakMap::Set(v8::Isolate* isolate,
+                    int32_t id,
+                    v8::Local<v8::Object> object) {
+  auto global = make_linked_ptr(new v8::Global<v8::Object>(isolate, object));
+  ObjectKey* key = new ObjectKey(id, this);
+  global->SetWeak(key, OnObjectGC, v8::WeakCallbackType::kParameter);
+  map_[id] = global;
+}
+
+int32_t IDWeakMap::Add(v8::Isolate* isolate, v8::Local<v8::Object> object) {
+  int32_t id = GetNextID();
+  Set(isolate, id, object);
+  return id;
+}
+
+v8::MaybeLocal<v8::Object> IDWeakMap::Get(v8::Isolate* isolate, int32_t id) {
+  auto iter = map_.find(id);
+  if (iter == map_.end())
+    return v8::MaybeLocal<v8::Object>();
+  else
+    return v8::Local<v8::Object>::New(isolate, *iter->second);
+}
+
+bool IDWeakMap::Has(int32_t id) const {
+  return map_.find(id) != map_.end();
+}
+
+std::vector<int32_t> IDWeakMap::Keys() const {
+  std::vector<int32_t> keys;
+  keys.reserve(map_.size());
+  for (const auto& iter : map_)
+    keys.emplace_back(iter.first);
+  return keys;
+}
+
+std::vector<v8::Local<v8::Object>> IDWeakMap::Values(v8::Isolate* isolate) {
+  std::vector<v8::Local<v8::Object>> keys;
+  keys.reserve(map_.size());
+  for (const auto& iter : map_)
+    keys.emplace_back(v8::Local<v8::Object>::New(isolate, *iter.second));
+  return keys;
+}
+
+void IDWeakMap::Remove(int32_t id) {
+  auto iter = map_.find(id);
+  if (iter == map_.end())
+    LOG(WARNING) << "Removing unexist object with ID " << id;
+  else
+    map_.erase(iter);
+}
+
+void IDWeakMap::Clear() {
+  map_.clear();
+}
+
+int32_t IDWeakMap::GetNextID() {
+  return ++next_id_;
+}
+
+}  // namespace electron
added in remote
  their  100644 1ba179fab601d6d29940da2b1deda5d1f95aaf76 electron/common/id_weak_map.h
@@ -0,0 +1,61 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_ID_WEAK_MAP_H_
+#define ELECTRON_COMMON_ID_WEAK_MAP_H_
+
+#include <unordered_map>
+#include <vector>
+
+#include "base/memory/linked_ptr.h"
+#include "v8/include/v8.h"
+
+namespace electron {
+
+// Like ES6's WeakMap, but the key is Integer and the value is Weak Pointer.
+class IDWeakMap {
+ public:
+  IDWeakMap();
+  ~IDWeakMap();
+
+  // Sets the object to WeakMap with the given |id|.
+  void Set(v8::Isolate* isolate, int32_t id, v8::Local<v8::Object> object);
+
+  // Adds |object| to WeakMap and returns its allocated |id|.
+  int32_t Add(v8::Isolate* isolate, v8::Local<v8::Object> object);
+
+  // Gets the object from WeakMap by its |id|.
+  v8::MaybeLocal<v8::Object> Get(v8::Isolate* isolate, int32_t id);
+
+  // Whethere there is an object with |id| in this WeakMap.
+  bool Has(int32_t id) const;
+
+  // Returns IDs of all available objects.
+  std::vector<int32_t> Keys() const;
+
+  // Returns all objects.
+  std::vector<v8::Local<v8::Object>> Values(v8::Isolate* isolate);
+
+  // Remove object with |id| in the WeakMap.
+  void Remove(int32_t key);
+
+  // Clears the weak map.
+  void Clear();
+
+ private:
+  // Returns next available ID.
+  int32_t GetNextID();
+
+  // ID of next stored object.
+  int32_t next_id_;
+
+  // Map of stored objects.
+  std::unordered_map<int32_t, linked_ptr<v8::Global<v8::Object>>> map_;
+
+  DISALLOW_COPY_AND_ASSIGN(IDWeakMap);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_ID_WEAK_MAP_H_
added in remote
  their  100644 4504df65bc043c77aa77274fe8d5d57c71c8e16b electron/common/keyboard_util.cc
@@ -0,0 +1,176 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/keyboard_util.h"
+#include "base/strings/string_number_conversions.h"
+#include "base/strings/string_util.h"
+
+namespace electron {
+
+namespace {
+
+// Return key code of the char, and also determine whether the SHIFT key is
+// pressed.
+ui::KeyboardCode KeyboardCodeFromCharCode(base::char16 c, bool* shifted) {
+  c = base::ToLowerASCII(c);
+  *shifted = false;
+  switch (c) {
+    case 0x08: return ui::VKEY_BACK;
+    case 0x7F: return ui::VKEY_DELETE;
+    case 0x09: return ui::VKEY_TAB;
+    case 0x0D: return ui::VKEY_RETURN;
+    case 0x1B: return ui::VKEY_ESCAPE;
+    case ' ': return ui::VKEY_SPACE;
+
+    case 'a': return ui::VKEY_A;
+    case 'b': return ui::VKEY_B;
+    case 'c': return ui::VKEY_C;
+    case 'd': return ui::VKEY_D;
+    case 'e': return ui::VKEY_E;
+    case 'f': return ui::VKEY_F;
+    case 'g': return ui::VKEY_G;
+    case 'h': return ui::VKEY_H;
+    case 'i': return ui::VKEY_I;
+    case 'j': return ui::VKEY_J;
+    case 'k': return ui::VKEY_K;
+    case 'l': return ui::VKEY_L;
+    case 'm': return ui::VKEY_M;
+    case 'n': return ui::VKEY_N;
+    case 'o': return ui::VKEY_O;
+    case 'p': return ui::VKEY_P;
+    case 'q': return ui::VKEY_Q;
+    case 'r': return ui::VKEY_R;
+    case 's': return ui::VKEY_S;
+    case 't': return ui::VKEY_T;
+    case 'u': return ui::VKEY_U;
+    case 'v': return ui::VKEY_V;
+    case 'w': return ui::VKEY_W;
+    case 'x': return ui::VKEY_X;
+    case 'y': return ui::VKEY_Y;
+    case 'z': return ui::VKEY_Z;
+
+    case ')': *shifted = true; case '0': return ui::VKEY_0;
+    case '!': *shifted = true; case '1': return ui::VKEY_1;
+    case '@': *shifted = true; case '2': return ui::VKEY_2;
+    case '#': *shifted = true; case '3': return ui::VKEY_3;
+    case '$': *shifted = true; case '4': return ui::VKEY_4;
+    case '%': *shifted = true; case '5': return ui::VKEY_5;
+    case '^': *shifted = true; case '6': return ui::VKEY_6;
+    case '&': *shifted = true; case '7': return ui::VKEY_7;
+    case '*': *shifted = true; case '8': return ui::VKEY_8;
+    case '(': *shifted = true; case '9': return ui::VKEY_9;
+
+    case ':': *shifted = true; case ';': return ui::VKEY_OEM_1;
+    case '+': *shifted = true; case '=': return ui::VKEY_OEM_PLUS;
+    case '<': *shifted = true; case ',': return ui::VKEY_OEM_COMMA;
+    case '_': *shifted = true; case '-': return ui::VKEY_OEM_MINUS;
+    case '>': *shifted = true; case '.': return ui::VKEY_OEM_PERIOD;
+    case '?': *shifted = true; case '/': return ui::VKEY_OEM_2;
+    case '~': *shifted = true; case '`': return ui::VKEY_OEM_3;
+    case '{': *shifted = true; case '[': return ui::VKEY_OEM_4;
+    case '|': *shifted = true; case '\\': return ui::VKEY_OEM_5;
+    case '}': *shifted = true; case ']': return ui::VKEY_OEM_6;
+    case '"': *shifted = true; case '\'': return ui::VKEY_OEM_7;
+
+    default: return ui::VKEY_UNKNOWN;
+  }
+}
+
+// Return key code represented by |str|.
+ui::KeyboardCode KeyboardCodeFromKeyIdentifier(const std::string& s,
+                                               bool* shifted) {
+  std::string str = base::ToLowerASCII(s);
+  if (str == "ctrl" || str == "control") {
+    return ui::VKEY_CONTROL;
+  } else if (str == "super" || str == "cmd" || str == "command" ||
+             str == "meta") {
+    return ui::VKEY_COMMAND;
+  } else if (str == "commandorcontrol" || str == "cmdorctrl") {
+#if defined(OS_MACOSX)
+    return ui::VKEY_COMMAND;
+#else
+    return ui::VKEY_CONTROL;
+#endif
+  } else if (str == "alt" || str == "option") {
+    return ui::VKEY_MENU;
+  } else if (str == "shift") {
+    return ui::VKEY_SHIFT;
+  } else if (str == "altgr") {
+    return ui::VKEY_ALTGR;
+  } else if (str == "plus") {
+    *shifted = true;
+    return ui::VKEY_OEM_PLUS;
+  } else if (str == "tab") {
+    return ui::VKEY_TAB;
+  } else if (str == "space") {
+    return ui::VKEY_SPACE;
+  } else if (str == "backspace") {
+    return ui::VKEY_BACK;
+  } else if (str == "delete") {
+    return ui::VKEY_DELETE;
+  } else if (str == "insert") {
+    return ui::VKEY_INSERT;
+  } else if (str == "enter" || str == "return") {
+    return ui::VKEY_RETURN;
+  } else if (str == "up") {
+    return ui::VKEY_UP;
+  } else if (str == "down") {
+    return ui::VKEY_DOWN;
+  } else if (str == "left") {
+    return ui::VKEY_LEFT;
+  } else if (str == "right") {
+    return ui::VKEY_RIGHT;
+  } else if (str == "home") {
+    return ui::VKEY_HOME;
+  } else if (str == "end") {
+    return ui::VKEY_END;
+  } else if (str == "pageup") {
+    return ui::VKEY_PRIOR;
+  } else if (str == "pagedown") {
+    return ui::VKEY_NEXT;
+  } else if (str == "esc" || str == "escape") {
+    return ui::VKEY_ESCAPE;
+  } else if (str == "volumemute") {
+    return ui::VKEY_VOLUME_MUTE;
+  } else if (str == "volumeup") {
+    return ui::VKEY_VOLUME_UP;
+  } else if (str == "volumedown") {
+    return ui::VKEY_VOLUME_DOWN;
+  } else if (str == "medianexttrack") {
+    return ui::VKEY_MEDIA_NEXT_TRACK;
+  } else if (str == "mediaprevioustrack") {
+    return ui::VKEY_MEDIA_PREV_TRACK;
+  } else if (str == "mediastop") {
+    return ui::VKEY_MEDIA_STOP;
+  } else if (str == "mediaplaypause") {
+    return ui::VKEY_MEDIA_PLAY_PAUSE;
+  } else if (str == "printscreen") {
+    return ui::VKEY_SNAPSHOT;
+  } else if (str.size() > 1 && str[0] == 'f') {
+    // F1 - F24.
+    int n;
+    if (base::StringToInt(str.c_str() + 1, &n) && n > 0 && n < 25) {
+      return static_cast<ui::KeyboardCode>(ui::VKEY_F1 + n - 1);
+    } else {
+      LOG(WARNING) << str << "is not available on keyboard";
+      return ui::VKEY_UNKNOWN;
+    }
+  } else {
+    LOG(WARNING) << "Invalid accelerator token: " << str;
+    return ui::VKEY_UNKNOWN;
+  }
+}
+
+}  // namespace
+
+ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted) {
+  if (str.size() == 1)
+    return KeyboardCodeFromCharCode(str[0], shifted);
+  else
+    return KeyboardCodeFromKeyIdentifier(str, shifted);
+}
+
+}  // namespace electron
added in remote
  their  100644 0dec464f4c0f5de1c9e49edd819a9b0fa3352f00 electron/common/keyboard_util.h
@@ -0,0 +1,20 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_KEYBOARD_UTIL_H_
+#define ELECTRON_COMMON_KEYBOARD_UTIL_H_
+
+#include <string>
+
+#include "ui/events/keycodes/keyboard_codes.h"
+
+namespace electron {
+
+// Return key code of the |str|, and also determine whether the SHIFT key is
+// pressed.
+ui::KeyboardCode KeyboardCodeFromStr(const std::string& str, bool* shifted);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_KEYBOARD_UTIL_H_
added in remote
  their  100644 498cc377154bf0d1fb9ed0c6ad5959a0b5d1a5f3 electron/common/linux/application_info.cc
@@ -0,0 +1,19 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+
+#include "electron/common/electron_version.h"
+
+namespace brightray {
+
+std::string GetApplicationName() {
+  return ELECTRON_PRODUCT_NAME;
+}
+
+std::string GetApplicationVersion() {
+  return ELECTRON_VERSION_STRING;
+}
+
+}  // namespace brightray
added in remote
  their  100644 f920d2b36cfca98a9bf1d9f44e738e58a59ee65a electron/common/mouse_util.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include <string>
+#include "electron/common/mouse_util.h"
+
+using Cursor = blink::WebCursorInfo::Type;
+
+namespace electron {
+
+std::string CursorTypeToString(const content::WebCursor::CursorInfo& info) {
+  switch (info.type) {
+    case Cursor::TypePointer: return "default";
+    case Cursor::TypeCross: return "crosshair";
+    case Cursor::TypeHand: return "pointer";
+    case Cursor::TypeIBeam: return "text";
+    case Cursor::TypeWait: return "wait";
+    case Cursor::TypeHelp: return "help";
+    case Cursor::TypeEastResize: return "e-resize";
+    case Cursor::TypeNorthResize: return "n-resize";
+    case Cursor::TypeNorthEastResize: return "ne-resize";
+    case Cursor::TypeNorthWestResize: return "nw-resize";
+    case Cursor::TypeSouthResize: return "s-resize";
+    case Cursor::TypeSouthEastResize: return "se-resize";
+    case Cursor::TypeSouthWestResize: return "sw-resize";
+    case Cursor::TypeWestResize: return "w-resize";
+    case Cursor::TypeNorthSouthResize: return "ns-resize";
+    case Cursor::TypeEastWestResize: return "ew-resize";
+    case Cursor::TypeNorthEastSouthWestResize: return "nesw-resize";
+    case Cursor::TypeNorthWestSouthEastResize: return "nwse-resize";
+    case Cursor::TypeColumnResize: return "col-resize";
+    case Cursor::TypeRowResize: return "row-resize";
+    case Cursor::TypeMiddlePanning: return "m-panning";
+    case Cursor::TypeEastPanning: return "e-panning";
+    case Cursor::TypeNorthPanning: return "n-panning";
+    case Cursor::TypeNorthEastPanning: return "ne-panning";
+    case Cursor::TypeNorthWestPanning: return "nw-panning";
+    case Cursor::TypeSouthPanning: return "s-panning";
+    case Cursor::TypeSouthEastPanning: return "se-panning";
+    case Cursor::TypeSouthWestPanning: return "sw-panning";
+    case Cursor::TypeWestPanning: return "w-panning";
+    case Cursor::TypeMove: return "move";
+    case Cursor::TypeVerticalText: return "vertical-text";
+    case Cursor::TypeCell: return "cell";
+    case Cursor::TypeContextMenu: return "context-menu";
+    case Cursor::TypeAlias: return "alias";
+    case Cursor::TypeProgress: return "progress";
+    case Cursor::TypeNoDrop: return "nodrop";
+    case Cursor::TypeCopy: return "copy";
+    case Cursor::TypeNone: return "none";
+    case Cursor::TypeNotAllowed: return "not-allowed";
+    case Cursor::TypeZoomIn: return "zoom-in";
+    case Cursor::TypeZoomOut: return "zoom-out";
+    case Cursor::TypeGrab: return "grab";
+    case Cursor::TypeGrabbing: return "grabbing";
+    case Cursor::TypeCustom: return "custom";
+    default: return "default";
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 54e549b4ac7b592d5eccea6e447d1bcf132a9fee electron/common/mouse_util.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_MOUSE_UTIL_H_
+#define ELECTRON_COMMON_MOUSE_UTIL_H_
+
+#include <string>
+#include "content/common/cursors/webcursor.h"
+#include "ipc/ipc_message_macros.h"
+
+// IPC macros similar to the already existing ones in the chromium source.
+// We need these to listen to the cursor change IPC message while still
+// letting chromium handle the actual cursor change by setting handled = false.
+#define IPC_MESSAGE_HANDLER_CODE(msg_class, member_func, code)                 \
+  IPC_MESSAGE_FORWARD_CODE(msg_class, this,                                    \
+    _IpcMessageHandlerClass::member_func, code)
+
+#define IPC_MESSAGE_FORWARD_CODE(msg_class, obj, member_func, code)            \
+    case msg_class::ID: {                                                      \
+        TRACK_RUN_IN_THIS_SCOPED_REGION(member_func);                          \
+        if (!msg_class::Dispatch(&ipc_message__, obj, this, param__,           \
+                                 &member_func))                                \
+          ipc_message__.set_dispatch_error();                                  \
+        code;                                                                  \
+      }                                                                        \
+      break;
+
+namespace electron {
+
+// Returns the cursor's type as a string.
+std::string CursorTypeToString(const content::WebCursor::CursorInfo& info);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_MOUSE_UTIL_H_
added in remote
  their  100644 142a2e73a6559b29d2f14c111b779253470b5638 electron/common/native_mate_converters/accelerator_converter.cc
@@ -0,0 +1,22 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/accelerator_converter.h"
+
+#include <string>
+
+#include "electron/browser/ui/accelerator_util.h"
+
+namespace mate {
+
+// static
+bool Converter<ui::Accelerator>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, ui::Accelerator* out) {
+  std::string keycode;
+  if (!ConvertFromV8(isolate, val, &keycode))
+    return false;
+  return accelerator_util::StringToAccelerator(keycode, out);
+}
+
+}  // namespace mate
added in remote
  their  100644 2941bcb7a9e24728b3cefcb3b9f805d7bdba4e43 electron/common/native_mate_converters/accelerator_converter.h
@@ -0,0 +1,24 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace ui {
+class Accelerator;
+}
+
+namespace mate {
+
+template<>
+struct Converter<ui::Accelerator> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     ui::Accelerator* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_ACCELERATOR_CONVERTER_H_
added in remote
  their  100644 6307bad231e6754231304f8f99dd1b80b309d236 electron/common/native_mate_converters/blink_converter.cc
@@ -0,0 +1,299 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/blink_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/keyboard_util.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "content/public/browser/native_web_keyboard_event.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebDeviceEmulationParams.h"
+#include "third_party/WebKit/public/web/WebFindOptions.h"
+#include "third_party/WebKit/public/web/WebInputEvent.h"
+
+namespace {
+
+template<typename T>
+int VectorToBitArray(const std::vector<T>& vec) {
+  int bits = 0;
+  for (const T& item : vec)
+    bits |= item;
+  return bits;
+}
+
+}  // namespace
+
+namespace mate {
+
+template<>
+struct Converter<base::char16> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     base::char16* out) {
+    base::string16 code = base::UTF8ToUTF16(V8ToString(val));
+    if (code.length() != 1)
+      return false;
+    *out = code[0];
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebInputEvent::Type> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Type* out) {
+    std::string type = base::ToLowerASCII(V8ToString(val));
+    if (type == "mousedown")
+      *out = blink::WebInputEvent::MouseDown;
+    else if (type == "mouseup")
+      *out = blink::WebInputEvent::MouseUp;
+    else if (type == "mousemove")
+      *out = blink::WebInputEvent::MouseMove;
+    else if (type == "mouseenter")
+      *out = blink::WebInputEvent::MouseEnter;
+    else if (type == "mouseleave")
+      *out = blink::WebInputEvent::MouseLeave;
+    else if (type == "contextmenu")
+      *out = blink::WebInputEvent::ContextMenu;
+    else if (type == "mousewheel")
+      *out = blink::WebInputEvent::MouseWheel;
+    else if (type == "keydown")
+      *out = blink::WebInputEvent::RawKeyDown;
+    else if (type == "keyup")
+      *out = blink::WebInputEvent::KeyUp;
+    else if (type == "char")
+      *out = blink::WebInputEvent::Char;
+    else if (type == "touchstart")
+      *out = blink::WebInputEvent::TouchStart;
+    else if (type == "touchmove")
+      *out = blink::WebInputEvent::TouchMove;
+    else if (type == "touchend")
+      *out = blink::WebInputEvent::TouchEnd;
+    else if (type == "touchcancel")
+      *out = blink::WebInputEvent::TouchCancel;
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebMouseEvent::Button> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebMouseEvent::Button* out) {
+    std::string button = base::ToLowerASCII(V8ToString(val));
+    if (button == "left")
+      *out = blink::WebMouseEvent::Button::ButtonLeft;
+    else if (button == "middle")
+      *out = blink::WebMouseEvent::Button::ButtonMiddle;
+    else if (button == "right")
+      *out = blink::WebMouseEvent::Button::ButtonRight;
+    return true;
+  }
+};
+
+template<>
+struct Converter<blink::WebInputEvent::Modifiers> {
+  static bool FromV8(v8::Isolate* isolate, v8::Handle<v8::Value> val,
+                     blink::WebInputEvent::Modifiers* out) {
+    std::string modifier = base::ToLowerASCII(V8ToString(val));
+    if (modifier == "shift")
+      *out = blink::WebInputEvent::ShiftKey;
+    else if (modifier == "control" || modifier == "ctrl")
+      *out = blink::WebInputEvent::ControlKey;
+    else if (modifier == "alt")
+      *out = blink::WebInputEvent::AltKey;
+    else if (modifier == "meta" || modifier == "command" || modifier == "cmd")
+      *out = blink::WebInputEvent::MetaKey;
+    else if (modifier == "iskeypad")
+      *out = blink::WebInputEvent::IsKeyPad;
+    else if (modifier == "isautorepeat")
+      *out = blink::WebInputEvent::IsAutoRepeat;
+    else if (modifier == "leftbuttondown")
+      *out = blink::WebInputEvent::LeftButtonDown;
+    else if (modifier == "middlebuttondown")
+      *out = blink::WebInputEvent::MiddleButtonDown;
+    else if (modifier == "rightbuttondown")
+      *out = blink::WebInputEvent::RightButtonDown;
+    else if (modifier == "capslock")
+      *out = blink::WebInputEvent::CapsLockOn;
+    else if (modifier == "numlock")
+      *out = blink::WebInputEvent::NumLockOn;
+    else if (modifier == "left")
+      *out = blink::WebInputEvent::IsLeft;
+    else if (modifier == "right")
+      *out = blink::WebInputEvent::IsRight;
+    return true;
+  }
+};
+
+int GetWebInputEventType(v8::Isolate* isolate, v8::Local<v8::Value> val) {
+  blink::WebInputEvent::Type type = blink::WebInputEvent::Undefined;
+  mate::Dictionary dict;
+  ConvertFromV8(isolate, val, &dict) && dict.Get("type", &type);
+  return type;
+}
+
+bool Converter<blink::WebInputEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebInputEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!dict.Get("type", &out->type))
+    return false;
+  std::vector<blink::WebInputEvent::Modifiers> modifiers;
+  if (dict.Get("modifiers", &modifiers))
+    out->modifiers = VectorToBitArray(modifiers);
+  out->timeStampSeconds = base::Time::Now().ToDoubleT();
+  return true;
+}
+
+bool Converter<blink::WebKeyboardEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebKeyboardEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+
+  std::string str;
+  bool shifted = false;
+  if (dict.Get("keyCode", &str))
+    out->windowsKeyCode = electron::KeyboardCodeFromStr(str, &shifted);
+  else
+    return false;
+
+  if (shifted)
+    out->modifiers |= blink::WebInputEvent::ShiftKey;
+  out->setKeyIdentifierFromWindowsKeyCode();
+  if ((out->type == blink::WebInputEvent::Char ||
+       out->type == blink::WebInputEvent::RawKeyDown) &&
+      str.size() == 1) {
+    out->text[0] = str[0];
+    out->unmodifiedText[0] = str[0];
+  }
+  return true;
+}
+
+bool Converter<content::NativeWebKeyboardEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    content::NativeWebKeyboardEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebKeyboardEvent*>(out)))
+    return false;
+  dict.Get("skipInBrowser", &out->skip_in_browser);
+  return true;
+}
+
+bool Converter<blink::WebMouseEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebMouseEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebInputEvent*>(out)))
+    return false;
+  if (!dict.Get("x", &out->x) || !dict.Get("y", &out->y))
+    return false;
+  dict.Get("button", &out->button);
+  dict.Get("globalX", &out->globalX);
+  dict.Get("globalY", &out->globalY);
+  dict.Get("movementX", &out->movementX);
+  dict.Get("movementY", &out->movementY);
+  dict.Get("clickCount", &out->clickCount);
+  return true;
+}
+
+bool Converter<blink::WebMouseWheelEvent>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebMouseWheelEvent* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  if (!ConvertFromV8(isolate, val, static_cast<blink::WebMouseEvent*>(out)))
+    return false;
+  dict.Get("deltaX", &out->deltaX);
+  dict.Get("deltaY", &out->deltaY);
+  dict.Get("wheelTicksX", &out->wheelTicksX);
+  dict.Get("wheelTicksY", &out->wheelTicksY);
+  dict.Get("accelerationRatioX", &out->accelerationRatioX);
+  dict.Get("accelerationRatioY", &out->accelerationRatioY);
+  dict.Get("hasPreciseScrollingDeltas", &out->hasPreciseScrollingDeltas);
+  dict.Get("canScroll", &out->canScroll);
+  return true;
+}
+
+bool Converter<blink::WebFloatPoint>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebFloatPoint* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
+}
+
+bool Converter<blink::WebPoint>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebPoint* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("x", &out->x) && dict.Get("y", &out->y);
+}
+
+bool Converter<blink::WebSize>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val, blink::WebSize* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  return dict.Get("width", &out->width) && dict.Get("height", &out->height);
+}
+
+bool Converter<blink::WebDeviceEmulationParams>::FromV8(
+    v8::Isolate* isolate, v8::Local<v8::Value> val,
+    blink::WebDeviceEmulationParams* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  std::string screen_position;
+  if (dict.Get("screenPosition", &screen_position)) {
+    screen_position = base::ToLowerASCII(screen_position);
+    if (screen_position == "mobile")
+      out->screenPosition = blink::WebDeviceEmulationParams::Mobile;
+    else if (screen_position == "desktop")
+      out->screenPosition = blink::WebDeviceEmulationParams::Desktop;
+    else
+      return false;
+  }
+
+  dict.Get("screenSize", &out->screenSize);
+  dict.Get("viewPosition", &out->viewPosition);
+  dict.Get("deviceScaleFactor", &out->deviceScaleFactor);
+  dict.Get("viewSize", &out->viewSize);
+  dict.Get("fitToView", &out->fitToView);
+  dict.Get("offset", &out->offset);
+  dict.Get("scale", &out->scale);
+  return true;
+}
+
+bool Converter<blink::WebFindOptions>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    blink::WebFindOptions* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+
+  dict.Get("forward", &out->forward);
+  dict.Get("matchCase", &out->matchCase);
+  dict.Get("findNext", &out->findNext);
+  dict.Get("wordStart", &out->wordStart);
+  dict.Get("medialCapitalAsWordStart", &out->medialCapitalAsWordStart);
+  return true;
+}
+
+}  // namespace mate
added in remote
  their  100644 421306f8a83bf7843e96a7e2174cbeba61f86eb6 electron/common/native_mate_converters/blink_converter.h
@@ -0,0 +1,92 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace blink {
+class WebInputEvent;
+class WebMouseEvent;
+class WebMouseWheelEvent;
+class WebKeyboardEvent;
+struct WebDeviceEmulationParams;
+struct WebFindOptions;
+struct WebFloatPoint;
+struct WebPoint;
+struct WebSize;
+}  // namespace blink
+
+namespace content {
+struct NativeWebKeyboardEvent;
+}
+
+namespace mate {
+
+int GetWebInputEventType(v8::Isolate* isolate, v8::Local<v8::Value> val);
+
+template<>
+struct Converter<blink::WebInputEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebInputEvent* out);
+};
+
+template<>
+struct Converter<blink::WebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebKeyboardEvent* out);
+};
+
+template<>
+struct Converter<content::NativeWebKeyboardEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::NativeWebKeyboardEvent* out);
+};
+
+template<>
+struct Converter<blink::WebMouseEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebMouseEvent* out);
+};
+
+template<>
+struct Converter<blink::WebMouseWheelEvent> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebMouseWheelEvent* out);
+};
+
+template<>
+struct Converter<blink::WebFloatPoint> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebFloatPoint* out);
+};
+
+template<>
+struct Converter<blink::WebPoint> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebPoint* out);
+};
+
+template<>
+struct Converter<blink::WebSize> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebSize* out);
+};
+
+template<>
+struct Converter<blink::WebDeviceEmulationParams> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebDeviceEmulationParams* out);
+};
+
+template<>
+struct Converter<blink::WebFindOptions> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     blink::WebFindOptions* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_BLINK_CONVERTER_H_
added in remote
  their  100644 2c4d31ae293aebe6c4e660c9d85138bc97d39b89 electron/common/native_mate_converters/callback.cc
@@ -0,0 +1,137 @@
+// Copyright (c) 2015 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/callback.h"
+
+#include "content/public/browser/browser_thread.h"
+
+using content::BrowserThread;
+
+namespace mate {
+
+namespace internal {
+
+namespace {
+
+struct TranslaterHolder {
+  Translater translater;
+};
+
+// Cached JavaScript version of |CallTranslater|.
+v8::Persistent<v8::FunctionTemplate> g_call_translater;
+
+void CallTranslater(v8::Local<v8::External> external,
+                    v8::Local<v8::Object> state,
+                    mate::Arguments* args) {
+  v8::Isolate* isolate = args->isolate();
+
+  // Check if the callback has already been called.
+  v8::Local<v8::String> called_symbol = mate::StringToSymbol(isolate, "called");
+  if (state->Has(called_symbol)) {
+    args->ThrowError("callback can only be called for once");
+    return;
+  } else {
+    state->Set(called_symbol, v8::Boolean::New(isolate, true));
+  }
+
+  TranslaterHolder* holder = static_cast<TranslaterHolder*>(external->Value());
+  holder->translater.Run(args);
+  delete holder;
+}
+
+// func.bind(func, arg1).
+// NB(zcbenz): Using C++11 version crashes VS.
+v8::Local<v8::Value> BindFunctionWith(v8::Isolate* isolate,
+                                      v8::Local<v8::Context> context,
+                                      v8::Local<v8::Function> func,
+                                      v8::Local<v8::Value> arg1,
+                                      v8::Local<v8::Value> arg2) {
+  v8::MaybeLocal<v8::Value> bind = func->Get(mate::StringToV8(isolate, "bind"));
+  CHECK(!bind.IsEmpty());
+  v8::Local<v8::Function> bind_func =
+      v8::Local<v8::Function>::Cast(bind.ToLocalChecked());
+  v8::Local<v8::Value> converted[] = { func, arg1, arg2 };
+  return bind_func->Call(
+      context, func, arraysize(converted), converted).ToLocalChecked();
+}
+
+}  // namespace
+
+// Destroy the class on UI thread when possible.
+struct DeleteOnUIThread {
+  template<typename T>
+  static void Destruct(const T* x) {
+    if (Locker::IsBrowserProcess() &&
+        !BrowserThread::CurrentlyOn(BrowserThread::UI)) {
+      BrowserThread::DeleteSoon(BrowserThread::UI, FROM_HERE, x);
+    } else {
+      delete x;
+    }
+  }
+};
+
+// Like v8::Global, but ref-counted.
+template<typename T>
+class RefCountedGlobal : public base::RefCountedThreadSafe<RefCountedGlobal<T>,
+                                                           DeleteOnUIThread> {
+ public:
+  RefCountedGlobal(v8::Isolate* isolate, v8::Local<v8::Value> value)
+      : handle_(isolate, v8::Local<T>::Cast(value)) {
+  }
+
+  bool IsAlive() const {
+    return !handle_.IsEmpty();
+  }
+
+  v8::Local<T> NewHandle(v8::Isolate* isolate) const {
+    return v8::Local<T>::New(isolate, handle_);
+  }
+
+ private:
+  v8::Global<T> handle_;
+
+  DISALLOW_COPY_AND_ASSIGN(RefCountedGlobal);
+};
+
+SafeV8Function::SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value)
+    : v8_function_(new RefCountedGlobal<v8::Function>(isolate, value)) {
+}
+
+SafeV8Function::SafeV8Function(const SafeV8Function& other)
+    : v8_function_(other.v8_function_) {
+}
+
+SafeV8Function::~SafeV8Function() {
+}
+
+bool SafeV8Function::IsAlive() const {
+  return v8_function_.get() && v8_function_->IsAlive();
+}
+
+v8::Local<v8::Function> SafeV8Function::NewHandle(v8::Isolate* isolate) const {
+  return v8_function_->NewHandle(isolate);
+}
+
+v8::Local<v8::Value> CreateFunctionFromTranslater(
+    v8::Isolate* isolate, const Translater& translater) {
+  // The FunctionTemplate is cached.
+  if (g_call_translater.IsEmpty())
+    g_call_translater.Reset(
+        isolate,
+        mate::CreateFunctionTemplate(isolate, base::Bind(&CallTranslater)));
+
+  v8::Local<v8::FunctionTemplate> call_translater =
+      v8::Local<v8::FunctionTemplate>::New(isolate, g_call_translater);
+  TranslaterHolder* holder = new TranslaterHolder;
+  holder->translater = translater;
+  return BindFunctionWith(isolate,
+                          isolate->GetCurrentContext(),
+                          call_translater->GetFunction(),
+                          v8::External::New(isolate, holder),
+                          v8::Object::New(isolate));
+}
+
+}  // namespace internal
+
+}  // namespace mate
added in remote
  their  100644 77c92e191926789c7c2e61de9514caf5a68e63bc electron/common/native_mate_converters/callback.h
@@ -0,0 +1,155 @@
+// Copyright (c) 2015 GitHub, Inc. All rights reserved.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
+
+#include <vector>
+
+#include "electron/common/api/locker.h"
+#include "base/bind.h"
+#include "base/callback.h"
+#include "base/memory/weak_ptr.h"
+#include "native_mate/function_template.h"
+#include "native_mate/scoped_persistent.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+namespace mate {
+
+namespace internal {
+
+template<typename T>
+class RefCountedGlobal;
+
+// Manages the V8 function with RAII.
+class SafeV8Function {
+ public:
+  SafeV8Function(v8::Isolate* isolate, v8::Local<v8::Value> value);
+  SafeV8Function(const SafeV8Function& other);
+  ~SafeV8Function();
+
+  bool IsAlive() const;
+  v8::Local<v8::Function> NewHandle(v8::Isolate* isolate) const;
+
+ private:
+  scoped_refptr<RefCountedGlobal<v8::Function>> v8_function_;
+};
+
+// Helper to invoke a V8 function with C++ parameters.
+template <typename Sig>
+struct V8FunctionInvoker {};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<v8::Local<v8::Value>(ArgTypes...)> {
+  static v8::Local<v8::Value> Go(v8::Isolate* isolate,
+                                 const SafeV8Function& function,
+                                 ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::EscapableHandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return v8::Null(isolate);
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    v8::Local<v8::Value> ret(holder->Call(holder, args.size(), &args.front()));
+    return handle_scope.Escape(ret);
+  }
+};
+
+template <typename... ArgTypes>
+struct V8FunctionInvoker<void(ArgTypes...)> {
+  static void Go(v8::Isolate* isolate,
+                 const SafeV8Function& function,
+                 ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    if (!function.IsAlive())
+      return;
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    holder->Call(holder, args.size(), &args.front());
+  }
+};
+
+template <typename ReturnType, typename... ArgTypes>
+struct V8FunctionInvoker<ReturnType(ArgTypes...)> {
+  static ReturnType Go(v8::Isolate* isolate,
+                       const SafeV8Function& function,
+                       ArgTypes... raw) {
+    Locker locker(isolate);
+    v8::HandleScope handle_scope(isolate);
+    ReturnType ret = ReturnType();
+    if (!function.IsAlive())
+      return ret;
+    scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+        Locker::IsBrowserProcess() ?
+        nullptr : new blink::WebScopedRunV8Script);
+    v8::Local<v8::Function> holder = function.NewHandle(isolate);
+    v8::Local<v8::Context> context = holder->CreationContext();
+    v8::Context::Scope context_scope(context);
+    std::vector<v8::Local<v8::Value>> args = { ConvertToV8(isolate, raw)... };
+    v8::Local<v8::Value> result;
+    auto maybe_result =
+        holder->Call(context, holder, args.size(), &args.front());
+    if (maybe_result.ToLocal(&result))
+      Converter<ReturnType>::FromV8(isolate, result, &ret);
+    return ret;
+  }
+};
+
+// Helper to pass a C++ funtion to JavaScript.
+using Translater = base::Callback<void(Arguments* args)>;
+v8::Local<v8::Value> CreateFunctionFromTranslater(
+    v8::Isolate* isolate, const Translater& translater);
+
+// Calls callback with Arguments.
+template <typename Sig>
+struct NativeFunctionInvoker {};
+
+template <typename ReturnType, typename... ArgTypes>
+struct NativeFunctionInvoker<ReturnType(ArgTypes...)> {
+  static void Go(base::Callback<ReturnType(ArgTypes...)> val, Arguments* args) {
+    using Indices = typename IndicesGenerator<sizeof...(ArgTypes)>::type;
+    Invoker<Indices, ArgTypes...> invoker(args, 0);
+    if (invoker.IsOK())
+      invoker.DispatchToCallback(val);
+  }
+};
+
+}  // namespace internal
+
+template<typename Sig>
+struct Converter<base::Callback<Sig>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::Callback<Sig>& val) {
+    // We don't use CreateFunctionTemplate here because it creates a new
+    // FunctionTemplate everytime, which is cached by V8 and causes leaks.
+    internal::Translater translater = base::Bind(
+        &internal::NativeFunctionInvoker<Sig>::Go, val);
+    return internal::CreateFunctionFromTranslater(isolate, translater);
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::Callback<Sig>* out) {
+    if (!val->IsFunction())
+      return false;
+
+    *out = base::Bind(&internal::V8FunctionInvoker<Sig>::Go,
+                      isolate, internal::SafeV8Function(isolate, val));
+    return true;
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CALLBACK_H_
added in remote
  their  100644 f32bf20ab95c1481f72e91bd0028ee9ec12cd9d9 electron/common/native_mate_converters/content_converter.cc
@@ -0,0 +1,181 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/content_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/browser/api/electron_api_web_contents.h"
+#include "electron/browser/web_contents_permission_helper.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "content/public/browser/web_contents.h"
+#include "content/public/common/context_menu_params.h"
+#include "native_mate/dictionary.h"
+
+namespace {
+
+void ExecuteCommand(content::WebContents* web_contents,
+                    int action,
+                    const content::CustomContextMenuContext& context) {
+  web_contents->ExecuteCustomContextMenuCommand(action, context);
+}
+
+// Forward declaration for nested recursive call.
+v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
+                              content::WebContents* web_contents,
+                              const content::CustomContextMenuContext& context,
+                              const std::vector<content::MenuItem>& menu);
+
+v8::Local<v8::Value> MenuItemToV8(
+    v8::Isolate* isolate,
+    content::WebContents* web_contents,
+    const content::CustomContextMenuContext& context,
+    const content::MenuItem& item) {
+  mate::Dictionary v8_item = mate::Dictionary::CreateEmpty(isolate);
+  switch (item.type) {
+    case content::MenuItem::CHECKABLE_OPTION:
+    case content::MenuItem::GROUP:
+      v8_item.Set("checked", item.checked);
+    case content::MenuItem::OPTION:
+    case content::MenuItem::SUBMENU:
+      v8_item.Set("label", item.label);
+      v8_item.Set("enabled", item.enabled);
+    default:
+      v8_item.Set("type", item.type);
+  }
+  if (item.type == content::MenuItem::SUBMENU)
+    v8_item.Set("submenu",
+                MenuToV8(isolate, web_contents, context, item.submenu));
+  else if (item.action > 0)
+    v8_item.Set("click",
+                base::Bind(ExecuteCommand, web_contents, item.action, context));
+  return v8_item.GetHandle();
+}
+
+v8::Local<v8::Value> MenuToV8(v8::Isolate* isolate,
+                              content::WebContents* web_contents,
+                              const content::CustomContextMenuContext& context,
+                              const std::vector<content::MenuItem>& menu) {
+  std::vector<v8::Local<v8::Value>> v8_menu;
+  for (const auto& menu_item : menu)
+    v8_menu.push_back(MenuItemToV8(isolate, web_contents, context, menu_item));
+  return mate::ConvertToV8(isolate, v8_menu);
+}
+
+}  // namespace
+
+namespace mate {
+
+// static
+v8::Local<v8::Value> Converter<content::MenuItem::Type>::ToV8(
+    v8::Isolate* isolate, const content::MenuItem::Type& val) {
+  switch (val) {
+    case content::MenuItem::CHECKABLE_OPTION:
+      return StringToV8(isolate, "checkbox");
+    case content::MenuItem::GROUP:
+      return StringToV8(isolate, "radio");
+    case content::MenuItem::SEPARATOR:
+      return StringToV8(isolate, "separator");
+    case content::MenuItem::SUBMENU:
+      return StringToV8(isolate, "submenu");
+    case content::MenuItem::OPTION:
+    default:
+      return StringToV8(isolate, "normal");
+  }
+}
+
+// static
+v8::Local<v8::Value> Converter<ContextMenuParamsWithWebContents>::ToV8(
+    v8::Isolate* isolate, const ContextMenuParamsWithWebContents& val) {
+  const auto& params = val.first;
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.Set("x", params.x);
+  dict.Set("y", params.y);
+  if (params.custom_context.is_pepper_menu)
+    dict.Set("menu", MenuToV8(isolate, val.second, params.custom_context,
+                              params.custom_items));
+  return mate::ConvertToV8(isolate, dict);
+}
+
+// static
+bool Converter<content::PermissionStatus>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    content::PermissionStatus* out) {
+  bool result;
+  if (!ConvertFromV8(isolate, val, &result))
+    return false;
+
+  if (result)
+    *out = content::PERMISSION_STATUS_GRANTED;
+  else
+    *out = content::PERMISSION_STATUS_DENIED;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::PermissionType>::ToV8(
+    v8::Isolate* isolate, const content::PermissionType& val) {
+  using PermissionType = electron::WebContentsPermissionHelper::PermissionType;
+  switch (val) {
+    case content::PermissionType::MIDI_SYSEX:
+      return StringToV8(isolate, "midiSysex");
+    case content::PermissionType::PUSH_MESSAGING:
+      return StringToV8(isolate, "pushMessaging");
+    case content::PermissionType::NOTIFICATIONS:
+      return StringToV8(isolate, "notifications");
+    case content::PermissionType::GEOLOCATION:
+      return StringToV8(isolate, "geolocation");
+    case content::PermissionType::AUDIO_CAPTURE:
+    case content::PermissionType::VIDEO_CAPTURE:
+      return StringToV8(isolate, "media");
+    case content::PermissionType::PROTECTED_MEDIA_IDENTIFIER:
+      return StringToV8(isolate, "mediaKeySystem");
+    case content::PermissionType::MIDI:
+      return StringToV8(isolate, "midi");
+    default:
+      break;
+  }
+
+  if (val == (content::PermissionType)(PermissionType::POINTER_LOCK))
+    return StringToV8(isolate, "pointerLock");
+  else if (val == (content::PermissionType)(PermissionType::FULLSCREEN))
+    return StringToV8(isolate, "fullscreen");
+
+  return StringToV8(isolate, "unknown");
+}
+
+// static
+bool Converter<content::StopFindAction>::FromV8(
+    v8::Isolate* isolate,
+    v8::Local<v8::Value> val,
+    content::StopFindAction* out) {
+  std::string action;
+  if (!ConvertFromV8(isolate, val, &action))
+    return false;
+
+  if (action == "clearSelection")
+    *out = content::STOP_FIND_ACTION_CLEAR_SELECTION;
+  else if (action == "keepSelection")
+    *out = content::STOP_FIND_ACTION_KEEP_SELECTION;
+  else if (action == "activateSelection")
+    *out = content::STOP_FIND_ACTION_ACTIVATE_SELECTION;
+  else
+    return false;
+
+  return true;
+}
+
+// static
+v8::Local<v8::Value> Converter<content::WebContents*>::ToV8(
+    v8::Isolate* isolate, content::WebContents* val) {
+  if (!val)
+    return v8::Null(isolate);
+  return electron::api::WebContents::CreateFrom(isolate, val).ToV8();
+}
+
+}  // namespace mate
added in remote
  their  100644 00764b15e3257bd4be31c2a9edeb3ff7353d5b44 electron/common/native_mate_converters/content_converter.h
@@ -0,0 +1,64 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
+
+#include <utility>
+
+#include "content/public/browser/permission_type.h"
+#include "content/public/common/menu_item.h"
+#include "content/public/common/permission_status.mojom.h"
+#include "content/public/common/stop_find_action.h"
+#include "native_mate/converter.h"
+
+namespace content {
+struct ContextMenuParams;
+class WebContents;
+}
+
+using ContextMenuParamsWithWebContents =
+    std::pair<content::ContextMenuParams, content::WebContents*>;
+
+namespace mate {
+
+template<>
+struct Converter<content::MenuItem::Type> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::MenuItem::Type& val);
+};
+
+template<>
+struct Converter<ContextMenuParamsWithWebContents> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const ContextMenuParamsWithWebContents& val);
+};
+
+template<>
+struct Converter<content::PermissionStatus> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::PermissionStatus* out);
+};
+
+template<>
+struct Converter<content::PermissionType> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const content::PermissionType& val);
+};
+
+template<>
+struct Converter<content::StopFindAction> {
+  static bool FromV8(v8::Isolate* isolate, v8::Local<v8::Value> val,
+                     content::StopFindAction* out);
+};
+
+template<>
+struct Converter<content::WebContents*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   content::WebContents* val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_CONTENT_CONVERTER_H_
added in remote
  their  100644 28b965e16055f0968ae3b3dd2f4a706315698caa electron/common/native_mate_converters/file_path_converter.h
@@ -0,0 +1,39 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
+
+#include <string>
+
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/files/file_path.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::FilePath> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const base::FilePath& val) {
+    return Converter<base::FilePath::StringType>::ToV8(isolate, val.value());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::FilePath* out) {
+    if (val->IsNull())
+      return true;
+
+    base::FilePath::StringType path;
+    if (Converter<base::FilePath::StringType>::FromV8(isolate, val, &path)) {
+      *out = base::FilePath(path);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_FILE_PATH_CONVERTER_H_
added in remote
  their  100644 8de28554eb036b8d6af872bfb772508857b2411f electron/common/native_mate_converters/gfx_converter.cc
@@ -0,0 +1,114 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/gfx_converter.h"
+
+#include "native_mate/dictionary.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/geometry/rect.h"
+#include "ui/gfx/screen.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace mate {
+
+v8::Local<v8::Value> Converter<gfx::Point>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Point& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Point>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Point* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int x, y;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y))
+    return false;
+  *out = gfx::Point(x, y);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Size>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Size& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Size>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Size* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int width, height;
+  if (!dict.Get("width", &width) || !dict.Get("height", &height))
+    return false;
+  *out = gfx::Size(width, height);
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Rect>::ToV8(v8::Isolate* isolate,
+                                                 const gfx::Rect& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("x", val.x());
+  dict.Set("y", val.y());
+  dict.Set("width", val.width());
+  dict.Set("height", val.height());
+  return dict.GetHandle();
+}
+
+bool Converter<gfx::Rect>::FromV8(v8::Isolate* isolate,
+                                  v8::Local<v8::Value> val,
+                                  gfx::Rect* out) {
+  mate::Dictionary dict;
+  if (!ConvertFromV8(isolate, val, &dict))
+    return false;
+  int x, y, width, height;
+  if (!dict.Get("x", &x) || !dict.Get("y", &y) ||
+      !dict.Get("width", &width) || !dict.Get("height", &height))
+    return false;
+  *out = gfx::Rect(x, y, width, height);
+  return true;
+}
+
+template<>
+struct Converter<gfx::Display::TouchSupport> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Display::TouchSupport& val) {
+    switch (val) {
+      case gfx::Display::TOUCH_SUPPORT_AVAILABLE:
+        return StringToV8(isolate, "available");
+      case gfx::Display::TOUCH_SUPPORT_UNAVAILABLE:
+        return StringToV8(isolate, "unavailable");
+      default:
+        return StringToV8(isolate, "unknown");
+    }
+  }
+};
+
+v8::Local<v8::Value> Converter<gfx::Display>::ToV8(v8::Isolate* isolate,
+                                                    const gfx::Display& val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.SetHidden("simple", true);
+  dict.Set("id", val.id());
+  dict.Set("bounds", val.bounds());
+  dict.Set("workArea", val.work_area());
+  dict.Set("size", val.size());
+  dict.Set("workAreaSize", val.work_area_size());
+  dict.Set("scaleFactor", val.device_scale_factor());
+  dict.Set("rotation", val.RotationAsDegree());
+  dict.Set("touchSupport", val.touch_support());
+  return dict.GetHandle();
+}
+
+}  // namespace mate
added in remote
  their  100644 eb4a98f93ec7a98160c41f23ae8e79e8bd66ada7 electron/common/native_mate_converters/gfx_converter.h
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace gfx {
+class Point;
+class Size;
+class Rect;
+class Display;
+}
+
+namespace mate {
+
+template<>
+struct Converter<gfx::Point> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Point& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Point* out);
+};
+
+template<>
+struct Converter<gfx::Size> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Size& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Size* out);
+};
+
+template<>
+struct Converter<gfx::Rect> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Rect& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Rect* out);
+};
+
+template<>
+struct Converter<gfx::Display> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Display& val);
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Display* out);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GFX_CONVERTER_H_
added in remote
  their  100644 343df5d654fe40063e62598281965048b05b0fca electron/common/native_mate_converters/gurl_converter.h
@@ -0,0 +1,36 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
+
+#include <string>
+
+#include "native_mate/converter.h"
+#include "url/gurl.h"
+
+namespace mate {
+
+template<>
+struct Converter<GURL> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const GURL& val) {
+    return ConvertToV8(isolate, val.spec());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     GURL* out) {
+    std::string url;
+    if (Converter<std::string>::FromV8(isolate, val, &url)) {
+      *out = GURL(url);
+      return true;
+    } else {
+      return false;
+    }
+  }
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_GURL_CONVERTER_H_
added in remote
  their  100644 6998d1bf4c983005120d11473cce6e7a1f0d44ac electron/common/native_mate_converters/image_converter.cc
@@ -0,0 +1,51 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/image_converter.h"
+
+#include "electron/common/api/electron_api_native_image.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "ui/gfx/image/image_skia.h"
+
+namespace mate {
+
+bool Converter<gfx::ImageSkia>::FromV8(v8::Isolate* isolate,
+                                       v8::Local<v8::Value> val,
+                                       gfx::ImageSkia* out) {
+  gfx::Image image;
+  if (!ConvertFromV8(isolate, val, &image))
+    return false;
+
+  *out = image.AsImageSkia();
+  return true;
+}
+
+bool Converter<gfx::Image>::FromV8(v8::Isolate* isolate,
+                                   v8::Local<v8::Value> val,
+                                   gfx::Image* out) {
+  if (val->IsNull())
+    return true;
+
+  Handle<electron::api::NativeImage> native_image;
+  if (!ConvertFromV8(isolate, val, &native_image)) {
+    // Try converting from file path.
+    base::FilePath path;
+    if (!Converter<base::FilePath>::FromV8(isolate, val, &path))
+      return false;
+
+    native_image = electron::api::NativeImage::CreateFromPath(isolate, path);
+    if (native_image->image().IsEmpty())
+      return false;
+  }
+
+  *out = native_image->image();
+  return true;
+}
+
+v8::Local<v8::Value> Converter<gfx::Image>::ToV8(v8::Isolate* isolate,
+                                                  const gfx::Image& val) {
+  return ConvertToV8(isolate, electron::api::NativeImage::Create(isolate, val));
+}
+
+}  // namespace mate
added in remote
  their  100644 d9a5739303088f38ecee5e978fc473bd2089e69c electron/common/native_mate_converters/image_converter.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace gfx {
+class Image;
+class ImageSkia;
+}
+
+namespace mate {
+
+template<>
+struct Converter<gfx::ImageSkia> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::ImageSkia* out);
+};
+
+template<>
+struct Converter<gfx::Image> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     gfx::Image* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const gfx::Image& val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_IMAGE_CONVERTER_H_
added in remote
  their  100644 3d63cadbec97e8b36131b4e0616444b915d6a485 electron/common/native_mate_converters/net_converter.cc
@@ -0,0 +1,99 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/net_converter.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/node_includes.h"
+#include "electron/common/native_mate_converters/gurl_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "base/values.h"
+#include "native_mate/dictionary.h"
+#include "net/base/upload_bytes_element_reader.h"
+#include "net/base/upload_data_stream.h"
+#include "net/base/upload_element_reader.h"
+#include "net/base/upload_file_element_reader.h"
+#include "net/cert/x509_certificate.h"
+#include "net/http/http_response_headers.h"
+#include "net/url_request/url_request.h"
+
+namespace mate {
+
+// static
+v8::Local<v8::Value> Converter<const net::URLRequest*>::ToV8(
+    v8::Isolate* isolate, const net::URLRequest* val) {
+  scoped_ptr<base::DictionaryValue> dict(new base::DictionaryValue);
+  dict->SetString("method", val->method());
+  std::string url;
+  if (!val->url_chain().empty()) url = val->url().spec();
+  dict->SetStringWithoutPathExpansion("url", url);
+  dict->SetString("referrer", val->referrer());
+  scoped_ptr<base::ListValue> list(new base::ListValue);
+  electron::GetUploadData(list.get(), val);
+  if (!list->empty())
+    dict->Set("uploadData", std::move(list));
+  return mate::ConvertToV8(isolate, *(dict.get()));
+}
+
+// static
+v8::Local<v8::Value> Converter<const net::AuthChallengeInfo*>::ToV8(
+    v8::Isolate* isolate, const net::AuthChallengeInfo* val) {
+  mate::Dictionary dict = mate::Dictionary::CreateEmpty(isolate);
+  dict.Set("isProxy", val->is_proxy);
+  dict.Set("scheme", val->scheme);
+  dict.Set("host", val->challenger.host());
+  dict.Set("port", static_cast<uint32_t>(val->challenger.port()));
+  dict.Set("realm", val->realm);
+  return mate::ConvertToV8(isolate, dict);
+}
+
+// static
+v8::Local<v8::Value> Converter<scoped_refptr<net::X509Certificate>>::ToV8(
+    v8::Isolate* isolate, const scoped_refptr<net::X509Certificate>& val) {
+  mate::Dictionary dict(isolate, v8::Object::New(isolate));
+  std::string encoded_data;
+  net::X509Certificate::GetPEMEncoded(
+      val->os_cert_handle(), &encoded_data);
+  auto buffer = node::Buffer::Copy(isolate,
+                                   encoded_data.data(),
+                                   encoded_data.size()).ToLocalChecked();
+  dict.Set("data", buffer);
+  dict.Set("issuerName", val->issuer().GetDisplayName());
+  return dict.GetHandle();
+}
+
+}  // namespace mate
+
+namespace electron {
+
+void GetUploadData(base::ListValue* upload_data_list,
+                   const net::URLRequest* request) {
+  const net::UploadDataStream* upload_data = request->get_upload();
+  if (!upload_data)
+    return;
+  const std::vector<scoped_ptr<net::UploadElementReader>>* readers =
+      upload_data->GetElementReaders();
+  for (const auto& reader : *readers) {
+    scoped_ptr<base::DictionaryValue> upload_data_dict(
+        new base::DictionaryValue);
+    if (reader->AsBytesReader()) {
+      const net::UploadBytesElementReader* bytes_reader =
+          reader->AsBytesReader();
+      scoped_ptr<base::Value> bytes(
+          base::BinaryValue::CreateWithCopiedBuffer(bytes_reader->bytes(),
+                                                    bytes_reader->length()));
+      upload_data_dict->Set("bytes", std::move(bytes));
+    } else if (reader->AsFileReader()) {
+      const net::UploadFileElementReader* file_reader =
+          reader->AsFileReader();
+      auto file_path = file_reader->path().AsUTF8Unsafe();
+      upload_data_dict->SetStringWithoutPathExpansion("file", file_path);
+    }
+    upload_data_list->Append(std::move(upload_data_dict));
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 5527ae4195242262dc2ba1263f0443e2810e2ece electron/common/native_mate_converters/net_converter.h
@@ -0,0 +1,50 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
+
+#include "base/memory/ref_counted.h"
+#include "native_mate/converter.h"
+
+namespace base {
+class ListValue;
+}
+
+namespace net {
+class AuthChallengeInfo;
+class URLRequest;
+class X509Certificate;
+}
+
+namespace mate {
+
+template<>
+struct Converter<const net::URLRequest*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::URLRequest* val);
+};
+
+template<>
+struct Converter<const net::AuthChallengeInfo*> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const net::AuthChallengeInfo* val);
+};
+
+template<>
+struct Converter<scoped_refptr<net::X509Certificate>> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+      const scoped_refptr<net::X509Certificate>& val);
+};
+
+}  // namespace mate
+
+namespace electron {
+
+void GetUploadData(base::ListValue* upload_data_list,
+                   const net::URLRequest* request);
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_NET_CONVERTER_H_
added in remote
  their  100644 db6fb3f5f729b1db5ef0fb4acef3b22a18ee5449 electron/common/native_mate_converters/string16_converter.h
@@ -0,0 +1,40 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
+
+#include "base/strings/string16.h"
+#include "native_mate/converter.h"
+
+namespace mate {
+
+template<>
+struct Converter<base::string16> {
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                    const base::string16& val) {
+    return MATE_STRING_NEW_FROM_UTF16(
+        isolate, reinterpret_cast<const uint16_t*>(val.data()), val.size());
+  }
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::string16* out) {
+    if (!val->IsString())
+      return false;
+
+    v8::String::Value s(val);
+    out->assign(reinterpret_cast<const base::char16*>(*s), s.length());
+    return true;
+  }
+};
+
+inline v8::Local<v8::String> StringToV8(
+    v8::Isolate* isolate,
+    const base::string16& input) {
+  return ConvertToV8(isolate, input).As<v8::String>();
+}
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_STRING16_CONVERTER_H_
added in remote
  their  100644 40d71b0e694d24e5ddce7ccbe699795cf1ecf598 electron/common/native_mate_converters/v8_value_converter.cc
@@ -0,0 +1,410 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+
+#include <map>
+#include <string>
+#include <utility>
+
+#include "base/logging.h"
+#include "base/memory/scoped_ptr.h"
+#include "base/values.h"
+#include "native_mate/dictionary.h"
+#include "vendor/node/src/node_buffer.h"
+
+namespace electron {
+
+namespace {
+
+const int kMaxRecursionDepth = 100;
+
+}  // namespace
+
+// The state of a call to FromV8Value.
+class V8ValueConverter::FromV8ValueState {
+ public:
+  // Level scope which updates the current depth of some FromV8ValueState.
+  class Level {
+   public:
+    explicit Level(FromV8ValueState* state) : state_(state) {
+      state_->max_recursion_depth_--;
+    }
+    ~Level() {
+      state_->max_recursion_depth_++;
+    }
+
+   private:
+    FromV8ValueState* state_;
+  };
+
+  FromV8ValueState() : max_recursion_depth_(kMaxRecursionDepth) {}
+
+  // If |handle| is not in |unique_map_|, then add it to |unique_map_| and
+  // return true.
+  //
+  // Otherwise do nothing and return false. Here "A is unique" means that no
+  // other handle B in the map points to the same object as A. Note that A can
+  // be unique even if there already is another handle with the same identity
+  // hash (key) in the map, because two objects can have the same hash.
+  bool UpdateAndCheckUniqueness(v8::Local<v8::Object> handle) {
+    typedef HashToHandleMap::const_iterator Iterator;
+    int hash = handle->GetIdentityHash();
+    // We only compare using == with handles to objects with the same identity
+    // hash. Different hash obviously means different objects, but two objects
+    // in a couple of thousands could have the same identity hash.
+    std::pair<Iterator, Iterator> range = unique_map_.equal_range(hash);
+    for (Iterator it = range.first; it != range.second; ++it) {
+      // Operator == for handles actually compares the underlying objects.
+      if (it->second == handle)
+        return false;
+    }
+    unique_map_.insert(std::make_pair(hash, handle));
+    return true;
+  }
+
+  bool HasReachedMaxRecursionDepth() {
+    return max_recursion_depth_ < 0;
+  }
+
+ private:
+  typedef std::multimap<int, v8::Local<v8::Object> > HashToHandleMap;
+  HashToHandleMap unique_map_;
+
+  int max_recursion_depth_;
+};
+
+V8ValueConverter::V8ValueConverter()
+    : reg_exp_allowed_(false),
+      function_allowed_(false),
+      strip_null_from_objects_(false) {}
+
+void V8ValueConverter::SetRegExpAllowed(bool val) {
+  reg_exp_allowed_ = val;
+}
+
+void V8ValueConverter::SetFunctionAllowed(bool val) {
+  function_allowed_ = val;
+}
+
+void V8ValueConverter::SetStripNullFromObjects(bool val) {
+  strip_null_from_objects_ = val;
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Value(
+    const base::Value* value, v8::Local<v8::Context> context) const {
+  v8::Context::Scope context_scope(context);
+  v8::EscapableHandleScope handle_scope(context->GetIsolate());
+  return handle_scope.Escape(ToV8ValueImpl(context->GetIsolate(), value));
+}
+
+base::Value* V8ValueConverter::FromV8Value(
+    v8::Local<v8::Value> val,
+    v8::Local<v8::Context> context) const {
+  v8::Context::Scope context_scope(context);
+  v8::HandleScope handle_scope(context->GetIsolate());
+  FromV8ValueState state;
+  return FromV8ValueImpl(&state, val, context->GetIsolate());
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8ValueImpl(
+     v8::Isolate* isolate, const base::Value* value) const {
+  CHECK(value);
+  switch (value->GetType()) {
+    case base::Value::TYPE_NULL:
+      return v8::Null(isolate);
+
+    case base::Value::TYPE_BOOLEAN: {
+      bool val = false;
+      CHECK(value->GetAsBoolean(&val));
+      return v8::Boolean::New(isolate, val);
+    }
+
+    case base::Value::TYPE_INTEGER: {
+      int val = 0;
+      CHECK(value->GetAsInteger(&val));
+      return v8::Integer::New(isolate, val);
+    }
+
+    case base::Value::TYPE_DOUBLE: {
+      double val = 0.0;
+      CHECK(value->GetAsDouble(&val));
+      return v8::Number::New(isolate, val);
+    }
+
+    case base::Value::TYPE_STRING: {
+      std::string val;
+      CHECK(value->GetAsString(&val));
+      return v8::String::NewFromUtf8(
+          isolate, val.c_str(), v8::String::kNormalString, val.length());
+    }
+
+    case base::Value::TYPE_LIST:
+      return ToV8Array(isolate, static_cast<const base::ListValue*>(value));
+
+    case base::Value::TYPE_DICTIONARY:
+      return ToV8Object(isolate,
+                        static_cast<const base::DictionaryValue*>(value));
+
+    case base::Value::TYPE_BINARY:
+      return ToArrayBuffer(isolate,
+                           static_cast<const base::BinaryValue*>(value));
+
+    default:
+      LOG(ERROR) << "Unexpected value type: " << value->GetType();
+      return v8::Null(isolate);
+  }
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Array(
+    v8::Isolate* isolate, const base::ListValue* val) const {
+  v8::Local<v8::Array> result(v8::Array::New(isolate, val->GetSize()));
+
+  for (size_t i = 0; i < val->GetSize(); ++i) {
+    const base::Value* child = NULL;
+    CHECK(val->Get(i, &child));
+
+    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, child);
+    CHECK(!child_v8.IsEmpty());
+
+    v8::TryCatch try_catch;
+    result->Set(static_cast<uint32_t>(i), child_v8);
+    if (try_catch.HasCaught())
+      LOG(ERROR) << "Setter for index " << i << " threw an exception.";
+  }
+
+  return result;
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToV8Object(
+    v8::Isolate* isolate, const base::DictionaryValue* val) const {
+  mate::Dictionary result = mate::Dictionary::CreateEmpty(isolate);
+  result.SetHidden("simple", true);
+
+  for (base::DictionaryValue::Iterator iter(*val);
+       !iter.IsAtEnd(); iter.Advance()) {
+    const std::string& key = iter.key();
+    v8::Local<v8::Value> child_v8 = ToV8ValueImpl(isolate, &iter.value());
+    CHECK(!child_v8.IsEmpty());
+
+    v8::TryCatch try_catch;
+    result.Set(key, child_v8);
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Setter for property " << key.c_str() << " threw an "
+                 << "exception.";
+    }
+  }
+
+  return result.GetHandle();
+}
+
+v8::Local<v8::Value> V8ValueConverter::ToArrayBuffer(
+    v8::Isolate* isolate, const base::BinaryValue* value) const {
+  return node::Buffer::Copy(isolate,
+                            value->GetBuffer(),
+                            value->GetSize()).ToLocalChecked();
+}
+
+base::Value* V8ValueConverter::FromV8ValueImpl(
+    FromV8ValueState* state,
+    v8::Local<v8::Value> val,
+    v8::Isolate* isolate) const {
+  CHECK(!val.IsEmpty());
+
+  FromV8ValueState::Level state_level(state);
+  if (state->HasReachedMaxRecursionDepth())
+    return NULL;
+
+  if (val->IsNull())
+    return base::Value::CreateNullValue().release();
+
+  if (val->IsBoolean())
+    return new base::FundamentalValue(val->ToBoolean()->Value());
+
+  if (val->IsInt32())
+    return new base::FundamentalValue(val->ToInt32()->Value());
+
+  if (val->IsNumber())
+    return new base::FundamentalValue(val->ToNumber()->Value());
+
+  if (val->IsString()) {
+    v8::String::Utf8Value utf8(val->ToString());
+    return new base::StringValue(std::string(*utf8, utf8.length()));
+  }
+
+  if (val->IsUndefined())
+    // JSON.stringify ignores undefined.
+    return NULL;
+
+  if (val->IsDate()) {
+    v8::Date* date = v8::Date::Cast(*val);
+    v8::Local<v8::Value> toISOString =
+        date->Get(v8::String::NewFromUtf8(isolate, "toISOString"));
+    if (toISOString->IsFunction()) {
+      v8::Local<v8::Value> result =
+          toISOString.As<v8::Function>()->Call(val, 0, nullptr);
+      if (!result.IsEmpty()) {
+        v8::String::Utf8Value utf8(result->ToString());
+        return new base::StringValue(std::string(*utf8, utf8.length()));
+      }
+    }
+  }
+
+  if (val->IsRegExp()) {
+    if (!reg_exp_allowed_)
+      // JSON.stringify converts to an object.
+      return FromV8Object(val->ToObject(), state, isolate);
+    return new base::StringValue(*v8::String::Utf8Value(val->ToString()));
+  }
+
+  // v8::Value doesn't have a ToArray() method for some reason.
+  if (val->IsArray())
+    return FromV8Array(val.As<v8::Array>(), state, isolate);
+
+  if (val->IsFunction()) {
+    if (!function_allowed_)
+      // JSON.stringify refuses to convert function(){}.
+      return NULL;
+    return FromV8Object(val->ToObject(), state, isolate);
+  }
+
+  if (node::Buffer::HasInstance(val)) {
+    return FromNodeBuffer(val, state, isolate);
+  }
+
+  if (val->IsObject()) {
+    return FromV8Object(val->ToObject(), state, isolate);
+  }
+
+  LOG(ERROR) << "Unexpected v8 value type encountered.";
+  return NULL;
+}
+
+base::Value* V8ValueConverter::FromV8Array(
+    v8::Local<v8::Array> val,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  if (!state->UpdateAndCheckUniqueness(val))
+    return base::Value::CreateNullValue().release();
+
+  scoped_ptr<v8::Context::Scope> scope;
+  // If val was created in a different context than our current one, change to
+  // that context, but change back after val is converted.
+  if (!val->CreationContext().IsEmpty() &&
+      val->CreationContext() != isolate->GetCurrentContext())
+    scope.reset(new v8::Context::Scope(val->CreationContext()));
+
+  base::ListValue* result = new base::ListValue();
+
+  // Only fields with integer keys are carried over to the ListValue.
+  for (uint32_t i = 0; i < val->Length(); ++i) {
+    v8::TryCatch try_catch;
+    v8::Local<v8::Value> child_v8 = val->Get(i);
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Getter for index " << i << " threw an exception.";
+      child_v8 = v8::Null(isolate);
+    }
+
+    if (!val->HasRealIndexedProperty(i))
+      continue;
+
+    base::Value* child = FromV8ValueImpl(state, child_v8, isolate);
+    if (child)
+      result->Append(child);
+    else
+      // JSON.stringify puts null in places where values don't serialize, for
+      // example undefined and functions. Emulate that behavior.
+      result->Append(base::Value::CreateNullValue());
+  }
+  return result;
+}
+
+base::Value* V8ValueConverter::FromNodeBuffer(
+    v8::Local<v8::Value> value,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  return base::BinaryValue::CreateWithCopiedBuffer(
+      node::Buffer::Data(value), node::Buffer::Length(value));
+}
+
+base::Value* V8ValueConverter::FromV8Object(
+    v8::Local<v8::Object> val,
+    FromV8ValueState* state,
+    v8::Isolate* isolate) const {
+  if (!state->UpdateAndCheckUniqueness(val))
+    return base::Value::CreateNullValue().release();
+
+  scoped_ptr<v8::Context::Scope> scope;
+  // If val was created in a different context than our current one, change to
+  // that context, but change back after val is converted.
+  if (!val->CreationContext().IsEmpty() &&
+      val->CreationContext() != isolate->GetCurrentContext())
+    scope.reset(new v8::Context::Scope(val->CreationContext()));
+
+  scoped_ptr<base::DictionaryValue> result(new base::DictionaryValue());
+  v8::Local<v8::Array> property_names(val->GetOwnPropertyNames());
+
+  for (uint32_t i = 0; i < property_names->Length(); ++i) {
+    v8::Local<v8::Value> key(property_names->Get(i));
+
+    // Extend this test to cover more types as necessary and if sensible.
+    if (!key->IsString() &&
+        !key->IsNumber()) {
+      NOTREACHED() << "Key \"" << *v8::String::Utf8Value(key) << "\" "
+                      "is neither a string nor a number";
+      continue;
+    }
+
+    // Skip all callbacks: crbug.com/139933
+    if (val->HasRealNamedCallbackProperty(key->ToString()))
+      continue;
+
+    v8::String::Utf8Value name_utf8(key->ToString());
+
+    v8::TryCatch try_catch;
+    v8::Local<v8::Value> child_v8 = val->Get(key);
+
+    if (try_catch.HasCaught()) {
+      LOG(ERROR) << "Getter for property " << *name_utf8
+                 << " threw an exception.";
+      child_v8 = v8::Null(isolate);
+    }
+
+    scoped_ptr<base::Value> child(FromV8ValueImpl(state, child_v8, isolate));
+    if (!child.get())
+      // JSON.stringify skips properties whose values don't serialize, for
+      // example undefined and functions. Emulate that behavior.
+      continue;
+
+    // Strip null if asked (and since undefined is turned into null, undefined
+    // too). The use case for supporting this is JSON-schema support,
+    // specifically for extensions, where "optional" JSON properties may be
+    // represented as null, yet due to buggy legacy code elsewhere isn't
+    // treated as such (potentially causing crashes). For example, the
+    // "tabs.create" function takes an object as its first argument with an
+    // optional "windowId" property.
+    //
+    // Given just
+    //
+    //   tabs.create({})
+    //
+    // this will work as expected on code that only checks for the existence of
+    // a "windowId" property (such as that legacy code). However given
+    //
+    //   tabs.create({windowId: null})
+    //
+    // there *is* a "windowId" property, but since it should be an int, code
+    // on the browser which doesn't additionally check for null will fail.
+    // We can avoid all bugs related to this by stripping null.
+    if (strip_null_from_objects_ && child->IsType(base::Value::TYPE_NULL))
+      continue;
+
+    result->SetWithoutPathExpansion(std::string(*name_utf8, name_utf8.length()),
+                                    child.release());
+  }
+
+  return result.release();
+}
+
+}  // namespace electron
added in remote
  their  100644 9b1d76d15de1bd8354b4715b05c15a1ee64595c0 electron/common/native_mate_converters/v8_value_converter.h
@@ -0,0 +1,75 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
+
+#include "base/macros.h"
+#include "base/compiler_specific.h"
+#include "v8/include/v8.h"
+
+namespace base {
+class BinaryValue;
+class DictionaryValue;
+class ListValue;
+class Value;
+}
+
+namespace electron {
+
+class V8ValueConverter {
+ public:
+  V8ValueConverter();
+
+  void SetRegExpAllowed(bool val);
+  void SetFunctionAllowed(bool val);
+  void SetStripNullFromObjects(bool val);
+  v8::Local<v8::Value> ToV8Value(const base::Value* value,
+                                 v8::Local<v8::Context> context) const;
+  base::Value* FromV8Value(v8::Local<v8::Value> value,
+                           v8::Local<v8::Context> context) const;
+
+ private:
+  class FromV8ValueState;
+
+  v8::Local<v8::Value> ToV8ValueImpl(v8::Isolate* isolate,
+                                     const base::Value* value) const;
+  v8::Local<v8::Value> ToV8Array(v8::Isolate* isolate,
+                                 const base::ListValue* list) const;
+  v8::Local<v8::Value> ToV8Object(
+      v8::Isolate* isolate,
+      const base::DictionaryValue* dictionary) const;
+  v8::Local<v8::Value> ToArrayBuffer(
+      v8::Isolate* isolate,
+      const base::BinaryValue* value) const;
+
+  base::Value* FromV8ValueImpl(FromV8ValueState* state,
+                               v8::Local<v8::Value> value,
+                               v8::Isolate* isolate) const;
+  base::Value* FromV8Array(v8::Local<v8::Array> array,
+                           FromV8ValueState* state,
+                           v8::Isolate* isolate) const;
+  base::Value* FromNodeBuffer(v8::Local<v8::Value> value,
+                              FromV8ValueState* state,
+                              v8::Isolate* isolate) const;
+  base::Value* FromV8Object(v8::Local<v8::Object> object,
+                            FromV8ValueState* state,
+                            v8::Isolate* isolate) const;
+
+  // If true, we will convert RegExp JavaScript objects to string.
+  bool reg_exp_allowed_;
+
+  // If true, we will convert Function JavaScript objects to dictionaries.
+  bool function_allowed_;
+
+  // If true, undefined and null values are ignored when converting v8 objects
+  // into Values.
+  bool strip_null_from_objects_;
+
+  DISALLOW_COPY_AND_ASSIGN(V8ValueConverter);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_V8_VALUE_CONVERTER_H_
added in remote
  their  100644 25689927d9c4edaf1229ddbf424b94e9461a886e electron/common/native_mate_converters/value_converter.cc
@@ -0,0 +1,54 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/native_mate_converters/value_converter.h"
+
+#include "electron/common/native_mate_converters/v8_value_converter.h"
+#include "base/values.h"
+
+namespace mate {
+
+bool Converter<base::DictionaryValue>::FromV8(v8::Isolate* isolate,
+                                              v8::Local<v8::Value> val,
+                                              base::DictionaryValue* out) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  scoped_ptr<base::Value> value(converter->FromV8Value(
+      val, isolate->GetCurrentContext()));
+  if (value && value->IsType(base::Value::TYPE_DICTIONARY)) {
+    out->Swap(static_cast<base::DictionaryValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::DictionaryValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::DictionaryValue& val) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  return converter->ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+bool Converter<base::ListValue>::FromV8(v8::Isolate* isolate,
+                                        v8::Local<v8::Value> val,
+                                        base::ListValue* out) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  scoped_ptr<base::Value> value(converter->FromV8Value(
+      val, isolate->GetCurrentContext()));
+  if (value->IsType(base::Value::TYPE_LIST)) {
+    out->Swap(static_cast<base::ListValue*>(value.get()));
+    return true;
+  } else {
+    return false;
+  }
+}
+
+v8::Local<v8::Value> Converter<base::ListValue>::ToV8(
+    v8::Isolate* isolate,
+    const base::ListValue& val) {
+  scoped_ptr<electron::V8ValueConverter> converter(new electron::V8ValueConverter);
+  return converter->ToV8Value(&val, isolate->GetCurrentContext());
+}
+
+}  // namespace mate
added in remote
  their  100644 661cbcc37968bc47994e95f64d66c8cbc2110af7 electron/common/native_mate_converters/value_converter.h
@@ -0,0 +1,37 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
+#define ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
+
+#include "native_mate/converter.h"
+
+namespace base {
+class DictionaryValue;
+class ListValue;
+}
+
+namespace mate {
+
+template<>
+struct Converter<base::DictionaryValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::DictionaryValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::DictionaryValue& val);
+};
+
+template<>
+struct Converter<base::ListValue> {
+  static bool FromV8(v8::Isolate* isolate,
+                     v8::Local<v8::Value> val,
+                     base::ListValue* out);
+  static v8::Local<v8::Value> ToV8(v8::Isolate* isolate,
+                                   const base::ListValue& val);
+};
+
+}  // namespace mate
+
+#endif  // ELECTRON_COMMON_NATIVE_MATE_CONVERTERS_VALUE_CONVERTER_H_
added in remote
  their  100644 eb5f2255261f0d185291279482eda55548167426 electron/common/node_bindings.cc
@@ -0,0 +1,272 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/api/locker.h"
+#include "electron/common/electron_command_line.h"
+#include "electron/common/native_mate_converters/file_path_converter.h"
+#include "electron/common/node_includes.h"
+#include "base/command_line.h"
+#include "base/base_paths.h"
+#include "base/environment.h"
+#include "base/files/file_path.h"
+#include "base/message_loop/message_loop.h"
+#include "base/path_service.h"
+#include "content/public/browser/browser_thread.h"
+#include "content/public/common/content_paths.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebScopedMicrotaskSuppression.h"
+
+using content::BrowserThread;
+
+// Force all builtin modules to be referenced so they can actually run their
+// DSO constructors, see http://git.io/DRIqCg.
+#define REFERENCE_MODULE(name) \
+  extern "C" void _register_ ## name(void); \
+  void (*fp_register_ ## name)(void) = _register_ ## name
+// Electron's builtin modules.
+REFERENCE_MODULE(electron_browser_app);
+REFERENCE_MODULE(electron_browser_auto_updater);
+REFERENCE_MODULE(electron_browser_content_tracing);
+REFERENCE_MODULE(electron_browser_dialog);
+REFERENCE_MODULE(electron_browser_debugger);
+REFERENCE_MODULE(electron_browser_desktop_capturer);
+REFERENCE_MODULE(electron_browser_download_item);
+REFERENCE_MODULE(electron_browser_menu);
+REFERENCE_MODULE(electron_browser_power_monitor);
+REFERENCE_MODULE(electron_browser_power_save_blocker);
+REFERENCE_MODULE(electron_browser_protocol);
+REFERENCE_MODULE(electron_browser_global_shortcut);
+REFERENCE_MODULE(electron_browser_session);
+REFERENCE_MODULE(electron_browser_tray);
+REFERENCE_MODULE(electron_browser_web_contents);
+REFERENCE_MODULE(electron_browser_web_view_manager);
+REFERENCE_MODULE(electron_browser_window);
+REFERENCE_MODULE(electron_common_asar);
+REFERENCE_MODULE(electron_common_clipboard);
+REFERENCE_MODULE(electron_common_crash_reporter);
+REFERENCE_MODULE(electron_common_id_weak_map);
+REFERENCE_MODULE(electron_common_native_image);
+REFERENCE_MODULE(electron_common_screen);
+REFERENCE_MODULE(electron_common_shell);
+REFERENCE_MODULE(electron_common_v8_util);
+REFERENCE_MODULE(electron_renderer_ipc);
+REFERENCE_MODULE(electron_renderer_web_frame);
+#undef REFERENCE_MODULE
+
+// The "v8::Function::kLineOffsetNotFound" is exported in node.dll, but the
+// linker can not find it, could be a bug of VS.
+#if defined(OS_WIN) && !defined(DEBUG)
+namespace v8 {
+const int Function::kLineOffsetNotFound = -1;
+}
+#endif
+
+namespace electron {
+
+namespace {
+
+// Empty callback for async handle.
+void UvNoOp(uv_async_t* handle) {
+}
+
+// Convert the given vector to an array of C-strings. The strings in the
+// returned vector are only guaranteed valid so long as the vector of strings
+// is not modified.
+scoped_ptr<const char*[]> StringVectorToArgArray(
+    const std::vector<std::string>& vector) {
+  scoped_ptr<const char*[]> array(new const char*[vector.size()]);
+  for (size_t i = 0; i < vector.size(); ++i) {
+    array[i] = vector[i].c_str();
+  }
+  return array;
+}
+
+base::FilePath GetResourcesPath(bool is_browser) {
+  auto command_line = base::CommandLine::ForCurrentProcess();
+  base::FilePath exec_path(command_line->GetProgram());
+  PathService::Get(base::FILE_EXE, &exec_path);
+
+  base::FilePath resources_path =
+#if defined(OS_MACOSX)
+      is_browser ? exec_path.DirName().DirName().Append("Resources") :
+                   exec_path.DirName().DirName().DirName().DirName().DirName()
+                            .Append("Resources");
+#else
+      exec_path.DirName().Append(FILE_PATH_LITERAL("resources"));
+#endif
+  return resources_path;
+}
+
+}  // namespace
+
+NodeBindings::NodeBindings(bool is_browser)
+    : is_browser_(is_browser),
+      message_loop_(nullptr),
+      uv_loop_(uv_default_loop()),
+      embed_closed_(false),
+      uv_env_(nullptr),
+      weak_factory_(this) {
+}
+
+NodeBindings::~NodeBindings() {
+  // Quit the embed thread.
+  embed_closed_ = true;
+  uv_sem_post(&embed_sem_);
+  WakeupEmbedThread();
+
+  // Wait for everything to be done.
+  uv_thread_join(&embed_thread_);
+
+  // Clear uv.
+  uv_sem_destroy(&embed_sem_);
+}
+
+void NodeBindings::Initialize() {
+  // Open node's error reporting system for browser process.
+  node::g_standalone_mode = is_browser_;
+  node::g_upstream_node_mode = false;
+
+#if defined(OS_LINUX)
+  // Get real command line in renderer process forked by zygote.
+  if (!is_browser_)
+    ElectronCommandLine::InitializeFromCommandLine();
+#endif
+
+  // Init node.
+  // (we assume node::Init would not modify the parameters under embedded mode).
+  node::Init(nullptr, nullptr, nullptr, nullptr);
+
+#if defined(OS_WIN)
+  // uv_init overrides error mode to suppress the default crash dialog, bring
+  // it back if user wants to show it.
+  scoped_ptr<base::Environment> env(base::Environment::Create());
+  if (env->HasVar("ELECTRON_DEFAULT_ERROR_MODE"))
+    SetErrorMode(0);
+#endif
+}
+
+node::Environment* NodeBindings::CreateEnvironment(
+    v8::Handle<v8::Context> context) {
+  auto args = ElectronCommandLine::argv();
+
+  // Feed node the path to initialization script.
+  base::FilePath::StringType process_type = is_browser_ ?
+      FILE_PATH_LITERAL("browser") : FILE_PATH_LITERAL("renderer");
+  base::FilePath resources_path = GetResourcesPath(is_browser_);
+  base::FilePath script_path =
+      resources_path.Append(FILE_PATH_LITERAL("electron.asar"))
+                    .Append(process_type)
+                    .Append(FILE_PATH_LITERAL("init.js"));
+  std::string script_path_str = script_path.AsUTF8Unsafe();
+  args.insert(args.begin() + 1, script_path_str.c_str());
+
+  scoped_ptr<const char*[]> c_argv = StringVectorToArgArray(args);
+  node::Environment* env = node::CreateEnvironment(
+      context->GetIsolate(), uv_default_loop(), context,
+      args.size(), c_argv.get(), 0, nullptr);
+
+  mate::Dictionary process(context->GetIsolate(), env->process_object());
+  process.Set("type", process_type);
+  process.Set("resourcesPath", resources_path);
+  // The path to helper app.
+  base::FilePath helper_exec_path;
+  PathService::Get(content::CHILD_PROCESS_EXE, &helper_exec_path);
+  process.Set("helperExecPath", helper_exec_path);
+  return env;
+}
+
+void NodeBindings::LoadEnvironment(node::Environment* env) {
+  node::LoadEnvironment(env);
+  mate::EmitEvent(env->isolate(), env->process_object(), "loaded");
+}
+
+void NodeBindings::PrepareMessageLoop() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // Add dummy handle for libuv, otherwise libuv would quit when there is
+  // nothing to do.
+  uv_async_init(uv_loop_, &dummy_uv_handle_, UvNoOp);
+
+  // Start worker that will interrupt main loop when having uv events.
+  uv_sem_init(&embed_sem_, 0);
+  uv_thread_create(&embed_thread_, EmbedThreadRunner, this);
+}
+
+void NodeBindings::RunMessageLoop() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  // The MessageLoop should have been created, remember the one in main thread.
+  message_loop_ = base::MessageLoop::current();
+
+  // Run uv loop for once to give the uv__io_poll a chance to add all events.
+  UvRunOnce();
+}
+
+void NodeBindings::UvRunOnce() {
+  DCHECK(!is_browser_ || BrowserThread::CurrentlyOn(BrowserThread::UI));
+
+  node::Environment* env = uv_env();
+  CHECK(env);
+
+  // Use Locker in browser process.
+  mate::Locker locker(env->isolate());
+  v8::HandleScope handle_scope(env->isolate());
+
+  // Enter node context while dealing with uv events.
+  v8::Context::Scope context_scope(env->context());
+
+  // Perform microtask checkpoint after running JavaScript.
+  scoped_ptr<blink::WebScopedRunV8Script> script_scope(
+      is_browser_ ? nullptr : new blink::WebScopedRunV8Script);
+
+  // Deal with uv events.
+  int r = uv_run(uv_loop_, UV_RUN_NOWAIT);
+  if (r == 0 || uv_loop_->stop_flag != 0)
+    message_loop_->QuitWhenIdle();  // Quit from uv.
+
+  // Tell the worker thread to continue polling.
+  uv_sem_post(&embed_sem_);
+}
+
+void NodeBindings::WakeupMainThread() {
+  DCHECK(message_loop_);
+  message_loop_->PostTask(FROM_HERE, base::Bind(&NodeBindings::UvRunOnce,
+                                                weak_factory_.GetWeakPtr()));
+}
+
+void NodeBindings::WakeupEmbedThread() {
+  uv_async_send(&dummy_uv_handle_);
+}
+
+// static
+void NodeBindings::EmbedThreadRunner(void *arg) {
+  NodeBindings* self = static_cast<NodeBindings*>(arg);
+
+  while (true) {
+    // Wait for the main loop to deal with events.
+    uv_sem_wait(&self->embed_sem_);
+    if (self->embed_closed_)
+      break;
+
+    // Wait for something to happen in uv loop.
+    // Note that the PollEvents() is implemented by derived classes, so when
+    // this class is being destructed the PollEvents() would not be available
+    // anymore. Because of it we must make sure we only invoke PollEvents()
+    // when this class is alive.
+    self->PollEvents();
+    if (self->embed_closed_)
+      break;
+
+    // Deal with event in main thread.
+    self->WakeupMainThread();
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 39f471883b143caab1502d04157ace731128b74a electron/common/node_bindings.h
@@ -0,0 +1,98 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_H_
+
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "v8/include/v8.h"
+#include "vendor/node/deps/uv/include/uv.h"
+
+namespace base {
+class MessageLoop;
+}
+
+namespace node {
+class Environment;
+}
+
+namespace electron {
+
+class NodeBindings {
+ public:
+  static NodeBindings* Create(bool is_browser);
+
+  virtual ~NodeBindings();
+
+  // Setup V8, libuv.
+  void Initialize();
+
+  // Create the environment and load node.js.
+  node::Environment* CreateEnvironment(v8::Handle<v8::Context> context);
+
+  // Load node.js in the environment.
+  void LoadEnvironment(node::Environment* env);
+
+  // Prepare for message loop integration.
+  void PrepareMessageLoop();
+
+  // Do message loop integration.
+  virtual void RunMessageLoop();
+
+  // Gets/sets the environment to wrap uv loop.
+  void set_uv_env(node::Environment* env) { uv_env_ = env; }
+  node::Environment* uv_env() const { return uv_env_; }
+
+ protected:
+  explicit NodeBindings(bool is_browser);
+
+  // Called to poll events in new thread.
+  virtual void PollEvents() = 0;
+
+  // Run the libuv loop for once.
+  void UvRunOnce();
+
+  // Make the main thread run libuv loop.
+  void WakeupMainThread();
+
+  // Interrupt the PollEvents.
+  void WakeupEmbedThread();
+
+  // Are we running in browser.
+  bool is_browser_;
+
+  // Main thread's MessageLoop.
+  base::MessageLoop* message_loop_;
+
+  // Main thread's libuv loop.
+  uv_loop_t* uv_loop_;
+
+ private:
+  // Thread to poll uv events.
+  static void EmbedThreadRunner(void *arg);
+
+  // Whether the libuv loop has ended.
+  bool embed_closed_;
+
+  // Dummy handle to make uv's loop not quit.
+  uv_async_t dummy_uv_handle_;
+
+  // Thread for polling events.
+  uv_thread_t embed_thread_;
+
+  // Semaphore to wait for main loop in the embed thread.
+  uv_sem_t embed_sem_;
+
+  // Environment that to wrap the uv loop.
+  node::Environment* uv_env_;
+
+  base::WeakPtrFactory<NodeBindings> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindings);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_H_
added in remote
  their  100644 9c3e4f7606e94203b044e099a96bcdd005de1b10 electron/common/node_bindings_linux.cc
@@ -0,0 +1,57 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_linux.h"
+
+#include <sys/epoll.h>
+
+namespace electron {
+
+NodeBindingsLinux::NodeBindingsLinux(bool is_browser)
+    : NodeBindings(is_browser),
+      epoll_(epoll_create(1)) {
+  int backend_fd = uv_backend_fd(uv_loop_);
+  struct epoll_event ev = { 0 };
+  ev.events = EPOLLIN;
+  ev.data.fd = backend_fd;
+  epoll_ctl(epoll_, EPOLL_CTL_ADD, backend_fd, &ev);
+}
+
+NodeBindingsLinux::~NodeBindingsLinux() {
+}
+
+void NodeBindingsLinux::RunMessageLoop() {
+  // Get notified when libuv's watcher queue changes.
+  uv_loop_->data = this;
+  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
+
+  NodeBindings::RunMessageLoop();
+}
+
+// static
+void NodeBindingsLinux::OnWatcherQueueChanged(uv_loop_t* loop) {
+  NodeBindingsLinux* self = static_cast<NodeBindingsLinux*>(loop->data);
+
+  // We need to break the io polling in the epoll thread when loop's watcher
+  // queue changes, otherwise new events cannot be notified.
+  self->WakeupEmbedThread();
+}
+
+void NodeBindingsLinux::PollEvents() {
+  int timeout = uv_backend_timeout(uv_loop_);
+
+  // Wait for new libuv events.
+  int r;
+  do {
+    struct epoll_event ev;
+    r = epoll_wait(epoll_, &ev, 1, timeout);
+  } while (r == -1 && errno == EINTR);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsLinux(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 b2e77d1aeaa894f97273b8eec7f63e3492f1178d electron/common/node_bindings_linux.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
+
+#include "base/compiler_specific.h"
+#include "electron/common/node_bindings.h"
+
+namespace electron {
+
+class NodeBindingsLinux : public NodeBindings {
+ public:
+  explicit NodeBindingsLinux(bool is_browser);
+  virtual ~NodeBindingsLinux();
+
+  void RunMessageLoop() override;
+
+ private:
+  // Called when uv's watcher queue changes.
+  static void OnWatcherQueueChanged(uv_loop_t* loop);
+
+  void PollEvents() override;
+
+  // Epoll to poll for uv's backend fd.
+  int epoll_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsLinux);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_LINUX_H_
added in remote
  their  100644 fce1852f2946aa2533a559c1c465f0dbaa7a97d8 electron/common/node_bindings_mac.cc
@@ -0,0 +1,68 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_mac.h"
+
+#include <errno.h>
+#include <sys/sysctl.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+NodeBindingsMac::NodeBindingsMac(bool is_browser)
+    : NodeBindings(is_browser),
+      kqueue_(kqueue()) {
+  // Add uv's backend fd to kqueue.
+  struct kevent ev;
+  EV_SET(&ev, uv_backend_fd(uv_loop_), EVFILT_READ, EV_ADD | EV_ENABLE,
+         0, 0, 0);
+  kevent(kqueue_, &ev, 1, NULL, 0, NULL);
+}
+
+NodeBindingsMac::~NodeBindingsMac() {
+}
+
+void NodeBindingsMac::RunMessageLoop() {
+  // Get notified when libuv's watcher queue changes.
+  uv_loop_->data = this;
+  uv_loop_->on_watcher_queue_updated = OnWatcherQueueChanged;
+
+  NodeBindings::RunMessageLoop();
+}
+
+// static
+void NodeBindingsMac::OnWatcherQueueChanged(uv_loop_t* loop) {
+  NodeBindingsMac* self = static_cast<NodeBindingsMac*>(loop->data);
+
+  // We need to break the io polling in the kqueue thread when loop's watcher
+  // queue changes, otherwise new events cannot be notified.
+  self->WakeupEmbedThread();
+}
+
+void NodeBindingsMac::PollEvents() {
+  struct timespec spec;
+  int timeout = uv_backend_timeout(uv_loop_);
+  if (timeout != -1) {
+    spec.tv_sec = timeout / 1000;
+    spec.tv_nsec = (timeout % 1000) * 1000000;
+  }
+
+  // Wait for new libuv events.
+  int r;
+  do {
+    struct kevent ev;
+    r = ::kevent(kqueue_, NULL, 0, &ev, 1,
+                 timeout == -1 ? NULL : &spec);
+  } while (r == -1 && errno == EINTR);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsMac(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 e4c8c7c11e1c2b75d9994f876c8f5d2fbce0a9a2 electron/common/node_bindings_mac.h
@@ -0,0 +1,34 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
+
+#include "electron/common/node_bindings.h"
+#include "base/compiler_specific.h"
+
+namespace electron {
+
+class NodeBindingsMac : public NodeBindings {
+ public:
+  explicit NodeBindingsMac(bool is_browser);
+  virtual ~NodeBindingsMac();
+
+  void RunMessageLoop() override;
+
+ private:
+  // Called when uv's watcher queue changes.
+  static void OnWatcherQueueChanged(uv_loop_t* loop);
+
+  void PollEvents() override;
+
+  // Kqueue to poll for uv's backend fd.
+  int kqueue_;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsMac);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_MAC_H_
added in remote
  their  100644 ca0b40490c698ca833f109208c9ba5c533a0874d electron/common/node_bindings_win.cc
@@ -0,0 +1,52 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/node_bindings_win.h"
+
+#include <windows.h>
+
+#include "base/logging.h"
+
+extern "C" {
+#include "vendor/node/deps/uv/src/win/internal.h"
+}
+
+namespace electron {
+
+NodeBindingsWin::NodeBindingsWin(bool is_browser)
+    : NodeBindings(is_browser) {
+}
+
+NodeBindingsWin::~NodeBindingsWin() {
+}
+
+void NodeBindingsWin::PollEvents() {
+  // If there are other kinds of events pending, uv_backend_timeout will
+  // instruct us not to wait.
+  DWORD bytes, timeout;
+  ULONG_PTR key;
+  OVERLAPPED* overlapped;
+
+  timeout = uv_backend_timeout(uv_loop_);
+
+  GetQueuedCompletionStatus(uv_loop_->iocp,
+                            &bytes,
+                            &key,
+                            &overlapped,
+                            timeout);
+
+  // Give the event back so libuv can deal with it.
+  if (overlapped != NULL)
+    PostQueuedCompletionStatus(uv_loop_->iocp,
+                               bytes,
+                               key,
+                               overlapped);
+}
+
+// static
+NodeBindings* NodeBindings::Create(bool is_browser) {
+  return new NodeBindingsWin(is_browser);
+}
+
+}  // namespace electron
added in remote
  their  100644 c6599fe682c3bbc91abb6c619bce46605ca7a747 electron/common/node_bindings_win.h
@@ -0,0 +1,26 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
+#define ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
+
+#include "electron/common/node_bindings.h"
+#include "base/compiler_specific.h"
+
+namespace electron {
+
+class NodeBindingsWin : public NodeBindings {
+ public:
+  explicit NodeBindingsWin(bool is_browser);
+  virtual ~NodeBindingsWin();
+
+ private:
+  void PollEvents() override;
+
+  DISALLOW_COPY_AND_ASSIGN(NodeBindingsWin);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_NODE_BINDINGS_WIN_H_
added in remote
  their  100644 57c82cb5ba4555bd957f764656fd2c9964703111 electron/common/node_includes.h
@@ -0,0 +1,31 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_NODE_INCLUDES_H_
+#define ELECTRON_COMMON_NODE_INCLUDES_H_
+
+#include "base/logging.h"
+
+// Include common headers for using node APIs.
+
+#define BUILDING_NODE_EXTENSION
+
+#undef ASSERT
+#undef CHECK
+#undef CHECK_EQ
+#undef CHECK_NE
+#undef CHECK_GE
+#undef CHECK_GT
+#undef CHECK_LE
+#undef CHECK_LT
+#undef DISALLOW_COPY_AND_ASSIGN
+#undef NO_RETURN
+#undef debug_string  // This is defined in OS X 10.9 SDK in AssertMacros.h.
+#include "vendor/node/src/env.h"
+#include "vendor/node/src/env-inl.h"
+#include "vendor/node/src/node.h"
+#include "vendor/node/src/node_buffer.h"
+#include "vendor/node/src/node_internals.h"
+
+#endif  // ELECTRON_COMMON_NODE_INCLUDES_H_
added in remote
  their  100644 1aa8c5e403f2468b076a0098532cb9e6d40ccff8 electron/common/options_switches.cc
@@ -0,0 +1,160 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/options_switches.h"
+
+namespace electron {
+
+namespace options {
+
+const char kTitle[]          = "title";
+const char kIcon[]           = "icon";
+const char kFrame[]          = "frame";
+const char kShow[]           = "show";
+const char kCenter[]         = "center";
+const char kX[]              = "x";
+const char kY[]              = "y";
+const char kWidth[]          = "width";
+const char kHeight[]         = "height";
+const char kMinWidth[]       = "minWidth";
+const char kMinHeight[]      = "minHeight";
+const char kMaxWidth[]       = "maxWidth";
+const char kMaxHeight[]      = "maxHeight";
+const char kResizable[]      = "resizable";
+const char kMovable[]        = "movable";
+const char kMinimizable[]    = "minimizable";
+const char kMaximizable[]    = "maximizable";
+const char kFullScreenable[] = "fullscreenable";
+const char kClosable[]       = "closable";
+const char kFullscreen[]     = "fullscreen";
+
+// Whether the window should show in taskbar.
+const char kSkipTaskbar[] = "skipTaskbar";
+
+// Start with the kiosk mode, see Opera's page for description:
+// http://www.opera.com/support/mastering/kiosk/
+const char kKiosk[] = "kiosk";
+
+// Make windows stays on the top of all other windows.
+const char kAlwaysOnTop[] = "alwaysOnTop";
+
+// Enable the NSView to accept first mouse event.
+const char kAcceptFirstMouse[] = "acceptFirstMouse";
+
+// Whether window size should include window frame.
+const char kUseContentSize[] = "useContentSize";
+
+// The requested title bar style for the window
+const char kTitleBarStyle[] = "titleBarStyle";
+
+// The menu bar is hidden unless "Alt" is pressed.
+const char kAutoHideMenuBar[] = "autoHideMenuBar";
+
+// Enable window to be resized larger than screen.
+const char kEnableLargerThanScreen[] = "enableLargerThanScreen";
+
+// Forces to use dark theme on Linux.
+const char kDarkTheme[] = "darkTheme";
+
+// Whether the window should be transparent.
+const char kTransparent[] = "transparent";
+
+// Window type hint.
+const char kType[] = "type";
+
+// Disable auto-hiding cursor.
+const char kDisableAutoHideCursor[] = "disableAutoHideCursor";
+
+// Use the OS X's standard window instead of the textured window.
+const char kStandardWindow[] = "standardWindow";
+
+// Default browser window background color.
+const char kBackgroundColor[] = "backgroundColor";
+
+// Whether the window should have a shadow.
+const char kHasShadow[] = "hasShadow";
+
+// The WebPreferences.
+const char kWebPreferences[] = "webPreferences";
+
+// The factor of which page should be zoomed.
+const char kZoomFactor[] = "zoomFactor";
+
+// Script that will be loaded by guest WebContents before other scripts.
+const char kPreloadScript[] = "preload";
+
+// Like --preload, but the passed argument is an URL.
+const char kPreloadURL[] = "preloadURL";
+
+// Enable the node integration.
+const char kNodeIntegration[] = "nodeIntegration";
+
+// Instancd ID of guest WebContents.
+const char kGuestInstanceID[] = "guestInstanceId";
+
+// Enable DirectWrite on Windows.
+const char kDirectWrite[] = "directWrite";
+
+// Web runtime features.
+const char kExperimentalFeatures[]       = "experimentalFeatures";
+const char kExperimentalCanvasFeatures[] = "experimentalCanvasFeatures";
+
+// Opener window's ID.
+const char kOpenerID[] = "openerId";
+
+// Enable blink features.
+const char kBlinkFeatures[] = "blinkFeatures";
+
+}  // namespace options
+
+namespace switches {
+
+// Enable plugins.
+const char kEnablePlugins[] = "enable-plugins";
+
+// Ppapi Flash path.
+const char kPpapiFlashPath[] = "ppapi-flash-path";
+
+// Ppapi Flash version.
+const char kPpapiFlashVersion[] = "ppapi-flash-version";
+
+// Path to client certificate.
+const char kClientCertificate[] = "client-certificate";
+
+// Disable HTTP cache.
+const char kDisableHttpCache[] = "disable-http-cache";
+
+// Register schemes to standard.
+const char kRegisterStandardSchemes[] = "register-standard-schemes";
+
+// Register schemes to handle service worker.
+const char kRegisterServiceWorkerSchemes[] = "register-service-worker-schemes";
+
+// The minimum SSL/TLS version ("tls1", "tls1.1", or "tls1.2") that
+// TLS fallback will accept.
+const char kSSLVersionFallbackMin[] = "ssl-version-fallback-min";
+
+// Comma-separated list of SSL cipher suites to disable.
+const char kCipherSuiteBlacklist[] = "cipher-suite-blacklist";
+
+// The browser process app model ID
+const char kAppUserModelId[] = "app-user-model-id";
+
+// The command line switch versions of the options.
+const char kZoomFactor[]                 = "zoom-factor";
+const char kPreloadScript[]              = "preload";
+const char kPreloadURL[]                 = "preload-url";
+const char kNodeIntegration[]            = "node-integration";
+const char kGuestInstanceID[]            = "guest-instance-id";
+const char kOpenerID[]                   = "opener-id";
+
+// Widevine options
+// Path to Widevine CDM binaries.
+const char kWidevineCdmPath[] = "widevine-cdm-path";
+// Widevine CDM version.
+const char kWidevineCdmVersion[] = "widevine-cdm-version";
+
+}  // namespace switches
+
+}  // namespace electron
added in remote
  their  100644 d7fee063f7e2fc2c07e725d1b05f79ec104e1187 electron/common/options_switches.h
@@ -0,0 +1,93 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_OPTIONS_SWITCHES_H_
+#define ELECTRON_COMMON_OPTIONS_SWITCHES_H_
+
+namespace electron {
+
+namespace options {
+
+extern const char kTitle[];
+extern const char kIcon[];
+extern const char kFrame[];
+extern const char kShow[];
+extern const char kCenter[];
+extern const char kX[];
+extern const char kY[];
+extern const char kWidth[];
+extern const char kHeight[];
+extern const char kMinWidth[];
+extern const char kMinHeight[];
+extern const char kMaxWidth[];
+extern const char kMaxHeight[];
+extern const char kResizable[];
+extern const char kMovable[];
+extern const char kMinimizable[];
+extern const char kMaximizable[];
+extern const char kFullScreenable[];
+extern const char kClosable[];
+extern const char kFullscreen[];
+extern const char kSkipTaskbar[];
+extern const char kKiosk[];
+extern const char kAlwaysOnTop[];
+extern const char kAcceptFirstMouse[];
+extern const char kUseContentSize[];
+extern const char kTitleBarStyle[];
+extern const char kAutoHideMenuBar[];
+extern const char kEnableLargerThanScreen[];
+extern const char kDarkTheme[];
+extern const char kTransparent[];
+extern const char kType[];
+extern const char kDisableAutoHideCursor[];
+extern const char kStandardWindow[];
+extern const char kBackgroundColor[];
+extern const char kHasShadow[];
+extern const char kWebPreferences[];
+
+// WebPreferences.
+extern const char kDirectWrite[];
+extern const char kZoomFactor[];
+extern const char kPreloadScript[];
+extern const char kPreloadURL[];
+extern const char kNodeIntegration[];
+extern const char kGuestInstanceID[];
+extern const char kExperimentalFeatures[];
+extern const char kExperimentalCanvasFeatures[];
+extern const char kOpenerID[];
+extern const char kBlinkFeatures[];
+
+}   // namespace options
+
+
+// Following are actually command line switches, should be moved to other files.
+
+namespace switches {
+
+extern const char kEnablePlugins[];
+extern const char kPpapiFlashPath[];
+extern const char kPpapiFlashVersion[];
+extern const char kClientCertificate[];
+extern const char kDisableHttpCache[];
+extern const char kRegisterStandardSchemes[];
+extern const char kRegisterServiceWorkerSchemes[];
+extern const char kSSLVersionFallbackMin[];
+extern const char kCipherSuiteBlacklist[];
+extern const char kAppUserModelId[];
+
+extern const char kZoomFactor[];
+extern const char kPreloadScript[];
+extern const char kPreloadURL[];
+extern const char kNodeIntegration[];
+extern const char kGuestInstanceID[];
+extern const char kOpenerID[];
+
+extern const char kWidevineCdmPath[];
+extern const char kWidevineCdmVersion[];
+
+}  // namespace switches
+
+}  // namespace electron
+
+#endif  // ELECTRON_COMMON_OPTIONS_SWITCHES_H_
added in remote
  their  100644 c06f74061cb24f97b6f8937cef2f6ac084d4388c electron/common/platform_util.h
@@ -0,0 +1,35 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_COMMON_PLATFORM_UTIL_H_
+#define ELECTRON_COMMON_PLATFORM_UTIL_H_
+
+class GURL;
+
+namespace base {
+class FilePath;
+}
+
+namespace platform_util {
+
+// Show the given file in a file manager. If possible, select the file.
+// Must be called from the UI thread.
+void ShowItemInFolder(const base::FilePath& full_path);
+
+// Open the given file in the desktop's default manner.
+// Must be called from the UI thread.
+void OpenItem(const base::FilePath& full_path);
+
+// Open the given external protocol URL in the desktop's default manner.
+// (For example, mailto: URLs in the default mail user agent.)
+bool OpenExternal(const GURL& url, bool activate);
+
+// Move a file to trash.
+bool MoveItemToTrash(const base::FilePath& full_path);
+
+void Beep();
+
+}  // namespace platform_util
+
+#endif  // ELECTRON_COMMON_PLATFORM_UTIL_H_
added in remote
  their  100644 3a9f000c4a8cf579605ced3f0b47cd9ae4535b27 electron/common/platform_util_linux.cc
@@ -0,0 +1,87 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <stdio.h>
+
+#include "base/files/file_util.h"
+#include "base/process/kill.h"
+#include "base/process/launch.h"
+#include "url/gurl.h"
+
+namespace {
+
+bool XDGUtil(const std::string& util, const std::string& arg) {
+  std::vector<std::string> argv;
+  argv.push_back(util);
+  argv.push_back(arg);
+
+  base::LaunchOptions options;
+  options.allow_new_privs = true;
+  // xdg-open can fall back on mailcap which eventually might plumb through
+  // to a command that needs a terminal.  Set the environment variable telling
+  // it that we definitely don't have a terminal available and that it should
+  // bring up a new terminal if necessary.  See "man mailcap".
+  options.environ["MM_NOTTTY"] = "1";
+
+  base::Process process = base::LaunchProcess(argv, options);
+  if (!process.IsValid())
+    return false;
+
+  int exit_code = -1;
+  if (!process.WaitForExit(&exit_code))
+    return false;
+
+  return (exit_code == 0);
+}
+
+bool XDGOpen(const std::string& path) {
+  return XDGUtil("xdg-open", path);
+}
+
+bool XDGEmail(const std::string& email) {
+  return XDGUtil("xdg-email", email);
+}
+
+}  // namespace
+
+namespace platform_util {
+
+// TODO(estade): It would be nice to be able to select the file in the file
+// manager, but that probably requires extending xdg-open. For now just
+// show the folder.
+void ShowItemInFolder(const base::FilePath& full_path) {
+  base::FilePath dir = full_path.DirName();
+  if (!base::DirectoryExists(dir))
+    return;
+
+  XDGOpen(dir.value());
+}
+
+void OpenItem(const base::FilePath& full_path) {
+  XDGOpen(full_path.value());
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  if (url.SchemeIs("mailto"))
+    return XDGEmail(url.spec());
+  else
+    return XDGOpen(url.spec());
+}
+
+bool MoveItemToTrash(const base::FilePath& full_path) {
+  return XDGUtil("gvfs-trash", full_path.value());
+}
+
+void Beep() {
+  // echo '\a' > /dev/console
+  FILE* console = fopen("/dev/console", "r");
+  if (console == NULL)
+    return;
+  fprintf(console, "\a");
+  fclose(console);
+}
+
+}  // namespace platform_util
added in remote
  their  100644 da6b6a80ac2a216d4a0726b2c99ef98595bc28b4 electron/common/platform_util_mac.mm
@@ -0,0 +1,166 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <Carbon/Carbon.h>
+#import <Cocoa/Cocoa.h>
+
+#include "base/files/file_path.h"
+#include "base/logging.h"
+#include "base/mac/mac_logging.h"
+#include "base/mac/scoped_aedesc.h"
+#include "base/strings/sys_string_conversions.h"
+#include "net/base/mac/url_conversions.h"
+#include "url/gurl.h"
+
+namespace platform_util {
+
+void ShowItemInFolder(const base::FilePath& full_path) {
+  DCHECK([NSThread isMainThread]);
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  if (!path_string || ![[NSWorkspace sharedWorkspace] selectFile:path_string
+                                        inFileViewerRootedAtPath:@""])
+    LOG(WARNING) << "NSWorkspace failed to select file " << full_path.value();
+}
+
+// This function opens a file.  This doesn't use LaunchServices or NSWorkspace
+// because of two bugs:
+//  1. Incorrect app activation with com.apple.quarantine:
+//     http://crbug.com/32921
+//  2. Silent no-op for unassociated file types: http://crbug.com/50263
+// Instead, an AppleEvent is constructed to tell the Finder to open the
+// document.
+void OpenItem(const base::FilePath& full_path) {
+  DCHECK([NSThread isMainThread]);
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  if (!path_string)
+    return;
+
+  // Create the target of this AppleEvent, the Finder.
+  base::mac::ScopedAEDesc<AEAddressDesc> address;
+  const OSType finderCreatorCode = 'MACS';
+  OSErr status = AECreateDesc(typeApplSignature,  // type
+                              &finderCreatorCode,  // data
+                              sizeof(finderCreatorCode),  // dataSize
+                              address.OutPointer());  // result
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE target";
+    return;
+  }
+
+  // Build the AppleEvent data structure that instructs Finder to open files.
+  base::mac::ScopedAEDesc<AppleEvent> theEvent;
+  status = AECreateAppleEvent(kCoreEventClass,  // theAEEventClass
+                              kAEOpenDocuments,  // theAEEventID
+                              address,  // target
+                              kAutoGenerateReturnID,  // returnID
+                              kAnyTransactionID,  // transactionID
+                              theEvent.OutPointer());  // result
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE event";
+    return;
+  }
+
+  // Create the list of files (only ever one) to open.
+  base::mac::ScopedAEDesc<AEDescList> fileList;
+  status = AECreateList(NULL,  // factoringPtr
+                        0,  // factoredSize
+                        false,  // isRecord
+                        fileList.OutPointer());  // resultList
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status) << "Could not create OpenItem() AE file list";
+    return;
+  }
+
+  // Add the single path to the file list.  C-style cast to avoid both a
+  // static_cast and a const_cast to get across the toll-free bridge.
+  CFURLRef pathURLRef = (CFURLRef)[NSURL fileURLWithPath:path_string];
+  FSRef pathRef;
+  if (CFURLGetFSRef(pathURLRef, &pathRef)) {
+    status = AEPutPtr(fileList.OutPointer(),  // theAEDescList
+                      0,  // index
+                      typeFSRef,  // typeCode
+                      &pathRef,  // dataPtr
+                      sizeof(pathRef));  // dataSize
+    if (status != noErr) {
+      OSSTATUS_LOG(WARNING, status)
+          << "Could not add file path to AE list in OpenItem()";
+      return;
+    }
+  } else {
+    LOG(WARNING) << "Could not get FSRef for path URL in OpenItem()";
+    return;
+  }
+
+  // Attach the file list to the AppleEvent.
+  status = AEPutParamDesc(theEvent.OutPointer(),  // theAppleEvent
+                          keyDirectObject,  // theAEKeyword
+                          fileList);  // theAEDesc
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status)
+        << "Could not put the AE file list the path in OpenItem()";
+    return;
+  }
+
+  // Send the actual event.  Do not care about the reply.
+  base::mac::ScopedAEDesc<AppleEvent> reply;
+  status = AESend(theEvent,  // theAppleEvent
+                  reply.OutPointer(),  // reply
+                  kAENoReply + kAEAlwaysInteract,  // sendMode
+                  kAENormalPriority,  // sendPriority
+                  kAEDefaultTimeout,  // timeOutInTicks
+                  NULL, // idleProc
+                  NULL);  // filterProc
+  if (status != noErr) {
+    OSSTATUS_LOG(WARNING, status)
+        << "Could not send AE to Finder in OpenItem()";
+  }
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  DCHECK([NSThread isMainThread]);
+  NSURL* ns_url = net::NSURLWithGURL(url);
+  if (!ns_url) {
+    return false;
+  }
+
+  CFURLRef openingApp = NULL;
+  OSStatus status = LSGetApplicationForURL((CFURLRef)ns_url,
+                                           kLSRolesAll,
+                                           NULL,
+                                           &openingApp);
+  if (status != noErr) {
+    return false;
+  }
+  CFRelease(openingApp);  // NOT A BUG; LSGetApplicationForURL retains for us
+
+  NSUInteger launchOptions = NSWorkspaceLaunchDefault;
+  if (!activate)
+    launchOptions |= NSWorkspaceLaunchWithoutActivation;
+
+  return [[NSWorkspace sharedWorkspace] openURLs: @[ns_url]
+                                        withAppBundleIdentifier: nil
+                                        options: launchOptions
+                                        additionalEventParamDescriptor: NULL
+                                        launchIdentifiers: NULL];
+}
+
+bool MoveItemToTrash(const base::FilePath& full_path) {
+  NSString* path_string = base::SysUTF8ToNSString(full_path.value());
+  BOOL status = [[NSFileManager defaultManager]
+                trashItemAtURL:[NSURL fileURLWithPath:path_string]
+                resultingItemURL:nil
+                error:nil];
+  if (!path_string || !status)
+    LOG(WARNING) << "NSWorkspace failed to move file " << full_path.value()
+                 << " to trash";
+  return status;
+}
+
+void Beep() {
+  NSBeep();
+}
+
+}  // namespace platform_util
added in remote
  their  100644 baf691a4f737f40009b881721145b544d96d3f6f electron/common/platform_util_win.cc
@@ -0,0 +1,392 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/platform_util.h"
+
+#include <windows.h>
+#include <atlbase.h>
+#include <commdlg.h>
+#include <comdef.h>
+#include <dwmapi.h>
+#include <shellapi.h>
+#include <shlobj.h>
+
+#include "base/bind.h"
+#include "base/bind_helpers.h"
+#include "base/files/file_path.h"
+#include "base/files/file_util.h"
+#include "base/logging.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "base/win/registry.h"
+#include "base/win/scoped_co_mem.h"
+#include "base/win/scoped_com_initializer.h"
+#include "base/win/scoped_comptr.h"
+#include "base/win/windows_version.h"
+#include "url/gurl.h"
+#include "ui/base/win/shell.h"
+
+namespace {
+
+// Old ShellExecute crashes the process when the command for a given scheme
+// is empty. This function tells if it is.
+bool ValidateShellCommandForScheme(const std::string& scheme) {
+  base::win::RegKey key;
+  base::string16 registry_path = base::ASCIIToUTF16(scheme) +
+                                 L"\\shell\\open\\command";
+  key.Open(HKEY_CLASSES_ROOT, registry_path.c_str(), KEY_READ);
+  if (!key.Valid())
+    return false;
+  DWORD size = 0;
+  key.ReadValue(NULL, NULL, &size, NULL);
+  if (size <= 2)
+    return false;
+  return true;
+}
+
+// Required COM implementation of IFileOperationProgressSink so we can
+// precheck files before deletion to make sure they can be move to the
+// Recycle Bin.
+class DeleteFileProgressSink : public IFileOperationProgressSink {
+ public:
+  DeleteFileProgressSink();
+
+ private:
+  ULONG STDMETHODCALLTYPE AddRef(void);
+  ULONG STDMETHODCALLTYPE Release(void);
+  HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid, LPVOID* ppvObj);
+  HRESULT STDMETHODCALLTYPE StartOperations(void);
+  HRESULT STDMETHODCALLTYPE FinishOperations(HRESULT);
+  HRESULT STDMETHODCALLTYPE PreRenameItem(
+      DWORD, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostRenameItem(
+      DWORD, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreMoveItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostMoveItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreCopyItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostCopyItem(
+      DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreDeleteItem(DWORD, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PostDeleteItem(
+      DWORD, IShellItem*, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE PreNewItem(
+      DWORD, IShellItem*, LPCWSTR);
+  HRESULT STDMETHODCALLTYPE PostNewItem(
+      DWORD, IShellItem*, LPCWSTR, LPCWSTR, DWORD, HRESULT, IShellItem*);
+  HRESULT STDMETHODCALLTYPE UpdateProgress(UINT, UINT);
+  HRESULT STDMETHODCALLTYPE ResetTimer(void);
+  HRESULT STDMETHODCALLTYPE PauseTimer(void);
+  HRESULT STDMETHODCALLTYPE ResumeTimer(void);
+
+  ULONG m_cRef;
+};
+
+DeleteFileProgressSink::DeleteFileProgressSink() {
+  m_cRef = 0;
+}
+
+HRESULT DeleteFileProgressSink::PreDeleteItem(DWORD dwFlags, IShellItem*) {
+  if (!(dwFlags & TSF_DELETE_RECYCLE_IF_POSSIBLE)) {
+    // TSF_DELETE_RECYCLE_IF_POSSIBLE will not be set for items that cannot be
+    // recycled.  In this case, we abort the delete operation.  This bubbles
+    // up and stops the Delete in IFileOperation.
+    return E_ABORT;
+  }
+  // Returns S_OK if successful, or an error value otherwise. In the case of an
+  // error value, the delete operation and all subsequent operations pending
+  // from the call to IFileOperation are canceled.
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::QueryInterface(REFIID riid, LPVOID* ppvObj) {
+  // Always set out parameter to NULL, validating it first.
+  if (!ppvObj)
+    return E_INVALIDARG;
+  *ppvObj = nullptr;
+  if (riid == IID_IUnknown || riid == IID_IFileOperationProgressSink) {
+    // Increment the reference count and return the pointer.
+    *ppvObj = reinterpret_cast<IUnknown*>(this);
+    AddRef();
+    return NOERROR;
+  }
+  return E_NOINTERFACE;
+}
+
+ULONG DeleteFileProgressSink::AddRef() {
+  InterlockedIncrement(&m_cRef);
+  return m_cRef;
+}
+
+ULONG DeleteFileProgressSink::Release() {
+  // Decrement the object's internal counter.
+  ULONG ulRefCount = InterlockedDecrement(&m_cRef);
+  if (0 == m_cRef) {
+    delete this;
+  }
+  return ulRefCount;
+}
+
+HRESULT DeleteFileProgressSink::StartOperations() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::FinishOperations(HRESULT) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PreRenameItem(DWORD, IShellItem*, LPCWSTR) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PostRenameItem(
+    DWORD, IShellItem*, __RPC__in_string LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PreMoveItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostMoveItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PreCopyItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostCopyItem(
+    DWORD, IShellItem*, IShellItem*, LPCWSTR, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostDeleteItem(
+    DWORD, IShellItem*, HRESULT, IShellItem*) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PreNewItem(
+    DWORD dwFlags, IShellItem*, LPCWSTR) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::PostNewItem(
+    DWORD, IShellItem*, LPCWSTR, LPCWSTR, DWORD, HRESULT, IShellItem*) {
+  return E_NOTIMPL;
+}
+
+HRESULT DeleteFileProgressSink::UpdateProgress(UINT, UINT) {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::ResetTimer() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::PauseTimer() {
+  return S_OK;
+}
+
+HRESULT DeleteFileProgressSink::ResumeTimer() {
+  return S_OK;
+}
+
+}  // namespace
+
+namespace platform_util {
+
+void ShowItemInFolder(const base::FilePath& full_path) {
+  base::win::ScopedCOMInitializer com_initializer;
+  if (!com_initializer.succeeded())
+    return;
+
+  base::FilePath dir = full_path.DirName().AsEndingWithSeparator();
+  // ParseDisplayName will fail if the directory is "C:", it must be "C:\\".
+  if (dir.empty())
+    return;
+
+  typedef HRESULT (WINAPI *SHOpenFolderAndSelectItemsFuncPtr)(
+      PCIDLIST_ABSOLUTE pidl_Folder,
+      UINT cidl,
+      PCUITEMID_CHILD_ARRAY pidls,
+      DWORD flags);
+
+  static SHOpenFolderAndSelectItemsFuncPtr open_folder_and_select_itemsPtr =
+    NULL;
+  static bool initialize_open_folder_proc = true;
+  if (initialize_open_folder_proc) {
+    initialize_open_folder_proc = false;
+    // The SHOpenFolderAndSelectItems API is exposed by shell32 version 6
+    // and does not exist in Win2K. We attempt to retrieve this function export
+    // from shell32 and if it does not exist, we just invoke ShellExecute to
+    // open the folder thus losing the functionality to select the item in
+    // the process.
+    HMODULE shell32_base = GetModuleHandle(L"shell32.dll");
+    if (!shell32_base) {
+      NOTREACHED() << " " << __FUNCTION__ << "(): Can't open shell32.dll";
+      return;
+    }
+    open_folder_and_select_itemsPtr =
+        reinterpret_cast<SHOpenFolderAndSelectItemsFuncPtr>
+            (GetProcAddress(shell32_base, "SHOpenFolderAndSelectItems"));
+  }
+  if (!open_folder_and_select_itemsPtr) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  base::win::ScopedComPtr<IShellFolder> desktop;
+  HRESULT hr = SHGetDesktopFolder(desktop.Receive());
+  if (FAILED(hr))
+    return;
+
+  base::win::ScopedCoMem<ITEMIDLIST> dir_item;
+  hr = desktop->ParseDisplayName(NULL, NULL,
+                                 const_cast<wchar_t *>(dir.value().c_str()),
+                                 NULL, &dir_item, NULL);
+  if (FAILED(hr)) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  base::win::ScopedCoMem<ITEMIDLIST> file_item;
+  hr = desktop->ParseDisplayName(NULL, NULL,
+      const_cast<wchar_t *>(full_path.value().c_str()),
+      NULL, &file_item, NULL);
+  if (FAILED(hr)) {
+    ui::win::OpenFolderViaShell(dir);
+    return;
+  }
+
+  const ITEMIDLIST* highlight[] = { file_item };
+
+  hr = (*open_folder_and_select_itemsPtr)(dir_item, arraysize(highlight),
+                                          highlight, NULL);
+
+  if (FAILED(hr)) {
+    // On some systems, the above call mysteriously fails with "file not
+    // found" even though the file is there.  In these cases, ShellExecute()
+    // seems to work as a fallback (although it won't select the file).
+    if (hr == ERROR_FILE_NOT_FOUND) {
+      ui::win::OpenFolderViaShell(dir);
+    } else {
+      LPTSTR message = NULL;
+      DWORD message_length = FormatMessage(
+          FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,
+          0, hr, 0, reinterpret_cast<LPTSTR>(&message), 0, NULL);
+      LOG(WARNING) << " " << __FUNCTION__
+                   << "(): Can't open full_path = \""
+                   << full_path.value() << "\""
+                   << " hr = " << hr
+                   << " " << reinterpret_cast<LPTSTR>(&message);
+      if (message)
+        LocalFree(message);
+
+      ui::win::OpenFolderViaShell(dir);
+    }
+  }
+}
+
+void OpenItem(const base::FilePath& full_path) {
+  if (base::DirectoryExists(full_path))
+    ui::win::OpenFolderViaShell(full_path);
+  else
+    ui::win::OpenFileViaShell(full_path);
+}
+
+bool OpenExternal(const GURL& url, bool activate) {
+  // Quote the input scheme to be sure that the command does not have
+  // parameters unexpected by the external program. This url should already
+  // have been escaped.
+  std::string escaped_url = url.spec();
+  escaped_url.insert(0, "\"");
+  escaped_url += "\"";
+
+  // According to Mozilla in uriloader/exthandler/win/nsOSHelperAppService.cpp:
+  // "Some versions of windows (Win2k before SP3, Win XP before SP1) crash in
+  // ShellExecute on long URLs (bug 161357 on bugzilla.mozilla.org). IE 5 and 6
+  // support URLS of 2083 chars in length, 2K is safe."
+  const size_t kMaxURLLength = 2048;
+  if (escaped_url.length() > kMaxURLLength) {
+    NOTREACHED();
+    return false;
+  }
+
+  if (base::win::GetVersion() < base::win::VERSION_WIN7) {
+    if (!ValidateShellCommandForScheme(url.scheme()))
+      return false;
+  }
+
+  if (reinterpret_cast<ULONG_PTR>(ShellExecuteA(NULL, "open",
+                                                escaped_url.c_str(), NULL, NULL,
+                                                SW_SHOWNORMAL)) <= 32) {
+    // We fail to execute the call. We could display a message to the user.
+    // TODO(nsylvain): we should also add a dialog to warn on errors. See
+    // bug 1136923.
+    return false;
+  }
+  return true;
+}
+
+bool MoveItemToTrash(const base::FilePath& path) {
+  base::win::ScopedCOMInitializer com_initializer;
+  if (!com_initializer.succeeded())
+    return false;
+
+  base::win::ScopedComPtr<IFileOperation> pfo;
+  if (FAILED(pfo.CreateInstance(CLSID_FileOperation)))
+    return false;
+
+  // Elevation prompt enabled for UAC protected files.  This overrides the
+  // SILENT, NO_UI and NOERRORUI flags.
+
+  if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
+    // Windows 8 introduces the flag RECYCLEONDELETE and deprecates the
+    // ALLOWUNDO in favor of ADDUNDORECORD.
+    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI |
+                                      FOFX_ADDUNDORECORD |
+                                      FOF_NOERRORUI |
+                                      FOF_SILENT |
+                                      FOFX_SHOWELEVATIONPROMPT |
+                                      FOFX_RECYCLEONDELETE)))
+      return false;
+  } else {
+    // For Windows 7 and Vista, RecycleOnDelete is the default behavior.
+    if (FAILED(pfo->SetOperationFlags(FOF_NO_UI |
+                                      FOF_ALLOWUNDO |
+                                      FOF_NOERRORUI |
+                                      FOF_SILENT |
+                                      FOFX_SHOWELEVATIONPROMPT)))
+      return false;
+  }
+
+  // Create an IShellItem from the supplied source path.
+  base::win::ScopedComPtr<IShellItem> delete_item;
+  if (FAILED(SHCreateItemFromParsingName(path.value().c_str(),
+                                         NULL,
+                                         IID_PPV_ARGS(delete_item.Receive()))))
+    return false;
+
+  base::win::ScopedComPtr<IFileOperationProgressSink> delete_sink(
+      new DeleteFileProgressSink);
+  if (!delete_sink)
+    return false;
+
+  // Processes the queued command DeleteItem. This will trigger
+  // the DeleteFileProgressSink to check for Recycle Bin.
+  return SUCCEEDED(pfo->DeleteItem(delete_item.get(), delete_sink.get())) &&
+         SUCCEEDED(pfo->PerformOperations());
+}
+
+void Beep() {
+  MessageBeep(MB_OK);
+}
+
+}  // namespace platform_util
added in remote
  their  100644 e39b2b84171ce2ebdef3cbe22597bd68fb822c08 electron/common/resources/mac/Info.plist
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+	<key>CFBundleIdentifier</key>
+	<string>${ELECTRON_BUNDLE_ID}</string>
+	<key>CFBundleName</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundleExecutable</key>
+	<string>${PRODUCT_NAME}</string>
+	<key>CFBundlePackageType</key>
+	<string>FMWK</string>
+	<key>NSSupportsAutomaticGraphicsSwitching</key>
+	<true/>
+</dict>
+</plist>
added in remote
  their  100644 8cb57c709237496ee9b263834d0f10b1455f42d3 electron/common/resources/mac/MainMenu.xib
@@ -0,0 +1,180 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<archive type="com.apple.InterfaceBuilder3.Cocoa.XIB" version="8.00">
+	<data>
+		<int key="IBDocument.SystemTarget">101000</int>
+		<string key="IBDocument.SystemVersion">14D136</string>
+		<string key="IBDocument.InterfaceBuilderVersion">7531</string>
+		<string key="IBDocument.AppKitVersion">1347.57</string>
+		<string key="IBDocument.HIToolboxVersion">758.70</string>
+		<object class="NSMutableDictionary" key="IBDocument.PluginVersions">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin</string>
+			<string key="NS.object.0">7531</string>
+		</object>
+		<array key="IBDocument.IntegratedClassDependencies">
+			<string>NSCustomObject</string>
+			<string>NSMenu</string>
+			<string>NSMenuItem</string>
+		</array>
+		<array key="IBDocument.PluginDependencies">
+			<string>com.apple.InterfaceBuilder.CocoaPlugin</string>
+		</array>
+		<object class="NSMutableDictionary" key="IBDocument.Metadata">
+			<string key="NS.key.0">PluginDependencyRecalculationVersion</string>
+			<integer value="1" key="NS.object.0"/>
+		</object>
+		<array class="NSMutableArray" key="IBDocument.RootObjects" id="1048">
+			<object class="NSCustomObject" id="1021">
+				<string key="NSClassName">ElectronApplication</string>
+			</object>
+			<object class="NSCustomObject" id="1014">
+				<string key="NSClassName">FirstResponder</string>
+			</object>
+			<object class="NSCustomObject" id="1050">
+				<string key="NSClassName">NSApplication</string>
+			</object>
+			<object class="NSCustomObject" id="903638069">
+				<string key="NSClassName">NSFontManager</string>
+			</object>
+			<object class="NSMenu" id="649796088">
+				<string key="NSTitle">Main Menu</string>
+				<array class="NSMutableArray" key="NSMenuItems">
+					<object class="NSMenuItem" id="694149608">
+						<reference key="NSMenu" ref="649796088"/>
+						<string key="NSTitle">Electron</string>
+						<string key="NSKeyEquiv"/>
+						<int key="NSMnemonicLoc">2147483647</int>
+						<object class="NSCustomResource" key="NSOnImage" id="229763992">
+							<string key="NSClassName">NSImage</string>
+							<string key="NSResourceName">NSMenuCheckmark</string>
+						</object>
+						<object class="NSCustomResource" key="NSMixedImage" id="909111550">
+							<string key="NSClassName">NSImage</string>
+							<string key="NSResourceName">NSMenuMixedState</string>
+						</object>
+						<string key="NSAction">submenuAction:</string>
+						<reference key="NSTarget" ref="110575045"/>
+						<object class="NSMenu" key="NSSubmenu" id="110575045">
+							<string key="NSTitle">Electron</string>
+							<array class="NSMutableArray" key="NSMenuItems">
+								<object class="NSMenuItem" id="632727374">
+									<reference key="NSMenu" ref="110575045"/>
+									<string key="NSTitle">Quit</string>
+									<string key="NSKeyEquiv">q</string>
+									<int key="NSKeyEquivModMask">1048576</int>
+									<int key="NSMnemonicLoc">2147483647</int>
+									<reference key="NSOnImage" ref="229763992"/>
+									<reference key="NSMixedImage" ref="909111550"/>
+								</object>
+							</array>
+							<string key="NSName">_NSAppleMenu</string>
+						</object>
+					</object>
+				</array>
+				<string key="NSName">_NSMainMenu</string>
+			</object>
+		</array>
+		<object class="IBObjectContainer" key="IBDocument.Objects">
+			<array key="connectionRecords">
+				<object class="IBConnectionRecord">
+					<object class="IBActionConnection" key="connection">
+						<string key="label">terminate:</string>
+						<reference key="source" ref="1014"/>
+						<reference key="destination" ref="632727374"/>
+					</object>
+					<int key="connectionID">807</int>
+				</object>
+			</array>
+			<object class="IBMutableOrderedSet" key="objectRecords">
+				<array key="orderedObjects">
+					<object class="IBObjectRecord">
+						<int key="objectID">0</int>
+						<array key="object" id="0"/>
+						<reference key="children" ref="1048"/>
+						<nil key="parent"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-2</int>
+						<reference key="object" ref="1021"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">File's Owner</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-1</int>
+						<reference key="object" ref="1014"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">First Responder</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">-3</int>
+						<reference key="object" ref="1050"/>
+						<reference key="parent" ref="0"/>
+						<string key="objectName">Application</string>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">371</int>
+						<reference key="object" ref="903638069"/>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">29</int>
+						<reference key="object" ref="649796088"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="694149608"/>
+						</array>
+						<reference key="parent" ref="0"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">56</int>
+						<reference key="object" ref="694149608"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="110575045"/>
+						</array>
+						<reference key="parent" ref="649796088"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">57</int>
+						<reference key="object" ref="110575045"/>
+						<array class="NSMutableArray" key="children">
+							<reference ref="632727374"/>
+						</array>
+						<reference key="parent" ref="694149608"/>
+					</object>
+					<object class="IBObjectRecord">
+						<int key="objectID">136</int>
+						<reference key="object" ref="632727374"/>
+						<reference key="parent" ref="110575045"/>
+					</object>
+				</array>
+			</object>
+			<dictionary class="NSMutableDictionary" key="flattenedProperties">
+				<string key="-1.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="-2.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="-3.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="136.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="29.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="371.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="56.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+				<string key="57.IBPluginDependency">com.apple.InterfaceBuilder.CocoaPlugin</string>
+			</dictionary>
+			<dictionary class="NSMutableDictionary" key="unlocalizedProperties"/>
+			<nil key="activeLocalization"/>
+			<dictionary class="NSMutableDictionary" key="localizations"/>
+			<nil key="sourceID"/>
+			<int key="maxID">807</int>
+		</object>
+		<int key="IBDocument.localizationMode">0</int>
+		<string key="IBDocument.TargetRuntimeIdentifier">IBCocoaFramework</string>
+		<bool key="IBDocument.previouslyAttemptedUpgradeToXcode5">NO</bool>
+		<object class="NSMutableDictionary" key="IBDocument.PluginDeclaredDevelopmentDependencies">
+			<string key="NS.key.0">com.apple.InterfaceBuilder.CocoaPlugin.InterfaceBuilder3</string>
+			<integer value="4600" key="NS.object.0"/>
+		</object>
+		<bool key="IBDocument.PluginDeclaredDependenciesTrackSystemTargetVersion">YES</bool>
+		<int key="IBDocument.defaultPropertyAccessControl">3</int>
+		<dictionary class="NSMutableDictionary" key="IBDocument.LastKnownImageSizes">
+			<string key="NSMenuCheckmark">{12, 12}</string>
+			<string key="NSMenuMixedState">{10, 2}</string>
+		</dictionary>
+		<bool key="IBDocument.UseAutolayout">YES</bool>
+	</data>
+</archive>
added in remote
  their  100644 9ec1b0cf2470f653d8df7f103f82c6ecaf8ed73c electron/renderer/api/electron_api_renderer_ipc.cc
@@ -0,0 +1,74 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "content/public/renderer/render_view.h"
+#include "native_mate/dictionary.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+using content::RenderView;
+using blink::WebLocalFrame;
+using blink::WebView;
+
+namespace {
+
+RenderView* GetCurrentRenderView() {
+  WebLocalFrame* frame = WebLocalFrame::frameForCurrentContext();
+  if (!frame)
+    return NULL;
+
+  WebView* view = frame->view();
+  if (!view)
+    return NULL;  // can happen during closing.
+
+  return RenderView::FromWebView(view);
+}
+
+void Send(mate::Arguments* args,
+          const base::string16& channel,
+          const base::ListValue& arguments) {
+  RenderView* render_view = GetCurrentRenderView();
+  if (render_view == NULL)
+    return;
+
+  bool success = render_view->Send(new ElectronViewHostMsg_Message(
+      render_view->GetRoutingID(), channel, arguments));
+
+  if (!success)
+    args->ThrowError("Unable to send ElectronViewHostMsg_Message");
+}
+
+base::string16 SendSync(mate::Arguments* args,
+                        const base::string16& channel,
+                        const base::ListValue& arguments) {
+  base::string16 json;
+
+  RenderView* render_view = GetCurrentRenderView();
+  if (render_view == NULL)
+    return json;
+
+  IPC::SyncMessage* message = new ElectronViewHostMsg_Message_Sync(
+      render_view->GetRoutingID(), channel, arguments, &json);
+  bool success = render_view->Send(message);
+
+  if (!success)
+    args->ThrowError("Unable to send ElectronViewHostMsg_Message_Sync");
+
+  return json;
+}
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  mate::Dictionary dict(context->GetIsolate(), exports);
+  dict.SetMethod("send", &Send);
+  dict.SetMethod("sendSync", &SendSync);
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_renderer_ipc, Initialize)
added in remote
  their  100644 8e704aa729fe453b2f4863517b94631990fe81d9 electron/renderer/api/electron_api_spell_check_client.cc
@@ -0,0 +1,189 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/api/electron_api_spell_check_client.h"
+
+#include <algorithm>
+#include <vector>
+
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "base/logging.h"
+#include "native_mate/converter.h"
+#include "native_mate/dictionary.h"
+#include "third_party/icu/source/common/unicode/uscript.h"
+#include "third_party/WebKit/public/web/WebTextCheckingCompletion.h"
+#include "third_party/WebKit/public/web/WebTextCheckingResult.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+bool HasWordCharacters(const base::string16& text, int index) {
+  const base::char16* data = text.data();
+  int length = text.length();
+  while (index < length) {
+    uint32_t code = 0;
+    U16_NEXT(data, index, length, code);
+    UErrorCode error = U_ZERO_ERROR;
+    if (uscript_getScript(code, &error) != USCRIPT_COMMON)
+      return true;
+  }
+  return false;
+}
+
+}  // namespace
+
+SpellCheckClient::SpellCheckClient(const std::string& language,
+                                   bool auto_spell_correct_turned_on,
+                                   v8::Isolate* isolate,
+                                   v8::Local<v8::Object> provider)
+    : isolate_(isolate),
+      provider_(isolate, provider) {
+  character_attributes_.SetDefaultLanguage(language);
+
+  // Persistent the method.
+  mate::Dictionary dict(isolate, provider);
+  dict.Get("spellCheck", &spell_check_);
+}
+
+SpellCheckClient::~SpellCheckClient() {}
+
+void SpellCheckClient::spellCheck(
+    const blink::WebString& text,
+    int& misspelling_start,
+    int& misspelling_len,
+    blink::WebVector<blink::WebString>* optional_suggestions) {
+  std::vector<blink::WebTextCheckingResult> results;
+  SpellCheckText(base::string16(text), true, &results);
+  if (results.size() == 1) {
+    misspelling_start = results[0].location;
+    misspelling_len = results[0].length;
+  }
+}
+
+void SpellCheckClient::checkTextOfParagraph(
+    const blink::WebString& text,
+    blink::WebTextCheckingTypeMask mask,
+    blink::WebVector<blink::WebTextCheckingResult>* results) {
+  if (!results)
+    return;
+
+  if (!(mask & blink::WebTextCheckingTypeSpelling))
+    return;
+
+  NOTREACHED() << "checkTextOfParagraph should never be called";
+}
+
+void SpellCheckClient::requestCheckingOfText(
+    const blink::WebString& textToCheck,
+    const blink::WebVector<uint32_t>& markersInText,
+    const blink::WebVector<unsigned>& markerOffsets,
+    blink::WebTextCheckingCompletion* completionCallback) {
+  base::string16 text(textToCheck);
+  if (text.empty() || !HasWordCharacters(text, 0)) {
+    completionCallback->didCancelCheckingText();
+    return;
+  }
+
+  std::vector<blink::WebTextCheckingResult> results;
+  SpellCheckText(text, false, &results);
+  completionCallback->didFinishCheckingText(results);
+}
+
+void SpellCheckClient::showSpellingUI(bool show) {
+}
+
+bool SpellCheckClient::isShowingSpellingUI() {
+  return false;
+}
+
+void SpellCheckClient::updateSpellingUIWithMisspelledWord(
+    const blink::WebString& word) {
+}
+
+void SpellCheckClient::SpellCheckText(
+    const base::string16& text,
+    bool stop_at_first_result,
+    std::vector<blink::WebTextCheckingResult>* results) {
+  if (text.length() == 0 || spell_check_.IsEmpty())
+    return;
+
+  base::string16 word;
+  int word_start;
+  int word_length;
+  if (!text_iterator_.IsInitialized() &&
+      !text_iterator_.Initialize(&character_attributes_, true)) {
+      // We failed to initialize text_iterator_, return as spelled correctly.
+      VLOG(1) << "Failed to initialize SpellcheckWordIterator";
+      return;
+  }
+
+  base::string16 in_word(text);
+  text_iterator_.SetText(in_word.c_str(), in_word.size());
+  while (text_iterator_.GetNextWord(&word, &word_start, &word_length)) {
+    // Found a word (or a contraction) that the spellchecker can check the
+    // spelling of.
+    if (SpellCheckWord(word))
+      continue;
+
+    // If the given word is a concatenated word of two or more valid words
+    // (e.g. "hello:hello"), we should treat it as a valid word.
+    if (IsValidContraction(word))
+      continue;
+
+    blink::WebTextCheckingResult result;
+    result.location = word_start;
+    result.length = word_length;
+    results->push_back(result);
+
+    if (stop_at_first_result)
+      return;
+  }
+}
+
+bool SpellCheckClient::SpellCheckWord(const base::string16& word_to_check) {
+  if (spell_check_.IsEmpty())
+    return true;
+
+  v8::HandleScope handle_scope(isolate_);
+  v8::Local<v8::Value> word = mate::ConvertToV8(isolate_, word_to_check);
+  v8::Local<v8::Value> result = spell_check_.NewHandle()->Call(
+      provider_.NewHandle(), 1, &word);
+
+  if (result->IsBoolean())
+    return result->BooleanValue();
+  else
+    return true;
+}
+
+// Returns whether or not the given string is a valid contraction.
+// This function is a fall-back when the SpellcheckWordIterator class
+// returns a concatenated word which is not in the selected dictionary
+// (e.g. "in'n'out") but each word is valid.
+bool SpellCheckClient::IsValidContraction(const base::string16& contraction) {
+  if (!contraction_iterator_.IsInitialized() &&
+      !contraction_iterator_.Initialize(&character_attributes_, false)) {
+    // We failed to initialize the word iterator, return as spelled correctly.
+    VLOG(1) << "Failed to initialize contraction_iterator_";
+    return true;
+  }
+
+  contraction_iterator_.SetText(contraction.c_str(), contraction.length());
+
+  base::string16 word;
+  int word_start;
+  int word_length;
+
+  while (contraction_iterator_.GetNextWord(&word, &word_start, &word_length)) {
+    if (!SpellCheckWord(word))
+      return false;
+  }
+  return true;
+}
+
+}  // namespace api
+
+}  // namespace electron
added in remote
  their  100644 85f7541857b00affa935eca56ac1bd530ee9718a electron/renderer/api/electron_api_spell_check_client.h
@@ -0,0 +1,91 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
+#define ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
+
+#include <string>
+#include <vector>
+
+#include "base/callback.h"
+#include "chrome/renderer/spellchecker/spellcheck_worditerator.h"
+#include "native_mate/scoped_persistent.h"
+#include "third_party/WebKit/public/web/WebSpellCheckClient.h"
+
+namespace electron {
+
+namespace api {
+
+class SpellCheckClient : public blink::WebSpellCheckClient {
+ public:
+  SpellCheckClient(const std::string& language,
+                   bool auto_spell_correct_turned_on,
+                   v8::Isolate* isolate,
+                   v8::Local<v8::Object> provider);
+  virtual ~SpellCheckClient();
+
+ private:
+  // blink::WebSpellCheckClient:
+  void spellCheck(
+      const blink::WebString& text,
+      int& misspelledOffset,
+      int& misspelledLength,
+      blink::WebVector<blink::WebString>* optionalSuggestions) override;
+  void checkTextOfParagraph(
+      const blink::WebString&,
+      blink::WebTextCheckingTypeMask mask,
+      blink::WebVector<blink::WebTextCheckingResult>* results) override;
+  void requestCheckingOfText(
+      const blink::WebString& textToCheck,
+      const blink::WebVector<uint32_t>& markersInText,
+      const blink::WebVector<unsigned>& markerOffsets,
+      blink::WebTextCheckingCompletion* completionCallback) override;
+  void showSpellingUI(bool show) override;
+  bool isShowingSpellingUI() override;
+  void updateSpellingUIWithMisspelledWord(
+      const blink::WebString& word) override;
+
+  // Check the spelling of text.
+  void SpellCheckText(const base::string16& text,
+                      bool stop_at_first_result,
+                      std::vector<blink::WebTextCheckingResult>* results);
+
+  // Call JavaScript to check spelling a word.
+  bool SpellCheckWord(const base::string16& word_to_check);
+
+  // Find a possible correctly spelled word for a misspelled word. Computes an
+  // empty string if input misspelled word is too long, there is ambiguity, or
+  // the correct spelling cannot be determined.
+  base::string16 GetAutoCorrectionWord(const base::string16& word);
+
+  // Returns whether or not the given word is a contraction of valid words
+  // (e.g. "word:word").
+  bool IsValidContraction(const base::string16& word);
+
+  // Represents character attributes used for filtering out characters which
+  // are not supported by this SpellCheck object.
+  SpellcheckCharAttribute character_attributes_;
+
+  // Represents word iterators used in this spellchecker. The |text_iterator_|
+  // splits text provided by WebKit into words, contractions, or concatenated
+  // words. The |contraction_iterator_| splits a concatenated word extracted by
+  // |text_iterator_| into word components so we can treat a concatenated word
+  // consisting only of correct words as a correct word.
+  SpellcheckWordIterator text_iterator_;
+  SpellcheckWordIterator contraction_iterator_;
+
+  bool auto_spell_correct_turned_on_;
+
+  v8::Isolate* isolate_;
+  mate::ScopedPersistent<v8::Object> provider_;
+  mate::ScopedPersistent<v8::Function> spell_check_;
+
+  DISALLOW_COPY_AND_ASSIGN(SpellCheckClient);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_API_ELECTRON_API_SPELL_CHECK_CLIENT_H_
added in remote
  their  100644 184b597d27b12619e2fba2387ce2c4250e74a669 electron/renderer/api/electron_api_web_frame.cc
@@ -0,0 +1,210 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/api/electron_api_web_frame.h"
+
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/callback.h"
+#include "electron/common/native_mate_converters/gfx_converter.h"
+#include "electron/common/native_mate_converters/string16_converter.h"
+#include "electron/renderer/api/electron_api_spell_check_client.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_view.h"
+#include "native_mate/dictionary.h"
+#include "native_mate/object_template_builder.h"
+#include "third_party/WebKit/public/web/WebDocument.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebScriptExecutionCallback.h"
+#include "third_party/WebKit/public/web/WebScriptSource.h"
+#include "third_party/WebKit/public/web/WebSecurityPolicy.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+#include "electron/common/node_includes.h"
+
+namespace electron {
+
+namespace api {
+
+namespace {
+
+class ScriptExecutionCallback : public blink::WebScriptExecutionCallback {
+ public:
+  using CompletionCallback =
+      base::Callback<void(
+          const v8::Local<v8::Value>& result)>;
+
+  explicit ScriptExecutionCallback(const CompletionCallback& callback)
+      : callback_(callback) {}
+  ~ScriptExecutionCallback() {}
+
+  void completed(
+      const blink::WebVector<v8::Local<v8::Value>>& result) override {
+    if (!callback_.is_null() && !result.isEmpty() && !result[0].IsEmpty())
+      // Right now only single results per frame is supported.
+      callback_.Run(result[0]);
+    delete this;
+  }
+
+ private:
+  CompletionCallback callback_;
+
+  DISALLOW_COPY_AND_ASSIGN(ScriptExecutionCallback);
+};
+
+}  // namespace
+
+WebFrame::WebFrame()
+    : web_frame_(blink::WebLocalFrame::frameForCurrentContext()) {
+}
+
+WebFrame::~WebFrame() {
+}
+
+void WebFrame::SetName(const std::string& name) {
+  web_frame_->setName(blink::WebString::fromUTF8(name));
+}
+
+double WebFrame::SetZoomLevel(double level) {
+  double ret = web_frame_->view()->setZoomLevel(level);
+  mate::EmitEvent(isolate(), GetWrapper(isolate()), "zoom-level-changed", ret);
+  return ret;
+}
+
+double WebFrame::GetZoomLevel() const {
+  return web_frame_->view()->zoomLevel();
+}
+
+double WebFrame::SetZoomFactor(double factor) {
+  return blink::WebView::zoomLevelToZoomFactor(SetZoomLevel(
+      blink::WebView::zoomFactorToZoomLevel(factor)));
+}
+
+double WebFrame::GetZoomFactor() const {
+  return blink::WebView::zoomLevelToZoomFactor(GetZoomLevel());
+}
+
+void WebFrame::SetZoomLevelLimits(double min_level, double max_level) {
+  web_frame_->view()->setDefaultPageScaleLimits(min_level, max_level);
+}
+
+v8::Local<v8::Value> WebFrame::RegisterEmbedderCustomElement(
+    const base::string16& name, v8::Local<v8::Object> options) {
+  blink::WebExceptionCode c = 0;
+  return web_frame_->document().registerEmbedderCustomElement(name, options, c);
+}
+
+void WebFrame::RegisterElementResizeCallback(
+    int element_instance_id,
+    const GuestViewContainer::ResizeCallback& callback) {
+  auto guest_view_container = GuestViewContainer::FromID(element_instance_id);
+  if (guest_view_container)
+    guest_view_container->RegisterElementResizeCallback(callback);
+}
+
+void WebFrame::AttachGuest(int id) {
+  content::RenderFrame::FromWebFrame(web_frame_)->AttachGuest(id);
+}
+
+void WebFrame::SetSpellCheckProvider(mate::Arguments* args,
+                                     const std::string& language,
+                                     bool auto_spell_correct_turned_on,
+                                     v8::Local<v8::Object> provider) {
+  if (!provider->Has(mate::StringToV8(args->isolate(), "spellCheck"))) {
+    args->ThrowError("\"spellCheck\" has to be defined");
+    return;
+  }
+
+  spell_check_client_.reset(new SpellCheckClient(
+      language, auto_spell_correct_turned_on, args->isolate(), provider));
+  web_frame_->view()->setSpellCheckClient(spell_check_client_.get());
+}
+
+void WebFrame::RegisterURLSchemeAsSecure(const std::string& scheme) {
+  // Register scheme to secure list (https, wss, data).
+  blink::WebSecurityPolicy::registerURLSchemeAsSecure(
+      blink::WebString::fromUTF8(scheme));
+}
+
+void WebFrame::RegisterURLSchemeAsBypassingCSP(const std::string& scheme) {
+  // Register scheme to bypass pages's Content Security Policy.
+  blink::WebSecurityPolicy::registerURLSchemeAsBypassingContentSecurityPolicy(
+      blink::WebString::fromUTF8(scheme));
+}
+
+void WebFrame::RegisterURLSchemeAsPrivileged(const std::string& scheme) {
+  // Register scheme to privileged list (https, wss, data, chrome-extension)
+  blink::WebString privileged_scheme(blink::WebString::fromUTF8(scheme));
+  blink::WebSecurityPolicy::registerURLSchemeAsSecure(privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsBypassingContentSecurityPolicy(
+      privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsAllowingServiceWorkers(
+      privileged_scheme);
+  blink::WebSecurityPolicy::registerURLSchemeAsSupportingFetchAPI(
+      privileged_scheme);
+}
+
+void WebFrame::InsertText(const std::string& text) {
+  web_frame_->insertText(blink::WebString::fromUTF8(text));
+}
+
+void WebFrame::ExecuteJavaScript(const base::string16& code,
+                                 mate::Arguments* args) {
+  bool has_user_gesture = false;
+  args->GetNext(&has_user_gesture);
+  ScriptExecutionCallback::CompletionCallback completion_callback;
+  args->GetNext(&completion_callback);
+  scoped_ptr<blink::WebScriptExecutionCallback> callback(
+      new ScriptExecutionCallback(completion_callback));
+  web_frame_->requestExecuteScriptAndReturnValue(
+      blink::WebScriptSource(code),
+      has_user_gesture,
+      callback.release());
+}
+
+mate::ObjectTemplateBuilder WebFrame::GetObjectTemplateBuilder(
+    v8::Isolate* isolate) {
+  return mate::ObjectTemplateBuilder(isolate)
+      .SetMethod("setName", &WebFrame::SetName)
+      .SetMethod("setZoomLevel", &WebFrame::SetZoomLevel)
+      .SetMethod("getZoomLevel", &WebFrame::GetZoomLevel)
+      .SetMethod("setZoomFactor", &WebFrame::SetZoomFactor)
+      .SetMethod("getZoomFactor", &WebFrame::GetZoomFactor)
+      .SetMethod("setZoomLevelLimits", &WebFrame::SetZoomLevelLimits)
+      .SetMethod("registerEmbedderCustomElement",
+                 &WebFrame::RegisterEmbedderCustomElement)
+      .SetMethod("registerElementResizeCallback",
+                 &WebFrame::RegisterElementResizeCallback)
+      .SetMethod("attachGuest", &WebFrame::AttachGuest)
+      .SetMethod("setSpellCheckProvider", &WebFrame::SetSpellCheckProvider)
+      .SetMethod("registerURLSchemeAsSecure",
+                 &WebFrame::RegisterURLSchemeAsSecure)
+      .SetMethod("registerURLSchemeAsBypassingCSP",
+                 &WebFrame::RegisterURLSchemeAsBypassingCSP)
+      .SetMethod("registerURLSchemeAsPrivileged",
+                 &WebFrame::RegisterURLSchemeAsPrivileged)
+      .SetMethod("insertText", &WebFrame::InsertText)
+      .SetMethod("executeJavaScript", &WebFrame::ExecuteJavaScript);
+}
+
+// static
+mate::Handle<WebFrame> WebFrame::Create(v8::Isolate* isolate) {
+  return CreateHandle(isolate, new WebFrame);
+}
+
+}  // namespace api
+
+}  // namespace electron
+
+namespace {
+
+void Initialize(v8::Local<v8::Object> exports, v8::Local<v8::Value> unused,
+                v8::Local<v8::Context> context, void* priv) {
+  v8::Isolate* isolate = context->GetIsolate();
+  mate::Dictionary dict(isolate, exports);
+  dict.Set("webFrame", electron::api::WebFrame::Create(isolate));
+}
+
+}  // namespace
+
+NODE_MODULE_CONTEXT_AWARE_BUILTIN(electron_renderer_web_frame, Initialize)
added in remote
  their  100644 7723e08a579bef948d2139e066a42783377ab1d0 electron/renderer/api/electron_api_web_frame.h
@@ -0,0 +1,84 @@
+// Copyright (c) 2014 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
+#define ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
+
+#include <string>
+
+#include "electron/renderer/guest_view_container.h"
+#include "base/memory/scoped_ptr.h"
+#include "native_mate/handle.h"
+#include "native_mate/wrappable.h"
+
+namespace blink {
+class WebLocalFrame;
+}
+
+namespace mate {
+class Arguments;
+}
+
+namespace electron {
+
+namespace api {
+
+class SpellCheckClient;
+
+class WebFrame : public mate::Wrappable {
+ public:
+  static mate::Handle<WebFrame> Create(v8::Isolate* isolate);
+
+ private:
+  WebFrame();
+  virtual ~WebFrame();
+
+  void SetName(const std::string& name);
+
+  double SetZoomLevel(double level);
+  double GetZoomLevel() const;
+  double SetZoomFactor(double factor);
+  double GetZoomFactor() const;
+
+  void SetZoomLevelLimits(double min_level, double max_level);
+
+  v8::Local<v8::Value> RegisterEmbedderCustomElement(
+      const base::string16& name, v8::Local<v8::Object> options);
+  void RegisterElementResizeCallback(
+      int element_instance_id,
+      const GuestViewContainer::ResizeCallback& callback);
+  void AttachGuest(int element_instance_id);
+
+  // Set the provider that will be used by SpellCheckClient for spell check.
+  void SetSpellCheckProvider(mate::Arguments* args,
+                             const std::string& language,
+                             bool auto_spell_correct_turned_on,
+                             v8::Local<v8::Object> provider);
+
+  void RegisterURLSchemeAsSecure(const std::string& scheme);
+  void RegisterURLSchemeAsBypassingCSP(const std::string& scheme);
+  void RegisterURLSchemeAsPrivileged(const std::string& scheme);
+
+  // Editing.
+  void InsertText(const std::string& text);
+
+  // Excecuting scripts.
+  void ExecuteJavaScript(const base::string16& code, mate::Arguments* args);
+
+  // mate::Wrappable:
+  virtual mate::ObjectTemplateBuilder GetObjectTemplateBuilder(
+      v8::Isolate* isolate);
+
+  scoped_ptr<SpellCheckClient> spell_check_client_;
+
+  blink::WebLocalFrame* web_frame_;
+
+  DISALLOW_COPY_AND_ASSIGN(WebFrame);
+};
+
+}  // namespace api
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_API_ELECTRON_API_WEB_FRAME_H_
added in remote
  their  100644 9caa7dec200dbfb466a528213e09023834989cd4 electron/renderer/electron_render_view_observer.cc
@@ -0,0 +1,155 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/electron_render_view_observer.h"
+
+#include <string>
+#include <vector>
+
+// Put this before event_emitter_caller.h to have string16 support.
+#include "electron/common/native_mate_converters/string16_converter.h"
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/native_mate_converters/value_converter.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "electron/renderer/electron_renderer_client.h"
+#include "base/command_line.h"
+#include "base/strings/string_number_conversions.h"
+#include "content/public/renderer/render_view.h"
+#include "ipc/ipc_message_macros.h"
+#include "net/base/net_module.h"
+#include "net/grit/net_resources.h"
+#include "third_party/WebKit/public/web/WebDraggableRegion.h"
+#include "third_party/WebKit/public/web/WebDocument.h"
+#include "third_party/WebKit/public/web/WebFrame.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebKit.h"
+#include "third_party/WebKit/public/web/WebView.h"
+#include "ui/base/resource/resource_bundle.h"
+#include "native_mate/dictionary.h"
+
+namespace electron {
+
+namespace {
+
+bool GetIPCObject(v8::Isolate* isolate,
+                  v8::Local<v8::Context> context,
+                  v8::Local<v8::Object>* ipc) {
+  v8::Local<v8::String> key = mate::StringToV8(isolate, "ipc");
+  v8::Local<v8::Private> privateKey = v8::Private::ForApi(isolate, key);
+  v8::Local<v8::Object> global_object = context->Global();
+  v8::Local<v8::Value> value;
+  if (!global_object->GetPrivate(context, privateKey).ToLocal(&value))
+    return false;
+  if (value.IsEmpty() || !value->IsObject())
+    return false;
+  *ipc = value->ToObject();
+  return true;
+}
+
+std::vector<v8::Local<v8::Value>> ListValueToVector(
+    v8::Isolate* isolate,
+    const base::ListValue& list) {
+  v8::Local<v8::Value> array = mate::ConvertToV8(isolate, list);
+  std::vector<v8::Local<v8::Value>> result;
+  mate::ConvertFromV8(isolate, array, &result);
+  return result;
+}
+
+base::StringPiece NetResourceProvider(int key) {
+  if (key == IDR_DIR_HEADER_HTML) {
+    base::StringPiece html_data =
+        ui::ResourceBundle::GetSharedInstance().GetRawDataResource(
+            IDR_DIR_HEADER_HTML);
+    return html_data;
+  }
+  return base::StringPiece();
+}
+
+}  // namespace
+
+ElectronRenderViewObserver::ElectronRenderViewObserver(
+    content::RenderView* render_view,
+    ElectronRendererClient* renderer_client)
+    : content::RenderViewObserver(render_view),
+      renderer_client_(renderer_client),
+      document_created_(false) {
+  // Initialise resource for directory listing.
+  net::NetModule::SetResourceProvider(NetResourceProvider);
+}
+
+ElectronRenderViewObserver::~ElectronRenderViewObserver() {
+}
+
+void ElectronRenderViewObserver::DidCreateDocumentElement(
+    blink::WebLocalFrame* frame) {
+  document_created_ = true;
+
+  // Read --zoom-factor from command line.
+  std::string zoom_factor_str = base::CommandLine::ForCurrentProcess()->
+      GetSwitchValueASCII(switches::kZoomFactor);
+  if (zoom_factor_str.empty())
+    return;
+  double zoom_factor;
+  if (!base::StringToDouble(zoom_factor_str, &zoom_factor))
+    return;
+  double zoom_level = blink::WebView::zoomFactorToZoomLevel(zoom_factor);
+  frame->view()->setZoomLevel(zoom_level);
+}
+
+void ElectronRenderViewObserver::DraggableRegionsChanged(blink::WebFrame* frame) {
+  blink::WebVector<blink::WebDraggableRegion> webregions =
+      frame->document().draggableRegions();
+  std::vector<DraggableRegion> regions;
+  for (size_t i = 0; i < webregions.size(); ++i) {
+    DraggableRegion region;
+    region.bounds = webregions[i].bounds;
+    region.draggable = webregions[i].draggable;
+    regions.push_back(region);
+  }
+  Send(new ElectronViewHostMsg_UpdateDraggableRegions(routing_id(), regions));
+}
+
+bool ElectronRenderViewObserver::OnMessageReceived(const IPC::Message& message) {
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(ElectronRenderViewObserver, message)
+    IPC_MESSAGE_HANDLER(ElectronViewMsg_Message, OnBrowserMessage)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  return handled;
+}
+
+void ElectronRenderViewObserver::OnBrowserMessage(const base::string16& channel,
+                                              const base::ListValue& args) {
+  if (!document_created_)
+    return;
+
+  if (!render_view()->GetWebView())
+    return;
+
+  blink::WebFrame* frame = render_view()->GetWebView()->mainFrame();
+  if (!frame || frame->isWebRemoteFrame())
+    return;
+
+  v8::Isolate* isolate = blink::mainThreadIsolate();
+  v8::HandleScope handle_scope(isolate);
+
+  v8::Local<v8::Context> context = frame->mainWorldScriptContext();
+  v8::Context::Scope context_scope(context);
+
+  v8::Local<v8::Object> ipc;
+  if (GetIPCObject(isolate, context, &ipc)) {
+    auto args_vector = ListValueToVector(isolate, args);
+    // Insert the Event object, event.sender is ipc.
+    mate::Dictionary event = mate::Dictionary::CreateEmpty(isolate);
+    event.Set("sender", ipc);
+    args_vector.insert(args_vector.begin(), event.GetHandle());
+    mate::EmitEvent(isolate, ipc, channel, args_vector);
+  }
+}
+
+}  // namespace electron
added in remote
  their  100644 714395305caebceaffba5558cca3930501b3650d electron/renderer/electron_render_view_observer.h
@@ -0,0 +1,47 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
+#define ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
+
+#include "base/strings/string16.h"
+#include "content/public/renderer/render_view_observer.h"
+
+namespace base {
+class ListValue;
+}
+
+namespace electron {
+
+class ElectronRendererClient;
+
+class ElectronRenderViewObserver : public content::RenderViewObserver {
+ public:
+  explicit ElectronRenderViewObserver(content::RenderView* render_view,
+                                  ElectronRendererClient* renderer_client);
+
+ protected:
+  virtual ~ElectronRenderViewObserver();
+
+ private:
+  // content::RenderViewObserver implementation.
+  void DidCreateDocumentElement(blink::WebLocalFrame* frame) override;
+  void DraggableRegionsChanged(blink::WebFrame* frame) override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  void OnBrowserMessage(const base::string16& channel,
+                        const base::ListValue& args);
+
+  // Weak reference to renderer client.
+  ElectronRendererClient* renderer_client_;
+
+  // Whether the document object has been created.
+  bool document_created_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRenderViewObserver);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_ELECTRON_RENDER_VIEW_OBSERVER_H_
added in remote
  their  100644 6eb66e35b8e76b305296e14079e20e0305845ac0 electron/renderer/electron_renderer_client.cc
@@ -0,0 +1,214 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/electron_renderer_client.h"
+
+#include <string>
+#include <vector>
+
+#include "electron/common/api/api_messages.h"
+#include "electron/common/api/electron_bindings.h"
+#include "electron/common/api/event_emitter_caller.h"
+#include "electron/common/node_bindings.h"
+#include "electron/common/node_includes.h"
+#include "electron/common/options_switches.h"
+#include "electron/renderer/electron_render_view_observer.h"
+#include "electron/renderer/guest_view_container.h"
+#include "electron/renderer/node_array_buffer_bridge.h"
+#include "base/command_line.h"
+#include "chrome/renderer/media/chrome_key_systems.h"
+#include "chrome/renderer/pepper/pepper_helper.h"
+#include "chrome/renderer/printing/print_web_view_helper.h"
+#include "chrome/renderer/tts_dispatcher.h"
+#include "content/public/common/content_constants.h"
+#include "content/public/renderer/render_frame.h"
+#include "content/public/renderer/render_frame_observer.h"
+#include "content/public/renderer/render_thread.h"
+#include "content/public/renderer/render_view.h"
+#include "ipc/ipc_message_macros.h"
+#include "third_party/WebKit/public/web/WebCustomElement.h"
+#include "third_party/WebKit/public/web/WebLocalFrame.h"
+#include "third_party/WebKit/public/web/WebPluginParams.h"
+#include "third_party/WebKit/public/web/WebKit.h"
+#include "third_party/WebKit/public/web/WebSecurityPolicy.h"
+#include "third_party/WebKit/public/web/WebRuntimeFeatures.h"
+#include "third_party/WebKit/public/web/WebView.h"
+
+#if defined(OS_WIN)
+#include <shlobj.h>
+#endif
+
+namespace electron {
+
+namespace {
+
+// Helper class to forward the messages to the client.
+class ElectronRenderFrameObserver : public content::RenderFrameObserver {
+ public:
+  ElectronRenderFrameObserver(content::RenderFrame* frame,
+                          ElectronRendererClient* renderer_client)
+      : content::RenderFrameObserver(frame),
+        world_id_(-1),
+        renderer_client_(renderer_client) {}
+
+  // content::RenderFrameObserver:
+  void DidCreateScriptContext(v8::Handle<v8::Context> context,
+                              int extension_group,
+                              int world_id) override {
+    if (world_id_ != -1 && world_id_ != world_id)
+      return;
+    world_id_ = world_id;
+    renderer_client_->DidCreateScriptContext(context);
+  }
+  void WillReleaseScriptContext(v8::Local<v8::Context> context,
+                                int world_id) override {
+    if (world_id_ != world_id)
+      return;
+    renderer_client_->WillReleaseScriptContext(context);
+  }
+
+ private:
+  int world_id_;
+  ElectronRendererClient* renderer_client_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRenderFrameObserver);
+};
+
+}  // namespace
+
+ElectronRendererClient::ElectronRendererClient()
+    : node_bindings_(NodeBindings::Create(false)),
+      electron_bindings_(new ElectronBindings) {
+}
+
+ElectronRendererClient::~ElectronRendererClient() {
+}
+
+void ElectronRendererClient::WebKitInitialized() {
+  blink::WebCustomElement::addEmbedderCustomElementName("webview");
+  blink::WebCustomElement::addEmbedderCustomElementName("browserplugin");
+
+  OverrideNodeArrayBuffer();
+}
+
+void ElectronRendererClient::RenderThreadStarted() {
+  content::RenderThread::Get()->AddObserver(this);
+
+#if defined(OS_WIN)
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  base::string16 app_id =
+      command_line->GetSwitchValueNative(switches::kAppUserModelId);
+  if (!app_id.empty()) {
+    SetCurrentProcessExplicitAppUserModelID(app_id.c_str());
+  }
+#endif
+}
+
+void ElectronRendererClient::RenderFrameCreated(
+    content::RenderFrame* render_frame) {
+  new PepperHelper(render_frame);
+
+  // Allow file scheme to handle service worker by default.
+  blink::WebSecurityPolicy::registerURLSchemeAsAllowingServiceWorkers("file");
+
+  // Only insert node integration for the main frame.
+  if (!render_frame->IsMainFrame())
+    return;
+
+  new ElectronRenderFrameObserver(render_frame, this);
+}
+
+void ElectronRendererClient::RenderViewCreated(content::RenderView* render_view) {
+  // Set default UA-dependent background as transparent.
+  render_view->GetWebView()->setBaseBackgroundColor(SK_ColorTRANSPARENT);
+
+  new printing::PrintWebViewHelper(render_view);
+  new ElectronRenderViewObserver(render_view, this);
+}
+
+blink::WebSpeechSynthesizer* ElectronRendererClient::OverrideSpeechSynthesizer(
+    blink::WebSpeechSynthesizerClient* client) {
+  return new TtsDispatcher(client);
+}
+
+bool ElectronRendererClient::OverrideCreatePlugin(
+    content::RenderFrame* render_frame,
+    blink::WebLocalFrame* frame,
+    const blink::WebPluginParams& params,
+    blink::WebPlugin** plugin) {
+  base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
+  if (params.mimeType.utf8() == content::kBrowserPluginMimeType ||
+      command_line->HasSwitch(switches::kEnablePlugins))
+    return false;
+
+  *plugin = nullptr;
+  return true;
+}
+
+void ElectronRendererClient::DidCreateScriptContext(
+    v8::Handle<v8::Context> context) {
+  // Whether the node binding has been initialized.
+  bool first_time = node_bindings_->uv_env() == nullptr;
+
+  // Prepare the node bindings.
+  if (first_time) {
+    node_bindings_->Initialize();
+    node_bindings_->PrepareMessageLoop();
+  }
+
+  // Setup node environment for each window.
+  node::Environment* env = node_bindings_->CreateEnvironment(context);
+
+  // Add Electron extended APIs.
+  electron_bindings_->BindTo(env->isolate(), env->process_object());
+
+  // Load everything.
+  node_bindings_->LoadEnvironment(env);
+
+  if (first_time) {
+    // Make uv loop being wrapped by window context.
+    node_bindings_->set_uv_env(env);
+
+    // Give the node loop a run to make sure everything is ready.
+    node_bindings_->RunMessageLoop();
+  }
+}
+
+void ElectronRendererClient::WillReleaseScriptContext(
+    v8::Handle<v8::Context> context) {
+  node::Environment* env = node::Environment::GetCurrent(context);
+  mate::EmitEvent(env->isolate(), env->process_object(), "exit");
+}
+
+bool ElectronRendererClient::ShouldFork(blink::WebLocalFrame* frame,
+                                    const GURL& url,
+                                    const std::string& http_method,
+                                    bool is_initial_navigation,
+                                    bool is_server_redirect,
+                                    bool* send_referrer) {
+  // Handle all the navigations and reloads in browser.
+  // FIXME We only support GET here because http method will be ignored when
+  // the OpenURLFromTab is triggered, which means form posting would not work,
+  // we should solve this by patching Chromium in future.
+  *send_referrer = true;
+  return http_method == "GET";
+}
+
+content::BrowserPluginDelegate* ElectronRendererClient::CreateBrowserPluginDelegate(
+    content::RenderFrame* render_frame,
+    const std::string& mime_type,
+    const GURL& original_url) {
+  if (mime_type == content::kBrowserPluginMimeType) {
+    return new GuestViewContainer(render_frame);
+  } else {
+    return nullptr;
+  }
+}
+
+void ElectronRendererClient::AddKeySystems(
+    std::vector<media::KeySystemInfo>* key_systems) {
+  AddChromeKeySystems(key_systems);
+}
+
+}  // namespace electron
added in remote
  their  100644 9a5440c6b71174f94d37bfa148151b8b862199aa electron/renderer/electron_renderer_client.h
@@ -0,0 +1,69 @@
+// Copyright (c) 2013 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
+#define ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
+
+#include <string>
+#include <vector>
+
+#include "content/public/renderer/content_renderer_client.h"
+#include "content/public/renderer/render_process_observer.h"
+
+namespace electron {
+
+class ElectronBindings;
+class NodeBindings;
+
+class ElectronRendererClient : public content::ContentRendererClient,
+                           public content::RenderProcessObserver {
+ public:
+  ElectronRendererClient();
+  virtual ~ElectronRendererClient();
+
+  void DidCreateScriptContext(v8::Handle<v8::Context> context);
+  void WillReleaseScriptContext(v8::Handle<v8::Context> context);
+
+ private:
+  enum NodeIntegration {
+    ALL,
+    EXCEPT_IFRAME,
+    MANUAL_ENABLE_IFRAME,
+    DISABLE,
+  };
+
+  // content::RenderProcessObserver:
+  void WebKitInitialized() override;
+
+  // content::ContentRendererClient:
+  void RenderThreadStarted() override;
+  void RenderFrameCreated(content::RenderFrame*) override;
+  void RenderViewCreated(content::RenderView*) override;
+  blink::WebSpeechSynthesizer* OverrideSpeechSynthesizer(
+      blink::WebSpeechSynthesizerClient* client) override;
+  bool OverrideCreatePlugin(content::RenderFrame* render_frame,
+                            blink::WebLocalFrame* frame,
+                            const blink::WebPluginParams& params,
+                            blink::WebPlugin** plugin) override;
+  bool ShouldFork(blink::WebLocalFrame* frame,
+                  const GURL& url,
+                  const std::string& http_method,
+                  bool is_initial_navigation,
+                  bool is_server_redirect,
+                  bool* send_referrer) override;
+  content::BrowserPluginDelegate* CreateBrowserPluginDelegate(
+      content::RenderFrame* render_frame,
+      const std::string& mime_type,
+      const GURL& original_url) override;
+  void AddKeySystems(std::vector<media::KeySystemInfo>* key_systems) override;
+
+  scoped_ptr<NodeBindings> node_bindings_;
+  scoped_ptr<ElectronBindings> electron_bindings_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronRendererClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_ELECTRON_RENDERER_CLIENT_H_
added in remote
  their  100644 40541fccd4e27021915b2290b2aff68ee1b962aa electron/renderer/guest_view_container.cc
@@ -0,0 +1,65 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/guest_view_container.h"
+
+#include <map>
+
+#include "base/bind.h"
+#include "base/lazy_instance.h"
+#include "base/message_loop/message_loop.h"
+#include "ui/gfx/geometry/size.h"
+
+namespace electron {
+
+namespace {
+
+using GuestViewContainerMap = std::map<int, GuestViewContainer*>;
+static base::LazyInstance<GuestViewContainerMap> g_guest_view_container_map =
+    LAZY_INSTANCE_INITIALIZER;
+
+}  // namespace
+
+GuestViewContainer::GuestViewContainer(content::RenderFrame* render_frame)
+    : render_frame_(render_frame),
+      weak_ptr_factory_(this) {
+}
+
+GuestViewContainer::~GuestViewContainer() {
+  if (element_instance_id_ > 0)
+    g_guest_view_container_map.Get().erase(element_instance_id_);
+}
+
+// static
+GuestViewContainer* GuestViewContainer::FromID(int element_instance_id) {
+  GuestViewContainerMap* guest_view_containers =
+      g_guest_view_container_map.Pointer();
+  auto it = guest_view_containers->find(element_instance_id);
+  return it == guest_view_containers->end() ? nullptr : it->second;
+}
+
+void GuestViewContainer::RegisterElementResizeCallback(
+    const ResizeCallback& callback) {
+  element_resize_callback_ = callback;
+}
+
+void GuestViewContainer::SetElementInstanceID(int element_instance_id) {
+  element_instance_id_ = element_instance_id;
+  g_guest_view_container_map.Get().insert(
+      std::make_pair(element_instance_id, this));
+}
+
+void GuestViewContainer::DidResizeElement(const gfx::Size& new_size) {
+  if (element_resize_callback_.is_null())
+    return;
+
+  base::MessageLoop::current()->PostTask(
+      FROM_HERE, base::Bind(element_resize_callback_, new_size));
+}
+
+base::WeakPtr<content::BrowserPluginDelegate> GuestViewContainer::GetWeakPtr() {
+  return weak_ptr_factory_.GetWeakPtr();
+}
+
+}  // namespace electron
added in remote
  their  100644 3fd4dc87aff131b320551b3cb4c31d59f9fc3e57 electron/renderer/guest_view_container.h
@@ -0,0 +1,46 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
+#define ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
+
+#include "base/callback.h"
+#include "content/public/renderer/browser_plugin_delegate.h"
+
+namespace gfx {
+class Size;
+}
+
+namespace electron {
+
+class GuestViewContainer : public content::BrowserPluginDelegate {
+ public:
+  typedef base::Callback<void(const gfx::Size&)> ResizeCallback;
+
+  explicit GuestViewContainer(content::RenderFrame* render_frame);
+  ~GuestViewContainer() override;
+
+  static GuestViewContainer* FromID(int element_instance_id);
+
+  void RegisterElementResizeCallback(const ResizeCallback& callback);
+
+  // content::BrowserPluginDelegate:
+  void SetElementInstanceID(int element_instance_id) final;
+  void DidResizeElement(const gfx::Size& new_size) final;
+  base::WeakPtr<BrowserPluginDelegate> GetWeakPtr() final;
+
+ private:
+  int element_instance_id_;
+  content::RenderFrame* render_frame_;
+
+  ResizeCallback element_resize_callback_;
+
+  base::WeakPtrFactory<GuestViewContainer> weak_ptr_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(GuestViewContainer);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_GUEST_VIEW_CONTAINER_H_
added in remote
  their  100644 3c5f7df558e9ec455f35596d7fdd626298ce38ed electron/renderer/node_array_buffer_bridge.cc
@@ -0,0 +1,66 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/renderer/node_array_buffer_bridge.h"
+
+#include "base/macros.h"
+#include "electron/common/node_includes.h"
+#include "native_mate/converter.h"
+#include "third_party/WebKit/public/web/WebArrayBuffer.h"
+#include "third_party/WebKit/public/web/WebArrayBufferConverter.h"
+
+namespace electron {
+
+namespace {
+
+// global.Uint8Array;
+v8::Local<v8::Function> GetUint8ArrayConstructor(
+    v8::Isolate* isolate, v8::Local<v8::Context> context) {
+  v8::Local<v8::Value> constructor = context->Global()->Get(
+      mate::StringToV8(isolate, "Uint8Array"));
+  return v8::Local<v8::Function>::Cast(constructor);
+}
+
+// new ArrayBuffer(size);
+v8::Local<v8::ArrayBuffer> BlinkArrayBufferNew(
+    v8::Isolate* isolate, size_t size) {
+  blink::WebArrayBuffer buffer = blink::WebArrayBuffer::create(size, 1);
+  return v8::Local<v8::ArrayBuffer>::Cast(
+      blink::WebArrayBufferConverter::toV8Value(
+          &buffer, isolate->GetCurrentContext()->Global(), isolate));
+}
+
+// new ArrayBuffer(data, size);
+v8::Local<v8::ArrayBuffer> BlinkArrayBufferNewWith(
+    v8::Isolate* isolate, void* data, size_t size) {
+  blink::WebArrayBuffer buffer = blink::WebArrayBuffer::createExternal(
+      data, size);
+  return v8::Local<v8::ArrayBuffer>::Cast(
+      blink::WebArrayBufferConverter::toV8Value(
+          &buffer, isolate->GetCurrentContext()->Global(), isolate));
+}
+
+// new Uint8Array(array_buffer, offset, size);
+v8::Local<v8::Uint8Array> BlinkUint8ArrayNew(
+    v8::Local<v8::ArrayBuffer> ab, size_t offset, size_t size) {
+  // Use the DOM's Uint8Array constructor to create Uint8Array.
+  v8::Local<v8::Context> context = ab->CreationContext();
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::Local<v8::Function> constructor =
+      GetUint8ArrayConstructor(isolate, context);
+  v8::Local<v8::Value> args[] = {
+      ab, mate::ConvertToV8(isolate, offset), mate::ConvertToV8(isolate, size)
+  };
+  return v8::Local<v8::Uint8Array>::Cast(constructor->NewInstance(
+      context, arraysize(args), args).ToLocalChecked());
+}
+
+}  // namespace
+
+void OverrideNodeArrayBuffer() {
+  node::Buffer::SetArrayBufferCreator(
+      BlinkArrayBufferNew, BlinkArrayBufferNewWith, BlinkUint8ArrayNew);
+}
+
+}  // namespace electron
added in remote
  their  100644 182f19e8ec16c8312fa70ea67c2376a74043bd5b electron/renderer/node_array_buffer_bridge.h
@@ -0,0 +1,15 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
+#define ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
+
+namespace electron {
+
+// Override Node's ArrayBuffer with DOM's ArrayBuffer.
+void OverrideNodeArrayBuffer();
+
+}  // namespace electron
+
+#endif  // ELECTRON_RENDERER_NODE_ARRAY_BUFFER_BRIDGE_H_
added in remote
  their  100644 2d39d2a9845a90a066120fa302b031641faa11b9 electron/renderer/resources/mac/Info.plist
@@ -0,0 +1,16 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
+<plist version="1.0">
+<dict>
+  <key>CFBundleIdentifier</key>
+  <string>${ELECTRON_BUNDLE_ID}</string>
+  <key>CFBundleName</key>
+  <string>${PRODUCT_NAME}</string>
+  <key>CFBundlePackageType</key>
+  <string>APPL</string>
+  <key>LSUIElement</key>
+  <true/>
+  <key>NSSupportsAutomaticGraphicsSwitching</key>
+  <true/>
+</dict>
+</plist>
added in remote
  their  100644 879c3ffccdd878603c11d69bb754690d936b531a electron/utility/electron_content_utility_client.cc
@@ -0,0 +1,81 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#include "electron/utility/electron_content_utility_client.h"
+
+#include "base/command_line.h"
+#include "base/files/file_path.h"
+#include "base/memory/ref_counted.h"
+#include "base/time/time.h"
+#include "chrome/common/chrome_utility_messages.h"
+#include "chrome/utility/utility_message_handler.h"
+#include "content/public/common/content_switches.h"
+#include "content/public/utility/utility_thread.h"
+#include "ipc/ipc_channel.h"
+#include "ipc/ipc_message_macros.h"
+
+
+#if defined(OS_WIN)
+#include "chrome/utility/printing_handler_win.h"
+#endif
+
+
+namespace {
+
+bool Send(IPC::Message* message) {
+  return content::UtilityThread::Get()->Send(message);
+}
+
+}  // namespace
+
+namespace electron {
+
+int64_t ElectronContentUtilityClient::max_ipc_message_size_ =
+    IPC::Channel::kMaximumMessageSize;
+
+ElectronContentUtilityClient::ElectronContentUtilityClient()
+    : filter_messages_(false) {
+#if defined(OS_WIN)
+  handlers_.push_back(new PrintingHandlerWin());
+#endif
+}
+
+ElectronContentUtilityClient::~ElectronContentUtilityClient() {
+}
+
+void ElectronContentUtilityClient::UtilityThreadStarted() {
+}
+
+bool ElectronContentUtilityClient::OnMessageReceived(
+    const IPC::Message& message) {
+  if (filter_messages_ && !ContainsKey(message_id_whitelist_, message.type()))
+    return false;
+
+  bool handled = true;
+  IPC_BEGIN_MESSAGE_MAP(ElectronContentUtilityClient, message)
+    IPC_MESSAGE_HANDLER(ChromeUtilityMsg_StartupPing, OnStartupPing)
+    IPC_MESSAGE_UNHANDLED(handled = false)
+  IPC_END_MESSAGE_MAP()
+
+  for (Handlers::iterator it = handlers_.begin();
+       !handled && it != handlers_.end(); ++it) {
+    handled = (*it)->OnMessageReceived(message);
+  }
+
+  return handled;
+}
+
+void ElectronContentUtilityClient::OnStartupPing() {
+  Send(new ChromeUtilityHostMsg_ProcessStarted);
+  // Don't release the process, we assume further messages are on the way.
+}
+
+// static
+void ElectronContentUtilityClient::PreSandboxStartup() {
+#if defined(OS_WIN)
+  PrintingHandlerWin::PreSandboxStartup();
+#endif
+}
+
+}  // namespace electron
added in remote
  their  100644 29700bb05c8e8ae9fa408096cd0da806b9cc232a electron/utility/electron_content_utility_client.h
@@ -0,0 +1,58 @@
+// Copyright (c) 2015 GitHub, Inc.
+// Use of this source code is governed by the MIT license that can be
+// found in the LICENSE file.
+
+#ifndef ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
+#define ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
+
+#include <set>
+#include <string>
+#include <vector>
+
+#include "base/compiler_specific.h"
+#include "base/memory/scoped_vector.h"
+#include "content/public/utility/content_utility_client.h"
+#include "ipc/ipc_platform_file.h"
+
+namespace base {
+class FilePath;
+struct FileDescriptor;
+}
+
+class UtilityMessageHandler;
+
+namespace electron {
+
+class ElectronContentUtilityClient : public content::ContentUtilityClient {
+ public:
+  ElectronContentUtilityClient();
+  ~ElectronContentUtilityClient() override;
+
+  void UtilityThreadStarted() override;
+  bool OnMessageReceived(const IPC::Message& message) override;
+
+  static void PreSandboxStartup();
+
+  static void set_max_ipc_message_size_for_test(int64_t max_message_size) {
+    max_ipc_message_size_ = max_message_size;
+  }
+
+ private:
+  void OnStartupPing();
+
+  typedef ScopedVector<UtilityMessageHandler> Handlers;
+  Handlers handlers_;
+
+  // Flag to enable whitelisting.
+  bool filter_messages_;
+  // A list of message_ids to filter.
+  std::set<int> message_id_whitelist_;
+  // Maximum IPC msg size (default to kMaximumMessageSize; override for testing)
+  static int64_t max_ipc_message_size_;
+
+  DISALLOW_COPY_AND_ASSIGN(ElectronContentUtilityClient);
+};
+
+}  // namespace electron
+
+#endif  // ELECTRON_UTILITY_ELECTRON_CONTENT_UTILITY_CLIENT_H_
changed in both
  base   100644 baf0202f3eca9811577c06ca30e215eae1da888a filenames.gypi
  our    100644 f57860558f06b7e5d8a50f48cfc7e53044df0bc6 filenames.gypi
  their  100644 75c0fbc18740d07f20b3cdbe5075e233f2ac3856 filenames.gypi
@@ -1,11 +1,15 @@
 {
   'variables': {
     'app_sources': [
-      'atom/app/atom_main.cc',
-      'atom/app/atom_main.h',
+      'electron/app/electron_main.cc',
+      'electron/app/electron_main.h',
     ],
     'bundle_sources': [
+<<<<<<< .our
       'atom/browser/resources/mac/electron.icns',
+=======
+      'electron/browser/resources/mac/electron.icns',
+>>>>>>> .their
     ],
     'js_sources': [
       'lib/browser/api/app.js',
@@ -107,6 +111,7 @@
       'node_modules/octicons/build/svg/gift.svg',
     ],
     'lib_sources': [
+<<<<<<< .our
       'atom/app/atom_content_client.cc',
       'atom/app/atom_content_client.h',
       'atom/app/atom_main_delegate.cc',
@@ -563,6 +568,318 @@
       'atom/renderer/web_worker_observer.h',
       'atom/utility/atom_content_utility_client.cc',
       'atom/utility/atom_content_utility_client.h',
+=======
+      'electron/app/electron_content_client.cc',
+      'electron/app/electron_content_client.h',
+      'electron/app/electron_main_delegate.cc',
+      'electron/app/electron_main_delegate.h',
+      'electron/app/electron_main_delegate_mac.mm',
+      'electron/app/node_main.cc',
+      'electron/app/node_main.h',
+      'electron/app/uv_task_runner.cc',
+      'electron/app/uv_task_runner.h',
+      'electron/browser/api/electron_api_app.cc',
+      'electron/browser/api/electron_api_app.h',
+      'electron/browser/api/electron_api_auto_updater.cc',
+      'electron/browser/api/electron_api_auto_updater.h',
+      'electron/browser/api/electron_api_content_tracing.cc',
+      'electron/browser/api/electron_api_cookies.cc',
+      'electron/browser/api/electron_api_cookies.h',
+      'electron/browser/api/electron_api_debugger.cc',
+      'electron/browser/api/electron_api_debugger.h',
+      'electron/browser/api/electron_api_desktop_capturer.cc',
+      'electron/browser/api/electron_api_desktop_capturer.h',
+      'electron/browser/api/electron_api_download_item.cc',
+      'electron/browser/api/electron_api_download_item.h',
+      'electron/browser/api/electron_api_dialog.cc',
+      'electron/browser/api/electron_api_global_shortcut.cc',
+      'electron/browser/api/electron_api_global_shortcut.h',
+      'electron/browser/api/electron_api_menu.cc',
+      'electron/browser/api/electron_api_menu.h',
+      'electron/browser/api/electron_api_menu_views.cc',
+      'electron/browser/api/electron_api_menu_views.h',
+      'electron/browser/api/electron_api_menu_mac.h',
+      'electron/browser/api/electron_api_menu_mac.mm',
+      'electron/browser/api/electron_api_power_monitor.cc',
+      'electron/browser/api/electron_api_power_monitor.h',
+      'electron/browser/api/electron_api_power_save_blocker.cc',
+      'electron/browser/api/electron_api_power_save_blocker.h',
+      'electron/browser/api/electron_api_protocol.cc',
+      'electron/browser/api/electron_api_protocol.h',
+      'electron/browser/api/electron_api_screen.cc',
+      'electron/browser/api/electron_api_screen.h',
+      'electron/browser/api/electron_api_session.cc',
+      'electron/browser/api/electron_api_session.h',
+      'electron/browser/api/electron_api_tray.cc',
+      'electron/browser/api/electron_api_tray.h',
+      'electron/browser/api/electron_api_web_contents.cc',
+      'electron/browser/api/electron_api_web_contents.h',
+      'electron/browser/api/electron_api_web_request.cc',
+      'electron/browser/api/electron_api_web_request.h',
+      'electron/browser/api/electron_api_web_view_manager.cc',
+      'electron/browser/api/electron_api_window.cc',
+      'electron/browser/api/electron_api_window.h',
+      'electron/browser/api/event.cc',
+      'electron/browser/api/event.h',
+      'electron/browser/api/event_emitter.cc',
+      'electron/browser/api/event_emitter.h',
+      'electron/browser/api/trackable_object.cc',
+      'electron/browser/api/trackable_object.h',
+      'electron/browser/api/frame_subscriber.cc',
+      'electron/browser/api/frame_subscriber.h',
+      'electron/browser/api/save_page_handler.cc',
+      'electron/browser/api/save_page_handler.h',
+      'electron/browser/auto_updater.cc',
+      'electron/browser/auto_updater.h',
+      'electron/browser/auto_updater_mac.mm',
+      'electron/browser/electron_access_token_store.cc',
+      'electron/browser/electron_access_token_store.h',
+      'electron/browser/electron_browser_client.cc',
+      'electron/browser/electron_browser_client.h',
+      'electron/browser/electron_browser_context.cc',
+      'electron/browser/electron_browser_context.h',
+      'electron/browser/electron_download_manager_delegate.cc',
+      'electron/browser/electron_download_manager_delegate.h',
+      'electron/browser/electron_browser_main_parts.cc',
+      'electron/browser/electron_browser_main_parts.h',
+      'electron/browser/electron_browser_main_parts_mac.mm',
+      'electron/browser/electron_browser_main_parts_posix.cc',
+      'electron/browser/electron_javascript_dialog_manager.cc',
+      'electron/browser/electron_javascript_dialog_manager.h',
+      'electron/browser/electron_permission_manager.cc',
+      'electron/browser/electron_permission_manager.h',
+      'electron/browser/electron_quota_permission_context.cc',
+      'electron/browser/electron_quota_permission_context.h',
+      'electron/browser/electron_resource_dispatcher_host_delegate.cc',
+      'electron/browser/electron_resource_dispatcher_host_delegate.h',
+      'electron/browser/electron_speech_recognition_manager_delegate.cc',
+      'electron/browser/electron_speech_recognition_manager_delegate.h',
+      'electron/browser/bridge_task_runner.cc',
+      'electron/browser/bridge_task_runner.h',
+      'electron/browser/browser.cc',
+      'electron/browser/browser.h',
+      'electron/browser/browser_linux.cc',
+      'electron/browser/browser_mac.mm',
+      'electron/browser/browser_win.cc',
+      'electron/browser/browser_observer.h',
+      'electron/browser/common_web_contents_delegate.cc',
+      'electron/browser/common_web_contents_delegate.h',
+      'electron/browser/javascript_environment.cc',
+      'electron/browser/javascript_environment.h',
+      'electron/browser/login_handler.cc',
+      'electron/browser/login_handler.h',
+      'electron/browser/mac/electron_application.h',
+      'electron/browser/mac/electron_application.mm',
+      'electron/browser/mac/electron_application_delegate.h',
+      'electron/browser/mac/electron_application_delegate.mm',
+      'electron/browser/native_window.cc',
+      'electron/browser/native_window.h',
+      'electron/browser/native_window_views_win.cc',
+      'electron/browser/native_window_views.cc',
+      'electron/browser/native_window_views.h',
+      'electron/browser/native_window_mac.h',
+      'electron/browser/native_window_mac.mm',
+      'electron/browser/native_window_observer.h',
+      'electron/browser/net/asar/asar_protocol_handler.cc',
+      'electron/browser/net/asar/asar_protocol_handler.h',
+      'electron/browser/net/asar/url_request_asar_job.cc',
+      'electron/browser/net/asar/url_request_asar_job.h',
+      'electron/browser/net/electron_cert_verifier.cc',
+      'electron/browser/net/electron_cert_verifier.h',
+      'electron/browser/net/electron_network_delegate.cc',
+      'electron/browser/net/electron_network_delegate.h',
+      'electron/browser/net/electron_ssl_config_service.cc',
+      'electron/browser/net/electron_ssl_config_service.h',
+      'electron/browser/net/electron_url_request_job_factory.cc',
+      'electron/browser/net/electron_url_request_job_factory.h',
+      'electron/browser/net/http_protocol_handler.cc',
+      'electron/browser/net/http_protocol_handler.h',
+      'electron/browser/net/js_asker.cc',
+      'electron/browser/net/js_asker.h',
+      'electron/browser/net/url_request_async_asar_job.cc',
+      'electron/browser/net/url_request_async_asar_job.h',
+      'electron/browser/net/url_request_string_job.cc',
+      'electron/browser/net/url_request_string_job.h',
+      'electron/browser/net/url_request_buffer_job.cc',
+      'electron/browser/net/url_request_buffer_job.h',
+      'electron/browser/net/url_request_fetch_job.cc',
+      'electron/browser/net/url_request_fetch_job.h',
+      'electron/browser/node_debugger.cc',
+      'electron/browser/node_debugger.h',
+      'electron/browser/ui/accelerator_util.cc',
+      'electron/browser/ui/accelerator_util.h',
+      'electron/browser/ui/accelerator_util_mac.mm',
+      'electron/browser/ui/accelerator_util_views.cc',
+      'electron/browser/ui/electron_menu_model.cc',
+      'electron/browser/ui/electron_menu_model.h',
+      'electron/browser/ui/cocoa/electron_menu_controller.h',
+      'electron/browser/ui/cocoa/electron_menu_controller.mm',
+      'electron/browser/ui/file_dialog.h',
+      'electron/browser/ui/file_dialog_gtk.cc',
+      'electron/browser/ui/file_dialog_mac.mm',
+      'electron/browser/ui/file_dialog_win.cc',
+      'electron/browser/ui/message_box.h',
+      'electron/browser/ui/message_box_gtk.cc',
+      'electron/browser/ui/message_box_mac.mm',
+      'electron/browser/ui/message_box_win.cc',
+      'electron/browser/ui/tray_icon.cc',
+      'electron/browser/ui/tray_icon.h',
+      'electron/browser/ui/tray_icon_gtk.cc',
+      'electron/browser/ui/tray_icon_gtk.h',
+      'electron/browser/ui/tray_icon_cocoa.h',
+      'electron/browser/ui/tray_icon_cocoa.mm',
+      'electron/browser/ui/tray_icon_observer.h',
+      'electron/browser/ui/tray_icon_win.cc',
+      'electron/browser/ui/views/frameless_view.cc',
+      'electron/browser/ui/views/frameless_view.h',
+      'electron/browser/ui/views/global_menu_bar_x11.cc',
+      'electron/browser/ui/views/global_menu_bar_x11.h',
+      'electron/browser/ui/views/menu_bar.cc',
+      'electron/browser/ui/views/menu_bar.h',
+      'electron/browser/ui/views/menu_delegate.cc',
+      'electron/browser/ui/views/menu_delegate.h',
+      'electron/browser/ui/views/menu_layout.cc',
+      'electron/browser/ui/views/menu_layout.h',
+      'electron/browser/ui/views/native_frame_view.cc',
+      'electron/browser/ui/views/native_frame_view.h',
+      'electron/browser/ui/views/submenu_button.cc',
+      'electron/browser/ui/views/submenu_button.h',
+      'electron/browser/ui/views/win_frame_view.cc',
+      'electron/browser/ui/views/win_frame_view.h',
+      'electron/browser/ui/win/electron_desktop_window_tree_host_win.cc',
+      'electron/browser/ui/win/electron_desktop_window_tree_host_win.h',
+      'electron/browser/ui/win/message_handler_delegate.cc',
+      'electron/browser/ui/win/message_handler_delegate.h',
+      'electron/browser/ui/win/notify_icon_host.cc',
+      'electron/browser/ui/win/notify_icon_host.h',
+      'electron/browser/ui/win/notify_icon.cc',
+      'electron/browser/ui/win/notify_icon.h',
+      'electron/browser/ui/win/taskbar_host.cc',
+      'electron/browser/ui/win/taskbar_host.h',
+      'electron/browser/ui/x/window_state_watcher.cc',
+      'electron/browser/ui/x/window_state_watcher.h',
+      'electron/browser/ui/x/x_window_utils.cc',
+      'electron/browser/ui/x/x_window_utils.h',
+      'electron/browser/web_contents_permission_helper.cc',
+      'electron/browser/web_contents_permission_helper.h',
+      'electron/browser/web_contents_preferences.cc',
+      'electron/browser/web_contents_preferences.h',
+      'electron/browser/web_dialog_helper.cc',
+      'electron/browser/web_dialog_helper.h',
+      'electron/browser/web_view_guest_delegate.cc',
+      'electron/browser/web_view_guest_delegate.h',
+      'electron/browser/web_view_manager.cc',
+      'electron/browser/web_view_manager.h',
+      'electron/browser/window_list.cc',
+      'electron/browser/window_list.h',
+      'electron/browser/window_list_observer.h',
+      'electron/common/api/api_messages.h',
+      'electron/common/api/electron_api_asar.cc',
+      'electron/common/api/electron_api_clipboard.cc',
+      'electron/common/api/electron_api_crash_reporter.cc',
+      'electron/common/api/electron_api_id_weak_map.cc',
+      'electron/common/api/electron_api_id_weak_map.h',
+      'electron/common/api/electron_api_native_image.cc',
+      'electron/common/api/electron_api_native_image.h',
+      'electron/common/api/electron_api_native_image_mac.mm',
+      'electron/common/api/electron_api_shell.cc',
+      'electron/common/api/electron_api_v8_util.cc',
+      'electron/common/api/electron_bindings.cc',
+      'electron/common/api/electron_bindings.h',
+      'electron/common/api/event_emitter_caller.cc',
+      'electron/common/api/event_emitter_caller.h',
+      'electron/common/api/locker.cc',
+      'electron/common/api/locker.h',
+      'electron/common/api/object_life_monitor.cc',
+      'electron/common/api/object_life_monitor.h',
+      'electron/common/asar/archive.cc',
+      'electron/common/asar/archive.h',
+      'electron/common/asar/asar_util.cc',
+      'electron/common/asar/asar_util.h',
+      'electron/common/asar/scoped_temporary_file.cc',
+      'electron/common/asar/scoped_temporary_file.h',
+      'electron/common/electron_command_line.cc',
+      'electron/common/electron_command_line.h',
+      'electron/common/electron_constants.cc',
+      'electron/common/electron_constants.h',
+      'electron/common/common_message_generator.cc',
+      'electron/common/common_message_generator.h',
+      'electron/common/crash_reporter/crash_reporter.cc',
+      'electron/common/crash_reporter/crash_reporter.h',
+      'electron/common/crash_reporter/crash_reporter_linux.cc',
+      'electron/common/crash_reporter/crash_reporter_linux.h',
+      'electron/common/crash_reporter/crash_reporter_mac.h',
+      'electron/common/crash_reporter/crash_reporter_mac.mm',
+      'electron/common/crash_reporter/crash_reporter_win.cc',
+      'electron/common/crash_reporter/crash_reporter_win.h',
+      'electron/common/crash_reporter/linux/crash_dump_handler.cc',
+      'electron/common/crash_reporter/linux/crash_dump_handler.h',
+      'electron/common/crash_reporter/win/crash_service.cc',
+      'electron/common/crash_reporter/win/crash_service.h',
+      'electron/common/crash_reporter/win/crash_service_main.cc',
+      'electron/common/crash_reporter/win/crash_service_main.h',
+      'electron/common/draggable_region.cc',
+      'electron/common/draggable_region.h',
+      'electron/common/google_api_key.h',
+      'electron/common/id_weak_map.cc',
+      'electron/common/id_weak_map.h',
+      'electron/common/keyboard_util.cc',
+      'electron/common/keyboard_util.h',
+      'electron/common/mouse_util.cc',
+      'electron/common/mouse_util.h',
+      'electron/common/linux/application_info.cc',
+      'electron/common/native_mate_converters/accelerator_converter.cc',
+      'electron/common/native_mate_converters/accelerator_converter.h',
+      'electron/common/native_mate_converters/blink_converter.cc',
+      'electron/common/native_mate_converters/blink_converter.h',
+      'electron/common/native_mate_converters/callback.cc',
+      'electron/common/native_mate_converters/callback.h',
+      'electron/common/native_mate_converters/content_converter.cc',
+      'electron/common/native_mate_converters/content_converter.h',
+      'electron/common/native_mate_converters/file_path_converter.h',
+      'electron/common/native_mate_converters/gfx_converter.cc',
+      'electron/common/native_mate_converters/gfx_converter.h',
+      'electron/common/native_mate_converters/gurl_converter.h',
+      'electron/common/native_mate_converters/image_converter.cc',
+      'electron/common/native_mate_converters/image_converter.h',
+      'electron/common/native_mate_converters/net_converter.cc',
+      'electron/common/native_mate_converters/net_converter.h',
+      'electron/common/native_mate_converters/string16_converter.h',
+      'electron/common/native_mate_converters/v8_value_converter.cc',
+      'electron/common/native_mate_converters/v8_value_converter.h',
+      'electron/common/native_mate_converters/value_converter.cc',
+      'electron/common/native_mate_converters/value_converter.h',
+      'electron/common/node_bindings.cc',
+      'electron/common/node_bindings.h',
+      'electron/common/node_bindings_linux.cc',
+      'electron/common/node_bindings_linux.h',
+      'electron/common/node_bindings_mac.cc',
+      'electron/common/node_bindings_mac.h',
+      'electron/common/node_bindings_win.cc',
+      'electron/common/node_bindings_win.h',
+      'electron/common/node_includes.h',
+      'electron/common/options_switches.cc',
+      'electron/common/options_switches.h',
+      'electron/common/platform_util.h',
+      'electron/common/platform_util_linux.cc',
+      'electron/common/platform_util_mac.mm',
+      'electron/common/platform_util_win.cc',
+      'electron/renderer/api/electron_api_renderer_ipc.cc',
+      'electron/renderer/api/electron_api_spell_check_client.cc',
+      'electron/renderer/api/electron_api_spell_check_client.h',
+      'electron/renderer/api/electron_api_web_frame.cc',
+      'electron/renderer/api/electron_api_web_frame.h',
+      'electron/renderer/electron_render_view_observer.cc',
+      'electron/renderer/electron_render_view_observer.h',
+      'electron/renderer/electron_renderer_client.cc',
+      'electron/renderer/electron_renderer_client.h',
+      'electron/renderer/guest_view_container.cc',
+      'electron/renderer/guest_view_container.h',
+      'electron/renderer/node_array_buffer_bridge.cc',
+      'electron/renderer/node_array_buffer_bridge.h',
+      'electron/utility/electron_content_utility_client.cc',
+      'electron/utility/electron_content_utility_client.h',
+>>>>>>> .their
       'chromium_src/chrome/browser/browser_process.cc',
       'chromium_src/chrome/browser/browser_process.h',
       'chromium_src/chrome/browser/chrome_process_finder_win.cc',
@@ -662,7 +979,7 @@
       'chromium_src/library_loaders/libspeechd_loader.cc',
       'chromium_src/library_loaders/libspeechd.h',
       '<@(native_mate_files)',
-      '<(SHARED_INTERMEDIATE_DIR)/atom_natives.h',
+      '<(SHARED_INTERMEDIATE_DIR)/electron_natives.h',
     ],
     'lib_sources_linux': [
       'chromium_src/chrome/browser/icon_loader_auralinux.cc',
@@ -681,8 +998,8 @@
       'chromium_src/chrome/utility/printing_handler_win.h',
     ],
     'framework_sources': [
-      'atom/app/atom_library_main.h',
-      'atom/app/atom_library_main.mm',
+      'electron/app/electron_library_main.h',
+      'electron/app/electron_library_main.mm',
     ],
     'login_helper_sources': [
       'atom/app/atom_login_helper.mm',
@@ -698,9 +1015,9 @@
     'conditions': [
       ['OS=="win"', {
         'app_sources': [
-          'atom/browser/resources/win/resource.h',
-          'atom/browser/resources/win/atom.ico',
-          'atom/browser/resources/win/atom.rc',
+          'electron/browser/resources/win/resource.h',
+          'electron/browser/resources/win/electron.ico',
+          'electron/browser/resources/win/electron.rc',
           # Cursors.
           '<(libchromiumcontent_src_dir)/ui/resources/cursors/aliasb.cur',
           '<(libchromiumcontent_src_dir)/ui/resources/cursors/cell.cur',
changed in both
  base   100644 d5cfd2da8399c2a2b0c2492df5713378747ad82b lib/common/api/callbacks-registry.js
  our    100644 6a1c63b20413753eeb9c5f8d190a9f5d2f303d22 lib/common/api/callbacks-registry.js
  their  100644 91356627865ec6455033a56464da3b9919cb91dc lib/common/api/callbacks-registry.js
@@ -24,6 +24,7 @@
     let match
 
     while ((match = regexp.exec(stackString)) !== null) {
+<<<<<<< .our
       const location = match[1]
       if (location.includes('(native)')) continue
       if (location.includes('(<anonymous>)')) continue
@@ -32,6 +33,18 @@
       const ref = /([^/^)]*)\)?$/gi.exec(location)
       filenameAndLine = ref[1]
       break
+=======
+      location = match[1];
+      if (location.indexOf('(native)') !== -1) {
+        continue;
+      }
+      if (location.indexOf('electron.asar') !== -1) {
+        continue;
+      }
+      ref = /([^\/^\)]*)\)?$/gi.exec(location);
+      filenameAndLine = ref[1];
+      break;
+>>>>>>> .their
     }
     this.callbacks[id] = callback
     v8Util.setHiddenValue(callback, 'callbackId', id)
changed in both
  base   100644 e3996a193aced293e4ed4808f804f39a4150823f lib/common/asar.js
  our    100644 41c3d0c85c69954dddad53c674f84051f25372e4 lib/common/asar.js
  their  100644 6bfe38783a9ea737481b6635e64c8ab56009d600 lib/common/asar.js
@@ -1,9 +1,16 @@
 (function () {
+<<<<<<< .our
   const asar = process.binding('atom_common_asar')
   const {Buffer} = require('buffer')
   const childProcess = require('child_process')
   const path = require('path')
   const util = require('util')
+=======
+  const asar = process.binding('electron_common_asar');
+  const child_process = require('child_process');
+  const path = require('path');
+  const util = require('util');
+>>>>>>> .their
 
   const hasProp = {}.hasOwnProperty
 
changed in both
  base   100644 85bb828583bc25841141d79f3a4bb40af1560f36 lib/common/asar_init.js
  our    100644 33abc155a54e6f78d6d9cd29ccaa182f8bf69647 lib/common/asar_init.js
  their  100644 b758084f9b21112d48f07938946d4d5cc75ce96b lib/common/asar_init.js
@@ -1,6 +1,13 @@
+<<<<<<< .our
 ;(function () {
   return function (process, require, asarSource) {
     const source = process.binding('natives')
+=======
+(function () {
+  return function(process, require, asarSource) {
+    // Make asar.js accessible via "require".
+    process.binding('natives').ATOM_SHELL_ASAR = asarSource;
+>>>>>>> .their
 
     // Expose fs module without asar support.
     source['original-fs'] = source.fs
changed in both
  base   100644 923ef910886de402706f29eccf497ecc5c0a8cea lib/common/init.js
  our    100644 b424768414b857b485bd5e29bfce504de6f1d749 lib/common/init.js
  their  100644 8a4bb1de6872f397007f3e55b8543ebe0edafa15 lib/common/init.js
@@ -1,5 +1,26 @@
+<<<<<<< .our
 const timers = require('timers')
 const util = require('util')
+=======
+const path = require('path');
+const timers = require('timers');
+const Module = require('module');
+
+process.atomBinding = function(name) {
+  try {
+    return process.binding("electron_" + process.type + "_" + name);
+  } catch (error) {
+    if (/No such module/.test(error.message)) {
+      return process.binding("electron_common_" + name);
+    }
+  }
+};
+
+if (!process.env.ELECTRON_HIDE_INTERNAL_MODULES) {
+  // Add common/api/lib to module search paths.
+  Module.globalPaths.push(path.join(__dirname, 'api'));
+}
+>>>>>>> .their
 
 process.atomBinding = require('./atom-binding-setup')(process.binding, process.type)
 
changed in both
  base   100755 1efea3c289731cba4c457ec367083c1e5bd55fc9 script/bootstrap.py
  our    100755 e4aaf89e216b0164f15882a3040e8cac70bf1fd9 script/bootstrap.py
  their  100755 4a1ba528921206a7673b897568e7111c43f9b385 script/bootstrap.py
@@ -238,8 +238,14 @@
     os.remove(tar_name)
 
 def create_chrome_version_h():
+<<<<<<< .our
   version_file = os.path.join(VENDOR_DIR, 'libchromiumcontent', 'VERSION')
   target_file = os.path.join(SOURCE_ROOT, 'atom', 'common', 'chrome_version.h')
+=======
+  version_file = os.path.join(SOURCE_ROOT, 'vendor', 'brightray', 'vendor',
+                              'libchromiumcontent', 'VERSION')
+  target_file = os.path.join(SOURCE_ROOT, 'electron', 'common', 'chrome_version.h')
+>>>>>>> .their
   template_file = os.path.join(SOURCE_ROOT, 'script', 'chrome_version.h.in')
 
   with open(version_file, 'r') as f:
changed in both
  base   100755 e2c22e8cd9d4714ecba9cf8899a01faea14487d0 script/bump-version.py
  our    100755 564adb2116312b0f6d0351096bd89cb373cd3bab script/bump-version.py
  their  100755 679eb28dddcbb235efd77cc9b9786438b7960b8e script/bump-version.py
@@ -115,15 +115,24 @@
   return versions
 
 
+<<<<<<< .our
 def update_electron_gyp(version, suffix):
   pattern = re.compile(" *'version%' *: *'[0-9.]+(-beta[0-9.]*)?(-dev)?"
     + "(-nightly[0-9.]*)?'")
+=======
+def update_atom_gyp(version):
+  pattern = re.compile(" *'version%' *: *'[0-9.]+'")
+>>>>>>> .their
   with open('electron.gyp', 'r') as f:
     lines = f.readlines()
 
   for i in range(0, len(lines)):
     if pattern.match(lines[i]):
+<<<<<<< .our
       lines[i] = "    'version%': '{0}',\n".format(version + suffix)
+=======
+      lines[i] = "    'version%': '{0}',\n".format(version)
+>>>>>>> .their
       with open('electron.gyp', 'w') as f:
         f.write(''.join(lines))
       return
@@ -135,7 +144,7 @@
   pattern_fvs = re.compile(' *VALUE "FileVersion", "[0-9.]+"')
   pattern_pvs = re.compile(' *VALUE "ProductVersion", "[0-9.]+"')
 
-  win_rc = os.path.join('atom', 'browser', 'resources', 'win', 'atom.rc')
+  win_rc = os.path.join('atom', 'browser', 'resources', 'win', 'electron.rc')
   with open(win_rc, 'r') as f:
     lines = f.readlines()
 
@@ -162,10 +171,10 @@
 
   for i in range(0, len(lines)):
     line = lines[i]
-    if 'ATOM_MAJOR_VERSION' in line:
-      lines[i] = '#define ATOM_MAJOR_VERSION {0}\n'.format(versions[0])
-      lines[i + 1] = '#define ATOM_MINOR_VERSION {0}\n'.format(versions[1])
-      lines[i + 2] = '#define ATOM_PATCH_VERSION {0}\n'.format(versions[2])
+    if 'ELECTRON_MAJOR_VERSION' in line:
+      lines[i] = '#define ELECTRON_MAJOR_VERSION {0}\n'.format(versions[0])
+      lines[i + 1] = '#define ELECTRON_MINOR_VERSION {0}\n'.format(versions[1])
+      lines[i + 2] = '#define ELECTRON_PATCH_VERSION {0}\n'.format(versions[2])
 
       if (suffix):
         lines[i + 3] = '#define ATOM_PRE_RELEASE_VERSION {0}\n'.format(suffix)
merged
  result 100644 7cbfdfd87896fc3af08df33b9be616e51ab78e83 script/chrome_version.h.in
  our    100644 be20655ec6d73b6aca9930911a464b96f098e5b9 script/chrome_version.h.in
@@ -5,10 +5,10 @@
 // This file is generated by script/bootstrap.py, you should never modify it
 // by hand.
 
-#ifndef ATOM_COMMON_CHROME_VERSION_H_
-#define ATOM_COMMON_CHROME_VERSION_H_
+#ifndef ELECTRON_COMMON_CHROME_VERSION_H_
+#define ELECTRON_COMMON_CHROME_VERSION_H_
 
 #define CHROME_VERSION_STRING "{PLACEHOLDER}"
 #define CHROME_VERSION "v" CHROME_VERSION_STRING
 
-#endif  // ATOM_COMMON_CHROME_VERSION_H_
+#endif  // ELECTRON_COMMON_CHROME_VERSION_H_
changed in both
  base   100755 d647bed2de4150a251dce6fde1dfb5fc455bdbfc script/cpplint.py
  our    100755 da4b6212f4b1a8ad187f8eae970e4887b71d73da script/cpplint.py
  their  100755 ed9e31b978362d16e392869a2479eeb8a4239aa9 script/cpplint.py
@@ -7,6 +7,7 @@
 from lib.config import enable_verbose_mode
 from lib.util import execute
 
+<<<<<<< .our
 IGNORE_FILES = set(os.path.join(*components) for components in [
   ['atom', 'browser', 'mac', 'atom_application.h'],
   ['atom', 'browser', 'mac', 'atom_application_delegate.h'],
@@ -36,6 +37,25 @@
   ['brightray', 'browser', 'win', 'win32_desktop_notifications', 'toast.h'],
   ['brightray', 'browser', 'win', 'win32_notification.h']
 ])
+=======
+IGNORE_FILES = [
+  os.path.join('electron', 'app', 'electron_main.cc'),
+  os.path.join('electron', 'browser', 'mac', 'electron_application.h'),
+  os.path.join('electron', 'browser', 'mac', 'electron_application_delegate.h'),
+  os.path.join('electron', 'browser', 'native_window_mac.h'),
+  os.path.join('electron', 'browser', 'resources', 'win', 'resource.h'),
+  os.path.join('electron', 'browser', 'ui', 'cocoa', 'event_processing_window.h'),
+  os.path.join('electron', 'browser', 'ui', 'cocoa', 'electron_menu_controller.h'),
+  os.path.join('electron', 'browser', 'ui', 'gtk', 'gtk_custom_menu.cc'),
+  os.path.join('electron', 'browser', 'ui', 'gtk', 'gtk_custom_menu_item.cc'),
+  os.path.join('electron', 'common', 'api', 'api_messages.h'),
+  os.path.join('electron', 'common', 'api', 'electron_extensions.h'),
+  os.path.join('electron', 'common', 'electron_version.h'),
+  os.path.join('electron', 'common', 'common_message_generator.cc'),
+  os.path.join('electron', 'common', 'common_message_generator.h'),
+  os.path.join('electron', 'common', 'swap_or_assign.h'),
+]
+>>>>>>> .their
 
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 
@@ -70,6 +90,7 @@
     enable_verbose_mode()
 
   os.chdir(SOURCE_ROOT)
+<<<<<<< .our
   files = find_files(['atom', 'brightray'], is_cpp_file)
   files -= IGNORE_FILES
   if args.only_changed:
@@ -85,6 +106,20 @@
         filename = os.path.join(parent, child)
         if test(filename):
           matches.add(filename)
+=======
+  files = list_files(['app', 'browser', 'common', 'renderer', 'utility'],
+                     ['*.cc', '*.h'])
+  call_cpplint(list(set(files) - set(IGNORE_FILES)))
+
+
+def list_files(directories, filters):
+  matches = []
+  for directory in directories:
+    for root, _, filenames, in os.walk(os.path.join('electron', directory)):
+      for f in filters:
+        for filename in fnmatch.filter(filenames, f):
+          matches.append(os.path.join(root, filename))
+>>>>>>> .their
   return matches
 
 
changed in both
  base   100755 e25845432c774c33bf718e56b9291293b7eec369 script/create-dist.py
  our    100755 4a6c0c7ce8f275175e48c4c380ff33627f7a5961 script/create-dist.py
  their  100755 b8f40a8bf076a392cd30f0b87a3948e24299d60d script/create-dist.py
@@ -18,10 +18,14 @@
                      execute, get_electron_version, make_zip, \
                      parse_version, rm_rf, scoped_cwd
 
+<<<<<<< .our
 from lib.env_util import get_vs_location
 
 
 ELECTRON_VERSION = get_electron_version()
+=======
+ELECTRON_SHELL_VERSION = get_atom_shell_version()
+>>>>>>> .their
 
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 DIST_DIR = os.path.join(SOURCE_ROOT, 'dist')
@@ -114,8 +118,13 @@
 
   create_version()
   create_dist_zip()
+<<<<<<< .our
   create_chrome_binary_zip('chromedriver', ELECTRON_VERSION)
   create_chrome_binary_zip('mksnapshot', ELECTRON_VERSION)
+=======
+  create_chrome_binary_zip('chromedriver', get_chromedriver_version())
+  create_chrome_binary_zip('mksnapshot', ELECTRON_SHELL_VERSION)
+>>>>>>> .their
   create_ffmpeg_zip()
   create_symbols_zip()
 
@@ -240,7 +249,11 @@
 def create_version():
   version_path = os.path.join(SOURCE_ROOT, 'dist', 'version')
   with open(version_path, 'w') as version_file:
+<<<<<<< .our
     version_file.write(ELECTRON_VERSION)
+=======
+    version_file.write(ELECTRON_SHELL_VERSION)
+>>>>>>> .their
 
 
 def create_symbols():
@@ -262,7 +275,13 @@
 
 
 def create_dist_zip():
+<<<<<<< .our
   dist_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION)
+=======
+  dist_name = '{0}-{1}-{2}-{3}.zip'.format(PROJECT_NAME, ELECTRON_SHELL_VERSION,
+                                           get_platform_key(),
+                                           get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(SOURCE_ROOT, 'dist', dist_name)
 
   with scoped_cwd(DIST_DIR):
@@ -310,7 +329,12 @@
       make_zip(zip_file, files, [])
 
 def create_ffmpeg_zip():
+<<<<<<< .our
   dist_name = get_zip_name('ffmpeg', ELECTRON_VERSION)
+=======
+  dist_name = 'ffmpeg-{0}-{1}-{2}.zip'.format(
+      ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(SOURCE_ROOT, 'dist', dist_name)
 
   if PLATFORM == 'darwin':
@@ -331,10 +355,17 @@
 
 
 def create_symbols_zip():
+<<<<<<< .our
   if get_target_arch() == 'mips64el':
     return
 
   dist_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'symbols')
+=======
+  dist_name = '{0}-{1}-{2}-{3}-symbols.zip'.format(PROJECT_NAME,
+                                                   ELECTRON_SHELL_VERSION,
+                                                   get_platform_key(),
+                                                   get_target_arch())
+>>>>>>> .their
   zip_file = os.path.join(DIST_DIR, dist_name)
   licenses = ['LICENSE', 'LICENSES.chromium.html', 'version']
 
@@ -343,7 +374,14 @@
     make_zip(zip_file, licenses, dirs)
 
   if PLATFORM == 'darwin':
+<<<<<<< .our
     dsym_name = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'dsym')
+=======
+    dsym_name = '{0}-{1}-{2}-{3}-dsym.zip'.format(PROJECT_NAME,
+                                                  ELECTRON_SHELL_VERSION,
+                                                  get_platform_key(),
+                                                  get_target_arch())
+>>>>>>> .their
     with scoped_cwd(DIST_DIR):
       dsyms = glob.glob('*.dSYM')
       make_zip(os.path.join(DIST_DIR, dsym_name), licenses, dsyms)
changed in both
  base   100644 fb1a4b89f27f3eb647638e9183d110287698964a script/lib/config.py
  our    100644 9ad0fbc680e5ecdeb8c13d0f0d6678bbba7d9031 script/lib/config.py
  their  100644 88b560c712316b0ffaac4cb2258f117d7f368146 script/lib/config.py
@@ -56,12 +56,21 @@
 
 
 def s3_config():
+<<<<<<< .our
   config = (get_env_var('S3_BUCKET'),
             get_env_var('S3_ACCESS_KEY'),
             get_env_var('S3_SECRET_KEY'))
   message = ('Error: Please set the $ELECTRON_S3_BUCKET, '
              '$ELECTRON_S3_ACCESS_KEY, and '
              '$ELECTRON_S3_SECRET_KEY environment variables')
+=======
+  config = (os.environ.get('ELECTRON_SHELL_S3_BUCKET', ''),
+            os.environ.get('ELECTRON_SHELL_S3_ACCESS_KEY', ''),
+            os.environ.get('ELECTRON_SHELL_S3_SECRET_KEY', ''))
+  message = ('Error: Please set the $ELECTRON_SHELL_S3_BUCKET, '
+             '$ELECTRON_SHELL_S3_ACCESS_KEY, and '
+             '$ELECTRON_SHELL_S3_SECRET_KEY environment variables')
+>>>>>>> .their
   assert all(len(c) for c in config), message
   return config
 
changed in both
  base   100644 fc52d316d30cc108850f51ec62ea3297161cc86e script/lib/util.py
  our    100644 d479d5a9556534c5d98ae1fdc97397cdd14376f5 script/lib/util.py
  their  100644 4e5fb90988d7382ded1744e35e8df9d786ecc5f9 script/lib/util.py
changed in both
  base   100755 e91e8401cbffca0ed484297ebedacfd0383ea940 script/update.py
  our    100755 5b4e201d76ab3689bc8847d6141b2fff1a852174 script/update.py
  their  100755 33a4cff50f64c16ff696634713b9784d6bb80953 script/update.py
@@ -84,6 +84,7 @@
     '-Dlibrary=static_library',
     '-Dmas_build={0}'.format(mas_build),
   ]
+<<<<<<< .our
 
   # Add the defines passed from command line.
   args = parse_args()
@@ -98,6 +99,9 @@
     generator = 'xcode-ninja'
 
   return subprocess.call([python, gyp, '-f', generator, '--depth', '.',
+=======
+  return subprocess.call([python, gyp, '-f', 'ninja', '--depth', '.',
+>>>>>>> .their
                           'electron.gyp', '-Icommon.gypi'] + defines, env=env)
 
 
changed in both
  base   100755 d23bc554c3ccdd0aacbec84d763cebab55db7b9b script/upload.py
  our    100755 2d9eaa201265971ca01acaea6e84a440e5db0532 script/upload.py
  their  100755 01edd91ccae024fdad884decd7ce16235215cd8e script/upload.py
@@ -17,8 +17,13 @@
                      parse_version, scoped_cwd, s3put
 
 
+<<<<<<< .our
 ELECTRON_REPO = 'electron/electron'
 ELECTRON_VERSION = get_electron_version()
+=======
+ELECTRON_SHELL_REPO = 'atom/electron'
+ELECTRON_SHELL_VERSION = get_atom_shell_version()
+>>>>>>> .their
 
 PROJECT_NAME = electron_gyp()['project_name%']
 PRODUCT_NAME = electron_gyp()['product_name%']
@@ -26,11 +31,26 @@
 SOURCE_ROOT = os.path.abspath(os.path.dirname(os.path.dirname(__file__)))
 OUT_DIR = os.path.join(SOURCE_ROOT, 'out', 'R')
 DIST_DIR = os.path.join(SOURCE_ROOT, 'dist')
+<<<<<<< .our
 
 DIST_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION)
 SYMBOLS_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'symbols')
 DSYM_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'dsym')
 PDB_NAME = get_zip_name(PROJECT_NAME, ELECTRON_VERSION, 'pdb')
+=======
+DIST_NAME = '{0}-{1}-{2}-{3}.zip'.format(PROJECT_NAME,
+                                         ELECTRON_SHELL_VERSION,
+                                         get_platform_key(),
+                                         get_target_arch())
+SYMBOLS_NAME = '{0}-{1}-{2}-{3}-symbols.zip'.format(PROJECT_NAME,
+                                                    ELECTRON_SHELL_VERSION,
+                                                    get_platform_key(),
+                                                    get_target_arch())
+DSYM_NAME = '{0}-{1}-{2}-{3}-dsym.zip'.format(PROJECT_NAME,
+                                              ELECTRON_SHELL_VERSION,
+                                              get_platform_key(),
+                                              get_target_arch())
+>>>>>>> .their
 
 
 def main():
@@ -39,6 +59,7 @@
     utcnow = datetime.datetime.utcnow()
     args.upload_timestamp = utcnow.strftime('%Y%m%d')
 
+<<<<<<< .our
   if not dist_newer_than_head():
     run_python_script('create-dist.py')
 
@@ -49,6 +70,37 @@
     sys.stderr.write(error)
     sys.stderr.flush()
     return 1
+=======
+  if not args.publish_release:
+    if not dist_newer_than_head():
+      create_dist = os.path.join(SOURCE_ROOT, 'script', 'create-dist.py')
+      execute([sys.executable, create_dist])
+
+    build_version = get_atom_shell_build_version()
+    if not ELECTRON_SHELL_VERSION.startswith(build_version):
+      error = 'Tag name ({0}) should match build version ({1})\n'.format(
+          ELECTRON_SHELL_VERSION, build_version)
+      sys.stderr.write(error)
+      sys.stderr.flush()
+      return 1
+
+  github = GitHub(auth_token())
+  releases = github.repos(ELECTRON_SHELL_REPO).releases.get()
+  tag_exists = False
+  for release in releases:
+    if not release['draft'] and release['tag_name'] == args.version:
+      tag_exists = True
+      break
+
+  release = create_or_get_release_draft(github, releases, args.version,
+                                        tag_exists)
+
+  if args.publish_release:
+    # Upload the SHASUMS.txt.
+    execute([sys.executable,
+             os.path.join(SOURCE_ROOT, 'script', 'upload-checksums.py'),
+             '-v', ELECTRON_SHELL_VERSION])
+>>>>>>> .their
 
   tag_exists = False
   release = get_release(args.version)
@@ -85,6 +137,7 @@
     mksnapshot = get_zip_name('mksnapshot', ELECTRON_VERSION, 'x64')
     upload_electron(release, os.path.join(DIST_DIR, mksnapshot), args)
 
+<<<<<<< .our
   if not tag_exists and not args.upload_to_s3:
     # Upload symbols to symbol server.
     run_python_script('upload-symbols.py')
@@ -92,15 +145,40 @@
       # Upload node headers.
       run_python_script('create-node-headers.py', '-v', args.version)
       run_python_script('upload-node-headers.py', '-v', args.version)
+=======
+  # Upload free version of ffmpeg.
+  ffmpeg = 'ffmpeg-{0}-{1}-{2}.zip'.format(
+      ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+  upload_atom_shell(github, release, os.path.join(DIST_DIR, ffmpeg))
+
+  # Upload chromedriver and mksnapshot for minor version update.
+  if parse_version(args.version)[2] == '0':
+    chromedriver = 'chromedriver-{0}-{1}-{2}.zip'.format(
+        get_chromedriver_version(), get_platform_key(), get_target_arch())
+    upload_atom_shell(github, release, os.path.join(DIST_DIR, chromedriver))
+    mksnapshot = 'mksnapshot-{0}-{1}-{2}.zip'.format(
+        ELECTRON_SHELL_VERSION, get_platform_key(), get_target_arch())
+    upload_atom_shell(github, release, os.path.join(DIST_DIR, mksnapshot))
+
+  if PLATFORM == 'win32' and not tag_exists:
+    # Upload node headers.
+    execute([sys.executable,
+             os.path.join(SOURCE_ROOT, 'script', 'upload-node-headers.py'),
+             '-v', args.version])
+>>>>>>> .their
 
 
 def parse_args():
   parser = argparse.ArgumentParser(description='upload distribution file')
   parser.add_argument('-v', '--version', help='Specify the version',
+<<<<<<< .our
                       default=ELECTRON_VERSION)
   parser.add_argument('-o', '--overwrite',
                       help='Overwrite a published release',
                       action='store_true')
+=======
+                      default=ELECTRON_SHELL_VERSION)
+>>>>>>> .their
   parser.add_argument('-p', '--publish-release',
                       help='Publish the release',
                       action='store_true')
@@ -121,7 +199,11 @@
 def get_electron_build_version():
   if get_target_arch().startswith('arm') or os.environ.has_key('CI'):
     # In CI we just build as told.
+<<<<<<< .our
     return ELECTRON_VERSION
+=======
+    return ELECTRON_SHELL_VERSION
+>>>>>>> .their
   if PLATFORM == 'darwin':
     electron = os.path.join(SOURCE_ROOT, 'out', 'R',
                               '{0}.app'.format(PRODUCT_NAME), 'Contents',
@@ -170,6 +252,12 @@
   # Upload the checksum file.
   upload_sha256_checksum(args.version, file_path)
 
+<<<<<<< .our
+=======
+  data = dict(tag_name=tag, name=name, body=body, draft=True)
+  r = github.repos(ELECTRON_SHELL_REPO).releases.post(data=data)
+  return r
+>>>>>>> .their
 
 def upload_io_to_github(release, filename, filepath, version):
   print 'Uploading %s to Github' % \
@@ -178,6 +266,19 @@
   execute(['node', script_path, filepath, filename, str(release['id']),
           version])
 
+<<<<<<< .our
+=======
+def upload_atom_shell(github, release, file_path):
+  # Delete the original file before uploading in CI.
+  if os.environ.has_key('CI'):
+    try:
+      for asset in release['assets']:
+        if asset['name'] == os.path.basename(file_path):
+          github.repos(ELECTRON_SHELL_REPO).releases.assets(asset['id']).delete()
+          break
+    except Exception:
+      pass
+>>>>>>> .their
 
 def upload_sha256_checksum(version, file_path, key_prefix=None):
   bucket, access_key, secret_key = s3_config()
@@ -186,6 +287,7 @@
     key_prefix = 'atom-shell/tmp/{0}'.format(version)
   sha256 = hashlib.sha256()
   with open(file_path, 'rb') as f:
+<<<<<<< .our
     sha256.update(f.read())
 
   filename = os.path.basename(file_path)
@@ -198,6 +300,20 @@
 def auth_token():
   token = get_env_var('GITHUB_TOKEN')
   message = ('Error: Please set the $ELECTRON_GITHUB_TOKEN '
+=======
+    github.repos(ELECTRON_SHELL_REPO).releases(release['id']).assets.post(
+        params=params, headers=headers, data=f, verify=False)
+
+
+def publish_release(github, release_id):
+  data = dict(draft=False)
+  github.repos(ELECTRON_SHELL_REPO).releases(release_id).patch(data=data)
+
+
+def auth_token():
+  token = os.environ.get('ELECTRON_SHELL_GITHUB_TOKEN')
+  message = ('Error: Please set the $ELECTRON_SHELL_GITHUB_TOKEN '
+>>>>>>> .their
              'environment variable, which is your personal token')
   assert token, message
   return token
changed in both
  base   160000 d8e7d3e76cb3c6e709449d181ddc2af8c4859303 vendor/node
  our    160000 ece0a06ac8147efb5b5af431c21f312f1884616e vendor/node
  their  160000 fc81e4e8cc13f606cc18096a3f407e2a7aac82bb vendor/node
