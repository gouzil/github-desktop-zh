changed in both
  base   100644 e9b918f69833d1b38d36130f044a948940a0631b build/monaco/package.json
  our    100644 efd919085b2ffc82da8d810c609a9ed217bffb35 build/monaco/package.json
  their  100644 2d5c119e81b1c89c6d6444192e6e4676e067f437 build/monaco/package.json
@@ -1,7 +1,11 @@
 {
   "name": "monaco-editor-core",
   "private": true,
+<<<<<<< .our
   "version": "0.14.3",
+=======
+  "version": "0.7.3",
+>>>>>>> .their
   "description": "A browser based code editor",
   "author": "Microsoft Corporation",
   "license": "MIT",
removed in local
  base   100644 cb7e444264682002e9447232092bf29c48370a6c src/vs/editor/browser/standalone/standaloneLanguages.ts
  their  100644 1dd17021bec04da15b3921118881f645658c1e96 src/vs/editor/browser/standalone/standaloneLanguages.ts
removed in local
  base   100644 28d4a2debea41c2567e8017cc3b1d5efc09e9d29 src/vs/editor/common/commonCodeEditor.ts
  their  100644 c74baecfea6baa4062f194002e8e82d6044e4923 src/vs/editor/common/commonCodeEditor.ts
changed in both
  base   100644 f64c674ec5434983c29a8f05da71a3bda8549249 src/vs/editor/common/editorCommon.ts
  our    100644 8ab17ce6977a746a13f9fe016e9948d332de49ca src/vs/editor/common/editorCommon.ts
  their  100644 47bc76baaa3b08c907277d86e7a1d01f170f8fdb src/vs/editor/common/editorCommon.ts
@@ -458,7 +458,3664 @@
 	 * @see `ITextModel.changeDecorations`
 	 * @internal
 	 */
+<<<<<<< .our
 	changeDecorations(callback: (changeAccessor: IModelDecorationsChangeAccessor) => any): any;
+=======
+	formatOnType?:boolean;
+	/**
+	 * Enable the suggestion box to pop-up on trigger characters.
+	 * Defaults to true.
+	 */
+	suggestOnTriggerCharacters?: boolean;
+	/**
+	 * Accept suggestions on ENTER.
+	 * Defaults to true.
+	 */
+	acceptSuggestionOnEnter?: boolean;
+	/**
+	 * Enable snippet suggestions. Default to 'true'.
+	 */
+	snippetSuggestions?: 'top' | 'bottom' | 'inline' | 'none';
+	/**
+	 * Enable tab completion. Defaults to 'false'
+	 */
+	tabCompletion?: boolean;
+	/**
+	 * Enable word based suggestions. Defaults to 'true'
+	 */
+	wordBasedSuggestions?: boolean;
+	/**
+	 * Enable selection highlight.
+	 * Defaults to true.
+	 */
+	selectionHighlight?:boolean;
+	/**
+	 * Show code lens
+	 * Defaults to true.
+	 */
+	codeLens?: boolean;
+	/**
+	 * @deprecated - use codeLens instead
+	 * @internal
+	 */
+	referenceInfos?: boolean;
+	/**
+	 * Enable code folding
+	 * Defaults to true.
+	 */
+	folding?: boolean;
+	/**
+	 * Enable rendering of whitespace.
+	 * Defaults to none.
+	 */
+	renderWhitespace?: 'none' | 'boundary' | 'all';
+	/**
+	 * Enable rendering of control characters.
+	 * Defaults to false.
+	 */
+	renderControlCharacters?: boolean;
+	/**
+	 * Enable rendering of indent guides.
+	 * Defaults to false.
+	 */
+	renderIndentGuides?: boolean;
+	/**
+	 * Enable rendering of current line highlight.
+	 * Defaults to true.
+	 */
+	renderLineHighlight?: boolean;
+	/**
+	 * Inserting and deleting whitespace follows tab stops.
+	 */
+	useTabStops?: boolean;
+	/**
+	 * The font family
+	 */
+	fontFamily?: string;
+	/**
+	 * The font weight
+	 */
+	fontWeight?: 'normal'|'bold'|'bolder'|'lighter'|'initial'|'inherit'|'100'|'200'|'300'|'400'|'500'|'600'|'700'|'800'|'900';
+	/**
+	 * The font size
+	 */
+	fontSize?: number;
+	/**
+	 * The line height
+	 */
+	lineHeight?: number;
+}
+
+/**
+ * Configuration options for the diff editor.
+ */
+export interface IDiffEditorOptions extends IEditorOptions {
+	/**
+	 * Allow the user to resize the diff editor split view.
+	 * Defaults to true.
+	 */
+	enableSplitViewResizing?: boolean;
+	/**
+	 * Render the differences in two side-by-side editors.
+	 * Defaults to true.
+	 */
+	renderSideBySide?: boolean;
+	/**
+	 * Compute the diff by ignoring leading/trailing whitespace
+	 * Defaults to true.
+	 */
+	ignoreTrimWhitespace?: boolean;
+	/**
+	 * Original model should be editable?
+	 * Defaults to false.
+	 */
+	originalEditable?: boolean;
+}
+
+export class InternalEditorScrollbarOptions {
+	_internalEditorScrollbarOptionsBrand: void;
+
+	arrowSize:number;
+	vertical:ScrollbarVisibility;
+	horizontal:ScrollbarVisibility;
+	useShadows:boolean;
+	verticalHasArrows:boolean;
+	horizontalHasArrows:boolean;
+	handleMouseWheel: boolean;
+	horizontalScrollbarSize: number;
+	horizontalSliderSize: number;
+	verticalScrollbarSize: number;
+	verticalSliderSize: number;
+	mouseWheelScrollSensitivity: number;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		arrowSize:number;
+		vertical:ScrollbarVisibility;
+		horizontal:ScrollbarVisibility;
+		useShadows:boolean;
+		verticalHasArrows:boolean;
+		horizontalHasArrows:boolean;
+		handleMouseWheel: boolean;
+		horizontalScrollbarSize: number;
+		horizontalSliderSize: number;
+		verticalScrollbarSize: number;
+		verticalSliderSize: number;
+		mouseWheelScrollSensitivity: number;
+	}) {
+		this.arrowSize = source.arrowSize|0;
+		this.vertical = source.vertical|0;
+		this.horizontal = source.horizontal|0;
+		this.useShadows = Boolean(source.useShadows);
+		this.verticalHasArrows = Boolean(source.verticalHasArrows);
+		this.horizontalHasArrows = Boolean(source.horizontalHasArrows);
+		this.handleMouseWheel = Boolean(source.handleMouseWheel);
+		this.horizontalScrollbarSize = source.horizontalScrollbarSize|0;
+		this.horizontalSliderSize = source.horizontalSliderSize|0;
+		this.verticalScrollbarSize = source.verticalScrollbarSize|0;
+		this.verticalSliderSize = source.verticalSliderSize|0;
+		this.mouseWheelScrollSensitivity = Number(source.mouseWheelScrollSensitivity);
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:InternalEditorScrollbarOptions): boolean {
+		return (
+			this.arrowSize === other.arrowSize
+			&& this.vertical === other.vertical
+			&& this.horizontal === other.horizontal
+			&& this.useShadows === other.useShadows
+			&& this.verticalHasArrows === other.verticalHasArrows
+			&& this.horizontalHasArrows === other.horizontalHasArrows
+			&& this.handleMouseWheel === other.handleMouseWheel
+			&& this.horizontalScrollbarSize === other.horizontalScrollbarSize
+			&& this.horizontalSliderSize === other.horizontalSliderSize
+			&& this.verticalScrollbarSize === other.verticalScrollbarSize
+			&& this.verticalSliderSize === other.verticalSliderSize
+			&& this.mouseWheelScrollSensitivity === other.mouseWheelScrollSensitivity
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): InternalEditorScrollbarOptions {
+		return new InternalEditorScrollbarOptions(this);
+	}
+}
+
+export class EditorWrappingInfo {
+	_editorWrappingInfoBrand: void;
+
+	isViewportWrapping: boolean;
+	wrappingColumn: number;
+	wrappingIndent: WrappingIndent;
+	wordWrapBreakBeforeCharacters: string;
+	wordWrapBreakAfterCharacters: string;
+	wordWrapBreakObtrusiveCharacters: string;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		isViewportWrapping: boolean;
+		wrappingColumn: number;
+		wrappingIndent: WrappingIndent;
+		wordWrapBreakBeforeCharacters: string;
+		wordWrapBreakAfterCharacters: string;
+		wordWrapBreakObtrusiveCharacters: string;
+	}) {
+		this.isViewportWrapping = Boolean(source.isViewportWrapping);
+		this.wrappingColumn = source.wrappingColumn|0;
+		this.wrappingIndent = source.wrappingIndent|0;
+		this.wordWrapBreakBeforeCharacters = String(source.wordWrapBreakBeforeCharacters);
+		this.wordWrapBreakAfterCharacters = String(source.wordWrapBreakAfterCharacters);
+		this.wordWrapBreakObtrusiveCharacters = String(source.wordWrapBreakObtrusiveCharacters);
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:EditorWrappingInfo): boolean {
+		return (
+			this.isViewportWrapping === other.isViewportWrapping
+			&& this.wrappingColumn === other.wrappingColumn
+			&& this.wrappingIndent === other.wrappingIndent
+			&& this.wordWrapBreakBeforeCharacters === other.wordWrapBreakBeforeCharacters
+			&& this.wordWrapBreakAfterCharacters === other.wordWrapBreakAfterCharacters
+			&& this.wordWrapBreakObtrusiveCharacters === other.wordWrapBreakObtrusiveCharacters
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): EditorWrappingInfo {
+		return new EditorWrappingInfo(this);
+	}
+}
+
+export class InternalEditorViewOptions {
+	_internalEditorViewOptionsBrand: void;
+
+	theme:string;
+	canUseTranslate3d:boolean;
+	experimentalScreenReader: boolean;
+	rulers: number[];
+	ariaLabel: string;
+	renderLineNumbers:boolean;
+	renderCustomLineNumbers: (lineNumber:number)=>string;
+	renderRelativeLineNumbers: boolean;
+	selectOnLineNumbers:boolean;
+	glyphMargin:boolean;
+	revealHorizontalRightPadding:number;
+	roundedSelection:boolean;
+	overviewRulerLanes:number;
+	cursorBlinking:TextEditorCursorBlinkingStyle;
+	mouseWheelZoom:boolean;
+	cursorStyle:TextEditorCursorStyle;
+	hideCursorInOverviewRuler:boolean;
+	scrollBeyondLastLine:boolean;
+	editorClassName: string;
+	stopRenderingLineAfter: number;
+	renderWhitespace: 'none' | 'boundary' | 'all';
+	renderControlCharacters: boolean;
+	renderIndentGuides: boolean;
+	renderLineHighlight: boolean;
+	scrollbar:InternalEditorScrollbarOptions;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		theme:string;
+		canUseTranslate3d:boolean;
+		experimentalScreenReader: boolean;
+		rulers: number[];
+		ariaLabel: string;
+		renderLineNumbers:boolean;
+		renderCustomLineNumbers: (lineNumber:number)=>string;
+		renderRelativeLineNumbers: boolean;
+		selectOnLineNumbers:boolean;
+		glyphMargin:boolean;
+		revealHorizontalRightPadding:number;
+		roundedSelection:boolean;
+		overviewRulerLanes:number;
+		cursorBlinking:TextEditorCursorBlinkingStyle;
+		mouseWheelZoom:boolean;
+		cursorStyle:TextEditorCursorStyle;
+		hideCursorInOverviewRuler:boolean;
+		scrollBeyondLastLine:boolean;
+		editorClassName: string;
+		stopRenderingLineAfter: number;
+		renderWhitespace: 'none' | 'boundary' | 'all';
+		renderControlCharacters: boolean;
+		renderIndentGuides: boolean;
+		renderLineHighlight: boolean;
+		scrollbar:InternalEditorScrollbarOptions;
+	}) {
+		this.theme = String(source.theme);
+		this.canUseTranslate3d = Boolean(source.canUseTranslate3d);
+		this.experimentalScreenReader = Boolean(source.experimentalScreenReader);
+		this.rulers = InternalEditorViewOptions._toSortedIntegerArray(source.rulers);
+		this.ariaLabel = String(source.ariaLabel);
+		this.renderLineNumbers = Boolean(source.renderLineNumbers);
+		this.renderCustomLineNumbers = source.renderCustomLineNumbers;
+		this.renderRelativeLineNumbers = Boolean(source.renderRelativeLineNumbers);
+		this.selectOnLineNumbers = Boolean(source.selectOnLineNumbers);
+		this.glyphMargin = Boolean(source.glyphMargin);
+		this.revealHorizontalRightPadding = source.revealHorizontalRightPadding|0;
+		this.roundedSelection = Boolean(source.roundedSelection);
+		this.overviewRulerLanes = source.overviewRulerLanes|0;
+		this.cursorBlinking = source.cursorBlinking|0;
+		this.mouseWheelZoom = Boolean(source.mouseWheelZoom);
+		this.cursorStyle = source.cursorStyle|0;
+		this.hideCursorInOverviewRuler = Boolean(source.hideCursorInOverviewRuler);
+		this.scrollBeyondLastLine = Boolean(source.scrollBeyondLastLine);
+		this.editorClassName = String(source.editorClassName);
+		this.stopRenderingLineAfter = source.stopRenderingLineAfter|0;
+		this.renderWhitespace = source.renderWhitespace;
+		this.renderControlCharacters = Boolean(source.renderControlCharacters);
+		this.renderIndentGuides = Boolean(source.renderIndentGuides);
+		this.renderLineHighlight = Boolean(source.renderLineHighlight);
+		this.scrollbar = source.scrollbar.clone();
+	}
+
+	private static _toSortedIntegerArray(source:any): number[] {
+		if (!Array.isArray(source)) {
+			return [];
+		}
+		let arrSource = <any[]>source;
+		let result = arrSource.map(el => {
+			let r = parseInt(el, 10);
+			if (isNaN(r)) {
+				return 0;
+			}
+			return r;
+		});
+		result.sort();
+		return result;
+	}
+
+	private static _numberArraysEqual(a:number[], b:number[]): boolean {
+		if (a.length !== b.length) {
+			return false;
+		}
+		for (let i = 0; i < a.length; i++) {
+			if (a[i] !== b[i]) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:InternalEditorViewOptions): boolean {
+		return (
+			this.theme === other.theme
+			&& this.canUseTranslate3d === other.canUseTranslate3d
+			&& this.experimentalScreenReader === other.experimentalScreenReader
+			&& InternalEditorViewOptions._numberArraysEqual(this.rulers, other.rulers)
+			&& this.ariaLabel === other.ariaLabel
+			&& this.renderLineNumbers === other.renderLineNumbers
+			&& this.renderCustomLineNumbers === other.renderCustomLineNumbers
+			&& this.renderRelativeLineNumbers === other.renderRelativeLineNumbers
+			&& this.selectOnLineNumbers === other.selectOnLineNumbers
+			&& this.glyphMargin === other.glyphMargin
+			&& this.revealHorizontalRightPadding === other.revealHorizontalRightPadding
+			&& this.roundedSelection === other.roundedSelection
+			&& this.overviewRulerLanes === other.overviewRulerLanes
+			&& this.cursorBlinking === other.cursorBlinking
+			&& this.mouseWheelZoom === other.mouseWheelZoom
+			&& this.cursorStyle === other.cursorStyle
+			&& this.hideCursorInOverviewRuler === other.hideCursorInOverviewRuler
+			&& this.scrollBeyondLastLine === other.scrollBeyondLastLine
+			&& this.editorClassName === other.editorClassName
+			&& this.stopRenderingLineAfter === other.stopRenderingLineAfter
+			&& this.renderWhitespace === other.renderWhitespace
+			&& this.renderControlCharacters === other.renderControlCharacters
+			&& this.renderIndentGuides === other.renderIndentGuides
+			&& this.renderLineHighlight === other.renderLineHighlight
+			&& this.scrollbar.equals(other.scrollbar)
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public createChangeEvent(newOpts:InternalEditorViewOptions): IViewConfigurationChangedEvent {
+		return {
+			theme: this.theme !== newOpts.theme,
+			canUseTranslate3d: this.canUseTranslate3d !== newOpts.canUseTranslate3d,
+			experimentalScreenReader: this.experimentalScreenReader !== newOpts.experimentalScreenReader,
+			rulers: (!InternalEditorViewOptions._numberArraysEqual(this.rulers, newOpts.rulers)),
+			ariaLabel: this.ariaLabel !== newOpts.ariaLabel,
+			renderLineNumbers: this.renderLineNumbers !== newOpts.renderLineNumbers,
+			renderCustomLineNumbers: this.renderCustomLineNumbers !== newOpts.renderCustomLineNumbers,
+			renderRelativeLineNumbers: this.renderRelativeLineNumbers !== newOpts.renderRelativeLineNumbers,
+			selectOnLineNumbers: this.selectOnLineNumbers !== newOpts.selectOnLineNumbers,
+			glyphMargin: this.glyphMargin !== newOpts.glyphMargin,
+			revealHorizontalRightPadding: this.revealHorizontalRightPadding !== newOpts.revealHorizontalRightPadding,
+			roundedSelection: this.roundedSelection !== newOpts.roundedSelection,
+			overviewRulerLanes: this.overviewRulerLanes !== newOpts.overviewRulerLanes,
+			cursorBlinking: this.cursorBlinking !== newOpts.cursorBlinking,
+			mouseWheelZoom: this.mouseWheelZoom !== newOpts.mouseWheelZoom,
+			cursorStyle: this.cursorStyle !== newOpts.cursorStyle,
+			hideCursorInOverviewRuler: this.hideCursorInOverviewRuler !== newOpts.hideCursorInOverviewRuler,
+			scrollBeyondLastLine: this.scrollBeyondLastLine !== newOpts.scrollBeyondLastLine,
+			editorClassName: this.editorClassName !== newOpts.editorClassName,
+			stopRenderingLineAfter: this.stopRenderingLineAfter !== newOpts.stopRenderingLineAfter,
+			renderWhitespace: this.renderWhitespace !== newOpts.renderWhitespace,
+			renderControlCharacters: this.renderControlCharacters !== newOpts.renderControlCharacters,
+			renderIndentGuides: this.renderIndentGuides !== newOpts.renderIndentGuides,
+			renderLineHighlight: this.renderLineHighlight !== newOpts.renderLineHighlight,
+			scrollbar: (!this.scrollbar.equals(newOpts.scrollbar)),
+		};
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): InternalEditorViewOptions {
+		return new InternalEditorViewOptions(this);
+	}
+}
+
+export interface IViewConfigurationChangedEvent {
+	theme: boolean;
+	canUseTranslate3d: boolean;
+	experimentalScreenReader: boolean;
+	rulers: boolean;
+	ariaLabel: boolean;
+	renderLineNumbers: boolean;
+	renderCustomLineNumbers: boolean;
+	renderRelativeLineNumbers: boolean;
+	selectOnLineNumbers: boolean;
+	glyphMargin: boolean;
+	revealHorizontalRightPadding: boolean;
+	roundedSelection: boolean;
+	overviewRulerLanes: boolean;
+	cursorBlinking: boolean;
+	mouseWheelZoom: boolean;
+	cursorStyle: boolean;
+	hideCursorInOverviewRuler: boolean;
+	scrollBeyondLastLine: boolean;
+	editorClassName: boolean;
+	stopRenderingLineAfter: boolean;
+	renderWhitespace: boolean;
+	renderControlCharacters: boolean;
+	renderIndentGuides: boolean;
+	renderLineHighlight: boolean;
+	scrollbar: boolean;
+}
+
+export class EditorContribOptions {
+	selectionClipboard: boolean;
+	hover:boolean;
+	contextmenu:boolean;
+	quickSuggestions:boolean;
+	quickSuggestionsDelay:number;
+	parameterHints: boolean;
+	iconsInSuggestions:boolean;
+	formatOnType:boolean;
+	suggestOnTriggerCharacters: boolean;
+	acceptSuggestionOnEnter: boolean;
+	snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+	tabCompletion: boolean;
+	wordBasedSuggestions: boolean;
+	selectionHighlight:boolean;
+	codeLens: boolean;
+	folding: boolean;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		selectionClipboard: boolean;
+		hover:boolean;
+		contextmenu:boolean;
+		quickSuggestions:boolean;
+		quickSuggestionsDelay:number;
+		parameterHints:boolean;
+		iconsInSuggestions:boolean;
+		formatOnType:boolean;
+		suggestOnTriggerCharacters: boolean;
+		acceptSuggestionOnEnter: boolean;
+		snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+		tabCompletion: boolean;
+		wordBasedSuggestions: boolean;
+		selectionHighlight:boolean;
+		codeLens: boolean;
+		folding: boolean;
+	}) {
+		this.selectionClipboard = Boolean(source.selectionClipboard);
+		this.hover = Boolean(source.hover);
+		this.contextmenu = Boolean(source.contextmenu);
+		this.quickSuggestions = Boolean(source.quickSuggestions);
+		this.quickSuggestionsDelay = source.quickSuggestionsDelay||0;
+		this.parameterHints = Boolean(source.parameterHints);
+		this.iconsInSuggestions = Boolean(source.iconsInSuggestions);
+		this.formatOnType = Boolean(source.formatOnType);
+		this.suggestOnTriggerCharacters = Boolean(source.suggestOnTriggerCharacters);
+		this.acceptSuggestionOnEnter = Boolean(source.acceptSuggestionOnEnter);
+		this.snippetSuggestions = source.snippetSuggestions;
+		this.tabCompletion = source.tabCompletion;
+		this.wordBasedSuggestions = source.wordBasedSuggestions;
+		this.selectionHighlight = Boolean(source.selectionHighlight);
+		this.codeLens = Boolean(source.codeLens);
+		this.folding = Boolean(source.folding);
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: EditorContribOptions): boolean {
+		return (
+			this.selectionClipboard === other.selectionClipboard
+			&& this.hover === other.hover
+			&& this.contextmenu === other.contextmenu
+			&& this.quickSuggestions === other.quickSuggestions
+			&& this.quickSuggestionsDelay === other.quickSuggestionsDelay
+			&& this.parameterHints === other.parameterHints
+			&& this.iconsInSuggestions === other.iconsInSuggestions
+			&& this.formatOnType === other.formatOnType
+			&& this.suggestOnTriggerCharacters === other.suggestOnTriggerCharacters
+			&& this.acceptSuggestionOnEnter === other.acceptSuggestionOnEnter
+			&& this.snippetSuggestions === other.snippetSuggestions
+			&& this.tabCompletion === other.tabCompletion
+			&& this.wordBasedSuggestions === other.wordBasedSuggestions
+			&& this.selectionHighlight === other.selectionHighlight
+			&& this.codeLens === other.codeLens
+			&& this.folding === other.folding
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): EditorContribOptions {
+		return new EditorContribOptions(this);
+	}
+}
+
+/**
+ * Internal configuration options (transformed or computed) for the editor.
+ */
+export class InternalEditorOptions {
+	_internalEditorOptionsBrand: void;
+
+	lineHeight:number; // todo: move to fontInfo
+
+	readOnly:boolean;
+	// ---- cursor options
+	wordSeparators: string;
+	autoClosingBrackets:boolean;
+	useTabStops: boolean;
+	tabFocusMode:boolean;
+	// ---- grouped options
+	layoutInfo: EditorLayoutInfo;
+	fontInfo: FontInfo;
+	viewInfo: InternalEditorViewOptions;
+	wrappingInfo: EditorWrappingInfo;
+	contribInfo: EditorContribOptions;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		lineHeight:number;
+		readOnly:boolean;
+		wordSeparators: string;
+		autoClosingBrackets:boolean;
+		useTabStops: boolean;
+		tabFocusMode:boolean;
+		layoutInfo: EditorLayoutInfo;
+		fontInfo: FontInfo;
+		viewInfo: InternalEditorViewOptions;
+		wrappingInfo: EditorWrappingInfo;
+		contribInfo: EditorContribOptions;
+	}) {
+		this.lineHeight = source.lineHeight|0;
+		this.readOnly = Boolean(source.readOnly);
+		this.wordSeparators = String(source.wordSeparators);
+		this.autoClosingBrackets = Boolean(source.autoClosingBrackets);
+		this.useTabStops = Boolean(source.useTabStops);
+		this.tabFocusMode = Boolean(source.tabFocusMode);
+		this.layoutInfo = source.layoutInfo.clone();
+		this.fontInfo = source.fontInfo.clone();
+		this.viewInfo = source.viewInfo.clone();
+		this.wrappingInfo = source.wrappingInfo.clone();
+		this.contribInfo = source.contribInfo.clone();
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:InternalEditorOptions): boolean {
+		return (
+			this.lineHeight === other.lineHeight
+			&& this.readOnly === other.readOnly
+			&& this.wordSeparators === other.wordSeparators
+			&& this.autoClosingBrackets === other.autoClosingBrackets
+			&& this.useTabStops === other.useTabStops
+			&& this.tabFocusMode === other.tabFocusMode
+			&& this.layoutInfo.equals(other.layoutInfo)
+			&& this.fontInfo.equals(other.fontInfo)
+			&& this.viewInfo.equals(other.viewInfo)
+			&& this.wrappingInfo.equals(other.wrappingInfo)
+			&& this.contribInfo.equals(other.contribInfo)
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public createChangeEvent(newOpts:InternalEditorOptions): IConfigurationChangedEvent {
+		return {
+			lineHeight: (this.lineHeight !== newOpts.lineHeight),
+			readOnly: (this.readOnly !== newOpts.readOnly),
+			wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
+			autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
+			useTabStops: (this.useTabStops !== newOpts.useTabStops),
+			tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
+			layoutInfo: (!this.layoutInfo.equals(newOpts.layoutInfo)),
+			fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
+			viewInfo: this.viewInfo.createChangeEvent(newOpts.viewInfo),
+			wrappingInfo: (!this.wrappingInfo.equals(newOpts.wrappingInfo)),
+			contribInfo: (!this.contribInfo.equals(newOpts.contribInfo)),
+		};
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): InternalEditorOptions {
+		return new InternalEditorOptions(this);
+	}
+}
+
+/**
+ * An event describing that the configuration of the editor has changed.
+ */
+export interface IConfigurationChangedEvent {
+	lineHeight: boolean;
+	readOnly: boolean;
+	wordSeparators: boolean;
+	autoClosingBrackets: boolean;
+	useTabStops: boolean;
+	tabFocusMode: boolean;
+	layoutInfo: boolean;
+	fontInfo: boolean;
+	viewInfo: IViewConfigurationChangedEvent;
+	wrappingInfo: boolean;
+	contribInfo: boolean;
+}
+
+/**
+ * Vertical Lane in the overview ruler of the editor.
+ */
+export enum OverviewRulerLane {
+	Left = 1,
+	Center = 2,
+	Right = 4,
+	Full = 7
+}
+
+/**
+ * Options for rendering a model decoration in the overview ruler.
+ */
+export interface IModelDecorationOverviewRulerOptions {
+	/**
+	 * CSS color to render in the overview ruler.
+	 * e.g.: rgba(100, 100, 100, 0.5)
+	 */
+	color: string;
+	/**
+	 * CSS color to render in the overview ruler.
+	 * e.g.: rgba(100, 100, 100, 0.5)
+	 */
+	darkColor: string;
+	/**
+	 * The position in the overview ruler.
+	 */
+	position: OverviewRulerLane;
+}
+
+/**
+ * Options for a model decoration.
+ */
+export interface IModelDecorationOptions {
+	/**
+	 * Customize the growing behaviour of the decoration when typing at the edges of the decoration.
+	 * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
+	 */
+	stickiness?:TrackedRangeStickiness;
+	/**
+	 * CSS class name describing the decoration.
+	 */
+	className?:string;
+	/**
+	 * Message to be rendered when hovering over the glyph margin decoration.
+	 * @internal
+	 */
+	glyphMarginHoverMessage?:string;
+	/**
+	 * Array of MarkedString to render as the decoration message.
+	 */
+	hoverMessage?:MarkedString | MarkedString[];
+	/**
+	 * Should the decoration expand to encompass a whole line.
+	 */
+	isWholeLine?:boolean;
+	/**
+	 * @deprecated : Use `overviewRuler` instead
+	 */
+	showInOverviewRuler?:string;
+	/**
+	 * If set, render this decoration in the overview ruler.
+	 */
+	overviewRuler?:IModelDecorationOverviewRulerOptions;
+	/**
+	 * If set, the decoration will be rendered in the glyph margin with this CSS class name.
+	 */
+	glyphMarginClassName?:string;
+	/**
+	 * If set, the decoration will be rendered in the lines decorations with this CSS class name.
+	 */
+	linesDecorationsClassName?:string;
+	/**
+	 * If set, the decoration will be rendered inline with the text with this CSS class name.
+	 * Please use this only for CSS rules that must impact the text. For example, use `className`
+	 * to have a background color decoration.
+	 */
+	inlineClassName?:string;
+	/**
+	 * If set, the decoration will be rendered before the text with this CSS class name.
+	 */
+	beforeContentClassName?:string;
+	/**
+	 * If set, the decoration will be rendered after the text with this CSS class name.
+	 */
+	afterContentClassName?:string;
+}
+
+/**
+ * New model decorations.
+ */
+export interface IModelDeltaDecoration {
+	/**
+	 * Range that this decoration covers.
+	 */
+	range: IRange;
+	/**
+	 * Options associated with this decoration.
+	 */
+	options: IModelDecorationOptions;
+}
+
+/**
+ * A tracked range in the model.
+ * @internal
+ */
+export interface IModelTrackedRange {
+	/**
+	 * Identifier for a tracked range
+	 */
+	id: string;
+	/**
+	 * Range that this tracked range covers
+	 */
+	range: Range;
+}
+
+/**
+ * A decoration in the model.
+ */
+export interface IModelDecoration {
+	/**
+	 * Identifier for a decoration.
+	 */
+	id: string;
+	/**
+	 * Identifier for a decoration's owener.
+	 */
+	ownerId: number;
+	/**
+	 * Range that this decoration covers.
+	 */
+	range: Range;
+	/**
+	 * Options associated with this decoration.
+	 */
+	options: IModelDecorationOptions;
+}
+
+/**
+ * An accessor that can add, change or remove model decorations.
+ * @internal
+ */
+export interface IModelDecorationsChangeAccessor {
+	/**
+	 * Add a new decoration.
+	 * @param range Range that this decoration covers.
+	 * @param options Options associated with this decoration.
+	 * @return An unique identifier associated with this decoration.
+	 */
+	addDecoration(range:IRange, options:IModelDecorationOptions): string;
+	/**
+	 * Change the range that an existing decoration covers.
+	 * @param id The unique identifier associated with the decoration.
+	 * @param newRange The new range that this decoration covers.
+	 */
+	changeDecoration(id:string, newRange:IRange): void;
+	/**
+	 * Change the options associated with an existing decoration.
+	 * @param id The unique identifier associated with the decoration.
+	 * @param newOptions The new options associated with this decoration.
+	 */
+	changeDecorationOptions(id: string, newOptions:IModelDecorationOptions): void;
+	/**
+	 * Remove an existing decoration.
+	 * @param id The unique identifier associated with the decoration.
+	 */
+	removeDecoration(id:string): void;
+	/**
+	 * Perform a minimum ammount of operations, in order to transform the decorations
+	 * identified by `oldDecorations` to the decorations described by `newDecorations`
+	 * and returns the new identifiers associated with the resulting decorations.
+	 *
+	 * @param oldDecorations Array containing previous decorations identifiers.
+	 * @param newDecorations Array describing what decorations should result after the call.
+	 * @return An array containing the new decorations identifiers.
+	 */
+	deltaDecorations(oldDecorations:string[], newDecorations:IModelDeltaDecoration[]): string[];
+}
+
+/**
+ * Word inside a model.
+ */
+export interface IWordAtPosition {
+	/**
+	 * The word.
+	 */
+	word: string;
+	/**
+	 * The column where the word starts.
+	 */
+	startColumn: number;
+	/**
+	 * The column where the word ends.
+	 */
+	endColumn: number;
+}
+
+/**
+ * Range of a word inside a model.
+ * @internal
+ */
+export interface IWordRange {
+	/**
+	 * The index where the word starts.
+	 */
+	start:number;
+	/**
+	 * The index where the word ends.
+	 */
+	end:number;
+}
+
+/**
+ * @internal
+ */
+export interface ITokenInfo {
+	type: string;
+	lineNumber: number;
+	startColumn: number;
+	endColumn: number;
+}
+
+/**
+ * @internal
+ */
+export interface ITokenIterator {
+	hasNext(): boolean;
+	next(): ITokenInfo;
+	hasPrev(): boolean;
+	prev(): ITokenInfo;
+}
+
+/**
+ * End of line character preference.
+ */
+export enum EndOfLinePreference {
+	/**
+	 * Use the end of line character identified in the text buffer.
+	 */
+	TextDefined = 0,
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 1,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 2
+}
+
+/**
+ * The default end of line to use when instantiating models.
+ */
+export enum DefaultEndOfLine {
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 1,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 2
+}
+
+/**
+ * End of line character preference.
+ */
+export enum EndOfLineSequence {
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 0,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 1
+}
+
+/**
+ * A read-only line marker in the model.
+ * @internal
+ */
+export interface IReadOnlyLineMarker {
+	id: string;
+	column: number;
+}
+
+/**
+ * And identifier for a single edit operation.
+ */
+export interface ISingleEditOperationIdentifier {
+	/**
+	 * Identifier major
+	 */
+	major:number;
+	/**
+	 * Identifier minor
+	 */
+	minor:number;
+}
+
+/**
+ * A builder and helper for edit operations for a command.
+ */
+export interface IEditOperationBuilder {
+	/**
+	 * Add a new edit operation (a replace operation).
+	 * @param range The range to replace (delete). May be empty to represent a simple insert.
+	 * @param text The text to replace with. May be null to represent a simple delete.
+	 */
+	addEditOperation(range:Range, text:string): void;
+
+	/**
+	 * Track `selection` when applying edit operations.
+	 * A best effort will be made to not grow/expand the selection.
+	 * An empty selection will clamp to a nearby character.
+	 * @param selection The selection to track.
+	 * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
+	 *           should clamp to the previous or the next character.
+	 * @return A unique identifer.
+	 */
+	trackSelection(selection:Selection, trackPreviousOnEmpty?:boolean): string;
+}
+
+/**
+ * A helper for computing cursor state after a command.
+ */
+export interface ICursorStateComputerData {
+	/**
+	 * Get the inverse edit operations of the added edit operations.
+	 */
+	getInverseEditOperations(): IIdentifiedSingleEditOperation[];
+	/**
+	 * Get a previously tracked selection.
+	 * @param id The unique identifier returned by `trackSelection`.
+	 * @return The selection.
+	 */
+	getTrackedSelection(id:string): Selection;
+}
+
+/**
+ * A command that modifies text / cursor state on a model.
+ */
+export interface ICommand {
+	/**
+	 * Get the edit operations needed to execute this command.
+	 * @param model The model the command will execute on.
+	 * @param builder A helper to collect the needed edit operations and to track selections.
+	 */
+	getEditOperations(model:ITokenizedModel, builder:IEditOperationBuilder): void;
+	/**
+	 * Compute the cursor state after the edit operations were applied.
+	 * @param model The model the commad has executed on.
+	 * @param helper A helper to get inverse edit operations and to get previously tracked selections.
+	 * @return The cursor state after the command executed.
+	 */
+	computeCursorState(model:ITokenizedModel, helper:ICursorStateComputerData): Selection;
+}
+
+/**
+ * A single edit operation, that acts as a simple replace.
+ * i.e. Replace text at `range` with `text` in model.
+ */
+export interface ISingleEditOperation {
+	/**
+	 * The range to replace. This can be empty to emulate a simple insert.
+	 */
+	range: IRange;
+	/**
+	 * The text to replace with. This can be null to emulate a simple delete.
+	 */
+	text: string;
+	/**
+	 * This indicates that this operation has "insert" semantics.
+	 * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+	 */
+	forceMoveMarkers?: boolean;
+}
+
+/**
+ * A single edit operation, that has an identifier.
+ */
+export interface IIdentifiedSingleEditOperation {
+	/**
+	 * An identifier associated with this single edit operation.
+	 */
+	identifier: ISingleEditOperationIdentifier;
+	/**
+	 * The range to replace. This can be empty to emulate a simple insert.
+	 */
+	range: Range;
+	/**
+	 * The text to replace with. This can be null to emulate a simple delete.
+	 */
+	text: string;
+	/**
+	 * This indicates that this operation has "insert" semantics.
+	 * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+	 */
+	forceMoveMarkers: boolean;
+	/**
+	 * This indicates that this operation is inserting automatic whitespace
+	 * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
+	 */
+	isAutoWhitespaceEdit?: boolean;
+}
+
+/**
+ * A callback that can compute the cursor state after applying a series of edit operations.
+ */
+export interface ICursorStateComputer {
+	/**
+	 * A callback that can compute the resulting cursors state after some edit operations have been executed.
+	 */
+	(inverseEditOperations:IIdentifiedSingleEditOperation[]): Selection[];
+}
+
+export interface ITextModelResolvedOptions {
+	tabSize: number;
+	insertSpaces: boolean;
+	defaultEOL: DefaultEndOfLine;
+	trimAutoWhitespace: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface ITextModelCreationOptions {
+	tabSize: number;
+	insertSpaces: boolean;
+	detectIndentation: boolean;
+	trimAutoWhitespace: boolean;
+	defaultEOL: DefaultEndOfLine;
+}
+
+export interface ITextModelUpdateOptions {
+	tabSize?: number;
+	insertSpaces?: boolean;
+	trimAutoWhitespace?: boolean;
+}
+
+export interface IModelOptionsChangedEvent {
+	tabSize: boolean;
+	insertSpaces: boolean;
+	trimAutoWhitespace: boolean;
+}
+
+/**
+ * A textual read-only model.
+ */
+export interface ITextModel {
+
+	getOptions(): ITextModelResolvedOptions;
+
+	/**
+	 * Get the current version id of the model.
+	 * Anytime a change happens to the model (even undo/redo),
+	 * the version id is incremented.
+	 */
+	getVersionId(): number;
+
+	/**
+	 * Get the alternative version id of the model.
+	 * This alternative version id is not always incremented,
+	 * it will return the same values in the case of undo-redo.
+	 */
+	getAlternativeVersionId(): number;
+
+	/**
+	 * Replace the entire text buffer value contained in this model.
+	 */
+	setValue(newValue:string): void;
+
+	/**
+	 * Replace the entire text buffer value contained in this model.
+	 */
+	setValueFromRawText(newValue:IRawText): void;
+
+	/**
+	 * Get the text stored in this model.
+	 * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
+	 * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
+	 * @return The text.
+	 */
+	getValue(eol?:EndOfLinePreference, preserveBOM?:boolean): string;
+
+	/**
+	 * Get the length of the text stored in this model.
+	 */
+	getValueLength(eol?:EndOfLinePreference, preserveBOM?:boolean): number;
+
+	/**
+	 * Get the raw text stored in this model.
+	 */
+	toRawText(): IRawText;
+
+	/**
+	 * Check if the raw text stored in this model equals another raw text.
+	 */
+	equals(other:IRawText): boolean;
+
+	/**
+	 * Get the text in a certain range.
+	 * @param range The range describing what text to get.
+	 * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
+	 * @return The text.
+	 */
+	getValueInRange(range:IRange, eol?:EndOfLinePreference): string;
+
+	/**
+	 * Get the length of text in a certain range.
+	 * @param range The range describing what text length to get.
+	 * @return The text length.
+	 */
+	getValueLengthInRange(range:IRange): number;
+
+	/**
+	 * Splits characters in two buckets. First bucket (A) is of characters that
+	 * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of
+	 * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.
+	 * If count(B) > count(A) return true. Returns false otherwise.
+	 * @internal
+	 */
+	isDominatedByLongLines(): boolean;
+
+	/**
+	 * Get the number of lines in the model.
+	 */
+	getLineCount(): number;
+
+	/**
+	 * Get the text for a certain line.
+	 */
+	getLineContent(lineNumber:number): string;
+
+	/**
+	 * @internal
+	 */
+	getIndentLevel(lineNumber:number): number;
+
+	/**
+	 * @internal
+	 */
+	getIndentRanges(): IndentRange[];
+
+	/**
+	 * @internal
+	 */
+	getLineIndentGuide(lineNumber:number): number;
+
+	/**
+	 * Get the text for all lines.
+	 */
+	getLinesContent(): string[];
+
+	/**
+	 * Get the end of line sequence predominantly used in the text buffer.
+	 * @return EOL char sequence (e.g.: '\n' or '\r\n').
+	 */
+	getEOL(): string;
+
+	/**
+	 * Change the end of line sequence used in the text buffer.
+	 */
+	setEOL(eol: EndOfLineSequence): void;
+
+	/**
+	 * Get the minimum legal column for line at `lineNumber`
+	 */
+	getLineMinColumn(lineNumber:number): number;
+
+	/**
+	 * Get the maximum legal column for line at `lineNumber`
+	 */
+	getLineMaxColumn(lineNumber:number): number;
+
+	/**
+	 * Returns the column before the first non whitespace character for line at `lineNumber`.
+	 * Returns 0 if line is empty or contains only whitespace.
+	 */
+	getLineFirstNonWhitespaceColumn(lineNumber:number): number;
+
+	/**
+	 * Returns the column after the last non whitespace character for line at `lineNumber`.
+	 * Returns 0 if line is empty or contains only whitespace.
+	 */
+	getLineLastNonWhitespaceColumn(lineNumber:number): number;
+
+	/**
+	 * Create a valid position,
+	 */
+	validatePosition(position:IPosition): Position;
+
+	/**
+	 * Advances the given position by the given offest (negative offsets are also accepted)
+	 * and returns it as a new valid position.
+	 *
+	 * If the offset and position are such that their combination goes beyond the beginning or
+	 * end of the model, throws an exception.
+	 *
+	 * If the ofsset is such that the new position would be in the middle of a multi-byte
+	 * line terminator, throws an exception.
+	 */
+	modifyPosition(position: IPosition, offset: number): Position;
+
+	/**
+	 * Create a valid range.
+	 */
+	validateRange(range:IRange): Range;
+
+	/**
+	 * Converts the position to a zero-based offset.
+	 *
+	 * The position will be [adjusted](#TextDocument.validatePosition).
+	 *
+	 * @param position A position.
+	 * @return A valid zero-based offset.
+	 */
+	getOffsetAt(position: IPosition): number;
+
+	/**
+	 * Converts a zero-based offset to a position.
+	 *
+	 * @param offset A zero-based offset.
+	 * @return A valid [position](#Position).
+	 */
+	getPositionAt(offset: number): Position;
+
+	/**
+	 * Get a range covering the entire model
+	 */
+	getFullModelRange(): Range;
+
+	/**
+	 * Returns iff the model was disposed or not.
+	 */
+	isDisposed(): boolean;
+
+	/**
+	 * No mode supports allowed on this model because it is simply too large.
+	 * (even tokenization would cause too much memory pressure)
+	 * @internal
+	 */
+	isTooLargeForHavingAMode(): boolean;
+
+	/**
+	 * Only basic mode supports allowed on this model because it is simply too large.
+	 * (tokenization is allowed and other basic supports)
+	 * @internal
+	 */
+	isTooLargeForHavingARichMode(): boolean;
+
+	/**
+	 * Search the model.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param limitResultCount Limit the number of results
+	 * @return The ranges where the matches are. It is empty if not matches have been found.
+	 */
+	findMatches(searchString:string, searchOnlyEditableRange:boolean, isRegex:boolean, matchCase:boolean, wholeWord:boolean, limitResultCount?:number): Range[];
+	/**
+	 * Search the model.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchScope Limit the searching to only search inside this range.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param limitResultCount Limit the number of results
+	 * @return The ranges where the matches are. It is empty if no matches have been found.
+	 */
+	findMatches(searchString:string, searchScope:IRange, isRegex:boolean, matchCase:boolean, wholeWord:boolean, limitResultCount?:number): Range[];
+	/**
+	 * Search the model for the next match. Loops to the beginning of the model if needed.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchStart Start the searching at the specified position.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @return The range where the next match is. It is null if no next match has been found.
+	 */
+	findNextMatch(searchString:string, searchStart:IPosition, isRegex:boolean, matchCase:boolean, wholeWord:boolean): Range;
+	/**
+	 * Search the model for the previous match. Loops to the end of the model if needed.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchStart Start the searching at the specified position.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @return The range where the previous match is. It is null if no previous match has been found.
+	 */
+	findPreviousMatch(searchString:string, searchStart:IPosition, isRegex:boolean, matchCase:boolean, wholeWord:boolean): Range;
+}
+
+export interface IReadOnlyModel extends ITextModel {
+	/**
+	 * Gets the resource associated with this editor model.
+	 */
+	uri: URI;
+
+	/**
+	 * Get the language associated with this model.
+	 */
+	getModeId(): string;
+
+	/**
+	 * Get the word under or besides `position`.
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Might be null.
+	 */
+	getWordAtPosition(position:IPosition): IWordAtPosition;
+
+	/**
+	 * Get the word under or besides `position` trimmed to `position`.column
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Will never be null.
+	 */
+	getWordUntilPosition(position:IPosition): IWordAtPosition;
+}
+
+/**
+ * @internal
+ */
+export interface IRichEditBracket {
+	modeId: string;
+	open: string;
+	close: string;
+	forwardRegex: RegExp;
+	reversedRegex: RegExp;
+}
+
+/**
+ * @internal
+ */
+export interface IFoundBracket {
+	range: Range;
+	open: string;
+	close: string;
+	isOpen: boolean;
+}
+
+/**
+ * A model that is tokenized.
+ */
+export interface ITokenizedModel extends ITextModel {
+
+	/**
+	 * Tokenize if necessary and get the tokens for the line `lineNumber`.
+	 * @param lineNumber The line number
+	 * @param inaccurateTokensAcceptable Are inaccurate tokens acceptable? Defaults to false
+	 * @internal
+	 */
+	getLineTokens(lineNumber:number, inaccurateTokensAcceptable?:boolean): LineTokens;
+
+	/**
+	 * Tokenize if necessary and get the tokenization result for the line `lineNumber`, as returned by the language mode.
+	 * @internal
+	 */
+	getLineContext(lineNumber:number): ILineContext;
+
+	/**
+	 * @internal
+	 */
+	_getLineModeTransitions(lineNumber:number): ModeTransition[];
+
+	/**
+	 * Get the current language mode associated with the model.
+	 */
+	getMode(): IMode;
+
+	/**
+	 * Get the language associated with this model.
+	 */
+	getModeId(): string;
+
+	/**
+	 * Set the current language mode associated with the model.
+	 * @internal
+	 */
+	setMode(languageId:string): void;
+
+	/**
+	 * Returns the true (inner-most) language mode at a given position.
+	 * @internal
+	 */
+	getModeIdAtPosition(lineNumber:number, column:number): string;
+
+	/**
+	 * Get the word under or besides `position`.
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Might be null.
+	 */
+	getWordAtPosition(position:IPosition): IWordAtPosition;
+
+	/**
+	 * Get the word under or besides `position` trimmed to `position`.column
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Will never be null.
+	 */
+	getWordUntilPosition(position:IPosition): IWordAtPosition;
+
+	/**
+	 * Returns an iterator that can be used to read
+	 * next and previous tokens from the provided position.
+	 * The iterator is made available through the callback
+	 * function and can't be used afterwards.
+	 * @internal
+	 */
+	tokenIterator(position: IPosition, callback: (it: ITokenIterator) =>any): any;
+
+	/**
+	 * Find the matching bracket of `request` up, counting brackets.
+	 * @param request The bracket we're searching for
+	 * @param position The position at which to start the search.
+	 * @return The range of the matching bracket, or null if the bracket match was not found.
+	 * @internal
+	 */
+	findMatchingBracketUp(bracket:string, position:IPosition): Range;
+
+	// /**
+	//  * Find the first bracket in the model before `position`.
+	//  * @param position The position at which to start the search.
+	//  * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.
+	//  */
+	// findPrevBracket(position:IPosition): IFoundBracket;
+
+	// /**
+	//  * Find the first bracket in the model after `position`.
+	//  * @param position The position at which to start the search.
+	//  * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.
+	//  */
+	// findNextBracket(position:IPosition): IFoundBracket;
+
+	/**
+	 * Given a `position`, if the position is on top or near a bracket,
+	 * find the matching bracket of that bracket and return the ranges of both brackets.
+	 * @param position The position at which to look for a bracket.
+	 * @internal
+	 */
+	matchBracket(position:IPosition): [Range,Range];
+}
+
+/**
+ * A model that can track markers.
+ */
+export interface ITextModelWithMarkers extends ITextModel {
+	/**
+	 * @internal
+	 */
+	_addMarker(lineNumber:number, column:number, stickToPreviousCharacter:boolean): string;
+	/**
+	 * @internal
+	 */
+	_changeMarker(id:string, newLineNumber:number, newColumn:number): void;
+	/**
+	 * @internal
+	 */
+	_changeMarkerStickiness(id:string, newStickToPreviousCharacter:boolean): void;
+	/**
+	 * @internal
+	 */
+	_getMarker(id:string): Position;
+	/**
+	 * @internal
+	 */
+	_removeMarker(id:string): void;
+	/**
+	 * @internal
+	 */
+	_getLineMarkers(lineNumber: number): IReadOnlyLineMarker[];
+}
+
+/**
+ * A map of changed ranges used during the model internal processing
+ * @internal
+ */
+export interface IChangedTrackedRanges {
+	[key:string]:IRange;
+}
+
+/**
+ * Describes the behaviour of decorations when typing/editing near their edges.
+ */
+export enum TrackedRangeStickiness {
+	AlwaysGrowsWhenTypingAtEdges = 0,
+	NeverGrowsWhenTypingAtEdges = 1,
+	GrowsOnlyWhenTypingBefore = 2,
+	GrowsOnlyWhenTypingAfter = 3,
+}
+
+/**
+ * A model that can track ranges.
+ */
+export interface ITextModelWithTrackedRanges extends ITextModel {
+	/**
+	 * Start tracking a range (across edit operations).
+	 * @param range The range to start tracking.
+	 * @param stickiness The behaviour when typing at the edges of the range.
+	 * @return A unique identifier for the tracked range.
+	 * @internal
+	 */
+	addTrackedRange(range:IRange, stickiness:TrackedRangeStickiness): string;
+
+	/**
+	 * Change the range of a tracked range.
+	 * @param id The id of the tracked range, as returned by a `addTrackedRange` call.
+	 * @param newRange The new range of the tracked range.
+	 * @internal
+	 */
+	changeTrackedRange(id:string, newRange:IRange): void;
+
+	/**
+	 * Change the stickiness (behaviour when typing at the edges of the range) for a tracked range.
+	 * @param id The id of the tracked range, as returned by a `addTrackedRange` call.
+	 * @param newStickiness The new behaviour when typing at the edges of the range.
+	 * @internal
+	 */
+	changeTrackedRangeStickiness(id:string, newStickiness:TrackedRangeStickiness): void;
+
+	/**
+	 * Remove a tracked range.
+	 * @param id The id of the tracked range, as returned by a `addTrackedRaneg` call.
+	 * @internal
+	 */
+	removeTrackedRange(id:string): void;
+
+	/**
+	 * Get the range of a tracked range.
+	 * @param id The id of the tracked range, as returned by a `addTrackedRaneg` call.
+	 * @internal
+	 */
+	getTrackedRange(id:string): Range;
+
+	/**
+	 * Gets all the tracked ranges for the lines between `startLineNumber` and `endLineNumber` as an array.
+	 * @param startLineNumber The start line number
+	 * @param endLineNumber The end line number
+	 * @return An array with the tracked ranges
+	 * @internal
+	 */
+	getLinesTrackedRanges(startLineNumber:number, endLineNumber:number): IModelTrackedRange[];
+}
+
+/**
+ * A model that can have decorations.
+ */
+export interface ITextModelWithDecorations {
+	/**
+	 * Change the decorations. The callback will be called with a change accessor
+	 * that becomes invalid as soon as the callback finishes executing.
+	 * This allows for all events to be queued up until the change
+	 * is completed. Returns whatever the callback returns.
+	 * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+	 * @internal
+	 */
+	changeDecorations(callback: (changeAccessor:IModelDecorationsChangeAccessor)=>any, ownerId?:number): any;
+
+	/**
+	 * Perform a minimum ammount of operations, in order to transform the decorations
+	 * identified by `oldDecorations` to the decorations described by `newDecorations`
+	 * and returns the new identifiers associated with the resulting decorations.
+	 *
+	 * @param oldDecorations Array containing previous decorations identifiers.
+	 * @param newDecorations Array describing what decorations should result after the call.
+	 * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+	 * @return An array containing the new decorations identifiers.
+	 */
+	deltaDecorations(oldDecorations:string[], newDecorations:IModelDeltaDecoration[], ownerId?:number): string[];
+
+	/**
+	 * Remove all decorations that have been added with this specific ownerId.
+	 * @param ownerId The owner id to search for.
+	 * @internal
+	 */
+	removeAllDecorationsWithOwnerId(ownerId:number): void;
+
+	/**
+	 * Get the options associated with a decoration.
+	 * @param id The decoration id.
+	 * @return The decoration options or null if the decoration was not found.
+	 */
+	getDecorationOptions(id:string): IModelDecorationOptions;
+
+	/**
+	 * Get the range associated with a decoration.
+	 * @param id The decoration id.
+	 * @return The decoration range or null if the decoration was not found.
+	 */
+	getDecorationRange(id:string): Range;
+
+	/**
+	 * Gets all the decorations for the line `lineNumber` as an array.
+	 * @param lineNumber The line number
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getLineDecorations(lineNumber:number, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
+	 * @param startLineNumber The start line number
+	 * @param endLineNumber The end line number
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getLinesDecorations(startLineNumber:number, endLineNumber:number, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
+	 * So for now it returns all the decorations on the same line as `range`.
+	 * @param range The range to search in
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getDecorationsInRange(range:IRange, ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the decorations as an array.
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 */
+	getAllDecorations(ownerId?:number, filterOutValidation?:boolean): IModelDecoration[];
+}
+
+/**
+ * An editable text model.
+ */
+export interface IEditableTextModel extends ITextModelWithMarkers {
+
+	/**
+	 * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
+	 */
+	normalizeIndentation(str:string): string;
+
+	/**
+	 * Get what is considered to be one indent (e.g. a tab character or 4 spaces, etc.).
+	 */
+	getOneIndent(): string;
+
+	/**
+	 * Change the options of this model.
+	 */
+	updateOptions(newOpts:ITextModelUpdateOptions): void;
+
+	/**
+	 * Detect the indentation options for this model from its content.
+	 */
+	detectIndentation(defaultInsertSpaces:boolean, defaultTabSize:number): void;
+
+	/**
+	 * Push a stack element onto the undo stack. This acts as an undo/redo point.
+	 * The idea is to use `pushEditOperations` to edit the model and then to
+	 * `pushStackElement` to create an undo/redo stop point.
+	 */
+	pushStackElement(): void;
+
+	/**
+	 * Push edit operations, basically editing the model. This is the preferred way
+	 * of editing the model. The edit operations will land on the undo stack.
+	 * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.
+	 * @param editOperations The edit operations.
+	 * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
+	 * @return The cursor state returned by the `cursorStateComputer`.
+	 */
+	pushEditOperations(beforeCursorState:Selection[], editOperations:IIdentifiedSingleEditOperation[], cursorStateComputer:ICursorStateComputer): Selection[];
+
+	/**
+	 * Edit the model without adding the edits to the undo stack.
+	 * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
+	 * @param operations The edit operations.
+	 * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.
+	 */
+	applyEdits(operations:IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];
+
+	/**
+	 * Undo edit operations until the first previous stop point created by `pushStackElement`.
+	 * The inverse edit operations will be pushed on the redo stack.
+	 * @internal
+	 */
+	undo(): Selection[];
+
+	/**
+	 * Redo edit operations until the next stop point created by `pushStackElement`.
+	 * The inverse edit operations will be pushed on the undo stack.
+	 * @internal
+	 */
+	redo(): Selection[];
+
+	/**
+	 * Set an editable range on the model.
+	 * @internal
+	 */
+	setEditableRange(range:IRange): void;
+
+	/**
+	 * Check if the model has an editable range.
+	 * @internal
+	 */
+	hasEditableRange(): boolean;
+
+	/**
+	 * Get the editable range on the model.
+	 * @internal
+	 */
+	getEditableRange(): Range;
+}
+
+/**
+ * A model.
+ */
+export interface IModel extends IReadOnlyModel, IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithTrackedRanges, ITextModelWithDecorations, IEditorModel {
+	/**
+	 * @deprecated Please use `onDidChangeContent` instead.
+	 * An event emitted when the contents of the model have changed.
+	 * @internal
+	 */
+	onDidChangeRawContent(listener: (e:IModelContentChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the contents of the model have changed.
+	 */
+	onDidChangeContent(listener: (e:IModelContentChangedEvent2)=>void): IDisposable;
+	/**
+	 * An event emitted when decorations of the model have changed.
+	 */
+	onDidChangeDecorations(listener: (e:IModelDecorationsChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the model options have changed.
+	 */
+	onDidChangeOptions(listener: (e:IModelOptionsChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the language associated with the model has changed.
+	 */
+	onDidChangeMode(listener: (e:IModelModeChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted right before disposing the model.
+	 */
+	onWillDispose(listener: ()=>void): IDisposable;
+
+	/**
+	 * @internal
+	 */
+	addBulkListener(listener:BulkListenerCallback):IDisposable;
+
+	/**
+	 * A unique identifier associated with this model.
+	 */
+	id: string;
+
+	/**
+	 * Destroy this model. This will unbind the model from the mode
+	 * and make all necessary clean-up to release this object to the GC.
+	 * @internal
+	 */
+	destroy(): void;
+
+	/**
+	 * Destroy this model. This will unbind the model from the mode
+	 * and make all necessary clean-up to release this object to the GC.
+	 */
+	dispose(): void;
+
+	/**
+	 * @internal
+	 */
+	onBeforeAttached(): void;
+
+	/**
+	 * @internal
+	 */
+	onBeforeDetached(): void;
+
+	/**
+	 * Returns iff this model is attached to an editor or not.
+	 * @internal
+	 */
+	isAttachedToEditor(): boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IRangeWithText {
+	text:string;
+	range:IRange;
+}
+
+/**
+ * An event describing that the current mode associated with a model has changed.
+ */
+export interface IModelModeChangedEvent {
+	/**
+	 * Previous mode
+	 */
+	oldMode:IMode;
+	/**
+	 * New mode
+	 */
+	newMode:IMode;
+}
+
+/**
+ * An event describing a change in the text of a model.
+ */
+export interface IModelContentChangedEvent2 {
+	/**
+	 * The range that got replaced.
+	 */
+	range: IRange;
+	/**
+	 * The length of the range that got replaced.
+	 */
+	rangeLength: number;
+	/**
+	 * The new text for the range.
+	 */
+	text: string;
+	/**
+	 * The (new) end-of-line character.
+	 */
+	eol: string;
+	/**
+	 * The new version id the model has transitioned to.
+	 */
+	versionId: number;
+	/**
+	 * Flag that indicates that this event was generated while undoing.
+	 */
+	isUndoing: boolean;
+	/**
+	 * Flag that indicates that this event was generated while redoing.
+	 */
+	isRedoing: boolean;
+}
+/**
+ * An event describing a change in the text of a model.
+ * @internal
+ */
+export interface IModelContentChangedEvent {
+	/**
+	 * The event type. It can be used to detect the actual event type:
+	 * 		EditorCommon.EventType.ModelContentChangedFlush => IModelContentChangedFlushEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLinesDeleted => IModelContentChangedLineChangedEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLinesInserted => IModelContentChangedLinesDeletedEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLineChanged => IModelContentChangedLinesInsertedEvent
+	 */
+	changeType: string;
+	/**
+	 * The new version id the model has transitioned to.
+	 */
+	versionId: number;
+	/**
+	 * Flag that indicates that this event was generated while undoing.
+	 */
+	isUndoing: boolean;
+	/**
+	 * Flag that indicates that this event was generated while redoing.
+	 */
+	isRedoing: boolean;
+}
+
+/**
+ * The raw text backing a model.
+ */
+export interface IRawText {
+	/**
+	 * The entire text length.
+	 */
+	length: number;
+	/**
+	 * The text split into lines.
+	 */
+	lines: string[];
+	/**
+	 * The BOM (leading character sequence of the file).
+	 */
+	BOM: string;
+	/**
+	 * The end of line sequence.
+	 */
+	EOL: string;
+	/**
+	 * The options associated with this text.
+	 */
+	options: ITextModelResolvedOptions;
+}
+
+/**
+ * An event describing that a model has been reset to a new value.
+ * @internal
+ */
+export interface IModelContentChangedFlushEvent extends IModelContentChangedEvent {
+	/**
+	 * The new text content of the model.
+	 */
+	detail: IRawText;
+}
+/**
+ * An event describing that a line has changed in a model.
+ * @internal
+ */
+export interface IModelContentChangedLineChangedEvent extends IModelContentChangedEvent {
+	/**
+	 * The line that has changed.
+	 */
+	lineNumber: number;
+	/**
+	 * The new value of the line.
+	 */
+	detail: string;
+}
+/**
+ * An event describing that line(s) have been deleted in a model.
+ * @internal
+ */
+export interface IModelContentChangedLinesDeletedEvent extends IModelContentChangedEvent {
+	/**
+	 * At what line the deletion began (inclusive).
+	 */
+	fromLineNumber: number;
+	/**
+	 * At what line the deletion stopped (inclusive).
+	 */
+	toLineNumber: number;
+}
+/**
+ * An event describing that line(s) have been inserted in a model.
+ * @internal
+ */
+export interface IModelContentChangedLinesInsertedEvent extends IModelContentChangedEvent {
+	/**
+	 * Before what line did the insertion begin
+	 */
+	fromLineNumber: number;
+	/**
+	 * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
+	 */
+	toLineNumber: number;
+	/**
+	 * The text that was inserted
+	 */
+	detail: string;
+}
+/**
+ * Decoration data associated with a model decorations changed event.
+ */
+export interface IModelDecorationsChangedEventDecorationData {
+	/**
+	 * The id of the decoration.
+	 */
+	id:string;
+	/**
+	 * The owner id of the decoration.
+	 */
+	ownerId:number;
+	/**
+	 * The range of the decoration.
+	 */
+	range:IRange;
+	/**
+	 * A flag describing if this is a problem decoration (e.g. warning/error).
+	 */
+	isForValidation:boolean;
+	/**
+	 * The options for this decoration.
+	 */
+	options:IModelDecorationOptions;
+}
+/**
+ * An event describing that model decorations have changed.
+ */
+export interface IModelDecorationsChangedEvent {
+	/**
+	 * A summary with ids of decorations that have changed.
+	 */
+	ids:string[];
+	/**
+	 * Lists of details for added or changed decorations.
+	 */
+	addedOrChangedDecorations:IModelDecorationsChangedEventDecorationData[];
+	/**
+	 * List of ids for removed decorations.
+	 */
+	removedDecorations:string[];
+	/**
+	 * Details regarding old options.
+	 */
+	oldOptions:{[decorationId:string]:IModelDecorationOptions;};
+	/**
+	 * Details regarding old ranges.
+	 */
+	oldRanges:{[decorationId:string]:IRange;};
+}
+/**
+ * An event describing that a range of lines has been tokenized
+ */
+export interface IModelTokensChangedEvent {
+	/**
+	 * The start of the range (inclusive)
+	 */
+	fromLineNumber:number;
+	/**
+	 * The end of the range (inclusive)
+	 */
+	toLineNumber:number;
+}
+
+/**
+ * Describes the reason the cursor has changed its position.
+ */
+export enum CursorChangeReason {
+	/**
+	 * Unknown or not set.
+	 */
+	NotSet = 0,
+	/**
+	 * A `model.setValue()` was called.
+	 */
+	ContentFlush = 1,
+	/**
+	 * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
+	 */
+	RecoverFromMarkers = 2,
+	/**
+	 * There was an explicit user gesture.
+	 */
+	Explicit = 3,
+	/**
+	 * There was a Paste.
+	 */
+	Paste = 4,
+	/**
+	 * There was an Undo.
+	 */
+	Undo = 5,
+	/**
+	 * There was a Redo.
+	 */
+	Redo = 6,
+}
+/**
+ * An event describing that the cursor position has changed.
+ */
+export interface ICursorPositionChangedEvent {
+	/**
+	 * Primary cursor's position.
+	 */
+	position:Position;
+	/**
+	 * Primary cursor's view position
+	 */
+	viewPosition:Position;
+	/**
+	 * Secondary cursors' position.
+	 */
+	secondaryPositions:Position[];
+	/**
+	 * Secondary cursors' view position.
+	 */
+	secondaryViewPositions:Position[];
+	/**
+	 * Reason.
+	 */
+	reason:CursorChangeReason;
+	/**
+	 * Source of the call that caused the event.
+	 */
+	source:string;
+	/**
+	 * Is the primary cursor in the editable range?
+	 */
+	isInEditableRange:boolean;
+}
+/**
+ * An event describing that the cursor selection has changed.
+ */
+export interface ICursorSelectionChangedEvent {
+	/**
+	 * The primary selection.
+	 */
+	selection:Selection;
+	/**
+	 * The primary selection in view coordinates.
+	 */
+	viewSelection:Selection;
+	/**
+	 * The secondary selections.
+	 */
+	secondarySelections:Selection[];
+	/**
+	 * The secondary selections in view coordinates.
+	 */
+	secondaryViewSelections:Selection[];
+	/**
+	 * Source of the call that caused the event.
+	 */
+	source:string;
+	/**
+	 * Reason.
+	 */
+	reason:CursorChangeReason;
+}
+/**
+ * @internal
+ */
+export enum VerticalRevealType {
+	Simple = 0,
+	Center = 1,
+	CenterIfOutsideViewport = 2,
+	Top = 3,
+	Bottom = 4
+}
+/**
+ * An event describing a request to reveal a specific range in the view of the editor.
+ * @internal
+ */
+export interface ICursorRevealRangeEvent {
+	/**
+	 * Range to be reavealed.
+	 */
+	range:Range;
+	/**
+	 * View range to be reavealed.
+	 */
+	viewRange:Range;
+
+	verticalType: VerticalRevealType;
+	/**
+	 * If true: there should be a horizontal & vertical revealing
+	 * If false: there should be just a vertical revealing
+	 */
+	revealHorizontal: boolean;
+	/**
+	 * If true: cursor is revealed if outside viewport
+	 */
+	revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface ICursorScrollRequestEvent {
+	deltaLines: number;
+	revealCursor: boolean;
+}
+
+/**
+ * An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
+ */
+export interface IModelChangedEvent {
+	/**
+	 * The `uri` of the previous model or null.
+	 */
+	oldModelUrl: URI;
+	/**
+	 * The `uri` of the new model or null.
+	 */
+	newModelUrl: URI;
+}
+
+/**
+ * @internal
+ */
+export interface IEditorWhitespace {
+	id:number;
+	afterLineNumber:number;
+	heightInLines:number;
+}
+
+/**
+ * A description for the overview ruler position.
+ */
+export class OverviewRulerPosition {
+	_overviewRulerPositionBrand: void;
+
+	/**
+	 * Width of the overview ruler
+	 */
+	width:number;
+	/**
+	 * Height of the overview ruler
+	 */
+	height:number;
+	/**
+	 * Top position for the overview ruler
+	 */
+	top:number;
+	/**
+	 * Right position for the overview ruler
+	 */
+	right:number;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		width:number;
+		height:number;
+		top:number;
+		right:number;
+	}) {
+		this.width = source.width|0;
+		this.height = source.height|0;
+		this.top = source.top|0;
+		this.right = source.right|0;
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:OverviewRulerPosition): boolean {
+		return (
+			this.width === other.width
+			&& this.height === other.height
+			&& this.top === other.top
+			&& this.right === other.right
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): OverviewRulerPosition {
+		return new OverviewRulerPosition(this);
+	}
+}
+
+/**
+ * The internal layout details of the editor.
+ */
+export class EditorLayoutInfo {
+	_editorLayoutInfoBrand: void;
+
+	/**
+	 * Full editor width.
+	 */
+	width:number;
+	/**
+	 * Full editor height.
+	 */
+	height:number;
+
+	/**
+	 * Left position for the glyph margin.
+	 */
+	glyphMarginLeft:number;
+	/**
+	 * The width of the glyph margin.
+	 */
+	glyphMarginWidth:number;
+	/**
+	 * The height of the glyph margin.
+	 */
+	glyphMarginHeight:number;
+
+	/**
+	 * Left position for the line numbers.
+	 */
+	lineNumbersLeft:number;
+	/**
+	 * The width of the line numbers.
+	 */
+	lineNumbersWidth:number;
+	/**
+	 * The height of the line numbers.
+	 */
+	lineNumbersHeight:number;
+
+	/**
+	 * Left position for the line decorations.
+	 */
+	decorationsLeft:number;
+	/**
+	 * The width of the line decorations.
+	 */
+	decorationsWidth:number;
+	/**
+	 * The height of the line decorations.
+	 */
+	decorationsHeight:number;
+
+	/**
+	 * Left position for the content (actual text)
+	 */
+	contentLeft:number;
+	/**
+	 * The width of the content (actual text)
+	 */
+	contentWidth:number;
+	/**
+	 * The height of the content (actual height)
+	 */
+	contentHeight:number;
+
+	/**
+	 * The width of the vertical scrollbar.
+	 */
+	verticalScrollbarWidth:number;
+	/**
+	 * The height of the horizontal scrollbar.
+	 */
+	horizontalScrollbarHeight:number;
+
+	/**
+	 * The position of the overview ruler.
+	 */
+	overviewRuler:OverviewRulerPosition;
+
+	/**
+	 * @internal
+	 */
+	constructor(source:{
+		width:number;
+		height:number;
+		glyphMarginLeft:number;
+		glyphMarginWidth:number;
+		glyphMarginHeight:number;
+		lineNumbersLeft:number;
+		lineNumbersWidth:number;
+		lineNumbersHeight:number;
+		decorationsLeft:number;
+		decorationsWidth:number;
+		decorationsHeight:number;
+		contentLeft:number;
+		contentWidth:number;
+		contentHeight:number;
+		verticalScrollbarWidth:number;
+		horizontalScrollbarHeight:number;
+		overviewRuler:OverviewRulerPosition;
+	}) {
+		this.width = source.width|0;
+		this.height = source.height|0;
+		this.glyphMarginLeft = source.glyphMarginLeft|0;
+		this.glyphMarginWidth = source.glyphMarginWidth|0;
+		this.glyphMarginHeight = source.glyphMarginHeight|0;
+		this.lineNumbersLeft = source.lineNumbersLeft|0;
+		this.lineNumbersWidth = source.lineNumbersWidth|0;
+		this.lineNumbersHeight = source.lineNumbersHeight|0;
+		this.decorationsLeft = source.decorationsLeft|0;
+		this.decorationsWidth = source.decorationsWidth|0;
+		this.decorationsHeight = source.decorationsHeight|0;
+		this.contentLeft = source.contentLeft|0;
+		this.contentWidth = source.contentWidth|0;
+		this.contentHeight = source.contentHeight|0;
+		this.verticalScrollbarWidth = source.verticalScrollbarWidth|0;
+		this.horizontalScrollbarHeight = source.horizontalScrollbarHeight|0;
+		this.overviewRuler = source.overviewRuler.clone();
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:EditorLayoutInfo): boolean {
+		return (
+			this.width === other.width
+			&& this.height === other.height
+			&& this.glyphMarginLeft === other.glyphMarginLeft
+			&& this.glyphMarginWidth === other.glyphMarginWidth
+			&& this.glyphMarginHeight === other.glyphMarginHeight
+			&& this.lineNumbersLeft === other.lineNumbersLeft
+			&& this.lineNumbersWidth === other.lineNumbersWidth
+			&& this.lineNumbersHeight === other.lineNumbersHeight
+			&& this.decorationsLeft === other.decorationsLeft
+			&& this.decorationsWidth === other.decorationsWidth
+			&& this.decorationsHeight === other.decorationsHeight
+			&& this.contentLeft === other.contentLeft
+			&& this.contentWidth === other.contentWidth
+			&& this.contentHeight === other.contentHeight
+			&& this.verticalScrollbarWidth === other.verticalScrollbarWidth
+			&& this.horizontalScrollbarHeight === other.horizontalScrollbarHeight
+			&& this.overviewRuler.equals(other.overviewRuler)
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): EditorLayoutInfo {
+		return new EditorLayoutInfo(this);
+	}
+}
+
+/**
+ * Options for creating the editor.
+ */
+export interface ICodeEditorWidgetCreationOptions extends IEditorOptions {
+	/**
+	 * The initial model associated with this code editor.
+	 */
+	model?:IModel;
+}
+
+/**
+ * An editor model.
+ */
+export interface IEditorModel {
+}
+/**
+ * An editor view state.
+ */
+export interface IEditorViewState {
+}
+export interface IDimension {
+	width:number;
+	height:number;
+}
+
+/**
+ * A (serializable) state of the cursors.
+ */
+export interface ICursorState {
+	inSelectionMode:boolean;
+	selectionStart:IPosition;
+	position:IPosition;
+}
+/**
+ * A (serializable) state of the view.
+ */
+export interface IViewState {
+	scrollTop: number;
+	scrollTopWithoutViewZones: number;
+	scrollLeft: number;
+}
+/**
+ * A (serializable) state of the code editor.
+ */
+export interface ICodeEditorViewState extends IEditorViewState {
+	cursorState:ICursorState[];
+	viewState:IViewState;
+	contributionsState: {[id:string]:any};
+}
+
+/**
+ * Type of hit element with the mouse in the editor.
+ */
+export enum MouseTargetType {
+	/**
+	 * Mouse is on top of an unknown element.
+	 */
+	UNKNOWN,
+	/**
+	 * Mouse is on top of the textarea used for input.
+	 */
+	TEXTAREA,
+	/**
+	 * Mouse is on top of the glyph margin
+	 */
+	GUTTER_GLYPH_MARGIN,
+	/**
+	 * Mouse is on top of the line numbers
+	 */
+	GUTTER_LINE_NUMBERS,
+	/**
+	 * Mouse is on top of the line decorations
+	 */
+	GUTTER_LINE_DECORATIONS,
+	/**
+	 * Mouse is on top of the whitespace left in the gutter by a view zone.
+	 */
+	GUTTER_VIEW_ZONE,
+	/**
+	 * Mouse is on top of text in the content.
+	 */
+	CONTENT_TEXT,
+	/**
+	 * Mouse is on top of empty space in the content (e.g. after line text or below last line)
+	 */
+	CONTENT_EMPTY,
+	/**
+	 * Mouse is on top of a view zone in the content.
+	 */
+	CONTENT_VIEW_ZONE,
+	/**
+	 * Mouse is on top of a content widget.
+	 */
+	CONTENT_WIDGET,
+	/**
+	 * Mouse is on top of the decorations overview ruler.
+	 */
+	OVERVIEW_RULER,
+	/**
+	 * Mouse is on top of a scrollbar.
+	 */
+	SCROLLBAR,
+	/**
+	 * Mouse is on top of an overlay widget.
+	 */
+	OVERLAY_WIDGET
+}
+
+/**
+ * A model for the diff editor.
+ */
+export interface IDiffEditorModel extends IEditorModel {
+	/**
+	 * Original model.
+	 */
+	original: IModel;
+	/**
+	 * Modified model.
+	 */
+	modified: IModel;
+}
+/**
+ * (Serializable) View state for the diff editor.
+ */
+export interface IDiffEditorViewState extends IEditorViewState {
+	original: ICodeEditorViewState;
+	modified: ICodeEditorViewState;
+}
+/**
+ * A change
+ */
+export interface IChange {
+	originalStartLineNumber:number;
+	originalEndLineNumber:number;
+	modifiedStartLineNumber:number;
+	modifiedEndLineNumber:number;
+}
+/**
+ * A character level change.
+ */
+export interface ICharChange extends IChange {
+	originalStartColumn:number;
+	originalEndColumn:number;
+	modifiedStartColumn:number;
+	modifiedEndColumn:number;
+}
+/**
+ * A line change
+ */
+export interface ILineChange extends IChange {
+	charChanges:ICharChange[];
+}
+/**
+ * Information about a line in the diff editor
+ * @internal
+ */
+export interface IDiffLineInformation {
+	equivalentLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export namespace EditorContextKeys {
+	/**
+	 * A context key that is set when the editor's text has focus (cursor is blinking).
+	 * @internal
+	 */
+	export const TextFocus = new RawContextKey<boolean>('editorTextFocus', false);
+	/**
+	 * A context key that is set when the editor's text or an editor's widget has focus.
+	 * @internal
+	 */
+	export const Focus = new RawContextKey<boolean>('editorFocus', false);
+
+	/**
+	 * A context key that is set when the editor's text is readonly.
+	 * @internal
+	 */
+	export const ReadOnly = new RawContextKey<boolean>('editorReadonly', false);
+
+	/**
+	 * @internal
+	 */
+	export const Writable:ContextKeyExpr = ReadOnly.toNegated();
+
+	/**
+	 * A context key that is set when the editor has a non-collapsed selection.
+	 * @internal
+	 */
+	export const HasNonEmptySelection = new RawContextKey<boolean>('editorHasSelection', false);
+	/**
+	 * @internal
+	 */
+	export const HasOnlyEmptySelection:ContextKeyExpr = HasNonEmptySelection.toNegated();
+
+	/**
+	 * A context key that is set when the editor has multiple selections (multiple cursors).
+	 * @internal
+	 */
+	export const HasMultipleSelections = new RawContextKey<boolean>('editorHasMultipleSelections', false);
+	/**
+	 * @internal
+	 */
+	export const HasSingleSelection:ContextKeyExpr = HasMultipleSelections.toNegated();
+
+	/**
+	 * @internal
+	 */
+	export const TabMovesFocus = new RawContextKey<boolean>('editorTabMovesFocus', false);
+	/**
+	 * @internal
+	 */
+	export const TabDoesNotMoveFocus:ContextKeyExpr = TabMovesFocus.toNegated();
+
+	/**
+	 * A context key that is set to the language associated with the model associated with the editor.
+	 * @internal
+	 */
+	export const LanguageId = new RawContextKey<string>('editorLangId', undefined);
+
+};
+
+
+/**
+ * @internal
+ */
+export namespace ModeContextKeys {
+	/**
+	 * @internal
+	 */
+	export const hasCompletionItemProvider = new RawContextKey<boolean>('editorHasCompletionItemProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasCodeActionsProvider = new RawContextKey<boolean>('editorHasCodeActionsProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasCodeLensProvider = new RawContextKey<boolean>('editorHasCodeLensProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDefinitionProvider = new RawContextKey<boolean>('editorHasDefinitionProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasHoverProvider = new RawContextKey<boolean>('editorHasHoverProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentHighlightProvider = new RawContextKey<boolean>('editorHasDocumentHighlightProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentSymbolProvider = new RawContextKey<boolean>('editorHasDocumentSymbolProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasReferenceProvider = new RawContextKey<boolean>('editorHasReferenceProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasRenameProvider = new RawContextKey<boolean>('editorHasRenameProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasFormattingProvider = new RawContextKey<boolean>('editorHasFormattingProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasSignatureHelpProvider = new RawContextKey<boolean>('editorHasSignatureHelpProvider', undefined);
+}
+
+export class BareFontInfo {
+	_bareFontInfoBrand: void;
+
+	fontFamily: string;
+	fontWeight: string;
+	fontSize: number;
+	lineHeight: number;
+
+	/**
+	 * @internal
+	 */
+	constructor(opts: {
+		fontFamily: string;
+		fontWeight: string;
+		fontSize: number;
+		lineHeight: number;
+	}) {
+		this.fontFamily = String(opts.fontFamily);
+		this.fontWeight = String(opts.fontWeight);
+		this.fontSize = opts.fontSize;
+		this.lineHeight = opts.lineHeight|0;
+	}
+
+	/**
+	 * @internal
+	 */
+	public getId(): string {
+		return this.fontFamily + '-' + this.fontWeight + '-' + this.fontSize + '-' + this.lineHeight + '-';
+	}
+}
+
+export class FontInfo extends BareFontInfo {
+	_editorStylingBrand: void;
+
+	typicalHalfwidthCharacterWidth:number;
+	typicalFullwidthCharacterWidth:number;
+	spaceWidth:number;
+	maxDigitWidth: number;
+
+	/**
+	 * @internal
+	 */
+	constructor(opts:{
+		fontFamily: string;
+		fontWeight: string;
+		fontSize: number;
+		lineHeight: number;
+		typicalHalfwidthCharacterWidth:number;
+		typicalFullwidthCharacterWidth:number;
+		spaceWidth:number;
+		maxDigitWidth: number;
+	}) {
+		super(opts);
+		this.typicalHalfwidthCharacterWidth = opts.typicalHalfwidthCharacterWidth;
+		this.typicalFullwidthCharacterWidth = opts.typicalFullwidthCharacterWidth;
+		this.spaceWidth = opts.spaceWidth;
+		this.maxDigitWidth = opts.maxDigitWidth;
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other:FontInfo): boolean {
+		return (
+			this.fontFamily === other.fontFamily
+			&& this.fontWeight === other.fontWeight
+			&& this.fontSize === other.fontSize
+			&& this.lineHeight === other.lineHeight
+			&& this.typicalHalfwidthCharacterWidth === other.typicalHalfwidthCharacterWidth
+			&& this.typicalFullwidthCharacterWidth === other.typicalFullwidthCharacterWidth
+			&& this.spaceWidth === other.spaceWidth
+			&& this.maxDigitWidth === other.maxDigitWidth
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): FontInfo {
+		return new FontInfo(this);
+	}
+}
+
+/**
+ * @internal
+ */
+export interface IConfiguration {
+	onDidChange: Event<IConfigurationChangedEvent>;
+
+	editor:InternalEditorOptions;
+
+	setMaxLineNumber(maxLineNumber:number): void;
+}
+
+// --- view
+
+/**
+ * @internal
+ */
+export interface IViewEventNames {
+	ModelFlushedEvent: string;
+	LinesDeletedEvent: string;
+	LinesInsertedEvent: string;
+	LineChangedEvent: string;
+	TokensChangedEvent: string;
+	DecorationsChangedEvent: string;
+	CursorPositionChangedEvent: string;
+	CursorSelectionChangedEvent: string;
+	RevealRangeEvent: string;
+	LineMappingChangedEvent: string;
+}
+
+/**
+ * @internal
+ */
+export var ViewEventNames = {
+	ModelFlushedEvent: 'modelFlushedEvent',
+	LinesDeletedEvent: 'linesDeletedEvent',
+	LinesInsertedEvent: 'linesInsertedEvent',
+	LineChangedEvent: 'lineChangedEvent',
+	TokensChangedEvent: 'tokensChangedEvent',
+	DecorationsChangedEvent: 'decorationsChangedEvent',
+	CursorPositionChangedEvent: 'cursorPositionChangedEvent',
+	CursorSelectionChangedEvent: 'cursorSelectionChangedEvent',
+	RevealRangeEvent: 'revealRangeEvent',
+	LineMappingChangedEvent: 'lineMappingChangedEvent',
+	ScrollRequestEvent: 'scrollRequestEvent'
+};
+
+export interface IScrollEvent {
+	scrollTop: number;
+	scrollLeft: number;
+	scrollWidth: number;
+	scrollHeight: number;
+
+	scrollTopChanged: boolean;
+	scrollLeftChanged: boolean;
+	scrollWidthChanged: boolean;
+	scrollHeightChanged: boolean;
+}
+
+export interface INewScrollPosition {
+	scrollLeft?: number;
+	scrollTop?: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLinesDeletedEvent {
+	/**
+	 * At what line the deletion began (inclusive).
+	 */
+	fromLineNumber: number;
+	/**
+	 * At what line the deletion stopped (inclusive).
+	 */
+	toLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLinesInsertedEvent {
+	/**
+	 * Before what line did the insertion begin
+	 */
+	fromLineNumber: number;
+	/**
+	 * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
+	 */
+	toLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLineChangedEvent {
+	/**
+	 * The line that has changed.
+	 */
+	lineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewTokensChangedEvent {
+	/**
+	 * Start line number of range
+	 */
+	fromLineNumber: number;
+	/**
+	 * End line number of range
+	 */
+	toLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewDecorationsChangedEvent {
+	/**
+	 * signals that at least one inline decoration has changed
+	 */
+	inlineDecorationsChanged: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewCursorPositionChangedEvent {
+	/**
+	 * Primary cursor's position.
+	 */
+	position: Position;
+	/**
+	 * Secondary cursors' position.
+	 */
+	secondaryPositions: Position[];
+	/**
+	 * Is the primary cursor in the editable range?
+	 */
+	isInEditableRange: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewCursorSelectionChangedEvent {
+	/**
+	 * The primary selection.
+	 */
+	selection: Selection;
+	/**
+	 * The secondary selections.
+	 */
+	secondarySelections: Selection[];
+}
+
+/**
+ * @internal
+ */
+export interface IViewRevealRangeEvent {
+	/**
+	 * Range to be reavealed.
+	 */
+	range: Range;
+
+	verticalType: VerticalRevealType;
+	/**
+	 * If true: there should be a horizontal & vertical revealing
+	 * If false: there should be just a vertical revealing
+	 */
+	revealHorizontal: boolean;
+	/**
+	 * If true: cursor is revealed if outside viewport
+	 */
+	revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewScrollRequestEvent {
+	deltaLines: number;
+	revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewWhitespaceViewportData {
+	id:number;
+	afterLineNumber:number;
+	verticalOffset:number;
+	height:number;
+}
+
+/**
+ * @internal
+ */
+export class Viewport {
+	_viewportBrand: void;
+
+	top: number;
+	left: number;
+	width: number;
+	height: number;
+
+	constructor(top:number, left:number, width:number, height:number) {
+		this.top = top|0;
+		this.left = left|0;
+		this.width = width|0;
+		this.height = height|0;
+	}
+}
+
+/**
+ * Description of an action contribution
+ */
+export interface IActionDescriptor {
+	/**
+	 * An unique identifier of the contributed action.
+	 */
+	id: string;
+	/**
+	 * A label of the action that will be presented to the user.
+	 */
+	label: string;
+	/**
+	 * An array of keybindings for the action.
+	 */
+	keybindings?: number[];
+	/**
+	 * Control if the action should show up in the context menu and where.
+	 * The context menu of the editor has these default:
+	 *   navigation - The navigation group comes first in all cases.
+	 *   1_modification - This group comes next and contains commands that modify your code.
+	 *   9_cutcopypaste - The last default group with the basic editing commands.
+	 * You can also create your own group.
+	 * Defaults to null (don't show in context menu).
+	 */
+	contextMenuGroupId?: string;
+	/**
+	 * Control the order in the context menu group.
+	 */
+	contextMenuOrder?: number;
+	/**
+	 * The keybinding rule.
+	 */
+	keybindingContext?: string;
+	/**
+	 * Method that will be executed when the action is triggered.
+	 * @param editor The editor instance is passed in as a convinience
+	 */
+	run:(editor:ICommonCodeEditor)=>TPromise<void>;
+}
+
+/**
+ * Data associated with an editor action contribution
+ * @internal
+ */
+export interface IEditorActionDescriptorData {
+	id:string;
+	label:string;
+	alias?:string;
+}
+
+/**
+ * @internal
+ */
+export type IEditorActionContributionCtor = IConstructorSignature2<IEditorActionDescriptorData, ICommonCodeEditor, IEditorContribution>;
+
+/**
+ * @internal
+ */
+export type ICommonEditorContributionCtor = IConstructorSignature1<ICommonCodeEditor, IEditorContribution>;
+
+export interface IEditorAction {
+	id: string;
+	label: string;
+	alias: string;
+	isSupported():boolean;
+	run(): TPromise<void>;
+}
+
+/**
+ * An editor.
+ */
+export interface IEditor {
+	/**
+	 * @deprecated. Please use `onDidChangeModelContent` instead.
+	 * An event emitted when the content of the current model has changed.
+	 * @internal
+	 */
+	onDidChangeModelRawContent(listener: (e:IModelContentChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the content of the current model has changed.
+	 */
+	onDidChangeModelContent(listener: (e:IModelContentChangedEvent2)=>void): IDisposable;
+	/**
+	 * An event emitted when the language of the current model has changed.
+	 */
+	onDidChangeModelMode(listener: (e:IModelModeChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the options of the current model has changed.
+	 */
+	onDidChangeModelOptions(listener: (e:IModelOptionsChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
+	 */
+	onDidChangeConfiguration(listener: (e:IConfigurationChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the cursor position has changed.
+	 */
+	onDidChangeCursorPosition(listener: (e:ICursorPositionChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the cursor selection has changed.
+	 */
+	onDidChangeCursorSelection(listener: (e:ICursorSelectionChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the editor has been disposed.
+	 */
+	onDidDispose(listener: ()=>void): IDisposable;
+
+	/**
+	 * Dispose the editor.
+	 */
+	dispose(): void;
+
+	/**
+	 * Get a unique id for this editor instance.
+	 */
+	getId(): string;
+
+	/**
+	 * Get the editor type. Please see `EditorType`.
+	 * This is to avoid an instanceof check
+	 */
+	getEditorType(): string;
+
+	/**
+	 * Destroy the editor.
+	 * @internal
+	 */
+	destroy(): void;
+
+	/**
+	 * Update the editor's options after the editor has been created.
+	 */
+	updateOptions(newOptions: IEditorOptions): void;
+
+	/**
+	 * Indicates that the editor becomes visible.
+	 * @internal
+	 */
+	onVisible(): void;
+
+	/**
+	 * Indicates that the editor becomes hidden.
+	 * @internal
+	 */
+	onHide(): void;
+
+	/**
+	 * Instructs the editor to remeasure its container. This method should
+	 * be called when the container of the editor gets resized.
+	 */
+	layout(dimension?:IDimension): void;
+
+	/**
+	 * Brings browser focus to the editor text
+	 */
+	focus(): void;
+
+	/**
+	 * Returns true if this editor has keyboard focus (e.g. cursor is blinking).
+	 */
+	isFocused(): boolean;
+
+	/**
+	 * Add a new action to this editor.
+	 */
+	addAction(descriptor:IActionDescriptor): void;
+
+	/**
+	 * Returns all actions associated with this editor.
+	 */
+	getActions(): IEditorAction[];
+
+	/**
+	 * Returns all actions associated with this editor.
+	 */
+	getSupportedActions(): IEditorAction[];
+
+	/**
+	 * Saves current view state of the editor in a serializable object.
+	 */
+	saveViewState(): IEditorViewState;
+
+	/**
+	 * Restores the view state of the editor from a serializable object generated by `saveViewState`.
+	 */
+	restoreViewState(state: IEditorViewState): void;
+
+	/**
+	 * Given a position, returns a column number that takes tab-widths into account.
+	 */
+	getVisibleColumnFromPosition(position:IPosition): number;
+
+	/**
+	 * Returns the primary position of the cursor.
+	 */
+	getPosition(): Position;
+
+	/**
+	 * Set the primary position of the cursor. This will remove any secondary cursors.
+	 * @param position New primary cursor's position
+	 */
+	setPosition(position:IPosition): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line.
+	 */
+	revealLine(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line centered vertically.
+	 */
+	revealLineInCenter(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
+	 */
+	revealLineInCenterIfOutsideViewport(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position.
+	 */
+	revealPosition(position: IPosition): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
+	 */
+	revealPositionInCenter(position: IPosition): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
+	 */
+	revealPositionInCenterIfOutsideViewport(position: IPosition): void;
+
+	/**
+	 * Returns the primary selection of the editor.
+	 */
+	getSelection(): Selection;
+
+	/**
+	 * Returns all the selections of the editor.
+	 */
+	getSelections(): Selection[];
+
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection:IRange): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection:Range): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection:ISelection): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection:Selection): void;
+
+	/**
+	 * Set the selections for all the cursors of the editor.
+	 * Cursors will be removed or added, as necessary.
+	 */
+	setSelections(selections:ISelection[]): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines.
+	 */
+	revealLines(startLineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines centered vertically.
+	 */
+	revealLinesInCenter(lineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
+	 */
+	revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range.
+	 */
+	revealRange(range: IRange): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
+	 */
+	revealRangeInCenter(range: IRange): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
+	 */
+	revealRangeInCenterIfOutsideViewport(range: IRange): void;
+
+
+	/**
+	 * Directly trigger a handler or an editor action.
+	 * @param source The source of the call.
+	 * @param handlerId The id of the handler or the id of a contribution.
+	 * @param payload Extra data to be sent to the handler.
+	 */
+	trigger(source:string, handlerId:string, payload:any): void;
+
+	/**
+	 * Gets the current model attached to this editor.
+	 */
+	getModel(): IEditorModel;
+
+	/**
+	 * Sets the current model attached to this editor.
+	 * If the previous model was created by the editor via the value key in the options
+	 * literal object, it will be destroyed. Otherwise, if the previous model was set
+	 * via setModel, or the model key in the options literal object, the previous model
+	 * will not be destroyed.
+	 * It is safe to call setModel(null) to simply detach the current model from the editor.
+	 */
+	setModel(model:IEditorModel): void;
+
+	/**
+	 * Change the decorations. All decorations added through this changeAccessor
+	 * will get the ownerId of the editor (meaning they will not show up in other
+	 * editors).
+	 * @see IModel.changeDecorations
+	 * @internal
+	 */
+	changeDecorations(callback: (changeAccessor:IModelDecorationsChangeAccessor)=>any): any;
+}
+
+/**
+ * @internal
+ */
+export interface ICodeEditorState {
+	validate(editor:ICommonCodeEditor): boolean;
+}
+
+/**
+ * @internal
+ */
+export enum CodeEditorStateFlag {
+	Value,
+	Selection,
+	Position,
+	Scroll
+}
+
+/**
+ * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
+ */
+export interface IEditorContribution {
+	/**
+	 * Get a unique identifier for this contribution.
+	 */
+	getId(): string;
+	/**
+	 * Dispose this contribution.
+	 */
+	dispose(): void;
+	/**
+	 * Store view state.
+	 */
+	saveViewState?(): any;
+	/**
+	 * Restore view state.
+	 */
+	restoreViewState?(state: any): void;
+}
+
+/**
+ * @internal
+ */
+export interface IThemeDecorationRenderOptions {
+	backgroundColor?: string;
+
+	outline?: string;
+	outlineColor?: string;
+	outlineStyle?: string;
+	outlineWidth?: string;
+
+	border?:string;
+	borderColor?: string;
+	borderRadius?: string;
+	borderSpacing?: string;
+	borderStyle?: string;
+	borderWidth?: string;
+
+	textDecoration?: string;
+	cursor?: string;
+	color?: string;
+	letterSpacing?: string;
+
+	gutterIconPath?: string | URI;
+	gutterIconSize?: string;
+
+	overviewRulerColor?: string;
+
+	before?: IContentDecorationRenderOptions;
+	after?: IContentDecorationRenderOptions;
+}
+
+/**
+ * @internal
+ */
+export interface IContentDecorationRenderOptions {
+	contentText?: string;
+	contentIconPath?: string | URI;
+
+	border?: string;
+	textDecoration?: string;
+	color?: string;
+	backgroundColor?: string;
+
+	margin?: string;
+	width?: string;
+	height?: string;
+}
+
+/**
+ * @internal
+ */
+export interface IDecorationRenderOptions extends IThemeDecorationRenderOptions {
+	isWholeLine?: boolean;
+	overviewRulerLane?: OverviewRulerLane;
+
+	light?: IThemeDecorationRenderOptions;
+	dark?: IThemeDecorationRenderOptions;
+}
+
+/**
+ * @internal
+ */
+export interface IThemeDecorationInstanceRenderOptions {
+	before?: IContentDecorationRenderOptions;
+	after?: IContentDecorationRenderOptions;
+}
+
+/**
+ * @internal
+ */
+export interface IDecorationInstanceRenderOptions extends IThemeDecorationInstanceRenderOptions {
+	light?: IThemeDecorationInstanceRenderOptions;
+	dark?: IThemeDecorationInstanceRenderOptions;
+}
+
+/**
+ * @internal
+ */
+export interface IDecorationOptions {
+	range: IRange;
+	hoverMessage?: MarkedString | MarkedString[];
+	renderOptions? : IDecorationInstanceRenderOptions;
+}
+
+
+export interface ICommonCodeEditor extends IEditor {
+	/**
+	 * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
+	 */
+	onDidChangeModel(listener: (e:IModelChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the decorations of the current model have changed.
+	 */
+	onDidChangeModelDecorations(listener: (e:IModelDecorationsChangedEvent)=>void): IDisposable;
+	/**
+	 * An event emitted when the text inside this editor gained focus (i.e. cursor blinking).
+	 */
+	onDidFocusEditorText(listener: ()=>void): IDisposable;
+	/**
+	 * An event emitted when the text inside this editor lost focus.
+	 */
+	onDidBlurEditorText(listener: ()=>void): IDisposable;
+	/**
+	 * An event emitted when the text inside this editor or an editor widget gained focus.
+	 */
+	onDidFocusEditor(listener: ()=>void): IDisposable;
+	/**
+	 * An event emitted when the text inside this editor or an editor widget lost focus.
+	 */
+	onDidBlurEditor(listener: ()=>void): IDisposable;
+
+	/**
+	 * Returns true if this editor or one of its widgets has keyboard focus.
+	 */
+	hasWidgetFocus(): boolean;
+
+	/**
+	 * Get a contribution of this editor.
+	 * @id Unique identifier of the contribution.
+	 * @return The contribution or null if contribution not found.
+	 */
+	getContribution<T extends IEditorContribution>(id: string): T;
+
+	/**
+	 * @internal
+	 */
+	captureState(...flags:CodeEditorStateFlag[]): ICodeEditorState;
+
+	/**
+	 * Execute `fn` with the editor's services.
+	 * @internal
+	 */
+	invokeWithinContext<T>(fn:(accessor:ServicesAccessor)=>T): T;
+
+	/**
+	 * Type the getModel() of IEditor.
+	 */
+	getModel(): IModel;
+
+	/**
+	 * Returns the current editor's configuration
+	 */
+	getConfiguration(): InternalEditorOptions;
+
+	/**
+	 * Returns the 'raw' editor's configuration, as it was applied over the defaults, but without any computed members.
+	 * @internal
+	 */
+	getRawConfiguration(): IEditorOptions;
+
+	/**
+	 * Get value of the current model attached to this editor.
+	 * @see IModel.getValue
+	 */
+	getValue(options?: { preserveBOM: boolean; lineEnding: string; }): string;
+
+	/**
+	 * Set the value of the current model attached to this editor.
+	 * @see IModel.setValue
+	 */
+	setValue(newValue: string): void;
+
+	/**
+	 * Get the scrollWidth of the editor's viewport.
+	 */
+	getScrollWidth(): number;
+	/**
+	 * Get the scrollLeft of the editor's viewport.
+	 */
+	getScrollLeft(): number;
+
+	/**
+	 * Get the scrollHeight of the editor's viewport.
+	 */
+	getScrollHeight(): number;
+	/**
+	 * Get the scrollTop of the editor's viewport.
+	 */
+	getScrollTop(): number;
+
+	/**
+	 * Change the scrollLeft of the editor's viewport.
+	 */
+	setScrollLeft(newScrollLeft: number): void;
+	/**
+	 * Change the scrollTop of the editor's viewport.
+	 */
+	setScrollTop(newScrollTop: number): void;
+	/**
+	 * Change the scroll position of the editor's viewport.
+	 */
+	setScrollPosition(position: INewScrollPosition): void;
+
+	/**
+	 * Get an action that is a contribution to this editor.
+	 * @id Unique identifier of the contribution.
+	 * @return The action or null if action not found.
+	 */
+	getAction(id: string): IEditorAction;
+
+	/**
+	 * Execute a command on the editor.
+	 * @param source The source of the call.
+	 * @param command The command to execute
+	 */
+	executeCommand(source: string, command: ICommand): void;
+
+	/**
+	 * Push an "undo stop" in the undo-redo stack.
+	 */
+	pushUndoStop(): boolean;
+
+	/**
+	 * Execute a command on the editor.
+	 * @param source The source of the call.
+	 * @param command The command to execute
+	 */
+	executeEdits(source: string, edits: IIdentifiedSingleEditOperation[]): boolean;
+
+	/**
+	 * Execute multiple (concommitent) commands on the editor.
+	 * @param source The source of the call.
+	 * @param command The commands to execute
+	 */
+	executeCommands(source: string, commands: ICommand[]): void;
+
+	/**
+	 * Get all the decorations on a line (filtering out decorations from other editors).
+	 */
+	getLineDecorations(lineNumber: number): IModelDecoration[];
+
+	/**
+	 * All decorations added through this call will get the ownerId of this editor.
+	 * @see IModel.deltaDecorations
+	 */
+	deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
+
+	/**
+	 * @internal
+	 */
+	setDecorations(decorationTypeKey: string, ranges: IDecorationOptions[]): void;
+
+	/**
+	 * @internal
+	 */
+	removeDecorations(decorationTypeKey:string): void;
+
+	/**
+	 * Get the layout info for the editor.
+	 */
+	getLayoutInfo(): EditorLayoutInfo;
+
+	/**
+	 * This listener is notified when a keypress produces a visible character.
+	 * The callback should not do operations on the view, as the view might not be updated to reflect previous typed characters.
+	 * @param character Character to listen to.
+	 * @param callback Function to call when `character` is typed.
+	 * @internal
+	 */
+	addTypingListener(character: string, callback: () => void): IDisposable;
+
+>>>>>>> .their
 }
 
 /**
removed in local
  base   100644 8b131f667fb5b431cb71b18d946dd4d25dc3fdfc src/vs/editor/contrib/contextmenu/browser/contextmenu.ts
  their  100644 1e2d9321168b3c5962b5d90c040f785715acec4c src/vs/editor/contrib/contextmenu/browser/contextmenu.ts
changed in both
  base   100644 755ddd32afd147ce4a7745e4bde8a9853efc4c9e src/vs/monaco.d.ts
  our    100644 76dcf491ff9c1973ad61bf5d423713bb1a3b4e44 src/vs/monaco.d.ts
  their  100644 043b2ee57b52194a9ef6e615613b1ae6c2946a42 src/vs/monaco.d.ts
@@ -810,6 +810,7 @@
 	}
 }
 
+<<<<<<< .our
 declare namespace monaco.editor {
 
 
@@ -4119,6 +4120,3028 @@
 	//compatibility:
 	export type IReadOnlyModel = ITextModel;
 	export type IModel = ITextModel;
+=======
+declare module monaco.editor {
+
+
+    /**
+     * Create a new editor under `domElement`.
+     * `domElement` should be empty (not contain other dom nodes).
+     * The editor will read the size of `domElement`.
+     */
+    export function create(domElement: HTMLElement, options?: IEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneCodeEditor;
+
+    /**
+     * Create a new diff editor under `domElement`.
+     * `domElement` should be empty (not contain other dom nodes).
+     * The editor will read the size of `domElement`.
+     */
+    export function createDiffEditor(domElement: HTMLElement, options?: IDiffEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneDiffEditor;
+
+    export interface IDiffNavigator {
+        canNavigate(): boolean;
+        next(): void;
+        previous(): void;
+        dispose(): void;
+    }
+
+    export interface IDiffNavigatorOptions {
+        followsCaret?: boolean;
+        ignoreCharChanges?: boolean;
+        alwaysRevealFirst?: boolean;
+    }
+
+    export function createDiffNavigator(diffEditor: IStandaloneDiffEditor, opts?: IDiffNavigatorOptions): IDiffNavigator;
+
+    /**
+     * Create a new editor model.
+     * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
+     */
+    export function createModel(value: string, language?: string, uri?: Uri): IModel;
+
+    /**
+     * Change the language for a model.
+     */
+    export function setModelLanguage(model: IModel, language: string): void;
+
+    /**
+     * Set the markers for a model.
+     */
+    export function setModelMarkers(model: IModel, owner: string, markers: IMarkerData[]): void;
+
+    /**
+     * Get the model that has `uri` if it exists.
+     */
+    export function getModel(uri: Uri): IModel;
+
+    /**
+     * Get all the created models.
+     */
+    export function getModels(): IModel[];
+
+    /**
+     * Emitted when a model is created.
+     */
+    export function onDidCreateModel(listener: (model: IModel) => void): IDisposable;
+
+    /**
+     * Emitted right before a model is disposed.
+     */
+    export function onWillDisposeModel(listener: (model: IModel) => void): IDisposable;
+
+    /**
+     * Emitted when a different language is set to a model.
+     */
+    export function onDidChangeModelLanguage(listener: (e: {
+        model: IModel;
+        oldLanguage: string;
+    }) => void): IDisposable;
+
+    /**
+     * Create a new web worker that has model syncing capabilities built in.
+     * Specify an AMD module to load that will `create` an object that will be proxied.
+     */
+    export function createWebWorker<T>(opts: IWebWorkerOptions): MonacoWebWorker<T>;
+
+    /**
+     * Colorize the contents of `domNode` using attribute `data-lang`.
+     */
+    export function colorizeElement(domNode: HTMLElement, options: IColorizerElementOptions): Promise<void>;
+
+    /**
+     * Colorize `text` using language `languageId`.
+     */
+    export function colorize(text: string, languageId: string, options: IColorizerOptions): Promise<string>;
+
+    /**
+     * Colorize a line in a model.
+     */
+    export function colorizeModelLine(model: IModel, lineNumber: number, tabSize?: number): string;
+
+    /**
+     * A web worker that can provide a proxy to an arbitrary file.
+     */
+    export interface MonacoWebWorker<T> {
+        /**
+         * Terminate the web worker, thus invalidating the returned proxy.
+         */
+        dispose(): void;
+        /**
+         * Get a proxy to the arbitrary loaded code.
+         */
+        getProxy(): Promise<T>;
+        /**
+         * Synchronize (send) the models at `resources` to the web worker,
+         * making them available in the monaco.worker.getMirrorModels().
+         */
+        withSyncedResources(resources: Uri[]): Promise<T>;
+    }
+
+    export interface IWebWorkerOptions {
+        /**
+         * The AMD moduleId to load.
+         * It should export a function `create` that should return the exported proxy.
+         */
+        moduleId: string;
+        /**
+         * The data to send over when calling create on the module.
+         */
+        createData?: any;
+        /**
+         * A label to be used to identify the web worker for debugging purposes.
+         */
+        label?: string;
+    }
+
+    /**
+     * The options to create an editor.
+     */
+    export interface IEditorConstructionOptions extends ICodeEditorWidgetCreationOptions {
+        /**
+         * The initial value of the auto created model in the editor.
+         * To not create automatically a model, use `model: null`.
+         */
+        value?: string;
+        /**
+         * The initial language of the auto created model in the editor.
+         * To not create automatically a model, use `model: null`.
+         */
+        language?: string;
+    }
+
+    /**
+     * The options to create a diff editor.
+     */
+    export interface IDiffEditorConstructionOptions extends IDiffEditorOptions {
+    }
+
+    export interface IStandaloneCodeEditor extends ICodeEditor {
+        addCommand(keybinding: number, handler: ICommandHandler, context: string): string;
+        createContextKey<T>(key: string, defaultValue: T): IContextKey<T>;
+        addAction(descriptor: IActionDescriptor): void;
+    }
+
+    export interface IStandaloneDiffEditor extends IDiffEditor {
+        addCommand(keybinding: number, handler: ICommandHandler, context: string): string;
+        createContextKey<T>(key: string, defaultValue: T): IContextKey<T>;
+        addAction(descriptor: IActionDescriptor): void;
+    }
+    export interface ICommandHandler {
+        (...args: any[]): void;
+    }
+
+    export interface IContextKey<T> {
+        set(value: T): void;
+        reset(): void;
+        get(): T;
+    }
+
+    export interface IEditorOverrideServices {
+    }
+
+    /**
+     * A structure defining a problem/warning/etc.
+     */
+    export interface IMarkerData {
+        code?: string;
+        severity: Severity;
+        message: string;
+        source?: string;
+        startLineNumber: number;
+        startColumn: number;
+        endLineNumber: number;
+        endColumn: number;
+    }
+
+    export interface IColorizerOptions {
+        tabSize?: number;
+    }
+
+    export interface IColorizerElementOptions extends IColorizerOptions {
+        theme?: string;
+        mimeType?: string;
+    }
+
+    export enum ScrollbarVisibility {
+        Auto = 1,
+        Hidden = 2,
+        Visible = 3,
+    }
+
+    export interface IAction extends IDisposable {
+        id: string;
+        label: string;
+        tooltip: string;
+        class: string;
+        enabled: boolean;
+        checked: boolean;
+        run(event?: any): Promise<any>;
+    }
+
+    /**
+     * Configuration options for editor scrollbars
+     */
+    export interface IEditorScrollbarOptions {
+        /**
+         * The size of arrows (if displayed).
+         * Defaults to 11.
+         */
+        arrowSize?: number;
+        /**
+         * Render vertical scrollbar.
+         * Accepted values: 'auto', 'visible', 'hidden'.
+         * Defaults to 'auto'.
+         */
+        vertical?: string;
+        /**
+         * Render horizontal scrollbar.
+         * Accepted values: 'auto', 'visible', 'hidden'.
+         * Defaults to 'auto'.
+         */
+        horizontal?: string;
+        /**
+         * Cast horizontal and vertical shadows when the content is scrolled.
+         * Defaults to true.
+         */
+        useShadows?: boolean;
+        /**
+         * Render arrows at the top and bottom of the vertical scrollbar.
+         * Defaults to false.
+         */
+        verticalHasArrows?: boolean;
+        /**
+         * Render arrows at the left and right of the horizontal scrollbar.
+         * Defaults to false.
+         */
+        horizontalHasArrows?: boolean;
+        /**
+         * Listen to mouse wheel events and react to them by scrolling.
+         * Defaults to true.
+         */
+        handleMouseWheel?: boolean;
+        /**
+         * Height in pixels for the horizontal scrollbar.
+         * Defaults to 10 (px).
+         */
+        horizontalScrollbarSize?: number;
+        /**
+         * Width in pixels for the vertical scrollbar.
+         * Defaults to 10 (px).
+         */
+        verticalScrollbarSize?: number;
+        /**
+         * Width in pixels for the vertical slider.
+         * Defaults to `verticalScrollbarSize`.
+         */
+        verticalSliderSize?: number;
+        /**
+         * Height in pixels for the horizontal slider.
+         * Defaults to `horizontalScrollbarSize`.
+         */
+        horizontalSliderSize?: number;
+    }
+
+    /**
+     * Describes how to indent wrapped lines.
+     */
+    export enum WrappingIndent {
+        /**
+         * No indentation => wrapped lines begin at column 1.
+         */
+        None = 0,
+        /**
+         * Same => wrapped lines get the same indentation as the parent.
+         */
+        Same = 1,
+        /**
+         * Indent => wrapped lines get +1 indentation as the parent.
+         */
+        Indent = 2,
+    }
+
+    export type LineNumbersOption = 'on' | 'off' | 'relative' | ((lineNumber: number) => string);
+
+    /**
+     * Configuration options for the editor.
+     */
+    export interface IEditorOptions {
+        /**
+         * Enable experimental screen reader support.
+         * Defaults to `true`.
+         */
+        experimentalScreenReader?: boolean;
+        /**
+         * The aria label for the editor's textarea (when it is focused).
+         */
+        ariaLabel?: string;
+        /**
+         * Render vertical lines at the specified columns.
+         * Defaults to empty array.
+         */
+        rulers?: number[];
+        /**
+         * A string containing the word separators used when doing word navigation.
+         * Defaults to `~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?
+         */
+        wordSeparators?: string;
+        /**
+         * Enable Linux primary clipboard.
+         * Defaults to true.
+         */
+        selectionClipboard?: boolean;
+        /**
+         * Control the rendering of line numbers.
+         * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
+         * Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
+         * Otherwise, line numbers will not be rendered.
+         * Defaults to true.
+         */
+        lineNumbers?: LineNumbersOption;
+        /**
+         * Should the corresponding line be selected when clicking on the line number?
+         * Defaults to true.
+         */
+        selectOnLineNumbers?: boolean;
+        /**
+         * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
+         * Defaults to 5.
+         */
+        lineNumbersMinChars?: number;
+        /**
+         * Enable the rendering of the glyph margin.
+         * Defaults to false.
+         */
+        glyphMargin?: boolean;
+        /**
+         * The width reserved for line decorations (in px).
+         * Line decorations are placed between line numbers and the editor content.
+         * Defaults to 10.
+         */
+        lineDecorationsWidth?: number;
+        /**
+         * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
+         * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
+         * Defaults to 30 (px).
+         */
+        revealHorizontalRightPadding?: number;
+        /**
+         * Render the editor selection with rounded borders.
+         * Defaults to true.
+         */
+        roundedSelection?: boolean;
+        /**
+         * Theme to be used for rendering. Consists of two parts, the UI theme and the syntax theme,
+         * separated by a space.
+         * The current available UI themes are: 'vs' (default), 'vs-dark', 'hc-black'
+         * The syntax themes are contributed. The default is 'default-theme'
+         */
+        theme?: string;
+        /**
+         * Should the editor be read only.
+         * Defaults to false.
+         */
+        readOnly?: boolean;
+        /**
+         * Control the behavior and rendering of the scrollbars.
+         */
+        scrollbar?: IEditorScrollbarOptions;
+        /**
+         * The number of vertical lanes the overview ruler should render.
+         * Defaults to 2.
+         */
+        overviewRulerLanes?: number;
+        /**
+         * Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
+         * Defaults to 'blink'.
+         */
+        cursorBlinking?: string;
+        /**
+         * Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
+         * Defaults to false.
+         */
+        mouseWheelZoom?: boolean;
+        /**
+         * Control the cursor style, either 'block' or 'line'.
+         * Defaults to 'line'.
+         */
+        cursorStyle?: string;
+        /**
+         * Enable font ligatures.
+         * Defaults to false.
+         */
+        fontLigatures?: boolean;
+        /**
+         * Disable the use of `translate3d`.
+         * Defaults to false.
+         */
+        disableTranslate3d?: boolean;
+        /**
+         * Should the cursor be hidden in the overview ruler.
+         * Defaults to false.
+         */
+        hideCursorInOverviewRuler?: boolean;
+        /**
+         * Enable that scrolling can go one screen size after the last line.
+         * Defaults to true.
+         */
+        scrollBeyondLastLine?: boolean;
+        /**
+         * Enable that the editor will install an interval to check if its container dom node size has changed.
+         * Enabling this might have a severe performance impact.
+         * Defaults to false.
+         */
+        automaticLayout?: boolean;
+        /**
+         * Control the wrapping strategy of the editor.
+         * Using -1 means no wrapping whatsoever.
+         * Using 0 means viewport width wrapping (ajusts with the resizing of the editor).
+         * Using a positive number means wrapping after a fixed number of characters.
+         * Defaults to 300.
+         */
+        wrappingColumn?: number;
+        /**
+         * Control the alternate style of viewport wrapping.
+         * When set to true viewport wrapping is used only when the window width is less than the number of columns specified in the wrappingColumn property. Has no effect if wrappingColumn is not a positive number.
+         * Defaults to false.
+         */
+        wordWrap?: boolean;
+        /**
+         * Control indentation of wrapped lines. Can be: 'none', 'same' or 'indent'.
+         * Defaults to 'none'.
+         */
+        wrappingIndent?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced before these characters.
+         * Defaults to '{([+'.
+         */
+        wordWrapBreakBeforeCharacters?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced after these characters.
+         * Defaults to ' \t})]?|&,;'.
+         */
+        wordWrapBreakAfterCharacters?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced after these characters only if no `wordWrapBreakBeforeCharacters` or `wordWrapBreakAfterCharacters` were found.
+         * Defaults to '.'.
+         */
+        wordWrapBreakObtrusiveCharacters?: string;
+        /**
+         * Performance guard: Stop rendering a line after x characters.
+         * Defaults to 10000 if wrappingColumn is -1. Defaults to -1 if wrappingColumn is >= 0.
+         * Use -1 to never stop rendering
+         */
+        stopRenderingLineAfter?: number;
+        /**
+         * Enable hover.
+         * Defaults to true.
+         */
+        hover?: boolean;
+        /**
+         * Enable custom contextmenu.
+         * Defaults to true.
+         */
+        contextmenu?: boolean;
+        /**
+         * A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
+         * Defaults to 1.
+         */
+        mouseWheelScrollSensitivity?: number;
+        /**
+         * Enable quick suggestions (shadow suggestions)
+         * Defaults to true.
+         */
+        quickSuggestions?: boolean;
+        /**
+         * Quick suggestions show delay (in ms)
+         * Defaults to 500 (ms)
+         */
+        quickSuggestionsDelay?: number;
+        /**
+         * Enables parameter hints
+         */
+        parameterHints?: boolean;
+        /**
+         * Render icons in suggestions box.
+         * Defaults to true.
+         */
+        iconsInSuggestions?: boolean;
+        /**
+         * Enable auto closing brackets.
+         * Defaults to true.
+         */
+        autoClosingBrackets?: boolean;
+        /**
+         * Enable format on type.
+         * Defaults to false.
+         */
+        formatOnType?: boolean;
+        /**
+         * Enable the suggestion box to pop-up on trigger characters.
+         * Defaults to true.
+         */
+        suggestOnTriggerCharacters?: boolean;
+        /**
+         * Accept suggestions on ENTER.
+         * Defaults to true.
+         */
+        acceptSuggestionOnEnter?: boolean;
+        /**
+         * Enable snippet suggestions. Default to 'true'.
+         */
+        snippetSuggestions?: 'top' | 'bottom' | 'inline' | 'none';
+        /**
+         * Enable tab completion. Defaults to 'false'
+         */
+        tabCompletion?: boolean;
+        /**
+         * Enable word based suggestions. Defaults to 'true'
+         */
+        wordBasedSuggestions?: boolean;
+        /**
+         * Enable selection highlight.
+         * Defaults to true.
+         */
+        selectionHighlight?: boolean;
+        /**
+         * Show code lens
+         * Defaults to true.
+         */
+        codeLens?: boolean;
+        /**
+         * Enable code folding
+         * Defaults to true.
+         */
+        folding?: boolean;
+        /**
+         * Enable rendering of whitespace.
+         * Defaults to none.
+         */
+        renderWhitespace?: 'none' | 'boundary' | 'all';
+        /**
+         * Enable rendering of control characters.
+         * Defaults to false.
+         */
+        renderControlCharacters?: boolean;
+        /**
+         * Enable rendering of indent guides.
+         * Defaults to false.
+         */
+        renderIndentGuides?: boolean;
+        /**
+         * Enable rendering of current line highlight.
+         * Defaults to true.
+         */
+        renderLineHighlight?: boolean;
+        /**
+         * Inserting and deleting whitespace follows tab stops.
+         */
+        useTabStops?: boolean;
+        /**
+         * The font family
+         */
+        fontFamily?: string;
+        /**
+         * The font weight
+         */
+        fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | 'initial' | 'inherit' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';
+        /**
+         * The font size
+         */
+        fontSize?: number;
+        /**
+         * The line height
+         */
+        lineHeight?: number;
+    }
+
+    /**
+     * Configuration options for the diff editor.
+     */
+    export interface IDiffEditorOptions extends IEditorOptions {
+        /**
+         * Allow the user to resize the diff editor split view.
+         * Defaults to true.
+         */
+        enableSplitViewResizing?: boolean;
+        /**
+         * Render the differences in two side-by-side editors.
+         * Defaults to true.
+         */
+        renderSideBySide?: boolean;
+        /**
+         * Compute the diff by ignoring leading/trailing whitespace
+         * Defaults to true.
+         */
+        ignoreTrimWhitespace?: boolean;
+        /**
+         * Original model should be editable?
+         * Defaults to false.
+         */
+        originalEditable?: boolean;
+    }
+
+    export class InternalEditorScrollbarOptions {
+        _internalEditorScrollbarOptionsBrand: void;
+        arrowSize: number;
+        vertical: ScrollbarVisibility;
+        horizontal: ScrollbarVisibility;
+        useShadows: boolean;
+        verticalHasArrows: boolean;
+        horizontalHasArrows: boolean;
+        handleMouseWheel: boolean;
+        horizontalScrollbarSize: number;
+        horizontalSliderSize: number;
+        verticalScrollbarSize: number;
+        verticalSliderSize: number;
+        mouseWheelScrollSensitivity: number;
+    }
+
+    export class EditorWrappingInfo {
+        _editorWrappingInfoBrand: void;
+        isViewportWrapping: boolean;
+        wrappingColumn: number;
+        wrappingIndent: WrappingIndent;
+        wordWrapBreakBeforeCharacters: string;
+        wordWrapBreakAfterCharacters: string;
+        wordWrapBreakObtrusiveCharacters: string;
+    }
+
+    export class InternalEditorViewOptions {
+        _internalEditorViewOptionsBrand: void;
+        theme: string;
+        canUseTranslate3d: boolean;
+        experimentalScreenReader: boolean;
+        rulers: number[];
+        ariaLabel: string;
+        renderLineNumbers: boolean;
+        renderCustomLineNumbers: (lineNumber: number) => string;
+        renderRelativeLineNumbers: boolean;
+        selectOnLineNumbers: boolean;
+        glyphMargin: boolean;
+        revealHorizontalRightPadding: number;
+        roundedSelection: boolean;
+        overviewRulerLanes: number;
+        cursorBlinking: TextEditorCursorBlinkingStyle;
+        mouseWheelZoom: boolean;
+        cursorStyle: TextEditorCursorStyle;
+        hideCursorInOverviewRuler: boolean;
+        scrollBeyondLastLine: boolean;
+        editorClassName: string;
+        stopRenderingLineAfter: number;
+        renderWhitespace: 'none' | 'boundary' | 'all';
+        renderControlCharacters: boolean;
+        renderIndentGuides: boolean;
+        renderLineHighlight: boolean;
+        scrollbar: InternalEditorScrollbarOptions;
+    }
+
+    export interface IViewConfigurationChangedEvent {
+        theme: boolean;
+        canUseTranslate3d: boolean;
+        experimentalScreenReader: boolean;
+        rulers: boolean;
+        ariaLabel: boolean;
+        renderLineNumbers: boolean;
+        renderCustomLineNumbers: boolean;
+        renderRelativeLineNumbers: boolean;
+        selectOnLineNumbers: boolean;
+        glyphMargin: boolean;
+        revealHorizontalRightPadding: boolean;
+        roundedSelection: boolean;
+        overviewRulerLanes: boolean;
+        cursorBlinking: boolean;
+        mouseWheelZoom: boolean;
+        cursorStyle: boolean;
+        hideCursorInOverviewRuler: boolean;
+        scrollBeyondLastLine: boolean;
+        editorClassName: boolean;
+        stopRenderingLineAfter: boolean;
+        renderWhitespace: boolean;
+        renderControlCharacters: boolean;
+        renderIndentGuides: boolean;
+        renderLineHighlight: boolean;
+        scrollbar: boolean;
+    }
+
+    export class EditorContribOptions {
+        selectionClipboard: boolean;
+        hover: boolean;
+        contextmenu: boolean;
+        quickSuggestions: boolean;
+        quickSuggestionsDelay: number;
+        parameterHints: boolean;
+        iconsInSuggestions: boolean;
+        formatOnType: boolean;
+        suggestOnTriggerCharacters: boolean;
+        acceptSuggestionOnEnter: boolean;
+        snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+        tabCompletion: boolean;
+        wordBasedSuggestions: boolean;
+        selectionHighlight: boolean;
+        codeLens: boolean;
+        folding: boolean;
+    }
+
+    /**
+     * Internal configuration options (transformed or computed) for the editor.
+     */
+    export class InternalEditorOptions {
+        _internalEditorOptionsBrand: void;
+        lineHeight: number;
+        readOnly: boolean;
+        wordSeparators: string;
+        autoClosingBrackets: boolean;
+        useTabStops: boolean;
+        tabFocusMode: boolean;
+        layoutInfo: EditorLayoutInfo;
+        fontInfo: FontInfo;
+        viewInfo: InternalEditorViewOptions;
+        wrappingInfo: EditorWrappingInfo;
+        contribInfo: EditorContribOptions;
+    }
+
+    /**
+     * An event describing that the configuration of the editor has changed.
+     */
+    export interface IConfigurationChangedEvent {
+        lineHeight: boolean;
+        readOnly: boolean;
+        wordSeparators: boolean;
+        autoClosingBrackets: boolean;
+        useTabStops: boolean;
+        tabFocusMode: boolean;
+        layoutInfo: boolean;
+        fontInfo: boolean;
+        viewInfo: IViewConfigurationChangedEvent;
+        wrappingInfo: boolean;
+        contribInfo: boolean;
+    }
+
+    /**
+     * Vertical Lane in the overview ruler of the editor.
+     */
+    export enum OverviewRulerLane {
+        Left = 1,
+        Center = 2,
+        Right = 4,
+        Full = 7,
+    }
+
+    /**
+     * Options for rendering a model decoration in the overview ruler.
+     */
+    export interface IModelDecorationOverviewRulerOptions {
+        /**
+         * CSS color to render in the overview ruler.
+         * e.g.: rgba(100, 100, 100, 0.5)
+         */
+        color: string;
+        /**
+         * CSS color to render in the overview ruler.
+         * e.g.: rgba(100, 100, 100, 0.5)
+         */
+        darkColor: string;
+        /**
+         * The position in the overview ruler.
+         */
+        position: OverviewRulerLane;
+    }
+
+    /**
+     * Options for a model decoration.
+     */
+    export interface IModelDecorationOptions {
+        /**
+         * Customize the growing behaviour of the decoration when typing at the edges of the decoration.
+         * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
+         */
+        stickiness?: TrackedRangeStickiness;
+        /**
+         * CSS class name describing the decoration.
+         */
+        className?: string;
+        /**
+         * Array of MarkedString to render as the decoration message.
+         */
+        hoverMessage?: MarkedString | MarkedString[];
+        /**
+         * Should the decoration expand to encompass a whole line.
+         */
+        isWholeLine?: boolean;
+        /**
+         * @deprecated : Use `overviewRuler` instead
+         */
+        showInOverviewRuler?: string;
+        /**
+         * If set, render this decoration in the overview ruler.
+         */
+        overviewRuler?: IModelDecorationOverviewRulerOptions;
+        /**
+         * If set, the decoration will be rendered in the glyph margin with this CSS class name.
+         */
+        glyphMarginClassName?: string;
+        /**
+         * If set, the decoration will be rendered in the lines decorations with this CSS class name.
+         */
+        linesDecorationsClassName?: string;
+        /**
+         * If set, the decoration will be rendered inline with the text with this CSS class name.
+         * Please use this only for CSS rules that must impact the text. For example, use `className`
+         * to have a background color decoration.
+         */
+        inlineClassName?: string;
+        /**
+         * If set, the decoration will be rendered before the text with this CSS class name.
+         */
+        beforeContentClassName?: string;
+        /**
+         * If set, the decoration will be rendered after the text with this CSS class name.
+         */
+        afterContentClassName?: string;
+    }
+
+    /**
+     * New model decorations.
+     */
+    export interface IModelDeltaDecoration {
+        /**
+         * Range that this decoration covers.
+         */
+        range: IRange;
+        /**
+         * Options associated with this decoration.
+         */
+        options: IModelDecorationOptions;
+    }
+
+    /**
+     * A decoration in the model.
+     */
+    export interface IModelDecoration {
+        /**
+         * Identifier for a decoration.
+         */
+        id: string;
+        /**
+         * Identifier for a decoration's owener.
+         */
+        ownerId: number;
+        /**
+         * Range that this decoration covers.
+         */
+        range: Range;
+        /**
+         * Options associated with this decoration.
+         */
+        options: IModelDecorationOptions;
+    }
+
+    /**
+     * Word inside a model.
+     */
+    export interface IWordAtPosition {
+        /**
+         * The word.
+         */
+        word: string;
+        /**
+         * The column where the word starts.
+         */
+        startColumn: number;
+        /**
+         * The column where the word ends.
+         */
+        endColumn: number;
+    }
+
+    /**
+     * End of line character preference.
+     */
+    export enum EndOfLinePreference {
+        /**
+         * Use the end of line character identified in the text buffer.
+         */
+        TextDefined = 0,
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 1,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 2,
+    }
+
+    /**
+     * The default end of line to use when instantiating models.
+     */
+    export enum DefaultEndOfLine {
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 1,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 2,
+    }
+
+    /**
+     * End of line character preference.
+     */
+    export enum EndOfLineSequence {
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 0,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 1,
+    }
+
+    /**
+     * And identifier for a single edit operation.
+     */
+    export interface ISingleEditOperationIdentifier {
+        /**
+         * Identifier major
+         */
+        major: number;
+        /**
+         * Identifier minor
+         */
+        minor: number;
+    }
+
+    /**
+     * A builder and helper for edit operations for a command.
+     */
+    export interface IEditOperationBuilder {
+        /**
+         * Add a new edit operation (a replace operation).
+         * @param range The range to replace (delete). May be empty to represent a simple insert.
+         * @param text The text to replace with. May be null to represent a simple delete.
+         */
+        addEditOperation(range: Range, text: string): void;
+        /**
+         * Track `selection` when applying edit operations.
+         * A best effort will be made to not grow/expand the selection.
+         * An empty selection will clamp to a nearby character.
+         * @param selection The selection to track.
+         * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
+         *           should clamp to the previous or the next character.
+         * @return A unique identifer.
+         */
+        trackSelection(selection: Selection, trackPreviousOnEmpty?: boolean): string;
+    }
+
+    /**
+     * A helper for computing cursor state after a command.
+     */
+    export interface ICursorStateComputerData {
+        /**
+         * Get the inverse edit operations of the added edit operations.
+         */
+        getInverseEditOperations(): IIdentifiedSingleEditOperation[];
+        /**
+         * Get a previously tracked selection.
+         * @param id The unique identifier returned by `trackSelection`.
+         * @return The selection.
+         */
+        getTrackedSelection(id: string): Selection;
+    }
+
+    /**
+     * A command that modifies text / cursor state on a model.
+     */
+    export interface ICommand {
+        /**
+         * Get the edit operations needed to execute this command.
+         * @param model The model the command will execute on.
+         * @param builder A helper to collect the needed edit operations and to track selections.
+         */
+        getEditOperations(model: ITokenizedModel, builder: IEditOperationBuilder): void;
+        /**
+         * Compute the cursor state after the edit operations were applied.
+         * @param model The model the commad has executed on.
+         * @param helper A helper to get inverse edit operations and to get previously tracked selections.
+         * @return The cursor state after the command executed.
+         */
+        computeCursorState(model: ITokenizedModel, helper: ICursorStateComputerData): Selection;
+    }
+
+    /**
+     * A single edit operation, that acts as a simple replace.
+     * i.e. Replace text at `range` with `text` in model.
+     */
+    export interface ISingleEditOperation {
+        /**
+         * The range to replace. This can be empty to emulate a simple insert.
+         */
+        range: IRange;
+        /**
+         * The text to replace with. This can be null to emulate a simple delete.
+         */
+        text: string;
+        /**
+         * This indicates that this operation has "insert" semantics.
+         * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+         */
+        forceMoveMarkers?: boolean;
+    }
+
+    /**
+     * A single edit operation, that has an identifier.
+     */
+    export interface IIdentifiedSingleEditOperation {
+        /**
+         * An identifier associated with this single edit operation.
+         */
+        identifier: ISingleEditOperationIdentifier;
+        /**
+         * The range to replace. This can be empty to emulate a simple insert.
+         */
+        range: Range;
+        /**
+         * The text to replace with. This can be null to emulate a simple delete.
+         */
+        text: string;
+        /**
+         * This indicates that this operation has "insert" semantics.
+         * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+         */
+        forceMoveMarkers: boolean;
+        /**
+         * This indicates that this operation is inserting automatic whitespace
+         * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
+         */
+        isAutoWhitespaceEdit?: boolean;
+    }
+
+    /**
+     * A callback that can compute the cursor state after applying a series of edit operations.
+     */
+    export interface ICursorStateComputer {
+        /**
+         * A callback that can compute the resulting cursors state after some edit operations have been executed.
+         */
+        (inverseEditOperations: IIdentifiedSingleEditOperation[]): Selection[];
+    }
+
+    export interface ITextModelResolvedOptions {
+        tabSize: number;
+        insertSpaces: boolean;
+        defaultEOL: DefaultEndOfLine;
+        trimAutoWhitespace: boolean;
+    }
+
+    export interface ITextModelUpdateOptions {
+        tabSize?: number;
+        insertSpaces?: boolean;
+        trimAutoWhitespace?: boolean;
+    }
+
+    export interface IModelOptionsChangedEvent {
+        tabSize: boolean;
+        insertSpaces: boolean;
+        trimAutoWhitespace: boolean;
+    }
+
+    /**
+     * A textual read-only model.
+     */
+    export interface ITextModel {
+        getOptions(): ITextModelResolvedOptions;
+        /**
+         * Get the current version id of the model.
+         * Anytime a change happens to the model (even undo/redo),
+         * the version id is incremented.
+         */
+        getVersionId(): number;
+        /**
+         * Get the alternative version id of the model.
+         * This alternative version id is not always incremented,
+         * it will return the same values in the case of undo-redo.
+         */
+        getAlternativeVersionId(): number;
+        /**
+         * Replace the entire text buffer value contained in this model.
+         */
+        setValue(newValue: string): void;
+        /**
+         * Replace the entire text buffer value contained in this model.
+         */
+        setValueFromRawText(newValue: IRawText): void;
+        /**
+         * Get the text stored in this model.
+         * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
+         * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
+         * @return The text.
+         */
+        getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
+        /**
+         * Get the length of the text stored in this model.
+         */
+        getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
+        /**
+         * Get the raw text stored in this model.
+         */
+        toRawText(): IRawText;
+        /**
+         * Check if the raw text stored in this model equals another raw text.
+         */
+        equals(other: IRawText): boolean;
+        /**
+         * Get the text in a certain range.
+         * @param range The range describing what text to get.
+         * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
+         * @return The text.
+         */
+        getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
+        /**
+         * Get the length of text in a certain range.
+         * @param range The range describing what text length to get.
+         * @return The text length.
+         */
+        getValueLengthInRange(range: IRange): number;
+        /**
+         * Get the number of lines in the model.
+         */
+        getLineCount(): number;
+        /**
+         * Get the text for a certain line.
+         */
+        getLineContent(lineNumber: number): string;
+        /**
+         * Get the text for all lines.
+         */
+        getLinesContent(): string[];
+        /**
+         * Get the end of line sequence predominantly used in the text buffer.
+         * @return EOL char sequence (e.g.: '\n' or '\r\n').
+         */
+        getEOL(): string;
+        /**
+         * Change the end of line sequence used in the text buffer.
+         */
+        setEOL(eol: EndOfLineSequence): void;
+        /**
+         * Get the minimum legal column for line at `lineNumber`
+         */
+        getLineMinColumn(lineNumber: number): number;
+        /**
+         * Get the maximum legal column for line at `lineNumber`
+         */
+        getLineMaxColumn(lineNumber: number): number;
+        /**
+         * Returns the column before the first non whitespace character for line at `lineNumber`.
+         * Returns 0 if line is empty or contains only whitespace.
+         */
+        getLineFirstNonWhitespaceColumn(lineNumber: number): number;
+        /**
+         * Returns the column after the last non whitespace character for line at `lineNumber`.
+         * Returns 0 if line is empty or contains only whitespace.
+         */
+        getLineLastNonWhitespaceColumn(lineNumber: number): number;
+        /**
+         * Create a valid position,
+         */
+        validatePosition(position: IPosition): Position;
+        /**
+         * Advances the given position by the given offest (negative offsets are also accepted)
+         * and returns it as a new valid position.
+         *
+         * If the offset and position are such that their combination goes beyond the beginning or
+         * end of the model, throws an exception.
+         *
+         * If the ofsset is such that the new position would be in the middle of a multi-byte
+         * line terminator, throws an exception.
+         */
+        modifyPosition(position: IPosition, offset: number): Position;
+        /**
+         * Create a valid range.
+         */
+        validateRange(range: IRange): Range;
+        /**
+         * Converts the position to a zero-based offset.
+         *
+         * The position will be [adjusted](#TextDocument.validatePosition).
+         *
+         * @param position A position.
+         * @return A valid zero-based offset.
+         */
+        getOffsetAt(position: IPosition): number;
+        /**
+         * Converts a zero-based offset to a position.
+         *
+         * @param offset A zero-based offset.
+         * @return A valid [position](#Position).
+         */
+        getPositionAt(offset: number): Position;
+        /**
+         * Get a range covering the entire model
+         */
+        getFullModelRange(): Range;
+        /**
+         * Returns iff the model was disposed or not.
+         */
+        isDisposed(): boolean;
+        /**
+         * Search the model.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param limitResultCount Limit the number of results
+         * @return The ranges where the matches are. It is empty if not matches have been found.
+         */
+        findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wholeWord: boolean, limitResultCount?: number): Range[];
+        /**
+         * Search the model.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchScope Limit the searching to only search inside this range.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param limitResultCount Limit the number of results
+         * @return The ranges where the matches are. It is empty if no matches have been found.
+         */
+        findMatches(searchString: string, searchScope: IRange, isRegex: boolean, matchCase: boolean, wholeWord: boolean, limitResultCount?: number): Range[];
+        /**
+         * Search the model for the next match. Loops to the beginning of the model if needed.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchStart Start the searching at the specified position.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @return The range where the next match is. It is null if no next match has been found.
+         */
+        findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean): Range;
+        /**
+         * Search the model for the previous match. Loops to the end of the model if needed.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchStart Start the searching at the specified position.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @return The range where the previous match is. It is null if no previous match has been found.
+         */
+        findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean): Range;
+    }
+
+    export interface IReadOnlyModel extends ITextModel {
+        /**
+         * Gets the resource associated with this editor model.
+         */
+        uri: Uri;
+        /**
+         * Get the language associated with this model.
+         */
+        getModeId(): string;
+        /**
+         * Get the word under or besides `position`.
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Might be null.
+         */
+        getWordAtPosition(position: IPosition): IWordAtPosition;
+        /**
+         * Get the word under or besides `position` trimmed to `position`.column
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Will never be null.
+         */
+        getWordUntilPosition(position: IPosition): IWordAtPosition;
+    }
+
+    /**
+     * A model that is tokenized.
+     */
+    export interface ITokenizedModel extends ITextModel {
+        /**
+         * Get the current language mode associated with the model.
+         */
+        getMode(): languages.IMode;
+        /**
+         * Get the language associated with this model.
+         */
+        getModeId(): string;
+        /**
+         * Get the word under or besides `position`.
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Might be null.
+         */
+        getWordAtPosition(position: IPosition): IWordAtPosition;
+        /**
+         * Get the word under or besides `position` trimmed to `position`.column
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Will never be null.
+         */
+        getWordUntilPosition(position: IPosition): IWordAtPosition;
+    }
+
+    /**
+     * A model that can track markers.
+     */
+    export interface ITextModelWithMarkers extends ITextModel {
+    }
+
+    /**
+     * Describes the behaviour of decorations when typing/editing near their edges.
+     */
+    export enum TrackedRangeStickiness {
+        AlwaysGrowsWhenTypingAtEdges = 0,
+        NeverGrowsWhenTypingAtEdges = 1,
+        GrowsOnlyWhenTypingBefore = 2,
+        GrowsOnlyWhenTypingAfter = 3,
+    }
+
+    /**
+     * A model that can track ranges.
+     */
+    export interface ITextModelWithTrackedRanges extends ITextModel {
+    }
+
+    /**
+     * A model that can have decorations.
+     */
+    export interface ITextModelWithDecorations {
+        /**
+         * Perform a minimum ammount of operations, in order to transform the decorations
+         * identified by `oldDecorations` to the decorations described by `newDecorations`
+         * and returns the new identifiers associated with the resulting decorations.
+         *
+         * @param oldDecorations Array containing previous decorations identifiers.
+         * @param newDecorations Array describing what decorations should result after the call.
+         * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+         * @return An array containing the new decorations identifiers.
+         */
+        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
+        /**
+         * Get the options associated with a decoration.
+         * @param id The decoration id.
+         * @return The decoration options or null if the decoration was not found.
+         */
+        getDecorationOptions(id: string): IModelDecorationOptions;
+        /**
+         * Get the range associated with a decoration.
+         * @param id The decoration id.
+         * @return The decoration range or null if the decoration was not found.
+         */
+        getDecorationRange(id: string): Range;
+        /**
+         * Gets all the decorations for the line `lineNumber` as an array.
+         * @param lineNumber The line number
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
+         * @param startLineNumber The start line number
+         * @param endLineNumber The end line number
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
+         * So for now it returns all the decorations on the same line as `range`.
+         * @param range The range to search in
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the decorations as an array.
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         */
+        getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+    }
+
+    /**
+     * An editable text model.
+     */
+    export interface IEditableTextModel extends ITextModelWithMarkers {
+        /**
+         * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
+         */
+        normalizeIndentation(str: string): string;
+        /**
+         * Get what is considered to be one indent (e.g. a tab character or 4 spaces, etc.).
+         */
+        getOneIndent(): string;
+        /**
+         * Change the options of this model.
+         */
+        updateOptions(newOpts: ITextModelUpdateOptions): void;
+        /**
+         * Detect the indentation options for this model from its content.
+         */
+        detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
+        /**
+         * Push a stack element onto the undo stack. This acts as an undo/redo point.
+         * The idea is to use `pushEditOperations` to edit the model and then to
+         * `pushStackElement` to create an undo/redo stop point.
+         */
+        pushStackElement(): void;
+        /**
+         * Push edit operations, basically editing the model. This is the preferred way
+         * of editing the model. The edit operations will land on the undo stack.
+         * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.
+         * @param editOperations The edit operations.
+         * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
+         * @return The cursor state returned by the `cursorStateComputer`.
+         */
+        pushEditOperations(beforeCursorState: Selection[], editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[];
+        /**
+         * Edit the model without adding the edits to the undo stack.
+         * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
+         * @param operations The edit operations.
+         * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.
+         */
+        applyEdits(operations: IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];
+    }
+
+    /**
+     * A model.
+     */
+    export interface IModel extends IReadOnlyModel, IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithTrackedRanges, ITextModelWithDecorations, IEditorModel {
+        /**
+         * An event emitted when the contents of the model have changed.
+         */
+        onDidChangeContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+        /**
+         * An event emitted when decorations of the model have changed.
+         */
+        onDidChangeDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the model options have changed.
+         */
+        onDidChangeOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the language associated with the model has changed.
+         */
+        onDidChangeMode(listener: (e: IModelModeChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted right before disposing the model.
+         */
+        onWillDispose(listener: () => void): IDisposable;
+        /**
+         * A unique identifier associated with this model.
+         */
+        id: string;
+        /**
+         * Destroy this model. This will unbind the model from the mode
+         * and make all necessary clean-up to release this object to the GC.
+         */
+        dispose(): void;
+    }
+
+    /**
+     * An event describing that the current mode associated with a model has changed.
+     */
+    export interface IModelModeChangedEvent {
+        /**
+         * Previous mode
+         */
+        oldMode: languages.IMode;
+        /**
+         * New mode
+         */
+        newMode: languages.IMode;
+    }
+
+    /**
+     * An event describing a change in the text of a model.
+     */
+    export interface IModelContentChangedEvent2 {
+        /**
+         * The range that got replaced.
+         */
+        range: IRange;
+        /**
+         * The length of the range that got replaced.
+         */
+        rangeLength: number;
+        /**
+         * The new text for the range.
+         */
+        text: string;
+        /**
+         * The (new) end-of-line character.
+         */
+        eol: string;
+        /**
+         * The new version id the model has transitioned to.
+         */
+        versionId: number;
+        /**
+         * Flag that indicates that this event was generated while undoing.
+         */
+        isUndoing: boolean;
+        /**
+         * Flag that indicates that this event was generated while redoing.
+         */
+        isRedoing: boolean;
+    }
+
+    /**
+     * The raw text backing a model.
+     */
+    export interface IRawText {
+        /**
+         * The entire text length.
+         */
+        length: number;
+        /**
+         * The text split into lines.
+         */
+        lines: string[];
+        /**
+         * The BOM (leading character sequence of the file).
+         */
+        BOM: string;
+        /**
+         * The end of line sequence.
+         */
+        EOL: string;
+        /**
+         * The options associated with this text.
+         */
+        options: ITextModelResolvedOptions;
+    }
+
+    /**
+     * Decoration data associated with a model decorations changed event.
+     */
+    export interface IModelDecorationsChangedEventDecorationData {
+        /**
+         * The id of the decoration.
+         */
+        id: string;
+        /**
+         * The owner id of the decoration.
+         */
+        ownerId: number;
+        /**
+         * The range of the decoration.
+         */
+        range: IRange;
+        /**
+         * A flag describing if this is a problem decoration (e.g. warning/error).
+         */
+        isForValidation: boolean;
+        /**
+         * The options for this decoration.
+         */
+        options: IModelDecorationOptions;
+    }
+
+    /**
+     * An event describing that model decorations have changed.
+     */
+    export interface IModelDecorationsChangedEvent {
+        /**
+         * A summary with ids of decorations that have changed.
+         */
+        ids: string[];
+        /**
+         * Lists of details for added or changed decorations.
+         */
+        addedOrChangedDecorations: IModelDecorationsChangedEventDecorationData[];
+        /**
+         * List of ids for removed decorations.
+         */
+        removedDecorations: string[];
+        /**
+         * Details regarding old options.
+         */
+        oldOptions: {
+            [decorationId: string]: IModelDecorationOptions;
+        };
+        /**
+         * Details regarding old ranges.
+         */
+        oldRanges: {
+            [decorationId: string]: IRange;
+        };
+    }
+
+    /**
+     * An event describing that a range of lines has been tokenized
+     */
+    export interface IModelTokensChangedEvent {
+        /**
+         * The start of the range (inclusive)
+         */
+        fromLineNumber: number;
+        /**
+         * The end of the range (inclusive)
+         */
+        toLineNumber: number;
+    }
+
+    /**
+     * Describes the reason the cursor has changed its position.
+     */
+    export enum CursorChangeReason {
+        /**
+         * Unknown or not set.
+         */
+        NotSet = 0,
+        /**
+         * A `model.setValue()` was called.
+         */
+        ContentFlush = 1,
+        /**
+         * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
+         */
+        RecoverFromMarkers = 2,
+        /**
+         * There was an explicit user gesture.
+         */
+        Explicit = 3,
+        /**
+         * There was a Paste.
+         */
+        Paste = 4,
+        /**
+         * There was an Undo.
+         */
+        Undo = 5,
+        /**
+         * There was a Redo.
+         */
+        Redo = 6,
+    }
+
+    /**
+     * An event describing that the cursor position has changed.
+     */
+    export interface ICursorPositionChangedEvent {
+        /**
+         * Primary cursor's position.
+         */
+        position: Position;
+        /**
+         * Primary cursor's view position
+         */
+        viewPosition: Position;
+        /**
+         * Secondary cursors' position.
+         */
+        secondaryPositions: Position[];
+        /**
+         * Secondary cursors' view position.
+         */
+        secondaryViewPositions: Position[];
+        /**
+         * Reason.
+         */
+        reason: CursorChangeReason;
+        /**
+         * Source of the call that caused the event.
+         */
+        source: string;
+        /**
+         * Is the primary cursor in the editable range?
+         */
+        isInEditableRange: boolean;
+    }
+
+    /**
+     * An event describing that the cursor selection has changed.
+     */
+    export interface ICursorSelectionChangedEvent {
+        /**
+         * The primary selection.
+         */
+        selection: Selection;
+        /**
+         * The primary selection in view coordinates.
+         */
+        viewSelection: Selection;
+        /**
+         * The secondary selections.
+         */
+        secondarySelections: Selection[];
+        /**
+         * The secondary selections in view coordinates.
+         */
+        secondaryViewSelections: Selection[];
+        /**
+         * Source of the call that caused the event.
+         */
+        source: string;
+        /**
+         * Reason.
+         */
+        reason: CursorChangeReason;
+    }
+
+    /**
+     * An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
+     */
+    export interface IModelChangedEvent {
+        /**
+         * The `uri` of the previous model or null.
+         */
+        oldModelUrl: Uri;
+        /**
+         * The `uri` of the new model or null.
+         */
+        newModelUrl: Uri;
+    }
+
+    /**
+     * A description for the overview ruler position.
+     */
+    export class OverviewRulerPosition {
+        _overviewRulerPositionBrand: void;
+        /**
+         * Width of the overview ruler
+         */
+        width: number;
+        /**
+         * Height of the overview ruler
+         */
+        height: number;
+        /**
+         * Top position for the overview ruler
+         */
+        top: number;
+        /**
+         * Right position for the overview ruler
+         */
+        right: number;
+    }
+
+    /**
+     * The internal layout details of the editor.
+     */
+    export class EditorLayoutInfo {
+        _editorLayoutInfoBrand: void;
+        /**
+         * Full editor width.
+         */
+        width: number;
+        /**
+         * Full editor height.
+         */
+        height: number;
+        /**
+         * Left position for the glyph margin.
+         */
+        glyphMarginLeft: number;
+        /**
+         * The width of the glyph margin.
+         */
+        glyphMarginWidth: number;
+        /**
+         * The height of the glyph margin.
+         */
+        glyphMarginHeight: number;
+        /**
+         * Left position for the line numbers.
+         */
+        lineNumbersLeft: number;
+        /**
+         * The width of the line numbers.
+         */
+        lineNumbersWidth: number;
+        /**
+         * The height of the line numbers.
+         */
+        lineNumbersHeight: number;
+        /**
+         * Left position for the line decorations.
+         */
+        decorationsLeft: number;
+        /**
+         * The width of the line decorations.
+         */
+        decorationsWidth: number;
+        /**
+         * The height of the line decorations.
+         */
+        decorationsHeight: number;
+        /**
+         * Left position for the content (actual text)
+         */
+        contentLeft: number;
+        /**
+         * The width of the content (actual text)
+         */
+        contentWidth: number;
+        /**
+         * The height of the content (actual height)
+         */
+        contentHeight: number;
+        /**
+         * The width of the vertical scrollbar.
+         */
+        verticalScrollbarWidth: number;
+        /**
+         * The height of the horizontal scrollbar.
+         */
+        horizontalScrollbarHeight: number;
+        /**
+         * The position of the overview ruler.
+         */
+        overviewRuler: OverviewRulerPosition;
+    }
+
+    /**
+     * Options for creating the editor.
+     */
+    export interface ICodeEditorWidgetCreationOptions extends IEditorOptions {
+        /**
+         * The initial model associated with this code editor.
+         */
+        model?: IModel;
+    }
+
+    /**
+     * An editor model.
+     */
+    export interface IEditorModel {
+    }
+
+    /**
+     * An editor view state.
+     */
+    export interface IEditorViewState {
+    }
+
+    export interface IDimension {
+        width: number;
+        height: number;
+    }
+
+    /**
+     * A (serializable) state of the cursors.
+     */
+    export interface ICursorState {
+        inSelectionMode: boolean;
+        selectionStart: IPosition;
+        position: IPosition;
+    }
+
+    /**
+     * A (serializable) state of the view.
+     */
+    export interface IViewState {
+        scrollTop: number;
+        scrollTopWithoutViewZones: number;
+        scrollLeft: number;
+    }
+
+    /**
+     * A (serializable) state of the code editor.
+     */
+    export interface ICodeEditorViewState extends IEditorViewState {
+        cursorState: ICursorState[];
+        viewState: IViewState;
+        contributionsState: {
+            [id: string]: any;
+        };
+    }
+
+    /**
+     * Type of hit element with the mouse in the editor.
+     */
+    export enum MouseTargetType {
+        /**
+         * Mouse is on top of an unknown element.
+         */
+        UNKNOWN = 0,
+        /**
+         * Mouse is on top of the textarea used for input.
+         */
+        TEXTAREA = 1,
+        /**
+         * Mouse is on top of the glyph margin
+         */
+        GUTTER_GLYPH_MARGIN = 2,
+        /**
+         * Mouse is on top of the line numbers
+         */
+        GUTTER_LINE_NUMBERS = 3,
+        /**
+         * Mouse is on top of the line decorations
+         */
+        GUTTER_LINE_DECORATIONS = 4,
+        /**
+         * Mouse is on top of the whitespace left in the gutter by a view zone.
+         */
+        GUTTER_VIEW_ZONE = 5,
+        /**
+         * Mouse is on top of text in the content.
+         */
+        CONTENT_TEXT = 6,
+        /**
+         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
+         */
+        CONTENT_EMPTY = 7,
+        /**
+         * Mouse is on top of a view zone in the content.
+         */
+        CONTENT_VIEW_ZONE = 8,
+        /**
+         * Mouse is on top of a content widget.
+         */
+        CONTENT_WIDGET = 9,
+        /**
+         * Mouse is on top of the decorations overview ruler.
+         */
+        OVERVIEW_RULER = 10,
+        /**
+         * Mouse is on top of a scrollbar.
+         */
+        SCROLLBAR = 11,
+        /**
+         * Mouse is on top of an overlay widget.
+         */
+        OVERLAY_WIDGET = 12,
+    }
+
+    /**
+     * A model for the diff editor.
+     */
+    export interface IDiffEditorModel extends IEditorModel {
+        /**
+         * Original model.
+         */
+        original: IModel;
+        /**
+         * Modified model.
+         */
+        modified: IModel;
+    }
+
+    /**
+     * (Serializable) View state for the diff editor.
+     */
+    export interface IDiffEditorViewState extends IEditorViewState {
+        original: ICodeEditorViewState;
+        modified: ICodeEditorViewState;
+    }
+
+    /**
+     * A change
+     */
+    export interface IChange {
+        originalStartLineNumber: number;
+        originalEndLineNumber: number;
+        modifiedStartLineNumber: number;
+        modifiedEndLineNumber: number;
+    }
+
+    /**
+     * A character level change.
+     */
+    export interface ICharChange extends IChange {
+        originalStartColumn: number;
+        originalEndColumn: number;
+        modifiedStartColumn: number;
+        modifiedEndColumn: number;
+    }
+
+    /**
+     * A line change
+     */
+    export interface ILineChange extends IChange {
+        charChanges: ICharChange[];
+    }
+
+    export class BareFontInfo {
+        _bareFontInfoBrand: void;
+        fontFamily: string;
+        fontWeight: string;
+        fontSize: number;
+        lineHeight: number;
+    }
+
+    export class FontInfo extends BareFontInfo {
+        _editorStylingBrand: void;
+        typicalHalfwidthCharacterWidth: number;
+        typicalFullwidthCharacterWidth: number;
+        spaceWidth: number;
+        maxDigitWidth: number;
+    }
+
+    export interface INewScrollPosition {
+        scrollLeft?: number;
+        scrollTop?: number;
+    }
+
+    /**
+     * Description of an action contribution
+     */
+    export interface IActionDescriptor {
+        /**
+         * An unique identifier of the contributed action.
+         */
+        id: string;
+        /**
+         * A label of the action that will be presented to the user.
+         */
+        label: string;
+        /**
+         * An array of keybindings for the action.
+         */
+        keybindings?: number[];
+        /**
+         * Control if the action should show up in the context menu and where.
+         * The context menu of the editor has these default:
+         *   navigation - The navigation group comes first in all cases.
+         *   1_modification - This group comes next and contains commands that modify your code.
+         *   9_cutcopypaste - The last default group with the basic editing commands.
+         * You can also create your own group.
+         * Defaults to null (don't show in context menu).
+         */
+        contextMenuGroupId?: string;
+        /**
+         * Control the order in the context menu group.
+         */
+        contextMenuOrder?: number;
+        /**
+         * The keybinding rule.
+         */
+        keybindingContext?: string;
+        /**
+         * Method that will be executed when the action is triggered.
+         * @param editor The editor instance is passed in as a convinience
+         */
+        run: (editor: ICommonCodeEditor) => Promise<void>;
+    }
+
+    export interface IEditorAction {
+        id: string;
+        label: string;
+        alias: string;
+        isSupported(): boolean;
+        run(): Promise<void>;
+    }
+
+    /**
+     * An editor.
+     */
+    export interface IEditor {
+        /**
+         * An event emitted when the content of the current model has changed.
+         */
+        onDidChangeModelContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+        /**
+         * An event emitted when the language of the current model has changed.
+         */
+        onDidChangeModelMode(listener: (e: IModelModeChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the options of the current model has changed.
+         */
+        onDidChangeModelOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
+         */
+        onDidChangeConfiguration(listener: (e: IConfigurationChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the cursor position has changed.
+         */
+        onDidChangeCursorPosition(listener: (e: ICursorPositionChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the cursor selection has changed.
+         */
+        onDidChangeCursorSelection(listener: (e: ICursorSelectionChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the editor has been disposed.
+         */
+        onDidDispose(listener: () => void): IDisposable;
+        /**
+         * Dispose the editor.
+         */
+        dispose(): void;
+        /**
+         * Get a unique id for this editor instance.
+         */
+        getId(): string;
+        /**
+         * Get the editor type. Please see `EditorType`.
+         * This is to avoid an instanceof check
+         */
+        getEditorType(): string;
+        /**
+         * Update the editor's options after the editor has been created.
+         */
+        updateOptions(newOptions: IEditorOptions): void;
+        /**
+         * Instructs the editor to remeasure its container. This method should
+         * be called when the container of the editor gets resized.
+         */
+        layout(dimension?: IDimension): void;
+        /**
+         * Brings browser focus to the editor text
+         */
+        focus(): void;
+        /**
+         * Returns true if this editor has keyboard focus (e.g. cursor is blinking).
+         */
+        isFocused(): boolean;
+        /**
+         * Add a new action to this editor.
+         */
+        addAction(descriptor: IActionDescriptor): void;
+        /**
+         * Returns all actions associated with this editor.
+         */
+        getActions(): IEditorAction[];
+        /**
+         * Returns all actions associated with this editor.
+         */
+        getSupportedActions(): IEditorAction[];
+        /**
+         * Saves current view state of the editor in a serializable object.
+         */
+        saveViewState(): IEditorViewState;
+        /**
+         * Restores the view state of the editor from a serializable object generated by `saveViewState`.
+         */
+        restoreViewState(state: IEditorViewState): void;
+        /**
+         * Given a position, returns a column number that takes tab-widths into account.
+         */
+        getVisibleColumnFromPosition(position: IPosition): number;
+        /**
+         * Returns the primary position of the cursor.
+         */
+        getPosition(): Position;
+        /**
+         * Set the primary position of the cursor. This will remove any secondary cursors.
+         * @param position New primary cursor's position
+         */
+        setPosition(position: IPosition): void;
+        /**
+         * Scroll vertically as necessary and reveal a line.
+         */
+        revealLine(lineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal a line centered vertically.
+         */
+        revealLineInCenter(lineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
+         */
+        revealLineInCenterIfOutsideViewport(lineNumber: number): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position.
+         */
+        revealPosition(position: IPosition): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
+         */
+        revealPositionInCenter(position: IPosition): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
+         */
+        revealPositionInCenterIfOutsideViewport(position: IPosition): void;
+        /**
+         * Returns the primary selection of the editor.
+         */
+        getSelection(): Selection;
+        /**
+         * Returns all the selections of the editor.
+         */
+        getSelections(): Selection[];
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: IRange): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: Range): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: ISelection): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: Selection): void;
+        /**
+         * Set the selections for all the cursors of the editor.
+         * Cursors will be removed or added, as necessary.
+         */
+        setSelections(selections: ISelection[]): void;
+        /**
+         * Scroll vertically as necessary and reveal lines.
+         */
+        revealLines(startLineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal lines centered vertically.
+         */
+        revealLinesInCenter(lineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
+         */
+        revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range.
+         */
+        revealRange(range: IRange): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
+         */
+        revealRangeInCenter(range: IRange): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
+         */
+        revealRangeInCenterIfOutsideViewport(range: IRange): void;
+        /**
+         * Directly trigger a handler or an editor action.
+         * @param source The source of the call.
+         * @param handlerId The id of the handler or the id of a contribution.
+         * @param payload Extra data to be sent to the handler.
+         */
+        trigger(source: string, handlerId: string, payload: any): void;
+        /**
+         * Gets the current model attached to this editor.
+         */
+        getModel(): IEditorModel;
+        /**
+         * Sets the current model attached to this editor.
+         * If the previous model was created by the editor via the value key in the options
+         * literal object, it will be destroyed. Otherwise, if the previous model was set
+         * via setModel, or the model key in the options literal object, the previous model
+         * will not be destroyed.
+         * It is safe to call setModel(null) to simply detach the current model from the editor.
+         */
+        setModel(model: IEditorModel): void;
+    }
+
+    /**
+     * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
+     */
+    export interface IEditorContribution {
+        /**
+         * Get a unique identifier for this contribution.
+         */
+        getId(): string;
+        /**
+         * Dispose this contribution.
+         */
+        dispose(): void;
+        /**
+         * Store view state.
+         */
+        saveViewState?(): any;
+        /**
+         * Restore view state.
+         */
+        restoreViewState?(state: any): void;
+    }
+
+    export interface ICommonCodeEditor extends IEditor {
+        /**
+         * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
+         */
+        onDidChangeModel(listener: (e: IModelChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the decorations of the current model have changed.
+         */
+        onDidChangeModelDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor gained focus (i.e. cursor blinking).
+         */
+        onDidFocusEditorText(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor lost focus.
+         */
+        onDidBlurEditorText(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor or an editor widget gained focus.
+         */
+        onDidFocusEditor(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor or an editor widget lost focus.
+         */
+        onDidBlurEditor(listener: () => void): IDisposable;
+        /**
+         * Returns true if this editor or one of its widgets has keyboard focus.
+         */
+        hasWidgetFocus(): boolean;
+        /**
+         * Get a contribution of this editor.
+         * @id Unique identifier of the contribution.
+         * @return The contribution or null if contribution not found.
+         */
+        getContribution<T extends IEditorContribution>(id: string): T;
+        /**
+         * Type the getModel() of IEditor.
+         */
+        getModel(): IModel;
+        /**
+         * Returns the current editor's configuration
+         */
+        getConfiguration(): InternalEditorOptions;
+        /**
+         * Get value of the current model attached to this editor.
+         * @see IModel.getValue
+         */
+        getValue(options?: {
+            preserveBOM: boolean;
+            lineEnding: string;
+        }): string;
+        /**
+         * Set the value of the current model attached to this editor.
+         * @see IModel.setValue
+         */
+        setValue(newValue: string): void;
+        /**
+         * Get the scrollWidth of the editor's viewport.
+         */
+        getScrollWidth(): number;
+        /**
+         * Get the scrollLeft of the editor's viewport.
+         */
+        getScrollLeft(): number;
+        /**
+         * Get the scrollHeight of the editor's viewport.
+         */
+        getScrollHeight(): number;
+        /**
+         * Get the scrollTop of the editor's viewport.
+         */
+        getScrollTop(): number;
+        /**
+         * Change the scrollLeft of the editor's viewport.
+         */
+        setScrollLeft(newScrollLeft: number): void;
+        /**
+         * Change the scrollTop of the editor's viewport.
+         */
+        setScrollTop(newScrollTop: number): void;
+        /**
+         * Change the scroll position of the editor's viewport.
+         */
+        setScrollPosition(position: INewScrollPosition): void;
+        /**
+         * Get an action that is a contribution to this editor.
+         * @id Unique identifier of the contribution.
+         * @return The action or null if action not found.
+         */
+        getAction(id: string): IEditorAction;
+        /**
+         * Execute a command on the editor.
+         * @param source The source of the call.
+         * @param command The command to execute
+         */
+        executeCommand(source: string, command: ICommand): void;
+        /**
+         * Push an "undo stop" in the undo-redo stack.
+         */
+        pushUndoStop(): boolean;
+        /**
+         * Execute a command on the editor.
+         * @param source The source of the call.
+         * @param command The command to execute
+         */
+        executeEdits(source: string, edits: IIdentifiedSingleEditOperation[]): boolean;
+        /**
+         * Execute multiple (concommitent) commands on the editor.
+         * @param source The source of the call.
+         * @param command The commands to execute
+         */
+        executeCommands(source: string, commands: ICommand[]): void;
+        /**
+         * Get all the decorations on a line (filtering out decorations from other editors).
+         */
+        getLineDecorations(lineNumber: number): IModelDecoration[];
+        /**
+         * All decorations added through this call will get the ownerId of this editor.
+         * @see IModel.deltaDecorations
+         */
+        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
+        /**
+         * Get the layout info for the editor.
+         */
+        getLayoutInfo(): EditorLayoutInfo;
+    }
+
+    export interface ICommonDiffEditor extends IEditor {
+        /**
+         * An event emitted when the diff information computed by this diff editor has been updated.
+         */
+        onDidUpdateDiff(listener: () => void): IDisposable;
+        /**
+         * Type the getModel() of IEditor.
+         */
+        getModel(): IDiffEditorModel;
+        /**
+         * Get the `original` editor.
+         */
+        getOriginalEditor(): ICommonCodeEditor;
+        /**
+         * Get the `modified` editor.
+         */
+        getModifiedEditor(): ICommonCodeEditor;
+        /**
+         * Get the computed diff information.
+         */
+        getLineChanges(): ILineChange[];
+        /**
+         * @see ICodeEditor.getValue
+         */
+        getValue(options?: {
+            preserveBOM: boolean;
+            lineEnding: string;
+        }): string;
+    }
+
+    /**
+     * The type of the `IEditor`.
+     */
+    export var EditorType: {
+        ICodeEditor: string;
+        IDiffEditor: string;
+    };
+
+    /**
+     * Positions in the view for cursor move command.
+     */
+    export const CursorMovePosition: {
+        Left: string;
+        Right: string;
+        Up: string;
+        Down: string;
+        WrappedLineStart: string;
+        WrappedLineFirstNonWhitespaceCharacter: string;
+        WrappedLineColumnCenter: string;
+        WrappedLineEnd: string;
+        WrappedLineLastNonWhitespaceCharacter: string;
+        ViewPortTop: string;
+        ViewPortCenter: string;
+        ViewPortBottom: string;
+        ViewPortIfOutside: string;
+    };
+
+    /**
+     * Units for Cursor move 'by' argument
+     */
+    export const CursorMoveByUnit: {
+        Line: string;
+        WrappedLine: string;
+        Character: string;
+        HalfLine: string;
+    };
+
+    /**
+     * Arguments for Cursor move command
+     */
+    export interface CursorMoveArguments {
+        to: string;
+        select?: boolean;
+        by?: string;
+        value?: number;
+    }
+
+    /**
+     * Directions in the view for editor scroll command.
+     */
+    export const EditorScrollDirection: {
+        Up: string;
+        Down: string;
+    };
+
+    /**
+     * Units for editor scroll 'by' argument
+     */
+    export const EditorScrollByUnit: {
+        Line: string;
+        WrappedLine: string;
+        Page: string;
+        HalfPage: string;
+    };
+
+    /**
+     * Arguments for editor scroll command
+     */
+    export interface EditorScrollArguments {
+        to: string;
+        by?: string;
+        value?: number;
+        revealCursor?: boolean;
+    }
+
+    /**
+     * Arguments for reveal line command
+     */
+    export interface RevealLineArguments {
+        lineNumber?: number;
+        at?: string;
+    }
+
+    /**
+     * Values for reveal line 'at' argument
+     */
+    export const RevealLineAtArgument: {
+        Top: string;
+        Center: string;
+        Bottom: string;
+    };
+
+    /**
+     * Built-in commands.
+     */
+    export var Handler: {
+        ExecuteCommand: string;
+        ExecuteCommands: string;
+        CursorLeft: string;
+        CursorLeftSelect: string;
+        CursorWordLeft: string;
+        CursorWordStartLeft: string;
+        CursorWordEndLeft: string;
+        CursorWordLeftSelect: string;
+        CursorWordStartLeftSelect: string;
+        CursorWordEndLeftSelect: string;
+        CursorRight: string;
+        CursorRightSelect: string;
+        CursorWordRight: string;
+        CursorWordStartRight: string;
+        CursorWordEndRight: string;
+        CursorWordRightSelect: string;
+        CursorWordStartRightSelect: string;
+        CursorWordEndRightSelect: string;
+        CursorUp: string;
+        CursorUpSelect: string;
+        CursorDown: string;
+        CursorDownSelect: string;
+        CursorPageUp: string;
+        CursorPageUpSelect: string;
+        CursorPageDown: string;
+        CursorPageDownSelect: string;
+        CursorHome: string;
+        CursorHomeSelect: string;
+        CursorEnd: string;
+        CursorEndSelect: string;
+        ExpandLineSelection: string;
+        CursorTop: string;
+        CursorTopSelect: string;
+        CursorBottom: string;
+        CursorBottomSelect: string;
+        CursorColumnSelectLeft: string;
+        CursorColumnSelectRight: string;
+        CursorColumnSelectUp: string;
+        CursorColumnSelectPageUp: string;
+        CursorColumnSelectDown: string;
+        CursorColumnSelectPageDown: string;
+        CursorMove: string;
+        AddCursorDown: string;
+        AddCursorUp: string;
+        CursorUndo: string;
+        MoveTo: string;
+        MoveToSelect: string;
+        ColumnSelect: string;
+        CreateCursor: string;
+        LastCursorMoveToSelect: string;
+        JumpToBracket: string;
+        Type: string;
+        ReplacePreviousChar: string;
+        CompositionStart: string;
+        CompositionEnd: string;
+        Paste: string;
+        Tab: string;
+        Indent: string;
+        Outdent: string;
+        DeleteLeft: string;
+        DeleteRight: string;
+        DeleteWordLeft: string;
+        DeleteWordStartLeft: string;
+        DeleteWordEndLeft: string;
+        DeleteWordRight: string;
+        DeleteWordStartRight: string;
+        DeleteWordEndRight: string;
+        DeleteAllLeft: string;
+        DeleteAllRight: string;
+        RemoveSecondaryCursors: string;
+        CancelSelection: string;
+        Cut: string;
+        Undo: string;
+        Redo: string;
+        WordSelect: string;
+        WordSelectDrag: string;
+        LastCursorWordSelect: string;
+        LineSelect: string;
+        LineSelectDrag: string;
+        LastCursorLineSelect: string;
+        LastCursorLineSelectDrag: string;
+        LineInsertBefore: string;
+        LineInsertAfter: string;
+        LineBreakInsert: string;
+        SelectAll: string;
+        EditorScroll: string;
+        ScrollLineUp: string;
+        ScrollLineDown: string;
+        ScrollPageUp: string;
+        ScrollPageDown: string;
+        RevealLine: string;
+    };
+
+    /**
+     * The style in which the editor's cursor should be rendered.
+     */
+    export enum TextEditorCursorStyle {
+        /**
+         * As a vertical line (sitting between two characters).
+         */
+        Line = 1,
+        /**
+         * As a block (sitting on top of a character).
+         */
+        Block = 2,
+        /**
+         * As a horizontal line (sitting under a character).
+         */
+        Underline = 3,
+    }
+
+    /**
+     * The kind of animation in which the editor's cursor should be rendered.
+     */
+    export enum TextEditorCursorBlinkingStyle {
+        /**
+         * Hidden
+         */
+        Hidden = 0,
+        /**
+         * Blinking
+         */
+        Blink = 1,
+        /**
+         * Blinking with smooth fading
+         */
+        Smooth = 2,
+        /**
+         * Blinking with prolonged filled state and smooth fading
+         */
+        Phase = 3,
+        /**
+         * Expand collapse animation on the y axis
+         */
+        Expand = 4,
+        /**
+         * No-Blinking
+         */
+        Solid = 5,
+    }
+
+    /**
+     * A view zone is a full horizontal rectangle that 'pushes' text down.
+     * The editor reserves space for view zones when rendering.
+     */
+    export interface IViewZone {
+        /**
+         * The line number after which this zone should appear.
+         * Use 0 to place a view zone before the first line number.
+         */
+        afterLineNumber: number;
+        /**
+         * The column after which this zone should appear.
+         * If not set, the maxLineColumn of `afterLineNumber` will be used.
+         */
+        afterColumn?: number;
+        /**
+         * Suppress mouse down events.
+         * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
+         * Defaults to false
+         */
+        suppressMouseDown?: boolean;
+        /**
+         * The height in lines of the view zone.
+         * If specified, `heightInPx` will be used instead of this.
+         * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
+         */
+        heightInLines?: number;
+        /**
+         * The height in px of the view zone.
+         * If this is set, the editor will give preference to it rather than `heightInLines` above.
+         * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
+         */
+        heightInPx?: number;
+        /**
+         * The dom node of the view zone
+         */
+        domNode: HTMLElement;
+        /**
+         * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
+         */
+        onDomNodeTop?: (top: number) => void;
+        /**
+         * Callback which gives the height in pixels of the view zone.
+         */
+        onComputedHeight?: (height: number) => void;
+    }
+
+    /**
+     * An accessor that allows for zones to be added or removed.
+     */
+    export interface IViewZoneChangeAccessor {
+        /**
+         * Create a new view zone.
+         * @param zone Zone to create
+         * @return A unique identifier to the view zone.
+         */
+        addZone(zone: IViewZone): number;
+        /**
+         * Remove a zone
+         * @param id A unique identifier to the view zone, as returned by the `addZone` call.
+         */
+        removeZone(id: number): void;
+        /**
+         * Change a zone's position.
+         * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.
+         */
+        layoutZone(id: number): void;
+    }
+
+    /**
+     * A positioning preference for rendering content widgets.
+     */
+    export enum ContentWidgetPositionPreference {
+        /**
+         * Place the content widget exactly at a position
+         */
+        EXACT = 0,
+        /**
+         * Place the content widget above a position
+         */
+        ABOVE = 1,
+        /**
+         * Place the content widget below a position
+         */
+        BELOW = 2,
+    }
+
+    /**
+     * A position for rendering content widgets.
+     */
+    export interface IContentWidgetPosition {
+        /**
+         * Desired position for the content widget.
+         * `preference` will also affect the placement.
+         */
+        position: IPosition;
+        /**
+         * Placement preference for position, in order of preference.
+         */
+        preference: ContentWidgetPositionPreference[];
+    }
+
+    /**
+     * A content widget renders inline with the text and can be easily placed 'near' an editor position.
+     */
+    export interface IContentWidget {
+        /**
+         * Render this content widget in a location where it could overflow the editor's view dom node.
+         */
+        allowEditorOverflow?: boolean;
+        suppressMouseDown?: boolean;
+        /**
+         * Get a unique identifier of the content widget.
+         */
+        getId(): string;
+        /**
+         * Get the dom node of the content widget.
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Get the placement of the content widget.
+         * If null is returned, the content widget will be placed off screen.
+         */
+        getPosition(): IContentWidgetPosition;
+    }
+
+    /**
+     * A positioning preference for rendering overlay widgets.
+     */
+    export enum OverlayWidgetPositionPreference {
+        /**
+         * Position the overlay widget in the top right corner
+         */
+        TOP_RIGHT_CORNER = 0,
+        /**
+         * Position the overlay widget in the bottom right corner
+         */
+        BOTTOM_RIGHT_CORNER = 1,
+        /**
+         * Position the overlay widget in the top center
+         */
+        TOP_CENTER = 2,
+    }
+
+    /**
+     * A position for rendering overlay widgets.
+     */
+    export interface IOverlayWidgetPosition {
+        /**
+         * The position preference for the overlay widget.
+         */
+        preference: OverlayWidgetPositionPreference;
+    }
+
+    /**
+     * An overlay widgets renders on top of the text.
+     */
+    export interface IOverlayWidget {
+        /**
+         * Get a unique identifier of the overlay widget.
+         */
+        getId(): string;
+        /**
+         * Get the dom node of the overlay widget.
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Get the placement of the overlay widget.
+         * If null is returned, the overlay widget is responsible to place itself.
+         */
+        getPosition(): IOverlayWidgetPosition;
+    }
+
+    /**
+     * Target hit with the mouse in the editor.
+     */
+    export interface IMouseTarget {
+        /**
+         * The target element
+         */
+        element: Element;
+        /**
+         * The target type
+         */
+        type: MouseTargetType;
+        /**
+         * The 'approximate' editor position
+         */
+        position: Position;
+        /**
+         * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
+         */
+        mouseColumn: number;
+        /**
+         * The 'approximate' editor range
+         */
+        range: Range;
+        /**
+         * Some extra detail.
+         */
+        detail: any;
+    }
+
+    /**
+     * A mouse event originating from the editor.
+     */
+    export interface IEditorMouseEvent {
+        event: IMouseEvent;
+        target: IMouseTarget;
+    }
+
+    /**
+     * A rich code editor.
+     */
+    export interface ICodeEditor extends ICommonCodeEditor {
+        /**
+         * An event emitted on a "mouseup".
+         */
+        onMouseUp(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mousedown".
+         */
+        onMouseDown(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "contextmenu".
+         */
+        onContextMenu(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mousemove".
+         */
+        onMouseMove(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mouseleave".
+         */
+        onMouseLeave(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "keyup".
+         */
+        onKeyUp(listener: (e: IKeyboardEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "keydown".
+         */
+        onKeyDown(listener: (e: IKeyboardEvent) => void): IDisposable;
+        /**
+         * An event emitted when the layout of the editor has changed.
+         */
+        onDidLayoutChange(listener: (e: EditorLayoutInfo) => void): IDisposable;
+        /**
+         * An event emitted when the scroll in the editor has changed.
+         */
+        onDidScrollChange(listener: (e: IScrollEvent) => void): IDisposable;
+        /**
+         * Returns the editor's dom node
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
+         */
+        addContentWidget(widget: IContentWidget): void;
+        /**
+         * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
+         * and update appropiately.
+         */
+        layoutContentWidget(widget: IContentWidget): void;
+        /**
+         * Remove a content widget.
+         */
+        removeContentWidget(widget: IContentWidget): void;
+        /**
+         * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
+         */
+        addOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
+         * and update appropiately.
+         */
+        layoutOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Remove an overlay widget.
+         */
+        removeOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Change the view zones. View zones are lost when a new model is attached to the editor.
+         */
+        changeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;
+        /**
+         * Returns the range that is currently centered in the view port.
+         */
+        getCenteredRangeInViewport(): Range;
+        /**
+         * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
+         * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).
+         * Use this method with caution.
+         */
+        getOffsetForColumn(lineNumber: number, column: number): number;
+        /**
+         * Force an editor render now.
+         */
+        render(): void;
+        /**
+         * Get the vertical position (top offset) for the line w.r.t. to the first line.
+         */
+        getTopForLineNumber(lineNumber: number): number;
+        /**
+         * Get the vertical position (top offset) for the position w.r.t. to the first line.
+         */
+        getTopForPosition(lineNumber: number, column: number): number;
+        /**
+         * Get the visible position for `position`.
+         * The result position takes scrolling into account and is relative to the top left corner of the editor.
+         * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.
+         * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
+         * Warning: the results of this method are innacurate for positions that are outside the current editor viewport.
+         */
+        getScrolledVisiblePosition(position: IPosition): {
+            top: number;
+            left: number;
+            height: number;
+        };
+        /**
+         * Apply the same font settings as the editor to `target`.
+         */
+        applyFontInfo(target: HTMLElement): void;
+    }
+
+    /**
+     * A rich diff editor.
+     */
+    export interface IDiffEditor extends ICommonDiffEditor {
+        /**
+         * @see ICodeEditor.getDomNode
+         */
+        getDomNode(): HTMLElement;
+    }
+>>>>>>> .their
 }
 
 declare namespace monaco.languages {
changed in both
  base   100644 24d687abceeef24008de69fa787695f0872374e4 src/vs/workbench/parts/terminal/electron-browser/media/xterm.css
  our    100644 be7a3c7a177dbbf6fff0d2b41b43d082ccb7d36f src/vs/workbench/parts/terminal/electron-browser/media/xterm.css
  their  100644 5e80769f86f104a2c523c241d9c06f3e292769ff src/vs/workbench/parts/terminal/electron-browser/media/xterm.css
@@ -66,7 +66,12 @@
 	 * HACK: to fix IE's blinking cursor
 	 * Move textarea out of the screen to the far left, so that the cursor is not visible.
 	 */
+<<<<<<< .our
 	position: absolute;
+=======
+	left: -9999em;
+	top: -9999em;
+>>>>>>> .their
 	opacity: 0;
 	left: -9999em;
 	top: 0;
