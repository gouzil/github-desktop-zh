changed in both
  base   100644 26f602cd68402408bbd17f8fd8b2773351f3c2d4 build/monaco/package.json
  our    100644 efd919085b2ffc82da8d810c609a9ed217bffb35 build/monaco/package.json
  their  100644 b24844587aa8ff68b4c1d2087bf5dd7c0751dae8 build/monaco/package.json
@@ -1,7 +1,11 @@
 {
   "name": "monaco-editor-core",
   "private": true,
+<<<<<<< .our
   "version": "0.14.3",
+=======
+  "version": "0.8.2",
+>>>>>>> .their
   "description": "A browser based code editor",
   "author": "Microsoft Corporation",
   "license": "MIT",
removed in local
  base   100644 e143c6e913aa59f3dffdb2c1a36cec4ffa2d1a1f src/vs/editor/browser/standalone/standaloneCodeEditor.ts
  their  100644 22c073693df2fc8c21766b778ee6f09413977ff4 src/vs/editor/browser/standalone/standaloneCodeEditor.ts
removed in local
  base   100644 4aa0f1e3fa4c2c7a08b29ae6692acddb09b39f2b src/vs/editor/browser/standalone/standaloneEditor.ts
  their  100644 ab7ba575a68acb6f1fa1484c4155b44a17862935 src/vs/editor/browser/standalone/standaloneEditor.ts
changed in both
  base   100644 6bd46d9b65e950f516d0422219f99f6b612a5646 src/vs/editor/browser/widget/codeEditorWidget.ts
  our    100644 6f588e16445e2740e0f36730ce132f1ff91e44d8 src/vs/editor/browser/widget/codeEditorWidget.ts
  their  100644 aba15b72080e1713f949a4899b7458cda390d98d src/vs/editor/browser/widget/codeEditorWidget.ts
@@ -6,7 +6,14 @@
 
 import 'vs/css!./media/editor';
 import 'vs/css!./media/tokens';
+<<<<<<< .our
 import * as nls from 'vs/nls';
+=======
+import { onUnexpectedError } from 'vs/base/common/errors';
+import { TPromise } from 'vs/base/common/winjs.base';
+import { IEventEmitter } from 'vs/base/common/eventEmitter';
+import * as browser from 'vs/base/browser/browser';
+>>>>>>> .their
 import * as dom from 'vs/base/browser/dom';
 import { onUnexpectedError } from 'vs/base/common/errors';
 import { Event, Emitter } from 'vs/base/common/event';
@@ -279,7 +286,11 @@
 			}
 		}
 
+<<<<<<< .our
 		EditorExtensionsRegistry.getEditorActions().forEach((action) => {
+=======
+		this._getActions().forEach((action) => {
+>>>>>>> .their
 			const internalAction = new InternalEditorAction(
 				action.id,
 				action.label,
changed in both
  base   100644 585718b20ed02bc6a3e3dd712990b606784eec75 src/vs/editor/browser/widget/diffEditorWidget.ts
  our    100644 481a3d62bd4fdb0fd496aaf0795bb98c9b1d946b src/vs/editor/browser/widget/diffEditorWidget.ts
  their  100644 9f41b1b89994ec05f8048ef5d5dba55d87b6d918 src/vs/editor/browser/widget/diffEditorWidget.ts
@@ -24,6 +24,7 @@
 import * as editorBrowser from 'vs/editor/browser/editorBrowser';
 import { CodeEditorWidget } from 'vs/editor/browser/widget/codeEditorWidget';
 import { Configuration } from 'vs/editor/browser/config/configuration';
+<<<<<<< .our
 import { Position, IPosition } from 'vs/editor/common/core/position';
 import { Selection, ISelection } from 'vs/editor/common/core/selection';
 import { InlineDecoration, InlineDecorationType, ViewLineRenderingData } from 'vs/editor/common/viewModel/viewModel';
@@ -42,6 +43,11 @@
 import { IModelDeltaDecoration, IModelDecorationsChangeAccessor, ITextModel } from 'vs/editor/common/model';
 import { INotificationService } from 'vs/platform/notification/common/notification';
 import { StableEditorScrollState } from 'vs/editor/browser/core/editorState';
+=======
+import { Position } from 'vs/editor/common/core/position';
+import { Selection } from 'vs/editor/common/core/selection';
+import { InlineDecoration } from 'vs/editor/common/viewModel/viewModel';
+>>>>>>> .their
 
 interface IEditorDiffDecorations {
 	decorations: IModelDeltaDecoration[];
@@ -400,6 +406,7 @@
 		this._containerDomElement.appendChild(this._modifiedDomNode);
 	}
 
+<<<<<<< .our
 	private _createLeftHandSideEditor(options: editorOptions.IDiffEditorOptions, instantiationService: IInstantiationService): void {
 		this.originalEditor = this._createInnerEditor(instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable));
 
@@ -470,6 +477,26 @@
 
 	protected _createInnerEditor(instantiationService: IInstantiationService, container: HTMLElement, options: editorOptions.IEditorOptions): CodeEditorWidget {
 		return instantiationService.createInstance(CodeEditorWidget, container, options, {});
+=======
+	private _createLeftHandSideEditor(options: editorCommon.IDiffEditorOptions, instantiationService: IInstantiationService): void {
+		this.originalEditor = this._createInnerEditor(instantiationService, this._originalDomNode, this._adjustOptionsForLeftHandSide(options, this._originalIsEditable));
+		this._toDispose.push(this.originalEditor.addBulkListener2((events) => this._onOriginalEditorEvents(events)));
+		this._toDispose.push(this.addEmitter2(this.originalEditor));
+	}
+
+	private _createRightHandSideEditor(options: editorCommon.IDiffEditorOptions, instantiationService: IInstantiationService): void {
+		this.modifiedEditor = this._createInnerEditor(instantiationService, this._modifiedDomNode, this._adjustOptionsForRightHandSide(options));
+		this._toDispose.push(this.modifiedEditor.addBulkListener2((events) => this._onModifiedEditorEvents(events)));
+		this._toDispose.push(this.addEmitter2(this.modifiedEditor));
+	}
+
+	protected _createInnerEditor(instantiationService: IInstantiationService, container: HTMLElement, options: editorCommon.IEditorOptions): CodeEditor {
+		return instantiationService.createInstance(CodeEditor, container, options);
+	}
+
+	public destroy(): void {
+		this.dispose();
+>>>>>>> .their
 	}
 
 	public dispose(): void {
@@ -716,12 +743,17 @@
 		this.modifiedEditor.revealRangeInCenter(range, scrollType);
 	}
 
+<<<<<<< .our
 	public revealRangeInCenterIfOutsideViewport(range: IRange, scrollType: editorCommon.ScrollType = editorCommon.ScrollType.Smooth): void {
 		this.modifiedEditor.revealRangeInCenterIfOutsideViewport(range, scrollType);
 	}
 
 	public revealRangeAtTop(range: IRange, scrollType: editorCommon.ScrollType = editorCommon.ScrollType.Smooth): void {
 		this.modifiedEditor.revealRangeAtTop(range, scrollType);
+=======
+	public getActions(): editorCommon.IEditorAction[] {
+		return this.modifiedEditor.getActions();
+>>>>>>> .their
 	}
 
 	public getSupportedActions(): editorCommon.IEditorAction[] {
@@ -952,7 +984,11 @@
 		return clonedOptions;
 	}
 
+<<<<<<< .our
 	private _adjustOptionsForLeftHandSide(options: editorOptions.IDiffEditorOptions, isEditable: boolean): editorOptions.IEditorOptions {
+=======
+	private _adjustOptionsForLeftHandSide(options: editorCommon.IDiffEditorOptions, isEditable: boolean): editorCommon.IEditorOptions {
+>>>>>>> .their
 		let result = this._adjustOptionsForSubEditor(options);
 		result.readOnly = !isEditable;
 		result.overviewRulerLanes = 1;
@@ -960,7 +996,11 @@
 		return result;
 	}
 
+<<<<<<< .our
 	private _adjustOptionsForRightHandSide(options: editorOptions.IDiffEditorOptions): editorOptions.IEditorOptions {
+=======
+	private _adjustOptionsForRightHandSide(options: editorCommon.IDiffEditorOptions): editorCommon.IEditorOptions {
+>>>>>>> .their
 		let result = this._adjustOptionsForSubEditor(options);
 		result.revealHorizontalRightPadding = editorOptions.EDITOR_DEFAULTS.viewInfo.revealHorizontalRightPadding + DiffEditorWidget.ENTIRE_DIFF_OVERVIEW_WIDTH;
 		result.scrollbar.verticalHasArrows = false;
removed in local
  base   100644 d4dec32f0ff442708d4f0405fc60338b6707772b src/vs/editor/common/commonCodeEditor.ts
  their  100644 cd57a84f5f07c427bd2e3ff0032fd8e47e519780 src/vs/editor/common/commonCodeEditor.ts
changed in both
  base   100644 0d5b7e24f8de071d307abed95224e42ed488a469 src/vs/editor/common/editorAction.ts
  our    100644 575781a80d996448822550e4c904633ef4da23fe src/vs/editor/common/editorAction.ts
  their  100644 b507e50a5cd313273fd40c6af360952bab6021a0 src/vs/editor/common/editorAction.ts
@@ -43,7 +43,11 @@
 			return TPromise.as(void 0);
 		}
 
+<<<<<<< .our
 		const r = this._run();
 		return r ? r : TPromise.as(void 0);
+=======
+		return TPromise.as(this._run());
+>>>>>>> .their
 	}
 }
changed in both
  base   100644 441a48481099f749878415cf37751d792450ccda src/vs/editor/common/editorCommon.ts
  our    100644 8ab17ce6977a746a13f9fe016e9948d332de49ca src/vs/editor/common/editorCommon.ts
  their  100644 1238d01366e29caebe5df1d480f764b68db9506b src/vs/editor/common/editorCommon.ts
@@ -94,7 +94,3003 @@
  */
 export interface IDiffEditorModel {
 	/**
+<<<<<<< .our
 	 * Original model.
+=======
+	 * @internal
+	 */
+	public clone(): EditorWrappingInfo {
+		return new EditorWrappingInfo(this);
+	}
+}
+
+export class InternalEditorViewOptions {
+	readonly _internalEditorViewOptionsBrand: void;
+
+	readonly theme: string;
+	readonly canUseTranslate3d: boolean;
+	readonly disableMonospaceOptimizations: boolean;
+	readonly experimentalScreenReader: boolean;
+	readonly rulers: number[];
+	readonly ariaLabel: string;
+	readonly renderLineNumbers: boolean;
+	readonly renderCustomLineNumbers: (lineNumber: number) => string;
+	readonly renderRelativeLineNumbers: boolean;
+	readonly selectOnLineNumbers: boolean;
+	readonly glyphMargin: boolean;
+	readonly revealHorizontalRightPadding: number;
+	readonly roundedSelection: boolean;
+	readonly overviewRulerLanes: number;
+	readonly cursorBlinking: TextEditorCursorBlinkingStyle;
+	readonly mouseWheelZoom: boolean;
+	readonly cursorStyle: TextEditorCursorStyle;
+	readonly hideCursorInOverviewRuler: boolean;
+	readonly scrollBeyondLastLine: boolean;
+	readonly editorClassName: string;
+	readonly stopRenderingLineAfter: number;
+	readonly renderWhitespace: 'none' | 'boundary' | 'all';
+	readonly renderControlCharacters: boolean;
+	readonly renderIndentGuides: boolean;
+	readonly renderLineHighlight: 'none' | 'gutter' | 'line' | 'all';
+	readonly scrollbar: InternalEditorScrollbarOptions;
+	readonly fixedOverflowWidgets: boolean;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		theme: string;
+		canUseTranslate3d: boolean;
+		disableMonospaceOptimizations: boolean;
+		experimentalScreenReader: boolean;
+		rulers: number[];
+		ariaLabel: string;
+		renderLineNumbers: boolean;
+		renderCustomLineNumbers: (lineNumber: number) => string;
+		renderRelativeLineNumbers: boolean;
+		selectOnLineNumbers: boolean;
+		glyphMargin: boolean;
+		revealHorizontalRightPadding: number;
+		roundedSelection: boolean;
+		overviewRulerLanes: number;
+		cursorBlinking: TextEditorCursorBlinkingStyle;
+		mouseWheelZoom: boolean;
+		cursorStyle: TextEditorCursorStyle;
+		hideCursorInOverviewRuler: boolean;
+		scrollBeyondLastLine: boolean;
+		editorClassName: string;
+		stopRenderingLineAfter: number;
+		renderWhitespace: 'none' | 'boundary' | 'all';
+		renderControlCharacters: boolean;
+		renderIndentGuides: boolean;
+		renderLineHighlight: 'none' | 'gutter' | 'line' | 'all';
+		scrollbar: InternalEditorScrollbarOptions;
+		fixedOverflowWidgets: boolean;
+	}) {
+		this.theme = String(source.theme);
+		this.canUseTranslate3d = Boolean(source.canUseTranslate3d);
+		this.disableMonospaceOptimizations = Boolean(source.disableMonospaceOptimizations);
+		this.experimentalScreenReader = Boolean(source.experimentalScreenReader);
+		this.rulers = InternalEditorViewOptions._toSortedIntegerArray(source.rulers);
+		this.ariaLabel = String(source.ariaLabel);
+		this.renderLineNumbers = Boolean(source.renderLineNumbers);
+		this.renderCustomLineNumbers = source.renderCustomLineNumbers;
+		this.renderRelativeLineNumbers = Boolean(source.renderRelativeLineNumbers);
+		this.selectOnLineNumbers = Boolean(source.selectOnLineNumbers);
+		this.glyphMargin = Boolean(source.glyphMargin);
+		this.revealHorizontalRightPadding = source.revealHorizontalRightPadding | 0;
+		this.roundedSelection = Boolean(source.roundedSelection);
+		this.overviewRulerLanes = source.overviewRulerLanes | 0;
+		this.cursorBlinking = source.cursorBlinking | 0;
+		this.mouseWheelZoom = Boolean(source.mouseWheelZoom);
+		this.cursorStyle = source.cursorStyle | 0;
+		this.hideCursorInOverviewRuler = Boolean(source.hideCursorInOverviewRuler);
+		this.scrollBeyondLastLine = Boolean(source.scrollBeyondLastLine);
+		this.editorClassName = String(source.editorClassName);
+		this.stopRenderingLineAfter = source.stopRenderingLineAfter | 0;
+		this.renderWhitespace = source.renderWhitespace;
+		this.renderControlCharacters = Boolean(source.renderControlCharacters);
+		this.renderIndentGuides = Boolean(source.renderIndentGuides);
+		this.renderLineHighlight = source.renderLineHighlight;
+		this.scrollbar = source.scrollbar.clone();
+		this.fixedOverflowWidgets = Boolean(source.fixedOverflowWidgets);
+	}
+
+	private static _toSortedIntegerArray(source: any): number[] {
+		if (!Array.isArray(source)) {
+			return [];
+		}
+		let arrSource = <any[]>source;
+		let result = arrSource.map(el => {
+			let r = parseInt(el, 10);
+			if (isNaN(r)) {
+				return 0;
+			}
+			return r;
+		});
+		result.sort();
+		return result;
+	}
+
+	private static _numberArraysEqual(a: number[], b: number[]): boolean {
+		if (a.length !== b.length) {
+			return false;
+		}
+		for (let i = 0; i < a.length; i++) {
+			if (a[i] !== b[i]) {
+				return false;
+			}
+		}
+		return true;
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: InternalEditorViewOptions): boolean {
+		return (
+			this.theme === other.theme
+			&& this.canUseTranslate3d === other.canUseTranslate3d
+			&& this.disableMonospaceOptimizations === other.disableMonospaceOptimizations
+			&& this.experimentalScreenReader === other.experimentalScreenReader
+			&& InternalEditorViewOptions._numberArraysEqual(this.rulers, other.rulers)
+			&& this.ariaLabel === other.ariaLabel
+			&& this.renderLineNumbers === other.renderLineNumbers
+			&& this.renderCustomLineNumbers === other.renderCustomLineNumbers
+			&& this.renderRelativeLineNumbers === other.renderRelativeLineNumbers
+			&& this.selectOnLineNumbers === other.selectOnLineNumbers
+			&& this.glyphMargin === other.glyphMargin
+			&& this.revealHorizontalRightPadding === other.revealHorizontalRightPadding
+			&& this.roundedSelection === other.roundedSelection
+			&& this.overviewRulerLanes === other.overviewRulerLanes
+			&& this.cursorBlinking === other.cursorBlinking
+			&& this.mouseWheelZoom === other.mouseWheelZoom
+			&& this.cursorStyle === other.cursorStyle
+			&& this.hideCursorInOverviewRuler === other.hideCursorInOverviewRuler
+			&& this.scrollBeyondLastLine === other.scrollBeyondLastLine
+			&& this.editorClassName === other.editorClassName
+			&& this.stopRenderingLineAfter === other.stopRenderingLineAfter
+			&& this.renderWhitespace === other.renderWhitespace
+			&& this.renderControlCharacters === other.renderControlCharacters
+			&& this.renderIndentGuides === other.renderIndentGuides
+			&& this.renderLineHighlight === other.renderLineHighlight
+			&& this.scrollbar.equals(other.scrollbar)
+			&& this.fixedOverflowWidgets === other.fixedOverflowWidgets
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public createChangeEvent(newOpts: InternalEditorViewOptions): IViewConfigurationChangedEvent {
+		return {
+			theme: this.theme !== newOpts.theme,
+			canUseTranslate3d: this.canUseTranslate3d !== newOpts.canUseTranslate3d,
+			disableMonospaceOptimizations: this.disableMonospaceOptimizations !== newOpts.disableMonospaceOptimizations,
+			experimentalScreenReader: this.experimentalScreenReader !== newOpts.experimentalScreenReader,
+			rulers: (!InternalEditorViewOptions._numberArraysEqual(this.rulers, newOpts.rulers)),
+			ariaLabel: this.ariaLabel !== newOpts.ariaLabel,
+			renderLineNumbers: this.renderLineNumbers !== newOpts.renderLineNumbers,
+			renderCustomLineNumbers: this.renderCustomLineNumbers !== newOpts.renderCustomLineNumbers,
+			renderRelativeLineNumbers: this.renderRelativeLineNumbers !== newOpts.renderRelativeLineNumbers,
+			selectOnLineNumbers: this.selectOnLineNumbers !== newOpts.selectOnLineNumbers,
+			glyphMargin: this.glyphMargin !== newOpts.glyphMargin,
+			revealHorizontalRightPadding: this.revealHorizontalRightPadding !== newOpts.revealHorizontalRightPadding,
+			roundedSelection: this.roundedSelection !== newOpts.roundedSelection,
+			overviewRulerLanes: this.overviewRulerLanes !== newOpts.overviewRulerLanes,
+			cursorBlinking: this.cursorBlinking !== newOpts.cursorBlinking,
+			mouseWheelZoom: this.mouseWheelZoom !== newOpts.mouseWheelZoom,
+			cursorStyle: this.cursorStyle !== newOpts.cursorStyle,
+			hideCursorInOverviewRuler: this.hideCursorInOverviewRuler !== newOpts.hideCursorInOverviewRuler,
+			scrollBeyondLastLine: this.scrollBeyondLastLine !== newOpts.scrollBeyondLastLine,
+			editorClassName: this.editorClassName !== newOpts.editorClassName,
+			stopRenderingLineAfter: this.stopRenderingLineAfter !== newOpts.stopRenderingLineAfter,
+			renderWhitespace: this.renderWhitespace !== newOpts.renderWhitespace,
+			renderControlCharacters: this.renderControlCharacters !== newOpts.renderControlCharacters,
+			renderIndentGuides: this.renderIndentGuides !== newOpts.renderIndentGuides,
+			renderLineHighlight: this.renderLineHighlight !== newOpts.renderLineHighlight,
+			scrollbar: (!this.scrollbar.equals(newOpts.scrollbar)),
+			fixedOverflowWidgets: this.fixedOverflowWidgets !== newOpts.fixedOverflowWidgets
+		};
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): InternalEditorViewOptions {
+		return new InternalEditorViewOptions(this);
+	}
+}
+
+export interface IViewConfigurationChangedEvent {
+	readonly theme: boolean;
+	readonly canUseTranslate3d: boolean;
+	readonly disableMonospaceOptimizations: boolean;
+	readonly experimentalScreenReader: boolean;
+	readonly rulers: boolean;
+	readonly ariaLabel: boolean;
+	readonly renderLineNumbers: boolean;
+	readonly renderCustomLineNumbers: boolean;
+	readonly renderRelativeLineNumbers: boolean;
+	readonly selectOnLineNumbers: boolean;
+	readonly glyphMargin: boolean;
+	readonly revealHorizontalRightPadding: boolean;
+	readonly roundedSelection: boolean;
+	readonly overviewRulerLanes: boolean;
+	readonly cursorBlinking: boolean;
+	readonly mouseWheelZoom: boolean;
+	readonly cursorStyle: boolean;
+	readonly hideCursorInOverviewRuler: boolean;
+	readonly scrollBeyondLastLine: boolean;
+	readonly editorClassName: boolean;
+	readonly stopRenderingLineAfter: boolean;
+	readonly renderWhitespace: boolean;
+	readonly renderControlCharacters: boolean;
+	readonly renderIndentGuides: boolean;
+	readonly renderLineHighlight: boolean;
+	readonly scrollbar: boolean;
+	readonly fixedOverflowWidgets: boolean;
+}
+
+export class EditorContribOptions {
+	readonly selectionClipboard: boolean;
+	readonly hover: boolean;
+	readonly contextmenu: boolean;
+	readonly quickSuggestions: boolean;
+	readonly quickSuggestionsDelay: number;
+	readonly parameterHints: boolean;
+	readonly iconsInSuggestions: boolean;
+	readonly formatOnType: boolean;
+	readonly formatOnPaste: boolean;
+	readonly suggestOnTriggerCharacters: boolean;
+	readonly acceptSuggestionOnEnter: boolean;
+	readonly acceptSuggestionOnCommitCharacter: boolean;
+	readonly snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+	readonly emptySelectionClipboard: boolean;
+	readonly tabCompletion: boolean;
+	readonly wordBasedSuggestions: boolean;
+	readonly suggestFontSize: number;
+	readonly suggestLineHeight: number;
+	readonly selectionHighlight: boolean;
+	readonly codeLens: boolean;
+	readonly folding: boolean;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		selectionClipboard: boolean;
+		hover: boolean;
+		contextmenu: boolean;
+		quickSuggestions: boolean;
+		quickSuggestionsDelay: number;
+		parameterHints: boolean;
+		iconsInSuggestions: boolean;
+		formatOnType: boolean;
+		formatOnPaste: boolean;
+		suggestOnTriggerCharacters: boolean;
+		acceptSuggestionOnEnter: boolean;
+		acceptSuggestionOnCommitCharacter: boolean;
+		snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+		emptySelectionClipboard: boolean;
+		tabCompletion: boolean;
+		wordBasedSuggestions: boolean;
+		suggestFontSize: number;
+		suggestLineHeight: number;
+		selectionHighlight: boolean;
+		codeLens: boolean;
+		folding: boolean;
+	}) {
+		this.selectionClipboard = Boolean(source.selectionClipboard);
+		this.hover = Boolean(source.hover);
+		this.contextmenu = Boolean(source.contextmenu);
+		this.quickSuggestions = Boolean(source.quickSuggestions);
+		this.quickSuggestionsDelay = source.quickSuggestionsDelay || 0;
+		this.parameterHints = Boolean(source.parameterHints);
+		this.iconsInSuggestions = Boolean(source.iconsInSuggestions);
+		this.formatOnType = Boolean(source.formatOnType);
+		this.formatOnPaste = Boolean(source.formatOnPaste);
+		this.suggestOnTriggerCharacters = Boolean(source.suggestOnTriggerCharacters);
+		this.acceptSuggestionOnEnter = Boolean(source.acceptSuggestionOnEnter);
+		this.acceptSuggestionOnCommitCharacter = Boolean(source.acceptSuggestionOnCommitCharacter);
+		this.snippetSuggestions = source.snippetSuggestions;
+		this.emptySelectionClipboard = source.emptySelectionClipboard;
+		this.tabCompletion = source.tabCompletion;
+		this.wordBasedSuggestions = source.wordBasedSuggestions;
+		this.suggestFontSize = source.suggestFontSize;
+		this.suggestLineHeight = source.suggestLineHeight;
+		this.selectionHighlight = Boolean(source.selectionHighlight);
+		this.codeLens = Boolean(source.codeLens);
+		this.folding = Boolean(source.folding);
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: EditorContribOptions): boolean {
+		return (
+			this.selectionClipboard === other.selectionClipboard
+			&& this.hover === other.hover
+			&& this.contextmenu === other.contextmenu
+			&& this.quickSuggestions === other.quickSuggestions
+			&& this.quickSuggestionsDelay === other.quickSuggestionsDelay
+			&& this.parameterHints === other.parameterHints
+			&& this.iconsInSuggestions === other.iconsInSuggestions
+			&& this.formatOnType === other.formatOnType
+			&& this.formatOnPaste === other.formatOnPaste
+			&& this.suggestOnTriggerCharacters === other.suggestOnTriggerCharacters
+			&& this.acceptSuggestionOnEnter === other.acceptSuggestionOnEnter
+			&& this.acceptSuggestionOnCommitCharacter === other.acceptSuggestionOnCommitCharacter
+			&& this.snippetSuggestions === other.snippetSuggestions
+			&& this.emptySelectionClipboard === other.emptySelectionClipboard
+			&& this.tabCompletion === other.tabCompletion
+			&& this.wordBasedSuggestions === other.wordBasedSuggestions
+			&& this.suggestFontSize === other.suggestFontSize
+			&& this.suggestLineHeight === other.suggestLineHeight
+			&& this.selectionHighlight === other.selectionHighlight
+			&& this.codeLens === other.codeLens
+			&& this.folding === other.folding
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): EditorContribOptions {
+		return new EditorContribOptions(this);
+	}
+}
+
+/**
+ * Internal configuration options (transformed or computed) for the editor.
+ */
+export class InternalEditorOptions {
+	readonly _internalEditorOptionsBrand: void;
+
+	readonly lineHeight: number; // todo: move to fontInfo
+
+	readonly readOnly: boolean;
+	// ---- cursor options
+	readonly wordSeparators: string;
+	readonly autoClosingBrackets: boolean;
+	readonly useTabStops: boolean;
+	readonly tabFocusMode: boolean;
+	// ---- grouped options
+	readonly layoutInfo: EditorLayoutInfo;
+	readonly fontInfo: FontInfo;
+	readonly viewInfo: InternalEditorViewOptions;
+	readonly wrappingInfo: EditorWrappingInfo;
+	readonly contribInfo: EditorContribOptions;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		lineHeight: number;
+		readOnly: boolean;
+		wordSeparators: string;
+		autoClosingBrackets: boolean;
+		useTabStops: boolean;
+		tabFocusMode: boolean;
+		layoutInfo: EditorLayoutInfo;
+		fontInfo: FontInfo;
+		viewInfo: InternalEditorViewOptions;
+		wrappingInfo: EditorWrappingInfo;
+		contribInfo: EditorContribOptions;
+	}) {
+		this.lineHeight = source.lineHeight | 0;
+		this.readOnly = Boolean(source.readOnly);
+		this.wordSeparators = String(source.wordSeparators);
+		this.autoClosingBrackets = Boolean(source.autoClosingBrackets);
+		this.useTabStops = Boolean(source.useTabStops);
+		this.tabFocusMode = Boolean(source.tabFocusMode);
+		this.layoutInfo = source.layoutInfo.clone();
+		this.fontInfo = source.fontInfo.clone();
+		this.viewInfo = source.viewInfo.clone();
+		this.wrappingInfo = source.wrappingInfo.clone();
+		this.contribInfo = source.contribInfo.clone();
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: InternalEditorOptions): boolean {
+		return (
+			this.lineHeight === other.lineHeight
+			&& this.readOnly === other.readOnly
+			&& this.wordSeparators === other.wordSeparators
+			&& this.autoClosingBrackets === other.autoClosingBrackets
+			&& this.useTabStops === other.useTabStops
+			&& this.tabFocusMode === other.tabFocusMode
+			&& this.layoutInfo.equals(other.layoutInfo)
+			&& this.fontInfo.equals(other.fontInfo)
+			&& this.viewInfo.equals(other.viewInfo)
+			&& this.wrappingInfo.equals(other.wrappingInfo)
+			&& this.contribInfo.equals(other.contribInfo)
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public createChangeEvent(newOpts: InternalEditorOptions): IConfigurationChangedEvent {
+		return {
+			lineHeight: (this.lineHeight !== newOpts.lineHeight),
+			readOnly: (this.readOnly !== newOpts.readOnly),
+			wordSeparators: (this.wordSeparators !== newOpts.wordSeparators),
+			autoClosingBrackets: (this.autoClosingBrackets !== newOpts.autoClosingBrackets),
+			useTabStops: (this.useTabStops !== newOpts.useTabStops),
+			tabFocusMode: (this.tabFocusMode !== newOpts.tabFocusMode),
+			layoutInfo: (!this.layoutInfo.equals(newOpts.layoutInfo)),
+			fontInfo: (!this.fontInfo.equals(newOpts.fontInfo)),
+			viewInfo: this.viewInfo.createChangeEvent(newOpts.viewInfo),
+			wrappingInfo: (!this.wrappingInfo.equals(newOpts.wrappingInfo)),
+			contribInfo: (!this.contribInfo.equals(newOpts.contribInfo)),
+		};
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): InternalEditorOptions {
+		return new InternalEditorOptions(this);
+	}
+}
+
+/**
+ * An event describing that the configuration of the editor has changed.
+ */
+export interface IConfigurationChangedEvent {
+	readonly lineHeight: boolean;
+	readonly readOnly: boolean;
+	readonly wordSeparators: boolean;
+	readonly autoClosingBrackets: boolean;
+	readonly useTabStops: boolean;
+	readonly tabFocusMode: boolean;
+	readonly layoutInfo: boolean;
+	readonly fontInfo: boolean;
+	readonly viewInfo: IViewConfigurationChangedEvent;
+	readonly wrappingInfo: boolean;
+	readonly contribInfo: boolean;
+}
+
+/**
+ * Vertical Lane in the overview ruler of the editor.
+ */
+export enum OverviewRulerLane {
+	Left = 1,
+	Center = 2,
+	Right = 4,
+	Full = 7
+}
+
+/**
+ * Options for rendering a model decoration in the overview ruler.
+ */
+export interface IModelDecorationOverviewRulerOptions {
+	/**
+	 * CSS color to render in the overview ruler.
+	 * e.g.: rgba(100, 100, 100, 0.5)
+	 */
+	color: string;
+	/**
+	 * CSS color to render in the overview ruler.
+	 * e.g.: rgba(100, 100, 100, 0.5)
+	 */
+	darkColor: string;
+	/**
+	 * The position in the overview ruler.
+	 */
+	position: OverviewRulerLane;
+}
+
+/**
+ * Options for a model decoration.
+ */
+export interface IModelDecorationOptions {
+	/**
+	 * Customize the growing behaviour of the decoration when typing at the edges of the decoration.
+	 * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
+	 */
+	stickiness?: TrackedRangeStickiness;
+	/**
+	 * CSS class name describing the decoration.
+	 */
+	className?: string;
+	/**
+	 * Message to be rendered when hovering over the glyph margin decoration.
+	 */
+	glyphMarginHoverMessage?: MarkedString | MarkedString[];
+	/**
+	 * Array of MarkedString to render as the decoration message.
+	 */
+	hoverMessage?: MarkedString | MarkedString[];
+	/**
+	 * Should the decoration expand to encompass a whole line.
+	 */
+	isWholeLine?: boolean;
+	/**
+	 * @deprecated : Use `overviewRuler` instead
+	 */
+	showInOverviewRuler?: string;
+	/**
+	 * If set, render this decoration in the overview ruler.
+	 */
+	overviewRuler?: IModelDecorationOverviewRulerOptions;
+	/**
+	 * If set, the decoration will be rendered in the glyph margin with this CSS class name.
+	 */
+	glyphMarginClassName?: string;
+	/**
+	 * If set, the decoration will be rendered in the lines decorations with this CSS class name.
+	 */
+	linesDecorationsClassName?: string;
+	/**
+	 * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
+	 */
+	marginClassName?: string;
+	/**
+	 * If set, the decoration will be rendered inline with the text with this CSS class name.
+	 * Please use this only for CSS rules that must impact the text. For example, use `className`
+	 * to have a background color decoration.
+	 */
+	inlineClassName?: string;
+	/**
+	 * If set, the decoration will be rendered before the text with this CSS class name.
+	 */
+	beforeContentClassName?: string;
+	/**
+	 * If set, the decoration will be rendered after the text with this CSS class name.
+	 */
+	afterContentClassName?: string;
+}
+
+/**
+ * New model decorations.
+ */
+export interface IModelDeltaDecoration {
+	/**
+	 * Range that this decoration covers.
+	 */
+	range: IRange;
+	/**
+	 * Options associated with this decoration.
+	 */
+	options: IModelDecorationOptions;
+}
+
+/**
+ * A decoration in the model.
+ */
+export interface IModelDecoration {
+	/**
+	 * Identifier for a decoration.
+	 */
+	readonly id: string;
+	/**
+	 * Identifier for a decoration's owener.
+	 */
+	readonly ownerId: number;
+	/**
+	 * Range that this decoration covers.
+	 */
+	readonly range: Range;
+	/**
+	 * Options associated with this decoration.
+	 */
+	readonly options: IModelDecorationOptions;
+	/**
+	 * A flag describing if this is a problem decoration (e.g. warning/error).
+	 */
+	readonly isForValidation: boolean;
+}
+
+/**
+ * An accessor that can add, change or remove model decorations.
+ * @internal
+ */
+export interface IModelDecorationsChangeAccessor {
+	/**
+	 * Add a new decoration.
+	 * @param range Range that this decoration covers.
+	 * @param options Options associated with this decoration.
+	 * @return An unique identifier associated with this decoration.
+	 */
+	addDecoration(range: IRange, options: IModelDecorationOptions): string;
+	/**
+	 * Change the range that an existing decoration covers.
+	 * @param id The unique identifier associated with the decoration.
+	 * @param newRange The new range that this decoration covers.
+	 */
+	changeDecoration(id: string, newRange: IRange): void;
+	/**
+	 * Change the options associated with an existing decoration.
+	 * @param id The unique identifier associated with the decoration.
+	 * @param newOptions The new options associated with this decoration.
+	 */
+	changeDecorationOptions(id: string, newOptions: IModelDecorationOptions): void;
+	/**
+	 * Remove an existing decoration.
+	 * @param id The unique identifier associated with the decoration.
+	 */
+	removeDecoration(id: string): void;
+	/**
+	 * Perform a minimum ammount of operations, in order to transform the decorations
+	 * identified by `oldDecorations` to the decorations described by `newDecorations`
+	 * and returns the new identifiers associated with the resulting decorations.
+	 *
+	 * @param oldDecorations Array containing previous decorations identifiers.
+	 * @param newDecorations Array describing what decorations should result after the call.
+	 * @return An array containing the new decorations identifiers.
+	 */
+	deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
+}
+
+/**
+ * Word inside a model.
+ */
+export interface IWordAtPosition {
+	/**
+	 * The word.
+	 */
+	readonly word: string;
+	/**
+	 * The column where the word starts.
+	 */
+	readonly startColumn: number;
+	/**
+	 * The column where the word ends.
+	 */
+	readonly endColumn: number;
+}
+
+/**
+ * Range of a word inside a model.
+ * @internal
+ */
+export interface IWordRange {
+	/**
+	 * The index where the word starts.
+	 */
+	readonly start: number;
+	/**
+	 * The index where the word ends.
+	 */
+	readonly end: number;
+}
+
+/**
+ * @internal
+ */
+export interface ITokenInfo {
+	readonly type: StandardTokenType;
+	readonly lineNumber: number;
+	readonly startColumn: number;
+	readonly endColumn: number;
+}
+
+/**
+ * @internal
+ */
+export interface ITokenIterator {
+	hasNext(): boolean;
+	next(): ITokenInfo;
+	hasPrev(): boolean;
+	prev(): ITokenInfo;
+}
+
+/**
+ * End of line character preference.
+ */
+export enum EndOfLinePreference {
+	/**
+	 * Use the end of line character identified in the text buffer.
+	 */
+	TextDefined = 0,
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 1,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 2
+}
+
+/**
+ * The default end of line to use when instantiating models.
+ */
+export enum DefaultEndOfLine {
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 1,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 2
+}
+
+/**
+ * End of line character preference.
+ */
+export enum EndOfLineSequence {
+	/**
+	 * Use line feed (\n) as the end of line character.
+	 */
+	LF = 0,
+	/**
+	 * Use carriage return and line feed (\r\n) as the end of line character.
+	 */
+	CRLF = 1
+}
+
+/**
+ * An identifier for a single edit operation.
+ */
+export interface ISingleEditOperationIdentifier {
+	/**
+	 * Identifier major
+	 */
+	major: number;
+	/**
+	 * Identifier minor
+	 */
+	minor: number;
+}
+
+/**
+ * A builder and helper for edit operations for a command.
+ */
+export interface IEditOperationBuilder {
+	/**
+	 * Add a new edit operation (a replace operation).
+	 * @param range The range to replace (delete). May be empty to represent a simple insert.
+	 * @param text The text to replace with. May be null to represent a simple delete.
+	 */
+	addEditOperation(range: Range, text: string): void;
+
+	/**
+	 * Track `selection` when applying edit operations.
+	 * A best effort will be made to not grow/expand the selection.
+	 * An empty selection will clamp to a nearby character.
+	 * @param selection The selection to track.
+	 * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
+	 *           should clamp to the previous or the next character.
+	 * @return A unique identifer.
+	 */
+	trackSelection(selection: Selection, trackPreviousOnEmpty?: boolean): string;
+}
+
+/**
+ * A helper for computing cursor state after a command.
+ */
+export interface ICursorStateComputerData {
+	/**
+	 * Get the inverse edit operations of the added edit operations.
+	 */
+	getInverseEditOperations(): IIdentifiedSingleEditOperation[];
+	/**
+	 * Get a previously tracked selection.
+	 * @param id The unique identifier returned by `trackSelection`.
+	 * @return The selection.
+	 */
+	getTrackedSelection(id: string): Selection;
+}
+
+/**
+ * A command that modifies text / cursor state on a model.
+ */
+export interface ICommand {
+	/**
+	 * Get the edit operations needed to execute this command.
+	 * @param model The model the command will execute on.
+	 * @param builder A helper to collect the needed edit operations and to track selections.
+	 */
+	getEditOperations(model: ITokenizedModel, builder: IEditOperationBuilder): void;
+	/**
+	 * Compute the cursor state after the edit operations were applied.
+	 * @param model The model the commad has executed on.
+	 * @param helper A helper to get inverse edit operations and to get previously tracked selections.
+	 * @return The cursor state after the command executed.
+	 */
+	computeCursorState(model: ITokenizedModel, helper: ICursorStateComputerData): Selection;
+}
+
+/**
+ * A single edit operation, that acts as a simple replace.
+ * i.e. Replace text at `range` with `text` in model.
+ */
+export interface ISingleEditOperation {
+	/**
+	 * The range to replace. This can be empty to emulate a simple insert.
+	 */
+	range: IRange;
+	/**
+	 * The text to replace with. This can be null to emulate a simple delete.
+	 */
+	text: string;
+	/**
+	 * This indicates that this operation has "insert" semantics.
+	 * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+	 */
+	forceMoveMarkers?: boolean;
+}
+
+/**
+ * A single edit operation, that has an identifier.
+ */
+export interface IIdentifiedSingleEditOperation {
+	/**
+	 * An identifier associated with this single edit operation.
+	 */
+	identifier: ISingleEditOperationIdentifier;
+	/**
+	 * The range to replace. This can be empty to emulate a simple insert.
+	 */
+	range: Range;
+	/**
+	 * The text to replace with. This can be null to emulate a simple delete.
+	 */
+	text: string;
+	/**
+	 * This indicates that this operation has "insert" semantics.
+	 * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+	 */
+	forceMoveMarkers: boolean;
+	/**
+	 * This indicates that this operation is inserting automatic whitespace
+	 * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
+	 */
+	isAutoWhitespaceEdit?: boolean;
+}
+
+/**
+ * A callback that can compute the cursor state after applying a series of edit operations.
+ */
+export interface ICursorStateComputer {
+	/**
+	 * A callback that can compute the resulting cursors state after some edit operations have been executed.
+	 */
+	(inverseEditOperations: IIdentifiedSingleEditOperation[]): Selection[];
+}
+
+export class TextModelResolvedOptions {
+	_textModelResolvedOptionsBrand: void;
+
+	readonly tabSize: number;
+	readonly insertSpaces: boolean;
+	readonly defaultEOL: DefaultEndOfLine;
+	readonly trimAutoWhitespace: boolean;
+
+	/**
+	 * @internal
+	 */
+	constructor(src: {
+		tabSize: number;
+		insertSpaces: boolean;
+		defaultEOL: DefaultEndOfLine;
+		trimAutoWhitespace: boolean;
+	}) {
+		this.tabSize = src.tabSize | 0;
+		this.insertSpaces = Boolean(src.insertSpaces);
+		this.defaultEOL = src.defaultEOL | 0;
+		this.trimAutoWhitespace = Boolean(src.trimAutoWhitespace);
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: TextModelResolvedOptions): boolean {
+		return (
+			this.tabSize === other.tabSize
+			&& this.insertSpaces === other.insertSpaces
+			&& this.defaultEOL === other.defaultEOL
+			&& this.trimAutoWhitespace === other.trimAutoWhitespace
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public createChangeEvent(newOpts: TextModelResolvedOptions): IModelOptionsChangedEvent {
+		return {
+			tabSize: this.tabSize !== newOpts.tabSize,
+			insertSpaces: this.insertSpaces !== newOpts.insertSpaces,
+			trimAutoWhitespace: this.trimAutoWhitespace !== newOpts.trimAutoWhitespace,
+		};
+	}
+}
+
+/**
+ * @internal
+ */
+export interface ITextModelCreationOptions {
+	tabSize: number;
+	insertSpaces: boolean;
+	detectIndentation: boolean;
+	trimAutoWhitespace: boolean;
+	defaultEOL: DefaultEndOfLine;
+}
+
+export interface ITextModelUpdateOptions {
+	tabSize?: number;
+	insertSpaces?: boolean;
+	trimAutoWhitespace?: boolean;
+}
+
+export interface IModelOptionsChangedEvent {
+	readonly tabSize: boolean;
+	readonly insertSpaces: boolean;
+	readonly trimAutoWhitespace: boolean;
+}
+
+/**
+ * A textual read-only model.
+ */
+export interface ITextModel {
+
+	/**
+	 * @internal
+	 */
+	mightContainRTL(): boolean;
+
+	/**
+	 * @internal
+	 */
+	mightContainNonBasicASCII(): boolean;
+
+	getOptions(): TextModelResolvedOptions;
+
+	/**
+	 * Get the current version id of the model.
+	 * Anytime a change happens to the model (even undo/redo),
+	 * the version id is incremented.
+	 */
+	getVersionId(): number;
+
+	/**
+	 * Get the alternative version id of the model.
+	 * This alternative version id is not always incremented,
+	 * it will return the same values in the case of undo-redo.
+	 */
+	getAlternativeVersionId(): number;
+
+	/**
+	 * Replace the entire text buffer value contained in this model.
+	 */
+	setValue(newValue: string): void;
+
+	/**
+	 * Replace the entire text buffer value contained in this model.
+	 * @internal
+	 */
+	setValueFromRawText(newValue: IRawText): void;
+
+	/**
+	 * Get the text stored in this model.
+	 * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
+	 * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
+	 * @return The text.
+	 */
+	getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
+
+	/**
+	 * Get the length of the text stored in this model.
+	 */
+	getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
+
+	/**
+	 * Get the raw text stored in this model.
+	 * @internal
+	 */
+	toRawText(): IRawText;
+
+	/**
+	 * Check if the raw text stored in this model equals another raw text.
+	 * @internal
+	 */
+	equals(other: IRawText): boolean;
+
+	/**
+	 * Get the text in a certain range.
+	 * @param range The range describing what text to get.
+	 * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
+	 * @return The text.
+	 */
+	getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
+
+	/**
+	 * Get the length of text in a certain range.
+	 * @param range The range describing what text length to get.
+	 * @return The text length.
+	 */
+	getValueLengthInRange(range: IRange): number;
+
+	/**
+	 * Splits characters in two buckets. First bucket (A) is of characters that
+	 * sit in lines with length < `LONG_LINE_BOUNDARY`. Second bucket (B) is of
+	 * characters that sit in lines with length >= `LONG_LINE_BOUNDARY`.
+	 * If count(B) > count(A) return true. Returns false otherwise.
+	 * @internal
+	 */
+	isDominatedByLongLines(): boolean;
+
+	/**
+	 * Get the number of lines in the model.
+	 */
+	getLineCount(): number;
+
+	/**
+	 * Get the text for a certain line.
+	 */
+	getLineContent(lineNumber: number): string;
+
+	/**
+	 * @internal
+	 */
+	getIndentLevel(lineNumber: number): number;
+
+	/**
+	 * @internal
+	 */
+	getIndentRanges(): IndentRange[];
+
+	/**
+	 * @internal
+	 */
+	getLineIndentGuide(lineNumber: number): number;
+
+	/**
+	 * Get the text for all lines.
+	 */
+	getLinesContent(): string[];
+
+	/**
+	 * Get the end of line sequence predominantly used in the text buffer.
+	 * @return EOL char sequence (e.g.: '\n' or '\r\n').
+	 */
+	getEOL(): string;
+
+	/**
+	 * Change the end of line sequence used in the text buffer.
+	 */
+	setEOL(eol: EndOfLineSequence): void;
+
+	/**
+	 * Get the minimum legal column for line at `lineNumber`
+	 */
+	getLineMinColumn(lineNumber: number): number;
+
+	/**
+	 * Get the maximum legal column for line at `lineNumber`
+	 */
+	getLineMaxColumn(lineNumber: number): number;
+
+	/**
+	 * Returns the column before the first non whitespace character for line at `lineNumber`.
+	 * Returns 0 if line is empty or contains only whitespace.
+	 */
+	getLineFirstNonWhitespaceColumn(lineNumber: number): number;
+
+	/**
+	 * Returns the column after the last non whitespace character for line at `lineNumber`.
+	 * Returns 0 if line is empty or contains only whitespace.
+	 */
+	getLineLastNonWhitespaceColumn(lineNumber: number): number;
+
+	/**
+	 * Create a valid position,
+	 */
+	validatePosition(position: IPosition): Position;
+
+	/**
+	 * Advances the given position by the given offest (negative offsets are also accepted)
+	 * and returns it as a new valid position.
+	 *
+	 * If the offset and position are such that their combination goes beyond the beginning or
+	 * end of the model, throws an exception.
+	 *
+	 * If the ofsset is such that the new position would be in the middle of a multi-byte
+	 * line terminator, throws an exception.
+	 */
+	modifyPosition(position: IPosition, offset: number): Position;
+
+	/**
+	 * Create a valid range.
+	 */
+	validateRange(range: IRange): Range;
+
+	/**
+	 * Converts the position to a zero-based offset.
+	 *
+	 * The position will be [adjusted](#TextDocument.validatePosition).
+	 *
+	 * @param position A position.
+	 * @return A valid zero-based offset.
+	 */
+	getOffsetAt(position: IPosition): number;
+
+	/**
+	 * Converts a zero-based offset to a position.
+	 *
+	 * @param offset A zero-based offset.
+	 * @return A valid [position](#Position).
+	 */
+	getPositionAt(offset: number): Position;
+
+	/**
+	 * Get a range covering the entire model
+	 */
+	getFullModelRange(): Range;
+
+	/**
+	 * Returns iff the model was disposed or not.
+	 */
+	isDisposed(): boolean;
+
+	/**
+	 * No mode supports allowed on this model because it is simply too large.
+	 * (even tokenization would cause too much memory pressure)
+	 * @internal
+	 */
+	isTooLargeForHavingAMode(): boolean;
+
+	/**
+	 * Only basic mode supports allowed on this model because it is simply too large.
+	 * (tokenization is allowed and other basic supports)
+	 * @internal
+	 */
+	isTooLargeForHavingARichMode(): boolean;
+
+	/**
+	 * Search the model.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param captureMatches The result will contain the captured groups.
+	 * @param limitResultCount Limit the number of results
+	 * @return The ranges where the matches are. It is empty if not matches have been found.
+	 */
+	findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
+	/**
+	 * Search the model.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchScope Limit the searching to only search inside this range.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param captureMatches The result will contain the captured groups.
+	 * @param limitResultCount Limit the number of results
+	 * @return The ranges where the matches are. It is empty if no matches have been found.
+	 */
+	findMatches(searchString: string, searchScope: IRange, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
+	/**
+	 * Search the model for the next match. Loops to the beginning of the model if needed.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchStart Start the searching at the specified position.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param captureMatches The result will contain the captured groups.
+	 * @return The range where the next match is. It is null if no next match has been found.
+	 */
+	findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
+	/**
+	 * Search the model for the previous match. Loops to the end of the model if needed.
+	 * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+	 * @param searchStart Start the searching at the specified position.
+	 * @param isRegex Used to indicate that `searchString` is a regular expression.
+	 * @param matchCase Force the matching to match lower/upper case exactly.
+	 * @param wholeWord Force the matching to match entire words only.
+	 * @param captureMatches The result will contain the captured groups.
+	 * @return The range where the previous match is. It is null if no previous match has been found.
+	 */
+	findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
+}
+
+export class FindMatch {
+	_findMatchBrand: void;
+
+	public readonly range: Range;
+	public readonly matches: string[];
+
+	/**
+	 * @internal
+	 */
+	constructor(range: Range, matches: string[]) {
+		this.range = range;
+		this.matches = matches;
+	}
+}
+
+export interface IReadOnlyModel extends ITextModel {
+	/**
+	 * Gets the resource associated with this editor model.
+	 */
+	readonly uri: URI;
+
+	/**
+	 * Get the language associated with this model.
+	 * @internal
+	 */
+	getLanguageIdentifier(): LanguageIdentifier;
+
+	/**
+	 * Get the language associated with this model.
+	 */
+	getModeId(): string;
+
+	/**
+	 * Get the word under or besides `position`.
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Might be null.
+	 */
+	getWordAtPosition(position: IPosition): IWordAtPosition;
+
+	/**
+	 * Get the word under or besides `position` trimmed to `position`.column
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Will never be null.
+	 */
+	getWordUntilPosition(position: IPosition): IWordAtPosition;
+}
+
+/**
+ * @internal
+ */
+export interface IFoundBracket {
+	range: Range;
+	open: string;
+	close: string;
+	isOpen: boolean;
+}
+
+/**
+ * A model that is tokenized.
+ */
+export interface ITokenizedModel extends ITextModel {
+
+	/**
+	 * Tokenize if necessary and get the tokens for the line `lineNumber`.
+	 * @param lineNumber The line number
+	 * @param inaccurateTokensAcceptable Are inaccurate tokens acceptable? Defaults to false
+	 * @internal
+	 */
+	getLineTokens(lineNumber: number, inaccurateTokensAcceptable?: boolean): LineTokens;
+
+	/**
+	 * Get the language associated with this model.
+	 * @internal
+	 */
+	getLanguageIdentifier(): LanguageIdentifier;
+
+	/**
+	 * Get the language associated with this model.
+	 */
+	getModeId(): string;
+
+	/**
+	 * Set the current language mode associated with the model.
+	 * @internal
+	 */
+	setMode(languageIdentifier: LanguageIdentifier): void;
+
+	/**
+	 * Returns the true (inner-most) language mode at a given position.
+	 * @internal
+	 */
+	getLanguageIdAtPosition(lineNumber: number, column: number): LanguageId;
+
+	/**
+	 * Get the word under or besides `position`.
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Might be null.
+	 */
+	getWordAtPosition(position: IPosition): IWordAtPosition;
+
+	/**
+	 * Get the word under or besides `position` trimmed to `position`.column
+	 * @param position The position to look for a word.
+	 * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+	 * @return The word under or besides `position`. Will never be null.
+	 */
+	getWordUntilPosition(position: IPosition): IWordAtPosition;
+
+	/**
+	 * Returns an iterator that can be used to read
+	 * next and previous tokens from the provided position.
+	 * The iterator is made available through the callback
+	 * function and can't be used afterwards.
+	 * @internal
+	 */
+	tokenIterator(position: IPosition, callback: (it: ITokenIterator) => any): any;
+
+	/**
+	 * Find the matching bracket of `request` up, counting brackets.
+	 * @param request The bracket we're searching for
+	 * @param position The position at which to start the search.
+	 * @return The range of the matching bracket, or null if the bracket match was not found.
+	 * @internal
+	 */
+	findMatchingBracketUp(bracket: string, position: IPosition): Range;
+
+	// /**
+	//  * Find the first bracket in the model before `position`.
+	//  * @param position The position at which to start the search.
+	//  * @return The info for the first bracket before `position`, or null if there are no more brackets before `positions`.
+	//  */
+	// findPrevBracket(position:IPosition): IFoundBracket;
+
+	// /**
+	//  * Find the first bracket in the model after `position`.
+	//  * @param position The position at which to start the search.
+	//  * @return The info for the first bracket after `position`, or null if there are no more brackets after `positions`.
+	//  */
+	// findNextBracket(position:IPosition): IFoundBracket;
+
+	/**
+	 * Given a `position`, if the position is on top or near a bracket,
+	 * find the matching bracket of that bracket and return the ranges of both brackets.
+	 * @param position The position at which to look for a bracket.
+	 * @internal
+	 */
+	matchBracket(position: IPosition): [Range, Range];
+}
+
+/**
+ * A model that can track markers.
+ */
+export interface ITextModelWithMarkers extends ITextModel {
+	/**
+	 * @internal
+	 */
+	_addMarker(internalDecorationId: number, lineNumber: number, column: number, stickToPreviousCharacter: boolean): string;
+	/**
+	 * @internal
+	 */
+	_changeMarker(id: string, newLineNumber: number, newColumn: number): void;
+	/**
+	 * @internal
+	 */
+	_changeMarkerStickiness(id: string, newStickToPreviousCharacter: boolean): void;
+	/**
+	 * @internal
+	 */
+	_getMarker(id: string): Position;
+	/**
+	 * @internal
+	 */
+	_removeMarker(id: string): void;
+}
+
+/**
+ * Describes the behaviour of decorations when typing/editing near their edges.
+ */
+export enum TrackedRangeStickiness {
+	AlwaysGrowsWhenTypingAtEdges = 0,
+	NeverGrowsWhenTypingAtEdges = 1,
+	GrowsOnlyWhenTypingBefore = 2,
+	GrowsOnlyWhenTypingAfter = 3,
+}
+
+/**
+ * A model that can have decorations.
+ */
+export interface ITextModelWithDecorations {
+	/**
+	 * Change the decorations. The callback will be called with a change accessor
+	 * that becomes invalid as soon as the callback finishes executing.
+	 * This allows for all events to be queued up until the change
+	 * is completed. Returns whatever the callback returns.
+	 * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+	 * @internal
+	 */
+	changeDecorations<T>(callback: (changeAccessor: IModelDecorationsChangeAccessor) => T, ownerId?: number): T;
+
+	/**
+	 * Perform a minimum ammount of operations, in order to transform the decorations
+	 * identified by `oldDecorations` to the decorations described by `newDecorations`
+	 * and returns the new identifiers associated with the resulting decorations.
+	 *
+	 * @param oldDecorations Array containing previous decorations identifiers.
+	 * @param newDecorations Array describing what decorations should result after the call.
+	 * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+	 * @return An array containing the new decorations identifiers.
+	 */
+	deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
+
+	/**
+	 * Remove all decorations that have been added with this specific ownerId.
+	 * @param ownerId The owner id to search for.
+	 * @internal
+	 */
+	removeAllDecorationsWithOwnerId(ownerId: number): void;
+
+	/**
+	 * Get the options associated with a decoration.
+	 * @param id The decoration id.
+	 * @return The decoration options or null if the decoration was not found.
+	 */
+	getDecorationOptions(id: string): IModelDecorationOptions;
+
+	/**
+	 * Get the range associated with a decoration.
+	 * @param id The decoration id.
+	 * @return The decoration range or null if the decoration was not found.
+	 */
+	getDecorationRange(id: string): Range;
+
+	/**
+	 * Gets all the decorations for the line `lineNumber` as an array.
+	 * @param lineNumber The line number
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
+	 * @param startLineNumber The start line number
+	 * @param endLineNumber The end line number
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
+	 * So for now it returns all the decorations on the same line as `range`.
+	 * @param range The range to search in
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 * @return An array with the decorations
+	 */
+	getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+
+	/**
+	 * Gets all the decorations as an array.
+	 * @param ownerId If set, it will ignore decorations belonging to other owners.
+	 * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+	 */
+	getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+}
+
+/**
+ * An editable text model.
+ */
+export interface IEditableTextModel extends ITextModelWithMarkers {
+
+	/**
+	 * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
+	 */
+	normalizeIndentation(str: string): string;
+
+	/**
+	 * Get what is considered to be one indent (e.g. a tab character or 4 spaces, etc.).
+	 */
+	getOneIndent(): string;
+
+	/**
+	 * Change the options of this model.
+	 */
+	updateOptions(newOpts: ITextModelUpdateOptions): void;
+
+	/**
+	 * Detect the indentation options for this model from its content.
+	 */
+	detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
+
+	/**
+	 * Push a stack element onto the undo stack. This acts as an undo/redo point.
+	 * The idea is to use `pushEditOperations` to edit the model and then to
+	 * `pushStackElement` to create an undo/redo stop point.
+	 */
+	pushStackElement(): void;
+
+	/**
+	 * Push edit operations, basically editing the model. This is the preferred way
+	 * of editing the model. The edit operations will land on the undo stack.
+	 * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.
+	 * @param editOperations The edit operations.
+	 * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
+	 * @return The cursor state returned by the `cursorStateComputer`.
+	 */
+	pushEditOperations(beforeCursorState: Selection[], editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[];
+
+	/**
+	 * Edit the model without adding the edits to the undo stack.
+	 * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
+	 * @param operations The edit operations.
+	 * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.
+	 */
+	applyEdits(operations: IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];
+
+	/**
+	 * Undo edit operations until the first previous stop point created by `pushStackElement`.
+	 * The inverse edit operations will be pushed on the redo stack.
+	 * @internal
+	 */
+	undo(): Selection[];
+
+	/**
+	 * Redo edit operations until the next stop point created by `pushStackElement`.
+	 * The inverse edit operations will be pushed on the undo stack.
+	 * @internal
+	 */
+	redo(): Selection[];
+
+	/**
+	 * Set an editable range on the model.
+	 * @internal
+	 */
+	setEditableRange(range: IRange): void;
+
+	/**
+	 * Check if the model has an editable range.
+	 * @internal
+	 */
+	hasEditableRange(): boolean;
+
+	/**
+	 * Get the editable range on the model.
+	 * @internal
+	 */
+	getEditableRange(): Range;
+}
+
+/**
+ * A model.
+ */
+export interface IModel extends IReadOnlyModel, IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithDecorations, IEditorModel {
+	/**
+	 * @deprecated Please use `onDidChangeContent` instead.
+	 * An event emitted when the contents of the model have changed.
+	 * @internal
+	 * @event
+	 */
+	onDidChangeRawContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the contents of the model have changed.
+	 * @event
+	 */
+	onDidChangeContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+	/**
+	 * An event emitted when decorations of the model have changed.
+	 * @event
+	 */
+	onDidChangeDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the model options have changed.
+	 * @event
+	 */
+	onDidChangeOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the language associated with the model has changed.
+	 * @event
+	 */
+	onDidChangeLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted right before disposing the model.
+	 * @event
+	 */
+	onWillDispose(listener: () => void): IDisposable;
+
+	/**
+	 * @internal
+	 */
+	addBulkListener(listener: BulkListenerCallback): IDisposable;
+
+	/**
+	 * A unique identifier associated with this model.
+	 */
+	readonly id: string;
+
+	/**
+	 * Destroy this model. This will unbind the model from the mode
+	 * and make all necessary clean-up to release this object to the GC.
+	 * @internal
+	 */
+	destroy(): void;
+
+	/**
+	 * Destroy this model. This will unbind the model from the mode
+	 * and make all necessary clean-up to release this object to the GC.
+	 */
+	dispose(): void;
+
+	/**
+	 * @internal
+	 */
+	onBeforeAttached(): void;
+
+	/**
+	 * @internal
+	 */
+	onBeforeDetached(): void;
+
+	/**
+	 * Returns iff this model is attached to an editor or not.
+	 * @internal
+	 */
+	isAttachedToEditor(): boolean;
+}
+
+/**
+ * An event describing that the current mode associated with a model has changed.
+ */
+export interface IModelLanguageChangedEvent {
+	/**
+	 * Previous language
+	 */
+	readonly oldLanguage: string;
+	/**
+	 * New language
+	 */
+	readonly newLanguage: string;
+}
+
+/**
+ * An event describing a change in the text of a model.
+ */
+export interface IModelContentChangedEvent2 {
+	/**
+	 * The range that got replaced.
+	 */
+	readonly range: IRange;
+	/**
+	 * The length of the range that got replaced.
+	 */
+	readonly rangeLength: number;
+	/**
+	 * The new text for the range.
+	 */
+	readonly text: string;
+	/**
+	 * The (new) end-of-line character.
+	 */
+	readonly eol: string;
+	/**
+	 * The new version id the model has transitioned to.
+	 */
+	versionId: number;
+	/**
+	 * Flag that indicates that this event was generated while undoing.
+	 */
+	readonly isUndoing: boolean;
+	/**
+	 * Flag that indicates that this event was generated while redoing.
+	 */
+	readonly isRedoing: boolean;
+}
+/**
+ * An event describing a change in the text of a model.
+ * @internal
+ */
+export interface IModelContentChangedEvent {
+	/**
+	 * The event type. It can be used to detect the actual event type:
+	 * 		EditorCommon.EventType.ModelContentChangedFlush => IModelContentChangedFlushEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLinesDeleted => IModelContentChangedLineChangedEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLinesInserted => IModelContentChangedLinesDeletedEvent
+	 * 		EditorCommon.EventType.ModelContentChangedLineChanged => IModelContentChangedLinesInsertedEvent
+	 */
+	readonly changeType: string;
+	/**
+	 * The new version id the model has transitioned to.
+	 */
+	versionId: number;
+	/**
+	 * Flag that indicates that this event was generated while undoing.
+	 */
+	readonly isUndoing: boolean;
+	/**
+	 * Flag that indicates that this event was generated while redoing.
+	 */
+	readonly isRedoing: boolean;
+}
+
+/**
+ * The raw text backing a model.
+ * @internal
+ */
+export interface IRawText {
+	/**
+	 * The entire text length.
+	 */
+	readonly length: number;
+	/**
+	 * The text split into lines.
+	 */
+	readonly lines: string[];
+	/**
+	 * The BOM (leading character sequence of the file).
+	 */
+	readonly BOM: string;
+	/**
+	 * The end of line sequence.
+	 */
+	readonly EOL: string;
+	/**
+	 * The text contains Unicode characters classified as "R" or "AL".
+	 */
+	readonly containsRTL: boolean;
+	/**
+	 * The text contains only characters inside the ASCII range 32-126 or \t \r \n
+	 */
+	readonly isBasicASCII: boolean;
+	/**
+	 * The options associated with this text.
+	 */
+	readonly options: {
+		readonly tabSize: number;
+		readonly insertSpaces: boolean;
+		readonly defaultEOL: DefaultEndOfLine;
+		readonly trimAutoWhitespace: boolean;
+	};
+}
+
+/**
+ * An event describing that a model has been reset to a new value.
+ * @internal
+ */
+export interface IModelContentChangedFlushEvent extends IModelContentChangedEvent {
+	/**
+	 * The new text content of the model.
+	 */
+	readonly detail: IRawText;
+}
+/**
+ * An event describing that a line has changed in a model.
+ * @internal
+ */
+export interface IModelContentChangedLineChangedEvent extends IModelContentChangedEvent {
+	/**
+	 * The line that has changed.
+	 */
+	readonly lineNumber: number;
+	/**
+	 * The new value of the line.
+	 */
+	readonly detail: string;
+}
+/**
+ * An event describing that line(s) have been deleted in a model.
+ * @internal
+ */
+export interface IModelContentChangedLinesDeletedEvent extends IModelContentChangedEvent {
+	/**
+	 * At what line the deletion began (inclusive).
+	 */
+	readonly fromLineNumber: number;
+	/**
+	 * At what line the deletion stopped (inclusive).
+	 */
+	readonly toLineNumber: number;
+}
+/**
+ * An event describing that line(s) have been inserted in a model.
+ * @internal
+ */
+export interface IModelContentChangedLinesInsertedEvent extends IModelContentChangedEvent {
+	/**
+	 * Before what line did the insertion begin
+	 */
+	readonly fromLineNumber: number;
+	/**
+	 * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
+	 */
+	readonly toLineNumber: number;
+	/**
+	 * The text that was inserted
+	 */
+	readonly detail: string;
+}
+/**
+ * An event describing that model decorations have changed.
+ */
+export interface IModelDecorationsChangedEvent {
+	/**
+	 * Lists of ids for added decorations.
+	 */
+	readonly addedDecorations: string[];
+	/**
+	 * Lists of ids for changed decorations.
+	 */
+	readonly changedDecorations: string[];
+	/**
+	 * List of ids for removed decorations.
+	 */
+	readonly removedDecorations: string[];
+}
+/**
+ * An event describing that some ranges of lines have been tokenized (their tokens have changed).
+ */
+export interface IModelTokensChangedEvent {
+	readonly ranges: {
+		/**
+		 * The start of the range (inclusive)
+		 */
+		readonly fromLineNumber: number;
+		/**
+		 * The end of the range (inclusive)
+		 */
+		readonly toLineNumber: number;
+	}[];
+}
+
+/**
+ * Describes the reason the cursor has changed its position.
+ */
+export enum CursorChangeReason {
+	/**
+	 * Unknown or not set.
+	 */
+	NotSet = 0,
+	/**
+	 * A `model.setValue()` was called.
+	 */
+	ContentFlush = 1,
+	/**
+	 * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
+	 */
+	RecoverFromMarkers = 2,
+	/**
+	 * There was an explicit user gesture.
+	 */
+	Explicit = 3,
+	/**
+	 * There was a Paste.
+	 */
+	Paste = 4,
+	/**
+	 * There was an Undo.
+	 */
+	Undo = 5,
+	/**
+	 * There was a Redo.
+	 */
+	Redo = 6,
+}
+/**
+ * An event describing that the cursor position has changed.
+ */
+export interface ICursorPositionChangedEvent {
+	/**
+	 * Primary cursor's position.
+	 */
+	readonly position: Position;
+	/**
+	 * Primary cursor's view position
+	 */
+	readonly viewPosition: Position;
+	/**
+	 * Secondary cursors' position.
+	 */
+	readonly secondaryPositions: Position[];
+	/**
+	 * Secondary cursors' view position.
+	 */
+	readonly secondaryViewPositions: Position[];
+	/**
+	 * Reason.
+	 */
+	readonly reason: CursorChangeReason;
+	/**
+	 * Source of the call that caused the event.
+	 */
+	readonly source: string;
+	/**
+	 * Is the primary cursor in the editable range?
+	 */
+	readonly isInEditableRange: boolean;
+}
+/**
+ * An event describing that the cursor selection has changed.
+ */
+export interface ICursorSelectionChangedEvent {
+	/**
+	 * The primary selection.
+	 */
+	readonly selection: Selection;
+	/**
+	 * The primary selection in view coordinates.
+	 */
+	readonly viewSelection: Selection;
+	/**
+	 * The secondary selections.
+	 */
+	readonly secondarySelections: Selection[];
+	/**
+	 * The secondary selections in view coordinates.
+	 */
+	readonly secondaryViewSelections: Selection[];
+	/**
+	 * Source of the call that caused the event.
+	 */
+	readonly source: string;
+	/**
+	 * Reason.
+	 */
+	readonly reason: CursorChangeReason;
+}
+/**
+ * @internal
+ */
+export const enum VerticalRevealType {
+	Simple = 0,
+	Center = 1,
+	CenterIfOutsideViewport = 2,
+	Top = 3,
+	Bottom = 4
+}
+/**
+ * An event describing a request to reveal a specific range in the view of the editor.
+ * @internal
+ */
+export interface ICursorRevealRangeEvent {
+	/**
+	 * Range to be reavealed.
+	 */
+	readonly range: Range;
+	/**
+	 * View range to be reavealed.
+	 */
+	readonly viewRange: Range;
+
+	readonly verticalType: VerticalRevealType;
+	/**
+	 * If true: there should be a horizontal & vertical revealing
+	 * If false: there should be just a vertical revealing
+	 */
+	readonly revealHorizontal: boolean;
+	/**
+	 * If true: cursor is revealed if outside viewport
+	 */
+	readonly revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface ICursorScrollRequestEvent {
+	readonly deltaLines: number;
+	readonly revealCursor: boolean;
+}
+
+/**
+ * An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
+ */
+export interface IModelChangedEvent {
+	/**
+	 * The `uri` of the previous model or null.
+	 */
+	readonly oldModelUrl: URI;
+	/**
+	 * The `uri` of the new model or null.
+	 */
+	readonly newModelUrl: URI;
+}
+
+/**
+ * @internal
+ */
+export interface IEditorWhitespace {
+	readonly id: number;
+	readonly afterLineNumber: number;
+	readonly heightInLines: number;
+}
+
+/**
+ * A description for the overview ruler position.
+ */
+export class OverviewRulerPosition {
+	readonly _overviewRulerPositionBrand: void;
+
+	/**
+	 * Width of the overview ruler
+	 */
+	readonly width: number;
+	/**
+	 * Height of the overview ruler
+	 */
+	readonly height: number;
+	/**
+	 * Top position for the overview ruler
+	 */
+	readonly top: number;
+	/**
+	 * Right position for the overview ruler
+	 */
+	readonly right: number;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		width: number;
+		height: number;
+		top: number;
+		right: number;
+	}) {
+		this.width = source.width | 0;
+		this.height = source.height | 0;
+		this.top = source.top | 0;
+		this.right = source.right | 0;
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: OverviewRulerPosition): boolean {
+		return (
+			this.width === other.width
+			&& this.height === other.height
+			&& this.top === other.top
+			&& this.right === other.right
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): OverviewRulerPosition {
+		return new OverviewRulerPosition(this);
+	}
+}
+
+/**
+ * The internal layout details of the editor.
+ */
+export class EditorLayoutInfo {
+	readonly _editorLayoutInfoBrand: void;
+
+	/**
+	 * Full editor width.
+	 */
+	readonly width: number;
+	/**
+	 * Full editor height.
+	 */
+	readonly height: number;
+
+	/**
+	 * Left position for the glyph margin.
+	 */
+	readonly glyphMarginLeft: number;
+	/**
+	 * The width of the glyph margin.
+	 */
+	readonly glyphMarginWidth: number;
+	/**
+	 * The height of the glyph margin.
+	 */
+	readonly glyphMarginHeight: number;
+
+	/**
+	 * Left position for the line numbers.
+	 */
+	readonly lineNumbersLeft: number;
+	/**
+	 * The width of the line numbers.
+	 */
+	readonly lineNumbersWidth: number;
+	/**
+	 * The height of the line numbers.
+	 */
+	readonly lineNumbersHeight: number;
+
+	/**
+	 * Left position for the line decorations.
+	 */
+	readonly decorationsLeft: number;
+	/**
+	 * The width of the line decorations.
+	 */
+	readonly decorationsWidth: number;
+	/**
+	 * The height of the line decorations.
+	 */
+	readonly decorationsHeight: number;
+
+	/**
+	 * Left position for the content (actual text)
+	 */
+	readonly contentLeft: number;
+	/**
+	 * The width of the content (actual text)
+	 */
+	readonly contentWidth: number;
+	/**
+	 * The height of the content (actual height)
+	 */
+	readonly contentHeight: number;
+
+	/**
+	 * The width of the vertical scrollbar.
+	 */
+	readonly verticalScrollbarWidth: number;
+	/**
+	 * The height of the horizontal scrollbar.
+	 */
+	readonly horizontalScrollbarHeight: number;
+
+	/**
+	 * The position of the overview ruler.
+	 */
+	readonly overviewRuler: OverviewRulerPosition;
+
+	/**
+	 * @internal
+	 */
+	constructor(source: {
+		width: number;
+		height: number;
+		glyphMarginLeft: number;
+		glyphMarginWidth: number;
+		glyphMarginHeight: number;
+		lineNumbersLeft: number;
+		lineNumbersWidth: number;
+		lineNumbersHeight: number;
+		decorationsLeft: number;
+		decorationsWidth: number;
+		decorationsHeight: number;
+		contentLeft: number;
+		contentWidth: number;
+		contentHeight: number;
+		verticalScrollbarWidth: number;
+		horizontalScrollbarHeight: number;
+		overviewRuler: OverviewRulerPosition;
+	}) {
+		this.width = source.width | 0;
+		this.height = source.height | 0;
+		this.glyphMarginLeft = source.glyphMarginLeft | 0;
+		this.glyphMarginWidth = source.glyphMarginWidth | 0;
+		this.glyphMarginHeight = source.glyphMarginHeight | 0;
+		this.lineNumbersLeft = source.lineNumbersLeft | 0;
+		this.lineNumbersWidth = source.lineNumbersWidth | 0;
+		this.lineNumbersHeight = source.lineNumbersHeight | 0;
+		this.decorationsLeft = source.decorationsLeft | 0;
+		this.decorationsWidth = source.decorationsWidth | 0;
+		this.decorationsHeight = source.decorationsHeight | 0;
+		this.contentLeft = source.contentLeft | 0;
+		this.contentWidth = source.contentWidth | 0;
+		this.contentHeight = source.contentHeight | 0;
+		this.verticalScrollbarWidth = source.verticalScrollbarWidth | 0;
+		this.horizontalScrollbarHeight = source.horizontalScrollbarHeight | 0;
+		this.overviewRuler = source.overviewRuler.clone();
+	}
+
+	/**
+	 * @internal
+	 */
+	public equals(other: EditorLayoutInfo): boolean {
+		return (
+			this.width === other.width
+			&& this.height === other.height
+			&& this.glyphMarginLeft === other.glyphMarginLeft
+			&& this.glyphMarginWidth === other.glyphMarginWidth
+			&& this.glyphMarginHeight === other.glyphMarginHeight
+			&& this.lineNumbersLeft === other.lineNumbersLeft
+			&& this.lineNumbersWidth === other.lineNumbersWidth
+			&& this.lineNumbersHeight === other.lineNumbersHeight
+			&& this.decorationsLeft === other.decorationsLeft
+			&& this.decorationsWidth === other.decorationsWidth
+			&& this.decorationsHeight === other.decorationsHeight
+			&& this.contentLeft === other.contentLeft
+			&& this.contentWidth === other.contentWidth
+			&& this.contentHeight === other.contentHeight
+			&& this.verticalScrollbarWidth === other.verticalScrollbarWidth
+			&& this.horizontalScrollbarHeight === other.horizontalScrollbarHeight
+			&& this.overviewRuler.equals(other.overviewRuler)
+		);
+	}
+
+	/**
+	 * @internal
+	 */
+	public clone(): EditorLayoutInfo {
+		return new EditorLayoutInfo(this);
+	}
+}
+
+/**
+ * Options for creating the editor.
+ */
+export interface ICodeEditorWidgetCreationOptions extends IEditorOptions {
+	/**
+	 * The initial model associated with this code editor.
+	 */
+	model?: IModel;
+}
+
+/**
+ * An editor model.
+ */
+export interface IEditorModel {
+}
+/**
+ * An editor view state.
+ */
+export interface IEditorViewState {
+}
+export interface IDimension {
+	width: number;
+	height: number;
+}
+
+/**
+ * A (serializable) state of the cursors.
+ */
+export interface ICursorState {
+	inSelectionMode: boolean;
+	selectionStart: IPosition;
+	position: IPosition;
+}
+/**
+ * A (serializable) state of the view.
+ */
+export interface IViewState {
+	scrollTop: number;
+	scrollTopWithoutViewZones: number;
+	scrollLeft: number;
+}
+/**
+ * A (serializable) state of the code editor.
+ */
+export interface ICodeEditorViewState extends IEditorViewState {
+	cursorState: ICursorState[];
+	viewState: IViewState;
+	contributionsState: { [id: string]: any };
+}
+
+/**
+ * Type of hit element with the mouse in the editor.
+ */
+export enum MouseTargetType {
+	/**
+	 * Mouse is on top of an unknown element.
+	 */
+	UNKNOWN,
+	/**
+	 * Mouse is on top of the textarea used for input.
+	 */
+	TEXTAREA,
+	/**
+	 * Mouse is on top of the glyph margin
+	 */
+	GUTTER_GLYPH_MARGIN,
+	/**
+	 * Mouse is on top of the line numbers
+	 */
+	GUTTER_LINE_NUMBERS,
+	/**
+	 * Mouse is on top of the line decorations
+	 */
+	GUTTER_LINE_DECORATIONS,
+	/**
+	 * Mouse is on top of the whitespace left in the gutter by a view zone.
+	 */
+	GUTTER_VIEW_ZONE,
+	/**
+	 * Mouse is on top of text in the content.
+	 */
+	CONTENT_TEXT,
+	/**
+	 * Mouse is on top of empty space in the content (e.g. after line text or below last line)
+	 */
+	CONTENT_EMPTY,
+	/**
+	 * Mouse is on top of a view zone in the content.
+	 */
+	CONTENT_VIEW_ZONE,
+	/**
+	 * Mouse is on top of a content widget.
+	 */
+	CONTENT_WIDGET,
+	/**
+	 * Mouse is on top of the decorations overview ruler.
+	 */
+	OVERVIEW_RULER,
+	/**
+	 * Mouse is on top of a scrollbar.
+	 */
+	SCROLLBAR,
+	/**
+	 * Mouse is on top of an overlay widget.
+	 */
+	OVERLAY_WIDGET
+}
+
+/**
+ * A model for the diff editor.
+ */
+export interface IDiffEditorModel extends IEditorModel {
+	/**
+	 * Original model.
+	 */
+	original: IModel;
+	/**
+	 * Modified model.
+	 */
+	modified: IModel;
+}
+/**
+ * (Serializable) View state for the diff editor.
+ */
+export interface IDiffEditorViewState extends IEditorViewState {
+	original: ICodeEditorViewState;
+	modified: ICodeEditorViewState;
+}
+/**
+ * A change
+ */
+export interface IChange {
+	readonly originalStartLineNumber: number;
+	readonly originalEndLineNumber: number;
+	readonly modifiedStartLineNumber: number;
+	readonly modifiedEndLineNumber: number;
+}
+/**
+ * A character level change.
+ */
+export interface ICharChange extends IChange {
+	readonly originalStartColumn: number;
+	readonly originalEndColumn: number;
+	readonly modifiedStartColumn: number;
+	readonly modifiedEndColumn: number;
+}
+/**
+ * A line change
+ */
+export interface ILineChange extends IChange {
+	readonly charChanges: ICharChange[];
+}
+/**
+ * Information about a line in the diff editor
+ */
+export interface IDiffLineInformation {
+	readonly equivalentLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export namespace EditorContextKeys {
+	/**
+	 * A context key that is set when the editor's text has focus (cursor is blinking).
+	 * @internal
+	 */
+	export const TextFocus = new RawContextKey<boolean>('editorTextFocus', false);
+	/**
+	 * A context key that is set when the editor's text or an editor's widget has focus.
+	 * @internal
+	 */
+	export const Focus = new RawContextKey<boolean>('editorFocus', false);
+
+	/**
+	 * A context key that is set when the editor's text is readonly.
+	 * @internal
+	 */
+	export const ReadOnly = new RawContextKey<boolean>('editorReadonly', false);
+
+	/**
+	 * @internal
+	 */
+	export const Writable: ContextKeyExpr = ReadOnly.toNegated();
+
+	/**
+	 * A context key that is set when the editor has a non-collapsed selection.
+	 * @internal
+	 */
+	export const HasNonEmptySelection = new RawContextKey<boolean>('editorHasSelection', false);
+	/**
+	 * @internal
+	 */
+	export const HasOnlyEmptySelection: ContextKeyExpr = HasNonEmptySelection.toNegated();
+
+	/**
+	 * A context key that is set when the editor has multiple selections (multiple cursors).
+	 * @internal
+	 */
+	export const HasMultipleSelections = new RawContextKey<boolean>('editorHasMultipleSelections', false);
+	/**
+	 * @internal
+	 */
+	export const HasSingleSelection: ContextKeyExpr = HasMultipleSelections.toNegated();
+
+	/**
+	 * @internal
+	 */
+	export const TabMovesFocus = new RawContextKey<boolean>('editorTabMovesFocus', false);
+	/**
+	 * @internal
+	 */
+	export const TabDoesNotMoveFocus: ContextKeyExpr = TabMovesFocus.toNegated();
+
+	/**
+	 * A context key that is set to the language associated with the model associated with the editor.
+	 * @internal
+	 */
+	export const LanguageId = new RawContextKey<string>('editorLangId', undefined);
+
+};
+
+
+/**
+ * @internal
+ */
+export namespace ModeContextKeys {
+	/**
+	 * @internal
+	 */
+	export const hasCompletionItemProvider = new RawContextKey<boolean>('editorHasCompletionItemProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasCodeActionsProvider = new RawContextKey<boolean>('editorHasCodeActionsProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasCodeLensProvider = new RawContextKey<boolean>('editorHasCodeLensProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDefinitionProvider = new RawContextKey<boolean>('editorHasDefinitionProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasImplementationProvider = new RawContextKey<boolean>('editorHasImplementationProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasHoverProvider = new RawContextKey<boolean>('editorHasHoverProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentHighlightProvider = new RawContextKey<boolean>('editorHasDocumentHighlightProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentSymbolProvider = new RawContextKey<boolean>('editorHasDocumentSymbolProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasReferenceProvider = new RawContextKey<boolean>('editorHasReferenceProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasRenameProvider = new RawContextKey<boolean>('editorHasRenameProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentFormattingProvider = new RawContextKey<boolean>('editorHasDocumentFormattingProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasDocumentSelectionFormattingProvider = new RawContextKey<boolean>('editorHasDocumentSelectionFormattingProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const hasSignatureHelpProvider = new RawContextKey<boolean>('editorHasSignatureHelpProvider', undefined);
+	/**
+	 * @internal
+	 */
+	export const isInEmbeddedEditor = new RawContextKey<boolean>('isInEmbeddedEditor', undefined);
+}
+
+
+
+/**
+ * @internal
+ */
+export interface IConfiguration {
+	readonly onDidChange: Event<IConfigurationChangedEvent>;
+
+	readonly editor: InternalEditorOptions;
+
+	setMaxLineNumber(maxLineNumber: number): void;
+}
+
+// --- view
+
+/**
+ * @internal
+ */
+export var ViewEventNames = {
+	ModelFlushedEvent: 'modelFlushedEvent',
+	LinesDeletedEvent: 'linesDeletedEvent',
+	LinesInsertedEvent: 'linesInsertedEvent',
+	LineChangedEvent: 'lineChangedEvent',
+	TokensChangedEvent: 'tokensChangedEvent',
+	DecorationsChangedEvent: 'decorationsChangedEvent',
+	CursorPositionChangedEvent: 'cursorPositionChangedEvent',
+	CursorSelectionChangedEvent: 'cursorSelectionChangedEvent',
+	RevealRangeEvent: 'revealRangeEvent',
+	LineMappingChangedEvent: 'lineMappingChangedEvent',
+	ScrollRequestEvent: 'scrollRequestEvent'
+};
+
+export interface IScrollEvent {
+	readonly scrollTop: number;
+	readonly scrollLeft: number;
+	readonly scrollWidth: number;
+	readonly scrollHeight: number;
+
+	readonly scrollTopChanged: boolean;
+	readonly scrollLeftChanged: boolean;
+	readonly scrollWidthChanged: boolean;
+	readonly scrollHeightChanged: boolean;
+}
+
+export interface INewScrollPosition {
+	scrollLeft?: number;
+	scrollTop?: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLinesDeletedEvent {
+	/**
+	 * At what line the deletion began (inclusive).
+	 */
+	readonly fromLineNumber: number;
+	/**
+	 * At what line the deletion stopped (inclusive).
+	 */
+	readonly toLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLinesInsertedEvent {
+	/**
+	 * Before what line did the insertion begin
+	 */
+	readonly fromLineNumber: number;
+	/**
+	 * `toLineNumber` - `fromLineNumber` + 1 denotes the number of lines that were inserted
+	 */
+	readonly toLineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewLineChangedEvent {
+	/**
+	 * The line that has changed.
+	 */
+	readonly lineNumber: number;
+}
+
+/**
+ * @internal
+ */
+export interface IViewTokensChangedEvent {
+	readonly ranges: {
+		/**
+		 * Start line number of range
+		 */
+		readonly fromLineNumber: number;
+		/**
+		 * End line number of range
+		 */
+		readonly toLineNumber: number;
+	}[];
+}
+
+/**
+ * @internal
+ */
+export interface IViewDecorationsChangedEvent {
+	_videDecorationsChangedEventBrand: void;
+}
+
+/**
+ * @internal
+ */
+export interface IViewCursorPositionChangedEvent {
+	/**
+	 * Primary cursor's position.
+	 */
+	readonly position: Position;
+	/**
+	 * Secondary cursors' position.
+	 */
+	readonly secondaryPositions: Position[];
+	/**
+	 * Is the primary cursor in the editable range?
+	 */
+	readonly isInEditableRange: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewCursorSelectionChangedEvent {
+	/**
+	 * The primary selection.
+	 */
+	readonly selection: Selection;
+	/**
+	 * The secondary selections.
+	 */
+	readonly secondarySelections: Selection[];
+}
+
+/**
+ * @internal
+ */
+export interface IViewRevealRangeEvent {
+	/**
+	 * Range to be reavealed.
+	 */
+	readonly range: Range;
+
+	readonly verticalType: VerticalRevealType;
+	/**
+	 * If true: there should be a horizontal & vertical revealing
+	 * If false: there should be just a vertical revealing
+	 */
+	readonly revealHorizontal: boolean;
+	/**
+	 * If true: cursor is revealed if outside viewport
+	 */
+	readonly revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewScrollRequestEvent {
+	readonly deltaLines: number;
+	readonly revealCursor: boolean;
+}
+
+/**
+ * @internal
+ */
+export interface IViewWhitespaceViewportData {
+	readonly id: number;
+	readonly afterLineNumber: number;
+	readonly verticalOffset: number;
+	readonly height: number;
+}
+
+/**
+ * @internal
+ */
+export class Viewport {
+	readonly _viewportBrand: void;
+
+	readonly top: number;
+	readonly left: number;
+	readonly width: number;
+	readonly height: number;
+
+	constructor(top: number, left: number, width: number, height: number) {
+		this.top = top | 0;
+		this.left = left | 0;
+		this.width = width | 0;
+		this.height = height | 0;
+	}
+}
+
+/**
+ * Description of an action contribution
+ */
+export interface IActionDescriptor {
+	/**
+	 * An unique identifier of the contributed action.
+	 */
+	id: string;
+	/**
+	 * A label of the action that will be presented to the user.
+	 */
+	label: string;
+	/**
+	 * Precondition rule.
+	 */
+	precondition?: string;
+	/**
+	 * An array of keybindings for the action.
+	 */
+	keybindings?: number[];
+	/**
+	 * The keybinding rule (condition on top of precondition).
+	 */
+	keybindingContext?: string;
+	/**
+	 * Control if the action should show up in the context menu and where.
+	 * The context menu of the editor has these default:
+	 *   navigation - The navigation group comes first in all cases.
+	 *   1_modification - This group comes next and contains commands that modify your code.
+	 *   9_cutcopypaste - The last default group with the basic editing commands.
+	 * You can also create your own group.
+	 * Defaults to null (don't show in context menu).
+	 */
+	contextMenuGroupId?: string;
+	/**
+	 * Control the order in the context menu group.
+	 */
+	contextMenuOrder?: number;
+	/**
+	 * Method that will be executed when the action is triggered.
+	 * @param editor The editor instance is passed in as a convinience
+	 */
+	run(editor: ICommonCodeEditor): void | TPromise<void>;
+}
+
+/**
+ * @internal
+ */
+export type ICommonEditorContributionCtor = IConstructorSignature1<ICommonCodeEditor, IEditorContribution>;
+
+export interface IEditorAction {
+	readonly id: string;
+	readonly label: string;
+	readonly alias: string;
+	isSupported(): boolean;
+	run(): TPromise<void>;
+}
+
+/**
+ * An editor.
+ */
+export interface IEditor {
+	/**
+	 * @deprecated. Please use `onDidChangeModelContent` instead.
+	 * An event emitted when the content of the current model has changed.
+	 * @internal
+	 * @event
+	 */
+	onDidChangeModelRawContent(listener: (e: IModelContentChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the content of the current model has changed.
+	 * @event
+	 */
+	onDidChangeModelContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+	/**
+	 * An event emitted when the language of the current model has changed.
+	 * @event
+	 */
+	onDidChangeModelLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the options of the current model has changed.
+	 * @event
+	 */
+	onDidChangeModelOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
+	 * @event
+	 */
+	onDidChangeConfiguration(listener: (e: IConfigurationChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the cursor position has changed.
+	 * @event
+	 */
+	onDidChangeCursorPosition(listener: (e: ICursorPositionChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the cursor selection has changed.
+	 * @event
+	 */
+	onDidChangeCursorSelection(listener: (e: ICursorSelectionChangedEvent) => void): IDisposable;
+	/**
+	 * An event emitted when the editor has been disposed.
+	 * @event
+	 */
+	onDidDispose(listener: () => void): IDisposable;
+
+	/**
+	 * Dispose the editor.
+	 */
+	dispose(): void;
+
+	/**
+	 * Get a unique id for this editor instance.
+	 */
+	getId(): string;
+
+	/**
+	 * Get the editor type. Please see `EditorType`.
+	 * This is to avoid an instanceof check
+	 */
+	getEditorType(): string;
+
+	/**
+	 * Destroy the editor.
+	 * @internal
+	 */
+	destroy(): void;
+
+	/**
+	 * Update the editor's options after the editor has been created.
+	 */
+	updateOptions(newOptions: IEditorOptions): void;
+
+	/**
+	 * Indicates that the editor becomes visible.
+	 * @internal
+	 */
+	onVisible(): void;
+
+	/**
+	 * Indicates that the editor becomes hidden.
+	 * @internal
+	 */
+	onHide(): void;
+
+	/**
+	 * Instructs the editor to remeasure its container. This method should
+	 * be called when the container of the editor gets resized.
+	 */
+	layout(dimension?: IDimension): void;
+
+	/**
+	 * Brings browser focus to the editor text
+	 */
+	focus(): void;
+
+	/**
+	 * Returns true if this editor has keyboard focus (e.g. cursor is blinking).
+	 */
+	isFocused(): boolean;
+
+	/**
+	 * Returns all actions associated with this editor.
+	 */
+	getActions(): IEditorAction[];
+
+	/**
+	 * Returns all actions associated with this editor.
+	 */
+	getSupportedActions(): IEditorAction[];
+
+	/**
+	 * Saves current view state of the editor in a serializable object.
+	 */
+	saveViewState(): IEditorViewState;
+
+	/**
+	 * Restores the view state of the editor from a serializable object generated by `saveViewState`.
+	 */
+	restoreViewState(state: IEditorViewState): void;
+
+	/**
+	 * Given a position, returns a column number that takes tab-widths into account.
+	 */
+	getVisibleColumnFromPosition(position: IPosition): number;
+
+	/**
+	 * Returns the primary position of the cursor.
+	 */
+	getPosition(): Position;
+
+	/**
+	 * Set the primary position of the cursor. This will remove any secondary cursors.
+	 * @param position New primary cursor's position
+	 */
+	setPosition(position: IPosition): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line.
+	 */
+	revealLine(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line centered vertically.
+	 */
+	revealLineInCenter(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
+	 */
+	revealLineInCenterIfOutsideViewport(lineNumber: number): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position.
+	 */
+	revealPosition(position: IPosition): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
+	 */
+	revealPositionInCenter(position: IPosition): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
+	 */
+	revealPositionInCenterIfOutsideViewport(position: IPosition): void;
+
+	/**
+	 * Returns the primary selection of the editor.
+	 */
+	getSelection(): Selection;
+
+	/**
+	 * Returns all the selections of the editor.
+	 */
+	getSelections(): Selection[];
+
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection: IRange): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection: Range): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection: ISelection): void;
+	/**
+	 * Set the primary selection of the editor. This will remove any secondary cursors.
+	 * @param selection The new selection
+	 */
+	setSelection(selection: Selection): void;
+
+	/**
+	 * Set the selections for all the cursors of the editor.
+	 * Cursors will be removed or added, as necessary.
+	 */
+	setSelections(selections: ISelection[]): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines.
+	 */
+	revealLines(startLineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines centered vertically.
+	 */
+	revealLinesInCenter(lineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
+	 */
+	revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range.
+	 */
+	revealRange(range: IRange): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
+	 */
+	revealRangeInCenter(range: IRange): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
+	 */
+	revealRangeAtTop(range: IRange): void;
+
+	/**
+	 * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
+	 */
+	revealRangeInCenterIfOutsideViewport(range: IRange): void;
+
+
+	/**
+	 * Directly trigger a handler or an editor action.
+	 * @param source The source of the call.
+	 * @param handlerId The id of the handler or the id of a contribution.
+	 * @param payload Extra data to be sent to the handler.
+>>>>>>> .their
 	 */
 	original: ITextModel;
 	/**
@@ -419,12 +3415,22 @@
 	revealRangeInCenter(range: IRange, scrollType?: ScrollType): void;
 
 	/**
+<<<<<<< .our
 	 * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
+=======
+	 * Get information based on computed diff about a line number from the original model.
+	 * If the diff computation is not finished or the model is missing, will return null.
+>>>>>>> .their
 	 */
 	revealRangeAtTop(range: IRange, scrollType?: ScrollType): void;
 
 	/**
+<<<<<<< .our
 	 * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
+=======
+	 * Get information based on computed diff about a line number from the modified model.
+	 * If the diff computation is not finished or the model is missing, will return null.
+>>>>>>> .their
 	 */
 	revealRangeInCenterIfOutsideViewport(range: IRange, scrollType?: ScrollType): void;
 
removed in local
  base   100644 19fa5138cc46295f8b55773503d77cf3df008557 src/vs/editor/contrib/diffNavigator/common/diffNavigator.ts
  their  100644 6327fbdae6f70db1eb70f60b072204c084f450af src/vs/editor/contrib/diffNavigator/common/diffNavigator.ts
changed in both
  base   100644 d6af73f63dfe05e76122a1f8924b982f709a2572 src/vs/monaco.d.ts
  our    100644 76dcf491ff9c1973ad61bf5d423713bb1a3b4e44 src/vs/monaco.d.ts
  their  100644 d2f5eadf1e98fbba058def565d3c9804eaaa451f src/vs/monaco.d.ts
@@ -810,6 +810,7 @@
 	}
 }
 
+<<<<<<< .our
 declare namespace monaco.editor {
 
 
@@ -4119,6 +4120,3101 @@
 	//compatibility:
 	export type IReadOnlyModel = ITextModel;
 	export type IModel = ITextModel;
+=======
+declare module monaco.editor {
+
+
+    /**
+     * Create a new editor under `domElement`.
+     * `domElement` should be empty (not contain other dom nodes).
+     * The editor will read the size of `domElement`.
+     */
+    export function create(domElement: HTMLElement, options?: IEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneCodeEditor;
+
+    /**
+     * Emitted when an editor is created.
+     * Creating a diff editor might cause this listener to be invoked with the two editors.
+     * @event
+     */
+    export function onDidCreateEditor(listener: (codeEditor: ICodeEditor) => void): IDisposable;
+
+    /**
+     * Create a new diff editor under `domElement`.
+     * `domElement` should be empty (not contain other dom nodes).
+     * The editor will read the size of `domElement`.
+     */
+    export function createDiffEditor(domElement: HTMLElement, options?: IDiffEditorConstructionOptions, override?: IEditorOverrideServices): IStandaloneDiffEditor;
+
+    export interface IDiffNavigator {
+        revealFirst: boolean;
+        canNavigate(): boolean;
+        next(): void;
+        previous(): void;
+        dispose(): void;
+    }
+
+    export interface IDiffNavigatorOptions {
+        readonly followsCaret?: boolean;
+        readonly ignoreCharChanges?: boolean;
+        readonly alwaysRevealFirst?: boolean;
+    }
+
+    export function createDiffNavigator(diffEditor: IStandaloneDiffEditor, opts?: IDiffNavigatorOptions): IDiffNavigator;
+
+    /**
+     * Create a new editor model.
+     * You can specify the language that should be set for this model or let the language be inferred from the `uri`.
+     */
+    export function createModel(value: string, language?: string, uri?: Uri): IModel;
+
+    /**
+     * Change the language for a model.
+     */
+    export function setModelLanguage(model: IModel, language: string): void;
+
+    /**
+     * Set the markers for a model.
+     */
+    export function setModelMarkers(model: IModel, owner: string, markers: IMarkerData[]): void;
+
+    /**
+     * Get the model that has `uri` if it exists.
+     */
+    export function getModel(uri: Uri): IModel;
+
+    /**
+     * Get all the created models.
+     */
+    export function getModels(): IModel[];
+
+    /**
+     * Emitted when a model is created.
+     * @event
+     */
+    export function onDidCreateModel(listener: (model: IModel) => void): IDisposable;
+
+    /**
+     * Emitted right before a model is disposed.
+     * @event
+     */
+    export function onWillDisposeModel(listener: (model: IModel) => void): IDisposable;
+
+    /**
+     * Emitted when a different language is set to a model.
+     * @event
+     */
+    export function onDidChangeModelLanguage(listener: (e: {
+        readonly model: IModel;
+        readonly oldLanguage: string;
+    }) => void): IDisposable;
+
+    /**
+     * Create a new web worker that has model syncing capabilities built in.
+     * Specify an AMD module to load that will `create` an object that will be proxied.
+     */
+    export function createWebWorker<T>(opts: IWebWorkerOptions): MonacoWebWorker<T>;
+
+    /**
+     * Colorize the contents of `domNode` using attribute `data-lang`.
+     */
+    export function colorizeElement(domNode: HTMLElement, options: IColorizerElementOptions): Promise<void>;
+
+    /**
+     * Colorize `text` using language `languageId`.
+     */
+    export function colorize(text: string, languageId: string, options: IColorizerOptions): Promise<string>;
+
+    /**
+     * Colorize a line in a model.
+     */
+    export function colorizeModelLine(model: IModel, lineNumber: number, tabSize?: number): string;
+
+    /**
+     * Tokenize `text` using language `languageId`
+     */
+    export function tokenize(text: string, languageId: string): Token[][];
+
+    /**
+     * Define a new theme.
+     */
+    export function defineTheme(themeName: string, themeData: ITheme): void;
+
+    export type BuiltinTheme = 'vs' | 'vs-dark' | 'hc-black';
+
+    export interface ITheme {
+        base: BuiltinTheme;
+        inherit: boolean;
+        rules: IThemeRule[];
+    }
+
+    export interface IThemeRule {
+        token: string;
+        foreground?: string;
+        background?: string;
+        fontStyle?: string;
+    }
+
+    /**
+     * A web worker that can provide a proxy to an arbitrary file.
+     */
+    export interface MonacoWebWorker<T> {
+        /**
+         * Terminate the web worker, thus invalidating the returned proxy.
+         */
+        dispose(): void;
+        /**
+         * Get a proxy to the arbitrary loaded code.
+         */
+        getProxy(): Promise<T>;
+        /**
+         * Synchronize (send) the models at `resources` to the web worker,
+         * making them available in the monaco.worker.getMirrorModels().
+         */
+        withSyncedResources(resources: Uri[]): Promise<T>;
+    }
+
+    export interface IWebWorkerOptions {
+        /**
+         * The AMD moduleId to load.
+         * It should export a function `create` that should return the exported proxy.
+         */
+        moduleId: string;
+        /**
+         * The data to send over when calling create on the module.
+         */
+        createData?: any;
+        /**
+         * A label to be used to identify the web worker for debugging purposes.
+         */
+        label?: string;
+    }
+
+    /**
+     * The options to create an editor.
+     */
+    export interface IEditorConstructionOptions extends ICodeEditorWidgetCreationOptions {
+        /**
+         * The initial value of the auto created model in the editor.
+         * To not create automatically a model, use `model: null`.
+         */
+        value?: string;
+        /**
+         * The initial language of the auto created model in the editor.
+         * To not create automatically a model, use `model: null`.
+         */
+        language?: string;
+    }
+
+    /**
+     * The options to create a diff editor.
+     */
+    export interface IDiffEditorConstructionOptions extends IDiffEditorOptions {
+    }
+
+    export interface IStandaloneCodeEditor extends ICodeEditor {
+        addCommand(keybinding: number, handler: ICommandHandler, context: string): string;
+        createContextKey<T>(key: string, defaultValue: T): IContextKey<T>;
+        addAction(descriptor: IActionDescriptor): IDisposable;
+    }
+
+    export interface IStandaloneDiffEditor extends IDiffEditor {
+        addCommand(keybinding: number, handler: ICommandHandler, context: string): string;
+        createContextKey<T>(key: string, defaultValue: T): IContextKey<T>;
+        addAction(descriptor: IActionDescriptor): IDisposable;
+        getOriginalEditor(): IStandaloneCodeEditor;
+        getModifiedEditor(): IStandaloneCodeEditor;
+    }
+    export interface ICommandHandler {
+        (...args: any[]): void;
+    }
+
+    export interface IContextKey<T> {
+        set(value: T): void;
+        reset(): void;
+        get(): T;
+    }
+
+    export interface IEditorOverrideServices {
+    }
+
+    /**
+     * A structure defining a problem/warning/etc.
+     */
+    export interface IMarkerData {
+        code?: string;
+        severity: Severity;
+        message: string;
+        source?: string;
+        startLineNumber: number;
+        startColumn: number;
+        endLineNumber: number;
+        endColumn: number;
+    }
+
+    export interface IColorizerOptions {
+        tabSize?: number;
+    }
+
+    export interface IColorizerElementOptions extends IColorizerOptions {
+        theme?: string;
+        mimeType?: string;
+    }
+
+    export enum ScrollbarVisibility {
+        Auto = 1,
+        Hidden = 2,
+        Visible = 3,
+    }
+
+    /**
+     * Configuration options for editor scrollbars
+     */
+    export interface IEditorScrollbarOptions {
+        /**
+         * The size of arrows (if displayed).
+         * Defaults to 11.
+         */
+        arrowSize?: number;
+        /**
+         * Render vertical scrollbar.
+         * Accepted values: 'auto', 'visible', 'hidden'.
+         * Defaults to 'auto'.
+         */
+        vertical?: string;
+        /**
+         * Render horizontal scrollbar.
+         * Accepted values: 'auto', 'visible', 'hidden'.
+         * Defaults to 'auto'.
+         */
+        horizontal?: string;
+        /**
+         * Cast horizontal and vertical shadows when the content is scrolled.
+         * Defaults to true.
+         */
+        useShadows?: boolean;
+        /**
+         * Render arrows at the top and bottom of the vertical scrollbar.
+         * Defaults to false.
+         */
+        verticalHasArrows?: boolean;
+        /**
+         * Render arrows at the left and right of the horizontal scrollbar.
+         * Defaults to false.
+         */
+        horizontalHasArrows?: boolean;
+        /**
+         * Listen to mouse wheel events and react to them by scrolling.
+         * Defaults to true.
+         */
+        handleMouseWheel?: boolean;
+        /**
+         * Height in pixels for the horizontal scrollbar.
+         * Defaults to 10 (px).
+         */
+        horizontalScrollbarSize?: number;
+        /**
+         * Width in pixels for the vertical scrollbar.
+         * Defaults to 10 (px).
+         */
+        verticalScrollbarSize?: number;
+        /**
+         * Width in pixels for the vertical slider.
+         * Defaults to `verticalScrollbarSize`.
+         */
+        verticalSliderSize?: number;
+        /**
+         * Height in pixels for the horizontal slider.
+         * Defaults to `horizontalScrollbarSize`.
+         */
+        horizontalSliderSize?: number;
+    }
+
+    /**
+     * Describes how to indent wrapped lines.
+     */
+    export enum WrappingIndent {
+        /**
+         * No indentation => wrapped lines begin at column 1.
+         */
+        None = 0,
+        /**
+         * Same => wrapped lines get the same indentation as the parent.
+         */
+        Same = 1,
+        /**
+         * Indent => wrapped lines get +1 indentation as the parent.
+         */
+        Indent = 2,
+    }
+
+    export type LineNumbersOption = 'on' | 'off' | 'relative' | ((lineNumber: number) => string);
+
+    /**
+     * Configuration options for the editor.
+     */
+    export interface IEditorOptions {
+        /**
+         * Enable experimental screen reader support.
+         * Defaults to `true`.
+         */
+        experimentalScreenReader?: boolean;
+        /**
+         * The aria label for the editor's textarea (when it is focused).
+         */
+        ariaLabel?: string;
+        /**
+         * Render vertical lines at the specified columns.
+         * Defaults to empty array.
+         */
+        rulers?: number[];
+        /**
+         * A string containing the word separators used when doing word navigation.
+         * Defaults to `~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?
+         */
+        wordSeparators?: string;
+        /**
+         * Enable Linux primary clipboard.
+         * Defaults to true.
+         */
+        selectionClipboard?: boolean;
+        /**
+         * Control the rendering of line numbers.
+         * If it is a function, it will be invoked when rendering a line number and the return value will be rendered.
+         * Otherwise, if it is a truey, line numbers will be rendered normally (equivalent of using an identity function).
+         * Otherwise, line numbers will not be rendered.
+         * Defaults to true.
+         */
+        lineNumbers?: LineNumbersOption;
+        /**
+         * Should the corresponding line be selected when clicking on the line number?
+         * Defaults to true.
+         */
+        selectOnLineNumbers?: boolean;
+        /**
+         * Control the width of line numbers, by reserving horizontal space for rendering at least an amount of digits.
+         * Defaults to 5.
+         */
+        lineNumbersMinChars?: number;
+        /**
+         * Enable the rendering of the glyph margin.
+         * Defaults to true in vscode and to false in monaco-editor.
+         */
+        glyphMargin?: boolean;
+        /**
+         * The width reserved for line decorations (in px).
+         * Line decorations are placed between line numbers and the editor content.
+         * You can pass in a string in the format floating point followed by "ch". e.g. 1.3ch.
+         * Defaults to 10.
+         */
+        lineDecorationsWidth?: number | string;
+        /**
+         * When revealing the cursor, a virtual padding (px) is added to the cursor, turning it into a rectangle.
+         * This virtual padding ensures that the cursor gets revealed before hitting the edge of the viewport.
+         * Defaults to 30 (px).
+         */
+        revealHorizontalRightPadding?: number;
+        /**
+         * Render the editor selection with rounded borders.
+         * Defaults to true.
+         */
+        roundedSelection?: boolean;
+        /**
+         * Theme to be used for rendering.
+         * The current out-of-the-box available themes are: 'vs' (default), 'vs-dark', 'hc-black'.
+         * You can create custom themes via `monaco.editor.defineTheme`.
+         */
+        theme?: string;
+        /**
+         * Should the editor be read only.
+         * Defaults to false.
+         */
+        readOnly?: boolean;
+        /**
+         * Control the behavior and rendering of the scrollbars.
+         */
+        scrollbar?: IEditorScrollbarOptions;
+        /**
+         * Display overflow widgets as `fixed`.
+         * Defaults to `false`.
+         */
+        fixedOverflowWidgets?: boolean;
+        /**
+         * The number of vertical lanes the overview ruler should render.
+         * Defaults to 2.
+         */
+        overviewRulerLanes?: number;
+        /**
+         * Control the cursor animation style, possible values are 'blink', 'smooth', 'phase', 'expand' and 'solid'.
+         * Defaults to 'blink'.
+         */
+        cursorBlinking?: string;
+        /**
+         * Zoom the font in the editor when using the mouse wheel in combination with holding Ctrl.
+         * Defaults to false.
+         */
+        mouseWheelZoom?: boolean;
+        /**
+         * Control the cursor style, either 'block' or 'line'.
+         * Defaults to 'line'.
+         */
+        cursorStyle?: string;
+        /**
+         * Enable font ligatures.
+         * Defaults to false.
+         */
+        fontLigatures?: boolean;
+        /**
+         * Disable the use of `translate3d`.
+         * Defaults to false.
+         */
+        disableTranslate3d?: boolean;
+        /**
+         * Disable the optimizations for monospace fonts.
+         * Defaults to false.
+         */
+        disableMonospaceOptimizations?: boolean;
+        /**
+         * Should the cursor be hidden in the overview ruler.
+         * Defaults to false.
+         */
+        hideCursorInOverviewRuler?: boolean;
+        /**
+         * Enable that scrolling can go one screen size after the last line.
+         * Defaults to true.
+         */
+        scrollBeyondLastLine?: boolean;
+        /**
+         * Enable that the editor will install an interval to check if its container dom node size has changed.
+         * Enabling this might have a severe performance impact.
+         * Defaults to false.
+         */
+        automaticLayout?: boolean;
+        /**
+         * Control the wrapping strategy of the editor.
+         * Using -1 means no wrapping whatsoever.
+         * Using 0 means viewport width wrapping (ajusts with the resizing of the editor).
+         * Using a positive number means wrapping after a fixed number of characters.
+         * Defaults to 300.
+         */
+        wrappingColumn?: number;
+        /**
+         * Control the alternate style of viewport wrapping.
+         * When set to true viewport wrapping is used only when the window width is less than the number of columns specified in the wrappingColumn property. Has no effect if wrappingColumn is not a positive number.
+         * Defaults to false.
+         */
+        wordWrap?: boolean;
+        /**
+         * Control indentation of wrapped lines. Can be: 'none', 'same' or 'indent'.
+         * Defaults to 'same' in vscode and to 'none' in monaco-editor.
+         */
+        wrappingIndent?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced before these characters.
+         * Defaults to '{([+'.
+         */
+        wordWrapBreakBeforeCharacters?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced after these characters.
+         * Defaults to ' \t})]?|&,;'.
+         */
+        wordWrapBreakAfterCharacters?: string;
+        /**
+         * Configure word wrapping characters. A break will be introduced after these characters only if no `wordWrapBreakBeforeCharacters` or `wordWrapBreakAfterCharacters` were found.
+         * Defaults to '.'.
+         */
+        wordWrapBreakObtrusiveCharacters?: string;
+        /**
+         * Performance guard: Stop rendering a line after x characters.
+         * Defaults to 10000 if wrappingColumn is -1. Defaults to -1 if wrappingColumn is >= 0.
+         * Use -1 to never stop rendering
+         */
+        stopRenderingLineAfter?: number;
+        /**
+         * Enable hover.
+         * Defaults to true.
+         */
+        hover?: boolean;
+        /**
+         * Enable custom contextmenu.
+         * Defaults to true.
+         */
+        contextmenu?: boolean;
+        /**
+         * A multiplier to be used on the `deltaX` and `deltaY` of mouse wheel scroll events.
+         * Defaults to 1.
+         */
+        mouseWheelScrollSensitivity?: number;
+        /**
+         * Enable quick suggestions (shadow suggestions)
+         * Defaults to true.
+         */
+        quickSuggestions?: boolean;
+        /**
+         * Quick suggestions show delay (in ms)
+         * Defaults to 500 (ms)
+         */
+        quickSuggestionsDelay?: number;
+        /**
+         * Enables parameter hints
+         */
+        parameterHints?: boolean;
+        /**
+         * Render icons in suggestions box.
+         * Defaults to true.
+         */
+        iconsInSuggestions?: boolean;
+        /**
+         * Enable auto closing brackets.
+         * Defaults to true.
+         */
+        autoClosingBrackets?: boolean;
+        /**
+         * Enable format on type.
+         * Defaults to false.
+         */
+        formatOnType?: boolean;
+        /**
+         * Enable format on paste.
+         * Defaults to false.
+         */
+        formatOnPaste?: boolean;
+        /**
+         * Enable the suggestion box to pop-up on trigger characters.
+         * Defaults to true.
+         */
+        suggestOnTriggerCharacters?: boolean;
+        /**
+         * Accept suggestions on ENTER.
+         * Defaults to true.
+         */
+        acceptSuggestionOnEnter?: boolean;
+        /**
+         * Accept suggestions on provider defined characters.
+         * Defaults to true.
+         */
+        acceptSuggestionOnCommitCharacter?: boolean;
+        /**
+         * Enable snippet suggestions. Default to 'true'.
+         */
+        snippetSuggestions?: 'top' | 'bottom' | 'inline' | 'none';
+        /**
+         * Copying without a selection copies the current line.
+         */
+        emptySelectionClipboard?: boolean;
+        /**
+         * Enable tab completion. Defaults to 'false'
+         */
+        tabCompletion?: boolean;
+        /**
+         * Enable word based suggestions. Defaults to 'true'
+         */
+        wordBasedSuggestions?: boolean;
+        /**
+         * The font size for the suggest widget.
+         * Defaults to the editor font size.
+         */
+        suggestFontSize?: number;
+        /**
+         * The line height for the suggest widget.
+         * Defaults to the editor line height.
+         */
+        suggestLineHeight?: number;
+        /**
+         * Enable selection highlight.
+         * Defaults to true.
+         */
+        selectionHighlight?: boolean;
+        /**
+         * Show code lens
+         * Defaults to true.
+         */
+        codeLens?: boolean;
+        /**
+         * Enable code folding
+         * Defaults to true in vscode and to false in monaco-editor.
+         */
+        folding?: boolean;
+        /**
+         * Enable rendering of whitespace.
+         * Defaults to none.
+         */
+        renderWhitespace?: 'none' | 'boundary' | 'all';
+        /**
+         * Enable rendering of control characters.
+         * Defaults to false.
+         */
+        renderControlCharacters?: boolean;
+        /**
+         * Enable rendering of indent guides.
+         * Defaults to false.
+         */
+        renderIndentGuides?: boolean;
+        /**
+         * Enable rendering of current line highlight.
+         * Defaults to all.
+         */
+        renderLineHighlight?: 'none' | 'gutter' | 'line' | 'all';
+        /**
+         * Inserting and deleting whitespace follows tab stops.
+         */
+        useTabStops?: boolean;
+        /**
+         * The font family
+         */
+        fontFamily?: string;
+        /**
+         * The font weight
+         */
+        fontWeight?: 'normal' | 'bold' | 'bolder' | 'lighter' | 'initial' | 'inherit' | '100' | '200' | '300' | '400' | '500' | '600' | '700' | '800' | '900';
+        /**
+         * The font size
+         */
+        fontSize?: number;
+        /**
+         * The line height
+         */
+        lineHeight?: number;
+    }
+
+    /**
+     * Configuration options for the diff editor.
+     */
+    export interface IDiffEditorOptions extends IEditorOptions {
+        /**
+         * Allow the user to resize the diff editor split view.
+         * Defaults to true.
+         */
+        enableSplitViewResizing?: boolean;
+        /**
+         * Render the differences in two side-by-side editors.
+         * Defaults to true.
+         */
+        renderSideBySide?: boolean;
+        /**
+         * Compute the diff by ignoring leading/trailing whitespace
+         * Defaults to true.
+         */
+        ignoreTrimWhitespace?: boolean;
+        /**
+         * Render +/- indicators for added/deleted changes.
+         * Defaults to true.
+         */
+        renderIndicators?: boolean;
+        /**
+         * Original model should be editable?
+         * Defaults to false.
+         */
+        originalEditable?: boolean;
+    }
+
+    export class InternalEditorScrollbarOptions {
+        readonly _internalEditorScrollbarOptionsBrand: void;
+        readonly arrowSize: number;
+        readonly vertical: ScrollbarVisibility;
+        readonly horizontal: ScrollbarVisibility;
+        readonly useShadows: boolean;
+        readonly verticalHasArrows: boolean;
+        readonly horizontalHasArrows: boolean;
+        readonly handleMouseWheel: boolean;
+        readonly horizontalScrollbarSize: number;
+        readonly horizontalSliderSize: number;
+        readonly verticalScrollbarSize: number;
+        readonly verticalSliderSize: number;
+        readonly mouseWheelScrollSensitivity: number;
+    }
+
+    export class EditorWrappingInfo {
+        readonly _editorWrappingInfoBrand: void;
+        readonly isViewportWrapping: boolean;
+        readonly wrappingColumn: number;
+        readonly wrappingIndent: WrappingIndent;
+        readonly wordWrapBreakBeforeCharacters: string;
+        readonly wordWrapBreakAfterCharacters: string;
+        readonly wordWrapBreakObtrusiveCharacters: string;
+    }
+
+    export class InternalEditorViewOptions {
+        readonly _internalEditorViewOptionsBrand: void;
+        readonly theme: string;
+        readonly canUseTranslate3d: boolean;
+        readonly disableMonospaceOptimizations: boolean;
+        readonly experimentalScreenReader: boolean;
+        readonly rulers: number[];
+        readonly ariaLabel: string;
+        readonly renderLineNumbers: boolean;
+        readonly renderCustomLineNumbers: (lineNumber: number) => string;
+        readonly renderRelativeLineNumbers: boolean;
+        readonly selectOnLineNumbers: boolean;
+        readonly glyphMargin: boolean;
+        readonly revealHorizontalRightPadding: number;
+        readonly roundedSelection: boolean;
+        readonly overviewRulerLanes: number;
+        readonly cursorBlinking: TextEditorCursorBlinkingStyle;
+        readonly mouseWheelZoom: boolean;
+        readonly cursorStyle: TextEditorCursorStyle;
+        readonly hideCursorInOverviewRuler: boolean;
+        readonly scrollBeyondLastLine: boolean;
+        readonly editorClassName: string;
+        readonly stopRenderingLineAfter: number;
+        readonly renderWhitespace: 'none' | 'boundary' | 'all';
+        readonly renderControlCharacters: boolean;
+        readonly renderIndentGuides: boolean;
+        readonly renderLineHighlight: 'none' | 'gutter' | 'line' | 'all';
+        readonly scrollbar: InternalEditorScrollbarOptions;
+        readonly fixedOverflowWidgets: boolean;
+    }
+
+    export interface IViewConfigurationChangedEvent {
+        readonly theme: boolean;
+        readonly canUseTranslate3d: boolean;
+        readonly disableMonospaceOptimizations: boolean;
+        readonly experimentalScreenReader: boolean;
+        readonly rulers: boolean;
+        readonly ariaLabel: boolean;
+        readonly renderLineNumbers: boolean;
+        readonly renderCustomLineNumbers: boolean;
+        readonly renderRelativeLineNumbers: boolean;
+        readonly selectOnLineNumbers: boolean;
+        readonly glyphMargin: boolean;
+        readonly revealHorizontalRightPadding: boolean;
+        readonly roundedSelection: boolean;
+        readonly overviewRulerLanes: boolean;
+        readonly cursorBlinking: boolean;
+        readonly mouseWheelZoom: boolean;
+        readonly cursorStyle: boolean;
+        readonly hideCursorInOverviewRuler: boolean;
+        readonly scrollBeyondLastLine: boolean;
+        readonly editorClassName: boolean;
+        readonly stopRenderingLineAfter: boolean;
+        readonly renderWhitespace: boolean;
+        readonly renderControlCharacters: boolean;
+        readonly renderIndentGuides: boolean;
+        readonly renderLineHighlight: boolean;
+        readonly scrollbar: boolean;
+        readonly fixedOverflowWidgets: boolean;
+    }
+
+    export class EditorContribOptions {
+        readonly selectionClipboard: boolean;
+        readonly hover: boolean;
+        readonly contextmenu: boolean;
+        readonly quickSuggestions: boolean;
+        readonly quickSuggestionsDelay: number;
+        readonly parameterHints: boolean;
+        readonly iconsInSuggestions: boolean;
+        readonly formatOnType: boolean;
+        readonly formatOnPaste: boolean;
+        readonly suggestOnTriggerCharacters: boolean;
+        readonly acceptSuggestionOnEnter: boolean;
+        readonly acceptSuggestionOnCommitCharacter: boolean;
+        readonly snippetSuggestions: 'top' | 'bottom' | 'inline' | 'none';
+        readonly emptySelectionClipboard: boolean;
+        readonly tabCompletion: boolean;
+        readonly wordBasedSuggestions: boolean;
+        readonly suggestFontSize: number;
+        readonly suggestLineHeight: number;
+        readonly selectionHighlight: boolean;
+        readonly codeLens: boolean;
+        readonly folding: boolean;
+    }
+
+    /**
+     * Internal configuration options (transformed or computed) for the editor.
+     */
+    export class InternalEditorOptions {
+        readonly _internalEditorOptionsBrand: void;
+        readonly lineHeight: number;
+        readonly readOnly: boolean;
+        readonly wordSeparators: string;
+        readonly autoClosingBrackets: boolean;
+        readonly useTabStops: boolean;
+        readonly tabFocusMode: boolean;
+        readonly layoutInfo: EditorLayoutInfo;
+        readonly fontInfo: FontInfo;
+        readonly viewInfo: InternalEditorViewOptions;
+        readonly wrappingInfo: EditorWrappingInfo;
+        readonly contribInfo: EditorContribOptions;
+    }
+
+    /**
+     * An event describing that the configuration of the editor has changed.
+     */
+    export interface IConfigurationChangedEvent {
+        readonly lineHeight: boolean;
+        readonly readOnly: boolean;
+        readonly wordSeparators: boolean;
+        readonly autoClosingBrackets: boolean;
+        readonly useTabStops: boolean;
+        readonly tabFocusMode: boolean;
+        readonly layoutInfo: boolean;
+        readonly fontInfo: boolean;
+        readonly viewInfo: IViewConfigurationChangedEvent;
+        readonly wrappingInfo: boolean;
+        readonly contribInfo: boolean;
+    }
+
+    /**
+     * Vertical Lane in the overview ruler of the editor.
+     */
+    export enum OverviewRulerLane {
+        Left = 1,
+        Center = 2,
+        Right = 4,
+        Full = 7,
+    }
+
+    /**
+     * Options for rendering a model decoration in the overview ruler.
+     */
+    export interface IModelDecorationOverviewRulerOptions {
+        /**
+         * CSS color to render in the overview ruler.
+         * e.g.: rgba(100, 100, 100, 0.5)
+         */
+        color: string;
+        /**
+         * CSS color to render in the overview ruler.
+         * e.g.: rgba(100, 100, 100, 0.5)
+         */
+        darkColor: string;
+        /**
+         * The position in the overview ruler.
+         */
+        position: OverviewRulerLane;
+    }
+
+    /**
+     * Options for a model decoration.
+     */
+    export interface IModelDecorationOptions {
+        /**
+         * Customize the growing behaviour of the decoration when typing at the edges of the decoration.
+         * Defaults to TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges
+         */
+        stickiness?: TrackedRangeStickiness;
+        /**
+         * CSS class name describing the decoration.
+         */
+        className?: string;
+        /**
+         * Message to be rendered when hovering over the glyph margin decoration.
+         */
+        glyphMarginHoverMessage?: MarkedString | MarkedString[];
+        /**
+         * Array of MarkedString to render as the decoration message.
+         */
+        hoverMessage?: MarkedString | MarkedString[];
+        /**
+         * Should the decoration expand to encompass a whole line.
+         */
+        isWholeLine?: boolean;
+        /**
+         * @deprecated : Use `overviewRuler` instead
+         */
+        showInOverviewRuler?: string;
+        /**
+         * If set, render this decoration in the overview ruler.
+         */
+        overviewRuler?: IModelDecorationOverviewRulerOptions;
+        /**
+         * If set, the decoration will be rendered in the glyph margin with this CSS class name.
+         */
+        glyphMarginClassName?: string;
+        /**
+         * If set, the decoration will be rendered in the lines decorations with this CSS class name.
+         */
+        linesDecorationsClassName?: string;
+        /**
+         * If set, the decoration will be rendered in the margin (covering its full width) with this CSS class name.
+         */
+        marginClassName?: string;
+        /**
+         * If set, the decoration will be rendered inline with the text with this CSS class name.
+         * Please use this only for CSS rules that must impact the text. For example, use `className`
+         * to have a background color decoration.
+         */
+        inlineClassName?: string;
+        /**
+         * If set, the decoration will be rendered before the text with this CSS class name.
+         */
+        beforeContentClassName?: string;
+        /**
+         * If set, the decoration will be rendered after the text with this CSS class name.
+         */
+        afterContentClassName?: string;
+    }
+
+    /**
+     * New model decorations.
+     */
+    export interface IModelDeltaDecoration {
+        /**
+         * Range that this decoration covers.
+         */
+        range: IRange;
+        /**
+         * Options associated with this decoration.
+         */
+        options: IModelDecorationOptions;
+    }
+
+    /**
+     * A decoration in the model.
+     */
+    export interface IModelDecoration {
+        /**
+         * Identifier for a decoration.
+         */
+        readonly id: string;
+        /**
+         * Identifier for a decoration's owener.
+         */
+        readonly ownerId: number;
+        /**
+         * Range that this decoration covers.
+         */
+        readonly range: Range;
+        /**
+         * Options associated with this decoration.
+         */
+        readonly options: IModelDecorationOptions;
+        /**
+         * A flag describing if this is a problem decoration (e.g. warning/error).
+         */
+        readonly isForValidation: boolean;
+    }
+
+    /**
+     * Word inside a model.
+     */
+    export interface IWordAtPosition {
+        /**
+         * The word.
+         */
+        readonly word: string;
+        /**
+         * The column where the word starts.
+         */
+        readonly startColumn: number;
+        /**
+         * The column where the word ends.
+         */
+        readonly endColumn: number;
+    }
+
+    /**
+     * End of line character preference.
+     */
+    export enum EndOfLinePreference {
+        /**
+         * Use the end of line character identified in the text buffer.
+         */
+        TextDefined = 0,
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 1,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 2,
+    }
+
+    /**
+     * The default end of line to use when instantiating models.
+     */
+    export enum DefaultEndOfLine {
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 1,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 2,
+    }
+
+    /**
+     * End of line character preference.
+     */
+    export enum EndOfLineSequence {
+        /**
+         * Use line feed (\n) as the end of line character.
+         */
+        LF = 0,
+        /**
+         * Use carriage return and line feed (\r\n) as the end of line character.
+         */
+        CRLF = 1,
+    }
+
+    /**
+     * An identifier for a single edit operation.
+     */
+    export interface ISingleEditOperationIdentifier {
+        /**
+         * Identifier major
+         */
+        major: number;
+        /**
+         * Identifier minor
+         */
+        minor: number;
+    }
+
+    /**
+     * A builder and helper for edit operations for a command.
+     */
+    export interface IEditOperationBuilder {
+        /**
+         * Add a new edit operation (a replace operation).
+         * @param range The range to replace (delete). May be empty to represent a simple insert.
+         * @param text The text to replace with. May be null to represent a simple delete.
+         */
+        addEditOperation(range: Range, text: string): void;
+        /**
+         * Track `selection` when applying edit operations.
+         * A best effort will be made to not grow/expand the selection.
+         * An empty selection will clamp to a nearby character.
+         * @param selection The selection to track.
+         * @param trackPreviousOnEmpty If set, and the selection is empty, indicates whether the selection
+         *           should clamp to the previous or the next character.
+         * @return A unique identifer.
+         */
+        trackSelection(selection: Selection, trackPreviousOnEmpty?: boolean): string;
+    }
+
+    /**
+     * A helper for computing cursor state after a command.
+     */
+    export interface ICursorStateComputerData {
+        /**
+         * Get the inverse edit operations of the added edit operations.
+         */
+        getInverseEditOperations(): IIdentifiedSingleEditOperation[];
+        /**
+         * Get a previously tracked selection.
+         * @param id The unique identifier returned by `trackSelection`.
+         * @return The selection.
+         */
+        getTrackedSelection(id: string): Selection;
+    }
+
+    /**
+     * A command that modifies text / cursor state on a model.
+     */
+    export interface ICommand {
+        /**
+         * Get the edit operations needed to execute this command.
+         * @param model The model the command will execute on.
+         * @param builder A helper to collect the needed edit operations and to track selections.
+         */
+        getEditOperations(model: ITokenizedModel, builder: IEditOperationBuilder): void;
+        /**
+         * Compute the cursor state after the edit operations were applied.
+         * @param model The model the commad has executed on.
+         * @param helper A helper to get inverse edit operations and to get previously tracked selections.
+         * @return The cursor state after the command executed.
+         */
+        computeCursorState(model: ITokenizedModel, helper: ICursorStateComputerData): Selection;
+    }
+
+    /**
+     * A single edit operation, that acts as a simple replace.
+     * i.e. Replace text at `range` with `text` in model.
+     */
+    export interface ISingleEditOperation {
+        /**
+         * The range to replace. This can be empty to emulate a simple insert.
+         */
+        range: IRange;
+        /**
+         * The text to replace with. This can be null to emulate a simple delete.
+         */
+        text: string;
+        /**
+         * This indicates that this operation has "insert" semantics.
+         * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+         */
+        forceMoveMarkers?: boolean;
+    }
+
+    /**
+     * A single edit operation, that has an identifier.
+     */
+    export interface IIdentifiedSingleEditOperation {
+        /**
+         * An identifier associated with this single edit operation.
+         */
+        identifier: ISingleEditOperationIdentifier;
+        /**
+         * The range to replace. This can be empty to emulate a simple insert.
+         */
+        range: Range;
+        /**
+         * The text to replace with. This can be null to emulate a simple delete.
+         */
+        text: string;
+        /**
+         * This indicates that this operation has "insert" semantics.
+         * i.e. forceMoveMarkers = true => if `range` is collapsed, all markers at the position will be moved.
+         */
+        forceMoveMarkers: boolean;
+        /**
+         * This indicates that this operation is inserting automatic whitespace
+         * that can be removed on next model edit operation if `config.trimAutoWhitespace` is true.
+         */
+        isAutoWhitespaceEdit?: boolean;
+    }
+
+    /**
+     * A callback that can compute the cursor state after applying a series of edit operations.
+     */
+    export interface ICursorStateComputer {
+        /**
+         * A callback that can compute the resulting cursors state after some edit operations have been executed.
+         */
+        (inverseEditOperations: IIdentifiedSingleEditOperation[]): Selection[];
+    }
+
+    export class TextModelResolvedOptions {
+        _textModelResolvedOptionsBrand: void;
+        readonly tabSize: number;
+        readonly insertSpaces: boolean;
+        readonly defaultEOL: DefaultEndOfLine;
+        readonly trimAutoWhitespace: boolean;
+    }
+
+    export interface ITextModelUpdateOptions {
+        tabSize?: number;
+        insertSpaces?: boolean;
+        trimAutoWhitespace?: boolean;
+    }
+
+    export interface IModelOptionsChangedEvent {
+        readonly tabSize: boolean;
+        readonly insertSpaces: boolean;
+        readonly trimAutoWhitespace: boolean;
+    }
+
+    /**
+     * A textual read-only model.
+     */
+    export interface ITextModel {
+        getOptions(): TextModelResolvedOptions;
+        /**
+         * Get the current version id of the model.
+         * Anytime a change happens to the model (even undo/redo),
+         * the version id is incremented.
+         */
+        getVersionId(): number;
+        /**
+         * Get the alternative version id of the model.
+         * This alternative version id is not always incremented,
+         * it will return the same values in the case of undo-redo.
+         */
+        getAlternativeVersionId(): number;
+        /**
+         * Replace the entire text buffer value contained in this model.
+         */
+        setValue(newValue: string): void;
+        /**
+         * Get the text stored in this model.
+         * @param eol The end of line character preference. Defaults to `EndOfLinePreference.TextDefined`.
+         * @param preserverBOM Preserve a BOM character if it was detected when the model was constructed.
+         * @return The text.
+         */
+        getValue(eol?: EndOfLinePreference, preserveBOM?: boolean): string;
+        /**
+         * Get the length of the text stored in this model.
+         */
+        getValueLength(eol?: EndOfLinePreference, preserveBOM?: boolean): number;
+        /**
+         * Get the text in a certain range.
+         * @param range The range describing what text to get.
+         * @param eol The end of line character preference. This will only be used for multiline ranges. Defaults to `EndOfLinePreference.TextDefined`.
+         * @return The text.
+         */
+        getValueInRange(range: IRange, eol?: EndOfLinePreference): string;
+        /**
+         * Get the length of text in a certain range.
+         * @param range The range describing what text length to get.
+         * @return The text length.
+         */
+        getValueLengthInRange(range: IRange): number;
+        /**
+         * Get the number of lines in the model.
+         */
+        getLineCount(): number;
+        /**
+         * Get the text for a certain line.
+         */
+        getLineContent(lineNumber: number): string;
+        /**
+         * Get the text for all lines.
+         */
+        getLinesContent(): string[];
+        /**
+         * Get the end of line sequence predominantly used in the text buffer.
+         * @return EOL char sequence (e.g.: '\n' or '\r\n').
+         */
+        getEOL(): string;
+        /**
+         * Change the end of line sequence used in the text buffer.
+         */
+        setEOL(eol: EndOfLineSequence): void;
+        /**
+         * Get the minimum legal column for line at `lineNumber`
+         */
+        getLineMinColumn(lineNumber: number): number;
+        /**
+         * Get the maximum legal column for line at `lineNumber`
+         */
+        getLineMaxColumn(lineNumber: number): number;
+        /**
+         * Returns the column before the first non whitespace character for line at `lineNumber`.
+         * Returns 0 if line is empty or contains only whitespace.
+         */
+        getLineFirstNonWhitespaceColumn(lineNumber: number): number;
+        /**
+         * Returns the column after the last non whitespace character for line at `lineNumber`.
+         * Returns 0 if line is empty or contains only whitespace.
+         */
+        getLineLastNonWhitespaceColumn(lineNumber: number): number;
+        /**
+         * Create a valid position,
+         */
+        validatePosition(position: IPosition): Position;
+        /**
+         * Advances the given position by the given offest (negative offsets are also accepted)
+         * and returns it as a new valid position.
+         *
+         * If the offset and position are such that their combination goes beyond the beginning or
+         * end of the model, throws an exception.
+         *
+         * If the ofsset is such that the new position would be in the middle of a multi-byte
+         * line terminator, throws an exception.
+         */
+        modifyPosition(position: IPosition, offset: number): Position;
+        /**
+         * Create a valid range.
+         */
+        validateRange(range: IRange): Range;
+        /**
+         * Converts the position to a zero-based offset.
+         *
+         * The position will be [adjusted](#TextDocument.validatePosition).
+         *
+         * @param position A position.
+         * @return A valid zero-based offset.
+         */
+        getOffsetAt(position: IPosition): number;
+        /**
+         * Converts a zero-based offset to a position.
+         *
+         * @param offset A zero-based offset.
+         * @return A valid [position](#Position).
+         */
+        getPositionAt(offset: number): Position;
+        /**
+         * Get a range covering the entire model
+         */
+        getFullModelRange(): Range;
+        /**
+         * Returns iff the model was disposed or not.
+         */
+        isDisposed(): boolean;
+        /**
+         * Search the model.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchOnlyEditableRange Limit the searching to only search inside the editable range of the model.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param captureMatches The result will contain the captured groups.
+         * @param limitResultCount Limit the number of results
+         * @return The ranges where the matches are. It is empty if not matches have been found.
+         */
+        findMatches(searchString: string, searchOnlyEditableRange: boolean, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
+        /**
+         * Search the model.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchScope Limit the searching to only search inside this range.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param captureMatches The result will contain the captured groups.
+         * @param limitResultCount Limit the number of results
+         * @return The ranges where the matches are. It is empty if no matches have been found.
+         */
+        findMatches(searchString: string, searchScope: IRange, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean, limitResultCount?: number): FindMatch[];
+        /**
+         * Search the model for the next match. Loops to the beginning of the model if needed.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchStart Start the searching at the specified position.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param captureMatches The result will contain the captured groups.
+         * @return The range where the next match is. It is null if no next match has been found.
+         */
+        findNextMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
+        /**
+         * Search the model for the previous match. Loops to the end of the model if needed.
+         * @param searchString The string used to search. If it is a regular expression, set `isRegex` to true.
+         * @param searchStart Start the searching at the specified position.
+         * @param isRegex Used to indicate that `searchString` is a regular expression.
+         * @param matchCase Force the matching to match lower/upper case exactly.
+         * @param wholeWord Force the matching to match entire words only.
+         * @param captureMatches The result will contain the captured groups.
+         * @return The range where the previous match is. It is null if no previous match has been found.
+         */
+        findPreviousMatch(searchString: string, searchStart: IPosition, isRegex: boolean, matchCase: boolean, wholeWord: boolean, captureMatches: boolean): FindMatch;
+    }
+
+    export class FindMatch {
+        _findMatchBrand: void;
+        readonly range: Range;
+        readonly matches: string[];
+    }
+
+    export interface IReadOnlyModel extends ITextModel {
+        /**
+         * Gets the resource associated with this editor model.
+         */
+        readonly uri: Uri;
+        /**
+         * Get the language associated with this model.
+         */
+        getModeId(): string;
+        /**
+         * Get the word under or besides `position`.
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Might be null.
+         */
+        getWordAtPosition(position: IPosition): IWordAtPosition;
+        /**
+         * Get the word under or besides `position` trimmed to `position`.column
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Will never be null.
+         */
+        getWordUntilPosition(position: IPosition): IWordAtPosition;
+    }
+
+    /**
+     * A model that is tokenized.
+     */
+    export interface ITokenizedModel extends ITextModel {
+        /**
+         * Get the language associated with this model.
+         */
+        getModeId(): string;
+        /**
+         * Get the word under or besides `position`.
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Might be null.
+         */
+        getWordAtPosition(position: IPosition): IWordAtPosition;
+        /**
+         * Get the word under or besides `position` trimmed to `position`.column
+         * @param position The position to look for a word.
+         * @param skipSyntaxTokens Ignore syntax tokens, as identified by the mode.
+         * @return The word under or besides `position`. Will never be null.
+         */
+        getWordUntilPosition(position: IPosition): IWordAtPosition;
+    }
+
+    /**
+     * A model that can track markers.
+     */
+    export interface ITextModelWithMarkers extends ITextModel {
+    }
+
+    /**
+     * Describes the behaviour of decorations when typing/editing near their edges.
+     */
+    export enum TrackedRangeStickiness {
+        AlwaysGrowsWhenTypingAtEdges = 0,
+        NeverGrowsWhenTypingAtEdges = 1,
+        GrowsOnlyWhenTypingBefore = 2,
+        GrowsOnlyWhenTypingAfter = 3,
+    }
+
+    /**
+     * A model that can have decorations.
+     */
+    export interface ITextModelWithDecorations {
+        /**
+         * Perform a minimum ammount of operations, in order to transform the decorations
+         * identified by `oldDecorations` to the decorations described by `newDecorations`
+         * and returns the new identifiers associated with the resulting decorations.
+         *
+         * @param oldDecorations Array containing previous decorations identifiers.
+         * @param newDecorations Array describing what decorations should result after the call.
+         * @param ownerId Identifies the editor id in which these decorations should appear. If no `ownerId` is provided, the decorations will appear in all editors that attach this model.
+         * @return An array containing the new decorations identifiers.
+         */
+        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[], ownerId?: number): string[];
+        /**
+         * Get the options associated with a decoration.
+         * @param id The decoration id.
+         * @return The decoration options or null if the decoration was not found.
+         */
+        getDecorationOptions(id: string): IModelDecorationOptions;
+        /**
+         * Get the range associated with a decoration.
+         * @param id The decoration id.
+         * @return The decoration range or null if the decoration was not found.
+         */
+        getDecorationRange(id: string): Range;
+        /**
+         * Gets all the decorations for the line `lineNumber` as an array.
+         * @param lineNumber The line number
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getLineDecorations(lineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the decorations for the lines between `startLineNumber` and `endLineNumber` as an array.
+         * @param startLineNumber The start line number
+         * @param endLineNumber The end line number
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getLinesDecorations(startLineNumber: number, endLineNumber: number, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the deocorations in a range as an array. Only `startLineNumber` and `endLineNumber` from `range` are used for filtering.
+         * So for now it returns all the decorations on the same line as `range`.
+         * @param range The range to search in
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         * @return An array with the decorations
+         */
+        getDecorationsInRange(range: IRange, ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+        /**
+         * Gets all the decorations as an array.
+         * @param ownerId If set, it will ignore decorations belonging to other owners.
+         * @param filterOutValidation If set, it will ignore decorations specific to validation (i.e. warnings, errors).
+         */
+        getAllDecorations(ownerId?: number, filterOutValidation?: boolean): IModelDecoration[];
+    }
+
+    /**
+     * An editable text model.
+     */
+    export interface IEditableTextModel extends ITextModelWithMarkers {
+        /**
+         * Normalize a string containing whitespace according to indentation rules (converts to spaces or to tabs).
+         */
+        normalizeIndentation(str: string): string;
+        /**
+         * Get what is considered to be one indent (e.g. a tab character or 4 spaces, etc.).
+         */
+        getOneIndent(): string;
+        /**
+         * Change the options of this model.
+         */
+        updateOptions(newOpts: ITextModelUpdateOptions): void;
+        /**
+         * Detect the indentation options for this model from its content.
+         */
+        detectIndentation(defaultInsertSpaces: boolean, defaultTabSize: number): void;
+        /**
+         * Push a stack element onto the undo stack. This acts as an undo/redo point.
+         * The idea is to use `pushEditOperations` to edit the model and then to
+         * `pushStackElement` to create an undo/redo stop point.
+         */
+        pushStackElement(): void;
+        /**
+         * Push edit operations, basically editing the model. This is the preferred way
+         * of editing the model. The edit operations will land on the undo stack.
+         * @param beforeCursorState The cursor state before the edit operaions. This cursor state will be returned when `undo` or `redo` are invoked.
+         * @param editOperations The edit operations.
+         * @param cursorStateComputer A callback that can compute the resulting cursors state after the edit operations have been executed.
+         * @return The cursor state returned by the `cursorStateComputer`.
+         */
+        pushEditOperations(beforeCursorState: Selection[], editOperations: IIdentifiedSingleEditOperation[], cursorStateComputer: ICursorStateComputer): Selection[];
+        /**
+         * Edit the model without adding the edits to the undo stack.
+         * This can have dire consequences on the undo stack! See @pushEditOperations for the preferred way.
+         * @param operations The edit operations.
+         * @return The inverse edit operations, that, when applied, will bring the model back to the previous state.
+         */
+        applyEdits(operations: IIdentifiedSingleEditOperation[]): IIdentifiedSingleEditOperation[];
+    }
+
+    /**
+     * A model.
+     */
+    export interface IModel extends IReadOnlyModel, IEditableTextModel, ITextModelWithMarkers, ITokenizedModel, ITextModelWithDecorations, IEditorModel {
+        /**
+         * An event emitted when the contents of the model have changed.
+         * @event
+         */
+        onDidChangeContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+        /**
+         * An event emitted when decorations of the model have changed.
+         * @event
+         */
+        onDidChangeDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the model options have changed.
+         * @event
+         */
+        onDidChangeOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the language associated with the model has changed.
+         * @event
+         */
+        onDidChangeLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted right before disposing the model.
+         * @event
+         */
+        onWillDispose(listener: () => void): IDisposable;
+        /**
+         * A unique identifier associated with this model.
+         */
+        readonly id: string;
+        /**
+         * Destroy this model. This will unbind the model from the mode
+         * and make all necessary clean-up to release this object to the GC.
+         */
+        dispose(): void;
+    }
+
+    /**
+     * An event describing that the current mode associated with a model has changed.
+     */
+    export interface IModelLanguageChangedEvent {
+        /**
+         * Previous language
+         */
+        readonly oldLanguage: string;
+        /**
+         * New language
+         */
+        readonly newLanguage: string;
+    }
+
+    /**
+     * An event describing a change in the text of a model.
+     */
+    export interface IModelContentChangedEvent2 {
+        /**
+         * The range that got replaced.
+         */
+        readonly range: IRange;
+        /**
+         * The length of the range that got replaced.
+         */
+        readonly rangeLength: number;
+        /**
+         * The new text for the range.
+         */
+        readonly text: string;
+        /**
+         * The (new) end-of-line character.
+         */
+        readonly eol: string;
+        /**
+         * The new version id the model has transitioned to.
+         */
+        versionId: number;
+        /**
+         * Flag that indicates that this event was generated while undoing.
+         */
+        readonly isUndoing: boolean;
+        /**
+         * Flag that indicates that this event was generated while redoing.
+         */
+        readonly isRedoing: boolean;
+    }
+
+    /**
+     * An event describing that model decorations have changed.
+     */
+    export interface IModelDecorationsChangedEvent {
+        /**
+         * Lists of ids for added decorations.
+         */
+        readonly addedDecorations: string[];
+        /**
+         * Lists of ids for changed decorations.
+         */
+        readonly changedDecorations: string[];
+        /**
+         * List of ids for removed decorations.
+         */
+        readonly removedDecorations: string[];
+    }
+
+    /**
+     * An event describing that some ranges of lines have been tokenized (their tokens have changed).
+     */
+    export interface IModelTokensChangedEvent {
+        readonly ranges: {
+            /**
+             * The start of the range (inclusive)
+             */
+            readonly fromLineNumber: number;
+            /**
+             * The end of the range (inclusive)
+             */
+            readonly toLineNumber: number;
+        }[];
+    }
+
+    /**
+     * Describes the reason the cursor has changed its position.
+     */
+    export enum CursorChangeReason {
+        /**
+         * Unknown or not set.
+         */
+        NotSet = 0,
+        /**
+         * A `model.setValue()` was called.
+         */
+        ContentFlush = 1,
+        /**
+         * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
+         */
+        RecoverFromMarkers = 2,
+        /**
+         * There was an explicit user gesture.
+         */
+        Explicit = 3,
+        /**
+         * There was a Paste.
+         */
+        Paste = 4,
+        /**
+         * There was an Undo.
+         */
+        Undo = 5,
+        /**
+         * There was a Redo.
+         */
+        Redo = 6,
+    }
+
+    /**
+     * An event describing that the cursor position has changed.
+     */
+    export interface ICursorPositionChangedEvent {
+        /**
+         * Primary cursor's position.
+         */
+        readonly position: Position;
+        /**
+         * Primary cursor's view position
+         */
+        readonly viewPosition: Position;
+        /**
+         * Secondary cursors' position.
+         */
+        readonly secondaryPositions: Position[];
+        /**
+         * Secondary cursors' view position.
+         */
+        readonly secondaryViewPositions: Position[];
+        /**
+         * Reason.
+         */
+        readonly reason: CursorChangeReason;
+        /**
+         * Source of the call that caused the event.
+         */
+        readonly source: string;
+        /**
+         * Is the primary cursor in the editable range?
+         */
+        readonly isInEditableRange: boolean;
+    }
+
+    /**
+     * An event describing that the cursor selection has changed.
+     */
+    export interface ICursorSelectionChangedEvent {
+        /**
+         * The primary selection.
+         */
+        readonly selection: Selection;
+        /**
+         * The primary selection in view coordinates.
+         */
+        readonly viewSelection: Selection;
+        /**
+         * The secondary selections.
+         */
+        readonly secondarySelections: Selection[];
+        /**
+         * The secondary selections in view coordinates.
+         */
+        readonly secondaryViewSelections: Selection[];
+        /**
+         * Source of the call that caused the event.
+         */
+        readonly source: string;
+        /**
+         * Reason.
+         */
+        readonly reason: CursorChangeReason;
+    }
+
+    /**
+     * An event describing that an editor has had its model reset (i.e. `editor.setModel()`).
+     */
+    export interface IModelChangedEvent {
+        /**
+         * The `uri` of the previous model or null.
+         */
+        readonly oldModelUrl: Uri;
+        /**
+         * The `uri` of the new model or null.
+         */
+        readonly newModelUrl: Uri;
+    }
+
+    /**
+     * A description for the overview ruler position.
+     */
+    export class OverviewRulerPosition {
+        readonly _overviewRulerPositionBrand: void;
+        /**
+         * Width of the overview ruler
+         */
+        readonly width: number;
+        /**
+         * Height of the overview ruler
+         */
+        readonly height: number;
+        /**
+         * Top position for the overview ruler
+         */
+        readonly top: number;
+        /**
+         * Right position for the overview ruler
+         */
+        readonly right: number;
+    }
+
+    /**
+     * The internal layout details of the editor.
+     */
+    export class EditorLayoutInfo {
+        readonly _editorLayoutInfoBrand: void;
+        /**
+         * Full editor width.
+         */
+        readonly width: number;
+        /**
+         * Full editor height.
+         */
+        readonly height: number;
+        /**
+         * Left position for the glyph margin.
+         */
+        readonly glyphMarginLeft: number;
+        /**
+         * The width of the glyph margin.
+         */
+        readonly glyphMarginWidth: number;
+        /**
+         * The height of the glyph margin.
+         */
+        readonly glyphMarginHeight: number;
+        /**
+         * Left position for the line numbers.
+         */
+        readonly lineNumbersLeft: number;
+        /**
+         * The width of the line numbers.
+         */
+        readonly lineNumbersWidth: number;
+        /**
+         * The height of the line numbers.
+         */
+        readonly lineNumbersHeight: number;
+        /**
+         * Left position for the line decorations.
+         */
+        readonly decorationsLeft: number;
+        /**
+         * The width of the line decorations.
+         */
+        readonly decorationsWidth: number;
+        /**
+         * The height of the line decorations.
+         */
+        readonly decorationsHeight: number;
+        /**
+         * Left position for the content (actual text)
+         */
+        readonly contentLeft: number;
+        /**
+         * The width of the content (actual text)
+         */
+        readonly contentWidth: number;
+        /**
+         * The height of the content (actual height)
+         */
+        readonly contentHeight: number;
+        /**
+         * The width of the vertical scrollbar.
+         */
+        readonly verticalScrollbarWidth: number;
+        /**
+         * The height of the horizontal scrollbar.
+         */
+        readonly horizontalScrollbarHeight: number;
+        /**
+         * The position of the overview ruler.
+         */
+        readonly overviewRuler: OverviewRulerPosition;
+    }
+
+    /**
+     * Options for creating the editor.
+     */
+    export interface ICodeEditorWidgetCreationOptions extends IEditorOptions {
+        /**
+         * The initial model associated with this code editor.
+         */
+        model?: IModel;
+    }
+
+    /**
+     * An editor model.
+     */
+    export interface IEditorModel {
+    }
+
+    /**
+     * An editor view state.
+     */
+    export interface IEditorViewState {
+    }
+
+    export interface IDimension {
+        width: number;
+        height: number;
+    }
+
+    /**
+     * A (serializable) state of the cursors.
+     */
+    export interface ICursorState {
+        inSelectionMode: boolean;
+        selectionStart: IPosition;
+        position: IPosition;
+    }
+
+    /**
+     * A (serializable) state of the view.
+     */
+    export interface IViewState {
+        scrollTop: number;
+        scrollTopWithoutViewZones: number;
+        scrollLeft: number;
+    }
+
+    /**
+     * A (serializable) state of the code editor.
+     */
+    export interface ICodeEditorViewState extends IEditorViewState {
+        cursorState: ICursorState[];
+        viewState: IViewState;
+        contributionsState: {
+            [id: string]: any;
+        };
+    }
+
+    /**
+     * Type of hit element with the mouse in the editor.
+     */
+    export enum MouseTargetType {
+        /**
+         * Mouse is on top of an unknown element.
+         */
+        UNKNOWN = 0,
+        /**
+         * Mouse is on top of the textarea used for input.
+         */
+        TEXTAREA = 1,
+        /**
+         * Mouse is on top of the glyph margin
+         */
+        GUTTER_GLYPH_MARGIN = 2,
+        /**
+         * Mouse is on top of the line numbers
+         */
+        GUTTER_LINE_NUMBERS = 3,
+        /**
+         * Mouse is on top of the line decorations
+         */
+        GUTTER_LINE_DECORATIONS = 4,
+        /**
+         * Mouse is on top of the whitespace left in the gutter by a view zone.
+         */
+        GUTTER_VIEW_ZONE = 5,
+        /**
+         * Mouse is on top of text in the content.
+         */
+        CONTENT_TEXT = 6,
+        /**
+         * Mouse is on top of empty space in the content (e.g. after line text or below last line)
+         */
+        CONTENT_EMPTY = 7,
+        /**
+         * Mouse is on top of a view zone in the content.
+         */
+        CONTENT_VIEW_ZONE = 8,
+        /**
+         * Mouse is on top of a content widget.
+         */
+        CONTENT_WIDGET = 9,
+        /**
+         * Mouse is on top of the decorations overview ruler.
+         */
+        OVERVIEW_RULER = 10,
+        /**
+         * Mouse is on top of a scrollbar.
+         */
+        SCROLLBAR = 11,
+        /**
+         * Mouse is on top of an overlay widget.
+         */
+        OVERLAY_WIDGET = 12,
+    }
+
+    /**
+     * A model for the diff editor.
+     */
+    export interface IDiffEditorModel extends IEditorModel {
+        /**
+         * Original model.
+         */
+        original: IModel;
+        /**
+         * Modified model.
+         */
+        modified: IModel;
+    }
+
+    /**
+     * (Serializable) View state for the diff editor.
+     */
+    export interface IDiffEditorViewState extends IEditorViewState {
+        original: ICodeEditorViewState;
+        modified: ICodeEditorViewState;
+    }
+
+    /**
+     * A change
+     */
+    export interface IChange {
+        readonly originalStartLineNumber: number;
+        readonly originalEndLineNumber: number;
+        readonly modifiedStartLineNumber: number;
+        readonly modifiedEndLineNumber: number;
+    }
+
+    /**
+     * A character level change.
+     */
+    export interface ICharChange extends IChange {
+        readonly originalStartColumn: number;
+        readonly originalEndColumn: number;
+        readonly modifiedStartColumn: number;
+        readonly modifiedEndColumn: number;
+    }
+
+    /**
+     * A line change
+     */
+    export interface ILineChange extends IChange {
+        readonly charChanges: ICharChange[];
+    }
+
+    /**
+     * Information about a line in the diff editor
+     */
+    export interface IDiffLineInformation {
+        readonly equivalentLineNumber: number;
+    }
+
+    export interface INewScrollPosition {
+        scrollLeft?: number;
+        scrollTop?: number;
+    }
+
+    /**
+     * Description of an action contribution
+     */
+    export interface IActionDescriptor {
+        /**
+         * An unique identifier of the contributed action.
+         */
+        id: string;
+        /**
+         * A label of the action that will be presented to the user.
+         */
+        label: string;
+        /**
+         * Precondition rule.
+         */
+        precondition?: string;
+        /**
+         * An array of keybindings for the action.
+         */
+        keybindings?: number[];
+        /**
+         * The keybinding rule (condition on top of precondition).
+         */
+        keybindingContext?: string;
+        /**
+         * Control if the action should show up in the context menu and where.
+         * The context menu of the editor has these default:
+         *   navigation - The navigation group comes first in all cases.
+         *   1_modification - This group comes next and contains commands that modify your code.
+         *   9_cutcopypaste - The last default group with the basic editing commands.
+         * You can also create your own group.
+         * Defaults to null (don't show in context menu).
+         */
+        contextMenuGroupId?: string;
+        /**
+         * Control the order in the context menu group.
+         */
+        contextMenuOrder?: number;
+        /**
+         * Method that will be executed when the action is triggered.
+         * @param editor The editor instance is passed in as a convinience
+         */
+        run(editor: ICommonCodeEditor): void | Promise<void>;
+    }
+
+    export interface IEditorAction {
+        readonly id: string;
+        readonly label: string;
+        readonly alias: string;
+        isSupported(): boolean;
+        run(): Promise<void>;
+    }
+
+    /**
+     * An editor.
+     */
+    export interface IEditor {
+        /**
+         * An event emitted when the content of the current model has changed.
+         * @event
+         */
+        onDidChangeModelContent(listener: (e: IModelContentChangedEvent2) => void): IDisposable;
+        /**
+         * An event emitted when the language of the current model has changed.
+         * @event
+         */
+        onDidChangeModelLanguage(listener: (e: IModelLanguageChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the options of the current model has changed.
+         * @event
+         */
+        onDidChangeModelOptions(listener: (e: IModelOptionsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the configuration of the editor has changed. (e.g. `editor.updateOptions()`)
+         * @event
+         */
+        onDidChangeConfiguration(listener: (e: IConfigurationChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the cursor position has changed.
+         * @event
+         */
+        onDidChangeCursorPosition(listener: (e: ICursorPositionChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the cursor selection has changed.
+         * @event
+         */
+        onDidChangeCursorSelection(listener: (e: ICursorSelectionChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the editor has been disposed.
+         * @event
+         */
+        onDidDispose(listener: () => void): IDisposable;
+        /**
+         * Dispose the editor.
+         */
+        dispose(): void;
+        /**
+         * Get a unique id for this editor instance.
+         */
+        getId(): string;
+        /**
+         * Get the editor type. Please see `EditorType`.
+         * This is to avoid an instanceof check
+         */
+        getEditorType(): string;
+        /**
+         * Update the editor's options after the editor has been created.
+         */
+        updateOptions(newOptions: IEditorOptions): void;
+        /**
+         * Instructs the editor to remeasure its container. This method should
+         * be called when the container of the editor gets resized.
+         */
+        layout(dimension?: IDimension): void;
+        /**
+         * Brings browser focus to the editor text
+         */
+        focus(): void;
+        /**
+         * Returns true if this editor has keyboard focus (e.g. cursor is blinking).
+         */
+        isFocused(): boolean;
+        /**
+         * Returns all actions associated with this editor.
+         */
+        getActions(): IEditorAction[];
+        /**
+         * Returns all actions associated with this editor.
+         */
+        getSupportedActions(): IEditorAction[];
+        /**
+         * Saves current view state of the editor in a serializable object.
+         */
+        saveViewState(): IEditorViewState;
+        /**
+         * Restores the view state of the editor from a serializable object generated by `saveViewState`.
+         */
+        restoreViewState(state: IEditorViewState): void;
+        /**
+         * Given a position, returns a column number that takes tab-widths into account.
+         */
+        getVisibleColumnFromPosition(position: IPosition): number;
+        /**
+         * Returns the primary position of the cursor.
+         */
+        getPosition(): Position;
+        /**
+         * Set the primary position of the cursor. This will remove any secondary cursors.
+         * @param position New primary cursor's position
+         */
+        setPosition(position: IPosition): void;
+        /**
+         * Scroll vertically as necessary and reveal a line.
+         */
+        revealLine(lineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal a line centered vertically.
+         */
+        revealLineInCenter(lineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal a line centered vertically only if it lies outside the viewport.
+         */
+        revealLineInCenterIfOutsideViewport(lineNumber: number): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position.
+         */
+        revealPosition(position: IPosition): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position centered vertically.
+         */
+        revealPositionInCenter(position: IPosition): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a position centered vertically only if it lies outside the viewport.
+         */
+        revealPositionInCenterIfOutsideViewport(position: IPosition): void;
+        /**
+         * Returns the primary selection of the editor.
+         */
+        getSelection(): Selection;
+        /**
+         * Returns all the selections of the editor.
+         */
+        getSelections(): Selection[];
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: IRange): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: Range): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: ISelection): void;
+        /**
+         * Set the primary selection of the editor. This will remove any secondary cursors.
+         * @param selection The new selection
+         */
+        setSelection(selection: Selection): void;
+        /**
+         * Set the selections for all the cursors of the editor.
+         * Cursors will be removed or added, as necessary.
+         */
+        setSelections(selections: ISelection[]): void;
+        /**
+         * Scroll vertically as necessary and reveal lines.
+         */
+        revealLines(startLineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal lines centered vertically.
+         */
+        revealLinesInCenter(lineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically as necessary and reveal lines centered vertically only if it lies outside the viewport.
+         */
+        revealLinesInCenterIfOutsideViewport(lineNumber: number, endLineNumber: number): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range.
+         */
+        revealRange(range: IRange): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range centered vertically.
+         */
+        revealRangeInCenter(range: IRange): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range at the top of the viewport.
+         */
+        revealRangeAtTop(range: IRange): void;
+        /**
+         * Scroll vertically or horizontally as necessary and reveal a range centered vertically only if it lies outside the viewport.
+         */
+        revealRangeInCenterIfOutsideViewport(range: IRange): void;
+        /**
+         * Directly trigger a handler or an editor action.
+         * @param source The source of the call.
+         * @param handlerId The id of the handler or the id of a contribution.
+         * @param payload Extra data to be sent to the handler.
+         */
+        trigger(source: string, handlerId: string, payload: any): void;
+        /**
+         * Gets the current model attached to this editor.
+         */
+        getModel(): IEditorModel;
+        /**
+         * Sets the current model attached to this editor.
+         * If the previous model was created by the editor via the value key in the options
+         * literal object, it will be destroyed. Otherwise, if the previous model was set
+         * via setModel, or the model key in the options literal object, the previous model
+         * will not be destroyed.
+         * It is safe to call setModel(null) to simply detach the current model from the editor.
+         */
+        setModel(model: IEditorModel): void;
+    }
+
+    /**
+     * An editor contribution that gets created every time a new editor gets created and gets disposed when the editor gets disposed.
+     */
+    export interface IEditorContribution {
+        /**
+         * Get a unique identifier for this contribution.
+         */
+        getId(): string;
+        /**
+         * Dispose this contribution.
+         */
+        dispose(): void;
+        /**
+         * Store view state.
+         */
+        saveViewState?(): any;
+        /**
+         * Restore view state.
+         */
+        restoreViewState?(state: any): void;
+    }
+
+    export interface ICommonCodeEditor extends IEditor {
+        /**
+         * An event emitted when the model of this editor has changed (e.g. `editor.setModel()`).
+         * @event
+         */
+        onDidChangeModel(listener: (e: IModelChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the decorations of the current model have changed.
+         * @event
+         */
+        onDidChangeModelDecorations(listener: (e: IModelDecorationsChangedEvent) => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor gained focus (i.e. cursor blinking).
+         * @event
+         */
+        onDidFocusEditorText(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor lost focus.
+         * @event
+         */
+        onDidBlurEditorText(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor or an editor widget gained focus.
+         * @event
+         */
+        onDidFocusEditor(listener: () => void): IDisposable;
+        /**
+         * An event emitted when the text inside this editor or an editor widget lost focus.
+         * @event
+         */
+        onDidBlurEditor(listener: () => void): IDisposable;
+        /**
+         * Returns true if this editor or one of its widgets has keyboard focus.
+         */
+        hasWidgetFocus(): boolean;
+        /**
+         * Get a contribution of this editor.
+         * @id Unique identifier of the contribution.
+         * @return The contribution or null if contribution not found.
+         */
+        getContribution<T extends IEditorContribution>(id: string): T;
+        /**
+         * Type the getModel() of IEditor.
+         */
+        getModel(): IModel;
+        /**
+         * Returns the current editor's configuration
+         */
+        getConfiguration(): InternalEditorOptions;
+        /**
+         * Get value of the current model attached to this editor.
+         * @see IModel.getValue
+         */
+        getValue(options?: {
+            preserveBOM: boolean;
+            lineEnding: string;
+        }): string;
+        /**
+         * Set the value of the current model attached to this editor.
+         * @see IModel.setValue
+         */
+        setValue(newValue: string): void;
+        /**
+         * Get the scrollWidth of the editor's viewport.
+         */
+        getScrollWidth(): number;
+        /**
+         * Get the scrollLeft of the editor's viewport.
+         */
+        getScrollLeft(): number;
+        /**
+         * Get the scrollHeight of the editor's viewport.
+         */
+        getScrollHeight(): number;
+        /**
+         * Get the scrollTop of the editor's viewport.
+         */
+        getScrollTop(): number;
+        /**
+         * Change the scrollLeft of the editor's viewport.
+         */
+        setScrollLeft(newScrollLeft: number): void;
+        /**
+         * Change the scrollTop of the editor's viewport.
+         */
+        setScrollTop(newScrollTop: number): void;
+        /**
+         * Change the scroll position of the editor's viewport.
+         */
+        setScrollPosition(position: INewScrollPosition): void;
+        /**
+         * Get an action that is a contribution to this editor.
+         * @id Unique identifier of the contribution.
+         * @return The action or null if action not found.
+         */
+        getAction(id: string): IEditorAction;
+        /**
+         * Execute a command on the editor.
+         * @param source The source of the call.
+         * @param command The command to execute
+         */
+        executeCommand(source: string, command: ICommand): void;
+        /**
+         * Push an "undo stop" in the undo-redo stack.
+         */
+        pushUndoStop(): boolean;
+        /**
+         * Execute edits on the editor.
+         * @param source The source of the call.
+         * @param edits The edits to execute.
+         * @param endCursoState Cursor state after the edits were applied.
+         */
+        executeEdits(source: string, edits: IIdentifiedSingleEditOperation[], endCursoState?: Selection[]): boolean;
+        /**
+         * Execute multiple (concommitent) commands on the editor.
+         * @param source The source of the call.
+         * @param command The commands to execute
+         */
+        executeCommands(source: string, commands: ICommand[]): void;
+        /**
+         * Get all the decorations on a line (filtering out decorations from other editors).
+         */
+        getLineDecorations(lineNumber: number): IModelDecoration[];
+        /**
+         * All decorations added through this call will get the ownerId of this editor.
+         * @see IModel.deltaDecorations
+         */
+        deltaDecorations(oldDecorations: string[], newDecorations: IModelDeltaDecoration[]): string[];
+        /**
+         * Get the layout info for the editor.
+         */
+        getLayoutInfo(): EditorLayoutInfo;
+    }
+
+    export interface ICommonDiffEditor extends IEditor {
+        /**
+         * An event emitted when the diff information computed by this diff editor has been updated.
+         * @event
+         */
+        onDidUpdateDiff(listener: () => void): IDisposable;
+        /**
+         * Type the getModel() of IEditor.
+         */
+        getModel(): IDiffEditorModel;
+        /**
+         * Get the `original` editor.
+         */
+        getOriginalEditor(): ICommonCodeEditor;
+        /**
+         * Get the `modified` editor.
+         */
+        getModifiedEditor(): ICommonCodeEditor;
+        /**
+         * Get the computed diff information.
+         */
+        getLineChanges(): ILineChange[];
+        /**
+         * Get information based on computed diff about a line number from the original model.
+         * If the diff computation is not finished or the model is missing, will return null.
+         */
+        getDiffLineInformationForOriginal(lineNumber: number): IDiffLineInformation;
+        /**
+         * Get information based on computed diff about a line number from the modified model.
+         * If the diff computation is not finished or the model is missing, will return null.
+         */
+        getDiffLineInformationForModified(lineNumber: number): IDiffLineInformation;
+        /**
+         * @see ICodeEditor.getValue
+         */
+        getValue(options?: {
+            preserveBOM: boolean;
+            lineEnding: string;
+        }): string;
+    }
+
+    /**
+     * The type of the `IEditor`.
+     */
+    export var EditorType: {
+        ICodeEditor: string;
+        IDiffEditor: string;
+    };
+
+    /**
+     * Positions in the view for cursor move command.
+     */
+    export const CursorMovePosition: {
+        Left: string;
+        Right: string;
+        Up: string;
+        Down: string;
+        WrappedLineStart: string;
+        WrappedLineFirstNonWhitespaceCharacter: string;
+        WrappedLineColumnCenter: string;
+        WrappedLineEnd: string;
+        WrappedLineLastNonWhitespaceCharacter: string;
+        ViewPortTop: string;
+        ViewPortCenter: string;
+        ViewPortBottom: string;
+        ViewPortIfOutside: string;
+    };
+
+    /**
+     * Units for Cursor move 'by' argument
+     */
+    export const CursorMoveByUnit: {
+        Line: string;
+        WrappedLine: string;
+        Character: string;
+        HalfLine: string;
+    };
+
+    /**
+     * Arguments for Cursor move command
+     */
+    export interface CursorMoveArguments {
+        to: string;
+        select?: boolean;
+        by?: string;
+        value?: number;
+    }
+
+    /**
+     * Directions in the view for editor scroll command.
+     */
+    export const EditorScrollDirection: {
+        Up: string;
+        Down: string;
+    };
+
+    /**
+     * Units for editor scroll 'by' argument
+     */
+    export const EditorScrollByUnit: {
+        Line: string;
+        WrappedLine: string;
+        Page: string;
+        HalfPage: string;
+    };
+
+    /**
+     * Arguments for editor scroll command
+     */
+    export interface EditorScrollArguments {
+        to: string;
+        by?: string;
+        value?: number;
+        revealCursor?: boolean;
+    }
+
+    /**
+     * Arguments for reveal line command
+     */
+    export interface RevealLineArguments {
+        lineNumber?: number;
+        at?: string;
+    }
+
+    /**
+     * Values for reveal line 'at' argument
+     */
+    export const RevealLineAtArgument: {
+        Top: string;
+        Center: string;
+        Bottom: string;
+    };
+
+    /**
+     * Built-in commands.
+     */
+    export var Handler: {
+        ExecuteCommand: string;
+        ExecuteCommands: string;
+        CursorLeft: string;
+        CursorLeftSelect: string;
+        CursorWordLeft: string;
+        CursorWordStartLeft: string;
+        CursorWordEndLeft: string;
+        CursorWordLeftSelect: string;
+        CursorWordStartLeftSelect: string;
+        CursorWordEndLeftSelect: string;
+        CursorRight: string;
+        CursorRightSelect: string;
+        CursorWordRight: string;
+        CursorWordStartRight: string;
+        CursorWordEndRight: string;
+        CursorWordRightSelect: string;
+        CursorWordStartRightSelect: string;
+        CursorWordEndRightSelect: string;
+        CursorUp: string;
+        CursorUpSelect: string;
+        CursorDown: string;
+        CursorDownSelect: string;
+        CursorPageUp: string;
+        CursorPageUpSelect: string;
+        CursorPageDown: string;
+        CursorPageDownSelect: string;
+        CursorHome: string;
+        CursorHomeSelect: string;
+        CursorEnd: string;
+        CursorEndSelect: string;
+        ExpandLineSelection: string;
+        CursorTop: string;
+        CursorTopSelect: string;
+        CursorBottom: string;
+        CursorBottomSelect: string;
+        CursorColumnSelectLeft: string;
+        CursorColumnSelectRight: string;
+        CursorColumnSelectUp: string;
+        CursorColumnSelectPageUp: string;
+        CursorColumnSelectDown: string;
+        CursorColumnSelectPageDown: string;
+        CursorMove: string;
+        AddCursorDown: string;
+        AddCursorUp: string;
+        CursorUndo: string;
+        MoveTo: string;
+        MoveToSelect: string;
+        ColumnSelect: string;
+        CreateCursor: string;
+        LastCursorMoveToSelect: string;
+        Type: string;
+        ReplacePreviousChar: string;
+        CompositionStart: string;
+        CompositionEnd: string;
+        Paste: string;
+        Tab: string;
+        Indent: string;
+        Outdent: string;
+        DeleteLeft: string;
+        DeleteRight: string;
+        DeleteWordLeft: string;
+        DeleteWordStartLeft: string;
+        DeleteWordEndLeft: string;
+        DeleteWordRight: string;
+        DeleteWordStartRight: string;
+        DeleteWordEndRight: string;
+        RemoveSecondaryCursors: string;
+        CancelSelection: string;
+        Cut: string;
+        Undo: string;
+        Redo: string;
+        WordSelect: string;
+        WordSelectDrag: string;
+        LastCursorWordSelect: string;
+        LineSelect: string;
+        LineSelectDrag: string;
+        LastCursorLineSelect: string;
+        LastCursorLineSelectDrag: string;
+        LineInsertBefore: string;
+        LineInsertAfter: string;
+        LineBreakInsert: string;
+        SelectAll: string;
+        EditorScroll: string;
+        ScrollLineUp: string;
+        ScrollLineDown: string;
+        ScrollPageUp: string;
+        ScrollPageDown: string;
+        RevealLine: string;
+    };
+
+    /**
+     * The style in which the editor's cursor should be rendered.
+     */
+    export enum TextEditorCursorStyle {
+        /**
+         * As a vertical line (sitting between two characters).
+         */
+        Line = 1,
+        /**
+         * As a block (sitting on top of a character).
+         */
+        Block = 2,
+        /**
+         * As a horizontal line (sitting under a character).
+         */
+        Underline = 3,
+    }
+
+    /**
+     * The kind of animation in which the editor's cursor should be rendered.
+     */
+    export enum TextEditorCursorBlinkingStyle {
+        /**
+         * Hidden
+         */
+        Hidden = 0,
+        /**
+         * Blinking
+         */
+        Blink = 1,
+        /**
+         * Blinking with smooth fading
+         */
+        Smooth = 2,
+        /**
+         * Blinking with prolonged filled state and smooth fading
+         */
+        Phase = 3,
+        /**
+         * Expand collapse animation on the y axis
+         */
+        Expand = 4,
+        /**
+         * No-Blinking
+         */
+        Solid = 5,
+    }
+
+    /**
+     * A view zone is a full horizontal rectangle that 'pushes' text down.
+     * The editor reserves space for view zones when rendering.
+     */
+    export interface IViewZone {
+        /**
+         * The line number after which this zone should appear.
+         * Use 0 to place a view zone before the first line number.
+         */
+        afterLineNumber: number;
+        /**
+         * The column after which this zone should appear.
+         * If not set, the maxLineColumn of `afterLineNumber` will be used.
+         */
+        afterColumn?: number;
+        /**
+         * Suppress mouse down events.
+         * If set, the editor will attach a mouse down listener to the view zone and .preventDefault on it.
+         * Defaults to false
+         */
+        suppressMouseDown?: boolean;
+        /**
+         * The height in lines of the view zone.
+         * If specified, `heightInPx` will be used instead of this.
+         * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
+         */
+        heightInLines?: number;
+        /**
+         * The height in px of the view zone.
+         * If this is set, the editor will give preference to it rather than `heightInLines` above.
+         * If neither `heightInPx` nor `heightInLines` is specified, a default of `heightInLines` = 1 will be chosen.
+         */
+        heightInPx?: number;
+        /**
+         * The dom node of the view zone
+         */
+        domNode: HTMLElement;
+        /**
+         * An optional dom node for the view zone that will be placed in the margin area.
+         */
+        marginDomNode?: HTMLElement;
+        /**
+         * Callback which gives the relative top of the view zone as it appears (taking scrolling into account).
+         */
+        onDomNodeTop?: (top: number) => void;
+        /**
+         * Callback which gives the height in pixels of the view zone.
+         */
+        onComputedHeight?: (height: number) => void;
+    }
+
+    /**
+     * An accessor that allows for zones to be added or removed.
+     */
+    export interface IViewZoneChangeAccessor {
+        /**
+         * Create a new view zone.
+         * @param zone Zone to create
+         * @return A unique identifier to the view zone.
+         */
+        addZone(zone: IViewZone): number;
+        /**
+         * Remove a zone
+         * @param id A unique identifier to the view zone, as returned by the `addZone` call.
+         */
+        removeZone(id: number): void;
+        /**
+         * Change a zone's position.
+         * The editor will rescan the `afterLineNumber` and `afterColumn` properties of a view zone.
+         */
+        layoutZone(id: number): void;
+    }
+
+    /**
+     * A positioning preference for rendering content widgets.
+     */
+    export enum ContentWidgetPositionPreference {
+        /**
+         * Place the content widget exactly at a position
+         */
+        EXACT = 0,
+        /**
+         * Place the content widget above a position
+         */
+        ABOVE = 1,
+        /**
+         * Place the content widget below a position
+         */
+        BELOW = 2,
+    }
+
+    /**
+     * A position for rendering content widgets.
+     */
+    export interface IContentWidgetPosition {
+        /**
+         * Desired position for the content widget.
+         * `preference` will also affect the placement.
+         */
+        position: IPosition;
+        /**
+         * Placement preference for position, in order of preference.
+         */
+        preference: ContentWidgetPositionPreference[];
+    }
+
+    /**
+     * A content widget renders inline with the text and can be easily placed 'near' an editor position.
+     */
+    export interface IContentWidget {
+        /**
+         * Render this content widget in a location where it could overflow the editor's view dom node.
+         */
+        allowEditorOverflow?: boolean;
+        suppressMouseDown?: boolean;
+        /**
+         * Get a unique identifier of the content widget.
+         */
+        getId(): string;
+        /**
+         * Get the dom node of the content widget.
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Get the placement of the content widget.
+         * If null is returned, the content widget will be placed off screen.
+         */
+        getPosition(): IContentWidgetPosition;
+    }
+
+    /**
+     * A positioning preference for rendering overlay widgets.
+     */
+    export enum OverlayWidgetPositionPreference {
+        /**
+         * Position the overlay widget in the top right corner
+         */
+        TOP_RIGHT_CORNER = 0,
+        /**
+         * Position the overlay widget in the bottom right corner
+         */
+        BOTTOM_RIGHT_CORNER = 1,
+        /**
+         * Position the overlay widget in the top center
+         */
+        TOP_CENTER = 2,
+    }
+
+    /**
+     * A position for rendering overlay widgets.
+     */
+    export interface IOverlayWidgetPosition {
+        /**
+         * The position preference for the overlay widget.
+         */
+        preference: OverlayWidgetPositionPreference;
+    }
+
+    /**
+     * An overlay widgets renders on top of the text.
+     */
+    export interface IOverlayWidget {
+        /**
+         * Get a unique identifier of the overlay widget.
+         */
+        getId(): string;
+        /**
+         * Get the dom node of the overlay widget.
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Get the placement of the overlay widget.
+         * If null is returned, the overlay widget is responsible to place itself.
+         */
+        getPosition(): IOverlayWidgetPosition;
+    }
+
+    /**
+     * Target hit with the mouse in the editor.
+     */
+    export interface IMouseTarget {
+        /**
+         * The target element
+         */
+        readonly element: Element;
+        /**
+         * The target type
+         */
+        readonly type: MouseTargetType;
+        /**
+         * The 'approximate' editor position
+         */
+        readonly position: Position;
+        /**
+         * Desired mouse column (e.g. when position.column gets clamped to text length -- clicking after text on a line).
+         */
+        readonly mouseColumn: number;
+        /**
+         * The 'approximate' editor range
+         */
+        readonly range: Range;
+        /**
+         * Some extra detail.
+         */
+        readonly detail: any;
+    }
+
+    /**
+     * A mouse event originating from the editor.
+     */
+    export interface IEditorMouseEvent {
+        readonly event: IMouseEvent;
+        readonly target: IMouseTarget;
+    }
+
+    /**
+     * A rich code editor.
+     */
+    export interface ICodeEditor extends ICommonCodeEditor {
+        /**
+         * An event emitted on a "mouseup".
+         * @event
+         */
+        onMouseUp(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mousedown".
+         * @event
+         */
+        onMouseDown(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "contextmenu".
+         * @event
+         */
+        onContextMenu(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mousemove".
+         * @event
+         */
+        onMouseMove(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "mouseleave".
+         * @event
+         */
+        onMouseLeave(listener: (e: IEditorMouseEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "keyup".
+         * @event
+         */
+        onKeyUp(listener: (e: IKeyboardEvent) => void): IDisposable;
+        /**
+         * An event emitted on a "keydown".
+         * @event
+         */
+        onKeyDown(listener: (e: IKeyboardEvent) => void): IDisposable;
+        /**
+         * An event emitted when the layout of the editor has changed.
+         * @event
+         */
+        onDidLayoutChange(listener: (e: EditorLayoutInfo) => void): IDisposable;
+        /**
+         * An event emitted when the scroll in the editor has changed.
+         * @event
+         */
+        onDidScrollChange(listener: (e: IScrollEvent) => void): IDisposable;
+        /**
+         * Returns the editor's dom node
+         */
+        getDomNode(): HTMLElement;
+        /**
+         * Add a content widget. Widgets must have unique ids, otherwise they will be overwritten.
+         */
+        addContentWidget(widget: IContentWidget): void;
+        /**
+         * Layout/Reposition a content widget. This is a ping to the editor to call widget.getPosition()
+         * and update appropiately.
+         */
+        layoutContentWidget(widget: IContentWidget): void;
+        /**
+         * Remove a content widget.
+         */
+        removeContentWidget(widget: IContentWidget): void;
+        /**
+         * Add an overlay widget. Widgets must have unique ids, otherwise they will be overwritten.
+         */
+        addOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Layout/Reposition an overlay widget. This is a ping to the editor to call widget.getPosition()
+         * and update appropiately.
+         */
+        layoutOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Remove an overlay widget.
+         */
+        removeOverlayWidget(widget: IOverlayWidget): void;
+        /**
+         * Change the view zones. View zones are lost when a new model is attached to the editor.
+         */
+        changeViewZones(callback: (accessor: IViewZoneChangeAccessor) => void): void;
+        /**
+         * Returns the range that is currently centered in the view port.
+         */
+        getCenteredRangeInViewport(): Range;
+        /**
+         * Get the horizontal position (left offset) for the column w.r.t to the beginning of the line.
+         * This method works only if the line `lineNumber` is currently rendered (in the editor's viewport).
+         * Use this method with caution.
+         */
+        getOffsetForColumn(lineNumber: number, column: number): number;
+        /**
+         * Force an editor render now.
+         */
+        render(): void;
+        /**
+         * Get the vertical position (top offset) for the line w.r.t. to the first line.
+         */
+        getTopForLineNumber(lineNumber: number): number;
+        /**
+         * Get the vertical position (top offset) for the position w.r.t. to the first line.
+         */
+        getTopForPosition(lineNumber: number, column: number): number;
+        /**
+         * Get the hit test target at coordinates `clientX` and `clientY`.
+         * The coordinates are relative to the top-left of the viewport.
+         *
+         * @returns Hit test target or null if the coordinates fall outside the editor or the editor has no model.
+         */
+        getTargetAtClientPoint(clientX: number, clientY: number): IMouseTarget;
+        /**
+         * Get the visible position for `position`.
+         * The result position takes scrolling into account and is relative to the top left corner of the editor.
+         * Explanation 1: the results of this method will change for the same `position` if the user scrolls the editor.
+         * Explanation 2: the results of this method will not change if the container of the editor gets repositioned.
+         * Warning: the results of this method are innacurate for positions that are outside the current editor viewport.
+         */
+        getScrolledVisiblePosition(position: IPosition): {
+            top: number;
+            left: number;
+            height: number;
+        };
+        /**
+         * Apply the same font settings as the editor to `target`.
+         */
+        applyFontInfo(target: HTMLElement): void;
+    }
+
+    /**
+     * A rich diff editor.
+     */
+    export interface IDiffEditor extends ICommonDiffEditor {
+        /**
+         * @see ICodeEditor.getDomNode
+         */
+        getDomNode(): HTMLElement;
+    }
+
+    export class FontInfo extends BareFontInfo {
+        readonly _editorStylingBrand: void;
+        readonly isMonospace: boolean;
+        readonly typicalHalfwidthCharacterWidth: number;
+        readonly typicalFullwidthCharacterWidth: number;
+        readonly spaceWidth: number;
+        readonly maxDigitWidth: number;
+    }
+    export class BareFontInfo {
+        readonly _bareFontInfoBrand: void;
+        readonly fontFamily: string;
+        readonly fontWeight: string;
+        readonly fontSize: number;
+        readonly lineHeight: number;
+    }
+>>>>>>> .their
 }
 
 declare namespace monaco.languages {
