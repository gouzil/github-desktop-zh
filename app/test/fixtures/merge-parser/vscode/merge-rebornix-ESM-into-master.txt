added in remote
  their  100644 a27c17db4ff7a2850ee29945b068a8566316c525 .babelrc
@@ -0,0 +1,16 @@
+{
+	"plugins": [
+		"./scripts/babel-monaco-plugin.js",
+		[
+			"module-resolver",
+			{
+				"root": [
+					"./out-build-esm"
+				],
+				"alias": {
+					"vs": "./out-build-esm/vs"
+				}
+			}
+		]
+	]
+}
\ No newline at end of file
changed in both
  base   100644 2445c0c728869d233681984313f3ef189f79fb33 .eslintrc
  our    100644 675654b0fa66a844d002d6ef424b56c8aa21ce23 .eslintrc
  their  100644 539f588bfb721b1db8bdbe0bd163c2f6868926c5 .eslintrc
@@ -10,10 +10,17 @@
 		"no-extra-semi": "warn",
 		"semi": "warn"
 	},
+<<<<<<< .our
 	"extends": "eslint:recommended",
 	"parserOptions": {
 		"ecmaFeatures": {
 			"experimentalObjectRestSpread": true
 		}
 	}
+=======
+	"parserOptions": {
+		"sourceType": "module"
+	},
+	"extends": "eslint:recommended"
+>>>>>>> .their
 }
\ No newline at end of file
changed in both
  base   100644 d08f65260d3fc89ce44c49c01766e7d25bfe679f .gitignore
  our    100644 6a9804cd2373e8051bf7b31a2c4dacc67eb9fb69 .gitignore
  their  100644 0c9bc895383b0888dcae256ff270b58713e819bf .gitignore
@@ -1,3 +1,4 @@
+<<<<<<< .our
 .DS_Store
 npm-debug.log
 Thumbs.db
@@ -19,3 +20,22 @@
 test_data/
 test-results/
 yarn-error.log
+=======
+.DS_Store
+npm-debug.log
+Thumbs.db
+node_modules/
+.build/
+out/
+out-build/
+out-build-esm/
+out-esm/
+out-editor/
+out-editor-min/
+out-monaco-editor-core/
+out-vscode/
+out-vscode-min/
+build/node_modules
+coverage/
+test_data/
+>>>>>>> .their
changed in both
  base   100644 1a09abd4f554043e693e676c248e280b22fc1afa build/gulpfile.editor.js
  our    100644 52d1f0fcf323631277651ff28381ae49c0fa6558 build/gulpfile.editor.js
  their  100644 4b5d7aee925c71b7ef3f0e8b842bd0806178205b build/gulpfile.editor.js
@@ -3,6 +3,7 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
+<<<<<<< .our
 const gulp = require('gulp');
 const path = require('path');
 const util = require('./lib/util');
@@ -15,6 +16,15 @@
 const compilation = require('./lib/compilation');
 const monacoapi = require('./monaco/api');
 const fs = require('fs');
+=======
+var gulp = require('gulp');
+var path = require('path');
+var util = require('./lib/util');
+var common = require('./lib/optimize');
+var es = require('event-stream');
+var File = require('vinyl');
+var compilation = require('./lib/compilation');
+>>>>>>> .their
 
 var root = path.dirname(__dirname);
 var sha1 = util.getVersion(root);
@@ -310,6 +320,15 @@
 	console.log(JSON.stringify(detailed, null, '\t'));
 });
 
+const rootDir = path.join(__dirname, '../src');
+const tsOptions = require('../src/tsconfig.esm.json').compilerOptions;
+tsOptions.verbose = false;
+tsOptions.sourceMap = true;
+tsOptions.rootDir = rootDir;
+tsOptions.sourceRoot = util.toFileUri(rootDir);
+gulp.task('clean-client-esm-build', util.rimraf('out-build-esm'));
+gulp.task('compile-client-esm-build', ['clean-client-esm-build'], compilation.compileEditorTask('out-build-esm', true, tsOptions));
+
 function filterStream(testFunc) {
 	return es.through(function (data) {
 		if (!testFunc(data.relative)) {
changed in both
  base   100644 97b1ab8367eae817c39ea22b259b515332682772 build/gulpfile.hygiene.js
  our    100644 6a4cd05d17fefc0e6fdc6e8d0fd2997f3c2894ff build/gulpfile.hygiene.js
  their  100644 5ca89cf053aa956862b030557f2cdeb2e4914b5d build/gulpfile.hygiene.js
@@ -66,9 +66,20 @@
 
 	// except multiple specific folders
 	'!**/octicons/**',
+<<<<<<< .our
 	'!**/fixtures/**',
 	'!**/lib/**',
 	'!extensions/**/out/**',
+=======
+	'!**/vs/base/common/marked/raw.marked.js',
+	'!**/vs/base/common/marked/raw.marked.esm.js',
+	'!**/vs/base/common/winjs.base.raw.js',
+	'!**/vs/base/common/winjs.base.esm.js',
+	'!**/vs/base/node/terminateProcess.sh',
+	'!**/vs/nls.js',
+	'!**/vs/css.js',
+	'!**/vs/loader.js',
+>>>>>>> .their
 	'!extensions/**/snippets/**',
 	'!extensions/**/syntaxes/**',
 	'!extensions/**/themes/**',
@@ -120,8 +131,15 @@
 	'!src/vs/nls.js',
 	'!src/vs/css.build.js',
 	'!src/vs/nls.build.js',
+<<<<<<< .our
 	'!src/**/winjs.base.js',
 	'!src/**/marked.js',
+=======
+	'!src/**/winjs.base.raw.js',
+	'!src/**/winjs.base.esm.js',
+	'!src/**/raw.marked.js',
+	'!src/**/raw.marked.esm.js',
+>>>>>>> .their
 	'!**/test/**'
 ];
 
changed in both
  base   100644 715ceeb4ede77e7d6cccb35c98ce5dd1efcbd255 build/lib/compilation.js
  our    100644 ad73e2dcf7309fcc9c63b1c1b73c3f86ecac6dca build/lib/compilation.js
  their  100644 f22f5479ca23b3b2bd683de907b5d791b7e21d67 build/lib/compilation.js
@@ -18,6 +18,7 @@
 var monacodts = require("../monaco/api");
 var fs = require("fs");
 var reporter = reporter_1.createReporter();
+<<<<<<< .our
 function getTypeScriptCompilerOptions(src) {
     var rootDir = path.join(__dirname, "../../" + src);
     var options = require("../../" + src + "/tsconfig.json").compilerOptions;
@@ -36,6 +37,19 @@
     opts.inlineSources = !!build;
     opts.noFilesystemLookup = true;
     var ts = tsb.create(opts, null, null, function (err) { return reporter(err.toString()); });
+=======
+var rootDir = path.join(__dirname, '../../src');
+var tsOptions = require('../../src/tsconfig.json').compilerOptions;
+tsOptions.verbose = false;
+tsOptions.sourceMap = true;
+tsOptions.rootDir = rootDir;
+tsOptions.sourceRoot = util.toFileUri(rootDir);
+function createCompile(build, options) {
+    var tsOpts = _.clone(options.overrideTSOptions ? options.overrideTSOptions : tsOptions);
+    tsOpts.inlineSources = !!build;
+    tsOpts.noFilesystemLookup = true;
+    var ts = tsb.create(tsOpts, null, null, function (err) { return reporter(err.toString()); });
+>>>>>>> .their
     return function (token) {
         var utf8Filter = util.filter(function (data) { return /(\/|\\)test(\/|\\).*utf8/.test(data.path); });
         var tsFilter = util.filter(function (data) { return /\.ts$/.test(data.path); });
@@ -54,20 +68,30 @@
             .pipe(sourcemaps.write('.', {
             addComment: false,
             includeContent: !!build,
+<<<<<<< .our
             sourceRoot: opts.sourceRoot
+=======
+            sourceRoot: tsOptions.sourceRoot
+>>>>>>> .their
         }))
             .pipe(tsFilter.restore)
-            .pipe(reporter.end(emitError));
+            .pipe(reporter.end(options.emitError));
         return es.duplex(input, output);
     };
 }
 function compileTask(src, out, build) {
     return function () {
+<<<<<<< .our
         var compile = createCompile(src, build, true);
         var srcPipe = es.merge(gulp.src(src + "/**", { base: "" + src }), gulp.src('node_modules/typescript/lib/lib.d.ts'));
         // Do not write .d.ts files to disk, as they are not needed there.
         var dtsFilter = util.filter(function (data) { return !/\.d\.ts$/.test(data.path); });
         return srcPipe
+=======
+        var compile = createCompile(build, { emitError: true });
+        var src = es.merge(gulp.src('src/**', { base: 'src' }), gulp.src('node_modules/typescript/lib/lib.d.ts'));
+        return src
+>>>>>>> .their
             .pipe(compile())
             .pipe(dtsFilter)
             .pipe(gulp.dest(out))
@@ -78,7 +102,11 @@
 exports.compileTask = compileTask;
 function watchTask(out, build) {
     return function () {
+<<<<<<< .our
         var compile = createCompile('src', build);
+=======
+        var compile = createCompile(build, {});
+>>>>>>> .their
         var src = es.merge(gulp.src('src/**', { base: 'src' }), gulp.src('node_modules/typescript/lib/lib.d.ts'));
         var watchSrc = watch('src/**', { base: 'src' });
         // Do not write .d.ts files to disk, as they are not needed there.
@@ -92,6 +120,69 @@
     };
 }
 exports.watchTask = watchTask;
+<<<<<<< .our
+=======
+function compileEditorTask(out, build, overrideTSOptions) {
+    return function () {
+        var compile = createCompile(build, { emitError: true, overrideTSOptions: overrideTSOptions });
+        var src = es.merge(gulp.src([
+            "src/**",
+            "src/vs/base/**/*",
+            "!src/vs/code/**/*",
+            "!src/vs/workbench/**",
+            "!**/test/**",
+            "!**/node/**",
+            "!**/electron-main/**",
+            "!**/electron-browser/**"
+        ], { base: 'src' }), gulp.src('node_modules/typescript/lib/lib.d.ts'));
+        return src
+            .pipe(compile())
+            .pipe(gulp.dest(out))
+            .pipe(monacodtsTask(out, false));
+    };
+}
+exports.compileEditorTask = compileEditorTask;
+function reloadTypeScriptNodeModule() {
+    var util = require('gulp-util');
+    function log(message) {
+        var rest = [];
+        for (var _i = 1; _i < arguments.length; _i++) {
+            rest[_i - 1] = arguments[_i];
+        }
+        util.log.apply(util, [util.colors.cyan('[memory watch dog]'), message].concat(rest));
+    }
+    function heapUsed() {
+        return (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2) + ' MB';
+    }
+    return es.through(function (data) {
+        this.emit('data', data);
+    }, function () {
+        log('memory usage after compilation finished: ' + heapUsed());
+        // It appears we are running into some variant of
+        // https://bugs.chromium.org/p/v8/issues/detail?id=2073
+        //
+        // Even though all references are dropped, some
+        // optimized methods in the TS compiler end up holding references
+        // to the entire TypeScript language host (>600MB)
+        //
+        // The idea is to force v8 to drop references to these
+        // optimized methods, by "reloading" the typescript node module
+        log('Reloading typescript node module...');
+        var resolvedName = require.resolve('typescript');
+        var originalModule = require.cache[resolvedName];
+        delete require.cache[resolvedName];
+        var newExports = require('typescript');
+        require.cache[resolvedName] = originalModule;
+        for (var prop in newExports) {
+            if (newExports.hasOwnProperty(prop)) {
+                originalModule.exports[prop] = newExports[prop];
+            }
+        }
+        log('typescript node module reloaded.');
+        this.emit('end');
+    });
+}
+>>>>>>> .their
 function monacodtsTask(out, isWatch) {
     var basePath = path.resolve(process.cwd(), out);
     var neededFiles = {};
changed in both
  base   100644 f1ca31f36e8fbefc91f7dda653f3b877cf1b3e15 build/lib/compilation.ts
  our    100644 33d8c11169093df0fd783c944e15dd2444a1594d build/lib/compilation.ts
  their  100644 5d1367ece7d3186473e9d692c2eb3af920e73b96 build/lib/compilation.ts
@@ -21,6 +21,7 @@
 
 const reporter = createReporter();
 
+<<<<<<< .our
 function getTypeScriptCompilerOptions(src: string) {
 	const rootDir = path.join(__dirname, `../../${src}`);
 	const options = require(`../../${src}/tsconfig.json`).compilerOptions;
@@ -39,8 +40,21 @@
 	const opts = _.clone(getTypeScriptCompilerOptions(src));
 	opts.inlineSources = !!build;
 	opts.noFilesystemLookup = true;
+=======
+const rootDir = path.join(__dirname, '../../src');
+const tsOptions = require('../../src/tsconfig.json').compilerOptions;
+tsOptions.verbose = false;
+tsOptions.sourceMap = true;
+tsOptions.rootDir = rootDir;
+tsOptions.sourceRoot = util.toFileUri(rootDir);
 
-	const ts = tsb.create(opts, null, null, err => reporter(err.toString()));
+function createCompile(build: boolean, options: { emitError?: boolean, overrideTSOptions?: any }): (token?: util.ICancellationToken) => NodeJS.ReadWriteStream {
+	const tsOpts = _.clone(options.overrideTSOptions ? options.overrideTSOptions : tsOptions);
+	tsOpts.inlineSources = !!build;
+	tsOpts.noFilesystemLookup = true;
+>>>>>>> .their
+
+	const ts = tsb.create(tsOpts, null, null, err => reporter(err.toString()));
 
 	return function (token?: util.ICancellationToken) {
 
@@ -62,10 +76,14 @@
 			.pipe(sourcemaps.write('.', {
 				addComment: false,
 				includeContent: !!build,
+<<<<<<< .our
 				sourceRoot: opts.sourceRoot
+=======
+				sourceRoot: tsOptions.sourceRoot
+>>>>>>> .their
 			}))
 			.pipe(tsFilter.restore)
-			.pipe(reporter.end(emitError));
+			.pipe(reporter.end(options.emitError));
 
 		return es.duplex(input, output);
 	};
@@ -74,7 +92,11 @@
 export function compileTask(src: string, out: string, build: boolean): () => NodeJS.ReadWriteStream {
 
 	return function () {
+<<<<<<< .our
 		const compile = createCompile(src, build, true);
+=======
+		const compile = createCompile(build, { emitError: true });
+>>>>>>> .their
 
 		const srcPipe = es.merge(
 			gulp.src(`${src}/**`, { base: `${src}` }),
@@ -96,7 +118,11 @@
 export function watchTask(out: string, build: boolean): () => NodeJS.ReadWriteStream {
 
 	return function () {
+<<<<<<< .our
 		const compile = createCompile('src', build);
+=======
+		const compile = createCompile(build, {});
+>>>>>>> .their
 
 		const src = es.merge(
 			gulp.src('src/**', { base: 'src' }),
@@ -116,6 +142,81 @@
 	};
 }
 
+<<<<<<< .our
+=======
+export function compileEditorTask(out: string, build: boolean, overrideTSOptions: any): () => NodeJS.ReadWriteStream {
+	return function () {
+		const compile = createCompile(build, { emitError: true, overrideTSOptions: overrideTSOptions });
+
+		const src = es.merge(
+			gulp.src([
+				"src/**",
+				"src/vs/base/**/*",
+				"!src/vs/code/**/*",
+				"!src/vs/workbench/**",
+				"!**/test/**",
+				"!**/node/**",
+				"!**/electron-main/**",
+				"!**/electron-browser/**"
+			], { base: 'src' }),
+			gulp.src('node_modules/typescript/lib/lib.d.ts'),
+		);
+
+		return src
+			.pipe(compile())
+			.pipe(gulp.dest(out))
+			.pipe(monacodtsTask(out, false));
+	};
+}
+
+function reloadTypeScriptNodeModule(): NodeJS.ReadWriteStream {
+	var util = require('gulp-util');
+	function log(message: any, ...rest: any[]): void {
+		util.log(util.colors.cyan('[memory watch dog]'), message, ...rest);
+	}
+
+	function heapUsed(): string {
+		return (process.memoryUsage().heapUsed / 1024 / 1024).toFixed(2) + ' MB';
+	}
+
+	return es.through(function (data) {
+		this.emit('data', data);
+	}, function () {
+
+		log('memory usage after compilation finished: ' + heapUsed());
+
+		// It appears we are running into some variant of
+		// https://bugs.chromium.org/p/v8/issues/detail?id=2073
+		//
+		// Even though all references are dropped, some
+		// optimized methods in the TS compiler end up holding references
+		// to the entire TypeScript language host (>600MB)
+		//
+		// The idea is to force v8 to drop references to these
+		// optimized methods, by "reloading" the typescript node module
+
+		log('Reloading typescript node module...');
+
+		var resolvedName = require.resolve('typescript');
+
+		var originalModule = require.cache[resolvedName];
+		delete require.cache[resolvedName];
+		var newExports = require('typescript');
+		require.cache[resolvedName] = originalModule;
+
+		for (var prop in newExports) {
+			if (newExports.hasOwnProperty(prop)) {
+				originalModule.exports[prop] = newExports[prop];
+			}
+		}
+
+		log('typescript node module reloaded.');
+
+		this.emit('end');
+	});
+}
+
+>>>>>>> .their
 function monacodtsTask(out: string, isWatch: boolean): NodeJS.ReadWriteStream {
 
 	const basePath = path.resolve(process.cwd(), out);
changed in both
  base   100644 53dd90bef39327730e4716d61ad2580f1969028d build/lib/nls.js
  our    100644 a63d36990143a97c7fb2c24d1ef123dfe5945f3a build/lib/nls.js
  their  100644 3bcbbb3d63829c14d2fef51a3694a20ba06eabeb build/lib/nls.js
@@ -1,8 +1,8 @@
-"use strict";
 /*---------------------------------------------------------------------------------------------
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+"use strict";
 var ts = require("typescript");
 var lazy = require("lazy.js");
 var event_stream_1 = require("event-stream");
@@ -44,7 +44,7 @@
         indent = '\t';
         wrap = '\n';
     }
-    return "/*---------------------------------------------------------\n * Copyright (C) Microsoft Corporation. All rights reserved.\n *--------------------------------------------------------*/\ndefine([], [" + (wrap + lines.map(function (l) { return indent + l; }).join(',\n') + wrap) + "]);";
+    return "var brackets = [" + (wrap + lines.map(function (l) { return indent + l; }).join(',\n') + wrap) + "];\nexport const localize = function(index, params) {\n\treturn brackets[index];\n}";
 }
 /**
  * Returns a stream containing the patched JavaScript and source maps.
@@ -94,7 +94,7 @@
         return { line: position.line - 1, character: position.column };
     }
     nls_1.lcFrom = lcFrom;
-    var SingleFileServiceHost = /** @class */ (function () {
+    var SingleFileServiceHost = (function () {
         function SingleFileServiceHost(options, filename, contents) {
             var _this = this;
             this.options = options;
@@ -203,7 +203,7 @@
         };
     }
     nls_1.analyze = analyze;
-    var TextModel = /** @class */ (function () {
+    var TextModel = (function () {
         function TextModel(contents) {
             var regex = /\r\n|\r|\n/g;
             var index = 0;
changed in both
  base   100644 856470107eccec0994b82f97f09a0b659c2d2568 build/lib/nls.ts
  our    100644 cffa53a2bd0ea3a7215cd1e136621a2661dd3670 build/lib/nls.ts
  their  100644 fbdda22669fa08603fb7655f7bf3c47614426b9f build/lib/nls.ts
@@ -57,10 +57,10 @@
 		wrap = '\n';
 	}
 
-	return `/*---------------------------------------------------------
- * Copyright (C) Microsoft Corporation. All rights reserved.
- *--------------------------------------------------------*/
-define([], [${ wrap + lines.map(l => indent + l).join(',\n') + wrap}]);`;
+	return `var brackets = [${ wrap + lines.map(l => indent + l).join(',\n') + wrap}];
+export const localize = function(index, params) {
+	return brackets[index];
+}`;
 }
 
 /**
changed in both
  base   100644 ff0d1b329792603437d93343f1239f08e4296a19 package.json
  our    100644 d0e982ce0b76c5b1b5eb02b673e459e47f3353a4 package.json
  their  100644 b21cf1e0d5ea6f8004855511a4cafcc98231aa0d package.json
@@ -55,12 +55,25 @@
   },
   "devDependencies": {
     "7zip": "0.0.6",
+<<<<<<< .our
     "@types/keytar": "4.0.1",
     "@types/minimist": "1.2.0",
     "@types/mocha": "2.2.39",
     "@types/sinon": "1.16.34",
     "asar": "^0.14.0",
     "chromium-pickle-js": "^0.2.0",
+=======
+    "@types/keytar": "^4.0.0",
+    "@types/minimist": "^1.2.0",
+    "@types/mocha": "^2.2.39",
+    "@types/semver": "^5.3.30",
+    "@types/sinon": "^1.16.34",
+    "@types/winreg": "^1.2.30",
+    "azure-storage": "^0.3.1",
+    "babel-cli": "^6.26.0",
+    "babel-core": "^6.26.0",
+    "babel-plugin-module-resolver": "^2.7.1",
+>>>>>>> .their
     "clean-css": "3.4.6",
     "copy-webpack-plugin": "^4.5.2",
     "coveralls": "^2.11.11",
@@ -114,12 +127,21 @@
     "queue": "3.0.6",
     "remap-istanbul": "^0.6.4",
     "rimraf": "^2.2.8",
+    "rollup": "0.50.0",
+    "rollup-plugin-babel": "3.0.2",
+    "rollup-plugin-typescript": "^0.8.1",
     "sinon": "^1.17.2",
     "source-map": "^0.4.4",
+<<<<<<< .our
     "ts-loader": "^4.4.2",
     "tslint": "^5.9.1",
     "typescript": "2.9.2",
     "typescript-formatter": "7.1.0",
+=======
+    "tslint": "^4.3.1",
+	"typescript": "2.5.2",
+    "typescript-formatter": "4.0.1",
+>>>>>>> .their
     "uglify-es": "^3.0.18",
     "underscore": "^1.8.2",
     "vinyl": "^0.4.5",
@@ -142,4 +164,4 @@
     "windows-mutex": "^0.2.0",
     "windows-process-tree": "0.2.2"
   }
-}
\ No newline at end of file
+}
added in remote
  their  100644 3b3010bd3bfa85ac1f82a5a20c03734c03a87970 rollup.js
@@ -0,0 +1,17 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+var rollup = require("rollup");
+var babel = require("rollup-plugin-babel");
+
+rollup.rollup({
+	input: "out-build-esm/vs/editor/editor.esm.js",
+	plugins: [babel()]
+}).then(function (bundle) {
+	bundle.write({
+		file: "out-build-esm/monaco.mjs",
+		format: "es"
+	});
+});
added in remote
  their  100644 0ceb75ca5ad5a1df4a0e6c2fc5faa833bf2a7481 scripts/babel-monaco-plugin.js
@@ -0,0 +1,39 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+'use strict';
+
+Object.defineProperty(exports, "__esModule", {
+	value: true
+});
+
+module.exports = function ({ types: t }) {
+	return {
+		visitor: {
+
+			ImportDeclaration: {
+				exit(nodePath, state) {
+					var source = nodePath.get('source');
+					if (source.type === 'StringLiteral') {
+						// console.log(source.node.value);
+						var moduleName = source.node.value;
+						if (moduleName.indexOf('vs/nls') >=0) {
+							source.node.value = './' + state.file.opts.filename.split('/').pop().replace('.js', '.nls.js');
+						} else if (moduleName.indexOf('vs/css!') >= 0) {
+							// source.node.value = moduleName.replace(/vs\/css\!/, '').concat('.css');
+							source.node.value = 'vs/css.esm.js';
+						} else if (moduleName.indexOf('winjs.base') >= 0 && moduleName.indexOf('winjs.base.raw') < 0) {
+							source.node.value = source.node.value.replace('winjs.base', 'winjs.base.esm.js');
+						} else if (moduleName.indexOf('vs/base/common/marked/marked') >= 0) {
+							source.node.value = source.node.value.replace('vs/base/common/marked/marked', 'vs/base/common/marked/raw.marked.esm.js');
+						} else if (moduleName.indexOf('.js') < 0) {
+							source.node.value = moduleName.concat('.js');
+						}
+					}
+				}
+			}
+		}
+	};
+};
\ No newline at end of file
added in remote
  their  100644 17aeef35c01ae8b74d0e43e585989be08d5b5e18 src/tsconfig.esm.json
@@ -0,0 +1,18 @@
+{
+	"compilerOptions": {
+		"module": "es2015",
+		"moduleResolution": "classic",
+		"noImplicitAny": false,
+		"removeComments": true,
+		"preserveConstEnums": true,
+		"target": "es5",
+		"sourceMap": false,
+		"experimentalDecorators": true,
+		"declaration": true,
+		"noImplicitReturns": true,
+		"baseUrl": ".",
+		"typeRoots": [
+			"typings"
+		]
+	}
+}
\ No newline at end of file
changed in both
  base   100644 4ab3711618efcf34220d145b08f9dd0be0cb132b src/vs/base/browser/builder.ts
  our    100644 9c285274a99474b0a9932d403c37f80d148c1ed1 src/vs/base/browser/builder.ts
  their  100644 daf03321756a68fefed902af9ed650211400ec9c src/vs/base/browser/builder.ts
@@ -5,8 +5,14 @@
 'use strict';
 
 import 'vs/css!./builder';
+<<<<<<< .our
 import * as types from 'vs/base/common/types';
 import { IDisposable, dispose, toDisposable } from 'vs/base/common/lifecycle';
+=======
+import { TPromise } from 'vs/base/common/winjs.base';
+import * as types from 'vs/base/common/types';
+import { IDisposable, dispose } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 import * as strings from 'vs/base/common/strings';
 import * as assert from 'vs/base/common/assert';
 import * as DOM from 'vs/base/browser/dom';
changed in both
  base   100644 095e36f8b4bf4920ffc0f4d42150b8b742c8af16 src/vs/base/browser/touch.ts
  our    100644 5620c65ccb62664741a70455e07979e62c79461f src/vs/base/browser/touch.ts
  their  100644 59b33fd589ec1e41163aa69d0e4932221cf56dbe src/vs/base/browser/touch.ts
@@ -7,7 +7,10 @@
 import * as arrays from 'vs/base/common/arrays';
 import { IDisposable, dispose } from 'vs/base/common/lifecycle';
 import * as DomUtils from 'vs/base/browser/dom';
+<<<<<<< .our
 import { memoize } from 'vs/base/common/decorators';
+=======
+>>>>>>> .their
 
 export namespace EventType {
 	export const Tap = '-monaco-gesturetap';
changed in both
  base   100644 688cb903a45e4b197344148c6cade6f9ef7c8ae4 src/vs/base/browser/ui/actionbar/actionbar.ts
  our    100644 0dc7a39304b16126c69b25b0abb4a2effaab717d src/vs/base/browser/ui/actionbar/actionbar.ts
  their  100644 038eda33c64bc0fe282b33dd04574c0e1149ba33 src/vs/base/browser/ui/actionbar/actionbar.ts
@@ -6,16 +6,29 @@
 'use strict';
 
 import 'vs/css!./actionbar';
+<<<<<<< .our
 import * as platform from 'vs/base/common/platform';
+=======
+>>>>>>> .their
 import * as nls from 'vs/nls';
 import * as lifecycle from 'vs/base/common/lifecycle';
 import { TPromise } from 'vs/base/common/winjs.base';
 import { Builder, $ } from 'vs/base/browser/builder';
+<<<<<<< .our
 import { SelectBox, ISelectBoxOptions } from 'vs/base/browser/ui/selectBox/selectBox';
 import { IAction, IActionRunner, Action, IActionChangeEvent, ActionRunner, IRunEvent } from 'vs/base/common/actions';
 import * as DOM from 'vs/base/browser/dom';
 import * as types from 'vs/base/common/types';
 import { EventType, Gesture } from 'vs/base/browser/touch';
+=======
+import { SelectBox } from 'vs/base/browser/ui/selectBox/selectBox';
+import { IAction, IActionRunner, Action, IActionChangeEvent, ActionRunner } from 'vs/base/common/actions';
+import * as DOM from 'vs/base/browser/dom';
+import { EventType as CommonEventType } from 'vs/base/common/events';
+import * as types from 'vs/base/common/types';
+import { IEventEmitter, EventEmitter } from 'vs/base/common/eventEmitter';
+import { Gesture, EventType } from 'vs/base/browser/touch';
+>>>>>>> .their
 import { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';
 import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
 import { IContextViewProvider } from 'vs/base/browser/ui/contextview/contextview';
changed in both
  base   100644 40b28f69b443d1599891a75d20f6d02e03e8b398 src/vs/base/browser/ui/aria/aria.ts
  our    100644 61c7dfd348d863dc44cd2aeeb2a7f5080c3e4e3d src/vs/base/browser/ui/aria/aria.ts
  their  100644 9d59cecfdce9b46b05dab9af11b30fa8d8804392 src/vs/base/browser/ui/aria/aria.ts
changed in both
  base   100644 356692bf76601732194fd4ed1c357a9809f5a84e src/vs/base/browser/ui/button/button.ts
  our    100644 dec147c543de1506718f37f2c9189430227e8531 src/vs/base/browser/ui/button/button.ts
  their  100644 57bed01e40f0cdb48b7db2a7fea8168367808b94 src/vs/base/browser/ui/button/button.ts
@@ -6,6 +6,10 @@
 'use strict';
 
 import 'vs/css!./button';
+<<<<<<< .our
+=======
+import { EventEmitter } from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 import * as DOM from 'vs/base/browser/dom';
 import { Builder, $ } from 'vs/base/browser/builder';
 import { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';
changed in both
  base   100644 10144ee2c719a772dc3f45cf3073f39afc52f40d src/vs/base/browser/ui/checkbox/checkbox.ts
  our    100644 1b1c5df85218f97db807c7df91ace9586a21ff40 src/vs/base/browser/ui/checkbox/checkbox.ts
  their  100644 d47b562e4fdd58cb000a413f8d80449ef6b3d8c4 src/vs/base/browser/ui/checkbox/checkbox.ts
@@ -6,7 +6,15 @@
 'use strict';
 
 import 'vs/css!./checkbox';
+<<<<<<< .our
 import * as DOM from 'vs/base/browser/dom';
+=======
+
+import * as DOM from 'vs/base/browser/dom';
+import * as objects from 'vs/base/common/objects';
+import { KeyCode } from 'vs/base/common/keyCodes';
+import { Widget } from 'vs/base/browser/ui/widget';
+>>>>>>> .their
 import { IKeyboardEvent } from 'vs/base/browser/keyboardEvent';
 import { Widget } from 'vs/base/browser/ui/widget';
 import { Color } from 'vs/base/common/color';
changed in both
  base   100644 dfb187b2ae57d7943dcd2e87b45451ace6228d6c src/vs/base/browser/ui/contextview/contextview.ts
  our    100644 c16fc27af1115c9c89ef5adcf135320ad583520f src/vs/base/browser/ui/contextview/contextview.ts
  their  100644 a8581e136728bef1c31234dc8796a536b0dc6e7d src/vs/base/browser/ui/contextview/contextview.ts
@@ -8,7 +8,12 @@
 import 'vs/css!./contextview';
 import { Builder, $ } from 'vs/base/browser/builder';
 import * as DOM from 'vs/base/browser/dom';
+<<<<<<< .our
 import { IDisposable, dispose, toDisposable } from 'vs/base/common/lifecycle';
+=======
+import { IDisposable, dispose } from 'vs/base/common/lifecycle';
+import { EventEmitter } from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 
 export interface IAnchor {
 	x: number;
changed in both
  base   100644 d13e1c2682ca5ebbcc5db73f8e08f63fe5ccacb3 src/vs/base/browser/ui/iconLabel/iconLabel.ts
  our    100644 74be56db003defdff09c1fd21cf24585cb53ae54 src/vs/base/browser/ui/iconLabel/iconLabel.ts
  their  100644 3e7752c7287f534fdbf71ba3cefd5c1cd7ef995f src/vs/base/browser/ui/iconLabel/iconLabel.ts
@@ -9,7 +9,14 @@
 import * as dom from 'vs/base/browser/dom';
 import { HighlightedLabel } from 'vs/base/browser/ui/highlightedlabel/highlightedLabel';
 import { IMatch } from 'vs/base/common/filters';
+<<<<<<< .our
 import { IDisposable, combinedDisposable, Disposable } from 'vs/base/common/lifecycle';
+=======
+import uri from 'vs/base/common/uri';
+import * as paths from 'vs/base/common/paths';
+import { IRootProvider, getPathLabel, IUserHomeProvider } from 'vs/base/common/labels';
+import { IDisposable, combinedDisposable } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 
 export interface IIconLabelCreationOptions {
 	supportHighlights?: boolean;
changed in both
  base   100644 18b09e697e87723c4a1efc71799e42e9070eeddb src/vs/base/browser/ui/inputbox/inputBox.ts
  our    100644 1691821da48ae0b80b5cd69d2a3d434a6265f2dc src/vs/base/browser/ui/inputbox/inputBox.ts
  their  100644 caf34bf5bdfb7b1a79817a5439579ca815262aec src/vs/base/browser/ui/inputbox/inputBox.ts
changed in both
  base   100644 1f6285529992e19474b123627a402ce7cdc7e3ac src/vs/base/browser/ui/octiconLabel/octiconLabel.mock.ts
  our    100644 7fb29670d641afcf239c0548b050fb6e7ca41b01 src/vs/base/browser/ui/octiconLabel/octiconLabel.mock.ts
  their  100644 36b8d07463d2128193b411fe0c1600f3ff5bcbe8 src/vs/base/browser/ui/octiconLabel/octiconLabel.mock.ts
@@ -2,7 +2,11 @@
  *  Copyright (c) Microsoft Corporation. All rights reserved.
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
+<<<<<<< .our
 
+=======
+import * as octiconLabel from 'vs/base/browser/ui/octiconLabel/octiconLabel';
+>>>>>>> .their
 import { escape } from 'vs/base/common/strings';
 
 export function renderOcticons(text: string): string {
@@ -22,3 +26,12 @@
 	}
 
 }
+<<<<<<< .our
+=======
+
+export var mock: typeof octiconLabel = {
+	expand: expand,
+	OcticonLabel: <any>MockOcticonLabel
+};
+// export = mock;
+>>>>>>> .their
changed in both
  base   100644 ea34e06e1cbb94506a82d837e8a1946441911e49 src/vs/base/browser/ui/progressbar/progressbar.ts
  our    100644 602b7d93dd9f8581041d1e2654381f159993faa3 src/vs/base/browser/ui/progressbar/progressbar.ts
  their  100644 9ddbd6f0936e6a43d7e645ffbd5b4b4948bd7bd7 src/vs/base/browser/ui/progressbar/progressbar.ts
@@ -6,9 +6,17 @@
 'use strict';
 
 import 'vs/css!./progressbar';
+<<<<<<< .our
 import * as assert from 'vs/base/common/assert';
 import { Builder, $ } from 'vs/base/browser/builder';
 import { Disposable } from 'vs/base/common/lifecycle';
+=======
+import { TPromise, ValueCallback } from 'vs/base/common/winjs.base';
+import * as assert from 'vs/base/common/assert';
+import { Builder, $ } from 'vs/base/browser/builder';
+import * as DOM from 'vs/base/browser/dom';
+import { IDisposable, dispose } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 import { Color } from 'vs/base/common/color';
 import { mixin } from 'vs/base/common/objects';
 
removed in local
  base   100644 762852ab390fe1690acb8fc84c829a1a4cf7a760 src/vs/base/browser/ui/resourceviewer/resourceViewer.ts
  their  100644 87bb82400d8cd11a9056986778e97d0061b632db src/vs/base/browser/ui/resourceviewer/resourceViewer.ts
changed in both
  base   100644 338d07b4681e24fb83856600c66ea65b95082a42 src/vs/base/browser/ui/sash/sash.ts
  our    100644 45ce480601b8417948e788935de8182f5fbc1171 src/vs/base/browser/ui/sash/sash.ts
  their  100644 b3f86631889dd068d56b489218455a8e2d89b8fe src/vs/base/browser/ui/sash/sash.ts
@@ -10,7 +10,13 @@
 import { isIPad } from 'vs/base/browser/browser';
 import { isMacintosh } from 'vs/base/common/platform';
 import * as types from 'vs/base/common/types';
+<<<<<<< .our
 import { EventType, GestureEvent, Gesture } from 'vs/base/browser/touch';
+=======
+import * as DOM from 'vs/base/browser/dom';
+import { Gesture, EventType, GestureEvent } from 'vs/base/browser/touch';
+import { EventEmitter } from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 import { StandardMouseEvent } from 'vs/base/browser/mouseEvent';
 import { Event, Emitter } from 'vs/base/common/event';
 import { getElementsByTagName, EventHelper, createStyleSheet, addDisposableListener, append, $, addClass, removeClass, toggleClass } from 'vs/base/browser/dom';
changed in both
  base   100644 6faeda7eb200b325f42cba4482502596729835c0 src/vs/base/browser/ui/splitview/splitview.ts
  our    100644 3f593b721e0e5f25237d90e4a9b2a29fb3997f1a src/vs/base/browser/ui/splitview/splitview.ts
  their  100644 4d8eb65d299c849f861a9cc6908b5cad54c3f1c3 src/vs/base/browser/ui/splitview/splitview.ts
@@ -6,6 +6,7 @@
 'use strict';
 
 import 'vs/css!./splitview';
+<<<<<<< .our
 import { IDisposable, combinedDisposable, toDisposable } from 'vs/base/common/lifecycle';
 import { Event, mapEvent, Emitter } from 'vs/base/common/event';
 import * as types from 'vs/base/common/types';
@@ -13,6 +14,17 @@
 import { clamp } from 'vs/base/common/numbers';
 import { range, firstIndex, pushToStart, pushToEnd } from 'vs/base/common/arrays';
 import { Sash, Orientation, ISashEvent as IBaseSashEvent, SashState } from 'vs/base/browser/ui/sash/sash';
+=======
+import * as lifecycle from 'vs/base/common/lifecycle';
+import * as ee from 'vs/base/common/eventEmitter';
+import * as types from 'vs/base/common/types';
+import * as dom from 'vs/base/browser/dom';
+import * as numbers from 'vs/base/common/numbers';
+import * as sash from 'vs/base/browser/ui/sash/sash';
+import { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';
+import { KeyCode } from 'vs/base/common/keyCodes';
+import Event, { Emitter } from 'vs/base/common/event';
+>>>>>>> .their
 import { Color } from 'vs/base/common/color';
 import { domEvent } from 'vs/base/browser/event';
 export { Orientation } from 'vs/base/browser/ui/sash/sash';
changed in both
  base   100644 2565b518f14194e17cc49f0753a71070f9074494 src/vs/base/browser/ui/toolbar/toolbar.ts
  our    100644 02fcb82fa11db603164c69c9b8d56bba5708737a src/vs/base/browser/ui/toolbar/toolbar.ts
  their  100644 71a8d4c893f185388c65e9bd60086402dc31ee24 src/vs/base/browser/ui/toolbar/toolbar.ts
@@ -8,6 +8,12 @@
 import 'vs/css!./toolbar';
 import * as nls from 'vs/nls';
 import { TPromise } from 'vs/base/common/winjs.base';
+<<<<<<< .our
+=======
+import { IDisposable } from 'vs/base/common/lifecycle';
+import { Builder, $ } from 'vs/base/browser/builder';
+import * as types from 'vs/base/common/types';
+>>>>>>> .their
 import { Action, IActionRunner, IAction } from 'vs/base/common/actions';
 import { ActionBar, ActionsOrientation, IActionItemProvider } from 'vs/base/browser/ui/actionbar/actionbar';
 import { IContextMenuProvider, DropdownMenuActionItem } from 'vs/base/browser/ui/dropdown/dropdown';
changed in both
  base   100644 67a95a10c866e1e41acd5849733beefaa39749e1 src/vs/base/common/comparers.ts
  our    100644 c2448ce4dd1e2d49fee9db8908e01977733bd95d src/vs/base/common/comparers.ts
  their  100644 876b22cf0b4b7a049af43ae9d9f9c987c6b056a0 src/vs/base/common/comparers.ts
@@ -4,6 +4,10 @@
  *--------------------------------------------------------------------------------------------*/
 'use strict';
 
+<<<<<<< .our
+=======
+import * as scorer from 'vs/base/common/scorer';
+>>>>>>> .their
 import * as strings from 'vs/base/common/strings';
 import * as paths from 'vs/base/common/paths';
 
changed in both
  base   100644 1f587120c5e1c5225e9e59577ade56dcf0a715f6 src/vs/base/common/errorMessage.ts
  our    100644 7d2f7b4210d171bf0c817251cf813a62fccae09b src/vs/base/common/errorMessage.ts
  their  100644 17532c863f48d9769a6e6b21459b88c0a6821481 src/vs/base/common/errorMessage.ts
@@ -5,8 +5,161 @@
 'use strict';
 
 import * as nls from 'vs/nls';
+<<<<<<< .our
 import * as types from 'vs/base/common/types';
 import * as arrays from 'vs/base/common/arrays';
+=======
+import * as objects from 'vs/base/common/objects';
+import * as types from 'vs/base/common/types';
+import * as arrays from 'vs/base/common/arrays';
+import * as strings from 'vs/base/common/strings';
+
+export interface IXHRResponse {
+	responseText: string;
+	status: number;
+
+	readyState: number;
+	getResponseHeader: (header: string) => string;
+}
+
+export interface IConnectionErrorData {
+	status: number;
+	statusText?: string;
+	responseText?: string;
+}
+
+/**
+ * The base class for all connection errors originating from XHR requests.
+ */
+export class ConnectionError implements Error {
+	public status: number;
+	public statusText: string;
+	public responseText: string;
+	public errorMessage: string;
+	public errorCode: string;
+	public errorObject: any;
+	public name: string;
+
+	constructor(mixin: IConnectionErrorData);
+	constructor(request: IXHRResponse);
+	constructor(arg: any) {
+		this.status = arg.status;
+		this.statusText = arg.statusText;
+		this.name = 'ConnectionError';
+
+		try {
+			this.responseText = arg.responseText;
+		} catch (e) {
+			this.responseText = '';
+		}
+
+		this.errorMessage = null;
+		this.errorCode = null;
+		this.errorObject = null;
+
+		if (this.responseText) {
+			try {
+				let errorObj = JSON.parse(this.responseText);
+				this.errorMessage = errorObj.message;
+				this.errorCode = errorObj.code;
+				this.errorObject = errorObj;
+			} catch (error) {
+				// Ignore
+			}
+		}
+	}
+
+	public get message(): string {
+		return this.connectionErrorToMessage(this, false);
+	}
+
+	public get verboseMessage(): string {
+		return this.connectionErrorToMessage(this, true);
+	}
+
+	private connectionErrorDetailsToMessage(error: ConnectionError, verbose: boolean): string {
+		let errorCode = error.errorCode;
+		let errorMessage = error.errorMessage;
+
+		if (errorCode !== null && errorMessage !== null) {
+			return nls.localize(
+				{
+					key: 'message',
+					comment: [
+						'{0} represents the error message',
+						'{1} represents the error code'
+					]
+				},
+				"{0}. Error code: {1}",
+				strings.rtrim(errorMessage, '.'), errorCode);
+		}
+
+		if (errorMessage !== null) {
+			return errorMessage;
+		}
+
+		if (verbose && error.responseText !== null) {
+			return error.responseText;
+		}
+
+		return null;
+	}
+
+	private connectionErrorToMessage(error: ConnectionError, verbose: boolean): string {
+		let details = this.connectionErrorDetailsToMessage(error, verbose);
+
+		// Status Code based Error
+		if (error.status === 401) {
+			if (details !== null) {
+				return nls.localize(
+					{
+						key: 'error.permission.verbose',
+						comment: [
+							'{0} represents detailed information why the permission got denied'
+						]
+					},
+					"Permission Denied (HTTP {0})",
+					details);
+			}
+
+			return nls.localize('error.permission', "Permission Denied");
+		}
+
+		// Return error details if present
+		if (details) {
+			return details;
+		}
+
+		// Fallback to HTTP Status and Code
+		if (error.status > 0 && error.statusText !== null) {
+			if (verbose && error.responseText !== null && error.responseText.length > 0) {
+				return nls.localize('error.http.verbose', "{0} (HTTP {1}: {2})", error.statusText, error.status, error.responseText);
+			}
+
+			return nls.localize('error.http', "{0} (HTTP {1})", error.statusText, error.status);
+		}
+
+		// Finally its an Unknown Connection Error
+		if (verbose && error.responseText !== null && error.responseText.length > 0) {
+			return nls.localize('error.connection.unknown.verbose', "Unknown Connection Error ({0})", error.responseText);
+		}
+
+		return nls.localize('error.connection.unknown', "An unknown connection error occurred. Either you are no longer connected to the internet or the server you are connected to is offline.");
+	}
+}
+
+// Bug: Can not subclass a JS Type. Do it manually (as done in WinJS.Class.derive)
+objects.derive(Error, ConnectionError);
+
+function xhrToErrorMessage(xhr: IConnectionErrorData, verbose: boolean): string {
+	let ce = new ConnectionError(xhr);
+	if (verbose) {
+		return ce.verboseMessage;
+	} else {
+		return ce.message;
+	}
+}
+>>>>>>> .their
 
 function exceptionToErrorMessage(exception: any, verbose: boolean): string {
 	if (exception.message) {
changed in both
  base   100644 18d8cad519c8fc779ea3ab760282556cb0073d82 src/vs/base/common/errors.ts
  our    100644 46b7f230ff80d3c03c6159d5c920eb9b2b996ad6 src/vs/base/common/errors.ts
  their  100644 3ec916c0db8a61f792c64fe46f82d5898d95ade9 src/vs/base/common/errors.ts
@@ -4,6 +4,11 @@
  *--------------------------------------------------------------------------------------------*/
 'use strict';
 
+<<<<<<< .our
+=======
+import * as platform from 'vs/base/common/platform';
+import * as types from 'vs/base/common/types';
+>>>>>>> .their
 import { IAction } from 'vs/base/common/actions';
 import { TPromise, IPromiseError, IPromiseErrorDetail } from 'vs/base/common/winjs.base';
 
removed in local
  base   100644 b9217b1c6795f601957fd1fc6d513229590d49d1 src/vs/base/common/eventEmitter.ts
  their  100644 0eefed346fb2a110fb47def5f9783691a2a39b63 src/vs/base/common/eventEmitter.ts
changed in both
  base   100644 27609764bdbe807e61f0298df3f44dd06fd5fcac src/vs/base/common/filters.ts
  our    100644 5f052e2e02afab9ec1e2c937a134ee34b1584315 src/vs/base/common/filters.ts
  their  100644 443135073e1a8909e6197c63cf3680c197d4f990 src/vs/base/common/filters.ts
@@ -5,7 +5,11 @@
 'use strict';
 
 import * as strings from 'vs/base/common/strings';
+<<<<<<< .our
 import { LRUCache } from 'vs/base/common/map';
+=======
+import { BoundedMap } from 'vs/base/common/map';
+>>>>>>> .their
 import { CharCode } from 'vs/base/common/charCode';
 
 export interface IFilter {
changed in both
  base   100644 cc14eea9d51abe2200644f6cfe97373e1393fbaa src/vs/base/common/glob.ts
  our    100644 6ec8e429211b4bfe577a5acce697c639e25f14de src/vs/base/common/glob.ts
  their  100644 8a18be654bf5f6609fd7473abb64a936590dbaaa src/vs/base/common/glob.ts
@@ -5,9 +5,16 @@
 'use strict';
 
 import * as arrays from 'vs/base/common/arrays';
+<<<<<<< .our
 import * as strings from 'vs/base/common/strings';
 import * as paths from 'vs/base/common/paths';
 import { LRUCache } from 'vs/base/common/map';
+=======
+import * as objects from 'vs/base/common/objects';
+import * as strings from 'vs/base/common/strings';
+import * as paths from 'vs/base/common/paths';
+import { BoundedMap } from 'vs/base/common/map';
+>>>>>>> .their
 import { CharCode } from 'vs/base/common/charCode';
 import { TPromise } from 'vs/base/common/winjs.base';
 import { isThenable } from 'vs/base/common/async';
changed in both
  base   100644 63b1c9697abfb2f81f66c550fcfc789be978a5bc src/vs/base/common/labels.ts
  our    100644 44d9373ab80467fdd436c7aa73c68361fa9fce36 src/vs/base/common/labels.ts
  their  100644 6bb9c279c04f0eb165982d0020f47cf8089e5d49 src/vs/base/common/labels.ts
@@ -5,6 +5,7 @@
 'use strict';
 
 import URI from 'vs/base/common/uri';
+<<<<<<< .our
 import { nativeSep, normalize, basename as pathsBasename, sep } from 'vs/base/common/paths';
 import { endsWith, ltrim, startsWithIgnoreCase, rtrim, startsWith } from 'vs/base/common/strings';
 import { Schemas } from 'vs/base/common/network';
@@ -13,6 +14,22 @@
 
 export interface IWorkspaceFolderProvider {
 	getWorkspaceFolder(resource: URI): { uri: URI, name?: string };
+=======
+import * as platform from 'vs/base/common/platform';
+import { nativeSep, normalize, isEqualOrParent, isEqual, basename, join } from 'vs/base/common/paths';
+import { endsWith, ltrim } from 'vs/base/common/strings';
+
+export interface ILabelProvider {
+
+	/**
+	 * Given an element returns a label for it to display in the UI.
+	 */
+	getLabel(element: any): string;
+}
+
+export interface IRootProvider {
+	getRoot(resource: URI): URI;
+>>>>>>> .their
 	getWorkspace(): {
 		folders: { uri: URI, name?: string }[];
 	};
added in remote
  their  100644 91ff6f03aa9f9f14492866d5c2184e4ec6a3ef46 src/vs/base/common/marked/raw.marked.esm.js
@@ -0,0 +1,1295 @@
+/**
+ * marked - a markdown parser
+ * Copyright (c) 2011-2014, Christopher Jeffrey. (MIT Licensed)
+ * https://github.com/chjj/marked
+ */
+
+// TODO MonacoChange: we have our own way of defining modules
+// ;(function() {
+// END MonacoChange
+
+/**
+ * Block-Level Grammar
+ */
+
+var block = {
+	newline: /^\n+/,
+	code: /^( {4}[^\n]+\n*)+/,
+	fences: noop,
+	hr: /^( *[-*_]){3,} *(?:\n+|$)/,
+	heading: /^ *(#{1,6}) *([^\n]+?) *#* *(?:\n+|$)/,
+	nptable: noop,
+	lheading: /^([^\n]+)\n *(=|-){2,} *(?:\n+|$)/,
+	blockquote: /^( *>[^\n]+(\n(?!def)[^\n]+)*\n*)+/,
+	list: /^( *)(bull) [\s\S]+?(?:hr|def|\n{2,}(?! )(?!\1bull )\n*|\s*$)/,
+	html: /^ *(?:comment *(?:\n|\s*$)|closed *(?:\n{2,}|\s*$)|closing *(?:\n{2,}|\s*$))/,
+	def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +["(]([^\n]+)[")])? *(?:\n+|$)/,
+	table: noop,
+	paragraph: /^((?:[^\n]+\n?(?!hr|heading|lheading|blockquote|tag|def))+)\n*/,
+	text: /^[^\n]+/
+};
+
+block.bullet = /(?:[*+-]|\d+\.)/;
+block.item = /^( *)(bull) [^\n]*(?:\n(?!\1bull )[^\n]*)*/;
+block.item = replace(block.item, 'gm')
+	(/bull/g, block.bullet)
+	();
+
+block.list = replace(block.list)
+	(/bull/g, block.bullet)
+	('hr', '\\n+(?=\\1?(?:[-*_] *){3,}(?:\\n+|$))')
+	('def', '\\n+(?=' + block.def.source + ')')
+	();
+
+block.blockquote = replace(block.blockquote)
+	('def', block.def)
+	();
+
+block._tag = '(?!(?:'
+	+ 'a|em|strong|small|s|cite|q|dfn|abbr|data|time|code'
+	+ '|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo'
+	+ '|span|br|wbr|ins|del|img)\\b)\\w+(?!:/|[^\\w\\s@]*@)\\b';
+
+block.html = replace(block.html)
+	('comment', /<!--[\s\S]*?-->/)
+	('closed', /<(tag)[\s\S]+?<\/\1>/)
+	('closing', /<tag(?:"[^"]*"|'[^']*'|[^'">])*?>/)
+	(/tag/g, block._tag)
+	();
+
+block.paragraph = replace(block.paragraph)
+	('hr', block.hr)
+	('heading', block.heading)
+	('lheading', block.lheading)
+	('blockquote', block.blockquote)
+	('tag', '<' + block._tag)
+	('def', block.def)
+	();
+
+/**
+ * Normal Block Grammar
+ */
+
+block.normal = merge({}, block);
+
+/**
+ * GFM Block Grammar
+ */
+
+block.gfm = merge({}, block.normal, {
+	fences: /^ *(`{3,}|~{3,})[ \.]*(\S+)? *\n([\s\S]*?)\s*\1 *(?:\n+|$)/,
+	paragraph: /^/,
+	heading: /^ *(#{1,6}) +([^\n]+?) *#* *(?:\n+|$)/
+});
+
+block.gfm.paragraph = replace(block.paragraph)
+	('(?!', '(?!'
+	+ block.gfm.fences.source.replace('\\1', '\\2') + '|'
+	+ block.list.source.replace('\\1', '\\3') + '|')
+	();
+
+/**
+ * GFM + Tables Block Grammar
+ */
+
+block.tables = merge({}, block.gfm, {
+	nptable: /^ *(\S.*\|.*)\n *([-:]+ *\|[-| :]*)\n((?:.*\|.*(?:\n|$))*)\n*/,
+	table: /^ *\|(.+)\n *\|( *[-:]+[-| :]*)\n((?: *\|.*(?:\n|$))*)\n*/
+});
+
+/**
+ * Block Lexer
+ */
+
+function Lexer(options) {
+	this.tokens = [];
+	this.tokens.links = {};
+	this.options = options || marked.defaults;
+	this.rules = block.normal;
+
+	if (this.options.gfm) {
+		if (this.options.tables) {
+			this.rules = block.tables;
+		} else {
+			this.rules = block.gfm;
+		}
+	}
+}
+
+/**
+ * Expose Block Rules
+ */
+
+Lexer.rules = block;
+
+/**
+ * Static Lex Method
+ */
+
+Lexer.lex = function (src, options) {
+	var lexer = new Lexer(options);
+	return lexer.lex(src);
+};
+
+/**
+ * Preprocessing
+ */
+
+Lexer.prototype.lex = function (src) {
+	src = src
+		.replace(/\r\n|\r/g, '\n')
+		.replace(/\t/g, '    ')
+		.replace(/\u00a0/g, ' ')
+		.replace(/\u2424/g, '\n');
+
+	return this.token(src, true);
+};
+
+/**
+ * Lexing
+ */
+
+Lexer.prototype.token = function (src, top, bq) {
+	var src = src.replace(/^ +$/gm, '')
+		, next
+		, loose
+		, cap
+		, bull
+		, b
+		, item
+		, space
+		, i
+		, l;
+
+	while (src) {
+		// newline
+		if (cap = this.rules.newline.exec(src)) {
+			src = src.substring(cap[0].length);
+			if (cap[0].length > 1) {
+				this.tokens.push({
+					type: 'space'
+				});
+			}
+		}
+
+		// code
+		if (cap = this.rules.code.exec(src)) {
+			src = src.substring(cap[0].length);
+			cap = cap[0].replace(/^ {4}/gm, '');
+			this.tokens.push({
+				type: 'code',
+				text: !this.options.pedantic
+					? cap.replace(/\n+$/, '')
+					: cap
+			});
+			continue;
+		}
+
+		// fences (gfm)
+		if (cap = this.rules.fences.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'code',
+				lang: cap[2],
+				text: cap[3] || ''
+			});
+			continue;
+		}
+
+		// heading
+		if (cap = this.rules.heading.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'heading',
+				depth: cap[1].length,
+				text: cap[2]
+			});
+			continue;
+		}
+
+		// table no leading pipe (gfm)
+		if (top && (cap = this.rules.nptable.exec(src))) {
+			src = src.substring(cap[0].length);
+
+			item = {
+				type: 'table',
+				header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
+				align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
+				cells: cap[3].replace(/\n$/, '').split('\n')
+			};
+
+			for (i = 0; i < item.align.length; i++) {
+				if (/^ *-+: *$/.test(item.align[i])) {
+					item.align[i] = 'right';
+				} else if (/^ *:-+: *$/.test(item.align[i])) {
+					item.align[i] = 'center';
+				} else if (/^ *:-+ *$/.test(item.align[i])) {
+					item.align[i] = 'left';
+				} else {
+					item.align[i] = null;
+				}
+			}
+
+			for (i = 0; i < item.cells.length; i++) {
+				item.cells[i] = item.cells[i].split(/ *\| */);
+			}
+
+			this.tokens.push(item);
+
+			continue;
+		}
+
+		// lheading
+		if (cap = this.rules.lheading.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'heading',
+				depth: cap[2] === '=' ? 1 : 2,
+				text: cap[1]
+			});
+			continue;
+		}
+
+		// hr
+		if (cap = this.rules.hr.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'hr'
+			});
+			continue;
+		}
+
+		// blockquote
+		if (cap = this.rules.blockquote.exec(src)) {
+			src = src.substring(cap[0].length);
+
+			this.tokens.push({
+				type: 'blockquote_start'
+			});
+
+			cap = cap[0].replace(/^ *> ?/gm, '');
+
+			// Pass `top` to keep the current
+			// "toplevel" state. This is exactly
+			// how markdown.pl works.
+			this.token(cap, top, true);
+
+			this.tokens.push({
+				type: 'blockquote_end'
+			});
+
+			continue;
+		}
+
+		// list
+		if (cap = this.rules.list.exec(src)) {
+			src = src.substring(cap[0].length);
+			bull = cap[2];
+
+			this.tokens.push({
+				type: 'list_start',
+				ordered: bull.length > 1
+			});
+
+			// Get each top-level item.
+			cap = cap[0].match(this.rules.item);
+
+			next = false;
+			l = cap.length;
+			i = 0;
+
+			for (; i < l; i++) {
+				item = cap[i];
+
+				// Remove the list item's bullet
+				// so it is seen as the next token.
+				space = item.length;
+				item = item.replace(/^ *([*+-]|\d+\.) +/, '');
+
+				// Outdent whatever the
+				// list item contains. Hacky.
+				if (~item.indexOf('\n ')) {
+					space -= item.length;
+					item = !this.options.pedantic
+						? item.replace(new RegExp('^ {1,' + space + '}', 'gm'), '')
+						: item.replace(/^ {1,4}/gm, '');
+				}
+
+				// Determine whether the next list item belongs here.
+				// Backpedal if it does not belong in this list.
+				if (this.options.smartLists && i !== l - 1) {
+					b = block.bullet.exec(cap[i + 1])[0];
+					if (bull !== b && !(bull.length > 1 && b.length > 1)) {
+						src = cap.slice(i + 1).join('\n') + src;
+						i = l - 1;
+					}
+				}
+
+				// Determine whether item is loose or not.
+				// Use: /(^|\n)(?! )[^\n]+\n\n(?!\s*$)/
+				// for discount behavior.
+				loose = next || /\n\n(?!\s*$)/.test(item);
+				if (i !== l - 1) {
+					next = item.charAt(item.length - 1) === '\n';
+					if (!loose) loose = next;
+				}
+
+				this.tokens.push({
+					type: loose
+						? 'loose_item_start'
+						: 'list_item_start'
+				});
+
+				// Recurse.
+				this.token(item, false, bq);
+
+				this.tokens.push({
+					type: 'list_item_end'
+				});
+			}
+
+			this.tokens.push({
+				type: 'list_end'
+			});
+
+			continue;
+		}
+
+		// html
+		if (cap = this.rules.html.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: this.options.sanitize
+					? 'paragraph'
+					: 'html',
+				pre: !this.options.sanitizer
+				&& (cap[1] === 'pre' || cap[1] === 'script' || cap[1] === 'style'),
+				text: cap[0]
+			});
+			continue;
+		}
+
+		// def
+		if ((!bq && top) && (cap = this.rules.def.exec(src))) {
+			src = src.substring(cap[0].length);
+			this.tokens.links[cap[1].toLowerCase()] = {
+				href: cap[2],
+				title: cap[3]
+			};
+			continue;
+		}
+
+		// table (gfm)
+		if (top && (cap = this.rules.table.exec(src))) {
+			src = src.substring(cap[0].length);
+
+			item = {
+				type: 'table',
+				header: cap[1].replace(/^ *| *\| *$/g, '').split(/ *\| */),
+				align: cap[2].replace(/^ *|\| *$/g, '').split(/ *\| */),
+				cells: cap[3].replace(/(?: *\| *)?\n$/, '').split('\n')
+			};
+
+			for (i = 0; i < item.align.length; i++) {
+				if (/^ *-+: *$/.test(item.align[i])) {
+					item.align[i] = 'right';
+				} else if (/^ *:-+: *$/.test(item.align[i])) {
+					item.align[i] = 'center';
+				} else if (/^ *:-+ *$/.test(item.align[i])) {
+					item.align[i] = 'left';
+				} else {
+					item.align[i] = null;
+				}
+			}
+
+			for (i = 0; i < item.cells.length; i++) {
+				item.cells[i] = item.cells[i]
+					.replace(/^ *\| *| *\| *$/g, '')
+					.split(/ *\| */);
+			}
+
+			this.tokens.push(item);
+
+			continue;
+		}
+
+		// top-level paragraph
+		if (top && (cap = this.rules.paragraph.exec(src))) {
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'paragraph',
+				text: cap[1].charAt(cap[1].length - 1) === '\n'
+					? cap[1].slice(0, -1)
+					: cap[1]
+			});
+			continue;
+		}
+
+		// text
+		if (cap = this.rules.text.exec(src)) {
+			// Top-level should never reach here.
+			src = src.substring(cap[0].length);
+			this.tokens.push({
+				type: 'text',
+				text: cap[0]
+			});
+			continue;
+		}
+
+		if (src) {
+			throw new
+				Error('Infinite loop on byte: ' + src.charCodeAt(0));
+		}
+	}
+
+	return this.tokens;
+};
+
+/**
+ * Inline-Level Grammar
+ */
+
+var inline = {
+	escape: /^\\([\\`*{}\[\]()#+\-.!_>])/,
+	autolink: /^<([^ >]+(@|:\/)[^ >]+)>/,
+	url: noop,
+	tag: /^<!--[\s\S]*?-->|^<\/?\w+(?:"[^"]*"|'[^']*'|[^'">])*?>/,
+	link: /^!?\[(inside)\]\(href\)/,
+	reflink: /^!?\[(inside)\]\s*\[([^\]]*)\]/,
+	nolink: /^!?\[((?:\[[^\]]*\]|[^\[\]])*)\]/,
+	strong: /^__([\s\S]+?)__(?!_)|^\*\*([\s\S]+?)\*\*(?!\*)/,
+	em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
+	code: /^(`+)\s*([\s\S]*?[^`])\s*\1(?!`)/,
+	br: /^ {2,}\n(?!\s*$)/,
+	del: noop,
+	text: /^[\s\S]+?(?=[\\<!\[_*`]| {2,}\n|$)/
+};
+
+inline._inside = /(?:\[[^\]]*\]|[^\[\]]|\](?=[^\[]*\]))*/;
+inline._href = /\s*<?([\s\S]*?)>?(?:\s+['"]([\s\S]*?)['"])?\s*/;
+
+inline.link = replace(inline.link)
+	('inside', inline._inside)
+	('href', inline._href)
+	();
+
+inline.reflink = replace(inline.reflink)
+	('inside', inline._inside)
+	();
+
+/**
+ * Normal Inline Grammar
+ */
+
+inline.normal = merge({}, inline);
+
+/**
+ * Pedantic Inline Grammar
+ */
+
+inline.pedantic = merge({}, inline.normal, {
+	strong: /^__(?=\S)([\s\S]*?\S)__(?!_)|^\*\*(?=\S)([\s\S]*?\S)\*\*(?!\*)/,
+	em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
+});
+
+/**
+ * GFM Inline Grammar
+ */
+
+inline.gfm = merge({}, inline.normal, {
+	escape: replace(inline.escape)('])', '~|])')(),
+	url: /^(https?:\/\/[^\s<]+[^<.,:;"')\]\s])/,
+	del: /^~~(?=\S)([\s\S]*?\S)~~/,
+	text: replace(inline.text)
+		(']|', '~]|')
+		('|', '|https?://|')
+		()
+});
+
+/**
+ * GFM + Line Breaks Inline Grammar
+ */
+
+inline.breaks = merge({}, inline.gfm, {
+	br: replace(inline.br)('{2,}', '*')(),
+	text: replace(inline.gfm.text)('{2,}', '*')()
+});
+
+/**
+ * Inline Lexer & Compiler
+ */
+
+function InlineLexer(links, options) {
+	this.options = options || marked.defaults;
+	this.links = links;
+	this.rules = inline.normal;
+	this.renderer = this.options.renderer || new Renderer;
+	this.renderer.options = this.options;
+
+	if (!this.links) {
+		throw new
+			Error('Tokens array requires a `links` property.');
+	}
+
+	if (this.options.gfm) {
+		if (this.options.breaks) {
+			this.rules = inline.breaks;
+		} else {
+			this.rules = inline.gfm;
+		}
+	} else if (this.options.pedantic) {
+		this.rules = inline.pedantic;
+	}
+}
+
+/**
+ * Expose Inline Rules
+ */
+
+InlineLexer.rules = inline;
+
+/**
+ * Static Lexing/Compiling Method
+ */
+
+InlineLexer.output = function (src, links, options) {
+	var inline = new InlineLexer(links, options);
+	return inline.output(src);
+};
+
+/**
+ * Lexing/Compiling
+ */
+
+InlineLexer.prototype.output = function (src) {
+	var out = ''
+		, link
+		, text
+		, href
+		, cap;
+
+	while (src) {
+		// escape
+		if (cap = this.rules.escape.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += cap[1];
+			continue;
+		}
+
+		// autolink
+		if (cap = this.rules.autolink.exec(src)) {
+			src = src.substring(cap[0].length);
+			if (cap[2] === '@') {
+				text = cap[1].charAt(6) === ':'
+					? this.mangle(cap[1].substring(7))
+					: this.mangle(cap[1]);
+				href = this.mangle('mailto:') + text;
+			} else {
+				text = escape(cap[1]);
+				href = text;
+			}
+			out += this.renderer.link(href, null, text);
+			continue;
+		}
+
+		// url (gfm)
+		if (!this.inLink && (cap = this.rules.url.exec(src))) {
+			src = src.substring(cap[0].length);
+			text = escape(cap[1]);
+			href = text;
+			out += this.renderer.link(href, null, text);
+			continue;
+		}
+
+		// tag
+		if (cap = this.rules.tag.exec(src)) {
+			if (!this.inLink && /^<a /i.test(cap[0])) {
+				this.inLink = true;
+			} else if (this.inLink && /^<\/a>/i.test(cap[0])) {
+				this.inLink = false;
+			}
+			src = src.substring(cap[0].length);
+			out += this.options.sanitize
+				? this.options.sanitizer
+					? this.options.sanitizer(cap[0])
+					: escape(cap[0])
+				: cap[0]
+			continue;
+		}
+
+		// link
+		if (cap = this.rules.link.exec(src)) {
+			src = src.substring(cap[0].length);
+			this.inLink = true;
+			out += this.outputLink(cap, {
+				href: cap[2],
+				title: cap[3]
+			});
+			this.inLink = false;
+			continue;
+		}
+
+		// reflink, nolink
+		if ((cap = this.rules.reflink.exec(src))
+			|| (cap = this.rules.nolink.exec(src))) {
+			src = src.substring(cap[0].length);
+			link = (cap[2] || cap[1]).replace(/\s+/g, ' ');
+			link = this.links[link.toLowerCase()];
+			if (!link || !link.href) {
+				out += cap[0].charAt(0);
+				src = cap[0].substring(1) + src;
+				continue;
+			}
+			this.inLink = true;
+			out += this.outputLink(cap, link);
+			this.inLink = false;
+			continue;
+		}
+
+		// strong
+		if (cap = this.rules.strong.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.strong(this.output(cap[2] || cap[1]));
+			continue;
+		}
+
+		// em
+		if (cap = this.rules.em.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.em(this.output(cap[2] || cap[1]));
+			continue;
+		}
+
+		// code
+		if (cap = this.rules.code.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.codespan(escape(cap[2], true));
+			continue;
+		}
+
+		// br
+		if (cap = this.rules.br.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.br();
+			continue;
+		}
+
+		// del (gfm)
+		if (cap = this.rules.del.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.del(this.output(cap[1]));
+			continue;
+		}
+
+		// text
+		if (cap = this.rules.text.exec(src)) {
+			src = src.substring(cap[0].length);
+			out += this.renderer.text(escape(this.smartypants(cap[0])));
+			continue;
+		}
+
+		if (src) {
+			throw new
+				Error('Infinite loop on byte: ' + src.charCodeAt(0));
+		}
+	}
+
+	return out;
+};
+
+/**
+ * Compile Link
+ */
+
+InlineLexer.prototype.outputLink = function (cap, link) {
+	var href = escape(link.href)
+		, title = link.title ? escape(link.title) : null;
+
+	return cap[0].charAt(0) !== '!'
+		? this.renderer.link(href, title, this.output(cap[1]))
+		: this.renderer.image(href, title, escape(cap[1]));
+};
+
+/**
+ * Smartypants Transformations
+ */
+
+InlineLexer.prototype.smartypants = function (text) {
+	if (!this.options.smartypants) return text;
+	return text
+		// em-dashes
+		.replace(/---/g, '\u2014')
+		// en-dashes
+		.replace(/--/g, '\u2013')
+		// opening singles
+		.replace(/(^|[-\u2014/(\[{"\s])'/g, '$1\u2018')
+		// closing singles & apostrophes
+		.replace(/'/g, '\u2019')
+		// opening doubles
+		.replace(/(^|[-\u2014/(\[{\u2018\s])"/g, '$1\u201c')
+		// closing doubles
+		.replace(/"/g, '\u201d')
+		// ellipses
+		.replace(/\.{3}/g, '\u2026');
+};
+
+/**
+ * Mangle Links
+ */
+
+InlineLexer.prototype.mangle = function (text) {
+	if (!this.options.mangle) return text;
+	var out = ''
+		, l = text.length
+		, i = 0
+		, ch;
+
+	for (; i < l; i++) {
+		ch = text.charCodeAt(i);
+		if (Math.random() > 0.5) {
+			ch = 'x' + ch.toString(16);
+		}
+		out += '&#' + ch + ';';
+	}
+
+	return out;
+};
+
+/**
+ * Renderer
+ */
+
+function Renderer(options) {
+	this.options = options || {};
+}
+
+Renderer.prototype.code = function (code, lang, escaped) {
+	if (this.options.highlight) {
+		var out = this.options.highlight(code, lang);
+		if (out != null && out !== code) {
+			escaped = true;
+			code = out;
+		}
+	}
+
+	if (!lang) {
+		return '<pre><code>'
+			+ (escaped ? code : escape(code, true))
+			+ '\n</code></pre>';
+	}
+
+	return '<pre><code class="'
+		+ this.options.langPrefix
+		+ escape(lang, true)
+		+ '">'
+		+ (escaped ? code : escape(code, true))
+		+ '\n</code></pre>\n';
+};
+
+Renderer.prototype.blockquote = function (quote) {
+	return '<blockquote>\n' + quote + '</blockquote>\n';
+};
+
+Renderer.prototype.html = function (html) {
+	return html;
+};
+
+Renderer.prototype.heading = function (text, level, raw) {
+	return '<h'
+		+ level
+		+ ' id="'
+		+ this.options.headerPrefix
+		+ raw.toLowerCase().replace(/[^\w]+/g, '-')
+		+ '">'
+		+ text
+		+ '</h'
+		+ level
+		+ '>\n';
+};
+
+Renderer.prototype.hr = function () {
+	return this.options.xhtml ? '<hr/>\n' : '<hr>\n';
+};
+
+Renderer.prototype.list = function (body, ordered) {
+	var type = ordered ? 'ol' : 'ul';
+	return '<' + type + '>\n' + body + '</' + type + '>\n';
+};
+
+Renderer.prototype.listitem = function (text) {
+	return '<li>' + text + '</li>\n';
+};
+
+Renderer.prototype.paragraph = function (text) {
+	return '<p>' + text + '</p>\n';
+};
+
+Renderer.prototype.table = function (header, body) {
+	return '<table>\n'
+		+ '<thead>\n'
+		+ header
+		+ '</thead>\n'
+		+ '<tbody>\n'
+		+ body
+		+ '</tbody>\n'
+		+ '</table>\n';
+};
+
+Renderer.prototype.tablerow = function (content) {
+	return '<tr>\n' + content + '</tr>\n';
+};
+
+Renderer.prototype.tablecell = function (content, flags) {
+	var type = flags.header ? 'th' : 'td';
+	var tag = flags.align
+		? '<' + type + ' style="text-align:' + flags.align + '">'
+		: '<' + type + '>';
+	return tag + content + '</' + type + '>\n';
+};
+
+// span level renderer
+Renderer.prototype.strong = function (text) {
+	return '<strong>' + text + '</strong>';
+};
+
+Renderer.prototype.em = function (text) {
+	return '<em>' + text + '</em>';
+};
+
+Renderer.prototype.codespan = function (text) {
+	return '<code>' + text + '</code>';
+};
+
+Renderer.prototype.br = function () {
+	return this.options.xhtml ? '<br/>' : '<br>';
+};
+
+Renderer.prototype.del = function (text) {
+	return '<del>' + text + '</del>';
+};
+
+Renderer.prototype.link = function (href, title, text) {
+	if (this.options.sanitize) {
+		try {
+			var prot = decodeURIComponent(unescape(href))
+				.replace(/[^\w:]/g, '')
+				.toLowerCase();
+		} catch (e) {
+			return '';
+		}
+		if (prot.indexOf('javascript:') === 0 || prot.indexOf('vbscript:') === 0 || prot.indexOf('data:') === 0) {
+			return '';
+		}
+	}
+	var out = '<a href="' + href + '"';
+	if (title) {
+		out += ' title="' + title + '"';
+	}
+	out += '>' + text + '</a>';
+	return out;
+};
+
+Renderer.prototype.image = function (href, title, text) {
+	var out = '<img src="' + href + '" alt="' + text + '"';
+	if (title) {
+		out += ' title="' + title + '"';
+	}
+	out += this.options.xhtml ? '/>' : '>';
+	return out;
+};
+
+Renderer.prototype.text = function (text) {
+	return text;
+};
+
+/**
+ * Parsing & Compiling
+ */
+
+function Parser(options) {
+	this.tokens = [];
+	this.token = null;
+	this.options = options || marked.defaults;
+	this.options.renderer = this.options.renderer || new Renderer;
+	this.renderer = this.options.renderer;
+	this.renderer.options = this.options;
+}
+
+/**
+ * Static Parse Method
+ */
+
+Parser.parse = function (src, options, renderer) {
+	var parser = new Parser(options, renderer);
+	return parser.parse(src);
+};
+
+/**
+ * Parse Loop
+ */
+
+Parser.prototype.parse = function (src) {
+	this.inline = new InlineLexer(src.links, this.options, this.renderer);
+	this.tokens = src.reverse();
+
+	var out = '';
+	while (this.next()) {
+		out += this.tok();
+	}
+
+	return out;
+};
+
+/**
+ * Next Token
+ */
+
+Parser.prototype.next = function () {
+	return this.token = this.tokens.pop();
+};
+
+/**
+ * Preview Next Token
+ */
+
+Parser.prototype.peek = function () {
+	return this.tokens[this.tokens.length - 1] || 0;
+};
+
+/**
+ * Parse Text Tokens
+ */
+
+Parser.prototype.parseText = function () {
+	var body = this.token.text;
+
+	while (this.peek().type === 'text') {
+		body += '\n' + this.next().text;
+	}
+
+	return this.inline.output(body);
+};
+
+/**
+ * Parse Current Token
+ */
+
+Parser.prototype.tok = function () {
+	switch (this.token.type) {
+		case 'space': {
+			return '';
+		}
+		case 'hr': {
+			return this.renderer.hr();
+		}
+		case 'heading': {
+			return this.renderer.heading(
+				this.inline.output(this.token.text),
+				this.token.depth,
+				this.token.text);
+		}
+		case 'code': {
+			return this.renderer.code(this.token.text,
+				this.token.lang,
+				this.token.escaped);
+		}
+		case 'table': {
+			var header = ''
+				, body = ''
+				, i
+				, row
+				, cell
+				, flags
+				, j;
+
+			// header
+			cell = '';
+			for (i = 0; i < this.token.header.length; i++) {
+				flags = { header: true, align: this.token.align[i] };
+				cell += this.renderer.tablecell(
+					this.inline.output(this.token.header[i]),
+					{ header: true, align: this.token.align[i] }
+				);
+			}
+			header += this.renderer.tablerow(cell);
+
+			for (i = 0; i < this.token.cells.length; i++) {
+				row = this.token.cells[i];
+
+				cell = '';
+				for (j = 0; j < row.length; j++) {
+					cell += this.renderer.tablecell(
+						this.inline.output(row[j]),
+						{ header: false, align: this.token.align[j] }
+					);
+				}
+
+				body += this.renderer.tablerow(cell);
+			}
+			return this.renderer.table(header, body);
+		}
+		case 'blockquote_start': {
+			var body = '';
+
+			while (this.next().type !== 'blockquote_end') {
+				body += this.tok();
+			}
+
+			return this.renderer.blockquote(body);
+		}
+		case 'list_start': {
+			var body = ''
+				, ordered = this.token.ordered;
+
+			while (this.next().type !== 'list_end') {
+				body += this.tok();
+			}
+
+			return this.renderer.list(body, ordered);
+		}
+		case 'list_item_start': {
+			var body = '';
+
+			while (this.next().type !== 'list_item_end') {
+				body += this.token.type === 'text'
+					? this.parseText()
+					: this.tok();
+			}
+
+			return this.renderer.listitem(body);
+		}
+		case 'loose_item_start': {
+			var body = '';
+
+			while (this.next().type !== 'list_item_end') {
+				body += this.tok();
+			}
+
+			return this.renderer.listitem(body);
+		}
+		case 'html': {
+			var html = !this.token.pre && !this.options.pedantic
+				? this.inline.output(this.token.text)
+				: this.token.text;
+			return this.renderer.html(html);
+		}
+		case 'paragraph': {
+			return this.renderer.paragraph(this.inline.output(this.token.text));
+		}
+		case 'text': {
+			return this.renderer.paragraph(this.parseText());
+		}
+	}
+};
+
+/**
+ * Helpers
+ */
+
+function escape(html, encode) {
+	return html
+		.replace(!encode ? /&(?!#?\w+;)/g : /&/g, '&amp;')
+		.replace(/</g, '&lt;')
+		.replace(/>/g, '&gt;')
+		.replace(/"/g, '&quot;')
+		.replace(/'/g, '&#39;');
+}
+
+function unescape(html) {
+	// explicitly match decimal, hex, and named HTML entities
+	return html.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/g, function (_, n) {
+		n = n.toLowerCase();
+		if (n === 'colon') return ':';
+		if (n.charAt(0) === '#') {
+			return n.charAt(1) === 'x'
+				? String.fromCharCode(parseInt(n.substring(2), 16))
+				: String.fromCharCode(+n.substring(1));
+		}
+		return '';
+	});
+}
+
+function replace(regex, opt) {
+	regex = regex.source;
+	opt = opt || '';
+	return function self(name, val) {
+		if (!name) return new RegExp(regex, opt);
+		val = val.source || val;
+		val = val.replace(/(^|[^\[])\^/g, '$1');
+		regex = regex.replace(name, val);
+		return self;
+	};
+}
+
+function noop() { }
+noop.exec = noop;
+
+function merge(obj) {
+	var i = 1
+		, target
+		, key;
+
+	for (; i < arguments.length; i++) {
+		target = arguments[i];
+		for (key in target) {
+			if (Object.prototype.hasOwnProperty.call(target, key)) {
+				obj[key] = target[key];
+			}
+		}
+	}
+
+	return obj;
+}
+
+
+/**
+ * Marked
+ */
+
+export function marked(src, opt, callback) {
+	if (callback || typeof opt === 'function') {
+		if (!callback) {
+			callback = opt;
+			opt = null;
+		}
+
+		opt = merge({}, marked.defaults, opt || {});
+
+		var highlight = opt.highlight
+			, tokens
+			, pending
+			, i = 0;
+
+		try {
+			tokens = Lexer.lex(src, opt)
+		} catch (e) {
+			return callback(e);
+		}
+
+		pending = tokens.length;
+
+		var done = function (err) {
+			if (err) {
+				opt.highlight = highlight;
+				return callback(err);
+			}
+
+			var out;
+
+			try {
+				out = Parser.parse(tokens, opt);
+			} catch (e) {
+				err = e;
+			}
+
+			opt.highlight = highlight;
+
+			return err
+				? callback(err)
+				: callback(null, out);
+		};
+
+		if (!highlight || highlight.length < 3) {
+			return done();
+		}
+
+		delete opt.highlight;
+
+		if (!pending) return done();
+
+		for (; i < tokens.length; i++) {
+			(function (token) {
+				if (token.type !== 'code') {
+					return --pending || done();
+				}
+				return highlight(token.text, token.lang, function (err, code) {
+					if (err) return done(err);
+					if (code == null || code === token.text) {
+						return --pending || done();
+					}
+					token.text = code;
+					token.escaped = true;
+					--pending || done();
+				});
+			})(tokens[i]);
+		}
+
+		return;
+	}
+	try {
+		if (opt) opt = merge({}, marked.defaults, opt);
+		return Parser.parse(Lexer.lex(src, opt), opt);
+	} catch (e) {
+		e.message += '\nPlease report this to https://github.com/chjj/marked.';
+		if ((opt || marked.defaults).silent) {
+			return '<p>An error occurred:</p><pre>'
+				+ escape(e.message + '', true)
+				+ '</pre>';
+		}
+		throw e;
+	}
+}
+
+/**
+ * Options
+ */
+
+marked.options =
+	marked.setOptions = function (opt) {
+		merge(marked.defaults, opt);
+		return marked;
+	};
+
+marked.defaults = {
+	gfm: true,
+	tables: true,
+	breaks: false,
+	pedantic: false,
+	sanitize: false,
+	sanitizer: null,
+	mangle: true,
+	smartLists: false,
+	silent: false,
+	highlight: null,
+	langPrefix: 'lang-',
+	smartypants: false,
+	headerPrefix: '',
+	renderer: new Renderer,
+	xhtml: false
+};
+
+/**
+ * Expose
+ */
+
+marked.Parser = Parser;
+marked.parser = Parser.parse;
+
+marked.Renderer = Renderer;
+
+marked.Lexer = Lexer;
+marked.lexer = Lexer.lex;
+
+marked.InlineLexer = InlineLexer;
+marked.inlineLexer = InlineLexer.output;
+
+marked.parse = marked;
+
+// TODO MonacoChange: we have our own way of defining modules
+// define([], function() {
+//   return marked;
+// });
+//if (typeof module !== 'undefined' && typeof exports === 'object') {
+//  module.exports = marked;
+//} else if (typeof define === 'function' && define.amd) {
+//  define(function() { return marked; });
+//} else {
+//  this.marked = marked;
+//}
+//
+//}).call(function() {
+//  return this || (typeof window !== 'undefined' ? window : global);
+//}());
+// END MonacoChange
+
+export default marked;
\ No newline at end of file
changed in both
  base   100644 6868a2989664a5dd6e951047cfb923a147b3b523 src/vs/base/common/mime.ts
  our    100644 f2eb135794a355007d7c19ba089a4092a9bc9081 src/vs/base/common/mime.ts
  their  100644 a790195caa2614a96738d0a4cf2f85c3f435043c src/vs/base/common/mime.ts
@@ -5,6 +5,10 @@
 'use strict';
 
 import * as paths from 'vs/base/common/paths';
+<<<<<<< .our
+=======
+import * as types from 'vs/base/common/types';
+>>>>>>> .their
 import * as strings from 'vs/base/common/strings';
 import { match } from 'vs/base/common/glob';
 
changed in both
  base   100644 65bcbbd79229445d5b414984568db7dc78f0690f src/vs/base/common/numbers.ts
  our    100644 fa4932e9ec70cf5d433273dc84e88ce78eb5fbc6 src/vs/base/common/numbers.ts
  their  100644 e040cc2e7912f242dc45ae21addf2402a66d52b9 src/vs/base/common/numbers.ts
@@ -5,8 +5,36 @@
 
 'use strict';
 
+<<<<<<< .our
 export function clamp(value: number, min: number, max: number): number {
 	return Math.min(Math.max(value, min), max);
+=======
+import * as types from 'vs/base/common/types';
+
+export type NumberCallback = (index: number) => void;
+
+export function count(to: number, callback: NumberCallback): void;
+export function count(from: number, to: number, callback: NumberCallback): void;
+export function count(fromOrTo: number, toOrCallback?: NumberCallback | number, callback?: NumberCallback): any {
+	let from: number;
+	let to: number;
+
+	if (types.isNumber(toOrCallback)) {
+		from = fromOrTo;
+		to = <number>toOrCallback;
+	} else {
+		from = 0;
+		to = fromOrTo;
+		callback = <NumberCallback>toOrCallback;
+	}
+
+	const op = from <= to ? (i: number) => i + 1 : (i: number) => i - 1;
+	const cmp = from <= to ? (a: number, b: number) => a < b : (a: number, b: number) => a > b;
+
+	for (let i = from; cmp(i, to); i = op(i)) {
+		callback(i);
+	}
+>>>>>>> .their
 }
 
 export function rot(index: number, modulo: number): number {
changed in both
  base   100644 07da59265e91c2f5e84ef42e922aa3b0cde3b12e src/vs/base/common/processes.ts
  our    100644 adc3504949efd20369ddaaf5f894545227b0d570 src/vs/base/common/processes.ts
  their  100644 806aea7310c48671bc2643edcb92d516ba15ec57 src/vs/base/common/processes.ts
@@ -4,6 +4,18 @@
  *--------------------------------------------------------------------------------------------*/
 'use strict';
 
+<<<<<<< .our
+=======
+import * as NLS from 'vs/nls';
+
+import * as Objects from 'vs/base/common/objects';
+import * as Platform from 'vs/base/common/platform';
+import { IStringDictionary } from 'vs/base/common/collections';
+import * as Types from 'vs/base/common/types';
+
+import { ValidationState, IProblemReporter, Parser } from 'vs/base/common/parsers';
+
+>>>>>>> .their
 /**
  * Options to be passed to the external program or shell.
  */
changed in both
  base   100644 96d698cb449479b15e77e34af063adfa55e17bc2 src/vs/base/common/severity.ts
  our    100644 fd6980d689e13219986e4a8a6bf22559bc7efe5a src/vs/base/common/severity.ts
  their  100644 1dd85bb1712ff98476b802efb102979d18044e58 src/vs/base/common/severity.ts
added in remote
  their  100644 958c5e05e5e5a0545501309fa6cdb8a094b22f46 src/vs/base/common/winjs.base.esm.js
@@ -0,0 +1,2038 @@
+/**
+ * Extracted from https://github.com/winjs/winjs
+ * Version: 4.4.0(ec3258a9f3a36805a187848984e3bb938044178d)
+ * Copyright (c) Microsoft Corporation.
+ * All Rights Reserved.
+ * Licensed under the MIT License.
+ */
+
+var exported;
+(function () {
+
+    var _modules = {};
+    _modules["WinJS/Core/_WinJS"] = {};
+
+    var _winjs = function (moduleId, deps, factory) {
+        var exports = {};
+        var exportsPassedIn = false;
+
+        var depsValues = deps.map(function (dep) {
+            if (dep === 'exports') {
+                exportsPassedIn = true;
+                return exports;
+            }
+            return _modules[dep];
+        });
+
+        var result = factory.apply({}, depsValues);
+
+        _modules[moduleId] = exportsPassedIn ? exports : result;
+    };
+
+    _winjs("WinJS/Core/_Global", [], function () {
+        "use strict";
+
+        // Appease jshint
+        /* global window, self, global */
+
+        var globalObject = typeof window !== 'undefined' ? window : typeof self !== 'undefined' ? self : typeof global !== 'undefined' ? global : {};
+        return globalObject;
+    });
+
+    _winjs("WinJS/Core/_BaseCoreUtils", ["WinJS/Core/_Global"], function baseCoreUtilsInit(_Global) {
+        "use strict";
+
+        var hasWinRT = !!_Global.Windows;
+
+        function markSupportedForProcessing(func) {
+            /// <signature helpKeyword="WinJS.Utilities.markSupportedForProcessing">
+            /// <summary locid="WinJS.Utilities.markSupportedForProcessing">
+            /// Marks a function as being compatible with declarative processing, such as WinJS.UI.processAll
+            /// or WinJS.Binding.processAll.
+            /// </summary>
+            /// <param name="func" type="Function" locid="WinJS.Utilities.markSupportedForProcessing_p:func">
+            /// The function to be marked as compatible with declarative processing.
+            /// </param>
+            /// <returns type="Function" locid="WinJS.Utilities.markSupportedForProcessing_returnValue">
+            /// The input function.
+            /// </returns>
+            /// </signature>
+            func.supportedForProcessing = true;
+            return func;
+        }
+
+        return {
+            hasWinRT: hasWinRT,
+            markSupportedForProcessing: markSupportedForProcessing,
+            _setImmediate: _Global.setImmediate ? _Global.setImmediate.bind(_Global) : function (handler) {
+                _Global.setTimeout(handler, 0);
+            }
+        };
+    });
+    _winjs("WinJS/Core/_WriteProfilerMark", ["WinJS/Core/_Global"], function profilerInit(_Global) {
+        "use strict";
+
+        return _Global.msWriteProfilerMark || function () {};
+    });
+    _winjs("WinJS/Core/_Base", ["WinJS/Core/_WinJS", "WinJS/Core/_Global", "WinJS/Core/_BaseCoreUtils", "WinJS/Core/_WriteProfilerMark"], function baseInit(_WinJS, _Global, _BaseCoreUtils, _WriteProfilerMark) {
+        "use strict";
+
+        function initializeProperties(target, members, prefix) {
+            var keys = Object.keys(members);
+            var isArray = Array.isArray(target);
+            var properties;
+            var i, len;
+            for (i = 0, len = keys.length; i < len; i++) {
+                var key = keys[i];
+                var enumerable = key.charCodeAt(0) !== /*_*/95;
+                var member = members[key];
+                if (member && typeof member === 'object') {
+                    if (member.value !== undefined || typeof member.get === 'function' || typeof member.set === 'function') {
+                        if (member.enumerable === undefined) {
+                            member.enumerable = enumerable;
+                        }
+                        if (prefix && member.setName && typeof member.setName === 'function') {
+                            member.setName(prefix + "." + key);
+                        }
+                        properties = properties || {};
+                        properties[key] = member;
+                        continue;
+                    }
+                }
+                if (!enumerable) {
+                    properties = properties || {};
+                    properties[key] = { value: member, enumerable: enumerable, configurable: true, writable: true };
+                    continue;
+                }
+                if (isArray) {
+                    target.forEach(function (target) {
+                        target[key] = member;
+                    });
+                } else {
+                    target[key] = member;
+                }
+            }
+            if (properties) {
+                if (isArray) {
+                    target.forEach(function (target) {
+                        Object.defineProperties(target, properties);
+                    });
+                } else {
+                    Object.defineProperties(target, properties);
+                }
+            }
+        }
+
+        (function () {
+
+            var _rootNamespace = _WinJS;
+            if (!_rootNamespace.Namespace) {
+                _rootNamespace.Namespace = Object.create(Object.prototype);
+            }
+
+            function createNamespace(parentNamespace, name) {
+                var currentNamespace = parentNamespace || {};
+                if (name) {
+                    var namespaceFragments = name.split(".");
+                    if (currentNamespace === _Global && namespaceFragments[0] === "WinJS") {
+                        currentNamespace = _WinJS;
+                        namespaceFragments.splice(0, 1);
+                    }
+                    for (var i = 0, len = namespaceFragments.length; i < len; i++) {
+                        var namespaceName = namespaceFragments[i];
+                        if (!currentNamespace[namespaceName]) {
+                            Object.defineProperty(currentNamespace, namespaceName, { value: {}, writable: false, enumerable: true, configurable: true });
+                        }
+                        currentNamespace = currentNamespace[namespaceName];
+                    }
+                }
+                return currentNamespace;
+            }
+
+            function defineWithParent(parentNamespace, name, members) {
+                /// <signature helpKeyword="WinJS.Namespace.defineWithParent">
+                /// <summary locid="WinJS.Namespace.defineWithParent">
+                /// Defines a new namespace with the specified name under the specified parent namespace.
+                /// </summary>
+                /// <param name="parentNamespace" type="Object" locid="WinJS.Namespace.defineWithParent_p:parentNamespace">
+                /// The parent namespace.
+                /// </param>
+                /// <param name="name" type="String" locid="WinJS.Namespace.defineWithParent_p:name">
+                /// The name of the new namespace.
+                /// </param>
+                /// <param name="members" type="Object" locid="WinJS.Namespace.defineWithParent_p:members">
+                /// The members of the new namespace.
+                /// </param>
+                /// <returns type="Object" locid="WinJS.Namespace.defineWithParent_returnValue">
+                /// The newly-defined namespace.
+                /// </returns>
+                /// </signature>
+                var currentNamespace = createNamespace(parentNamespace, name);
+
+                if (members) {
+                    initializeProperties(currentNamespace, members, name || "<ANONYMOUS>");
+                }
+
+                return currentNamespace;
+            }
+
+            function define(name, members) {
+                /// <signature helpKeyword="WinJS.Namespace.define">
+                /// <summary locid="WinJS.Namespace.define">
+                /// Defines a new namespace with the specified name.
+                /// </summary>
+                /// <param name="name" type="String" locid="WinJS.Namespace.define_p:name">
+                /// The name of the namespace. This could be a dot-separated name for nested namespaces.
+                /// </param>
+                /// <param name="members" type="Object" locid="WinJS.Namespace.define_p:members">
+                /// The members of the new namespace.
+                /// </param>
+                /// <returns type="Object" locid="WinJS.Namespace.define_returnValue">
+                /// The newly-defined namespace.
+                /// </returns>
+                /// </signature>
+                return defineWithParent(_Global, name, members);
+            }
+
+            var LazyStates = {
+                uninitialized: 1,
+                working: 2,
+                initialized: 3
+            };
+
+            function lazy(f) {
+                var name;
+                var state = LazyStates.uninitialized;
+                var result;
+                return {
+                    setName: function (value) {
+                        name = value;
+                    },
+                    get: function () {
+                        switch (state) {
+                            case LazyStates.initialized:
+                                return result;
+
+                            case LazyStates.uninitialized:
+                                state = LazyStates.working;
+                                try {
+                                    _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StartTM");
+                                    result = f();
+                                } finally {
+                                    _WriteProfilerMark("WinJS.Namespace._lazy:" + name + ",StopTM");
+                                    state = LazyStates.uninitialized;
+                                }
+                                f = null;
+                                state = LazyStates.initialized;
+                                return result;
+
+                            case LazyStates.working:
+                                throw "Illegal: reentrancy on initialization";
+
+                            default:
+                                throw "Illegal";
+                        }
+                    },
+                    set: function (value) {
+                        switch (state) {
+                            case LazyStates.working:
+                                throw "Illegal: reentrancy on initialization";
+
+                            default:
+                                state = LazyStates.initialized;
+                                result = value;
+                                break;
+                        }
+                    },
+                    enumerable: true,
+                    configurable: true
+                };
+            }
+
+            // helper for defining AMD module members
+            function moduleDefine(exports, name, members) {
+                var target = [exports];
+                var publicNS = null;
+                if (name) {
+                    publicNS = createNamespace(_Global, name);
+                    target.push(publicNS);
+                }
+                initializeProperties(target, members, name || "<ANONYMOUS>");
+                return publicNS;
+            }
+
+            // Establish members of the "WinJS.Namespace" namespace
+            Object.defineProperties(_rootNamespace.Namespace, {
+
+                defineWithParent: { value: defineWithParent, writable: true, enumerable: true, configurable: true },
+
+                define: { value: define, writable: true, enumerable: true, configurable: true },
+
+                _lazy: { value: lazy, writable: true, enumerable: true, configurable: true },
+
+                _moduleDefine: { value: moduleDefine, writable: true, enumerable: true, configurable: true }
+
+            });
+        })();
+
+        (function () {
+
+            function define(constructor, instanceMembers, staticMembers) {
+                /// <signature helpKeyword="WinJS.Class.define">
+                /// <summary locid="WinJS.Class.define">
+                /// Defines a class using the given constructor and the specified instance members.
+                /// </summary>
+                /// <param name="constructor" type="Function" locid="WinJS.Class.define_p:constructor">
+                /// A constructor function that is used to instantiate this class.
+                /// </param>
+                /// <param name="instanceMembers" type="Object" locid="WinJS.Class.define_p:instanceMembers">
+                /// The set of instance fields, properties, and methods made available on the class.
+                /// </param>
+                /// <param name="staticMembers" type="Object" locid="WinJS.Class.define_p:staticMembers">
+                /// The set of static fields, properties, and methods made available on the class.
+                /// </param>
+                /// <returns type="Function" locid="WinJS.Class.define_returnValue">
+                /// The newly-defined class.
+                /// </returns>
+                /// </signature>
+                constructor = constructor || function () {};
+                _BaseCoreUtils.markSupportedForProcessing(constructor);
+                if (instanceMembers) {
+                    initializeProperties(constructor.prototype, instanceMembers);
+                }
+                if (staticMembers) {
+                    initializeProperties(constructor, staticMembers);
+                }
+                return constructor;
+            }
+
+            function derive(baseClass, constructor, instanceMembers, staticMembers) {
+                /// <signature helpKeyword="WinJS.Class.derive">
+                /// <summary locid="WinJS.Class.derive">
+                /// Creates a sub-class based on the supplied baseClass parameter, using prototypal inheritance.
+                /// </summary>
+                /// <param name="baseClass" type="Function" locid="WinJS.Class.derive_p:baseClass">
+                /// The class to inherit from.
+                /// </param>
+                /// <param name="constructor" type="Function" locid="WinJS.Class.derive_p:constructor">
+                /// A constructor function that is used to instantiate this class.
+                /// </param>
+                /// <param name="instanceMembers" type="Object" locid="WinJS.Class.derive_p:instanceMembers">
+                /// The set of instance fields, properties, and methods to be made available on the class.
+                /// </param>
+                /// <param name="staticMembers" type="Object" locid="WinJS.Class.derive_p:staticMembers">
+                /// The set of static fields, properties, and methods to be made available on the class.
+                /// </param>
+                /// <returns type="Function" locid="WinJS.Class.derive_returnValue">
+                /// The newly-defined class.
+                /// </returns>
+                /// </signature>
+                if (baseClass) {
+                    constructor = constructor || function () {};
+                    var basePrototype = baseClass.prototype;
+                    constructor.prototype = Object.create(basePrototype);
+                    _BaseCoreUtils.markSupportedForProcessing(constructor);
+                    Object.defineProperty(constructor.prototype, "constructor", { value: constructor, writable: true, configurable: true, enumerable: true });
+                    if (instanceMembers) {
+                        initializeProperties(constructor.prototype, instanceMembers);
+                    }
+                    if (staticMembers) {
+                        initializeProperties(constructor, staticMembers);
+                    }
+                    return constructor;
+                } else {
+                    return define(constructor, instanceMembers, staticMembers);
+                }
+            }
+
+            function mix(constructor) {
+                /// <signature helpKeyword="WinJS.Class.mix">
+                /// <summary locid="WinJS.Class.mix">
+                /// Defines a class using the given constructor and the union of the set of instance members
+                /// specified by all the mixin objects. The mixin parameter list is of variable length.
+                /// </summary>
+                /// <param name="constructor" locid="WinJS.Class.mix_p:constructor">
+                /// A constructor function that is used to instantiate this class.
+                /// </param>
+                /// <returns type="Function" locid="WinJS.Class.mix_returnValue">
+                /// The newly-defined class.
+                /// </returns>
+                /// </signature>
+                constructor = constructor || function () {};
+                var i, len;
+                for (i = 1, len = arguments.length; i < len; i++) {
+                    initializeProperties(constructor.prototype, arguments[i]);
+                }
+                return constructor;
+            }
+
+            // Establish members of "WinJS.Class" namespace
+            _WinJS.Namespace.define("WinJS.Class", {
+                define: define,
+                derive: derive,
+                mix: mix
+            });
+        })();
+
+        return {
+            Namespace: _WinJS.Namespace,
+            Class: _WinJS.Class
+        };
+    });
+    _winjs("WinJS/Core/_ErrorFromName", ["WinJS/Core/_Base"], function errorsInit(_Base) {
+        "use strict";
+
+        var ErrorFromName = _Base.Class.derive(Error, function (name, message) {
+            /// <signature helpKeyword="WinJS.ErrorFromName">
+            /// <summary locid="WinJS.ErrorFromName">
+            /// Creates an Error object with the specified name and message properties.
+            /// </summary>
+            /// <param name="name" type="String" locid="WinJS.ErrorFromName_p:name">The name of this error. The name is meant to be consumed programmatically and should not be localized.</param>
+            /// <param name="message" type="String" optional="true" locid="WinJS.ErrorFromName_p:message">The message for this error. The message is meant to be consumed by humans and should be localized.</param>
+            /// <returns type="Error" locid="WinJS.ErrorFromName_returnValue">Error instance with .name and .message properties populated</returns>
+            /// </signature>
+            this.name = name;
+            this.message = message || name;
+        }, {
+            /* empty */
+        }, {
+            supportedForProcessing: false
+        });
+
+        _Base.Namespace.define("WinJS", {
+            // ErrorFromName establishes a simple pattern for returning error codes.
+            //
+            ErrorFromName: ErrorFromName
+        });
+
+        return ErrorFromName;
+    });
+
+    _winjs("WinJS/Core/_Events", ["exports", "WinJS/Core/_Base"], function eventsInit(exports, _Base) {
+        "use strict";
+
+        function createEventProperty(name) {
+            var eventPropStateName = "_on" + name + "state";
+
+            return {
+                get: function () {
+                    var state = this[eventPropStateName];
+                    return state && state.userHandler;
+                },
+                set: function (handler) {
+                    var state = this[eventPropStateName];
+                    if (handler) {
+                        if (!state) {
+                            state = { wrapper: function (evt) {
+                                    return state.userHandler(evt);
+                                }, userHandler: handler };
+                            Object.defineProperty(this, eventPropStateName, { value: state, enumerable: false, writable: true, configurable: true });
+                            this.addEventListener(name, state.wrapper, false);
+                        }
+                        state.userHandler = handler;
+                    } else if (state) {
+                        this.removeEventListener(name, state.wrapper, false);
+                        this[eventPropStateName] = null;
+                    }
+                },
+                enumerable: true
+            };
+        }
+
+        function createEventProperties() {
+            /// <signature helpKeyword="WinJS.Utilities.createEventProperties">
+            /// <summary locid="WinJS.Utilities.createEventProperties">
+            /// Creates an object that has one property for each name passed to the function.
+            /// </summary>
+            /// <param name="events" locid="WinJS.Utilities.createEventProperties_p:events">
+            /// A variable list of property names.
+            /// </param>
+            /// <returns type="Object" locid="WinJS.Utilities.createEventProperties_returnValue">
+            /// The object with the specified properties. The names of the properties are prefixed with 'on'.
+            /// </returns>
+            /// </signature>
+            var props = {};
+            for (var i = 0, len = arguments.length; i < len; i++) {
+                var name = arguments[i];
+                props["on" + name] = createEventProperty(name);
+            }
+            return props;
+        }
+
+        var EventMixinEvent = _Base.Class.define(function EventMixinEvent_ctor(type, detail, target) {
+            this.detail = detail;
+            this.target = target;
+            this.timeStamp = Date.now();
+            this.type = type;
+        }, {
+            bubbles: { value: false, writable: false },
+            cancelable: { value: false, writable: false },
+            currentTarget: {
+                get: function () {
+                    return this.target;
+                }
+            },
+            defaultPrevented: {
+                get: function () {
+                    return this._preventDefaultCalled;
+                }
+            },
+            trusted: { value: false, writable: false },
+            eventPhase: { value: 0, writable: false },
+            target: null,
+            timeStamp: null,
+            type: null,
+
+            preventDefault: function () {
+                this._preventDefaultCalled = true;
+            },
+            stopImmediatePropagation: function () {
+                this._stopImmediatePropagationCalled = true;
+            },
+            stopPropagation: function () {}
+        }, {
+            supportedForProcessing: false
+        });
+
+        var eventMixin = {
+            _listeners: null,
+
+            addEventListener: function (type, listener, useCapture) {
+                /// <signature helpKeyword="WinJS.Utilities.eventMixin.addEventListener">
+                /// <summary locid="WinJS.Utilities.eventMixin.addEventListener">
+                /// Adds an event listener to the control.
+                /// </summary>
+                /// <param name="type" locid="WinJS.Utilities.eventMixin.addEventListener_p:type">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name="listener" locid="WinJS.Utilities.eventMixin.addEventListener_p:listener">
+                /// The listener to invoke when the event is raised.
+                /// </param>
+                /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.addEventListener_p:useCapture">
+                /// if true initiates capture, otherwise false.
+                /// </param>
+                /// </signature>
+                useCapture = useCapture || false;
+                this._listeners = this._listeners || {};
+                var eventListeners = this._listeners[type] = this._listeners[type] || [];
+                for (var i = 0, len = eventListeners.length; i < len; i++) {
+                    var l = eventListeners[i];
+                    if (l.useCapture === useCapture && l.listener === listener) {
+                        return;
+                    }
+                }
+                eventListeners.push({ listener: listener, useCapture: useCapture });
+            },
+            dispatchEvent: function (type, details) {
+                /// <signature helpKeyword="WinJS.Utilities.eventMixin.dispatchEvent">
+                /// <summary locid="WinJS.Utilities.eventMixin.dispatchEvent">
+                /// Raises an event of the specified type and with the specified additional properties.
+                /// </summary>
+                /// <param name="type" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:type">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name="details" locid="WinJS.Utilities.eventMixin.dispatchEvent_p:details">
+                /// The set of additional properties to be attached to the event object when the event is raised.
+                /// </param>
+                /// <returns type="Boolean" locid="WinJS.Utilities.eventMixin.dispatchEvent_returnValue">
+                /// true if preventDefault was called on the event.
+                /// </returns>
+                /// </signature>
+                var listeners = this._listeners && this._listeners[type];
+                if (listeners) {
+                    var eventValue = new EventMixinEvent(type, details, this);
+                    // Need to copy the array to protect against people unregistering while we are dispatching
+                    listeners = listeners.slice(0, listeners.length);
+                    for (var i = 0, len = listeners.length; i < len && !eventValue._stopImmediatePropagationCalled; i++) {
+                        listeners[i].listener(eventValue);
+                    }
+                    return eventValue.defaultPrevented || false;
+                }
+                return false;
+            },
+            removeEventListener: function (type, listener, useCapture) {
+                /// <signature helpKeyword="WinJS.Utilities.eventMixin.removeEventListener">
+                /// <summary locid="WinJS.Utilities.eventMixin.removeEventListener">
+                /// Removes an event listener from the control.
+                /// </summary>
+                /// <param name="type" locid="WinJS.Utilities.eventMixin.removeEventListener_p:type">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name="listener" locid="WinJS.Utilities.eventMixin.removeEventListener_p:listener">
+                /// The listener to remove.
+                /// </param>
+                /// <param name="useCapture" locid="WinJS.Utilities.eventMixin.removeEventListener_p:useCapture">
+                /// Specifies whether to initiate capture.
+                /// </param>
+                /// </signature>
+                useCapture = useCapture || false;
+                var listeners = this._listeners && this._listeners[type];
+                if (listeners) {
+                    for (var i = 0, len = listeners.length; i < len; i++) {
+                        var l = listeners[i];
+                        if (l.listener === listener && l.useCapture === useCapture) {
+                            listeners.splice(i, 1);
+                            if (listeners.length === 0) {
+                                delete this._listeners[type];
+                            }
+                            // Only want to remove one element for each call to removeEventListener
+                            break;
+                        }
+                    }
+                }
+            }
+        };
+
+        _Base.Namespace._moduleDefine(exports, "WinJS.Utilities", {
+            _createEventProperty: createEventProperty,
+            createEventProperties: createEventProperties,
+            eventMixin: eventMixin
+        });
+    });
+
+    _winjs("WinJS/Core/_Trace", ["WinJS/Core/_Global"], function traceInit(_Global) {
+        "use strict";
+
+        function nop(v) {
+            return v;
+        }
+
+        return {
+            _traceAsyncOperationStarting: _Global.Debug && _Global.Debug.msTraceAsyncOperationStarting && _Global.Debug.msTraceAsyncOperationStarting.bind(_Global.Debug) || nop,
+            _traceAsyncOperationCompleted: _Global.Debug && _Global.Debug.msTraceAsyncOperationCompleted && _Global.Debug.msTraceAsyncOperationCompleted.bind(_Global.Debug) || nop,
+            _traceAsyncCallbackStarting: _Global.Debug && _Global.Debug.msTraceAsyncCallbackStarting && _Global.Debug.msTraceAsyncCallbackStarting.bind(_Global.Debug) || nop,
+            _traceAsyncCallbackCompleted: _Global.Debug && _Global.Debug.msTraceAsyncCallbackCompleted && _Global.Debug.msTraceAsyncCallbackCompleted.bind(_Global.Debug) || nop
+        };
+    });
+    _winjs("WinJS/Promise/_StateMachine", ["WinJS/Core/_Global", "WinJS/Core/_BaseCoreUtils", "WinJS/Core/_Base", "WinJS/Core/_ErrorFromName", "WinJS/Core/_Events", "WinJS/Core/_Trace"], function promiseStateMachineInit(_Global, _BaseCoreUtils, _Base, _ErrorFromName, _Events, _Trace) {
+        "use strict";
+
+        _Global.Debug && (_Global.Debug.setNonUserCodeExceptions = true);
+
+        var ListenerType = _Base.Class.mix(_Base.Class.define(null, {/*empty*/}, { supportedForProcessing: false }), _Events.eventMixin);
+        var promiseEventListeners = new ListenerType();
+        // make sure there is a listeners collection so that we can do a more trivial check below
+        promiseEventListeners._listeners = {};
+        var errorET = "error";
+        var canceledName = "Canceled";
+        var tagWithStack = false;
+        var tag = {
+            promise: 0x01,
+            thenPromise: 0x02,
+            errorPromise: 0x04,
+            exceptionPromise: 0x08,
+            completePromise: 0x10
+        };
+        tag.all = tag.promise | tag.thenPromise | tag.errorPromise | tag.exceptionPromise | tag.completePromise;
+
+        //
+        // Global error counter, for each error which enters the system we increment this once and then
+        // the error number travels with the error as it traverses the tree of potential handlers.
+        //
+        // When someone has registered to be told about errors (WinJS.Promise.callonerror) promises
+        // which are in error will get tagged with a ._errorId field. This tagged field is the
+        // contract by which nested promises with errors will be identified as chaining for the
+        // purposes of the callonerror semantics. If a nested promise in error is encountered without
+        // a ._errorId it will be assumed to be foreign and treated as an interop boundary and
+        // a new error id will be minted.
+        //
+        var error_number = 1;
+
+        //
+        // The state machine has a interesting hiccup in it with regards to notification, in order
+        // to flatten out notification and avoid recursion for synchronous completion we have an
+        // explicit set of *_notify states which are responsible for notifying their entire tree
+        // of children. They can do this because they know that immediate children are always
+        // ThenPromise instances and we can therefore reach into their state to access the
+        // _listeners collection.
+        //
+        // So, what happens is that a Promise will be fulfilled through the _completed or _error
+        // messages at which point it will enter a *_notify state and be responsible for to move
+        // its children into an (as appropriate) success or error state and also notify that child's
+        // listeners of the state transition, until leaf notes are reached.
+        //
+
+        var state_created, // -> working
+        state_working, // -> error | error_notify | success | success_notify | canceled | waiting
+        state_waiting, // -> error | error_notify | success | success_notify | waiting_canceled
+        state_waiting_canceled, // -> error | error_notify | success | success_notify | canceling
+        state_canceled, // -> error | error_notify | success | success_notify | canceling
+        state_canceling, // -> error_notify
+        state_success_notify, // -> success
+        state_success, // -> .
+        state_error_notify, // -> error
+        state_error; // -> .
+
+        // Noop function, used in the various states to indicate that they don't support a given
+        // message. Named with the somewhat cute name '_' because it reads really well in the states.
+
+        function _() {}
+
+        // Initial state
+        //
+        state_created = {
+            name: "created",
+            enter: function (promise) {
+                promise._setState(state_working);
+            },
+            cancel: _,
+            done: _,
+            then: _,
+            _completed: _,
+            _error: _,
+            _notify: _,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        // Ready state, waiting for a message (completed/error/progress), able to be canceled
+        //
+        state_working = {
+            name: "working",
+            enter: _,
+            cancel: function (promise) {
+                promise._setState(state_canceled);
+            },
+            done: done,
+            then: then,
+            _completed: completed,
+            _error: error,
+            _notify: _,
+            _progress: progress,
+            _setCompleteValue: setCompleteValue,
+            _setErrorValue: setErrorValue
+        };
+
+        // Waiting state, if a promise is completed with a value which is itself a promise
+        // (has a then() method) it signs up to be informed when that child promise is
+        // fulfilled at which point it will be fulfilled with that value.
+        //
+        state_waiting = {
+            name: "waiting",
+            enter: function (promise) {
+                var waitedUpon = promise._value;
+                // We can special case our own intermediate promises which are not in a
+                //  terminal state by just pushing this promise as a listener without
+                //  having to create new indirection functions
+                if (waitedUpon instanceof ThenPromise && waitedUpon._state !== state_error && waitedUpon._state !== state_success) {
+                    pushListener(waitedUpon, { promise: promise });
+                } else {
+                    var error = function (value) {
+                        if (waitedUpon._errorId) {
+                            promise._chainedError(value, waitedUpon);
+                        } else {
+                            // Because this is an interop boundary we want to indicate that this
+                            //  error has been handled by the promise infrastructure before we
+                            //  begin a new handling chain.
+                            //
+                            callonerror(promise, value, detailsForHandledError, waitedUpon, error);
+                            promise._error(value);
+                        }
+                    };
+                    error.handlesOnError = true;
+                    waitedUpon.then(promise._completed.bind(promise), error, promise._progress.bind(promise));
+                }
+            },
+            cancel: function (promise) {
+                promise._setState(state_waiting_canceled);
+            },
+            done: done,
+            then: then,
+            _completed: completed,
+            _error: error,
+            _notify: _,
+            _progress: progress,
+            _setCompleteValue: setCompleteValue,
+            _setErrorValue: setErrorValue
+        };
+
+        // Waiting canceled state, when a promise has been in a waiting state and receives a
+        // request to cancel its pending work it will forward that request to the child promise
+        // and then waits to be informed of the result. This promise moves itself into the
+        // canceling state but understands that the child promise may instead push it to a
+        // different state.
+        //
+        state_waiting_canceled = {
+            name: "waiting_canceled",
+            enter: function (promise) {
+                // Initiate a transition to canceling. Triggering a cancel on the promise
+                // that we are waiting upon may result in a different state transition
+                // before the state machine pump runs again.
+                promise._setState(state_canceling);
+                var waitedUpon = promise._value;
+                if (waitedUpon.cancel) {
+                    waitedUpon.cancel();
+                }
+            },
+            cancel: _,
+            done: done,
+            then: then,
+            _completed: completed,
+            _error: error,
+            _notify: _,
+            _progress: progress,
+            _setCompleteValue: setCompleteValue,
+            _setErrorValue: setErrorValue
+        };
+
+        // Canceled state, moves to the canceling state and then tells the promise to do
+        // whatever it might need to do on cancelation.
+        //
+        state_canceled = {
+            name: "canceled",
+            enter: function (promise) {
+                // Initiate a transition to canceling. The _cancelAction may change the state
+                // before the state machine pump runs again.
+                promise._setState(state_canceling);
+                promise._cancelAction();
+            },
+            cancel: _,
+            done: done,
+            then: then,
+            _completed: completed,
+            _error: error,
+            _notify: _,
+            _progress: progress,
+            _setCompleteValue: setCompleteValue,
+            _setErrorValue: setErrorValue
+        };
+
+        // Canceling state, commits to the promise moving to an error state with an error
+        // object whose 'name' and 'message' properties contain the string "Canceled"
+        //
+        state_canceling = {
+            name: "canceling",
+            enter: function (promise) {
+                var error = new Error(canceledName);
+                error.name = error.message;
+                promise._value = error;
+                promise._setState(state_error_notify);
+            },
+            cancel: _,
+            done: _,
+            then: _,
+            _completed: _,
+            _error: _,
+            _notify: _,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        // Success notify state, moves a promise to the success state and notifies all children
+        //
+        state_success_notify = {
+            name: "complete_notify",
+            enter: function (promise) {
+                promise.done = CompletePromise.prototype.done;
+                promise.then = CompletePromise.prototype.then;
+                if (promise._listeners) {
+                    var queue = [promise];
+                    var p;
+                    while (queue.length) {
+                        p = queue.shift();
+                        p._state._notify(p, queue);
+                    }
+                }
+                promise._setState(state_success);
+            },
+            cancel: _,
+            done: null, /*error to get here */
+            then: null, /*error to get here */
+            _completed: _,
+            _error: _,
+            _notify: notifySuccess,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        // Success state, moves a promise to the success state and does NOT notify any children.
+        // Some upstream promise is owning the notification pass.
+        //
+        state_success = {
+            name: "success",
+            enter: function (promise) {
+                promise.done = CompletePromise.prototype.done;
+                promise.then = CompletePromise.prototype.then;
+                promise._cleanupAction();
+            },
+            cancel: _,
+            done: null, /*error to get here */
+            then: null, /*error to get here */
+            _completed: _,
+            _error: _,
+            _notify: notifySuccess,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        // Error notify state, moves a promise to the error state and notifies all children
+        //
+        state_error_notify = {
+            name: "error_notify",
+            enter: function (promise) {
+                promise.done = ErrorPromise.prototype.done;
+                promise.then = ErrorPromise.prototype.then;
+                if (promise._listeners) {
+                    var queue = [promise];
+                    var p;
+                    while (queue.length) {
+                        p = queue.shift();
+                        p._state._notify(p, queue);
+                    }
+                }
+                promise._setState(state_error);
+            },
+            cancel: _,
+            done: null, /*error to get here*/
+            then: null, /*error to get here*/
+            _completed: _,
+            _error: _,
+            _notify: notifyError,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        // Error state, moves a promise to the error state and does NOT notify any children.
+        // Some upstream promise is owning the notification pass.
+        //
+        state_error = {
+            name: "error",
+            enter: function (promise) {
+                promise.done = ErrorPromise.prototype.done;
+                promise.then = ErrorPromise.prototype.then;
+                promise._cleanupAction();
+            },
+            cancel: _,
+            done: null, /*error to get here*/
+            then: null, /*error to get here*/
+            _completed: _,
+            _error: _,
+            _notify: notifyError,
+            _progress: _,
+            _setCompleteValue: _,
+            _setErrorValue: _
+        };
+
+        //
+        // The statemachine implementation follows a very particular pattern, the states are specified
+        // as static stateless bags of functions which are then indirected through the state machine
+        // instance (a Promise). As such all of the functions on each state have the promise instance
+        // passed to them explicitly as a parameter and the Promise instance members do a little
+        // dance where they indirect through the state and insert themselves in the argument list.
+        //
+        // We could instead call directly through the promise states however then every caller
+        // would have to remember to do things like pumping the state machine to catch state transitions.
+        //
+
+        var PromiseStateMachine = _Base.Class.define(null, {
+            _listeners: null,
+            _nextState: null,
+            _state: null,
+            _value: null,
+
+            cancel: function () {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
+                /// <summary locid="WinJS.PromiseStateMachine.cancel">
+                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
+                /// already been fulfilled and cancellation is supported, the promise enters
+                /// the error state with a value of Error("Canceled").
+                /// </summary>
+                /// </signature>
+                this._state.cancel(this);
+                this._run();
+            },
+            done: function Promise_done(onComplete, onError, onProgress) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
+                /// <summary locid="WinJS.PromiseStateMachine.done">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                ///
+                /// After the handlers have finished executing, this function throws any error that would have been returned
+                /// from then() as a promise in the error state.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The fulfilled value is passed as the single argument. If the value is null,
+                /// the fulfilled value is returned. The value returned
+                /// from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while executing the function, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function is the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
+                /// the function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// </signature>
+                this._state.done(this, onComplete, onError, onProgress);
+            },
+            then: function Promise_then(onComplete, onError, onProgress) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
+                /// <summary locid="WinJS.PromiseStateMachine.then">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The value is passed as the single argument. If the value is null, the value is returned.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while this function is being executed, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
+                /// The function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
+                /// The promise whose value is the result of executing the complete or
+                /// error function.
+                /// </returns>
+                /// </signature>
+                return this._state.then(this, onComplete, onError, onProgress);
+            },
+
+            _chainedError: function (value, context) {
+                var result = this._state._error(this, value, detailsForChainedError, context);
+                this._run();
+                return result;
+            },
+            _completed: function (value) {
+                var result = this._state._completed(this, value);
+                this._run();
+                return result;
+            },
+            _error: function (value) {
+                var result = this._state._error(this, value, detailsForError);
+                this._run();
+                return result;
+            },
+            _progress: function (value) {
+                this._state._progress(this, value);
+            },
+            _setState: function (state) {
+                this._nextState = state;
+            },
+            _setCompleteValue: function (value) {
+                this._state._setCompleteValue(this, value);
+                this._run();
+            },
+            _setChainedErrorValue: function (value, context) {
+                var result = this._state._setErrorValue(this, value, detailsForChainedError, context);
+                this._run();
+                return result;
+            },
+            _setExceptionValue: function (value) {
+                var result = this._state._setErrorValue(this, value, detailsForException);
+                this._run();
+                return result;
+            },
+            _run: function () {
+                while (this._nextState) {
+                    this._state = this._nextState;
+                    this._nextState = null;
+                    this._state.enter(this);
+                }
+            }
+        }, {
+            supportedForProcessing: false
+        });
+
+        //
+        // Implementations of shared state machine code.
+        //
+
+        function completed(promise, value) {
+            var targetState;
+            if (value && typeof value === "object" && typeof value.then === "function") {
+                targetState = state_waiting;
+            } else {
+                targetState = state_success_notify;
+            }
+            promise._value = value;
+            promise._setState(targetState);
+        }
+        function createErrorDetails(exception, error, promise, id, parent, handler) {
+            return {
+                exception: exception,
+                error: error,
+                promise: promise,
+                handler: handler,
+                id: id,
+                parent: parent
+            };
+        }
+        function detailsForHandledError(promise, errorValue, context, handler) {
+            var exception = context._isException;
+            var errorId = context._errorId;
+            return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context, handler);
+        }
+        function detailsForChainedError(promise, errorValue, context) {
+            var exception = context._isException;
+            var errorId = context._errorId;
+            setErrorInfo(promise, errorId, exception);
+            return createErrorDetails(exception ? errorValue : null, exception ? null : errorValue, promise, errorId, context);
+        }
+        function detailsForError(promise, errorValue) {
+            var errorId = ++error_number;
+            setErrorInfo(promise, errorId);
+            return createErrorDetails(null, errorValue, promise, errorId);
+        }
+        function detailsForException(promise, exceptionValue) {
+            var errorId = ++error_number;
+            setErrorInfo(promise, errorId, true);
+            return createErrorDetails(exceptionValue, null, promise, errorId);
+        }
+        function done(promise, onComplete, onError, onProgress) {
+            var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.done");
+            pushListener(promise, { c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
+        }
+        function error(promise, value, onerrorDetails, context) {
+            promise._value = value;
+            callonerror(promise, value, onerrorDetails, context);
+            promise._setState(state_error_notify);
+        }
+        function notifySuccess(promise, queue) {
+            var value = promise._value;
+            var listeners = promise._listeners;
+            if (!listeners) {
+                return;
+            }
+            promise._listeners = null;
+            var i, len;
+            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
+                var listener = len === 1 ? listeners : listeners[i];
+                var onComplete = listener.c;
+                var target = listener.promise;
+
+                _Trace._traceAsyncOperationCompleted(listener.asyncOpID, _Global.Debug && _Global.Debug.MS_ASYNC_OP_STATUS_SUCCESS);
+
+                if (target) {
+                    _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
+                    try {
+                        target._setCompleteValue(onComplete ? onComplete(value) : value);
+                    } catch (ex) {
+                        target._setExceptionValue(ex);
+                    } finally {
+                        _Trace._traceAsyncCallbackCompleted();
+                    }
+                    if (target._state !== state_waiting && target._listeners) {
+                        queue.push(target);
+                    }
+                } else {
+                    CompletePromise.prototype.done.call(promise, onComplete);
+                }
+            }
+        }
+        function notifyError(promise, queue) {
+            var value = promise._value;
+            var listeners = promise._listeners;
+            if (!listeners) {
+                return;
+            }
+            promise._listeners = null;
+            var i, len;
+            for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
+                var listener = len === 1 ? listeners : listeners[i];
+                var onError = listener.e;
+                var target = listener.promise;
+
+                var errorID = _Global.Debug && (value && value.name === canceledName ? _Global.Debug.MS_ASYNC_OP_STATUS_CANCELED : _Global.Debug.MS_ASYNC_OP_STATUS_ERROR);
+                _Trace._traceAsyncOperationCompleted(listener.asyncOpID, errorID);
+
+                if (target) {
+                    var asyncCallbackStarted = false;
+                    try {
+                        if (onError) {
+                            _Trace._traceAsyncCallbackStarting(listener.asyncOpID);
+                            asyncCallbackStarted = true;
+                            if (!onError.handlesOnError) {
+                                callonerror(target, value, detailsForHandledError, promise, onError);
+                            }
+                            target._setCompleteValue(onError(value));
+                        } else {
+                            target._setChainedErrorValue(value, promise);
+                        }
+                    } catch (ex) {
+                        target._setExceptionValue(ex);
+                    } finally {
+                        if (asyncCallbackStarted) {
+                            _Trace._traceAsyncCallbackCompleted();
+                        }
+                    }
+                    if (target._state !== state_waiting && target._listeners) {
+                        queue.push(target);
+                    }
+                } else {
+                    ErrorPromise.prototype.done.call(promise, null, onError);
+                }
+            }
+        }
+        function callonerror(promise, value, onerrorDetailsGenerator, context, handler) {
+            if (promiseEventListeners._listeners[errorET]) {
+                if (value instanceof Error && value.message === canceledName) {
+                    return;
+                }
+                promiseEventListeners.dispatchEvent(errorET, onerrorDetailsGenerator(promise, value, context, handler));
+            }
+        }
+        function progress(promise, value) {
+            var listeners = promise._listeners;
+            if (listeners) {
+                var i, len;
+                for (i = 0, len = Array.isArray(listeners) ? listeners.length : 1; i < len; i++) {
+                    var listener = len === 1 ? listeners : listeners[i];
+                    var onProgress = listener.p;
+                    if (onProgress) {
+                        try {
+                            onProgress(value);
+                        } catch (ex) {}
+                    }
+                    if (!(listener.c || listener.e) && listener.promise) {
+                        listener.promise._progress(value);
+                    }
+                }
+            }
+        }
+        function pushListener(promise, listener) {
+            var listeners = promise._listeners;
+            if (listeners) {
+                // We may have either a single listener (which will never be wrapped in an array)
+                // or 2+ listeners (which will be wrapped). Since we are now adding one more listener
+                // we may have to wrap the single listener before adding the second.
+                listeners = Array.isArray(listeners) ? listeners : [listeners];
+                listeners.push(listener);
+            } else {
+                listeners = listener;
+            }
+            promise._listeners = listeners;
+        }
+        // The difference beween setCompleteValue()/setErrorValue() and complete()/error() is that setXXXValue() moves
+        // a promise directly to the success/error state without starting another notification pass (because one
+        // is already ongoing).
+        function setErrorInfo(promise, errorId, isException) {
+            promise._isException = isException || false;
+            promise._errorId = errorId;
+        }
+        function setErrorValue(promise, value, onerrorDetails, context) {
+            promise._value = value;
+            callonerror(promise, value, onerrorDetails, context);
+            promise._setState(state_error);
+        }
+        function setCompleteValue(promise, value) {
+            var targetState;
+            if (value && typeof value === "object" && typeof value.then === "function") {
+                targetState = state_waiting;
+            } else {
+                targetState = state_success;
+            }
+            promise._value = value;
+            promise._setState(targetState);
+        }
+        function then(promise, onComplete, onError, onProgress) {
+            var result = new ThenPromise(promise);
+            var asyncOpID = _Trace._traceAsyncOperationStarting("WinJS.Promise.then");
+            pushListener(promise, { promise: result, c: onComplete, e: onError, p: onProgress, asyncOpID: asyncOpID });
+            return result;
+        }
+
+        //
+        // Internal implementation detail promise, ThenPromise is created when a promise needs
+        // to be returned from a then() method.
+        //
+        var ThenPromise = _Base.Class.derive(PromiseStateMachine, function (creator) {
+
+            if (tagWithStack && (tagWithStack === true || tagWithStack & tag.thenPromise)) {
+                this._stack = Promise._getStack();
+            }
+
+            this._creator = creator;
+            this._setState(state_created);
+            this._run();
+        }, {
+            _creator: null,
+
+            _cancelAction: function () {
+                if (this._creator) {
+                    this._creator.cancel();
+                }
+            },
+            _cleanupAction: function () {
+                this._creator = null;
+            }
+        }, {
+            supportedForProcessing: false
+        });
+
+        //
+        // Slim promise implementations for already completed promises, these are created
+        // under the hood on synchronous completion paths as well as by WinJS.Promise.wrap
+        // and WinJS.Promise.wrapError.
+        //
+
+        var ErrorPromise = _Base.Class.define(function ErrorPromise_ctor(value) {
+
+            if (tagWithStack && (tagWithStack === true || tagWithStack & tag.errorPromise)) {
+                this._stack = Promise._getStack();
+            }
+
+            this._value = value;
+            callonerror(this, value, detailsForError);
+        }, {
+            cancel: function () {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
+                /// <summary locid="WinJS.PromiseStateMachine.cancel">
+                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
+                /// already been fulfilled and cancellation is supported, the promise enters
+                /// the error state with a value of Error("Canceled").
+                /// </summary>
+                /// </signature>
+            },
+            done: function ErrorPromise_done(unused, onError) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
+                /// <summary locid="WinJS.PromiseStateMachine.done">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                ///
+                /// After the handlers have finished executing, this function throws any error that would have been returned
+                /// from then() as a promise in the error state.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The fulfilled value is passed as the single argument. If the value is null,
+                /// the fulfilled value is returned. The value returned
+                /// from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while executing the function, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function is the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
+                /// the function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// </signature>
+                var value = this._value;
+                if (onError) {
+                    try {
+                        if (!onError.handlesOnError) {
+                            callonerror(null, value, detailsForHandledError, this, onError);
+                        }
+                        var result = onError(value);
+                        if (result && typeof result === "object" && typeof result.done === "function") {
+                            // If a promise is returned we need to wait on it.
+                            result.done();
+                        }
+                        return;
+                    } catch (ex) {
+                        value = ex;
+                    }
+                }
+                if (value instanceof Error && value.message === canceledName) {
+                    // suppress cancel
+                    return;
+                }
+                // force the exception to be thrown asyncronously to avoid any try/catch blocks
+                //
+                Promise._doneHandler(value);
+            },
+            then: function ErrorPromise_then(unused, onError) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
+                /// <summary locid="WinJS.PromiseStateMachine.then">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The value is passed as the single argument. If the value is null, the value is returned.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while this function is being executed, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
+                /// The function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
+                /// The promise whose value is the result of executing the complete or
+                /// error function.
+                /// </returns>
+                /// </signature>
+
+                // If the promise is already in a error state and no error handler is provided
+                // we optimize by simply returning the promise instead of creating a new one.
+                //
+                if (!onError) {
+                    return this;
+                }
+                var result;
+                var value = this._value;
+                try {
+                    if (!onError.handlesOnError) {
+                        callonerror(null, value, detailsForHandledError, this, onError);
+                    }
+                    result = new CompletePromise(onError(value));
+                } catch (ex) {
+                    // If the value throw from the error handler is the same as the value
+                    // provided to the error handler then there is no need for a new promise.
+                    //
+                    if (ex === value) {
+                        result = this;
+                    } else {
+                        result = new ExceptionPromise(ex);
+                    }
+                }
+                return result;
+            }
+        }, {
+            supportedForProcessing: false
+        });
+
+        var ExceptionPromise = _Base.Class.derive(ErrorPromise, function ExceptionPromise_ctor(value) {
+
+            if (tagWithStack && (tagWithStack === true || tagWithStack & tag.exceptionPromise)) {
+                this._stack = Promise._getStack();
+            }
+
+            this._value = value;
+            callonerror(this, value, detailsForException);
+        }, {
+            /* empty */
+        }, {
+            supportedForProcessing: false
+        });
+
+        var CompletePromise = _Base.Class.define(function CompletePromise_ctor(value) {
+
+            if (tagWithStack && (tagWithStack === true || tagWithStack & tag.completePromise)) {
+                this._stack = Promise._getStack();
+            }
+
+            if (value && typeof value === "object" && typeof value.then === "function") {
+                var result = new ThenPromise(null);
+                result._setCompleteValue(value);
+                return result;
+            }
+            this._value = value;
+        }, {
+            cancel: function () {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.cancel">
+                /// <summary locid="WinJS.PromiseStateMachine.cancel">
+                /// Attempts to cancel the fulfillment of a promised value. If the promise hasn't
+                /// already been fulfilled and cancellation is supported, the promise enters
+                /// the error state with a value of Error("Canceled").
+                /// </summary>
+                /// </signature>
+            },
+            done: function CompletePromise_done(onComplete) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.done">
+                /// <summary locid="WinJS.PromiseStateMachine.done">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                ///
+                /// After the handlers have finished executing, this function throws any error that would have been returned
+                /// from then() as a promise in the error state.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.done_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The fulfilled value is passed as the single argument. If the value is null,
+                /// the fulfilled value is returned. The value returned
+                /// from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while executing the function, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function is the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.done_p:onProgress">
+                /// the function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// </signature>
+                if (!onComplete) {
+                    return;
+                }
+                try {
+                    var result = onComplete(this._value);
+                    if (result && typeof result === "object" && typeof result.done === "function") {
+                        result.done();
+                    }
+                } catch (ex) {
+                    // force the exception to be thrown asynchronously to avoid any try/catch blocks
+                    Promise._doneHandler(ex);
+                }
+            },
+            then: function CompletePromise_then(onComplete) {
+                /// <signature helpKeyword="WinJS.PromiseStateMachine.then">
+                /// <summary locid="WinJS.PromiseStateMachine.then">
+                /// Allows you to specify the work to be done on the fulfillment of the promised value,
+                /// the error handling to be performed if the promise fails to fulfill
+                /// a value, and the handling of progress notifications along the way.
+                /// </summary>
+                /// <param name='onComplete' type='Function' locid="WinJS.PromiseStateMachine.then_p:onComplete">
+                /// The function to be called if the promise is fulfilled successfully with a value.
+                /// The value is passed as the single argument. If the value is null, the value is returned.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by
+                /// then(). If an exception is thrown while this function is being executed, the promise returned
+                /// by then() moves into the error state.
+                /// </param>
+                /// <param name='onError' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onError">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument. If it is null, the error is forwarded.
+                /// The value returned from the function becomes the fulfilled value of the promise returned by then().
+                /// </param>
+                /// <param name='onProgress' type='Function' optional='true' locid="WinJS.PromiseStateMachine.then_p:onProgress">
+                /// The function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.PromiseStateMachine.then_returnValue">
+                /// The promise whose value is the result of executing the complete or
+                /// error function.
+                /// </returns>
+                /// </signature>
+                try {
+                    // If the value returned from the completion handler is the same as the value
+                    // provided to the completion handler then there is no need for a new promise.
+                    //
+                    var newValue = onComplete ? onComplete(this._value) : this._value;
+                    return newValue === this._value ? this : new CompletePromise(newValue);
+                } catch (ex) {
+                    return new ExceptionPromise(ex);
+                }
+            }
+        }, {
+            supportedForProcessing: false
+        });
+
+        //
+        // Promise is the user-creatable WinJS.Promise object.
+        //
+
+        function timeout(timeoutMS) {
+            var id;
+            return new Promise(function (c) {
+                if (timeoutMS) {
+                    id = _Global.setTimeout(c, timeoutMS);
+                } else {
+                    _BaseCoreUtils._setImmediate(c);
+                }
+            }, function () {
+                if (id) {
+                    _Global.clearTimeout(id);
+                }
+            });
+        }
+
+        function timeoutWithPromise(timeout, promise) {
+            var cancelPromise = function () {
+                promise.cancel();
+            };
+            var cancelTimeout = function () {
+                timeout.cancel();
+            };
+            timeout.then(cancelPromise);
+            promise.then(cancelTimeout, cancelTimeout);
+            return promise;
+        }
+
+        var staticCanceledPromise;
+
+        var Promise = _Base.Class.derive(PromiseStateMachine, function Promise_ctor(init, oncancel) {
+            /// <signature helpKeyword="WinJS.Promise">
+            /// <summary locid="WinJS.Promise">
+            /// A promise provides a mechanism to schedule work to be done on a value that
+            /// has not yet been computed. It is a convenient abstraction for managing
+            /// interactions with asynchronous APIs.
+            /// </summary>
+            /// <param name="init" type="Function" locid="WinJS.Promise_p:init">
+            /// The function that is called during construction of the  promise. The function
+            /// is given three arguments (complete, error, progress). Inside this function
+            /// you should add event listeners for the notifications supported by this value.
+            /// </param>
+            /// <param name="oncancel" optional="true" locid="WinJS.Promise_p:oncancel">
+            /// The function to call if a consumer of this promise wants
+            /// to cancel its undone work. Promises are not required to
+            /// support cancellation.
+            /// </param>
+            /// </signature>
+
+            if (tagWithStack && (tagWithStack === true || tagWithStack & tag.promise)) {
+                this._stack = Promise._getStack();
+            }
+
+            this._oncancel = oncancel;
+            this._setState(state_created);
+            this._run();
+
+            try {
+                var complete = this._completed.bind(this);
+                var error = this._error.bind(this);
+                var progress = this._progress.bind(this);
+                init(complete, error, progress);
+            } catch (ex) {
+                this._setExceptionValue(ex);
+            }
+        }, {
+            _oncancel: null,
+
+            _cancelAction: function () {
+                // BEGIN monaco change
+                try {
+                    if (this._oncancel) {
+                        this._oncancel();
+                    } else {
+                        throw new Error('Promise did not implement oncancel');
+                    }
+                } catch (ex) {
+                    // Access fields to get them created
+                    var msg = ex.message;
+                    var stack = ex.stack;
+                    promiseEventListeners.dispatchEvent('error', ex);
+                }
+                // END monaco change
+            },
+            _cleanupAction: function () {
+                this._oncancel = null;
+            }
+        }, {
+
+            addEventListener: function Promise_addEventListener(eventType, listener, capture) {
+                /// <signature helpKeyword="WinJS.Promise.addEventListener">
+                /// <summary locid="WinJS.Promise.addEventListener">
+                /// Adds an event listener to the control.
+                /// </summary>
+                /// <param name="eventType" locid="WinJS.Promise.addEventListener_p:eventType">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name="listener" locid="WinJS.Promise.addEventListener_p:listener">
+                /// The listener to invoke when the event is raised.
+                /// </param>
+                /// <param name="capture" locid="WinJS.Promise.addEventListener_p:capture">
+                /// Specifies whether or not to initiate capture.
+                /// </param>
+                /// </signature>
+                promiseEventListeners.addEventListener(eventType, listener, capture);
+            },
+            any: function Promise_any(values) {
+                /// <signature helpKeyword="WinJS.Promise.any">
+                /// <summary locid="WinJS.Promise.any">
+                /// Returns a promise that is fulfilled when one of the input promises
+                /// has been fulfilled.
+                /// </summary>
+                /// <param name="values" type="Array" locid="WinJS.Promise.any_p:values">
+                /// An array that contains promise objects or objects whose property
+                /// values include promise objects.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.any_returnValue">
+                /// A promise that on fulfillment yields the value of the input (complete or error).
+                /// </returns>
+                /// </signature>
+                return new Promise(function (complete, error) {
+                    var keys = Object.keys(values);
+                    if (keys.length === 0) {
+                        complete();
+                    }
+                    var canceled = 0;
+                    keys.forEach(function (key) {
+                        Promise.as(values[key]).then(function () {
+                            complete({ key: key, value: values[key] });
+                        }, function (e) {
+                            if (e instanceof Error && e.name === canceledName) {
+                                if (++canceled === keys.length) {
+                                    complete(Promise.cancel);
+                                }
+                                return;
+                            }
+                            error({ key: key, value: values[key] });
+                        });
+                    });
+                }, function () {
+                    var keys = Object.keys(values);
+                    keys.forEach(function (key) {
+                        var promise = Promise.as(values[key]);
+                        if (typeof promise.cancel === "function") {
+                            promise.cancel();
+                        }
+                    });
+                });
+            },
+            as: function Promise_as(value) {
+                /// <signature helpKeyword="WinJS.Promise.as">
+                /// <summary locid="WinJS.Promise.as">
+                /// Returns a promise. If the object is already a promise it is returned;
+                /// otherwise the object is wrapped in a promise.
+                /// </summary>
+                /// <param name="value" locid="WinJS.Promise.as_p:value">
+                /// The value to be treated as a promise.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.as_returnValue">
+                /// A promise.
+                /// </returns>
+                /// </signature>
+                if (value && typeof value === "object" && typeof value.then === "function") {
+                    return value;
+                }
+                return new CompletePromise(value);
+            },
+            /// <field type="WinJS.Promise" helpKeyword="WinJS.Promise.cancel" locid="WinJS.Promise.cancel">
+            /// Canceled promise value, can be returned from a promise completion handler
+            /// to indicate cancelation of the promise chain.
+            /// </field>
+            cancel: {
+                get: function () {
+                    return staticCanceledPromise = staticCanceledPromise || new ErrorPromise(new _ErrorFromName(canceledName));
+                }
+            },
+            dispatchEvent: function Promise_dispatchEvent(eventType, details) {
+                /// <signature helpKeyword="WinJS.Promise.dispatchEvent">
+                /// <summary locid="WinJS.Promise.dispatchEvent">
+                /// Raises an event of the specified type and properties.
+                /// </summary>
+                /// <param name="eventType" locid="WinJS.Promise.dispatchEvent_p:eventType">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name="details" locid="WinJS.Promise.dispatchEvent_p:details">
+                /// The set of additional properties to be attached to the event object.
+                /// </param>
+                /// <returns type="Boolean" locid="WinJS.Promise.dispatchEvent_returnValue">
+                /// Specifies whether preventDefault was called on the event.
+                /// </returns>
+                /// </signature>
+                return promiseEventListeners.dispatchEvent(eventType, details);
+            },
+            is: function Promise_is(value) {
+                /// <signature helpKeyword="WinJS.Promise.is">
+                /// <summary locid="WinJS.Promise.is">
+                /// Determines whether a value fulfills the promise contract.
+                /// </summary>
+                /// <param name="value" locid="WinJS.Promise.is_p:value">
+                /// A value that may be a promise.
+                /// </param>
+                /// <returns type="Boolean" locid="WinJS.Promise.is_returnValue">
+                /// true if the specified value is a promise, otherwise false.
+                /// </returns>
+                /// </signature>
+                return value && typeof value === "object" && typeof value.then === "function";
+            },
+            join: function Promise_join(values) {
+                /// <signature helpKeyword="WinJS.Promise.join">
+                /// <summary locid="WinJS.Promise.join">
+                /// Creates a promise that is fulfilled when all the values are fulfilled.
+                /// </summary>
+                /// <param name="values" type="Object" locid="WinJS.Promise.join_p:values">
+                /// An object whose fields contain values, some of which may be promises.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.join_returnValue">
+                /// A promise whose value is an object with the same field names as those of the object in the values parameter, where
+                /// each field value is the fulfilled value of a promise.
+                /// </returns>
+                /// </signature>
+                return new Promise(function (complete, error, progress) {
+                    var keys = Object.keys(values);
+                    var errors = Array.isArray(values) ? [] : {};
+                    var results = Array.isArray(values) ? [] : {};
+                    var undefineds = 0;
+                    var pending = keys.length;
+                    var argDone = function (key) {
+                        if (--pending === 0) {
+                            var errorCount = Object.keys(errors).length;
+                            if (errorCount === 0) {
+                                complete(results);
+                            } else {
+                                var canceledCount = 0;
+                                keys.forEach(function (key) {
+                                    var e = errors[key];
+                                    if (e instanceof Error && e.name === canceledName) {
+                                        canceledCount++;
+                                    }
+                                });
+                                if (canceledCount === errorCount) {
+                                    complete(Promise.cancel);
+                                } else {
+                                    error(errors);
+                                }
+                            }
+                        } else {
+                            progress({ Key: key, Done: true });
+                        }
+                    };
+                    keys.forEach(function (key) {
+                        var value = values[key];
+                        if (value === undefined) {
+                            undefineds++;
+                        } else {
+                            Promise.then(value, function (value) {
+                                results[key] = value;argDone(key);
+                            }, function (value) {
+                                errors[key] = value;argDone(key);
+                            });
+                        }
+                    });
+                    pending -= undefineds;
+                    if (pending === 0) {
+                        complete(results);
+                        return;
+                    }
+                }, function () {
+                    Object.keys(values).forEach(function (key) {
+                        var promise = Promise.as(values[key]);
+                        if (typeof promise.cancel === "function") {
+                            promise.cancel();
+                        }
+                    });
+                });
+            },
+            removeEventListener: function Promise_removeEventListener(eventType, listener, capture) {
+                /// <signature helpKeyword="WinJS.Promise.removeEventListener">
+                /// <summary locid="WinJS.Promise.removeEventListener">
+                /// Removes an event listener from the control.
+                /// </summary>
+                /// <param name='eventType' locid="WinJS.Promise.removeEventListener_eventType">
+                /// The type (name) of the event.
+                /// </param>
+                /// <param name='listener' locid="WinJS.Promise.removeEventListener_listener">
+                /// The listener to remove.
+                /// </param>
+                /// <param name='capture' locid="WinJS.Promise.removeEventListener_capture">
+                /// Specifies whether or not to initiate capture.
+                /// </param>
+                /// </signature>
+                promiseEventListeners.removeEventListener(eventType, listener, capture);
+            },
+            supportedForProcessing: false,
+            then: function Promise_then(value, onComplete, onError, onProgress) {
+                /// <signature helpKeyword="WinJS.Promise.then">
+                /// <summary locid="WinJS.Promise.then">
+                /// A static version of the promise instance method then().
+                /// </summary>
+                /// <param name="value" locid="WinJS.Promise.then_p:value">
+                /// the value to be treated as a promise.
+                /// </param>
+                /// <param name="onComplete" type="Function" locid="WinJS.Promise.then_p:complete">
+                /// The function to be called if the promise is fulfilled with a value.
+                /// If it is null, the promise simply
+                /// returns the value. The value is passed as the single argument.
+                /// </param>
+                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.then_p:error">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument.
+                /// </param>
+                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.then_p:progress">
+                /// The function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.then_returnValue">
+                /// A promise whose value is the result of executing the provided complete function.
+                /// </returns>
+                /// </signature>
+                return Promise.as(value).then(onComplete, onError, onProgress);
+            },
+            thenEach: function Promise_thenEach(values, onComplete, onError, onProgress) {
+                /// <signature helpKeyword="WinJS.Promise.thenEach">
+                /// <summary locid="WinJS.Promise.thenEach">
+                /// Performs an operation on all the input promises and returns a promise
+                /// that has the shape of the input and contains the result of the operation
+                /// that has been performed on each input.
+                /// </summary>
+                /// <param name="values" locid="WinJS.Promise.thenEach_p:values">
+                /// A set of values (which could be either an array or an object) of which some or all are promises.
+                /// </param>
+                /// <param name="onComplete" type="Function" locid="WinJS.Promise.thenEach_p:complete">
+                /// The function to be called if the promise is fulfilled with a value.
+                /// If the value is null, the promise returns the value.
+                /// The value is passed as the single argument.
+                /// </param>
+                /// <param name="onError" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:error">
+                /// The function to be called if the promise is fulfilled with an error. The error
+                /// is passed as the single argument.
+                /// </param>
+                /// <param name="onProgress" type="Function" optional="true" locid="WinJS.Promise.thenEach_p:progress">
+                /// The function to be called if the promise reports progress. Data about the progress
+                /// is passed as the single argument. Promises are not required to support
+                /// progress.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.thenEach_returnValue">
+                /// A promise that is the result of calling Promise.join on the values parameter.
+                /// </returns>
+                /// </signature>
+                var result = Array.isArray(values) ? [] : {};
+                Object.keys(values).forEach(function (key) {
+                    result[key] = Promise.as(values[key]).then(onComplete, onError, onProgress);
+                });
+                return Promise.join(result);
+            },
+            timeout: function Promise_timeout(time, promise) {
+                /// <signature helpKeyword="WinJS.Promise.timeout">
+                /// <summary locid="WinJS.Promise.timeout">
+                /// Creates a promise that is fulfilled after a timeout.
+                /// </summary>
+                /// <param name="timeout" type="Number" optional="true" locid="WinJS.Promise.timeout_p:timeout">
+                /// The timeout period in milliseconds. If this value is zero or not specified
+                /// setImmediate is called, otherwise setTimeout is called.
+                /// </param>
+                /// <param name="promise" type="Promise" optional="true" locid="WinJS.Promise.timeout_p:promise">
+                /// A promise that will be canceled if it doesn't complete before the
+                /// timeout has expired.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.timeout_returnValue">
+                /// A promise that is completed asynchronously after the specified timeout.
+                /// </returns>
+                /// </signature>
+                var to = timeout(time);
+                return promise ? timeoutWithPromise(to, promise) : to;
+            },
+            wrap: function Promise_wrap(value) {
+                /// <signature helpKeyword="WinJS.Promise.wrap">
+                /// <summary locid="WinJS.Promise.wrap">
+                /// Wraps a non-promise value in a promise. You can use this function if you need
+                /// to pass a value to a function that requires a promise.
+                /// </summary>
+                /// <param name="value" locid="WinJS.Promise.wrap_p:value">
+                /// Some non-promise value to be wrapped in a promise.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrap_returnValue">
+                /// A promise that is successfully fulfilled with the specified value
+                /// </returns>
+                /// </signature>
+                return new CompletePromise(value);
+            },
+            wrapError: function Promise_wrapError(error) {
+                /// <signature helpKeyword="WinJS.Promise.wrapError">
+                /// <summary locid="WinJS.Promise.wrapError">
+                /// Wraps a non-promise error value in a promise. You can use this function if you need
+                /// to pass an error to a function that requires a promise.
+                /// </summary>
+                /// <param name="error" locid="WinJS.Promise.wrapError_p:error">
+                /// A non-promise error value to be wrapped in a promise.
+                /// </param>
+                /// <returns type="WinJS.Promise" locid="WinJS.Promise.wrapError_returnValue">
+                /// A promise that is in an error state with the specified value.
+                /// </returns>
+                /// </signature>
+                return new ErrorPromise(error);
+            },
+
+            _veryExpensiveTagWithStack: {
+                get: function () {
+                    return tagWithStack;
+                },
+                set: function (value) {
+                    tagWithStack = value;
+                }
+            },
+            _veryExpensiveTagWithStack_tag: tag,
+            _getStack: function () {
+                if (_Global.Debug && _Global.Debug.debuggerEnabled) {
+                    try {
+                        throw new Error();
+                    } catch (e) {
+                        return e.stack;
+                    }
+                }
+            },
+
+            _cancelBlocker: function Promise__cancelBlocker(input, oncancel) {
+                //
+                // Returns a promise which on cancelation will still result in downstream cancelation while
+                //  protecting the promise 'input' from being  canceled which has the effect of allowing
+                //  'input' to be shared amoung various consumers.
+                //
+                if (!Promise.is(input)) {
+                    return Promise.wrap(input);
+                }
+                var complete;
+                var error;
+                var output = new Promise(function (c, e) {
+                    complete = c;
+                    error = e;
+                }, function () {
+                    complete = null;
+                    error = null;
+                    oncancel && oncancel();
+                });
+                input.then(function (v) {
+                    complete && complete(v);
+                }, function (e) {
+                    error && error(e);
+                });
+                return output;
+            }
+
+        });
+        Object.defineProperties(Promise, _Events.createEventProperties(errorET));
+
+        Promise._doneHandler = function (value) {
+            _BaseCoreUtils._setImmediate(function Promise_done_rethrow() {
+                throw value;
+            });
+        };
+
+        return {
+            PromiseStateMachine: PromiseStateMachine,
+            Promise: Promise,
+            state_created: state_created
+        };
+    });
+
+    _winjs("WinJS/Promise", ["WinJS/Core/_Base", "WinJS/Promise/_StateMachine"], function promiseInit(_Base, _StateMachine) {
+        "use strict";
+
+        _Base.Namespace.define("WinJS", {
+            Promise: _StateMachine.Promise
+        });
+
+        return _StateMachine.Promise;
+    });
+
+    exported = _modules["WinJS/Core/_WinJS"];
+    if (typeof exports === 'undefined' && typeof define === 'function' && define.amd) {
+        define(exported);
+    } else {
+		// module.exports = exported;
+    }
+
+    if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
+        _modules["WinJS/Core/_BaseCoreUtils"]._setImmediate = function (handler) {
+            return process.nextTick(handler);
+        };
+    }
+})();
+
+export const Promise = exported.Promise;
+export const TPromise = exported.Promise;
+export const PPromise = exported.Promise;
\ No newline at end of file
changed in both
  base   100644 24bb80a1fb211857e4e4d92449f98b414e60788e src/vs/base/parts/quickopen/browser/quickOpenModel.ts
  our    100644 08e0701b8476b0e21642522cba5b49079d402eed src/vs/base/parts/quickopen/browser/quickOpenModel.ts
  their  100644 7408be3fa6c4cc5039ccc170be59278f93fdea2b src/vs/base/parts/quickopen/browser/quickOpenModel.ts
@@ -10,7 +10,14 @@
 import * as types from 'vs/base/common/types';
 import URI from 'vs/base/common/uri';
 import { ITree, IActionProvider } from 'vs/base/parts/tree/browser/tree';
+<<<<<<< .our
 import { IconLabel, IIconLabelValueOptions } from 'vs/base/browser/ui/iconLabel/iconLabel';
+=======
+import * as filters from 'vs/base/common/filters';
+import * as strings from 'vs/base/common/strings';
+import * as paths from 'vs/base/common/paths';
+import { IconLabel, IIconLabelOptions } from 'vs/base/browser/ui/iconLabel/iconLabel';
+>>>>>>> .their
 import { IQuickNavigateConfiguration, IModel, IDataSource, IFilter, IAccessiblityProvider, IRenderer, IRunner, Mode } from 'vs/base/parts/quickopen/common/quickOpen';
 import { Action, IAction, IActionRunner } from 'vs/base/common/actions';
 import { compareAnything } from 'vs/base/common/comparers';
changed in both
  base   100644 63d07bf6c35a090686add18a4e370db8b04c2798 src/vs/base/parts/quickopen/browser/quickOpenWidget.ts
  our    100644 0b73a95911391c4873434ba6f7cfad646ef99f86 src/vs/base/parts/quickopen/browser/quickOpenWidget.ts
  their  100644 0f7054cc90621f7f8da52a7b048c9e108f513259 src/vs/base/parts/quickopen/browser/quickOpenWidget.ts
@@ -6,10 +6,19 @@
 
 import 'vs/css!./quickopen';
 import * as nls from 'vs/nls';
+<<<<<<< .our
 import * as platform from 'vs/base/common/platform';
 import * as types from 'vs/base/common/types';
 import * as errors from 'vs/base/common/errors';
 import { IQuickNavigateConfiguration, IAutoFocus, IEntryRunContext, IModel, Mode, IKeyMods } from 'vs/base/parts/quickopen/common/quickOpen';
+=======
+import { TPromise } from 'vs/base/common/winjs.base';
+import * as platform from 'vs/base/common/platform';
+import { EventType } from 'vs/base/common/events';
+import * as types from 'vs/base/common/types';
+import * as errors from 'vs/base/common/errors';
+import { IQuickNavigateConfiguration, IAutoFocus, IEntryRunContext, IModel, Mode } from 'vs/base/parts/quickopen/common/quickOpen';
+>>>>>>> .their
 import { Filter, Renderer, DataSource, IModelProvider, AccessibilityProvider } from 'vs/base/parts/quickopen/browser/quickOpenViewer';
 import { Builder, $ } from 'vs/base/browser/builder';
 import { ITree, ContextMenuEvent, IActionProvider, ITreeStyles, ITreeOptions, ITreeConfiguration } from 'vs/base/parts/tree/browser/tree';
@@ -20,8 +29,13 @@
 import { StandardKeyboardEvent } from 'vs/base/browser/keyboardEvent';
 import { DefaultController, ClickBehavior } from 'vs/base/parts/tree/browser/treeDefaults';
 import * as DOM from 'vs/base/browser/dom';
+<<<<<<< .our
 import { KeyCode } from 'vs/base/common/keyCodes';
 import { Disposable } from 'vs/base/common/lifecycle';
+=======
+import { KeyCode, KeyMod } from 'vs/base/common/keyCodes';
+import { IDisposable, dispose } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 import { ScrollbarVisibility } from 'vs/base/common/scrollable';
 import { Color } from 'vs/base/common/color';
 import { mixin } from 'vs/base/common/objects';
changed in both
  base   100644 e8bae236d8d754ce1c4b80f6dcdeeb0e41e3b16c src/vs/base/parts/tree/browser/tree.ts
  our    100644 64e2f7152f0f5abd08b9d0878661a6eaf7081f29 src/vs/base/parts/tree/browser/tree.ts
  their  100644 ea36b3df2697283a3754c0cf16d946053377382c src/vs/base/parts/tree/browser/tree.ts
@@ -6,6 +6,10 @@
 
 import * as WinJS from 'vs/base/common/winjs.base';
 import * as Touch from 'vs/base/browser/touch';
+<<<<<<< .our
+=======
+import * as Events from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 import * as Mouse from 'vs/base/browser/mouseEvent';
 import * as Keyboard from 'vs/base/browser/keyboardEvent';
 import { INavigator } from 'vs/base/common/iterator';
changed in both
  base   100644 05e19027d4f2143d8a56c2f8c7da2a26d1750467 src/vs/base/parts/tree/browser/treeDefaults.ts
  our    100644 ec975e735e2211d7851919a99745080668119cca src/vs/base/parts/tree/browser/treeDefaults.ts
  their  100644 e248f1398f69555b66505a9289118d5a8d25fe6e src/vs/base/parts/tree/browser/treeDefaults.ts
@@ -14,7 +14,11 @@
 import * as mouse from 'vs/base/browser/mouseEvent';
 import { IKeyboardEvent } from 'vs/base/browser/keyboardEvent';
 import * as _ from 'vs/base/parts/tree/browser/tree';
+<<<<<<< .our
 import { KeyCode, KeyMod, Keybinding, createKeybinding, SimpleKeybinding, createSimpleKeybinding } from 'vs/base/common/keyCodes';
+=======
+import { KeyCode, KeyMod, Keybinding, createKeybinding, SimpleKeybinding } from 'vs/base/common/keyCodes';
+>>>>>>> .their
 
 export interface IKeyBindingCallback {
 	(tree: _.ITree, event: IKeyboardEvent): void;
changed in both
  base   100644 abae2bcfd18b13388299de7f32b488f2648094c7 src/vs/base/parts/tree/browser/treeDnd.ts
  our    100644 768a47c6a441da775412998d3a6bab94bd1e7f98 src/vs/base/parts/tree/browser/treeDnd.ts
  their  100644 91f11a9d7be76494716f21bf83a9c3e46b8e8fb5 src/vs/base/parts/tree/browser/treeDnd.ts
@@ -6,6 +6,13 @@
 
 import * as _ from 'vs/base/parts/tree/browser/tree';
 import * as Mouse from 'vs/base/browser/mouseEvent';
+<<<<<<< .our
+=======
+import { DefaultDragAndDrop } from 'vs/base/parts/tree/browser/treeDefaults';
+import URI from 'vs/base/common/uri';
+import { basename } from 'vs/base/common/paths';
+import { getPathLabel } from 'vs/base/common/labels';
+>>>>>>> .their
 
 export class ElementsDragAndDropData implements _.IDragAndDropData {
 
changed in both
  base   100644 2c18c5700fb8f9230f24daa2c0d787c174a0eadd src/vs/base/parts/tree/browser/treeImpl.ts
  our    100644 dc008d1eedea30e04540f327da75b3af449d6ff9 src/vs/base/parts/tree/browser/treeImpl.ts
  their  100644 5587cf321b0eebccdd0c74b74f0f94e06e9011b6 src/vs/base/parts/tree/browser/treeImpl.ts
@@ -7,11 +7,20 @@
 import 'vs/css!./tree';
 import * as WinJS from 'vs/base/common/winjs.base';
 import * as TreeDefaults from 'vs/base/parts/tree/browser/treeDefaults';
+<<<<<<< .our
+=======
+import * as Events from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 import * as Model from 'vs/base/parts/tree/browser/treeModel';
 import * as View from './treeView';
 import * as _ from 'vs/base/parts/tree/browser/tree';
 import { INavigator, MappedNavigator } from 'vs/base/common/iterator';
+<<<<<<< .our
 import { Event, Emitter, Relay } from 'vs/base/common/event';
+=======
+import Event, { Emitter } from 'vs/base/common/event';
+import * as Lifecycle from 'vs/base/common/lifecycle';
+>>>>>>> .their
 import { Color } from 'vs/base/common/color';
 import { mixin } from 'vs/base/common/objects';
 
changed in both
  base   100644 1c5623fab9ef194cd686fa251a70225529eeab5e src/vs/base/parts/tree/browser/treeModel.ts
  our    100644 38abf8eca456faf80f8d46d7809724f48f82a14b src/vs/base/parts/tree/browser/treeModel.ts
  their  100644 3104125d031064078ad92374b06b0fb14866b50e src/vs/base/parts/tree/browser/treeModel.ts
@@ -9,9 +9,15 @@
 import { IDisposable, combinedDisposable } from 'vs/base/common/lifecycle';
 import * as arrays from 'vs/base/common/arrays';
 import { INavigator } from 'vs/base/common/iterator';
+<<<<<<< .our
 import * as WinJS from 'vs/base/common/winjs.base';
 import * as _ from './tree';
 import { Event, Emitter, once, EventMultiplexer, Relay } from 'vs/base/common/event';
+=======
+import * as Events from 'vs/base/common/eventEmitter';
+import * as WinJS from 'vs/base/common/winjs.base';
+import * as _ from './tree';
+>>>>>>> .their
 
 interface IMap<T> { [id: string]: T; }
 interface IItemMap extends IMap<Item> { }
changed in both
  base   100644 ac5ba32ad5c7c4e45947bc171691388268151fb1 src/vs/base/parts/tree/browser/treeView.ts
  our    100644 6b1e97a1a7f247863b6e4867e10351a2ef228606 src/vs/base/parts/tree/browser/treeView.ts
  their  100644 d65f32d4c085049142a55d73e44ac3d6bc79a41a src/vs/base/parts/tree/browser/treeView.ts
added in remote
  their  100644 5dce2499714454af8b18fdf00fd00dd035934000 src/vs/css.esm.js
@@ -0,0 +1,6 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+export var css = '';
\ No newline at end of file
changed in both
  base   100644 3436b8653c48afc448fbb3ab97d85865b5de2432 src/vs/editor/common/services/modelServiceImpl.ts
  our    100644 1a1202dde3c4f6f0ea6c3ead333eb6957cfba556 src/vs/editor/common/services/modelServiceImpl.ts
  their  100644 40482d9b5836e7f7b7c2492fbc0faa926f37f89e src/vs/editor/common/services/modelServiceImpl.ts
@@ -6,7 +6,12 @@
 
 import * as nls from 'vs/nls';
 import * as network from 'vs/base/common/network';
+<<<<<<< .our
 import { Event, Emitter } from 'vs/base/common/event';
+=======
+import Event, { Emitter } from 'vs/base/common/event';
+import { EmitterEvent } from 'vs/base/common/eventEmitter';
+>>>>>>> .their
 import { MarkdownString } from 'vs/base/common/htmlContent';
 import { IDisposable, dispose } from 'vs/base/common/lifecycle';
 import URI from 'vs/base/common/uri';
changed in both
  base   100644 794b815d4fd7ecce51f9148f7264d30a62acd17e src/vs/editor/common/view/editorColorRegistry.ts
  our    100644 c4c369cb0d295c59da893a5750489215aaa2a50d src/vs/editor/common/view/editorColorRegistry.ts
  their  100644 c59a36bc3ee40ed5560ce7f9196f5204b9337351 src/vs/editor/common/view/editorColorRegistry.ts
removed in local
  base   100644 bacb7f633f8217441d296cea3bba24ba933e0484 src/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.ts
  their  100644 c2ebbc4ade34297893c25c95f2ac88cf88f627f9 src/vs/editor/contrib/parameterHints/browser/parameterHintsWidget.ts
removed in local
  base   100644 2cd8cab8f8cc038694e275a15bbcc17d7a58990d src/vs/editor/contrib/wordHighlighter/common/wordHighlighter.ts
  their  100644 5b26d5046997209f02275ee6a11e0d4111118c2c src/vs/editor/contrib/wordHighlighter/common/wordHighlighter.ts
added in remote
  their  100644 1c4d9430c7c42cdf7addcd77d6f58884bb349d1e src/vs/editor/editor.esm.ts
@@ -0,0 +1,41 @@
+/*---------------------------------------------------------------------------------------------
+ *  Copyright (c) Microsoft Corporation. All rights reserved.
+ *  Licensed under the MIT License. See License.txt in the project root for license information.
+ *--------------------------------------------------------------------------------------------*/
+
+'use strict';
+
+import 'vs/editor/editor.all';
+import 'vs/editor/standalone/browser/accessibilityHelp/accessibilityHelp';
+import 'vs/editor/standalone/browser/inspectTokens/inspectTokens';
+import 'vs/editor/standalone/browser/iPadShowKeyboard/iPadShowKeyboard';
+import 'vs/editor/standalone/browser/quickOpen/quickOutline';
+import 'vs/editor/standalone/browser/quickOpen/gotoLine';
+import 'vs/editor/standalone/browser/quickOpen/quickCommand';
+import 'vs/editor/standalone/browser/toggleHighContrast/toggleHighContrast';
+
+import { createMonacoBaseAPI } from 'vs/editor/common/standalone/standaloneBase';
+import { createMonacoEditorAPI } from 'vs/editor/standalone/browser/standaloneEditor';
+import { createMonacoLanguagesAPI } from 'vs/editor/standalone/browser/standaloneLanguages';
+import { EDITOR_DEFAULTS, WrappingIndent } from 'vs/editor/common/config/editorOptions';
+
+// Set defaults for standalone editor
+(<any>EDITOR_DEFAULTS).wrappingIndent = WrappingIndent.None;
+(<any>EDITOR_DEFAULTS.contribInfo).folding = false;
+(<any>EDITOR_DEFAULTS.viewInfo).glyphMargin = false;
+(<any>EDITOR_DEFAULTS).autoIndent = false;
+
+let exported = {};
+let base = createMonacoBaseAPI();
+for (let prop in base) {
+	if (base.hasOwnProperty(prop)) {
+		exported[prop] = base[prop];
+	}
+}
+exported['editor'] = createMonacoEditorAPI();
+exported['languages'] = createMonacoLanguagesAPI();
+
+var global: any = self;
+global.monaco = exported;
+export const monaco = exported;
+
changed in both
  base   100644 063ebe91c6a190d6febbd516c03073fd70a2c625 src/vs/platform/backup/test/electron-main/backupMainService.test.ts
  our    100644 ab249bac7dc33cec2c79cad93399b7624782e22d src/vs/platform/backup/test/electron-main/backupMainService.test.ts
  their  100644 0f6fea8656b5d2b083645aec616aa8d6d7e3a70c src/vs/platform/backup/test/electron-main/backupMainService.test.ts
@@ -10,6 +10,10 @@
 import * as fs from 'fs';
 import * as os from 'os';
 import * as path from 'path';
+<<<<<<< .our
+=======
+import * as extfs from 'vs/base/node/extfs';
+>>>>>>> .their
 import * as pfs from 'vs/base/node/pfs';
 import Uri from 'vs/base/common/uri';
 import { EnvironmentService } from 'vs/platform/environment/node/environmentService';
changed in both
  base   100644 d2495cce311a89cc3f9dba69a0f7f4edb4037efb src/vs/platform/configuration/common/configurationRegistry.ts
  our    100644 0c63a065226bc399535e1e3f1044565e6f486734 src/vs/platform/configuration/common/configurationRegistry.ts
  their  100644 f6e82ef0be2f0d84273ada55d912f119d91f5e5d src/vs/platform/configuration/common/configurationRegistry.ts
@@ -5,7 +5,11 @@
 'use strict';
 
 import * as nls from 'vs/nls';
+<<<<<<< .our
 import { Event, Emitter } from 'vs/base/common/event';
+=======
+import Event, { Emitter } from 'vs/base/common/event';
+>>>>>>> .their
 import { IJSONSchema } from 'vs/base/common/jsonSchema';
 import { Registry } from 'vs/platform/registry/common/platform';
 import * as types from 'vs/base/common/types';
changed in both
  base   100644 594a6eb52871a2f426630f8cbeba77130da189b2 src/vs/platform/configuration/test/node/configurationService.test.ts
  our    100644 2a03ed6f1533bdff7c2594ca33f1b37d92334a4c src/vs/platform/configuration/test/node/configurationService.test.ts
  their  100644 58b546fba728fb8fd769ad58602b59983a97d04a src/vs/platform/configuration/test/node/configurationService.test.ts
@@ -15,6 +15,10 @@
 import { ParsedArgs } from 'vs/platform/environment/common/environment';
 import { parseArgs } from 'vs/platform/environment/node/argv';
 import { EnvironmentService } from 'vs/platform/environment/node/environmentService';
+<<<<<<< .our
+=======
+import * as extfs from 'vs/base/node/extfs';
+>>>>>>> .their
 import * as uuid from 'vs/base/common/uuid';
 import { IConfigurationRegistry, Extensions as ConfigurationExtensions } from 'vs/platform/configuration/common/configurationRegistry';
 import { testFile } from 'vs/base/test/node/utils';
changed in both
  base   100644 e019353ebcec5f82897d5a19c483b6b431593ed3 src/vs/platform/extensionManagement/node/extensionManagementService.ts
  our    100644 fca1b8fcc1eedca233bd95ef59ad6d0d3904e895 src/vs/platform/extensionManagement/node/extensionManagementService.ts
  their  100644 96ec0d7ab578c0e7167a922508ab51f4b965fdda src/vs/platform/extensionManagement/node/extensionManagementService.ts
@@ -30,6 +30,7 @@
 import { Event, Emitter } from 'vs/base/common/event';
 import * as semver from 'semver';
 import URI from 'vs/base/common/uri';
+<<<<<<< .our
 import pkg from 'vs/platform/node/package';
 import { isMacintosh, isWindows } from 'vs/base/common/platform';
 import { ILogService } from 'vs/platform/log/common/log';
@@ -62,6 +63,12 @@
 		super(message);
 	}
 }
+=======
+import { IChoiceService } from 'vs/platform/message/common/message';
+import Severity from 'vs/base/common/severity';
+
+const SystemExtensionsRoot = path.normalize(path.join(URI.parse(require.toUrl('')).fsPath, '..', 'extensions'));
+>>>>>>> .their
 
 function parseManifest(raw: string): TPromise<{ manifest: IExtensionManifest; metadata: IGalleryMetadata; }> {
 	return new TPromise((c, e) => {
changed in both
  base   100644 455db1408ecef7f6774a15b2b85710c28cd21749 src/vs/platform/files/common/files.ts
  our    100644 72b73ed86d2a2250bc747d5e4821c82038379d3b src/vs/platform/files/common/files.ts
  their  100644 fdf49c32bc97fcc6661561242fd6a5880267a425 src/vs/platform/files/common/files.ts
@@ -8,6 +8,10 @@
 import * as paths from 'vs/base/common/paths';
 import URI from 'vs/base/common/uri';
 import * as glob from 'vs/base/common/glob';
+<<<<<<< .our
+=======
+import * as events from 'vs/base/common/events';
+>>>>>>> .their
 import { isLinux } from 'vs/base/common/platform';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { Event } from 'vs/base/common/event';
changed in both
  base   100644 21234877c10df52286ccc947eae86fe3bb83047c src/vs/platform/instantiation/test/common/instantiationService.test.ts
  our    100644 db042a9cc4ffc87fcd6a942dabac732cff408a3e src/vs/platform/instantiation/test/common/instantiationService.test.ts
  their  100644 28b8056982e6d5557d16f7fcdeacbaa84c6de74d src/vs/platform/instantiation/test/common/instantiationService.test.ts
changed in both
  base   100644 5d4f91c0dff10502bd2cbd821a50d3cc87f467ec src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts
  our    100644 4b89524ac9f9d6105d5e410d5b74245e3d7b0b6c src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts
  their  100644 c5336744ea5b75f3c0450c47a82b66b9e58358a7 src/vs/platform/jsonschemas/common/jsonContributionRegistry.ts
@@ -6,7 +6,12 @@
 
 import { IJSONSchema } from 'vs/base/common/jsonSchema';
 import * as platform from 'vs/platform/registry/common/platform';
+<<<<<<< .our
 import { Event, Emitter } from 'vs/base/common/event';
+=======
+import { EventEmitter } from 'vs/base/common/eventEmitter';
+import { IDisposable } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 
 export const Extensions = {
 	JSONContribution: 'base.contributions.json'
removed in local
  base   100644 748d7a37ba156df32bec17833af3824025477a96 src/vs/platform/jsonschemas/common/jsonValidationExtensionPoint.ts
  their  100644 4f835bd874be79ee3ee792621ecf5181496a7f80 src/vs/platform/jsonschemas/common/jsonValidationExtensionPoint.ts
changed in both
  base   100644 abdd2247405f2ff315ae736e56b7644297e5dd6a src/vs/platform/markers/test/common/markerService.test.ts
  our    100644 25cb2e933a2be12aa3b8b474b9365c80ff77bb4d src/vs/platform/markers/test/common/markerService.test.ts
  their  100644 4ca4cde415c06a7f5b07fe80d6834808823701d4 src/vs/platform/markers/test/common/markerService.test.ts
@@ -8,7 +8,11 @@
 import * as assert from 'assert';
 import URI from 'vs/base/common/uri';
 import * as markerService from 'vs/platform/markers/common/markerService';
+<<<<<<< .our
 import { IMarkerData, MarkerSeverity } from 'vs/platform/markers/common/markers';
+=======
+import { IMarkerData } from 'vs/platform/markers/common/markers';
+>>>>>>> .their
 
 function randomMarkerData(severity = MarkerSeverity.Error): IMarkerData {
 	return {
removed in local
  base   100644 627bbe0900b0f5c9aef6212e85c6efea0889149e src/vs/platform/message/common/message.ts
  their  100644 4eb6b351fdab966548d628d8a1096528e2e1b8f7 src/vs/platform/message/common/message.ts
removed in local
  base   100644 069ca25321df5ec6bc45a8ef1f2fe20a0a6f66af src/vs/platform/message/common/messageIpc.ts
  their  100644 c62572a11f8facdb29e49d1a4242e8bd11d4ada2 src/vs/platform/message/common/messageIpc.ts
removed in local
  base   100644 846261e957482ae5712f4afef39244fa543c833c src/vs/platform/message/node/messageCli.ts
  their  100644 5302ef533e22f916b730edd7c19ce673ee25a297 src/vs/platform/message/node/messageCli.ts
changed in both
  base   100644 5ddc3f336bc0f95bcf81ae82126d49c81d64e4c2 src/vs/platform/registry/common/platform.ts
  our    100644 db2569b9bd3f326db2bd920b788dd6fae547edb2 src/vs/platform/registry/common/platform.ts
  their  100644 ce502207c23fde9f29a4062228e2b7af0eea2720 src/vs/platform/registry/common/platform.ts
@@ -6,6 +6,10 @@
 
 import * as Types from 'vs/base/common/types';
 import * as Assert from 'vs/base/common/assert';
+<<<<<<< .our
+=======
+import { IInstantiationService, IConstructorSignature0 } from 'vs/platform/instantiation/common/instantiation';
+>>>>>>> .their
 
 export interface IRegistry {
 
changed in both
  base   100644 4a26fd2eb363fcb1082f2d19ba7a4e32897ff04e src/vs/platform/registry/test/common/platform.test.ts
  our    100644 d3e653af565764ca6fa5d456590e9c2c114c6cc0 src/vs/platform/registry/test/common/platform.test.ts
  their  100644 158b418346812d701b0abd41d5a53c87545e12a0 src/vs/platform/registry/test/common/platform.test.ts
changed in both
  base   100644 199ba0c9dcf17e0c23177a37b23c3e39045c3642 src/vs/platform/storage/common/storageService.ts
  our    100644 cd60f29cd2e18e562c5c4d0c446ca1c079822aea src/vs/platform/storage/common/storageService.ts
  their  100644 b2ea4e5e578962b8b69ef833f3b64df866a9a8c5 src/vs/platform/storage/common/storageService.ts
changed in both
  base   100644 5bf022e190c15120b8ef5dbb91d5ec818a1739b1 src/vs/platform/telemetry/browser/errorTelemetry.ts
  our    100644 ec06e2c07eef85a9dbde991083fba2510c62b26e src/vs/platform/telemetry/browser/errorTelemetry.ts
  their  100644 3a811fe2834c838a11e67571e54c102c9179f990 src/vs/platform/telemetry/browser/errorTelemetry.ts
changed in both
  base   100644 d1c8b3db1563c33fc4a0208c2f594851a45aca10 src/vs/platform/telemetry/common/telemetryUtils.ts
  our    100644 83a4326ca5e511e1b955212a7929341083ae29ff src/vs/platform/telemetry/common/telemetryUtils.ts
  their  100644 527ffda07f87b53d8d5d50e1429554a676af3bb6 src/vs/platform/telemetry/common/telemetryUtils.ts
changed in both
  base   100644 494159a5f564e0c88f21d718e4dd179d483eff2e src/vs/platform/telemetry/test/electron-browser/telemetryService.test.ts
  our    100644 8cd91f0803bf07a93c03212bd1183b3d09b5419f src/vs/platform/telemetry/test/electron-browser/telemetryService.test.ts
  their  100644 f02f2f19841a36c5dddf9753436774cde0bc4cb9 src/vs/platform/telemetry/test/electron-browser/telemetryService.test.ts
removed in local
  base   100644 f42ffb926a309b6f0f4df13edfb534883e35e581 src/vs/platform/theme/common/colorExtensionPoint.ts
  their  100644 6c79c0ef896119cd27239e0330f7f1eb10fffe31 src/vs/platform/theme/common/colorExtensionPoint.ts
changed in both
  base   100644 0d21ee0e7a9caf1febef5c320519012dc557e21d src/vs/platform/theme/common/colorRegistry.ts
  our    100644 674f67411d4ee542ee937fac9146ef0768ec982d src/vs/platform/theme/common/colorRegistry.ts
  their  100644 80683cc51b20db99d5e6521698bcfe3e4ad484c1 src/vs/platform/theme/common/colorRegistry.ts
changed in both
  base   100644 1ae17c0ac90d52f4857f96a634226b4bca2e0744 src/vs/platform/theme/common/themeService.ts
  our    100644 7c1e2f9bae64abc3e50a713fddc1308d4989648c src/vs/platform/theme/common/themeService.ts
  their  100644 e61baef43c9d073700b6c98114f2acb38a0a29b5 src/vs/platform/theme/common/themeService.ts
@@ -6,7 +6,11 @@
 
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
 import { Color } from 'vs/base/common/color';
+<<<<<<< .our
 import { IDisposable, toDisposable } from 'vs/base/common/lifecycle';
+=======
+import { IDisposable } from 'vs/base/common/lifecycle';
+>>>>>>> .their
 import * as platform from 'vs/platform/registry/common/platform';
 import { ColorIdentifier } from 'vs/platform/theme/common/colorRegistry';
 import { Event, Emitter } from 'vs/base/common/event';
changed in both
  base   100644 ec0683890ca84792f6e8f0be0298ca3f9a56710b src/vs/platform/workspaces/test/electron-main/workspacesMainService.test.ts
  our    100644 b49fa1f295e8bc18af9f9fb9b3975f7eda229d64 src/vs/platform/workspaces/test/electron-main/workspacesMainService.test.ts
  their  100644 4fdb55ad4f088080b81220cc7d6622224702d9af src/vs/platform/workspaces/test/electron-main/workspacesMainService.test.ts
